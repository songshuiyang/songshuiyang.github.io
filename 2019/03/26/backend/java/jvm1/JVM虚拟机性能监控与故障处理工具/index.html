<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>JVM虚拟机性能监控与故障处理工具 | 宋水阳个人博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#3F51B5"><meta name="keywords" content="java,jvm"><meta name="description" content="JDK的命令行工具jcmd 综合工具 jcmd -l  列出当前运行的所有虚拟机 1235362 sun.tools.jcmd.JCmd -l1236 /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=9080 --debug"><meta name="keywords" content="java,jvm"><meta property="og:type" content="article"><meta property="og:title" content="JVM虚拟机性能监控与故障处理工具"><meta property="og:url" content="http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/index.html"><meta property="og:site_name" content="宋水阳个人博客"><meta property="og:description" content="JDK的命令行工具jcmd 综合工具 jcmd -l  列出当前运行的所有虚拟机 1235362 sun.tools.jcmd.JCmd -l1236 /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=9080 --debug"><meta property="og:locale" content="default"><meta property="og:image" content="http://www.songshuiyang.site/images/server/java/JVM/jstat.jpg"><meta property="og:updated_time" content="2019-03-26T12:32:55.245Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM虚拟机性能监控与故障处理工具"><meta name="twitter:description" content="JDK的命令行工具jcmd 综合工具 jcmd -l  列出当前运行的所有虚拟机 1235362 sun.tools.jcmd.JCmd -l1236 /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=9080 --debug"><meta name="twitter:image" content="http://www.songshuiyang.site/images/server/java/JVM/jstat.jpg"><link rel="alternate" type="application/atom+xml" title="宋水阳个人博客" href="/atom.xml"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="/css/style.css?v=1.7.2"><script>window.lazyScripts=[]</script></head><body><div id="loading" class="active"></div><aside id="menu"><div class="inner flex-row-vertical"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off"><i class="icon icon-lg icon-close"></i></a><div class="brand-wrap" style="background-image:url(/img/brand.jpg)"><div class="brand"> <a href="/" class="avatar waves-effect waves-circle waves-light"><img src="/img/avatar.jpg"></a><hgroup class="introduce"><h5 class="nickname">songshuiyang</h5> <a href="mailto:songshuiyang@foxmail.com" title="songshuiyang@foxmail.com" class="mail">songshuiyang@foxmail.com</a></hgroup></div></div><div class="scroll-wrap flex-col"><ul class="nav"><li class="waves-block waves-effect"><a href="/"><i class="icon icon-lg icon-home"></i> 主页</a></li><li class="waves-block waves-effect"><a href="/archives"><i class="icon icon-lg icon-archives"></i> 归档</a></li><li class="waves-block waves-effect"><a href="/categories"><i class="icon icon-lg icon-th-list"></i> 分类</a></li><li class="waves-block waves-effect"><a href="/tags"><i class="icon icon-lg icon-tags"></i> 标签</a></li><li class="waves-block waves-effect"><a href="https://github.com/songshuiyang" target="_blank"><i class="icon icon-lg icon-github"></i> Github</a></li></ul></div></div></aside><main id="main"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ac93934d9b847216e10a2f133187e535";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><header class="top-header" id="header"><div class="flex-row"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle"><i class="icon icon-lg icon-navicon"></i></a><div class="flex-col header-title ellipsis">JVM虚拟机性能监控与故障处理工具</div><div class="search-wrap" id="search-wrap"><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back"><i class="icon icon-lg icon-chevron-left"></i></a> <input type="text" id="key" class="search-input" autocomplete="off" placeholder=""><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search"><i class="icon icon-lg icon-search"></i></a></div><a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare"><i class="icon icon-lg icon-share-alt"></i></a></div></header><header class="content-header post-header"><div class="container fade-scale"><h1 class="title">JVM虚拟机性能监控与故障处理工具</h1><h5 class="subtitle"> <time datetime="2019-03-26T13:59:44.000Z" itemprop="datePublished" class="page-time">2019-03-26</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/服务器/">服务器</a></li></ul></h5></div></header><div class="container body-wrap"><aside class="post-widget"><nav class="post-toc-wrap post-toc-shrink" id="post-toc"><h4>TOC</h4><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JDK的命令行工具"><span class="post-toc-number">1.</span> <span class="post-toc-text">JDK的命令行工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jcmd-综合工具"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">jcmd 综合工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jps-虚拟机进程状况工具"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">jps 虚拟机进程状况工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jinfo-配置信息工具"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">jinfo 配置信息工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jstat：虚拟机统计信息监视工具"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">jstat：虚拟机统计信息监视工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jmap：Java内存映像工具"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">jmap：Java内存映像工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jhat：虚拟机堆转储快照分析工具"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">jhat：虚拟机堆转储快照分析工具</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#jstack：Java堆栈跟踪工具"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">jstack：Java堆栈跟踪工具</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#JDK的可视化工具"><span class="post-toc-number">2.</span> <span class="post-toc-text">JDK的可视化工具</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考转载"><span class="post-toc-number">3.</span> <span class="post-toc-text">参考转载</span></a></li></ol></nav></aside><article id="post-backend/java/jvm1/JVM虚拟机性能监控与故障处理工具" class="post-article article-type-post fade" itemprop="blogPost"><div class="post-card"><h1 class="post-card-title">JVM虚拟机性能监控与故障处理工具</h1><div class="post-meta"> <time class="post-time" title="2019-03-26 21:59:44" datetime="2019-03-26T13:59:44.000Z" itemprop="datePublished">2019-03-26</time><ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/服务器/">服务器</a></li></ul><span id="busuanzi_container_site_pv"><i class="icon icon-eye icon-pr"></i> 本页总访问量<span id="busuanzi_value_page_pv"></span>次</span></div><div class="post-content" id="post-content" itemprop="postContent"><h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><h3 id="jcmd-综合工具"><a href="#jcmd-综合工具" class="headerlink" title="jcmd 综合工具"></a>jcmd 综合工具</h3><ul><li><p><code>jcmd -l</code> 列出当前运行的所有虚拟机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5362</span> sun.tools.jcmd.JCmd -l</span><br><span class="line"><span class="number">1236</span> /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=<span class="number">9080</span> --debug=<span class="number">5</span> --handlerCountMax=<span class="number">100</span> --handlerCountMaxIdle=<span class="number">20</span></span><br><span class="line"><span class="number">7167</span> org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure></li><li><p><code>jcmd [pid] VM.uptime</code> 查看虚拟机启动时间VM.uptime</p></li><li><code>jcmd [pid] Thread.print</code> 打印线程栈信息Thread.print</li><li><code>jcmd [pid] GC.class_histogram</code> 查看系统中类统计信息GC.class_histogram</li><li><code>jcmd [pid] GC.heap_dump [filepath&amp;name]</code> 导出堆信息GC.heap_dump 这个命令功能和 jmap -dump 功能一样</li><li><code>jcmd [pid] VM.system_properties</code> 获取系统Properties内容VM.system_properties</li><li><code>jcmd [pid] VM.flags</code> 获取启动参数VM.flags</li><li><code>jcmd [pid] PerfCounter.print</code> 获取所有性能相关数据PerfCounter.print<h3 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps 虚拟机进程状况工具"></a>jps 虚拟机进程状况工具</h3></li><li>jps（JVM Process Status Tool）可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。虽然功能比较单一，但它是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier,PID）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。</li><li><p>命令格式，其中[option]、[hostid]参数也可以不写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-l : 输出主类全名或jar路径</span><br><span class="line">    •-q : 只输出LVMID</span><br><span class="line">    •-m : 输出JVM启动时传递给main()的参数</span><br><span class="line">    •-v : 输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line"></span><br><span class="line">15232 org.gradle.launcher.daemon.bootstrap.GradleDaemon</span><br><span class="line">3104 sun.tools.jps.Jps</span><br><span class="line">6784 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">8916 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">15976</span><br><span class="line">8936 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">11580 com.songsy.iframe.Application</span><br></pre></td></tr></table></figure></li></ul><h3 id="jinfo-配置信息工具"><a href="#jinfo-配置信息工具" class="headerlink" title="jinfo 配置信息工具"></a>jinfo 配置信息工具</h3><ul><li><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p></li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] [args] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-flag : 输出指定args参数的值</span><br><span class="line">    •-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">    •-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags <span class="number">11580</span></span><br><span class="line"></span><br><span class="line">Attaching to process ID <span class="number">11580</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.121</span>-b13</span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=<span class="number">3</span> -XX:InitialHeapSize=<span class="number">134217728</span> -XX:+ManagementServer -XX:MaxHeapSize=<span class="number">2118123520</span> -XX:MaxNewSize=<span class="number">705691648</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">44564480</span> -XX:OldSize=<span class="number">89653248</span> -XX:TieredStopAtLevel=<span class="number">1</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">Command line:  -agentlib:jdwp=transport=dt_socket,address=<span class="number">127.0</span>.0.1:<span class="number">58771</span>,suspend=y,server=n -XX:TieredStopAtLevel=<span class="number">1</span> -Xverify:none -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=<span class="number">58770</span> -Dcom.sun.management.jmxremote.authenticate=<span class="keyword">false</span> -Dcom.sun.management.jmxremote.ssl=<span class="keyword">false</span> -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=<span class="keyword">true</span> -javaagent:C:\Users\asua\.IntelliJIdea2017.2\system\groovyHotSwap\gragent.jar -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><ul><li>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li><p>命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">    •[option] : 操作参数</span><br><span class="line">    •LVMID : 本地虚拟机进程ID</span><br><span class="line">    •[interval] : 连续输出的时间间隔</span><br><span class="line">    •[count] : 连续输出的次数</span><br><span class="line">    </span><br><span class="line">对于命令格式中的VMID与LVMID需要特别说明一下：</span><br><span class="line">如果是本地虚拟机进程，VMID与LVMID是一致的;</span><br><span class="line">如果是远程虚拟机进程，那VMID的格式应当是：protocol://lvmid@hostname:port/servername</span><br><span class="line">参数interval和count代表查询间隔(单位毫秒)和次数，如果省略这两个参数，说明只查询一次。</span><br><span class="line">假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure></li><li><p>选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考表4-3中的描述。</p></li></ul><figure class="image-bubble"><div class="img-lightbox"><div class="overlay"></div> <img src="/images/server/java/JVM/jstat.jpg" alt="" title=""></div><div class="image-caption"></div></figure><ul><li><code>option</code>参数详解<blockquote><p><code>jstat -class</code>监视类装载、卸载数量、总空间以及耗费的时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -class 11580</span><br><span class="line"></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line">  7107 13135.3        0     0.0       6.84</span><br><span class="line"></span><br><span class="line">•Loaded : 加载class的数量</span><br><span class="line">•Bytes : class字节大小</span><br><span class="line">•Unloaded : 未加载class的数量</span><br><span class="line">•Bytes : 未加载class的字节大小</span><br><span class="line">•Time : 加载时间</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p><code>jstat -compiler</code>输出JIT编译过的方法数量耗时等<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -compiler  11580</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    4079      3       0     1.62          1 org/springframework/beans/CachedIntrospectionResults &lt;init&gt;</span><br><span class="line"></span><br><span class="line">•Compiled : 编译数量</span><br><span class="line">•Failed : 编译失败数量</span><br><span class="line">•Invalid : 无效数量</span><br><span class="line">•Time : 编译耗时</span><br><span class="line">•FailedType : 失败类型</span><br><span class="line">•FailedMethod : 失败方法的全限定名</span><br></pre></td></tr></table></figure><p></p><p><code>jstat -gc</code> 垃圾回收堆的行为统计<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc  11580</span><br><span class="line"> S0C    S1C      S0U    S1U      EC       EU        OC         OU       MC      MU      CCSC    CCSU    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">39424.0 29696.0  0.0    0.0      414208.0 353447.8  118272.0   46473.8  35072.0 34285.7 4608.0  4457.1  9       0.233   2      0.149    0.382</span><br><span class="line"></span><br><span class="line">•S0C : survivor0区的总容量</span><br><span class="line">•S1C : survivor1区的总容量</span><br><span class="line">•S0U : survivor0区已使用的容量</span><br><span class="line">•S1C : survivor1区已使用的容量</span><br><span class="line">•EC : Eden区的总容量</span><br><span class="line">•EU : Eden区已使用的容量</span><br><span class="line">•OC : Old区的总容量</span><br><span class="line">•OU : Old区已使用的容量</span><br><span class="line">•PC 当前perm的容量 (KB)</span><br><span class="line">•PU perm的使用 (KB)</span><br><span class="line">•YGC : 新生代垃圾回收次数</span><br><span class="line">•YGCT : 新生代垃圾回收时间</span><br><span class="line">•FGC : 老年代垃圾回收次数</span><br><span class="line">•FGCT : 老年代垃圾回收时间</span><br><span class="line">•GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure><p></p><p><code>jstat -gccapacity</code>同-gc，不过还会输出Java堆各区域使用到的最大、最小空间<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccapacity  11580</span><br><span class="line"> NGCMN    NGCMX     NGC      S0C     S1C       EC          OGCMN      OGCMX       OGC        OC            MCMN      MCMX         MC          CCSMN   CCSMX       CCSC    YGC    FGC</span><br><span class="line"> 43520.0  689152.0  689152.0 39424.0 29696.0   414208.0    87552.0    1379328.0   118272.0   118272.0      0.0       1079296.0    35072.0      0.0    1048576.0   4608.0  9      2</span><br><span class="line"> </span><br><span class="line">•NGCMN : 新生代占用的最小空间</span><br><span class="line">•NGCMX : 新生代占用的最大空间</span><br><span class="line">•OGCMN : 老年代占用的最小空间</span><br><span class="line">•OGCMX : 老年代占用的最大空间</span><br><span class="line">•OGC：当前年老代的容量 (KB)</span><br><span class="line">•OC：当前年老代的空间 (KB)</span><br><span class="line">•PGCMN : perm占用的最小空间</span><br><span class="line">•PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure><p></p><p><code>jstat -gcutil</code> 同-gc，不过输出的是已使用空间占总空间的百分比<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0     S1     E      O      M      CCS       YGC     YGCT      FGC    FGCT     GCT</span><br><span class="line">0.00   0.00  85.33   39.29  97.76  96.73      9      0.233     2      0.149    0.382</span><br></pre></td></tr></table></figure><p></p><p><code>jstat -gccause</code> 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccause  11580</span><br><span class="line">  S0     S1    E      O      M      CCS    YGC  YGCT     FGC  FGCT     GCT    LGCC                 GCC</span><br><span class="line">  0.00   0.00  85.33  39.29  97.76  96.73  9    0.233    2    0.149    0.382  Allocation Failure   No GC</span><br><span class="line"></span><br><span class="line">•LGCC：最近垃圾回收的原因</span><br><span class="line">•GCC：当前垃圾回收的原因</span><br></pre></td></tr></table></figure><p></p><p><code>jstat -gcnew</code> 统计新生代的行为<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnew  11580</span><br><span class="line"> S0C    S1C      S0U    S1U  TT  MTT  DSS      EC       EU            YGC     YGCT</span><br><span class="line">39424.0 29696.0  0.0    0.0  2   15   39424.0  414208.0 353447.8      9       0.233</span><br></pre></td></tr></table></figure><p></p><p><code>jstat -gcnewcapacity</code> 新生代与其相应的内存空间的统计<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnewcapacity  11580</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   43520.0   689152.0   689152.0 229376.0  39424.0 229376.0  29696.0   688128.0   414208.0     9     2</span><br><span class="line"></span><br><span class="line">•NGC:当前年轻代的容量 (KB)</span><br><span class="line">•S0CMX:最大的S0空间 (KB)</span><br><span class="line">•S0C:当前S0空间 (KB)</span><br><span class="line">•ECMX:最大eden空间 (KB)</span><br><span class="line">•EC:当前eden空间 (KB)</span><br></pre></td></tr></table></figure><p></p></blockquote><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><ul><li>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。</li><li>如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如加-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。</li><li>jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。</li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •dump : 生成堆转储快照，格式为:-dump:[live, ] format=b,file=&lt;filename&gt;,其中live子参数说明是否只dump出存活的对象。</span><br><span class="line">    •finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">    •heap : 显示Java堆详细信息</span><br><span class="line">    •histo : 显示堆中对象的统计信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</span><br><span class="line">    •permstat : to print permanent generation statistics</span><br><span class="line">    •F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 28920</span><br><span class="line"></span><br><span class="line">Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01  </span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC with 4 thread(s)                //GC 方式  </span><br><span class="line">  Heap Configuration:                         //堆内存初始化配置</span><br><span class="line">     MinHeapFreeRatio = 0                     //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">     MaxHeapFreeRatio = 100                   //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">     NewSize          = 1310720 (1.25MB)      //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">     MaxNewSize       = 17592186044415 MB     //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">     OldSize          = 5439488 (5.1875MB)    //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">     NewRatio         = 2                     //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">     SurvivorRatio    = 8                     //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">     PermSize         = 21757952 (20.75MB)    //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">     MaxPermSize      = 85983232 (82.0MB)     //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">     G1HeapRegionSize = 0 (0.0MB)  </span><br><span class="line">  Heap Usage:                                 //堆内存使用情况</span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space:                                 //Eden区内存分布</span><br><span class="line">     capacity = 33030144 (31.5MB)             //Eden区总容量</span><br><span class="line">     used     = 1524040 (1.4534378051757812MB)//Eden区已使用</span><br><span class="line">     free     = 31506104 (30.04656219482422MB)//Eden区剩余容量</span><br><span class="line">     4.614088270399305% used                  //Eden区使用比率</span><br><span class="line">  From Space:                                 //其中一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  To Space:                                   //另一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Old Generation                           //当前的Old区内存分布</span><br><span class="line">     capacity = 86507520 (82.5MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 86507520 (82.5MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Perm Generation                          //当前的 “永生代” 内存分布</span><br><span class="line">     capacity = 22020096 (21.0MB)</span><br><span class="line">     used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">     free     = 19523568 (18.619125366210938MB)</span><br><span class="line">     11.337498256138392% used  </span><br><span class="line">interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>jmap -histo:live 28920 | more 打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">num     #instances         #bytes  class name</span><br><span class="line"><span class="comment">----------------------------------------------</span></span><br><span class="line">   1:         83613       12012248  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         23868       11450280  [B</span><br><span class="line">   3:         83613       10716064  &lt;methodKlass&gt;</span><br><span class="line">   4:         76287       10412128  [C</span><br><span class="line">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         73627        1767048  java.lang.String</span><br><span class="line">   9:          2260        1348848  &lt;methodDataKlass&gt;</span><br><span class="line">  10:          8856         849296  java.lang.Class</span><br><span class="line">  </span><br><span class="line">class name是对象类型，说明如下：</span><br><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure><p></p></blockquote><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><ul><li><p>jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。</p></li><li><p>不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器。二是用于分析的机器一般也是服务器，由于加载dump快照文件需要比生成dump更大的内存，所以一般在64位JDK、大内存的服务器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。</p></li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    jhat [option] [dumpfile]</span><br><span class="line">参数</span><br><span class="line">    •-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line">    •-refs <span class="literal">false</span>|<span class="literal">true</span> 关闭对象引用跟踪(<span class="keyword">tracking</span> <span class="keyword">of</span> <span class="keyword">references</span> <span class="keyword">to</span> objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers <span class="keyword">or</span> incoming <span class="keyword">references</span>), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line">    •-port port-<span class="built_in">number</span> 设置 jhat <span class="keyword">HTTP</span> <span class="keyword">server</span> 的端口号. 默认值 <span class="number">7000.</span>&gt; </span><br><span class="line">    •-<span class="keyword">exclude</span> <span class="keyword">exclude</span>-<span class="keyword">file</span> 指定对象查询时需要排除的数据成员列表文件(a <span class="keyword">file</span> that lists <span class="keyword">data</span> members that should be excluded <span class="keyword">from</span> the reachable objects <span class="keyword">query</span>)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 <span class="keyword">Object</span> o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line">    •-baseline <span class="keyword">exclude</span>-<span class="keyword">file</span> 指定一个基准堆转储(baseline <span class="keyword">heap</span> dump)。 在两个 <span class="keyword">heap</span> dumps 中有相同 <span class="keyword">object</span> <span class="keyword">ID</span> 的对象会被标记为不是新的(marked <span class="keyword">as</span> <span class="keyword">not</span> being <span class="keyword">new</span>). 其他对象被标记为新的(<span class="keyword">new</span>). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line">    •-debug <span class="built_in">int</span> 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line">    •-<span class="keyword">version</span> 启动后只显示版本信息就退出&gt;</span><br><span class="line">    •-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的<span class="keyword">Java</span>虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ~ jhat eclipse.bin </span><br><span class="line">Reading from eclipse.bin...</span><br><span class="line">Dump file created Mon Oct 31 19:32:57 CST 2016</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 185857 objects...</span><br><span class="line">Chasing references, expect 37 dots.....................................</span><br><span class="line">Eliminating duplicate references.....................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br><span class="line"></span><br><span class="line">屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost:7000/就可以看到分析结果.</span><br><span class="line">分析结果默认是以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的“Heap Histogram”（与jmap -histo功能一样）与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计.</span><br></pre></td></tr></table></figure></li></ul><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><ul><li>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</li><li>命令格式<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">    •-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">    •-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure></li></ul><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版 《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/wade-luffy/p/6017137.html" target="_blank" rel="noopener">https://www.cnblogs.com/wade-luffy/p/6017137.html</a></li></ul></div><blockquote class="post-copyright"><footer> <a href="http://www.songshuiyang.site"><img src="/img/avatar.jpg" alt="songshuiyang"> songshuiyang</a></footer></blockquote><div class="post-footer"><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul><div class="page-share-wrap"><div class="page-share" id="pageShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/&title=《JVM虚拟机性能监控与故障处理工具》 — 宋水阳个人博客&pic=http://www.songshuiyang.site/img/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/&title=《JVM虚拟机性能监控与故障处理工具》 — 宋水阳个人博客&source=" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM虚拟机性能监控与故障处理工具》 — 宋水阳个人博客&url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/&via=http://www.songshuiyang.site" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle"><i class="icon icon-share-alt icon-lg"></i></a></div></div></div><nav class="post-nav flex-row flex-justify-between"><div class="waves-block waves-effect prev"><a href="/2019/03/26/backend/java/jvm1/JVM堆转储文件分析EclipseMemoryAnalyzer/" id="post-prev" class="post-nav-link"><div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div><h4 class="title">JVM堆转储文件分析EclipseMemoryAnalyzer</h4></a></div><div class="waves-block waves-effect next"><a href="/2019/03/21/backend/java/jvm1/JVM内存模型与线程(一)Java内存模型/" id="post-next" class="post-nav-link"><div class="tips">Next<i class="icon icon-angle-right icon-lg icon-pl"></i></div><h4 class="title">JVM内存模型与线程(一)Java内存模型</h4></a></div></nav><div class="comments vcomment" id="comments"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var GUEST_INFO=["nick","mail","link"],guest_info="nick,mail,link".split(",").filter(function(e){return-1<GUEST_INFO.indexOf(e)});new Valine({el:"#comments",notify:!1,verify:!1,appId:"tFSCtBMsjdDCJmCEKGvMlHLh-gzGzoHsz",appKey:"wDUxU3I7OcPPuDDwMSe5Ochu",avatar:"robohash",placeholder:"少侠不吐槽吐槽?",guest_info:0==guest_info.length?GUEST_INFO:guest_info,pageSize:"10"})</script></article></div><footer class="footer"><div class="bottom"><p><span>songshuiyang &copy; 2017 - 2019</span> <span><a href="http://www.miitbeian.gov.cn/" target="_blank">赣ICP备18001541号</a><br></span> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></p></div></footer></main><div class="mask" id="mask"></div><a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a><div class="global-share" id="globalShare"><ul class="reset share-icons"><li><a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/&title=《JVM虚拟机性能监控与故障处理工具》 — 宋水阳个人博客&pic=http://www.songshuiyang.site/img/avatar.jpg" data-title="微博"><i class="icon icon-weibo"></i></a></li><li><a class="weixin share-sns wxFab" href="javascript:;" data-title="微信"><i class="icon icon-weixin"></i></a></li><li><a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/&title=《JVM虚拟机性能监控与故障处理工具》 — 宋水阳个人博客&source=" data-title=" QQ"><i class="icon icon-qq"></i></a></li><li><a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/" data-title=" Facebook"><i class="icon icon-facebook"></i></a></li><li><a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《JVM虚拟机性能监控与故障处理工具》 — 宋水阳个人博客&url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/&via=http://www.songshuiyang.site" data-title=" Twitter"><i class="icon icon-twitter"></i></a></li><li><a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/" data-title=" Google+"><i class="icon icon-google-plus"></i></a></li></ul></div><div class="page-modal wx-share" id="wxShare"><a class="close" href="javascript:;"><i class="icon icon-close"></i></a><p>扫一扫，分享到微信</p> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADOElEQVR42u3ay46jQBAEQP//T3ulPc3BWJnVIJkmOI08s0D0HtL1eL3i6/3/+vvz309mnx/d/+jffr//64oLGxsb+ybs99fr6Nb53xw9JT/oo7slTzl8IjY2NvZ27CS02lj6Ds4/T5C5BRsbG/vJ7PVH5uVE/gk2NjY29izA2pKgLX5mx4GNjY39ZHZSALQjgaTkyCOqfc/TemnY2NjYP8+eDXp/8+fL59vY2NjYP8Z+j66V5n7bbGpXgqL3x8bGxt6I3Y5sZxmRL9bkA+b2icUpYmNjY9+Q3bZ12kb8eoy1ra42SrGxsbF3YreNpDZa2rHubORw+UgAGxsb+4fZbfNoFnIrYZk3lYqDwMbGxr45u42TNh7ydZ+82XTheAAbGxv7VuxZE+es0Dp3uFus8mBjY2NvxG4bSW2LvyXljFkcYmNjY+/HXvmin/xle6Ar5Uoet9jY2Nj7sZOv7GcF2MrAuB0tHL4zNjY29kbsK/ZY8tjLD7EdM+Sxio2Njb0He9hSX46WWbFxWvRiY2Njb8FOQuW9fOXFxmxZJx8tfOilYWNjY9+cvb4i03Zp8gOareMMG1XY2NjYt2W3rZ/8OFbaSVf0zA4HvdjY2NhbsPOISo5gNkho13pmTSVsbGzs/dizNs0sSBJGezRJ0VJUYNjY2Ng3ZLft9ZXCoB3ozgIyCkVsbGzsjdhnFQBtiz8PuXyMUQ96sbGxsbdg5w8+6+XyZZo2SvPiChsbG3sndr522S705M2p9iDyOIwKJ2xsbOybs9somq1UtseUH0RbomBjY2Pvx559fZ+VJbOwbA+rLYqwsbGxd2LPQqJt9yRx1ZY3KyUKNjY29n7sdimnXdDJR8srBdIrv7CxsbE3Yifh1P52BsiPO/+PLNIbGxsb+1bsWYt/FmwrI4c2PotNJWxsbOybs88qVNrGfTtyaNd9Vlpm2NjY2HdkzwqJ5PGzRtIsCNugxcbGxt6PnS/utC89C8gE1q7pfAgwbGxs7EeyV4qT2QhhPbo+3AEbGxv7key8YVSUBKPBQHtk2NjY2E9gt0s5bWs+Ly3aNlP7ztjY2Nj7sVeaPivrMrNhcMtbwmNjY2P/Ovsf9sz9YbyhVnsAAAAASUVORK5CYII=" alt="微信分享二维码"></div><script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script><script>var BLOG={ROOT:"/",SHARE:!0,REWARD:!1};lazyScripts.push("//s95.cnzz.com/z_stat.php?id=1275444015&web_id=1275444015")</script><script src="/js/main.min.js?v=1.7.2"></script><div class="search-panel" id="search-panel"><ul class="search-result" id="search-result"></ul></div><template id="search-tpl"><li class="item"><a href="{path}" class="waves-block waves-effect"><div class="title ellipsis" title="{title}">{title}</div><div class="flex-row flex-middle"><div class="tags ellipsis"> {tags}</div> <time class="flex-col time">{date}</time></div></a></li></template><script src="/js/search.min.js?v=1.7.2" async></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>!function(){var t,e=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="老铁为何离开了",clearTimeout(t)):(document.title="欢迎回来",t=setTimeout(function(){document.title=e},2e3))})}()</script></body></html><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?ac93934d9b847216e10a2f133187e535";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>