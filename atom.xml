<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋水阳个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.songshuiyang.site/"/>
  <updated>2019-03-18T14:42:14.853Z</updated>
  <id>http://www.songshuiyang.site/</id>
  
  <author>
    <name>songshuiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类加载机制(二)类加载器</title>
    <link href="http://www.songshuiyang.site/2019/03/18/backend/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6(%E4%BA%8C)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/18/backend/Java/JVM/类加载机制(二)类加载器/</id>
    <published>2019-03-18T13:59:44.000Z</published>
    <updated>2019-03-18T14:42:14.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h3><ul><li><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，</p></li><li><p>3种类加载器：</p><ul><li>启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。启动类加载器是无法被Java程序直接引用的。</li><li>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/classLoad.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>例子：<blockquote><p>寻找类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">64f</span>ef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>ddd40f3</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure></p></blockquote><ul><li><p>从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p></li><li><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></li><li><p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></li><li><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul><h3 id="2-自定义类加载器"><a href="#2-自定义类加载器" class="headerlink" title="2. 自定义类加载器"></a>2. 自定义类加载器</h3><ul><li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.neo.classloader.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-类的加载"><a href="#3-类的加载" class="headerlink" title="3. 类的加载"></a>3. 类的加载</h3><ul><li><p>类加载有三种方式</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li><li><p>Class.forName()和ClassLoader.loadClass()区别</p><ul><li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li>注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li></ul></li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul><li><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li><li><p>双亲委派机制:</p><ul><li>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li><li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li></ul></li><li>双亲委派模型意义：<ul><li>系统类防止内存中出现多份同样的字节码 </li><li>保证Java程序安全稳定运行<h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2></li></ul></li><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;h3 id=&quot;1-类加载器&quot;&gt;&lt;a href=&quot;#1-类加载器&quot; class=&quot;headerlink&quot; title=&quot;1. 类加载器&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制(一)类加载时机及过程</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6(%E4%B8%80)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA%E5%8F%8A%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/类加载机制(一)类加载时机及过程/</id>
    <published>2019-03-16T03:59:44.000Z</published>
    <updated>2019-03-18T14:18:06.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h2><ul><li><p>虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</p></li><li><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</p></li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul><li>如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。下面我们就分别来看一下这五个过程。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/jiazai.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><ul><li><p>加载的过程：</p><ul><li>1、通过一个类的全限定名来获取其定义的二进制字节流。</li><li>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul></li><li><p>加载<code>.class</code>文件的方式:</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件，比如java.lang.reflect.Proxy</li></ul></li><li><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p></li><li><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是Java堆中，在hotspot中它是存放在方法区中），这样便可以通过该对象访问方法区中的这些数据。</p></li></ul><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul><li><p>验证是为了确保被加载的类的正确性</p></li><li><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul></li><li>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3></li><li><p>准备是为类的静态变量分配内存，并将其初始化为默认值</p></li><li><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意</p><ul><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li><li>假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行</clinit></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/defalutValue.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><ul><li>解析是把类中的符号引用转换为直接引用</li><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3></li><li><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p></li><li><p>在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul></li><li>JVM初始化步骤<ul><li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul></li><li>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下五种(有且只有)：<ul><li>1、Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li><li>2、创建类的实例，也就是new的方式或者访问某个类或接口的静态变量，或者对该静态变量赋值，以及调用一个类的静态方法</li><li>3、使用java.lang.reflect包的方法对类进行反射调用的时候（如Class.forName(“com.shengsiyuan.Test”)）</li><li>4、初始化某个类的子类，如果父类没有初始化则其父类也会被初始化</li><li>5、当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li></ul></li><li>被动引用<ul><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发此类的初始化</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发</li></ul></li></ul><h3 id="6-结束"><a href="#6-结束" class="headerlink" title="6.结束"></a>6.结束</h3><ul><li>在如下几种情况下，Java虚拟机将结束生命周期<ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul></li><li>研究类加载全过程有助于连接JVM运行过程</li><li>深入了解java动态性（热部署，动态加载），提高程序的灵活性</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是类的加载&quot;&gt;&lt;a href=&quot;#什么是类的加载&quot; class=&quot;headerlink&quot; title=&quot;什么是类的加载&quot;&gt;&lt;/a&gt;什么是类的加载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(三)字节码指令</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%89)%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(三)字节码指令/</id>
    <published>2019-03-16T02:59:44.000Z</published>
    <updated>2019-03-16T15:24:29.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。由于JAVA虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码</p></li><li><p>伪代码执行模型</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zijie.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="加载、存储指令"><a href="#加载、存储指令" class="headerlink" title="加载、存储指令"></a>加载、存储指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）iload、iload&lt;n&gt;、lload、lload&lt;n&gt;、fload、fload&lt;n&gt;、dload、dload&lt;n&gt;、aload、aload&lt;n&gt;：将一个局部变量加载到操作数栈。</span><br><span class="line">2）istore、istore&lt;n&gt;、lstore、lstore&lt;n&gt;、fstore、fstore&lt;n&gt;、dstore、dstore&lt;n&gt;、astore、astore&lt;n&gt;：将一个数值从操作数栈存储到局部变量表。</span><br><span class="line">3）bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconstm1、iconst&lt;i&gt;、lconst&lt;l&gt;、fconst&lt;f&gt;、dconst_&lt;d&gt;：将一个常量加载到操作数栈。</span><br><span class="line">4）wide：扩充局部变量表的访问索引的指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">methodE</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">300000</span>;</span><br><span class="line">    e++;</span><br><span class="line">    ++e;</span><br><span class="line">    --e;</span><br><span class="line">    e--;</span><br><span class="line">    <span class="keyword">return</span> c + d + e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">methodE</span><span class="params">()</span></span>;</span><br><span class="line">        Signature: ()I</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">        Code:</span><br><span class="line">        stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: sipush        <span class="number">300</span></span><br><span class="line">        <span class="number">6</span>: istore_1</span><br><span class="line">        7: ldc           #5                  // int 300000</span><br><span class="line">        <span class="number">9</span>: istore_2</span><br><span class="line">        <span class="number">10</span>: iinc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">13</span>: iinc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">16</span>: iinc          <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="number">19</span>: iinc          <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="number">22</span>: iload_1</span><br><span class="line">        <span class="number">23</span>: iload_2</span><br><span class="line">        <span class="number">24</span>: iadd</span><br><span class="line">        <span class="number">25</span>: iload_0</span><br><span class="line">        <span class="number">26</span>: iadd</span><br><span class="line">        <span class="number">27</span>: ireturn</span><br><span class="line">        LineNumberTable:</span><br><span class="line">        line <span class="number">40</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">41</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">42</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">43</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">44</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">45</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">46</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">47</span>: <span class="number">22</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）iadd、ladd、fadd、dadd：加法指令。</span><br><span class="line">2）isub、lsub、fsub、dsub：减法指令。</span><br><span class="line">3）imul、lmul、fmul、dmul：乘法指令。</span><br><span class="line">4）idiv、ldiv、fdiv、ddiv：除法指令。</span><br><span class="line">5）irem、lrem、frem、drem：求余指令。</span><br><span class="line">6）ineg、lneg、fneg、dneg：取反指令。</span><br><span class="line">7）ishl、ishr、iushr、lshl、lshr、lushr：位移指令。</span><br><span class="line">8）ior、lor：按位或指令。</span><br><span class="line">9）iand、land：按位与指令。</span><br><span class="line">10）ixor、lxor：按位异或指令。</span><br><span class="line">11）iinc：局部变量自增指令。</span><br><span class="line">12）dcmpg、dcmpl、fcmpg、fcmpl、lcmp：比较指令。</span><br></pre></td></tr></table></figure><ul><li>示例参照上例</li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）int类型到long、float或者double类型，long类型到float、double类型，float类型到double类型：宽化类型转换（虚拟机直接支持）。</span><br><span class="line">2）i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f：窄化类型转换（显式指令）。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">short</span> i2s = (<span class="keyword">short</span>) i;</span><br><span class="line">    <span class="keyword">char</span> i2c = (<span class="keyword">char</span>) i;</span><br><span class="line">    <span class="keyword">long</span> i2l = i;</span><br><span class="line">    <span class="keyword">float</span> i2f = i;</span><br><span class="line">    <span class="keyword">double</span> i2d = i;</span><br><span class="line">    <span class="keyword">float</span> l2f = i2l;</span><br><span class="line">    <span class="keyword">double</span> l2d = i2l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodK</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">11</span>, args_size=<span class="number">0</span></span><br><span class="line">     <span class="number">0</span>: bipush        <span class="number">97</span></span><br><span class="line">     <span class="number">2</span>: istore_0</span><br><span class="line">     <span class="number">3</span>: iload_0</span><br><span class="line">     <span class="number">4</span>: i2s</span><br><span class="line">     <span class="number">5</span>: istore_1</span><br><span class="line">     <span class="number">6</span>: iload_0</span><br><span class="line">     <span class="number">7</span>: i2c</span><br><span class="line">     <span class="number">8</span>: istore_2</span><br><span class="line">     <span class="number">9</span>: iload_0</span><br><span class="line">    <span class="number">10</span>: i2l</span><br><span class="line">    <span class="number">11</span>: lstore_3</span><br><span class="line">    <span class="number">12</span>: iload_0</span><br><span class="line">    <span class="number">13</span>: i2f</span><br><span class="line">    <span class="number">14</span>: fstore        <span class="number">5</span></span><br><span class="line">    <span class="number">16</span>: iload_0</span><br><span class="line">    <span class="number">17</span>: i2d</span><br><span class="line">    <span class="number">18</span>: dstore        <span class="number">6</span></span><br><span class="line">    <span class="number">20</span>: lload_3</span><br><span class="line">    <span class="number">21</span>: l2f</span><br><span class="line">    <span class="number">22</span>: fstore        <span class="number">8</span></span><br><span class="line">    <span class="number">24</span>: lload_3</span><br><span class="line">    <span class="number">25</span>: l2d</span><br><span class="line">    <span class="number">26</span>: dstore        <span class="number">9</span></span><br><span class="line">    <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">100</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">101</span>: <span class="number">3</span></span><br><span class="line">    line <span class="number">102</span>: <span class="number">6</span></span><br><span class="line">    line <span class="number">103</span>: <span class="number">9</span></span><br><span class="line">    line <span class="number">104</span>: <span class="number">12</span></span><br><span class="line">    line <span class="number">105</span>: <span class="number">16</span></span><br><span class="line">    line <span class="number">106</span>: <span class="number">20</span></span><br><span class="line">    line <span class="number">107</span>: <span class="number">24</span></span><br><span class="line">    line <span class="number">108</span>: <span class="number">28</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）new ：创建类实例的指令。</span><br><span class="line">2）newarray、anewarray、multianewarray：创建数组的指令。</span><br><span class="line">3）getstatic、putstatic、getfield、putfield：访问类字段（类变量）和实例字段（实例变量）的指令。</span><br><span class="line">4）baload、caload、saload、iaload、laload、faload、daload、aaload：把一个数组元素加载到操作数栈的指令。</span><br><span class="line">5）bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore：把一个操作数栈的值存储到数组元素中的指令。</span><br><span class="line">6）arraylength：取数组长度的指令。</span><br><span class="line">7）instanceof、checkcast：检查类实例类型的指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodJ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SimpleMethodExecuteProcess();</span><br><span class="line"></span><br><span class="line">    System.out.println(SimpleMethodExecuteProcess.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodJ</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">     0: new           #9                  // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: invokespecial #10                 // Method "&lt;init&gt;":()V</span><br><span class="line">     <span class="number">7</span>: pop</span><br><span class="line">     8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    11: getstatic     #11                 // Field i:I</span><br><span class="line">    14: invokevirtual #12                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">    <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">91</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">93</span>: <span class="number">8</span></span><br><span class="line">    line <span class="number">94</span>: <span class="number">17</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）pop、pop2：将操作数栈的栈顶一个或两个元素出栈。</span><br><span class="line">2）dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。</span><br><span class="line">3）swap：将栈最顶端两个数值互换</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    heavyMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">        Signature: ([Ljava/lang/String;)V</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">        Code:</span><br><span class="line">                        stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">                        0: invokestatic  #23                 // Method heavyMethod:()I</span><br><span class="line">                        <span class="number">3</span>: pop</span><br><span class="line">                        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">                        line <span class="number">115</span>: <span class="number">0</span></span><br><span class="line">                        line <span class="number">116</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。</span><br><span class="line">2）tableswitch、lookupswitch：复合条件分支。</span><br><span class="line">3）goto、goto_w、jsr、jsr_w、ret：无条件分支。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodG</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodG</span><span class="params">()</span></span>;</span><br><span class="line"> Signature: ()V</span><br><span class="line"> flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"> Code:</span><br><span class="line">   stack=<span class="number">3</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">      0: getstatic     #6                  // Field i:I</span><br><span class="line">      <span class="number">3</span>: ifne          <span class="number">15</span></span><br><span class="line">      6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      9: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J</span><br><span class="line">     12: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V</span><br><span class="line">     15: getstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">18</span>: iconst_1</span><br><span class="line">     <span class="number">19</span>: if_icmpge     <span class="number">42</span></span><br><span class="line">     22: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     25: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J</span><br><span class="line">     28: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V</span><br><span class="line">     31: getstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">34</span>: iconst_1</span><br><span class="line">     <span class="number">35</span>: iadd</span><br><span class="line">     36: putstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">39</span>: goto          <span class="number">15</span></span><br><span class="line">     <span class="number">42</span>: <span class="keyword">return</span></span><br><span class="line">   LineNumberTable:</span><br><span class="line">     line <span class="number">62</span>: <span class="number">0</span></span><br><span class="line">     line <span class="number">63</span>: <span class="number">6</span></span><br><span class="line">     line <span class="number">66</span>: <span class="number">15</span></span><br><span class="line">     line <span class="number">67</span>: <span class="number">22</span></span><br><span class="line">     line <span class="number">68</span>: <span class="number">31</span></span><br><span class="line">     line <span class="number">70</span>: <span class="number">42</span></span><br><span class="line">   StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">15</span> <span class="comment">/* same */</span></span><br><span class="line">        frame_type = <span class="number">26</span> <span class="comment">/* same */</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">athrow ：显式抛出异常指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodH</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"nothing ..."</span>);</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodH</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">     0: new           #9                  // class java/lang/NullPointerException</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: ldc           #10                 // String nothing ...</span><br><span class="line">     6: invokespecial #11                 // Method java/lang/NullPointerException."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">     <span class="number">9</span>: athrow</span><br><span class="line">    <span class="number">10</span>: astore_0</span><br><span class="line">    <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         <span class="number">0</span>    <span class="number">10</span>    <span class="number">10</span>   Class java/lang/Throwable</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">77</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">79</span>: <span class="number">10</span></span><br><span class="line">    line <span class="number">82</span>: <span class="number">11</span></span><br><span class="line">  StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">       frame_type = <span class="number">74</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">      stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>同步指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorenter、monitorexit：支持synchronized语句块语义的指令。</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Integer.class)&#123;</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodI</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">     0: ldc_w         #13                 // class java/lang/Integer</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     <span class="number">4</span>: astore_1</span><br><span class="line">     <span class="number">5</span>: monitorenter</span><br><span class="line">     <span class="number">6</span>: aload_1</span><br><span class="line">     <span class="number">7</span>: monitorexit</span><br><span class="line">     <span class="number">8</span>: goto          <span class="number">16</span></span><br><span class="line">    <span class="number">11</span>: astore_2</span><br><span class="line">    <span class="number">12</span>: aload_1</span><br><span class="line">    <span class="number">13</span>: monitorexit</span><br><span class="line">    <span class="number">14</span>: aload_2</span><br><span class="line">    <span class="number">15</span>: athrow</span><br><span class="line">    <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         <span class="number">6</span>     <span class="number">8</span>    <span class="number">11</span>   any</span><br><span class="line">        <span class="number">11</span>    <span class="number">14</span>    <span class="number">11</span>   any</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">88</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">90</span>: <span class="number">6</span></span><br><span class="line">    line <span class="number">91</span>: <span class="number">16</span></span><br><span class="line">  StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">       frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">      offset_delta = <span class="number">11</span></span><br><span class="line">      locals = [ class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess, class java/lang/Object ]</span><br><span class="line">      stack = [ class java/lang/Throwable ]</span><br><span class="line">       frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">      offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>synchronized 修饰方法的语义解析：可以直接从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法，不需要解析出monitorenter、monitorexit同步指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodL</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodL</span><span class="params">()</span></span>;</span><br><span class="line">        Signature: ()V</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">        Code:</span><br><span class="line">            stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">                 <span class="number">0</span>: bipush        <span class="number">97</span></span><br><span class="line">                 <span class="number">2</span>: istore_0</span><br><span class="line">                 <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">            LineNumberTable:</span><br><span class="line">                line <span class="number">120</span>: <span class="number">0</span></span><br><span class="line">                line <span class="number">121</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>方法调用和返回指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）invokestatic：调用静态方法。</span><br><span class="line">2）invokespecial：调用实例构造器&lt;init&gt;方法、私有方法和父类方法。</span><br><span class="line">3）invokevirtual：调用所有的虚方法。非虚方法以外的都是虚方法，非虚方法包括使用invokestatic、invokespecial调用的方法和被final修饰的方法。</span><br><span class="line">4）invokeinterface：调用接口方法，运行时再确定一个实现此接口的对象。</span><br><span class="line">5）invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。</span><br><span class="line">ireturn（返回值是boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn：方法返回指令。</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heavyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> c = methodC(methodA(methodA(a, b), b), methodB(a, b));</span><br><span class="line">    methodD();</span><br><span class="line">    methodE();</span><br><span class="line">    methodF();</span><br><span class="line">    methodG();</span><br><span class="line">    methodH();</span><br><span class="line">    <span class="keyword">new</span> SimpleMethodExecuteProcess().methodI();</span><br><span class="line">    methodJ();</span><br><span class="line">    methodK();</span><br><span class="line">    methodL();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heavyMethod</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()I</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">     <span class="number">0</span>: sipush        <span class="number">200</span></span><br><span class="line">     <span class="number">3</span>: istore_0</span><br><span class="line">     <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">     <span class="number">6</span>: istore_1</span><br><span class="line">     <span class="number">7</span>: iload_0</span><br><span class="line">     <span class="number">8</span>: iload_1</span><br><span class="line">     9: invokestatic  #17                 // Method methodA:(II)I</span><br><span class="line">    <span class="number">12</span>: iload_1</span><br><span class="line">    13: invokestatic  #17                 // Method methodA:(II)I</span><br><span class="line">    <span class="number">16</span>: iload_0</span><br><span class="line">    <span class="number">17</span>: iload_1</span><br><span class="line">    18: invokestatic  #18                 // Method methodB:(II)I</span><br><span class="line">    21: invokestatic  #19                 // Method methodC:(II)I</span><br><span class="line">    <span class="number">24</span>: istore_2</span><br><span class="line">    25: invokestatic  #20                 // Method methodD:()V</span><br><span class="line">    28: invokestatic  #21                 // Method methodE:()I</span><br><span class="line">    <span class="number">31</span>: pop</span><br><span class="line">    32: invokestatic  #22                 // Method methodF:()D</span><br><span class="line">    <span class="number">35</span>: pop2</span><br><span class="line">    36: invokestatic  #23                 // Method methodG:()V</span><br><span class="line">    39: invokestatic  #24                 // Method methodH:()V</span><br><span class="line">    42: new           #14                 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess</span><br><span class="line">    <span class="number">45</span>: dup</span><br><span class="line">    46: invokespecial #15                 // Method "&lt;init&gt;":()V</span><br><span class="line">    49: invokevirtual #25                 // Method methodI:()V</span><br><span class="line">    52: invokestatic  #26                 // Method methodJ:()V</span><br><span class="line">    55: invokestatic  #27                 // Method methodK:()V</span><br><span class="line">    58: invokestatic  #28                 // Method methodL:()V</span><br><span class="line">    <span class="number">61</span>: iload_2</span><br><span class="line">    <span class="number">62</span>: ireturn</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">128</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">129</span>: <span class="number">4</span></span><br><span class="line">    line <span class="number">130</span>: <span class="number">7</span></span><br><span class="line">    line <span class="number">131</span>: <span class="number">25</span></span><br><span class="line">    line <span class="number">132</span>: <span class="number">28</span></span><br><span class="line">    line <span class="number">133</span>: <span class="number">32</span></span><br><span class="line">    line <span class="number">134</span>: <span class="number">36</span></span><br><span class="line">    line <span class="number">135</span>: <span class="number">39</span></span><br><span class="line">    line <span class="number">136</span>: <span class="number">42</span></span><br><span class="line">    line <span class="number">137</span>: <span class="number">52</span></span><br><span class="line">    line <span class="number">138</span>: <span class="number">55</span></span><br><span class="line">    line <span class="number">139</span>: <span class="number">58</span></span><br><span class="line">    line <span class="number">140</span>: <span class="number">61</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.51cto.com/damon188/2131035" target="_blank" rel="noopener">https://blog.51cto.com/damon188/2131035</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(二)Code属性</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%BA%8C)Code%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(二)Code属性/</id>
    <published>2019-03-16T01:59:44.000Z</published>
    <updated>2019-03-16T15:24:29.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据</p></li><li><p>Java虚拟机执行字节码是基于栈的体系结构</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/yxwkf/p/5222589.html" target="_blank" rel="noopener">https://www.cnblogs.com/yxwkf/p/5222589.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(一)Class类文件结构</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%80)Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(一)Class类文件结构/</id>
    <published>2019-03-16T00:59:44.000Z</published>
    <updated>2019-03-16T15:24:30.062Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器直接生成)。</p></li><li><p>Class文件是一组以8位字节为基础单位的二进制流。各个数据项严格按顺序排列，没有不论什么分隔符。</p></li><li><p>Class文件格式採用一种类似于C语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>使用以下的类进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getM</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>javap -verbose 执行后的可视byteCode（只存在两种数据类型：无符号数字与表）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/workspace-github/jvm/target/production/jvm/com/songsy/Test.class</span><br><span class="line">  Last modified <span class="number">2019</span>-<span class="number">3</span>-<span class="number">16</span>; size <span class="number">361</span> bytes</span><br><span class="line">  MD5 checksum bb8e54060828e4bf1f709c2f4434dca8</span><br><span class="line">  Compiled from <span class="string">"Test.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">songsy</span>.<span class="title">Test</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#18         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#19         // com/songsy/Test.m:I</span><br><span class="line">   #3 = Class              #20            // com/songsy/Test</span><br><span class="line">   #4 = Class              #21            // java/lang/Object</span><br><span class="line">   #5 = Utf8               m</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/songsy/Test;</span><br><span class="line">  #14 = Utf8               getM</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               SourceFile</span><br><span class="line">  #17 = Utf8               Test.java</span><br><span class="line">  #18 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #19 = NameAndType        #5:#6          // m:I</span><br><span class="line">  #20 = Utf8               com/songsy/Test</span><br><span class="line">  #21 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.songsy.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/songsy/Test;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getM</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/songsy/Test;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test.java"</span></span><br></pre></td></tr></table></figure></li><li><p>编译后的class文件例如以下：</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-魔数与Class版本"><a href="#1-魔数与Class版本" class="headerlink" title="1. 魔数与Class版本"></a>1. 魔数与Class版本</h3><ul><li>每一个class文件的头4个字节称为魔数，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。非常多文件存储标准中都使用魔数来进行身份识别。譬如图片格式gif、jpeg等。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，由于文件拓展格式能够任意修改。Class文件的魔数为：0xCAFEBABE（咖啡宝贝？）。这个魔数似乎也预示着日后JAVA这个商标名称的出现。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>第五六个字节是次版本（Minor Version）。第7和第8个字节是主版本（Major Version）。</p></li><li><p>高版本号的JDK能够向下兼容曾经版本号的Class文件，可是无法执行以后版本号的Class文件，即使文件格式并未发生变化，虚拟机也必须拒绝执行超过其版本号号的Class文件。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class-version.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h3><ul><li>紧接着版本之后就是常量池，常量池能够理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之中的一个。同一时候也是在Class文件里第一个出现的表类型数据项目</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>常量池中主要存放两大类常量<ul><li>字面量和符号引用。字面量如文本字符串、声明为final的常量值等</li><li>符号引用包含三类常量：类和接口的全限定名、字段的名称和描写叙述符、方法的名称和描写叙述符。</li></ul></li></ul><h3 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3. 访问标志"></a>3. 访问标志</h3><ul><li>在常量池结束之后，紧接着的两个字节代表訪问标志。用于识别一些类或者接口层次的訪问信息。包括：这个类是Class类还是接口；是否定义为public类型，是否被声明为final，具体的标志位及其含义例如以下表所看到的。</li></ul><p><img src="/images/server/java/JVM/class-access.png" alt="image"></p><ul><li>依据上面的表格，測试类的訪问标志0x0021= 0x0001 | 0x0020 =ACC_PUBLIC | ACC_SUPER </li></ul><p><img src="/images/server/java/JVM/class4.png" alt=""></p><h3 id="4-类索引、父类索引和接口索引集合"><a href="#4-类索引、父类索引和接口索引集合" class="headerlink" title="4. 类索引、父类索引和接口索引集合"></a>4. 类索引、父类索引和接口索引集合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>Class文件里由这3项数据来确定这个类的继承关系<ul><li>this_class：类索引，用于确定这个类的全限定名，占2字节</li><li>super_class：父类索引。用于确定这个类父类的全限定名（Java语言不同意多重继承，故父类索引仅仅有一个。除了java.lang.Object类之外全部类都有父类，故除了java.lang.Object类之外，全部类该字段值都不为0），占2字节</li><li>interfaces_count：接口索引计数器。占2字节。接口索引计数器。占2字节。</li><li>interfaces：接口索引集合，一组u2类型数据的集合。用来描写叙述这个类实现了哪些接口。这些被实现的接口将按implements语句（假设该类本身为接口，则为extends语句）后的接口顺序从左至右排列在接口的索引集合中</li></ul></li><li>this_class、super_class与interfaces中保存的索引值均指向常量池中一个CONSTANT_Class_info类型的常量。通过这个常量中保存的索引值能够找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串this_class的值为0x0001，即常量池中第一个常量，super_class的值为0x0003，即常量池中的第三个常量，interfaces_counts的值为0x0000，故接口索引集合大小为0</li></ul><h3 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5. 字段表集合"></a>5. 字段表集合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>字段表用于描写叙述接口或者类中声明的变量，包含类级变量和实例级变量(是否是static)。但不包含在方法内部声明的局部变量。<ul><li>fields_count：字段表计数器。即字段表集合中的字段表数据个数。占2字节，其值为0x0001，即仅仅有一个字段表数据。也就是測试类中仅仅包括一个变量（不算方法内部变量）</li><li>字段表集合，一组字段表类型数据的集合。字段表用于描写叙述接口或类中声明的变量。包含类级别（static）和实例级别变量，不包含在方法内部声明的变量 <h3 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6. 方法表集合"></a>6. 方法表集合</h3></li></ul></li><li><p>methods_count：方法表计数器，即方法表集合中的方法表数据个数。占2字节，其值为0x0002，即測试类中有2个方法(还自己主动添加了一个构造函数）</p></li><li><p>methods：方法表集合，一组方法表类型数据的集合。方法表结构和字段表结构一样：</p></li></ul><h3 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7. 属性表集合"></a>7. 属性表集合</h3><ul><li><p>在Class文件、属性表、方法表中都能够包括自己的属性表集合。用于描写叙述某些场景的专有信息</p></li><li><p>与Class文件里其他数据项对长度、顺序、格式的严格要求不同，属性表集合不要求当中包括的属性表具有严格的顺序，而且仅仅要属性的名称不与已有的属性名称反复。不论什么人实现的编译器可以向属性表中写入自定义的属性信息。虚拟机在执行时会忽略不能识别的属性，为了能正确解析Class文件</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/yxwkf/p/5222589.html" target="_blank" rel="noopener">https://www.cnblogs.com/yxwkf/p/5222589.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(四)常用参数</title>
    <link href="http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E5%9B%9B)%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
    <id>http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM垃圾回收(四)常用参数/</id>
    <published>2019-03-11T13:59:44.000Z</published>
    <updated>2019-03-16T03:03:49.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JVM参数的含义</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-Xms</td><td style="text-align:left">初始堆大小</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td style="text-align:left">-Xmx</td><td style="text-align:left">最大堆大小</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td style="text-align:left">-Xmn</td><td style="text-align:left">年轻代大小(1.4or lator)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td style="text-align:left">设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td style="text-align:left">年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:PermSize</td><td style="text-align:left">设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td style="text-align:left">设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td style="text-align:left">-Xss</td><td style="text-align:left">每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:””-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。</td></tr><tr><td style="text-align:left">-XX:ThreadStackSize</td><td style="text-align:left">Thread Stack Size</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td style="text-align:left">年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td style="text-align:left">Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td style="text-align:left">-XX:LargePageSizeInBytes</td><td style="text-align:left">内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>=128m</td></tr><tr><td style="text-align:left">-XX:+UseFastAccessorMethods</td><td style="text-align:left">原始类型的快速优化</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+DisableExplicitGC</td><td style="text-align:left">关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td style="text-align:left">-XX:MaxTenuringThreshold</td><td style="text-align:left">垃圾最大年龄</td><td></td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效</td></tr><tr><td style="text-align:left">-XX:+AggressiveOpts</td><td style="text-align:left">加快编译</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+UseBiasedLocking</td><td style="text-align:left">锁机制的性能改善</td><td></td><td></td></tr><tr><td style="text-align:left">-Xnoclassgc</td><td style="text-align:left">禁用垃圾回收</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:SoftRefLRUPolicyMSPerMB</td><td style="text-align:left">每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td></td></tr><tr><td style="text-align:left">-XX:PretenureSizeThreshold</td><td style="text-align:left">对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td style="text-align:left">-XX:TLABWasteTargetPercent</td><td style="text-align:left">TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td style="text-align:left">-XX:+CollectGen0First</td><td style="text-align:left">FullGC时是否先YGC</td><td>false</td></tr></tbody></table><blockquote><p>并行收集器相关参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+UseParallelGC</td><td style="text-align:left">Full GC采用parallel MSC(此项待验证)</td><td></td><td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td></tr><tr><td style="text-align:left">-XX:+UseParNewGC</td><td style="text-align:left">设置年轻代为并行收集</td><td></td><td>可与CMS收集同时使用JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td></tr><tr><td style="text-align:left">-XX:ParallelGCThreads</td><td style="text-align:left">并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td style="text-align:left">-XX:+UseParallelOldGC</td><td style="text-align:left">年老代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td><td>这个是JAVA 6出现的参数选项</td></tr><tr><td style="text-align:left">-XX:MaxGCPauseMillis</td><td style="text-align:left">每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr><tr><td style="text-align:left">-XX:+UseAdaptiveSizePolicy</td><td style="text-align:left">自动选择年轻代区大小和相应的Survivor区比例</td><td></td><td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td></tr><tr><td style="text-align:left">-XX:GCTimeRatio</td><td style="text-align:left">设置垃圾回收时间占程序运行时间的百分比</td><td></td><td>公式为1/(1+n)</td></tr><tr><td style="text-align:left">-XX:+ScavengeBeforeFullGC</td><td style="text-align:left">Full GC前调用YGC</td><td>true</td><td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td></tr></tbody></table><blockquote><p>CMS相关参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+UseConcMarkSweepGC</td><td style="text-align:left">使用CMS内存收集</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+AggressiveHeap</td><td style="text-align:left"></td><td></td><td>试图是使用大量的物理内存长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td style="text-align:left">-XX:CMSFullGCsBeforeCompaction</td><td style="text-align:left">多少次后进行内存压缩</td><td></td><td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td></tr><tr><td style="text-align:left">-XX:+CMSParallelRemarkEnabled</td><td style="text-align:left">降低标记停顿</td><td></td><td></td></tr><tr><td style="text-align:left">-XX+UseCMSCompactAtFullCollection</td><td style="text-align:left">在FULL GC的时候， 对年老代的压缩</td><td></td><td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片</td></tr><tr><td style="text-align:left">-XX:+UseCMSInitiatingOccupancyOnly</td><td style="text-align:left">使用手动定义初始化定义开始CMS收集</td><td></td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td style="text-align:left">-XX:CMSInitiatingOccupancyFraction=70</td><td style="text-align:left">使用cms作为垃圾回收使用70％后开始CMS收集</td><td>92</td><td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式</td></tr><tr><td style="text-align:left">-XX:CMSInitiatingPermOccupancyFraction</td><td style="text-align:left">设置Perm Gen使用到达多少比率时触发</td><td>92</td><td></td></tr><tr><td style="text-align:left">-XX:+CMSIncrementalMode</td><td style="text-align:left">设置为增量模式</td><td></td><td>用于单CPU情况</td></tr><tr><td style="text-align:left">-XX:+CMSClassUnloadingEnabled</td><td style="text-align:left"></td><td></td></tr></tbody></table><blockquote><p>辅助参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+PrintGC</td><td style="text-align:left"></td><td></td><td>输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143 secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCDetails</td><td style="text-align:left"></td><td></td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCTimeStamps</td><td style="text-align:left"></td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintGCApplicationStoppedTime</td><td style="text-align:left">打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td></td><td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCApplicationConcurrentTime</td><td style="text-align:left">打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td><td></td><td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td></tr><tr><td style="text-align:left">-XX:+PrintHeapAtGC</td><td style="text-align:left">打印GC前后的详细堆栈信息</td><td></td><td></td></tr><tr><td style="text-align:left">-Xloggc:filename</td><td style="text-align:left">把相关日志信息记录到文件以便分析，与上面几个配合使用</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintClassHistogram</td><td style="text-align:left">garbage collects before printing the histogram.</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintTLAB</td><td style="text-align:left">查看TLAB空间的使用情况</td><td></td><td></td></tr><tr><td style="text-align:left">XX:+PrintTenuringDistribution</td><td style="text-align:left">查看每次minor GC后新的存活周期的阈值</td><td></td><td>Desired survivor size 1048576 bytes, new threshold 7 (max 15)new threshold 7即标识新的存活周期的阈值为7。</td></tr></tbody></table><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;JVM参数的含义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;参数名称&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;含义&lt;/th&gt;
&lt;t
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(三)内存分配及回收策略</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%B8%89)%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%8A%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(三)内存分配及回收策略/</id>
    <published>2019-03-10T14:59:44.000Z</published>
    <updated>2019-03-16T15:24:30.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。</p></li><li><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><ul><li>TLAB: 首先讲讲什么是TLAB。内存分配的动作，可以按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。这么做的目的之一，也是为了并发创建一个对象时，保证创建对象的线程安全性。TLAB比较小，直接在TLAB上分配内存的方式称为快速分配方式，而TLAB大小不够，导致内存被分配在Eden区的内存分配方式称为慢速分配方式。</li></ul></li></ul><ul><li>接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。由于条件因素，只能在Client模式下测试，因此CMS和G1并未提及。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h3><ul><li>所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。<ul><li>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。</li><li>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc-generation.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。这时会把存活的对象转移进Survivor区。<ul><li><code>Minor GC</code> 新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。</li><li><code>Major GC/Full GC</code> 老年代GC，指发生在老年代的GC。</li></ul></li></ul><ul><li><p>举例说明</p><ul><li><p>下面的代码来看一下jvm具体是怎样分配的，下面的代码注释有详细解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：</span></span><br><span class="line"><span class="comment"> *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> * 参数解析：</span></span><br><span class="line"><span class="comment"> *      * 初始堆大小为20兆，不可扩展，年轻代大小为10兆剩下的10兆分配给老年代，PrintGCDetails打印内存回收日志，SurvivorRatio标识 eden与Survivor比例为8:1</span></span><br><span class="line"><span class="comment"> *      * "eden space 8192K from space 1024K to space 1024K" 新生代总可用空间为9216KB (一个Eden区 + 一个Survivor区)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/11 18:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1KB = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * _1KB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1,allocation2, allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到下一步出现一次Minor GC，因为发现Eden已经被占用了6Mb，剩余空间装不下4Mb，</span></span><br><span class="line"><span class="comment">         * 执行gc的时候发现已有3*2Mb的对象无法放入Survivor（只有1mb）空间，所以只好通过</span></span><br><span class="line"><span class="comment">         * 分配担保机制提前转移到老年代去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Gc结束，4Mb的allocation4对象将分配在Eden区，老年代占用6Mb</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">* 输出日志</span><br></pre></td></tr></table></figure><p>[GC[DefNew: 7485K-&gt;526K(9216K), 0.0076710 secs] 7485K-&gt;6671K(19456K), 0.0077381 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>Heap<br>def new generation   total 9216K, used 4952K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)<br>eden space 8192K,  54% used [0x00000000f9a00000, 0x00000000f9e526c8, 0x00000000fa200000)<br>from space 1024K,  51% used [0x00000000fa300000, 0x00000000fa383bd8, 0x00000000fa400000)<br>to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)<br>tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)<br> the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)<br>compacting perm gen  total 21248K, used 2950K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)<br> the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0e1918, 0x00000000fb0e1a00, 0x00000000fc2c0000)<br>No shared spaces configured.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 2. 大对象直接进入老年代</span><br><span class="line">* 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）。</span><br><span class="line">* 虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。</span><br><span class="line">* 举例说明</span><br><span class="line">    ```java</span><br><span class="line">    /**</span><br><span class="line">     * 测试大对象直接进入老年代</span><br><span class="line">     *</span><br><span class="line">     * VM参数：</span><br><span class="line">     *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br><span class="line">     * -XX:PretenureSizeThreshold=3145728 可选</span><br><span class="line">     * </span><br><span class="line">     * @author songsy</span><br><span class="line">     * @date 2019/3/11 18:37</span><br><span class="line">     */</span><br><span class="line">    public class Jvm2 &#123;</span><br><span class="line">    </span><br><span class="line">        private static final int _1KB = 1024;</span><br><span class="line">        private static final int _1MB = 1024 * _1KB;</span><br><span class="line">    </span><br><span class="line">        public static void testAllocation() &#123;</span><br><span class="line">            byte [] allocation1;</span><br><span class="line">            // 直接分配在老年代</span><br><span class="line">            allocation1 = new byte[4 * _1MB];</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            testAllocation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>没设置PretenureSizeThreshold，可以看到新生代<code>def new generation   total 9216K, used 5773K</code>，老年代<code>tenured generation   total 10240K, used 0K</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 5773K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)</span><br><span class="line">  eden space 8192K,  70% used [0x00000000f9a00000, 0x00000000f9fa3668, 0x00000000fa200000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000fa400000, 0x00000000fa400000, 0x00000000fa400200, 0x00000000fae00000)</span><br><span class="line"> compacting perm gen  total 21248K, used 3237K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)</span><br><span class="line">   the space 21248K,  15% used [0x00000000fae00000, 0x00000000fb129600, 0x00000000fb129600, 0x00000000fc2c0000)</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>* 设置了PretenureSizeThreshold结果，可以看到新生代`def new generation   total 9216K, used 1671K` ,老年代`tenured generation   total 10240K, used 4096K`<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1671K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)</span><br><span class="line">  eden space 8192K,  20% used [0x00000000f9a00000, 0x00000000f9ba1c08, 0x00000000fa200000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)</span><br><span class="line">   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)</span><br><span class="line"> compacting perm gen  total 21248K, used 2938K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)</span><br><span class="line">   the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0de9e0, 0x00000000fb0dea00, 0x00000000fc2c0000)</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure></code></pre><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><ul><li><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象放在新生代，那些对象放在老年代中</p></li><li><p>为了能做到这一点，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数<code>-XX：MaxTenuringThreshold</code>设置。</p></li><li><p>举例说明</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试长期存活的对象进入老年代</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * VM参数：</span></span><br><span class="line"><span class="comment"> *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold=1 可选</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/11 18:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1KB = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * _1KB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1,allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">// 虽然此处赋值为null，但未进行Gc空间仍被占用，下一行代码会执行minor GC</span></span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将MaxTenuringThreshold设为1，可以看出第二次Minor GC时，年轻代已经被清空，allocation1对象因为年龄符合MaxTenuringThreshold设置的值，因此进入老年代。</span></span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><ul><li>为了能更好的适应不同程序的内存状态，虚拟机并不是永远的要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升老年代的</li><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li></ul><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><ul><li><p>内存分配是在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。</p></li><li><p>Parallel Scavenge收集器与其他收集器在空间分配担保上有一点差别, 正常是在Minor GC前进行检查, 而Parallel Scavenge收集器在Minor GC后也会进行检查。</p></li><li><p>另外当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/v123411739/article/details/78941793" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/78941793</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(二)垃圾回收器</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%BA%8C)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(二)垃圾回收器/</id>
    <published>2019-03-10T13:59:50.000Z</published>
    <updated>2019-03-16T15:08:38.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</li><li>Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的回收器可能会有很大差异，一般是提供参数供用户根据自己的应用特点和要求组合各个年代所使用的回收器</li><li>这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图3-5所示</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/hotspot.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><ul><li>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。</li><li>大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</li><li>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcj1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-Serial-Old-收集器"><a href="#2-Serial-Old-收集器" class="headerlink" title="2. Serial Old 收集器"></a>2. Serial Old 收集器</h3><ul><li>Serial收集器的老年代版本，它同样是一个单线程收集器。</li><li>它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</li></ul><h3 id="3-ParNew-收集器"><a href="#3-ParNew-收集器" class="headerlink" title="3. ParNew 收集器"></a>3. ParNew 收集器</h3><ul><li>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</li><li>并行和并发概念补充：<ul><li>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj2.jpg" alt=""></p><h3 id="4-Parallel-Old收集器"><a href="#4-Parallel-Old收集器" class="headerlink" title="4. Parallel Old收集器"></a>4. Parallel Old收集器</h3><ul><li>Parallel Scavenge收集器的老年代版本。</li><li>使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</li></ul><h3 id="5-Parallel-Scavenge收集器"><a href="#5-Parallel-Scavenge收集器" class="headerlink" title="5. Parallel Scavenge收集器"></a>5. Parallel Scavenge收集器</h3><ul><li>Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？</li><li><p>Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代并行</span><br></pre></td></tr></table></figure></li><li><p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</p></li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li></ul><p><img src="/images/server/java/JVM/gcj3.jpg" alt=""></p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><ul><li>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</li><li>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</li><li>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：<ul><li>初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li><li>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj4.jpg" alt=""></p><ul><li><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p><ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h3></li></ul></li><li><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p></li><li><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点</p><ul><li>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul></li><li>G1收集器的运作大致分为以下几个步骤：<ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul></li><li>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html</a></li><li><a href="https://blog.csdn.net/qq_34337272/article/details/82177383" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/82177383</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。&lt;/li&gt;
&lt;li&gt;Java虚拟机规范对垃圾回收器应该如
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(一)垃圾回收算法</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%B8%80)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(一)垃圾回收算法/</id>
    <published>2019-03-10T13:59:44.000Z</published>
    <updated>2019-03-10T12:18:12.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p></li><li><p>而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p></li></ul><h2 id="判断对象是否存活的算法"><a href="#判断对象是否存活的算法" class="headerlink" title="判断对象是否存活的算法"></a>判断对象是否存活的算法</h2><ul><li>垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧）</li></ul><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><p>一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><ul><li>通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcroots.JPEG" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>上图中每个对象都存在引用链与GCRoots相连，表明对象还在，不能回收。有图中三个对象虽然互相引用，但是没有链接与GCRoots相连，则可判断它们是可回收的对象。</p></li><li><p>彻底死亡条件：</p><ul><li>条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。</li><li>条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。</li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>该算法是最基础的收集算法，算法分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象</p></li><li><p>之所以说它是最基础的算法是因为后续的算法都是基于这种思路并对其不足进行改进而得到的</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>效率不足</li><li>会产生大量不连续的内存碎片，碎片过多的话再分配一个较大对象时就无容身之地从而不得不提前触发另一次垃圾收集</li></ol><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>为了解决效率问题，此算法把内存划分为相等大小的两个区域，每一只使用其中一个，回收过程中将存活的对象全部复制到另一个区域中，清空原区域。在年轻代中eden区和两个survivor区就是使用了此种算法。这种算法只复制存活的对象，成本较低，而且不会出现内存碎片问题</p></li><li><p>现在的商业虚拟机都采用这种算法来回收新生代</p></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>费内存，需要2倍的内存空间</li></ol><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>该算法标记阶段和标记-清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。效率比“标记-清理”算法低，但不会产生内存碎片。</li></ul><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/aspirant/p/8662690.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8662690.html</a></li><li><a href="http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(六)方法区</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E5%85%AD)%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(六)方法区/</id>
    <published>2019-03-04T05:59:44.000Z</published>
    <updated>2019-03-16T15:22:34.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。</p></li><li><p>对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。</p></li><li><p>Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出<br>OutOfMemoryError 异常。</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li><p>运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p></li><li><p>Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规<em> 定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、</em> 装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的<em> 提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除</em> 了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常* 量池中。</p></li><li><p>运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语<em> 言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容</em> 才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发* 人员利用得比较多的便是String 类的intern() 方法。</p></li><li><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无* 法再申请到内存时会抛出OutOfMemoryError 异常 </p></li></ul><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(五)堆</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%BA%94)%E5%A0%86/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(五)堆/</id>
    <published>2019-03-04T04:59:44.000Z</published>
    <updated>2019-03-16T15:22:34.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。</p></li><li><p>对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p></li><li><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。</p></li><li><p>根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></li><li><p>所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。</p><ul><li>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。</li><li>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc-generation.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="内存溢出及内存泄漏"><a href="#内存溢出及内存泄漏" class="headerlink" title="内存溢出及内存泄漏"></a>内存溢出及内存泄漏</h2><h3 id="1、内存溢出-out-of-memory"><a href="#1、内存溢出-out-of-memory" class="headerlink" title="1、内存溢出 out of memory"></a>1、内存溢出 out of memory</h3><ul><li>是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出</li></ul><h4 id="1-1-方法区溢出-out-of-memory-PermGen-space"><a href="#1-1-方法区溢出-out-of-memory-PermGen-space" class="headerlink" title="1.1 方法区溢出 out of memory: PermGen space"></a>1.1 方法区溢出 out of memory: PermGen space</h4><h4 id="1-2-本机直接内存溢出"><a href="#1-2-本机直接内存溢出" class="headerlink" title="1.2 本机直接内存溢出"></a>1.2 本机直接内存溢出</h4><h3 id="2、内存泄露-memory-leak"><a href="#2、内存泄露-memory-leak" class="headerlink" title="2、内存泄露 memory leak"></a>2、内存泄露 memory leak</h3><ul><li><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光</p></li><li><p>memory leak会最终会导致out of memory！</p></li><li><p>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 </p></li><li><p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. </p></li><li><p>从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到</p></li></ul><h3 id="3、引起内存溢出的原因"><a href="#3、引起内存溢出的原因" class="headerlink" title="3、引起内存溢出的原因"></a>3、引起内存溢出的原因</h3><ul><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>使用的第三方软件中的BUG；</li><li>使用的第三方软件中的BUG；</li></ul><h3 id="4、内存溢出的解决方案"><a href="#4、内存溢出的解决方案" class="headerlink" title="4、内存溢出的解决方案"></a>4、内存溢出的解决方案</h3><ul><li>修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</li><li>检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</li><li>对代码进行走查和分析，找出可能发生内存溢出的位置。</li></ul><p>## </p><blockquote><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p><ul><li>-Xmx3550m：设置JVM最大可用内存为3550M。</li><li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</li><li>-Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li><li></li></ul></blockquote><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/Sharley/p/5285045.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sharley/p/5285045.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(四)本地方法栈</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E5%9B%9B)%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(四)本地方法栈/</id>
    <published>2019-03-04T03:59:44.000Z</published>
    <updated>2019-03-16T15:22:34.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h2 id="Native-Method"><a href="#Native-Method" class="headerlink" title="Native Method"></a>Native Method</h2><ul><li><p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数</p></li><li><p>例如 <code>Object.java</code> 类下就有很多<code>Native Method</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></li><li><p>本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。</p></li><li><p>为什么要使用Native Method</p><ul><li>与java环境外交互：有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。</li><li>与操作系统交互：JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li><li>Sun’s Java： Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/qq_28885149/article/details/52672475" target="_blank" rel="noopener">https://blog.csdn.net/qq_28885149/article/details/52672475</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Jav
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(三)Java虚拟机栈</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%B8%89)Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(三)Java虚拟机栈/</id>
    <published>2019-03-04T02:59:44.000Z</published>
    <updated>2019-03-16T15:22:34.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为虚拟机栈"><a href="#何为虚拟机栈" class="headerlink" title="何为虚拟机栈"></a>何为虚拟机栈</h2><ul><li><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></li><li><p>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。</p></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示： </li></ul><p><img src="/images/server/java/JVM/stackFrame.jpg" alt=""></p><h3 id="栈帧数据结构"><a href="#栈帧数据结构" class="headerlink" title="栈帧数据结构"></a>栈帧数据结构</h3><ul><li><p>每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中</p></li><li><p>我们先来理解一下虚拟机是如何执行一个方法的，这样我们才能理解为什么栈帧需要这些部分，这些部分分别提供了什么功能。首先我们的方法被编译成了字节码，并生成了可执行的命令。通过程序计数器，虚拟机会一行一行的执行命令，直到进入一个新的方法入口，对应虚拟机栈也就是新的栈帧入栈，当前栈帧改变，又或者遇到返回指令或出现异常结束了方法，对应虚拟机也就是出栈。</p></li></ul><h4 id="1、局部变量表"><a href="#1、局部变量表" class="headerlink" title="1、局部变量表"></a>1、局部变量表</h4><ul><li>是一片逻辑连续的内存空间，最小单位是Slot，用来存放方法参数和方法内部定义的局部变量</li></ul><h4 id="2、操作数栈"><a href="#2、操作数栈" class="headerlink" title="2、操作数栈"></a>2、操作数栈</h4><ul><li><p>每个栈帧都包含一个被叫做操作数栈的后进先出的栈。叫操作栈，或者操作数栈。</p></li><li><p>栈桢刚创建时，里面的操作数栈是空的。</p></li><li><p>Java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据、实例的字段等数据入栈。</p></li><li><p>同时也有指令来支持出栈操作。</p></li><li><p>向其他方法传参的参数，也存在操作数栈中。</p></li><li><p>其他方法返回的结果，返回时存在操作数栈中。</p></li></ul><h4 id="3、动态链接"><a href="#3、动态链接" class="headerlink" title="3、动态链接"></a>3、动态链接</h4><ul><li><p>一个方法调用另一个方法，或者一个类使用另一个类的成员变量时，总得知道被调用者的名字吧？(你可以不认识它本身，但调用它就需要知道他的名字)。符号引用就相当于名字，这些被调用者的名字就存放在Java字节码文件里。名字是知道了，但是Java真正运行起来的时候，真的能靠这个名字（符号引用）就能找到相应的类和方法吗？需要解析成相应的直接引用，利用直接引用来准确地找到。</p></li><li><p>举个例子，就相当于我在0X0300H这个地址存入了一个数526，为了方便编程，我把这个给这个地址起了个别名叫A, 以后我编程的时候(运行之前)可以用别名A来暗示访问这个空间的数据，但其实程序运行起来后，实质上还是去寻找0X0300H这片空间来获取526这个数据的。</p></li><li><p>这样的符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。</p><h4 id="4、方法返回地址"><a href="#4、方法返回地址" class="headerlink" title="4、方法返回地址"></a>4、方法返回地址</h4></li><li><p>返回一个值给调用它的方法，方法正常完成发生在一个方法执行过程 中遇到了方法返回的字节码指令（§2.11.8）的时候，使用哪种返回指令取决于方法返回值的数 据类型（如果有返回值的话）。</p></li></ul><h4 id="5、附加信息"><a href="#5、附加信息" class="headerlink" title="5、附加信息"></a>5、附加信息</h4><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/ychenfeng/article/details/77247807" target="_blank" rel="noopener">https://blog.csdn.net/ychenfeng/article/details/77247807</a></li><li><a href="https://blog.csdn.net/u014296316/article/details/82668670" target="_blank" rel="noopener">https://blog.csdn.net/u014296316/article/details/82668670</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;何为虚拟机栈&quot;&gt;&lt;a href=&quot;#何为虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;何为虚拟机栈&quot;&gt;&lt;/a&gt;何为虚拟机栈&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(二)程序计数器</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%BA%8C)%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(二)程序计数器/</id>
    <published>2019-03-04T01:59:44.000Z</published>
    <updated>2019-03-16T15:22:34.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的<code>行号指示器</code>，在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>线程私有的</li><li>是java虚拟机规范里面， 唯一 一个 没有规定任何 <code>OutOfMemoryError</code> 情况的区域</li><li>生命周期随着线程，线程启动而产生，线程结束而消亡</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>程序计数器，可以看做是当前线程执行的字节码的 行号指示器 ，这句话；要理解这句话，需要先知道字节码文件长什么样子，看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 文件被翻译为字节码的时候，字节码大概类似于下面的样子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 原来的 haha 方法内部的 java 代码，被翻译为下面的类似于汇编语言的指令</span></span><br><span class="line">    <span class="number">0</span> xxxx ....</span><br><span class="line">    <span class="number">2</span> xxxx ....</span><br><span class="line">    <span class="number">4</span> xx  ...</span><br><span class="line">    <span class="number">5</span> xxx ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面左边的 0、2、4、5 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的</p></li><li><p>理解了程序计数器，就好理解它的这些特点了；我们都知道，Java是支持多线程的，当CPU执行权从 A 线程，转移到 B 线程的时候，JVM就要暂时挂起线程 A ，去执行线程 B ；当线程 A 再次得到CPU执行权的时候，又会挂起B线程，继续执行 A 线程 ；</p></li><li><p>我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？</p></li><li><p>答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）；</p></li><li><p>那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，<code>程序计数器的内存空间是线程私有的</code> ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！</p></li><li><p>那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被<code>创建</code>；</p></li><li><p>程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，<code>jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域</code>；</p></li><li><p>当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 ；</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/youngyouth/article/details/79868299" target="_blank" rel="noopener">https://blog.csdn.net/youngyouth/article/details/79868299</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的&lt;code&gt;行号指示器&lt;/code&gt;，在虚拟机的概念模型里（仅仅是概念模
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(一)介绍</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%B8%80)%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(一)介绍/</id>
    <published>2019-03-04T00:59:44.000Z</published>
    <updated>2019-03-16T15:22:34.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/jvm1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>Java 虚拟机的内存模型分为两部分<ul><li>线程共享的<ul><li>方法区</li><li>Java 堆</li></ul></li><li>线程私有的<ul><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器</li></ul></li></ul></li></ul><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ol><li>程序计数器：指向当前线程正在执行的字节码指令。线程私有的。</li><li>虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈</li><li>本地方法栈：调用本地native的内存模型</li><li>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li><li>堆（Heap）：Java对象存储的地方</li></ol><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://segmentfault.com/a/1190000014395186" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014395186</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor</title>
    <link href="http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%B9%9D)RequestBody%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B9%8BRequestResponseBodyMethodProcessor/"/>
    <id>http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor/</id>
    <published>2019-03-03T12:59:44.000Z</published>
    <updated>2019-03-16T01:52:02.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li><p><code>RequestResponseBodyMethodProcessor</code> 的作用是处理被<code>@RequestBody</code>注解的参数，和<code>@ResponseBody</code>注解的返回值</p></li><li><p>查看<code>RequestResponseBodyMethodProcessor</code>继承关系，可以看到它是同时继承了<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>，所以就是说它同时具有参数对象解析及结果对象解析的功能，野心很大</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestResponseBodyMethodProcessor.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h2><blockquote><p>RequestResponseBodyMethodProcessor.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理被<span class="doctag">@RequestBody</span>注解的参数，和<span class="doctag">@ResponseBody</span>注解的返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Resolves method arguments annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; and handles return</span></span><br><span class="line"><span class="comment"> * values from methods annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; by reading and writing</span></span><br><span class="line"><span class="comment"> * to the body of the request or response with an &#123;<span class="doctag">@link</span> HttpMessageConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; method argument is also validated if it is annotated</span></span><br><span class="line"><span class="comment"> * with &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.validation.Valid&#125;. In case of validation failure,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> MethodArgumentNotValidException&#125; is raised and results in an HTTP 400</span></span><br><span class="line"><span class="comment"> * response status code if &#123;<span class="doctag">@link</span> DefaultHandlerExceptionResolver&#125; is configured.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic constructor with converters only. Suitable for resolving</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125;. For handling &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; consider also</span></span><br><span class="line"><span class="comment"> * providing a &#123;<span class="doctag">@code</span> ContentNegotiationManager&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(converters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic constructor with converters and &#123;<span class="doctag">@code</span> ContentNegotiationManager&#125;.</span></span><br><span class="line"><span class="comment"> * Suitable for resolving &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; and handling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; without &#123;<span class="doctag">@code</span> Request~&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ResponseBodyAdvice&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters,</span></span></span><br><span class="line"><span class="function"><span class="params">ContentNegotiationManager manager)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(converters, manager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Complete constructor for resolving &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; method arguments.</span></span><br><span class="line"><span class="comment"> * For handling &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; consider also providing a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ContentNegotiationManager&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters,</span></span></span><br><span class="line"><span class="function"><span class="params">List&lt;Object&gt; requestResponseBodyAdvice)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(converters, <span class="keyword">null</span>, requestResponseBodyAdvice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Complete constructor for resolving &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; and handling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters,</span></span></span><br><span class="line"><span class="function"><span class="params">ContentNegotiationManager manager, List&lt;Object&gt; requestResponseBodyAdvice)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(converters, manager, requestResponseBodyAdvice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测参数是否使用了<span class="doctag">@RequestBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测返回结果是否使用了<span class="doctag">@ResponseBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理被<span class="doctag">@RequestBody</span>注解的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment"> * converter to read the content with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line">Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line"><span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">validateIfApplicable(binder, parameter);</span><br><span class="line"><span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter descriptor (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramType the type of the argument value to be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type paramType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">ServletServerHttpRequest inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line"></span><br><span class="line">Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (checkRequired(parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"Required request body is missing: "</span> +</span><br><span class="line">parameter.getMethod().toGenericString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查RequestBody注解是否required</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkRequired</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (parameter.getParameterAnnotation(RequestBody.class).required() &amp;&amp; !parameter.isOptional());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理<span class="doctag">@ResponseBody</span>注解的返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotAcceptableException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotWritableException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span></span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-1-1-处理被-RequestBody注解的参数解析"><a href="#2-1-1-处理被-RequestBody注解的参数解析" class="headerlink" title="2.1.1 处理被@RequestBody注解的参数解析"></a>2.1.1 处理被@RequestBody注解的参数解析</h3><ul><li><p>参数解析需要关注此类是怎么实现的<code>HandlerMethodArgumentResolver</code>接口的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method parameter&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this resolver.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this resolver supports the supplied parameter;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据request解析方法参数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Resolves a method parameter into an argument value from a given request.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> ModelAndViewContainer&#125; provides access to the model for the</span></span><br><span class="line"><span class="comment"> * request. A &#123;<span class="doctag">@link</span> WebDataBinderFactory&#125; provides a way to create</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@link</span> WebDataBinder&#125; instance when needed for data binding and</span></span><br><span class="line"><span class="comment"> * type conversion purposes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to resolve. This parameter must</span></span><br><span class="line"><span class="comment"> * have previously been passed to &#123;<span class="doctag">@link</span> #supportsParameter&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> binderFactory a factory for creating &#123;<span class="doctag">@link</span> WebDataBinder&#125; instances</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resolved argument value, or &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors with the preparation of argument values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">* 查看`<span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;`方法的实现，实现很简单就是判断是否使用了<span class="meta">@RequestBody</span>注解</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测参数是否使用了<span class="doctag">@RequestBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</code> 方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理被<span class="doctag">@RequestBody</span>注解的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment"> * converter to read the content with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line"><span class="comment">// 主体逻辑</span></span><br><span class="line">Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line"><span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 校验参数是否正确 @Valid注解开启</span></span><br><span class="line">validateIfApplicable(binder, parameter);</span><br><span class="line"><span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"><span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type paramType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">ServletServerHttpRequest inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line">    <span class="comment">// 主体逻辑</span></span><br><span class="line">Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (checkRequired(parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"Required request body is missing: "</span> +</span><br><span class="line">parameter.getMethod().toGenericString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续进入<code>Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</code> ，可以看到是遍历 <code>this.messageConverters</code> 选择适合的消息处理器来处理参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the method argument value of the expected parameter type by reading</span></span><br><span class="line"><span class="comment"> * from the given HttpInputMessage.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the expected type of the argument value to be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputMessage the HTTP input message representing the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter descriptor (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetType the target type, not necessarily the same as the method</span></span><br><span class="line"><span class="comment"> * parameter type, e.g. for &#123;<span class="doctag">@code</span> HttpEntity&lt;String&gt;&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the created method argument value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the reading from the request fails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotSupportedException if no suitable message converter is found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type targetType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">MediaType contentType;</span><br><span class="line"><span class="keyword">boolean</span> noContentType = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">contentType = inputMessage.getHeaders().getContentType();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (contentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">noContentType = <span class="keyword">true</span>;</span><br><span class="line">contentType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; contextClass = (parameter != <span class="keyword">null</span> ? parameter.getContainingClass() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;T&gt; targetClass = (targetType <span class="keyword">instanceof</span> Class ? (Class&lt;T&gt;) targetType : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">ResolvableType resolvableType = (parameter != <span class="keyword">null</span> ?</span><br><span class="line">ResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType));</span><br><span class="line">targetClass = (Class&lt;T&gt;) resolvableType.resolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod();</span><br><span class="line">Object body = NO_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">inputMessage = <span class="keyword">new</span> EmptyBodyCheckingHttpInputMessage(inputMessage);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 this.messageConverters 选择适合的消息处理器来处理参数</span></span><br><span class="line"><span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line"><span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter;</span><br><span class="line"><span class="comment">// 判断是否适合处理参数</span></span><br><span class="line"><span class="keyword">if</span> (genericConverter.canRead(targetType, contextClass, contentType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">body = genericConverter.read(targetType, contextClass, inputMessage);</span><br><span class="line">body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (converter.canRead(targetClass, contentType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage);</span><br><span class="line">body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"I/O error while reading input message"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (body == NO_VALUE) &#123;</span><br><span class="line"><span class="keyword">if</span> (httpMethod == <span class="keyword">null</span> || !SUPPORTED_METHODS.contains(httpMethod) ||</span><br><span class="line">(noContentType &amp;&amp; inputMessage.getBody() == <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(contentType, <span class="keyword">this</span>.allSupportedMediaTypes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>this.messageConverters</code>有哪些呢？见下图</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/MessageConverters.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>下图是主要<code>MessageConverter</code>的功能介绍</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/MessageConverter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-1-2-处理被-ResponseBody注解的返回值解析"><a href="#2-1-2-处理被-ResponseBody注解的返回值解析" class="headerlink" title="2.1.2 处理被@ResponseBody注解的返回值解析"></a>2.1.2 处理被@ResponseBody注解的返回值解析</h3><ul><li><p>返回值解析需要关注此类是怎样实现<code>HandlerMethodArgumentResolver</code>接口的方法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method return type&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this handler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this handler supports the supplied return type;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理结果集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Handle the given return value by adding attributes to the model and</span></span><br><span class="line"><span class="comment"> * setting a view or setting the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ModelAndViewContainer#setRequestHandled&#125; flag to &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * to indicate the response has been handled directly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the return value handling results in an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>boolean supportsReturnType(MethodParameter returnType);</code>的方法的实现，实现也很简单就是判断是否使用了@ResponseBody注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测返回结果是否使用了<span class="doctag">@ResponseBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理<span class="doctag">@ResponseBody</span>注解的返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotAcceptableException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotWritableException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span></span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li>我们知道，Http请求和响应报文本质上都是一串字符串，当请求报文来到java世界，它会被封装成为一个ServletInputStream的输入流，供我们读取报文。响应报文则是通过一个ServletOutputStream的输出流，来输出响应报文，我们得到输入输出流之后需要把它转成我们的java实体类对象，这个是怎样转换的呢，就是通过我们的<code>HttpMessageConverter</code>消息转换器来实现的</li><li><p>下图是<code>HttpMessageConverter</code>的工作流程图</p><p><img src="/images/server/spring/spring-mvc/HttpMessageConverter.png" alt=""></p></li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="https://my.oschina.net/lichhao/blog/172562" target="_blank" rel="noopener">https://my.oschina.net/lichhao/blog/172562</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;RequestResponseBodyMethodProcessor&lt;/cod
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(八)RequestMappingHanlderAdapter</title>
    <link href="http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E5%85%AB)RequestMappingHanlderAdapter/"/>
    <id>http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring Mvc源码(八)RequestMappingHanlderAdapter/</id>
    <published>2019-03-03T03:59:44.000Z</published>
    <updated>2019-03-10T01:44:49.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li><code>RequestMappingHanlderAdapter</code>是 <code>HanlderAdapter</code> 中最复杂的也是最常用的处理适配器，他的作用是根据<code>HanlderMapping</code>找到的<code>Handler</code>调用我们<code>Controller</code> 里的方法</li><li>既然是调用方法我们推测它的工作应该主要设及3步， 1、方法参数绑定，2、方法执行，3、返回结果处理 ， 方法执行的流程已经在代码里写好了，重点是参数绑定及结果处理，各个方法参数类型不同个数不同，想想就复杂，下面来看人家是怎么做的</li></ul><h2 id="2-1-RequestMappingHanlderAdapter初始化解析"><a href="#2-1-RequestMappingHanlderAdapter初始化解析" class="headerlink" title="2.1 RequestMappingHanlderAdapter初始化解析"></a>2.1 RequestMappingHanlderAdapter初始化解析</h2><ul><li>查看<code>RequestMappingHanlderAdapter</code>的继承关系</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestMappingHandlerAdapter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>RequestMappingHandlerAdapter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> AbstractHandlerMethodAdapter&#125; that supports &#123;<span class="doctag">@link</span> HandlerMethod&#125;s</span></span><br><span class="line"><span class="comment"> * with their method argument and return type signature, as defined via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support for custom argument and return value types can be added via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125; and &#123;<span class="doctag">@link</span> #setCustomReturnValueHandlers&#125;.</span></span><br><span class="line"><span class="comment"> * Or alternatively, to re-configure all argument and return value types,</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@link</span> #setArgumentResolvers&#125; and &#123;<span class="doctag">@link</span> #setReturnValueHandlers&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodArgumentResolver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodReturnValueHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodAdapter</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于给处理器方法和注释了@ModelAttribute的方法设置参数</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolvers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于添加了@initBinder的方法设置参数</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于将处理器的返回值处理为ModelAndView类型</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;ModelAndViewResolver&gt; modelAndViewResolvers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ContentNegotiationManager contentNegotiationManager = <span class="keyword">new</span> ContentNegotiationManager();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; requestResponseBodyAdvice = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WebBindingInitializer webBindingInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AsyncTaskExecutor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor(<span class="string">"MvcAsync"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long asyncRequestTimeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CallableProcessingInterceptor[] callableInterceptors = <span class="keyword">new</span> CallableProcessingInterceptor[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DeferredResultProcessingInterceptor[] deferredResultInterceptors = <span class="keyword">new</span> DeferredResultProcessingInterceptor[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreDefaultModelOnRedirect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cacheSecondsForSessionAttributeHandlers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> synchronizeOnSession = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SessionAttributeStore sessionAttributeStore = <span class="keyword">new</span> DefaultSessionAttributeStore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SessionAttributesHandler&gt; sessionAttributesHandlerCache =</span><br><span class="line"><span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, SessionAttributesHandler&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; initBinderCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache =</span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; modelAttributeCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache =</span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringHttpMessageConverter stringHttpMessageConverter = <span class="keyword">new</span> StringHttpMessageConverter();</span><br><span class="line">stringHttpMessageConverter.setWriteAcceptCharset(<span class="keyword">false</span>);  <span class="comment">// see SPR-7316</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(stringHttpMessageConverter);</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;Source&gt;());</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到实现了<code>InitializingBean</code>接口，这个方法注册了<code>this.argumentResolvers</code> <code>this.initBinderArgumentResolvers</code> <code>this.returnValueHandlers</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line"><span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line"><span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例如<code>getDefaultArgumentResolvers方法</code>，可以看到是直接写死了有那些默认的参数解析组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of argument resolvers to use including built-in resolvers</span></span><br><span class="line"><span class="comment"> * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.PathVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.SessionAttributeMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletResponseMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RedirectAttributesMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom arguments</span></span><br><span class="line"><span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Catch-all</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-处理解析"><a href="#2-2-处理解析" class="headerlink" title="2.2 处理解析"></a>2.2 处理解析</h2><ul><li><p><code>RequestMappingHanlderAdapter</code> 处理请求入口方法是<code>handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod)</code>，进入该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">  HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ModelAndView mav;</span><br><span class="line">checkRequest(request);</span><br><span class="line"><span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 具体执行请求的处理</span></span><br><span class="line"><span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line"><span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>mav = invokeHandlerMethod(request, response, handlerMethod);</code>方法，进入该方法之后可以看到该方法主要是一些参数准备及组装各种处理单元，先备兵粮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the &#123;<span class="doctag">@link</span> RequestMapping&#125; handler method preparing a &#123;<span class="doctag">@link</span> ModelAndView&#125;</span></span><br><span class="line"><span class="comment"> * if view resolution is required.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createInvocableHandlerMethod(HandlerMethod)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建WebDataBinder，WebDataBinder用于参数绑定，将符合条件的注释了@InitBinder的方法找出来</span></span><br><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line"><span class="comment">// 用来处理Model，在处理器具体处理之前对Model进行初始化，在处理完请求之后对Model参数进行更新</span></span><br><span class="line">ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成</span></span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModelAndViewContainer承载着整个请求过程中数据的传递工作</span></span><br><span class="line">ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">webRequest.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个方法重点关注<code>ServletInvocableHandlerMethod</code>此对象，该类继承自<code>HandlerMethod</code>，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成</span></span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br></pre></td></tr></table></figure><ul><li><p>查看上面代码可以看到这里设置了参数解析器 结果解析器 等等</p></li><li><p><code>ServletInvocableHandlerMethod</code> 解析</p><ul><li><p>先查看<code>ServletInvocableHandlerMethod</code>的继承关系，此类的继承关系有三层</p><p><img src="/images/server/spring/spring-mvc/ServletInvocableHandlerMethod.png" alt=""></p></li><li><p>顶层<code>HandlerMethod</code>类，该类封装了方法调用相关信息，比如是属于哪个<code>bean</code>下的的，那个<code>Method</code>，方法的参数<code>MethodParameter[]</code>等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装了方法调用相关信息,子类还提供调用,参数准备和返回值处理的职责</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Encapsulates information about a handler method consisting of a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getMethod() method&#125; and a &#123;<span class="doctag">@linkplain</span> #getBean() bean&#125;.</span></span><br><span class="line"><span class="comment"> * Provides convenient access to method parameters, the method return value,</span></span><br><span class="line"><span class="comment"> * method annotations, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The class may be created with a bean instance or with a bean name</span></span><br><span class="line"><span class="comment"> * (e.g. lazy-init bean, prototype bean). Use &#123;<span class="doctag">@link</span> #createWithResolvedBean()&#125;</span></span><br><span class="line"><span class="comment"> * to obtain a &#123;<span class="doctag">@code</span> HandlerMethod&#125; instance with a bean instance resolved</span></span><br><span class="line"><span class="comment"> * through the associated &#123;<span class="doctag">@link</span> BeanFactory&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Logger that is available to subclasses */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method bridgedMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodParameter[] parameters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpStatus responseStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String responseStatusReason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class="line">  </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p><code>InvocableHandlerMethod</code> 类 <code>HandlerMethod</code>类的基础上添加了方法调用功能及注册了参数解析组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 HandlerMethod类的基础上添加了方法调用功能及注册了参数解析组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Provides a method for invoking the handler method for a given request after resolving its</span></span><br><span class="line"><span class="comment"> * method argument values through registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Argument resolution often requires a &#123;<span class="doctag">@link</span> WebDataBinder&#125; for data binding or for type</span></span><br><span class="line"><span class="comment"> * conversion. Use the &#123;<span class="doctag">@link</span> #setDataBinderFactory(WebDataBinderFactory)&#125; property to supply</span></span><br><span class="line"><span class="comment"> * a binder factory to pass to argument resolvers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #setHandlerMethodArgumentResolvers&#125; to customize the list of argument resolvers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocableHandlerMethod</span> <span class="keyword">extends</span> <span class="title">HandlerMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于参数解析器ArgumentResolver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> WebDataBinderFactory dataBinderFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> org.springframework.web.method.support.HandlerMethodArgumentResolverComposite argumentResolvers = <span class="keyword">new</span> org.springframework.web.method.support.HandlerMethodArgumentResolverComposite();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来获取参数名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create an instance from a &#123;<span class="doctag">@code</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocableHandlerMethod</span><span class="params">(HandlerMethod handlerMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul></li><li><p>得到<code>ServletInvocableHandlerMethod</code> 对象之后进入到<code>ServletInvocableHandlerMethod</code> 类的<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code> 方法，可以说这个方法是<code>RequestMappingHandlerAdapter</code>的核心方法，可以看到<code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</code> 是执行了方法体，得到<code>returnValue</code> 之后就是调用<code>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</code>该方法处理结果对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the method and handle the return value through one of the</span></span><br><span class="line"><span class="comment"> * configured &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type (not resolved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</code> 方法，可以看到该方法很简单，先是得到方法参数<code>Object[] args</code>，然后执行<code>Object returnValue = doInvoke(args);</code> 该方法得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the method after resolving its argument values in the context of the given request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Argument values are commonly resolved through &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> providedArgs&#125; parameter however may supply argument values to be used directly,</span></span><br><span class="line"><span class="comment"> * i.e. without argument resolution. Examples of provided argument values include a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> WebDataBinder&#125;, a &#123;<span class="doctag">@link</span> SessionStatus&#125;, or a thrown exception instance.</span></span><br><span class="line"><span class="comment"> * Provided argument values are checked before argument resolvers.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type, not resolved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the raw value returned by the invoked method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> Exception raised if no suitable argument resolver can be found,</span></span><br><span class="line"><span class="comment"> * or if the method raised an exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking '"</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line">Object returnValue = doInvoke(args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Method ["</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-1-方法参数绑定"><a href="#2-1-1-方法参数绑定" class="headerlink" title="2.1.1 方法参数绑定"></a>2.1.1 方法参数绑定</h3><ul><li><p>方法参数的绑定需要关注<code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</code> 这行代码，先进入该方法，可以看到该方法有两种解析形式 <code>1： providedArgs 2：argumentResolvers</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据当前请求获取方法的请求参数</span></span><br><span class="line"><span class="comment"> * Get the method argument values for the current request.</span></span><br><span class="line"><span class="comment"> * 两种解析形式 1： providedArgs 2：argumentResolvers 在RequestMappingHandlerAdapter中只有argumentResolvers解析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 获取方法的参数，在HanderMethod中</span></span><br><span class="line">MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"><span class="comment">// 用于保存解析出参数的值</span></span><br><span class="line">Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"><span class="comment">// 遍历每一个参数进行解析</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">MethodParameter parameter = parameters[i];</span><br><span class="line"><span class="comment">// 给Parameter设置参数名解析器</span></span><br><span class="line">parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"><span class="comment">// 如果相应类型的参数已经在providedArgs中提供了，则直接设置到parameter</span></span><br><span class="line">args[i] = resolveProvidedArgument(parameter, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 使用argumentResolvers解析参数</span></span><br><span class="line">args[i] = <span class="keyword">this</span>.argumentResolvers.resolveArgument(</span><br><span class="line">parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(getArgumentResolutionErrorMessage(<span class="string">"Failed to resolve"</span>, i), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析不出来，抛异常</span></span><br><span class="line"><span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not resolve method parameter at index "</span> +</span><br><span class="line">parameter.getParameterIndex() + <span class="string">" in "</span> + parameter.getMethod().toGenericString() +</span><br><span class="line"><span class="string">": "</span> + getArgumentResolutionErrorMessage(<span class="string">"No suitable resolver for"</span>, i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>RequestMappingHandlerAdapter</code>中只有<code>argumentResolvers</code>解析，因为<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code> 只传了两个参数，到了<code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</code> 方法之后也是没有传入<code>providedArgs</code>的</p></li><li><p><code>argumentResolvers</code> 存放在<code>HandlerMethodArgumentResolverComposite</code> 类中，所有的<code>ArgumentResolver</code>都存放在<code>List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers</code>中，也可以看到该类也做了一个<code>argumentResolverCacheCache</code>处理，也是为了性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HandlerMethodArgumentResolver 的仓库</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Resolves method parameters by delegating to a list of registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s.</span></span><br><span class="line"><span class="comment"> * Previously resolved method parameters are cached for faster lookups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethodArgumentResolverComposite</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers =</span><br><span class="line"><span class="keyword">new</span> LinkedList&lt;HandlerMethodArgumentResolver&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodParameter, HandlerMethodArgumentResolver&gt; argumentResolverCache =</span><br><span class="line"><span class="keyword">new</span> ConcurrentHashMap&lt;MethodParameter, HandlerMethodArgumentResolver&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the given &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HandlerMethodArgumentResolverComposite <span class="title">addResolver</span><span class="params">(HandlerMethodArgumentResolver resolver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.argumentResolvers.add(resolver);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过调试可以看到有下面这些<code>argumentResolvers</code>，看类名称是不是很熟悉，就是我们平常使用的<code>@RequestBody</code> <code>@RequestParam</code> 是一一对应的，还是专人做专事，可以得出不同的参数是有不同的参数解析组件来专门处理的</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/argumentResolvers.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>下面来看主要<code>XXXArgumentResolver</code>的作用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. SessionAttributeMethodArgumentResolver</span><br><span class="line">    针对 被 <span class="meta">@SessionAttribute</span> 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_SESSION)    </span><br><span class="line"><span class="number">2</span>. RequestParamMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@RequestParam</span> 注解修饰, 但类型不是 Map, 或类型是 Map, 并且 <span class="meta">@RequestParam</span> 中指定 name, 一般通过 MultipartHttpServletRequest | HttpServletRequest 获取数据</span><br><span class="line"><span class="number">3</span>. RequestHeaderMethodArgumentResolver</span><br><span class="line">    针对 参数被 RequestHeader 注解, 并且 参数不是 Map 类型, 数据通过 HttpServletRequest.getHeaderValues(name) 获取</span><br><span class="line"><span class="number">4</span>. RequestAttributeMethodArgumentResolver</span><br><span class="line">    针对 被 <span class="meta">@RequestAttribute</span> 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_REQUEST)</span><br><span class="line"><span class="number">5</span>. PathVariableMethodArgumentResolver</span><br><span class="line">    解决被注解 <span class="meta">@PathVariable</span> 注释的参数 &lt;- 这个注解对应的是 uri 中的数据, 在解析 URI 中已经进行解析好了 &lt;- 在 RequestMappingInfoHandlerMapping.handleMatch -&gt; getPathMatcher().extractUriTemplateVariables</span><br><span class="line"><span class="number">6</span>. MatrixVariableMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@MatrixVariable</span> 注解修饰的参数起作用,  从 HttpServletRequest 中获取去除 ; 的 URI Template Variables 获取数据</span><br><span class="line"><span class="number">7</span>. ExpressionValueMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@Value</span> 修饰, 返回 ExpressionValueNamedValueInfo</span><br><span class="line"><span class="number">8</span>. ServletCookieValueMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@CookieValue</span> 修饰, 通过 HttpServletRequest.getCookies 获取对应数据</span><br></pre></td></tr></table></figure><ul><li><p>然后进入<code>HandlerMethodArgumentResolverComposite</code>类的<code>args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</code> 方法，可以看到逻辑十分简单，就是遍历<code>this.argumentResolvers</code> 然后做了个缓存处理，得到<code>HandlerMethodArgumentResolver</code>之后就是调用<code>resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</code>方法了，该方法是参数解析的主体方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代注册过的 HandlerMethodArgumentResolver, 然后找到对应的ArgumentResolver</span></span><br><span class="line"><span class="comment"> * Iterate over registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s and invoke the one that supports it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if no suitable &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125; is found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</span><br><span class="line"><span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown parameter type ["</span> + parameter.getParameterType().getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先从缓存里取，没有的再遍历，注意这里是先来先得的</span></span><br><span class="line"><span class="comment"> * Find a registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125; that supports the given method parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMethodArgumentResolver methodArgumentResolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Testing if argument resolver ["</span> + methodArgumentResolver + <span class="string">"] supports ["</span> +</span><br><span class="line">parameter.getGenericParameterType() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (methodArgumentResolver.supportsParameter(parameter)) &#123;</span><br><span class="line">result = methodArgumentResolver;</span><br><span class="line"><span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再来回顾<code>HandlerMethodArgumentResolver</code>接口，该接口就两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法参数解析器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Strategy interface for resolving method parameters into argument values in</span></span><br><span class="line"><span class="comment"> * the context of a given request.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodReturnValueHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method parameter&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this resolver.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this resolver supports the supplied parameter;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据request解析方法参数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Resolves a method parameter into an argument value from a given request.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> ModelAndViewContainer&#125; provides access to the model for the</span></span><br><span class="line"><span class="comment"> * request. A &#123;<span class="doctag">@link</span> WebDataBinderFactory&#125; provides a way to create</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@link</span> WebDataBinder&#125; instance when needed for data binding and</span></span><br><span class="line"><span class="comment"> * type conversion purposes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to resolve. This parameter must</span></span><br><span class="line"><span class="comment"> * have previously been passed to &#123;<span class="doctag">@link</span> #supportsParameter&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> binderFactory a factory for creating &#123;<span class="doctag">@link</span> WebDataBinder&#125; instances</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resolved argument value, or &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors with the preparation of argument values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>HandlerMethodArgumentResolver</code>的 <code>resolveArgument</code> 的解析将在之后的章节介绍</p><h3 id="2-2-2-方法执行"><a href="#2-2-2-方法执行" class="headerlink" title="2.2.2 方法执行"></a>2.2.2 方法执行</h3></li><li><p>回到<code>InvocableHandlerMethod</code>类的<code>invokeForRequest</code> 方法，上一小节介绍了方法参数绑定的主体逻辑(<code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</code>)，这一小节介绍<code>Object returnValue = doInvoke(args);</code>，该行代码是方法执行的主体方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking '"</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line">Object returnValue = doInvoke(args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Method ["</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Object returnValue = doInvoke(args);</code> 方法，可以看到调用了<code>getBridgedMethod().invoke(getBean(), args);</code> 来执行方法，<code>getBridgedMethod()</code> 得到的是<code>private final Method bridgedMethod</code>，百度了一下这个桥接方法的用途是为了和jdk1.5之前的字节码兼容. 因为范型是在jdk1.5之后才引入的. 在jdk1.5之前例如集合的操作都是没有范型支持的, 所以生成的字节码中参数都是用Object接收的, 所以也可以往集合中放入任意类型的对象, 集合类型的校验也被拖到运行期.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 强制将他变为可调用 即使是private方法</span></span><br><span class="line">ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">"Illegal argument"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getInvocationErrorMessage(text, args), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">Throwable targetException = ex.getTargetException();</span><br><span class="line"><span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String text = getInvocationErrorMessage(<span class="string">"Failed to invoke handler method"</span>, args);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(text, targetException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在此方法执行完成</p></li></ul><h3 id="2-2-3-返回结果处理"><a href="#2-2-3-返回结果处理" class="headerlink" title="2.2.3 返回结果处理"></a>2.2.3 返回结果处理</h3><ul><li><p>方法执行完成之后就对返回结果的处理了，回到<code>ServletInvocableHandlerMethod</code>类，现在方法体已经执行了，就是对结果对象的处理了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the method and handle the return value through one of the</span></span><br><span class="line"><span class="comment"> * configured &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type (not resolved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看上面的代码可以看到<code>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</code> 这行代码作用是对结果对象的处理，查看<code>returnValueHandlers</code> 对象（<code>private HandlerMethodReturnValueHandlerComposite returnValueHandlers;</code>）可以看到和我们之前的参数绑定的处理是相似的，<code>HandlerMethodReturnValueHandlerComposite</code>存放了各种结果处理组件</p><blockquote><p>HandlerMethodReturnValueHandlerComposite.java</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles method return values by delegating to a list of registered &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s.</span></span><br><span class="line"><span class="comment"> * Previously resolved return types are cached for faster lookups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethodReturnValueHandlerComposite</span> <span class="keyword">implements</span> <span class="title">AsyncHandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果处理组件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers =</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;HandlerMethodReturnValueHandler&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>HandlerMethodReturnValueHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果对象处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Strategy interface to handle the value returned from the invocation of a</span></span><br><span class="line"><span class="comment"> * handler method .</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodArgumentResolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method return type&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this handler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this handler supports the supplied return type;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理结果集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Handle the given return value by adding attributes to the model and</span></span><br><span class="line"><span class="comment"> * setting a view or setting the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ModelAndViewContainer#setRequestHandled&#125; flag to &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * to indicate the response has been handled directly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the return value handling results in an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入<code>handleReturnValue</code>方法，可以看到和之前方法参数绑定处理是一样的套路的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代注册过的 HandlerMethodReturnValueHandler, 然后找到对应的ReturnValueHandler</span></span><br><span class="line"><span class="comment"> * Iterate over registered &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s and invoke the one that supports it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if no suitable &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125; is found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown return value type: "</span> + returnType.getParameterType().getName());</span><br><span class="line">&#125;</span><br><span class="line">handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title">selectHandler</span><span class="params">(Object value, MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> isAsyncValue = isAsyncReturnValue(value, returnType);</span><br><span class="line">       <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="keyword">this</span>.returnValueHandlers) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">               <span class="keyword">return</span> handler;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>如下图可以看到有如下<code>this.returnValueHandlers</code></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/HandlerComposite.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><code>RequestMappingHanlderAdapter</code> 的功能主要是 <code>1、方法参数绑定，2、方法执行，3、返回结果处理</code> </li><li><code>HandlerMethodArgumentResolver</code> 的方法参数绑定处理是针对于不同的方法参数有专门的<code>ArgumentResolver</code> 专人做专事，专业</li><li><code>HandlerMethodReturnValueHandler</code> 的返回结果处理也是和参数处理那样是针对于不同的返回对象有专门的<code>ReturnValueHandler</code></li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RequestMappingHanlderAdapter&lt;/code&gt;是 &lt;code
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(七)处理适配器HanlderAdapter</title>
    <link href="http://www.songshuiyang.site/2019/02/28/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%B8%83)%E5%A4%84%E7%90%86%E9%80%82%E9%85%8D%E5%99%A8HanlderAdapter/"/>
    <id>http://www.songshuiyang.site/2019/02/28/backend/spring/sourceCodeAnalysis/Spring Mvc源码(七)处理适配器HanlderAdapter/</id>
    <published>2019-02-28T13:59:44.000Z</published>
    <updated>2019-03-03T03:19:43.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li><p>前几章介绍了<code>HandlerMapping</code>处理流程， <code>HandlerMapping</code>负责根据<code>request</code>请求找到对应的<code>Handler</code>处理器及<code>Interceptor</code>拦截器，的到处理器<code>Handler</code>之后，<code>Spring MVC</code> 又根据该<code>Handler</code> 找出对应的 <code>HandlerAdapter</code>，这一章节来介绍<code>HandlerAdapter</code>，<code>HandlerAdapter</code>是具体使用<code>Handler</code> 来干活的</p></li><li><p>下面还是方法体<code>doDispatch(HttpServletRequest request, HttpServletResponse response)</code> 的处理代码，可以看到得到<code>Handler</code>处理器之后就是遍历所有的 <code>HandlerAdapter</code>，找到可以处理该 <code>Handler</code> 的 <code>HandlerAdapter</code>，找到之后就是<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code> 调用真正的处理方法了</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否是文件上传请求 Multipart，有则将请求转换为 Multipart 请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">// 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="comment">// 处理 last-modified 请求头</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行相应拦截器Interceptor的preHandle</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 执行实际的处理程序，执行Controller里的方法</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><h2 id="2-1-处理适配器HanlderAdapter解析"><a href="#2-1-处理适配器HanlderAdapter解析" class="headerlink" title="2.1 处理适配器HanlderAdapter解析"></a>2.1 处理适配器HanlderAdapter解析</h2><h3 id="2-1-1-HanlderAdapter-解析"><a href="#2-1-1-HanlderAdapter-解析" class="headerlink" title="2.1.1 HanlderAdapter 解析"></a>2.1.1 HanlderAdapter 解析</h3><ul><li>先看<code>HanlderAdapter</code> 这个接口有哪些方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handler 处理适配器, 适配不同的 Handler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MVC framework SPI, allowing parameterization of the core MVC workflow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Interface that must be implemented for each handler type to handle a request.</span></span><br><span class="line"><span class="comment"> * This interface is used to allow the &#123;<span class="doctag">@link</span> DispatcherServlet&#125; to be indefinitely</span></span><br><span class="line"><span class="comment"> * extensible. The &#123;<span class="doctag">@code</span> DispatcherServlet&#125; accesses all installed handlers through</span></span><br><span class="line"><span class="comment"> * this interface, meaning that it does not contain code specific to any handler type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that a handler can be of type &#123;<span class="doctag">@code</span> Object&#125;. This is to enable</span></span><br><span class="line"><span class="comment"> * handlers from other frameworks to be integrated with this framework without</span></span><br><span class="line"><span class="comment"> * custom coding, as well as to allow for annotation-driven handler objects that</span></span><br><span class="line"><span class="comment"> * do not obey any specific Java interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is not intended for application developers. It is available</span></span><br><span class="line"><span class="comment"> * to handlers who want to develop their own web workflow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: &#123;<span class="doctag">@code</span> HandlerAdapter&#125; implementors may implement the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.springframework.core.Ordered&#125; interface to be able to specify a sorting</span></span><br><span class="line"><span class="comment"> * order (and thus a priority) for getting applied by the &#123;<span class="doctag">@code</span> DispatcherServlet&#125;.</span></span><br><span class="line"><span class="comment"> * Non-Ordered instances get treated as lowest priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.handler.SimpleServletHandlerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测 HandlerAdapter 是否支持这个 handler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a handler instance, return whether or not this &#123;<span class="doctag">@code</span> HandlerAdapter&#125;</span></span><br><span class="line"><span class="comment"> * can support it. Typical HandlerAdapters will base the decision on the handler</span></span><br><span class="line"><span class="comment"> * type. HandlerAdapters will usually only support one handler type each.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A typical implementation:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * return (handler instanceof MyHandler);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler object to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this object can use the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理 HttpServletRequest 的入口方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use the given handler to handle this request.</span></span><br><span class="line"><span class="comment"> * The workflow that is required may vary widely.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler to use. This object must have previously been passed</span></span><br><span class="line"><span class="comment"> * to the &#123;<span class="doctag">@code</span> supports&#125; method of this interface, which must have</span></span><br><span class="line"><span class="comment"> * returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment"> * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取Http 请求中的lastModifiedTime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Same contract as for HttpServlet's &#123;<span class="doctag">@code</span> getLastModified&#125; method.</span></span><br><span class="line"><span class="comment"> * Can simply return -1 if there's no support in the handler class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the lastModified value for the given handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> javax.servlet.http.HttpServlet#getLastModified</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.mvc.LastModified#getLastModified</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下图是<code>HanlderAdapter</code>涉及子类的继承关系，看方法名是不是很熟悉，没错和前几章的<code>HandlerMapping</code>是差不多是一一对应的</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/HandlerAdapter.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>查看这些类可以看到除了<code>RequestMappingHandlerAdapter</code> 的实现比较复杂之外，其他的<code>HandlerAdapter</code>都是调用<code>Handler</code>里固定的方法，比如下图的<code>SimpleControllerHandlerAdapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) &#123;</span><br><span class="line"><span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>AbstractHandlerMethodAdapter</code>可以看到内容也很少，<code>HandlerAdapter</code> 接口的实现都转发到自己的抽象方法里去了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract base class for &#123;<span class="doctag">@link</span> HandlerAdapter&#125; implementations that support</span></span><br><span class="line"><span class="comment"> * handlers of type &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMethodAdapter</span> <span class="keyword">extends</span> <span class="title">WebContentGenerator</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> order = Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractHandlerMethodAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// no restriction of HTTP methods by default</span></span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify the order value for this HandlerAdapter bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Default value is &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125;, meaning that it's non-ordered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.Ordered#getOrder()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断是否是HandlerMethod，然后转向抽象方法supportsInternal</span></span><br><span class="line"><span class="comment"> * This implementation expects the handler to be an &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler instance to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this adapter can adapt the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a handler method, return whether or not this adapter can support it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handlerMethod the handler method to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this adapter can adapt the given method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">supportsInternal</span><span class="params">(HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转向抽象方法 handleInternal()</span></span><br><span class="line"><span class="comment"> * This implementation expects the handler to be an &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the given handler method to handle the request.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handlerMethod handler method to use. This object must have previously been passed to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #supportsInternal(HandlerMethod)&#125; this interface, which must have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ModelAndView object with the name of the view and the required model data,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转向抽象方法 getLastModifiedInternal()</span></span><br><span class="line"><span class="comment"> * This implementation expects the handler to be an &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getLastModifiedInternal(request, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same contract as for &#123;<span class="doctag">@link</span> javax.servlet.http.HttpServlet#getLastModified(HttpServletRequest)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handlerMethod handler method to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the lastModified value for the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLastModifiedInternal</span><span class="params">(HttpServletRequest request, HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-2-各个-HandlerAdapter作用"><a href="#2-1-2-各个-HandlerAdapter作用" class="headerlink" title="2.1.2 各个 HandlerAdapter作用"></a>2.1.2 各个 <code>HandlerAdapter</code>作用</h3><h4 id="AnnotationMethodHandlerAdapter"><a href="#AnnotationMethodHandlerAdapter" class="headerlink" title="AnnotationMethodHandlerAdapter"></a>AnnotationMethodHandlerAdapter</h4><p><code>AnnotationMethodHandlerAdapter</code>主要是适配注解类处理器，注解类处理器就是我们经常使用的<code>@Controller</code>的这类处理器，不过该类已经被<code>@Deprecated</code> 标记了（@deprecated as of Spring 3.2, in favor of`） </p><h4 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h4><p><code>HttpRequestHandlerAdapter</code> 主要是适配静态资源处理器，静态资源处理器就是实现了<code>HttpRequestHandler</code>接口的处理器，这类处理器的作用是处理通过<code>SpringMVC</code>来访问的静态资源的请求。        </p><h4 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h4><p><code>SimpleControllerHandlerAdapter</code> 是<code>Controller</code>处理适配器，适配实现了<code>Controller</code>接口或<code>Controller</code>接口子类的处理器，比如我们经常自己写的<code>Controller</code>来继承<code>MultiActionController</code></p><h4 id="SimpleServletHandlerAdapter"><a href="#SimpleServletHandlerAdapter" class="headerlink" title="SimpleServletHandlerAdapter"></a>SimpleServletHandlerAdapter</h4><p><code>SimpleServletHandlerAdapter</code>是<code>Servlet</code>处理适配器,适配实现了<code>Servlet</code>接口或<code>Servlet</code>的子类的处理器，我们不仅可以在web.xml里面配置Servlet，其实也可以用SpringMVC来配置Servlet，不过这个适配器很少用到，而且SpringMVC默认的适配器没有他，默认的是前面的三种。</p><h3 id="2-1-3-HandlerAdapter-注册过程"><a href="#2-1-3-HandlerAdapter-注册过程" class="headerlink" title="2.1.3 HandlerAdapter 注册过程"></a>2.1.3 <code>HandlerAdapter</code> 注册过程</h3><ul><li><p><code>HandlerAdapter</code> 注册过程 和 <code>HandlerMapping</code> 的注册过程是一样的，回到<code>DispatcherServlet</code> 类中<code>onRefresh</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 上传组件组件初始化</span></span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line"><span class="comment">// 请求映射处理组件初始化</span></span><br><span class="line">initHandlerMappings(context);</span><br><span class="line"><span class="comment">// 处理适配器组建初始化</span></span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line"><span class="comment">// 异常处理组件初始化</span></span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line"><span class="comment">// 视图处理组件初始化</span></span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>initHandlerAdapters(context);</code> 从下面代码也可以看到也是通过扫描<code>HandlerAdapter</code>类 <code>bean</code>的形式来注册<code>HandlerAdapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the HandlerAdapters used by this class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no HandlerAdapter beans are defined in the BeanFactory for this namespace,</span></span><br><span class="line"><span class="comment"> * we default to SimpleControllerHandlerAdapter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerAdapters</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerAdapters) &#123;</span><br><span class="line"><span class="comment">// 加载所有实现了HandlerAdapter接口的bean</span></span><br><span class="line"><span class="comment">// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;(matchingBeans.values());</span><br><span class="line"><span class="comment">// We keep HandlerAdapters in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerAdapters);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Ignore, we'll add a default HandlerAdapter later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure we have at least some HandlerAdapters, by registering</span></span><br><span class="line"><span class="comment">// default HandlerAdapters if no other adapters are found.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No HandlerAdapters found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><code>HanlderAdapter</code> 从字面上的意思就是处理适配器，他的作用就是根据用户的请求调用具体的方法，根据<code>HandlerMapping</code>传过来<code>Hanler</code>与注册好的<code>HandlerAdapter</code>一一匹配，如果找到了其中一种<code>HandlerAdapter</code>是支持传过来的<code>controller</code>类型，那么该<code>HandlerAdapter</code>会调用自己的<code>handle</code>方法</li><li>不同的<code>HanlderAdapter</code>可以适应不同的request需求</li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="https://www.jianshu.com/p/3d6df6b725e4" target="_blank" rel="noopener">https://www.jianshu.com/p/3d6df6b725e4</a></p><p><a href="https://blog.csdn.net/weixin_38399962/article/details/85288660" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38399962/article/details/85288660</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前几章介绍了&lt;code&gt;HandlerMapping&lt;/code&gt;处理流程， &lt;code&gt;
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程</title>
    <link href="http://www.songshuiyang.site/2019/02/27/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E5%85%AD)%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E7%9A%84RequestMappingHandlerMapping%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/02/27/backend/spring/sourceCodeAnalysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程/</id>
    <published>2019-02-27T13:59:44.000Z</published>
    <updated>2019-03-03T02:27:39.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li>上一章节介绍了 <code>RequestMappingHandlerMapping</code> 这个 <code>HandlerMapping</code> 的加载过程，这一章节来介绍<code>RequestMappingHandlerMapping</code>实现流程</li></ul><h2 id="2-1-找到与请求对应的-Handler-解析"><a href="#2-1-找到与请求对应的-Handler-解析" class="headerlink" title="2.1 找到与请求对应的 Handler 解析"></a>2.1 找到与请求对应的 Handler 解析</h2><ul><li>还是回到这个方法<code>doDispatch(HttpServletRequest request, HttpServletResponse response)</code> ，下面的代码是发挥<code>RequestMappingHandlerMapping</code>作用的地方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line"><span class="comment">// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还是进入 <code>getHandler</code>方法，这里会遍历到我们的<code>RequestMappingHandlerMapping</code> 这个<code>HandlerMapping</code>，通过<code>HandlerExecutionChain handler = hm.getHandler(request);</code> 得到<code>HandlerExecutionChain</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(</span><br><span class="line">                    <span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain</span></span><br><span class="line">        HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意这里是找到第一个就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入<code>hm.getHandler(request);</code> 会跳到我们的<code>AbstractHandlerMapping</code> 类中，<code>RequestMappingHandlerMapping</code> 继承该类，由下面代码可以看到这里这里获取了 <code>handler</code> 及 <code>Interceptor</code> 并封装为<code>HandlerExecutionChain</code> 返回调用者 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look up a handler for the given request, falling back to the default</span></span><br><span class="line"><span class="comment"> * handler if no specific one is found.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the corresponding handler instance, or the default handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getHandlerInternal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里获取 处理器handler，模板方法实现， RequestMappingHandlerMapping 跳到 AbstractHandlerMethodMapping</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 拦截器Interceptor</span></span><br><span class="line">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">    <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">        CorsConfiguration globalConfig = <span class="keyword">this</span>.corsConfigSource.getCorsConfiguration(request);</span><br><span class="line">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">        CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>Object handler = getHandlerInternal(request);</code> 这里是获取<code>handler</code>的地方，这时又会跳到<code>AbstractHandlerMethodMapping</code> 类中，这样跳来跳去可以看到封装的特性及使用模板方法提高了扩展性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look up a handler method for the given request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求url路径 localhost:8080/pub/account/list &gt;&gt;&gt; /pub/account/list</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Looking up handler method for path "</span> + lookupPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mappingRegistry添加读锁，其他线程只能读不能写</span></span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据request获取对应的HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning handler method ["</span> + handlerMethod + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">"Did not find handler method for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注 <code>HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</code> 这行代码，进入该方法，可以看到这个方法的作用是得到<code>HandlerMethod</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找当前request请求 最为匹配的处理方法HandlerMethod，如果有多个匹配结果，则选择最佳匹配结果</span></span><br><span class="line"><span class="comment"> * Look up the best-matching handler method for the current request.</span></span><br><span class="line"><span class="comment"> * If multiple matches are found, the best match is selected.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lookupPath mapping lookup path within the current servlet mapping</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the best-matching handler method, or &#123;<span class="doctag">@code</span> null&#125; if no match</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handleMatch(Object, String, HttpServletRequest)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handleNoMatch(Set, String, HttpServletRequest)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;Match&gt;();</span><br><span class="line">    <span class="comment">// 根据URL来获取,springMVC会在初始化的时候建立URL和相应RequestMappingInfo的映射。如果不是restful接口，这里就可以直接获取到了， lookupPath: /pub/account/list</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配校验</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 全盘扫描</span></span><br><span class="line">        <span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到匹配结果</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">        Collections.sort(matches, comparator);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Found "</span> + matches.size() + <span class="string">" matching mapping(s) for ["</span> +</span><br><span class="line">                    lookupPath + <span class="string">"] : "</span> + matches);</span><br><span class="line">        &#125;</span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">            &#125;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果最佳匹配 第二佳匹配都是同一个则报错</span></span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Ambiguous handler methods mapped for HTTP path '"</span> +</span><br><span class="line">                        request.getRequestURL() + <span class="string">"': &#123;"</span> + m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置HttpServletRequest值</span></span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有找到匹配，返回null</span></span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看这行代码可以看到是通过url来获取<code>this.mappingRegistry.getMappingsByUrl(lookupPath);</code>，进入该方法，可以看到<code>this.urlLookup</code>是<code>MappingRegistry</code>类中的一个<code>Map</code>,直接通过 <code>url</code>为<code>key</code>得到值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MappingRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, HandlerMethod&gt; mappingLookup = <span class="keyword">new</span> LinkedHashMap&lt;T, HandlerMethod&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; urlLookup = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;HandlerMethod&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;HandlerMethod, CorsConfiguration&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getMappingsByUrl</span><span class="params">(String urlPath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  MultiValueMap&lt;String, T&gt; urlLookup 就是个map</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.urlLookup.get(urlPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>下图是this.urlLookup.get(urlPath) 的到的结果，返回的是个list</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/getMappingsByUrl.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li>返回到<code>lookupHandlerMethod(String lookupPath, HttpServletRequest request)</code> 方法，这里使用了<code>Match</code>做了匹配处理，得到最佳<code>Match bestMatch</code> 对象，最后返回<code>HandlerMethod</code>，在此终于得到了<code>HandlerMethod</code></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><p><code>RequestMappingHandlerMapping</code> 的主要功能就是通过 <code>reqeust</code> 获取 <code>HandlerExecutionChain</code> 的 <code>HandlerMethod</code>、<code>Interceptor</code>。</p></li><li><p>下图是<code>RequestMappingHandlerMapping</code>工作流程图，可以看到<code>RequestMappingHandlerMapping</code> 一个类的实现分了4层，<code>HandlerMapping</code> 接口定义顶级方法，两个抽象类又分两次封装，由上而下，逐渐细分功能</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestMappingInfoHandlerMapping.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一章节介绍了 &lt;code&gt;RequestMappingHandlerMapping&lt;/code
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程</title>
    <link href="http://www.songshuiyang.site/2019/02/26/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%BA%94)%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E7%9A%84RequestMappingHandlerMapping%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/02/26/backend/spring/sourceCodeAnalysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程/</id>
    <published>2019-02-26T12:59:44.000Z</published>
    <updated>2019-02-26T12:19:01.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li>上一章节介绍了<code>请求映射处理组件HandlerMapping</code>的主体处理流程，根据<code>request url</code> 获取对应的处理器<code>Handler</code>，这一章节来详细介绍我们平常最多使用的<code>RequestMappingHandlerMapping</code>的加载，这个<code>HandlerMapping</code> 是怎样加载基于<code>@Controller,@RequestMapping</code> 实现的<code>Controller</code></li></ul><h2 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h2><ul><li>接下来我们关注<code>RequestMappingHandlerMapping</code>这个<code>HandlerMapping</code>，因为这个是我们开发过程中最为常用的<code>HandlerMapping</code>，那么它是怎样实现<code>HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</code> 这个方法，先看一下<code>RequestMappingHandlerMapping</code>的继承关系</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestMappingHandlerMapping.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="2-1-1-RequestMappingHandlerMapping-加载过程"><a href="#2-1-1-RequestMappingHandlerMapping-加载过程" class="headerlink" title="2.1.1 RequestMappingHandlerMapping 加载过程"></a>2.1.1 <code>RequestMappingHandlerMapping</code> 加载过程</h3><ul><li><p>有上图可以看到<code>RequestMappingHandlerMapping</code> 的父类<code>AbstractHandlerMethodMapping</code> 实现了<code>InitializingBean</code> 接口，InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类， 在初始化bean的时候都会执行该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoked by a BeanFactory after it has set all bean properties supplied</span></span><br><span class="line"><span class="comment"> * (and satisfied BeanFactoryAware and ApplicationContextAware).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method allows the bean instance to perform initialization only</span></span><br><span class="line"><span class="comment"> * possible when all bean properties have been set and to throw an</span></span><br><span class="line"><span class="comment"> * exception in the event of misconfiguration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in the event of misconfiguration (such</span></span><br><span class="line"><span class="comment"> * as failure to set an essential property) or if initialization fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>AbstractHandlerMethodMapping</code>类 <code>afterPropertiesSet()</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>又抽象了一个方法，通过方法名可以得到是初始化<code>HandlerMethods</code>，进入<code>initHandlerMethods();</code> 方法，这个方法是扫描<code>ApplicationContext</code> 所有的bean，如果发现了该bean是<code>Handler</code>，并把它注册为<code>handler methods</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isHandler(Class)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod(Method, Class)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized(Map)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Looking for request mappings in application context: "</span> + getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先拿到容器的所有的beanName数组</span></span><br><span class="line">    String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :</span><br><span class="line">            getApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// 得到bean类型</span></span><br><span class="line">            Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beanType = getApplicationContext().getType(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Could not resolve target class for bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查bean所在的类是否有Controller注解及RequestMapping注解</span></span><br><span class="line">            <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">                <span class="comment">// 负责将Handler保存到Map里</span></span><br><span class="line">                detectHandlerMethods(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对Handler进行一些初始化，是一个模板方法</span></span><br><span class="line">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>String[] beanNames 示例</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/beanNames.jpg" alt="iamge" title="">                </div>                <div class="image-caption">iamge</div>            </figure><ul><li><p>进入<code>isHandler(beanType)</code>方法，，此方法由<code>RequestMappingHandlerMapping</code>实现， 此方法检查<code>bean</code>所在的类是否有<code>Controller</code>注解及<code>RequestMapping</code>注解，可以看到此方法的实现是在<code>RequestMappingHandlerMapping</code>里，是不是看到了我们熟悉的两个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查bean所在的类是否有Controller注解及RequestMapping注解</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * Expects a handler to have a type-level @&#123;<span class="doctag">@link</span> Controller&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果该<code>bean</code>有 <code>Controller</code>注解及<code>RequestMapping</code>注解，则执行<code>detectHandlerMethods(beanName);</code>方法，下面举个例子，我们有一个<code>UserController</code>里面有五个方法，下面来看是怎么处理这个类的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pub/account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/view"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">view</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">view</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        User user1 = userService.findById(user.getId());</span><br><span class="line">        user1.setUsername(<span class="string">"update"</span>);</span><br><span class="line">        userService.saveSelective(user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        userService.logicDeleteOne(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>detectHandlerMethods(beanName);</code>方法，可以看到<code>Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods</code> 获取到了我们五个方法，<code>Map&lt;Method, T&gt; methods</code> 以<code>Method</code>为key，<code>RequestMappingInfo</code>为value</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/detectHandlerMethods.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for handler methods in a handler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the bean name of a handler or a handler instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Handler的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">            getApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取 RequestMapping方法，会过滤掉普通方法</span></span><br><span class="line">    Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">            <span class="keyword">new</span> MethodIntrospector.MetadataLookup&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> T <span class="title">inspect</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">                                userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(methods.size() + <span class="string">" request handler methods found on "</span> + userType + <span class="string">": "</span> + methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123;</span><br><span class="line">        Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);</span><br><span class="line">        T mapping = entry.getValue();</span><br><span class="line">        <span class="comment">// 注册 mappingRegistry</span></span><br><span class="line">        registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>getMappingForMethod(method, userType)</code> ，此方法在<code>RequestMappingHandlerMapping</code>实现，这里解析分两步解析，一个是方法<code>method</code>解析，另一个是方法所在类<code>handlerType</code>的解析，然后拼接成一个<code>RequestMappingInfo</code>，可以看到也是对<code>RequestMapping</code>注解的解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有使用 &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>&#125; 注解会返回null</span></span><br><span class="line"><span class="comment"> * Uses method and type-level @&#123;<span class="doctag">@link</span> RequestMapping&#125; annotations to create</span></span><br><span class="line"><span class="comment"> * the RequestMappingInfo.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the created RequestMappingInfo, or &#123;<span class="doctag">@code</span> null&#125; if the method</span></span><br><span class="line"><span class="comment"> * does not have a &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>&#125; annotation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCustomMethodCondition(Method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCustomTypeCondition(Class)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析method的@RequestMapping</span></span><br><span class="line">    RequestMappingInfo info = createRequestMappingInfo(method);</span><br><span class="line">    <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析Class的@RequestMapping</span></span><br><span class="line">        RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);</span><br><span class="line">        <span class="keyword">if</span> (typeInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 合并两个RequestMappingInfo 比如url拼接</span></span><br><span class="line">            info = typeInfo.combine(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是RequestMapping方法返回null</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestMappingInfo <span class="title">createRequestMappingInfo</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿到注解</span></span><br><span class="line">        RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);</span><br><span class="line">        RequestCondition&lt;?&gt; condition = (element <span class="keyword">instanceof</span> Class ?</span><br><span class="line">                getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));</span><br><span class="line">        <span class="keyword">return</span> (requestMapping != <span class="keyword">null</span> ? createRequestMappingInfo(requestMapping, condition) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">createRequestMappingInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用@RequestMapping的属性生成RequestMappingInfo</span></span><br><span class="line">    <span class="keyword">return</span> RequestMappingInfo</span><br><span class="line">            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))</span><br><span class="line">            .methods(requestMapping.method())</span><br><span class="line">            .params(requestMapping.params())</span><br><span class="line">            .headers(requestMapping.headers())</span><br><span class="line">            .consumes(requestMapping.consumes())</span><br><span class="line">            .produces(requestMapping.produces())</span><br><span class="line">            .mappingName(requestMapping.name())</span><br><span class="line">            .customCondition(customCondition)</span><br><span class="line">            .options(<span class="keyword">this</span>.config)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RequestMappingInfo.java 对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingInfo</span> <span class="keyword">implements</span> <span class="title">RequestCondition</span>&lt;<span class="title">RequestMappingInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PatternsRequestCondition patternsCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestMethodsRequestCondition methodsCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamsRequestCondition paramsCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HeadersRequestCondition headersCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumesRequestCondition consumesCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProducesRequestCondition producesCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestConditionHolder customConditionHolder;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>返回到<code>detectHandlerMethods</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Handler的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">            getApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取 RequestMapping方法，会过滤掉普通方法</span></span><br><span class="line">    Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">            <span class="keyword">new</span> MethodIntrospector.MetadataLookup&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> T <span class="title">inspect</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">                                userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(methods.size() + <span class="string">" request handler methods found on "</span> + userType + <span class="string">": "</span> + methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123;</span><br><span class="line">        Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);</span><br><span class="line">        T mapping = entry.getValue();</span><br><span class="line">        <span class="comment">// 注册 mappingRegistry</span></span><br><span class="line">        registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>得到<code>Map&lt;Method, T&gt; methods</code>方法之后，就是把这些信息保存起来，<code>registerHandlerMethod(handler, invocableMethod, mapping);</code> 这行代码就是做的这个功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">        assertUniqueMethodMapping(handlerMethod, mapping);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Mapped \""</span> + mapping + <span class="string">"\" onto "</span> + handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">        <span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">            <span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">            addMappingName(name, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">        <span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = new HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;();</span></span><br><span class="line"><span class="comment">         * key: RequestMappingInfo</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;T&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry</code> 对象，见下图<code>key</code>值是<code>RequestMappingInfo</code> <code>value</code>是<code>MappingRegistration</code></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/registry.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>MappingRegistration.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MappingRegistration</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T mapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerMethod handlerMethod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; directUrls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mappingName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><p><code>Spring Mvc</code>提供了各种各样的抽象，你能感受到面向对象的魅力。</p><ul><li><p><code>RequestMappingInfo</code> 这个类是对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。</p></li><li><p><code>HandlerMethod</code>这个类封装了处理器实例<code>（Controller Bean）</code>和 处理方法实例<code>（Method）</code>以及方法参数数组<code>（MethodParameter[]）</code></p></li><li><p><code>MethodParameter</code>  这个类从2.0就有了，它封装了方法某个参数的相关信息及行为，如该参数的索引，该参数所属方法实例或构造器实例，该参数的类型等。</p></li><li><p><code>HandlerMapping</code> 该接口的实现类用来定义请求和处理器之前的映射关系，其中只定义了一个方法<code>getHandler</code>。</p></li><li><p><code>AbstractHandlerMethodMapping</code> 这是<code>HandlerMapping</code>的一个基本实现类，该类定义了请求与<code>HandlerMethod</code>实例的映射关系。</p></li><li><p><code>RequestMappingInfoHandlerMapping</code>这个是<code>AbstractHandlerMethodMapping</code>的实现类，他维护了一个<code>RequestMappingInfo</code>和<code>HandlerMethod</code>的Map属性。</p></li><li><p><code>RequestMappingHandlerMapping</code> 这个是<code>RequestMappingInfoHandlerMapping</code>的子类，它将<code>@RequestMapping</code>注解转化为<code>RequestMappingInfo</code>实例，并为父类使用。也就是我们处理@RequestMapping的终点。</p></li><li><p><code>InitializingBean</code> 这个接口定义了其实现<code>Bean</code>在容器完成属性设置后可以执行自定义初始化操作，我们的<code>AbstractHandlerMethodMapping</code>便实现了这个接口，并且定义了一组自定义操作，就是用来检测处理我们的@RequestMapping注解。</p></li></ul></li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="https://www.cnblogs.com/taotingkai/p/8438360.html" target="_blank" rel="noopener">https://www.cnblogs.com/taotingkai/p/8438360.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一章节介绍了&lt;code&gt;请求映射处理组件HandlerMapping&lt;/code&gt;的主体处理流
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
</feed>
