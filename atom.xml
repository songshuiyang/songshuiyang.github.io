<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋水阳个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.songshuiyang.site/"/>
  <updated>2019-03-10T13:04:25.064Z</updated>
  <id>http://www.songshuiyang.site/</id>
  
  <author>
    <name>songshuiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM垃圾回收(二)垃圾回收器</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%BA%8C)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(二)垃圾回收器/</id>
    <published>2019-03-10T13:59:44.000Z</published>
    <updated>2019-03-10T13:04:25.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</li><li>Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的回收器可能会有很大差异，一般是提供参数供用户根据自己的应用特点和要求组合各个年代所使用的回收器</li><li>这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图3-5所示</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/hotspot.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><ul><li>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。</li><li>大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</li><li>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcj1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-Serial-Old-收集器"><a href="#2-Serial-Old-收集器" class="headerlink" title="2. Serial Old 收集器"></a>2. Serial Old 收集器</h3><ul><li>Serial收集器的老年代版本，它同样是一个单线程收集器。</li><li>它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</li></ul><h3 id="3-ParNew-收集器"><a href="#3-ParNew-收集器" class="headerlink" title="3. ParNew 收集器"></a>3. ParNew 收集器</h3><ul><li>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</li><li>并行和并发概念补充：<ul><li>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj2.jpg" alt=""></p><h3 id="4-Parallel-Old收集器"><a href="#4-Parallel-Old收集器" class="headerlink" title="4. Parallel Old收集器"></a>4. Parallel Old收集器</h3><ul><li>Parallel Scavenge收集器的老年代版本。</li><li>使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</li></ul><h3 id="5-Parallel-Scavenge收集器"><a href="#5-Parallel-Scavenge收集器" class="headerlink" title="5. Parallel Scavenge收集器"></a>5. Parallel Scavenge收集器</h3><ul><li>Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？</li><li><p>Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代并行</span><br></pre></td></tr></table></figure></li><li><p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</p></li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li></ul><p><img src="/images/server/java/JVM/gcj3.jpg" alt=""></p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><ul><li>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</li><li>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</li><li>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：<ul><li>初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li><li>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj4.jpg" alt=""></p><ul><li><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p><ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h3></li></ul></li><li><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p></li><li><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点</p><ul><li>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul></li><li>G1收集器的运作大致分为以下几个步骤：<ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul></li><li>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</li></ul><h2 id="GC参数的整理"><a href="#GC参数的整理" class="headerlink" title="GC参数的整理"></a>GC参数的整理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC：在新生代和老年代使用串行收集器</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio：设置eden区大小和survivior区大小的比例</span><br><span class="line"></span><br><span class="line">-XX:NewRatio:新生代和老年代的比</span><br><span class="line"></span><br><span class="line">-XX:+UseParNewGC：在新生代使用并行收集器</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelGC ：新生代使用并行回收收集器</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC：老年代使用并行回收收集器</span><br><span class="line"></span><br><span class="line">-XX:ParallelGCThreads：设置用于垃圾回收的线程数</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器</span><br><span class="line"></span><br><span class="line">-XX:ParallelCMSThreads：设定CMS的线程数量</span><br><span class="line"></span><br><span class="line">-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发</span><br><span class="line"></span><br><span class="line">-XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理</span><br><span class="line"></span><br><span class="line">-XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩</span><br><span class="line"></span><br><span class="line">-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收</span><br><span class="line"></span><br><span class="line">-XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收</span><br><span class="line"></span><br><span class="line">-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收</span><br></pre></td></tr></table></figure><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html</a></li><li><a href="https://blog.csdn.net/qq_34337272/article/details/82177383" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/82177383</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。&lt;/li&gt;
&lt;li&gt;Java虚拟机规范对垃圾回收器应该如
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(一)垃圾回收算法</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%B8%80)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(一)垃圾回收算法/</id>
    <published>2019-03-10T13:59:44.000Z</published>
    <updated>2019-03-10T12:18:12.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p></li><li><p>而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p></li></ul><h2 id="判断对象是否存活的算法"><a href="#判断对象是否存活的算法" class="headerlink" title="判断对象是否存活的算法"></a>判断对象是否存活的算法</h2><ul><li>垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧）</li></ul><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><p>一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><ul><li>通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcroots.JPEG" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>上图中每个对象都存在引用链与GCRoots相连，表明对象还在，不能回收。有图中三个对象虽然互相引用，但是没有链接与GCRoots相连，则可判断它们是可回收的对象。</p></li><li><p>彻底死亡条件：</p><ul><li>条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。</li><li>条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。</li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>该算法是最基础的收集算法，算法分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象</p></li><li><p>之所以说它是最基础的算法是因为后续的算法都是基于这种思路并对其不足进行改进而得到的</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>效率不足</li><li>会产生大量不连续的内存碎片，碎片过多的话再分配一个较大对象时就无容身之地从而不得不提前触发另一次垃圾收集</li></ol><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>为了解决效率问题，此算法把内存划分为相等大小的两个区域，每一只使用其中一个，回收过程中将存活的对象全部复制到另一个区域中，清空原区域。在年轻代中eden区和两个survivor区就是使用了此种算法。这种算法只复制存活的对象，成本较低，而且不会出现内存碎片问题</p></li><li><p>现在的商业虚拟机都采用这种算法来回收新生代</p></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>费内存，需要2倍的内存空间</li></ol><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>该算法标记阶段和标记-清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。效率比“标记-清理”算法低，但不会产生内存碎片。</li></ul><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/aspirant/p/8662690.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8662690.html</a></li><li><a href="http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor</title>
    <link href="http://www.songshuiyang.site/2019/03/06/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%B9%9D)RequestBody%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E4%B9%8BRequestResponseBodyMethodProcessor/"/>
    <id>http://www.songshuiyang.site/2019/03/06/backend/spring/sourceCodeAnalysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor/</id>
    <published>2019-03-06T12:59:44.000Z</published>
    <updated>2019-03-10T01:44:49.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li><p><code>RequestResponseBodyMethodProcessor</code> 的作用是处理被<code>@RequestBody</code>注解的参数，和<code>@ResponseBody</code>注解的返回值</p></li><li><p>查看<code>RequestResponseBodyMethodProcessor</code>继承关系，可以看到它是同时继承了<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>，所以就是说它同时具有参数对象解析及结果对象解析的功能，野心很大</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestResponseBodyMethodProcessor.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h2><blockquote><p>RequestResponseBodyMethodProcessor.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理被<span class="doctag">@RequestBody</span>注解的参数，和<span class="doctag">@ResponseBody</span>注解的返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Resolves method arguments annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; and handles return</span></span><br><span class="line"><span class="comment"> * values from methods annotated with &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; by reading and writing</span></span><br><span class="line"><span class="comment"> * to the body of the request or response with an &#123;<span class="doctag">@link</span> HttpMessageConverter&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; method argument is also validated if it is annotated</span></span><br><span class="line"><span class="comment"> * with &#123;<span class="doctag">@code</span> <span class="doctag">@javax</span>.validation.Valid&#125;. In case of validation failure,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> MethodArgumentNotValidException&#125; is raised and results in an HTTP 400</span></span><br><span class="line"><span class="comment"> * response status code if &#123;<span class="doctag">@link</span> DefaultHandlerExceptionResolver&#125; is configured.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic constructor with converters only. Suitable for resolving</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125;. For handling &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; consider also</span></span><br><span class="line"><span class="comment"> * providing a &#123;<span class="doctag">@code</span> ContentNegotiationManager&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(converters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic constructor with converters and &#123;<span class="doctag">@code</span> ContentNegotiationManager&#125;.</span></span><br><span class="line"><span class="comment"> * Suitable for resolving &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; and handling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; without &#123;<span class="doctag">@code</span> Request~&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ResponseBodyAdvice&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters,</span></span></span><br><span class="line"><span class="function"><span class="params">ContentNegotiationManager manager)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(converters, manager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Complete constructor for resolving &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; method arguments.</span></span><br><span class="line"><span class="comment"> * For handling &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125; consider also providing a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ContentNegotiationManager&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters,</span></span></span><br><span class="line"><span class="function"><span class="params">List&lt;Object&gt; requestResponseBodyAdvice)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(converters, <span class="keyword">null</span>, requestResponseBodyAdvice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Complete constructor for resolving &#123;<span class="doctag">@code</span> <span class="doctag">@RequestBody</span>&#125; and handling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@ResponseBody</span>&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestResponseBodyMethodProcessor</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters,</span></span></span><br><span class="line"><span class="function"><span class="params">ContentNegotiationManager manager, List&lt;Object&gt; requestResponseBodyAdvice)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(converters, manager, requestResponseBodyAdvice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测参数是否使用了<span class="doctag">@RequestBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测返回结果是否使用了<span class="doctag">@ResponseBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理被<span class="doctag">@RequestBody</span>注解的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment"> * converter to read the content with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line">Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line"><span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">validateIfApplicable(binder, parameter);</span><br><span class="line"><span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter descriptor (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramType the type of the argument value to be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotSupportedException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type paramType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">ServletServerHttpRequest inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line"></span><br><span class="line">Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (checkRequired(parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"Required request body is missing: "</span> +</span><br><span class="line">parameter.getMethod().toGenericString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查RequestBody注解是否required</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkRequired</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (parameter.getParameterAnnotation(RequestBody.class).required() &amp;&amp; !parameter.isOptional());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理<span class="doctag">@ResponseBody</span>注解的返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotAcceptableException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotWritableException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span></span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-1-1-处理被-RequestBody注解的参数解析"><a href="#2-1-1-处理被-RequestBody注解的参数解析" class="headerlink" title="2.1.1 处理被@RequestBody注解的参数解析"></a>2.1.1 处理被@RequestBody注解的参数解析</h3><ul><li><p>参数解析需要关注此类是怎么实现的<code>HandlerMethodArgumentResolver</code>接口的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method parameter&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this resolver.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this resolver supports the supplied parameter;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据request解析方法参数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Resolves a method parameter into an argument value from a given request.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> ModelAndViewContainer&#125; provides access to the model for the</span></span><br><span class="line"><span class="comment"> * request. A &#123;<span class="doctag">@link</span> WebDataBinderFactory&#125; provides a way to create</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@link</span> WebDataBinder&#125; instance when needed for data binding and</span></span><br><span class="line"><span class="comment"> * type conversion purposes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to resolve. This parameter must</span></span><br><span class="line"><span class="comment"> * have previously been passed to &#123;<span class="doctag">@link</span> #supportsParameter&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> binderFactory a factory for creating &#123;<span class="doctag">@link</span> WebDataBinder&#125; instances</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resolved argument value, or &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors with the preparation of argument values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">* 查看`<span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;`方法的实现，实现很简单就是判断是否使用了<span class="meta">@RequestBody</span>注解</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测参数是否使用了<span class="doctag">@RequestBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</code> 方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理被<span class="doctag">@RequestBody</span>注解的参数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Throws MethodArgumentNotValidException if validation fails.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotReadableException if &#123;<span class="doctag">@link</span> RequestBody#required()&#125;</span></span><br><span class="line"><span class="comment"> * is &#123;<span class="doctag">@code</span> true&#125; and there is no body content or if there is no suitable</span></span><br><span class="line"><span class="comment"> * converter to read the content with.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">parameter = parameter.nestedIfOptional();</span><br><span class="line"><span class="comment">// 主体逻辑</span></span><br><span class="line">Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line"><span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 校验参数是否正确 @Valid注解开启</span></span><br><span class="line">validateIfApplicable(binder, parameter);</span><br><span class="line"><span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"><span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(NativeWebRequest webRequest, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type paramType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">ServletServerHttpRequest inputMessage = <span class="keyword">new</span> ServletServerHttpRequest(servletRequest);</span><br><span class="line">    <span class="comment">// 主体逻辑</span></span><br><span class="line">Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</span><br><span class="line"><span class="keyword">if</span> (arg == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (checkRequired(parameter)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"Required request body is missing: "</span> +</span><br><span class="line">parameter.getMethod().toGenericString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续进入<code>Object arg = readWithMessageConverters(inputMessage, parameter, paramType);</code> ，可以看到是遍历 <code>this.messageConverters</code> 选择适合的消息处理器来处理参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the method argument value of the expected parameter type by reading</span></span><br><span class="line"><span class="comment"> * from the given HttpInputMessage.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the expected type of the argument value to be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputMessage the HTTP input message representing the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter descriptor (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetType the target type, not necessarily the same as the method</span></span><br><span class="line"><span class="comment"> * parameter type, e.g. for &#123;<span class="doctag">@code</span> HttpEntity&lt;String&gt;&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the created method argument value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException if the reading from the request fails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotSupportedException if no suitable message converter is found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">Object <span class="title">readWithMessageConverters</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter,</span></span></span><br><span class="line"><span class="function"><span class="params">Type targetType)</span> <span class="keyword">throws</span> IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException </span>&#123;</span><br><span class="line"></span><br><span class="line">MediaType contentType;</span><br><span class="line"><span class="keyword">boolean</span> noContentType = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">contentType = inputMessage.getHeaders().getContentType();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvalidMediaTypeException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (contentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">noContentType = <span class="keyword">true</span>;</span><br><span class="line">contentType = MediaType.APPLICATION_OCTET_STREAM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; contextClass = (parameter != <span class="keyword">null</span> ? parameter.getContainingClass() : <span class="keyword">null</span>);</span><br><span class="line">Class&lt;T&gt; targetClass = (targetType <span class="keyword">instanceof</span> Class ? (Class&lt;T&gt;) targetType : <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">ResolvableType resolvableType = (parameter != <span class="keyword">null</span> ?</span><br><span class="line">ResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType));</span><br><span class="line">targetClass = (Class&lt;T&gt;) resolvableType.resolve();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod();</span><br><span class="line">Object body = NO_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">inputMessage = <span class="keyword">new</span> EmptyBodyCheckingHttpInputMessage(inputMessage);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历 this.messageConverters 选择适合的消息处理器来处理参数</span></span><br><span class="line"><span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; converter : <span class="keyword">this</span>.messageConverters) &#123;</span><br><span class="line">Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();</span><br><span class="line"><span class="keyword">if</span> (converter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter;</span><br><span class="line"><span class="comment">// 判断是否适合处理参数</span></span><br><span class="line"><span class="keyword">if</span> (genericConverter.canRead(targetType, contextClass, contentType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">body = genericConverter.read(targetType, contextClass, inputMessage);</span><br><span class="line">body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (converter.canRead(targetClass, contentType)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Read ["</span> + targetType + <span class="string">"] as \""</span> + contentType + <span class="string">"\" with ["</span> + converter + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inputMessage.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);</span><br><span class="line">body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage);</span><br><span class="line">body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">body = getAdvice().handleEmptyBody(<span class="keyword">null</span>, inputMessage, parameter, targetType, converterType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMessageNotReadableException(<span class="string">"I/O error while reading input message"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (body == NO_VALUE) &#123;</span><br><span class="line"><span class="keyword">if</span> (httpMethod == <span class="keyword">null</span> || !SUPPORTED_METHODS.contains(httpMethod) ||</span><br><span class="line">(noContentType &amp;&amp; inputMessage.getBody() == <span class="keyword">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> HttpMediaTypeNotSupportedException(contentType, <span class="keyword">this</span>.allSupportedMediaTypes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>this.messageConverters</code>有哪些呢？见下图</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/MessageConverters.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>下图是主要<code>MessageConverter</code>的功能介绍</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/MessageConverter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-1-2-处理被-ResponseBody注解的返回值解析"><a href="#2-1-2-处理被-ResponseBody注解的返回值解析" class="headerlink" title="2.1.2 处理被@ResponseBody注解的返回值解析"></a>2.1.2 处理被@ResponseBody注解的返回值解析</h3><ul><li><p>返回值解析需要关注此类是怎样实现<code>HandlerMethodArgumentResolver</code>接口的方法的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method return type&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this handler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this handler supports the supplied return type;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理结果集</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Handle the given return value by adding attributes to the model and</span></span><br><span class="line"><span class="comment"> * setting a view or setting the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ModelAndViewContainer#setRequestHandled&#125; flag to &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * to indicate the response has been handled directly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the return value handling results in an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>boolean supportsReturnType(MethodParameter returnType);</code>的方法的实现，实现也很简单就是判断是否使用了@ResponseBody注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测返回结果是否使用了<span class="doctag">@ResponseBody</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||</span><br><span class="line">returnType.hasMethodAnnotation(ResponseBody.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理<span class="doctag">@ResponseBody</span>注解的返回值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMediaTypeNotAcceptableException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> HttpMessageNotWritableException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line">ServletServerHttpRequest inputMessage = createInputMessage(webRequest);</span><br><span class="line">ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try even with null return value. ResponseBodyAdvice could get involved.</span></span><br><span class="line">writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li>我们知道，Http请求和响应报文本质上都是一串字符串，当请求报文来到java世界，它会被封装成为一个ServletInputStream的输入流，供我们读取报文。响应报文则是通过一个ServletOutputStream的输出流，来输出响应报文，我们得到输入输出流之后需要把它转成我们的java实体类对象，这个是怎样转换的呢，就是通过我们的<code>HttpMessageConverter</code>消息转换器来实现的</li><li><p>下图是<code>HttpMessageConverter</code>的工作流程图</p><p><img src="/images/server/spring/spring-mvc/HttpMessageConverter.png" alt=""></p></li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="https://my.oschina.net/lichhao/blog/172562" target="_blank" rel="noopener">https://my.oschina.net/lichhao/blog/172562</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;RequestResponseBodyMethodProcessor&lt;/cod
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(六)方法区</title>
    <link href="http://www.songshuiyang.site/2019/03/03/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E5%85%AD)%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://www.songshuiyang.site/2019/03/03/backend/Java/JVM/JVM运行时数据区域(六)方法区/</id>
    <published>2019-03-03T13:59:44.000Z</published>
    <updated>2019-03-10T12:17:11.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。</p></li><li><p>对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。</p></li><li><p>Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出<br>OutOfMemoryError 异常。</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li><p>运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p></li><li><p>Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规<em> 定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、</em> 装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的<em> 提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除</em> 了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常* 量池中。</p></li><li><p>运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语<em> 言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容</em> 才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发* 人员利用得比较多的便是String 类的intern() 方法。</p></li><li><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无* 法再申请到内存时会抛出OutOfMemoryError 异常 </p></li></ul><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(五)堆</title>
    <link href="http://www.songshuiyang.site/2019/03/03/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%BA%94)%E5%A0%86/"/>
    <id>http://www.songshuiyang.site/2019/03/03/backend/Java/JVM/JVM运行时数据区域(五)堆/</id>
    <published>2019-03-03T13:59:44.000Z</published>
    <updated>2019-03-10T12:18:12.494Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。</p></li><li><p>对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p></li><li><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。</p></li><li><p>根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p><h2 id="内存溢出及内存泄漏"><a href="#内存溢出及内存泄漏" class="headerlink" title="内存溢出及内存泄漏"></a>内存溢出及内存泄漏</h2></li></ul><h3 id="1、内存溢出-out-of-memory"><a href="#1、内存溢出-out-of-memory" class="headerlink" title="1、内存溢出 out of memory"></a>1、内存溢出 out of memory</h3><ul><li>是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出</li></ul><h4 id="1-1-方法区溢出-out-of-memory-PermGen-space"><a href="#1-1-方法区溢出-out-of-memory-PermGen-space" class="headerlink" title="1.1 方法区溢出 out of memory: PermGen space"></a>1.1 方法区溢出 out of memory: PermGen space</h4><h4 id="1-2-本机直接内存溢出"><a href="#1-2-本机直接内存溢出" class="headerlink" title="1.2 本机直接内存溢出"></a>1.2 本机直接内存溢出</h4><h3 id="2、内存泄露-memory-leak"><a href="#2、内存泄露-memory-leak" class="headerlink" title="2、内存泄露 memory leak"></a>2、内存泄露 memory leak</h3><ul><li><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光</p></li><li><p>memory leak会最终会导致out of memory！</p></li><li><p>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 </p></li><li><p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. </p></li><li><p>从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到</p></li></ul><h3 id="3、引起内存溢出的原因"><a href="#3、引起内存溢出的原因" class="headerlink" title="3、引起内存溢出的原因"></a>3、引起内存溢出的原因</h3><ul><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>使用的第三方软件中的BUG；</li><li>使用的第三方软件中的BUG；</li></ul><h3 id="4、内存溢出的解决方案"><a href="#4、内存溢出的解决方案" class="headerlink" title="4、内存溢出的解决方案"></a>4、内存溢出的解决方案</h3><ul><li>修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</li><li>检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</li><li>对代码进行走查和分析，找出可能发生内存溢出的位置。</li></ul><p>## </p><blockquote><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p><ul><li>-Xmx3550m：设置JVM最大可用内存为3550M。</li><li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</li><li>-Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li><li></li></ul></blockquote><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/Sharley/p/5285045.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sharley/p/5285045.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(四)本地方法栈</title>
    <link href="http://www.songshuiyang.site/2019/03/03/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E5%9B%9B)%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    <id>http://www.songshuiyang.site/2019/03/03/backend/Java/JVM/JVM运行时数据区域(四)本地方法栈/</id>
    <published>2019-03-03T13:59:44.000Z</published>
    <updated>2019-03-10T12:16:45.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h2 id="Native-Method"><a href="#Native-Method" class="headerlink" title="Native Method"></a>Native Method</h2><ul><li><p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数</p></li><li><p>例如 <code>Object.java</code> 类下就有很多<code>Native Method</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></li><li><p>本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。</p></li><li><p>为什么要使用Native Method</p><ul><li>与java环境外交互：有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。</li><li>与操作系统交互：JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li><li>Sun’s Java： Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/qq_28885149/article/details/52672475" target="_blank" rel="noopener">https://blog.csdn.net/qq_28885149/article/details/52672475</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Jav
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(八)RequestMappingHanlderAdapter</title>
    <link href="http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E5%85%AB)RequestMappingHanlderAdapter/"/>
    <id>http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring Mvc源码(八)RequestMappingHanlderAdapter/</id>
    <published>2019-03-03T03:59:44.000Z</published>
    <updated>2019-03-10T01:44:49.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li><code>RequestMappingHanlderAdapter</code>是 <code>HanlderAdapter</code> 中最复杂的也是最常用的处理适配器，他的作用是根据<code>HanlderMapping</code>找到的<code>Handler</code>调用我们<code>Controller</code> 里的方法</li><li>既然是调用方法我们推测它的工作应该主要设及3步， 1、方法参数绑定，2、方法执行，3、返回结果处理 ， 方法执行的流程已经在代码里写好了，重点是参数绑定及结果处理，各个方法参数类型不同个数不同，想想就复杂，下面来看人家是怎么做的</li></ul><h2 id="2-1-RequestMappingHanlderAdapter初始化解析"><a href="#2-1-RequestMappingHanlderAdapter初始化解析" class="headerlink" title="2.1 RequestMappingHanlderAdapter初始化解析"></a>2.1 RequestMappingHanlderAdapter初始化解析</h2><ul><li>查看<code>RequestMappingHanlderAdapter</code>的继承关系</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestMappingHandlerAdapter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>RequestMappingHandlerAdapter.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@link</span> AbstractHandlerMethodAdapter&#125; that supports &#123;<span class="doctag">@link</span> HandlerMethod&#125;s</span></span><br><span class="line"><span class="comment"> * with their method argument and return type signature, as defined via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Support for custom argument and return value types can be added via</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125; and &#123;<span class="doctag">@link</span> #setCustomReturnValueHandlers&#125;.</span></span><br><span class="line"><span class="comment"> * Or alternatively, to re-configure all argument and return value types,</span></span><br><span class="line"><span class="comment"> * use &#123;<span class="doctag">@link</span> #setArgumentResolvers&#125; and &#123;<span class="doctag">@link</span> #setReturnValueHandlers&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodArgumentResolver</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodReturnValueHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodAdapter</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于给处理器方法和注释了@ModelAttribute的方法设置参数</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodArgumentResolverComposite argumentResolvers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于添加了@initBinder的方法设置参数</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于将处理器的返回值处理为ModelAndView类型</span></span><br><span class="line"><span class="keyword">private</span> HandlerMethodReturnValueHandlerComposite returnValueHandlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;ModelAndViewResolver&gt; modelAndViewResolvers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ContentNegotiationManager contentNegotiationManager = <span class="keyword">new</span> ContentNegotiationManager();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; requestResponseBodyAdvice = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> WebBindingInitializer webBindingInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AsyncTaskExecutor taskExecutor = <span class="keyword">new</span> SimpleAsyncTaskExecutor(<span class="string">"MvcAsync"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long asyncRequestTimeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CallableProcessingInterceptor[] callableInterceptors = <span class="keyword">new</span> CallableProcessingInterceptor[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> DeferredResultProcessingInterceptor[] deferredResultInterceptors = <span class="keyword">new</span> DeferredResultProcessingInterceptor[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ignoreDefaultModelOnRedirect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cacheSecondsForSessionAttributeHandlers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> synchronizeOnSession = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SessionAttributeStore sessionAttributeStore = <span class="keyword">new</span> DefaultSessionAttributeStore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SessionAttributesHandler&gt; sessionAttributesHandlerCache =</span><br><span class="line"><span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, SessionAttributesHandler&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; initBinderCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache =</span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; modelAttributeCache = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache =</span><br><span class="line"><span class="keyword">new</span> LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestMappingHandlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">StringHttpMessageConverter stringHttpMessageConverter = <span class="keyword">new</span> StringHttpMessageConverter();</span><br><span class="line">stringHttpMessageConverter.setWriteAcceptCharset(<span class="keyword">false</span>);  <span class="comment">// see SPR-7316</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.messageConverters = <span class="keyword">new</span> ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> ByteArrayHttpMessageConverter());</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(stringHttpMessageConverter);</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> SourceHttpMessageConverter&lt;Source&gt;());</span><br><span class="line"><span class="keyword">this</span>.messageConverters.add(<span class="keyword">new</span> AllEncompassingFormHttpMessageConverter());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到实现了<code>InitializingBean</code>接口，这个方法注册了<code>this.argumentResolvers</code> <code>this.initBinderArgumentResolvers</code> <code>this.returnValueHandlers</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line">initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();</span><br><span class="line"><span class="keyword">this</span>.argumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.initBinderArgumentResolvers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();</span><br><span class="line"><span class="keyword">this</span>.initBinderArgumentResolvers = <span class="keyword">new</span> HandlerMethodArgumentResolverComposite().addResolvers(resolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers = <span class="keyword">new</span> HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例如<code>getDefaultArgumentResolvers方法</code>，可以看到是直接写死了有那些默认的参数解析组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of argument resolvers to use including built-in resolvers</span></span><br><span class="line"><span class="comment"> * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;HandlerMethodArgumentResolver&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.PathVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.SessionAttributeMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type-based argument resolution</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletResponseMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.RedirectAttributesMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Custom arguments</span></span><br><span class="line"><span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Catch-all</span></span><br><span class="line">resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">resolvers.add(<span class="keyword">new</span> org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-处理解析"><a href="#2-2-处理解析" class="headerlink" title="2.2 处理解析"></a>2.2 处理解析</h2><ul><li><p><code>RequestMappingHanlderAdapter</code> 处理请求入口方法是<code>handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod)</code>，进入该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">  HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ModelAndView mav;</span><br><span class="line">checkRequest(request);</span><br><span class="line"><span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 具体执行请求的处理</span></span><br><span class="line"><span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line"><span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>mav = invokeHandlerMethod(request, response, handlerMethod);</code>方法，进入该方法之后可以看到该方法主要是一些参数准备及组装各种处理单元，先备兵粮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the &#123;<span class="doctag">@link</span> RequestMapping&#125; handler method preparing a &#123;<span class="doctag">@link</span> ModelAndView&#125;</span></span><br><span class="line"><span class="comment"> * if view resolution is required.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createInvocableHandlerMethod(HandlerMethod)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建WebDataBinder，WebDataBinder用于参数绑定，将符合条件的注释了@InitBinder的方法找出来</span></span><br><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line"><span class="comment">// 用来处理Model，在处理器具体处理之前对Model进行初始化，在处理完请求之后对Model参数进行更新</span></span><br><span class="line">ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成</span></span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ModelAndViewContainer承载着整个请求过程中数据的传递工作</span></span><br><span class="line">ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">webRequest.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个方法重点关注<code>ServletInvocableHandlerMethod</code>此对象，该类继承自<code>HandlerMethod</code>，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成</span></span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br></pre></td></tr></table></figure><ul><li><p>查看上面代码可以看到这里设置了参数解析器 结果解析器 等等</p></li><li><p><code>ServletInvocableHandlerMethod</code> 解析</p><ul><li><p>先查看<code>ServletInvocableHandlerMethod</code>的继承关系，此类的继承关系有三层</p><p><img src="/images/server/spring/spring-mvc/ServletInvocableHandlerMethod.png" alt=""></p></li><li><p>顶层<code>HandlerMethod</code>类，该类封装了方法调用相关信息，比如是属于哪个<code>bean</code>下的的，那个<code>Method</code>，方法的参数<code>MethodParameter[]</code>等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装了方法调用相关信息,子类还提供调用,参数准备和返回值处理的职责</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Encapsulates information about a handler method consisting of a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getMethod() method&#125; and a &#123;<span class="doctag">@linkplain</span> #getBean() bean&#125;.</span></span><br><span class="line"><span class="comment"> * Provides convenient access to method parameters, the method return value,</span></span><br><span class="line"><span class="comment"> * method annotations, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The class may be created with a bean instance or with a bean name</span></span><br><span class="line"><span class="comment"> * (e.g. lazy-init bean, prototype bean). Use &#123;<span class="doctag">@link</span> #createWithResolvedBean()&#125;</span></span><br><span class="line"><span class="comment"> * to obtain a &#123;<span class="doctag">@code</span> HandlerMethod&#125; instance with a bean instance resolved</span></span><br><span class="line"><span class="comment"> * through the associated &#123;<span class="doctag">@link</span> BeanFactory&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Sam Brannen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Logger that is available to subclasses */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; beanType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method bridgedMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodParameter[] parameters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpStatus responseStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String responseStatusReason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class="line">  </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p><code>InvocableHandlerMethod</code> 类 <code>HandlerMethod</code>类的基础上添加了方法调用功能及注册了参数解析组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 HandlerMethod类的基础上添加了方法调用功能及注册了参数解析组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Provides a method for invoking the handler method for a given request after resolving its</span></span><br><span class="line"><span class="comment"> * method argument values through registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Argument resolution often requires a &#123;<span class="doctag">@link</span> WebDataBinder&#125; for data binding or for type</span></span><br><span class="line"><span class="comment"> * conversion. Use the &#123;<span class="doctag">@link</span> #setDataBinderFactory(WebDataBinderFactory)&#125; property to supply</span></span><br><span class="line"><span class="comment"> * a binder factory to pass to argument resolvers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Use &#123;<span class="doctag">@link</span> #setHandlerMethodArgumentResolvers&#125; to customize the list of argument resolvers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocableHandlerMethod</span> <span class="keyword">extends</span> <span class="title">HandlerMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于参数解析器ArgumentResolver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> WebDataBinderFactory dataBinderFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> org.springframework.web.method.support.HandlerMethodArgumentResolverComposite argumentResolvers = <span class="keyword">new</span> org.springframework.web.method.support.HandlerMethodArgumentResolverComposite();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来获取参数名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create an instance from a &#123;<span class="doctag">@code</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InvocableHandlerMethod</span><span class="params">(HandlerMethod handlerMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul></li><li><p>得到<code>ServletInvocableHandlerMethod</code> 对象之后进入到<code>ServletInvocableHandlerMethod</code> 类的<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code> 方法，可以说这个方法是<code>RequestMappingHandlerAdapter</code>的核心方法，可以看到<code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</code> 是执行了方法体，得到<code>returnValue</code> 之后就是调用<code>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</code>该方法处理结果对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the method and handle the return value through one of the</span></span><br><span class="line"><span class="comment"> * configured &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type (not resolved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</code> 方法，可以看到该方法很简单，先是得到方法参数<code>Object[] args</code>，然后执行<code>Object returnValue = doInvoke(args);</code> 该方法得到结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the method after resolving its argument values in the context of the given request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Argument values are commonly resolved through &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s.</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@code</span> providedArgs&#125; parameter however may supply argument values to be used directly,</span></span><br><span class="line"><span class="comment"> * i.e. without argument resolution. Examples of provided argument values include a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> WebDataBinder&#125;, a &#123;<span class="doctag">@link</span> SessionStatus&#125;, or a thrown exception instance.</span></span><br><span class="line"><span class="comment"> * Provided argument values are checked before argument resolvers.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type, not resolved</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the raw value returned by the invoked method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> Exception raised if no suitable argument resolver can be found,</span></span><br><span class="line"><span class="comment"> * or if the method raised an exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking '"</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line">Object returnValue = doInvoke(args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Method ["</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-1-方法参数绑定"><a href="#2-1-1-方法参数绑定" class="headerlink" title="2.1.1 方法参数绑定"></a>2.1.1 方法参数绑定</h3><ul><li><p>方法参数的绑定需要关注<code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</code> 这行代码，先进入该方法，可以看到该方法有两种解析形式 <code>1： providedArgs 2：argumentResolvers</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据当前请求获取方法的请求参数</span></span><br><span class="line"><span class="comment"> * Get the method argument values for the current request.</span></span><br><span class="line"><span class="comment"> * 两种解析形式 1： providedArgs 2：argumentResolvers 在RequestMappingHandlerAdapter中只有argumentResolvers解析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object[] getMethodArgumentValues(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,</span><br><span class="line">Object... providedArgs) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// 获取方法的参数，在HanderMethod中</span></span><br><span class="line">MethodParameter[] parameters = getMethodParameters();</span><br><span class="line"><span class="comment">// 用于保存解析出参数的值</span></span><br><span class="line">Object[] args = <span class="keyword">new</span> Object[parameters.length];</span><br><span class="line"><span class="comment">// 遍历每一个参数进行解析</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">MethodParameter parameter = parameters[i];</span><br><span class="line"><span class="comment">// 给Parameter设置参数名解析器</span></span><br><span class="line">parameter.initParameterNameDiscovery(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"><span class="comment">// 如果相应类型的参数已经在providedArgs中提供了，则直接设置到parameter</span></span><br><span class="line">args[i] = resolveProvidedArgument(parameter, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (args[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers.supportsParameter(parameter)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 使用argumentResolvers解析参数</span></span><br><span class="line">args[i] = <span class="keyword">this</span>.argumentResolvers.resolveArgument(</span><br><span class="line">parameter, mavContainer, request, <span class="keyword">this</span>.dataBinderFactory);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(getArgumentResolutionErrorMessage(<span class="string">"Failed to resolve"</span>, i), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析不出来，抛异常</span></span><br><span class="line"><span class="keyword">if</span> (args[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not resolve method parameter at index "</span> +</span><br><span class="line">parameter.getParameterIndex() + <span class="string">" in "</span> + parameter.getMethod().toGenericString() +</span><br><span class="line"><span class="string">": "</span> + getArgumentResolutionErrorMessage(<span class="string">"No suitable resolver for"</span>, i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>RequestMappingHandlerAdapter</code>中只有<code>argumentResolvers</code>解析，因为<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code> 只传了两个参数，到了<code>Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</code> 方法之后也是没有传入<code>providedArgs</code>的</p></li><li><p><code>argumentResolvers</code> 存放在<code>HandlerMethodArgumentResolverComposite</code> 类中，所有的<code>ArgumentResolver</code>都存放在<code>List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers</code>中，也可以看到该类也做了一个<code>argumentResolverCacheCache</code>处理，也是为了性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HandlerMethodArgumentResolver 的仓库</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Resolves method parameters by delegating to a list of registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s.</span></span><br><span class="line"><span class="comment"> * Previously resolved method parameters are cached for faster lookups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethodArgumentResolverComposite</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers =</span><br><span class="line"><span class="keyword">new</span> LinkedList&lt;HandlerMethodArgumentResolver&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MethodParameter, HandlerMethodArgumentResolver&gt; argumentResolverCache =</span><br><span class="line"><span class="keyword">new</span> ConcurrentHashMap&lt;MethodParameter, HandlerMethodArgumentResolver&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add the given &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HandlerMethodArgumentResolverComposite <span class="title">addResolver</span><span class="params">(HandlerMethodArgumentResolver resolver)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.argumentResolvers.add(resolver);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过调试可以看到有下面这些<code>argumentResolvers</code>，看类名称是不是很熟悉，就是我们平常使用的<code>@RequestBody</code> <code>@RequestParam</code> 是一一对应的，还是专人做专事，可以得出不同的参数是有不同的参数解析组件来专门处理的</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/argumentResolvers.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>下面来看主要<code>XXXArgumentResolver</code>的作用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. SessionAttributeMethodArgumentResolver</span><br><span class="line">    针对 被 <span class="meta">@SessionAttribute</span> 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_SESSION)    </span><br><span class="line"><span class="number">2</span>. RequestParamMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@RequestParam</span> 注解修饰, 但类型不是 Map, 或类型是 Map, 并且 <span class="meta">@RequestParam</span> 中指定 name, 一般通过 MultipartHttpServletRequest | HttpServletRequest 获取数据</span><br><span class="line"><span class="number">3</span>. RequestHeaderMethodArgumentResolver</span><br><span class="line">    针对 参数被 RequestHeader 注解, 并且 参数不是 Map 类型, 数据通过 HttpServletRequest.getHeaderValues(name) 获取</span><br><span class="line"><span class="number">4</span>. RequestAttributeMethodArgumentResolver</span><br><span class="line">    针对 被 <span class="meta">@RequestAttribute</span> 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_REQUEST)</span><br><span class="line"><span class="number">5</span>. PathVariableMethodArgumentResolver</span><br><span class="line">    解决被注解 <span class="meta">@PathVariable</span> 注释的参数 &lt;- 这个注解对应的是 uri 中的数据, 在解析 URI 中已经进行解析好了 &lt;- 在 RequestMappingInfoHandlerMapping.handleMatch -&gt; getPathMatcher().extractUriTemplateVariables</span><br><span class="line"><span class="number">6</span>. MatrixVariableMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@MatrixVariable</span> 注解修饰的参数起作用,  从 HttpServletRequest 中获取去除 ; 的 URI Template Variables 获取数据</span><br><span class="line"><span class="number">7</span>. ExpressionValueMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@Value</span> 修饰, 返回 ExpressionValueNamedValueInfo</span><br><span class="line"><span class="number">8</span>. ServletCookieValueMethodArgumentResolver</span><br><span class="line">    针对被 <span class="meta">@CookieValue</span> 修饰, 通过 HttpServletRequest.getCookies 获取对应数据</span><br></pre></td></tr></table></figure><ul><li><p>然后进入<code>HandlerMethodArgumentResolverComposite</code>类的<code>args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);</code> 方法，可以看到逻辑十分简单，就是遍历<code>this.argumentResolvers</code> 然后做了个缓存处理，得到<code>HandlerMethodArgumentResolver</code>之后就是调用<code>resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</code>方法了，该方法是参数解析的主体方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代注册过的 HandlerMethodArgumentResolver, 然后找到对应的ArgumentResolver</span></span><br><span class="line"><span class="comment"> * Iterate over registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125;s and invoke the one that supports it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if no suitable &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125; is found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);</span><br><span class="line"><span class="keyword">if</span> (resolver == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown parameter type ["</span> + parameter.getParameterType().getName() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先从缓存里取，没有的再遍历，注意这里是先来先得的</span></span><br><span class="line"><span class="comment"> * Find a registered &#123;<span class="doctag">@link</span> HandlerMethodArgumentResolver&#125; that supports the given method parameter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> HandlerMethodArgumentResolver <span class="title">getArgumentResolver</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">HandlerMethodArgumentResolver result = <span class="keyword">this</span>.argumentResolverCache.get(parameter);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerMethodArgumentResolver methodArgumentResolver : <span class="keyword">this</span>.argumentResolvers) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Testing if argument resolver ["</span> + methodArgumentResolver + <span class="string">"] supports ["</span> +</span><br><span class="line">parameter.getGenericParameterType() + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (methodArgumentResolver.supportsParameter(parameter)) &#123;</span><br><span class="line">result = methodArgumentResolver;</span><br><span class="line"><span class="keyword">this</span>.argumentResolverCache.put(parameter, result);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再来回顾<code>HandlerMethodArgumentResolver</code>接口，该接口就两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法参数解析器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Strategy interface for resolving method parameters into argument values in</span></span><br><span class="line"><span class="comment"> * the context of a given request.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodReturnValueHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method parameter&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this resolver.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this resolver supports the supplied parameter;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据request解析方法参数值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Resolves a method parameter into an argument value from a given request.</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> ModelAndViewContainer&#125; provides access to the model for the</span></span><br><span class="line"><span class="comment"> * request. A &#123;<span class="doctag">@link</span> WebDataBinderFactory&#125; provides a way to create</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@link</span> WebDataBinder&#125; instance when needed for data binding and</span></span><br><span class="line"><span class="comment"> * type conversion purposes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameter the method parameter to resolve. This parameter must</span></span><br><span class="line"><span class="comment"> * have previously been passed to &#123;<span class="doctag">@link</span> #supportsParameter&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> binderFactory a factory for creating &#123;<span class="doctag">@link</span> WebDataBinder&#125; instances</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the resolved argument value, or &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors with the preparation of argument values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>HandlerMethodArgumentResolver</code>的 <code>resolveArgument</code> 的解析将在之后的章节介绍</p><h3 id="2-2-2-方法执行"><a href="#2-2-2-方法执行" class="headerlink" title="2.2.2 方法执行"></a>2.2.2 方法执行</h3></li><li><p>回到<code>InvocableHandlerMethod</code>类的<code>invokeForRequest</code> 方法，上一小节介绍了方法参数绑定的主体逻辑(<code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</code>)，这一小节介绍<code>Object returnValue = doInvoke(args);</code>，该行代码是方法执行的主体方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Invoking '"</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"' with arguments "</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line">Object returnValue = doInvoke(args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Method ["</span> + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +</span><br><span class="line"><span class="string">"] returned ["</span> + returnValue + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Object returnValue = doInvoke(args);</code> 方法，可以看到调用了<code>getBridgedMethod().invoke(getBean(), args);</code> 来执行方法，<code>getBridgedMethod()</code> 得到的是<code>private final Method bridgedMethod</code>，百度了一下这个桥接方法的用途是为了和jdk1.5之前的字节码兼容. 因为范型是在jdk1.5之后才引入的. 在jdk1.5之前例如集合的操作都是没有范型支持的, 所以生成的字节码中参数都是用Object接收的, 所以也可以往集合中放入任意类型的对象, 集合类型的校验也被拖到运行期.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the handler method with the given argument values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 强制将他变为可调用 即使是private方法</span></span><br><span class="line">ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">"Illegal argument"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getInvocationErrorMessage(text, args), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">Throwable targetException = ex.getTargetException();</span><br><span class="line"><span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String text = getInvocationErrorMessage(<span class="string">"Failed to invoke handler method"</span>, args);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(text, targetException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在此方法执行完成</p></li></ul><h3 id="2-2-3-返回结果处理"><a href="#2-2-3-返回结果处理" class="headerlink" title="2.2.3 返回结果处理"></a>2.2.3 返回结果处理</h3><ul><li><p>方法执行完成之后就对返回结果的处理了，回到<code>ServletInvocableHandlerMethod</code>类，现在方法体已经执行了，就是对结果对象的处理了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the method and handle the return value through one of the</span></span><br><span class="line"><span class="comment"> * configured &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for this request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> providedArgs "given" arguments matched by type (not resolved)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(getReturnValueHandlingErrorMessage(<span class="string">"Error handling return value"</span>, returnValue), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看上面的代码可以看到<code>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</code> 这行代码作用是对结果对象的处理，查看<code>returnValueHandlers</code> 对象（<code>private HandlerMethodReturnValueHandlerComposite returnValueHandlers;</code>）可以看到和我们之前的参数绑定的处理是相似的，<code>HandlerMethodReturnValueHandlerComposite</code>存放了各种结果处理组件</p><blockquote><p>HandlerMethodReturnValueHandlerComposite.java</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handles method return values by delegating to a list of registered &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s.</span></span><br><span class="line"><span class="comment"> * Previously resolved return types are cached for faster lookups.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerMethodReturnValueHandlerComposite</span> <span class="keyword">implements</span> <span class="title">AsyncHandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果处理组件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers =</span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;HandlerMethodReturnValueHandler&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>HandlerMethodReturnValueHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果对象处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Strategy interface to handle the value returned from the invocation of a</span></span><br><span class="line"><span class="comment"> * handler method .</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> HandlerMethodArgumentResolver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否支持</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Whether the given &#123;<span class="doctag">@linkplain</span> MethodParameter method return type&#125; is</span></span><br><span class="line"><span class="comment"> * supported by this handler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the method return type to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this handler supports the supplied return type;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理结果集</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Handle the given return value by adding attributes to the model and</span></span><br><span class="line"><span class="comment"> * setting a view or setting the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ModelAndViewContainer#setRequestHandled&#125; flag to &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * to indicate the response has been handled directly.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnValue the value returned from the handler method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> returnType the type of the return value. This type must have</span></span><br><span class="line"><span class="comment"> * previously been passed to &#123;<span class="doctag">@link</span> #supportsReturnType&#125; which must</span></span><br><span class="line"><span class="comment"> * have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mavContainer the ModelAndViewContainer for the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webRequest the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if the return value handling results in an error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入<code>handleReturnValue</code>方法，可以看到和之前方法参数绑定处理是一样的套路的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代注册过的 HandlerMethodReturnValueHandler, 然后找到对应的ReturnValueHandler</span></span><br><span class="line"><span class="comment"> * Iterate over registered &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125;s and invoke the one that supports it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalStateException if no suitable &#123;<span class="doctag">@link</span> HandlerMethodReturnValueHandler&#125; is found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown return value type: "</span> + returnType.getParameterType().getName());</span><br><span class="line">&#125;</span><br><span class="line">handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title">selectHandler</span><span class="params">(Object value, MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> isAsyncValue = isAsyncReturnValue(value, returnType);</span><br><span class="line">       <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="keyword">this</span>.returnValueHandlers) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">               <span class="keyword">return</span> handler;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>如下图可以看到有如下<code>this.returnValueHandlers</code></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/HandlerComposite.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><code>RequestMappingHanlderAdapter</code> 的功能主要是 <code>1、方法参数绑定，2、方法执行，3、返回结果处理</code> </li><li><code>HandlerMethodArgumentResolver</code> 的方法参数绑定处理是针对于不同的方法参数有专门的<code>ArgumentResolver</code> 专人做专事，专业</li><li><code>HandlerMethodReturnValueHandler</code> 的返回结果处理也是和参数处理那样是针对于不同的返回对象有专门的<code>ReturnValueHandler</code></li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RequestMappingHanlderAdapter&lt;/code&gt;是 &lt;code
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(一)介绍</title>
    <link href="http://www.songshuiyang.site/2019/03/02/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%B8%80)%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.songshuiyang.site/2019/03/02/backend/Java/JVM/JVM运行时数据区域(一)介绍/</id>
    <published>2019-03-02T13:59:44.000Z</published>
    <updated>2019-03-10T12:17:35.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/jvm1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>Java 虚拟机的内存模型分为两部分<ul><li>线程共享的<ul><li>方法区</li><li>Java 堆</li></ul></li><li>线程私有的<ul><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器</li></ul></li></ul></li></ul><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ol><li>程序计数器：指向当前线程正在执行的字节码指令。线程私有的。</li><li>虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈</li><li>本地方法栈：调用本地native的内存模型</li><li>方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li><li>堆（Heap）：Java对象存储的地方</li></ol><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://segmentfault.com/a/1190000014395186" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014395186</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(二)程序计数器</title>
    <link href="http://www.songshuiyang.site/2019/03/02/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%BA%8C)%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/02/backend/Java/JVM/JVM运行时数据区域(二)程序计数器/</id>
    <published>2019-03-02T13:59:44.000Z</published>
    <updated>2019-03-10T12:17:35.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的<code>行号指示器</code>，在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>线程私有的</li><li>是java虚拟机规范里面， 唯一 一个 没有规定任何 <code>OutOfMemoryError</code> 情况的区域</li><li>生命周期随着线程，线程启动而产生，线程结束而消亡</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>程序计数器，可以看做是当前线程执行的字节码的 行号指示器 ，这句话；要理解这句话，需要先知道字节码文件长什么样子，看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 文件被翻译为字节码的时候，字节码大概类似于下面的样子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 原来的 haha 方法内部的 java 代码，被翻译为下面的类似于汇编语言的指令</span></span><br><span class="line">    <span class="number">0</span> xxxx ....</span><br><span class="line">    <span class="number">2</span> xxxx ....</span><br><span class="line">    <span class="number">4</span> xx  ...</span><br><span class="line">    <span class="number">5</span> xxx ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面左边的 0、2、4、5 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的</p></li><li><p>理解了程序计数器，就好理解它的这些特点了；我们都知道，Java是支持多线程的，当CPU执行权从 A 线程，转移到 B 线程的时候，JVM就要暂时挂起线程 A ，去执行线程 B ；当线程 A 再次得到CPU执行权的时候，又会挂起B线程，继续执行 A 线程 ；</p></li><li><p>我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？</p></li><li><p>答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）；</p></li><li><p>那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，<code>程序计数器的内存空间是线程私有的</code> ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！</p></li><li><p>那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被<code>创建</code>；</p></li><li><p>程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，<code>jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域</code>；</p></li><li><p>当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 ；</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/youngyouth/article/details/79868299" target="_blank" rel="noopener">https://blog.csdn.net/youngyouth/article/details/79868299</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的&lt;code&gt;行号指示器&lt;/code&gt;，在虚拟机的概念模型里（仅仅是概念模
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(三)Java虚拟机栈</title>
    <link href="http://www.songshuiyang.site/2019/03/02/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%B8%89)Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://www.songshuiyang.site/2019/03/02/backend/Java/JVM/JVM运行时数据区域(三)Java虚拟机栈/</id>
    <published>2019-03-02T13:59:44.000Z</published>
    <updated>2019-03-10T12:17:35.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为虚拟机栈"><a href="#何为虚拟机栈" class="headerlink" title="何为虚拟机栈"></a>何为虚拟机栈</h2><ul><li><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></li><li><p>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。</p></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示： </li></ul><p><img src="/images/server/java/JVM/stackFrame.jpg" alt=""></p><h3 id="栈帧数据结构"><a href="#栈帧数据结构" class="headerlink" title="栈帧数据结构"></a>栈帧数据结构</h3><ul><li><p>每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中</p></li><li><p>我们先来理解一下虚拟机是如何执行一个方法的，这样我们才能理解为什么栈帧需要这些部分，这些部分分别提供了什么功能。首先我们的方法被编译成了字节码，并生成了可执行的命令。通过程序计数器，虚拟机会一行一行的执行命令，直到进入一个新的方法入口，对应虚拟机栈也就是新的栈帧入栈，当前栈帧改变，又或者遇到返回指令或出现异常结束了方法，对应虚拟机也就是出栈。</p></li></ul><h4 id="1、局部变量表"><a href="#1、局部变量表" class="headerlink" title="1、局部变量表"></a>1、局部变量表</h4><ul><li>是一片逻辑连续的内存空间，最小单位是Slot，用来存放方法参数和方法内部定义的局部变量</li></ul><h4 id="2、操作数栈"><a href="#2、操作数栈" class="headerlink" title="2、操作数栈"></a>2、操作数栈</h4><ul><li><p>每个栈帧都包含一个被叫做操作数栈的后进先出的栈。叫操作栈，或者操作数栈。</p></li><li><p>栈桢刚创建时，里面的操作数栈是空的。</p></li><li><p>Java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据、实例的字段等数据入栈。</p></li><li><p>同时也有指令来支持出栈操作。</p></li><li><p>向其他方法传参的参数，也存在操作数栈中。</p></li><li><p>其他方法返回的结果，返回时存在操作数栈中。</p></li></ul><h4 id="3、动态链接"><a href="#3、动态链接" class="headerlink" title="3、动态链接"></a>3、动态链接</h4><ul><li><p>一个方法调用另一个方法，或者一个类使用另一个类的成员变量时，总得知道被调用者的名字吧？(你可以不认识它本身，但调用它就需要知道他的名字)。符号引用就相当于名字，这些被调用者的名字就存放在Java字节码文件里。名字是知道了，但是Java真正运行起来的时候，真的能靠这个名字（符号引用）就能找到相应的类和方法吗？需要解析成相应的直接引用，利用直接引用来准确地找到。</p></li><li><p>举个例子，就相当于我在0X0300H这个地址存入了一个数526，为了方便编程，我把这个给这个地址起了个别名叫A, 以后我编程的时候(运行之前)可以用别名A来暗示访问这个空间的数据，但其实程序运行起来后，实质上还是去寻找0X0300H这片空间来获取526这个数据的。</p></li><li><p>这样的符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。</p><h4 id="4、方法返回地址"><a href="#4、方法返回地址" class="headerlink" title="4、方法返回地址"></a>4、方法返回地址</h4></li><li><p>返回一个值给调用它的方法，方法正常完成发生在一个方法执行过程 中遇到了方法返回的字节码指令（§2.11.8）的时候，使用哪种返回指令取决于方法返回值的数 据类型（如果有返回值的话）。</p></li></ul><h4 id="5、附加信息"><a href="#5、附加信息" class="headerlink" title="5、附加信息"></a>5、附加信息</h4><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/ychenfeng/article/details/77247807" target="_blank" rel="noopener">https://blog.csdn.net/ychenfeng/article/details/77247807</a></li><li><a href="https://blog.csdn.net/u014296316/article/details/82668670" target="_blank" rel="noopener">https://blog.csdn.net/u014296316/article/details/82668670</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;何为虚拟机栈&quot;&gt;&lt;a href=&quot;#何为虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;何为虚拟机栈&quot;&gt;&lt;/a&gt;何为虚拟机栈&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(七)处理适配器HanlderAdapter</title>
    <link href="http://www.songshuiyang.site/2019/02/28/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%B8%83)%E5%A4%84%E7%90%86%E9%80%82%E9%85%8D%E5%99%A8HanlderAdapter/"/>
    <id>http://www.songshuiyang.site/2019/02/28/backend/spring/sourceCodeAnalysis/Spring Mvc源码(七)处理适配器HanlderAdapter/</id>
    <published>2019-02-28T13:59:44.000Z</published>
    <updated>2019-03-03T03:19:43.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li><p>前几章介绍了<code>HandlerMapping</code>处理流程， <code>HandlerMapping</code>负责根据<code>request</code>请求找到对应的<code>Handler</code>处理器及<code>Interceptor</code>拦截器，的到处理器<code>Handler</code>之后，<code>Spring MVC</code> 又根据该<code>Handler</code> 找出对应的 <code>HandlerAdapter</code>，这一章节来介绍<code>HandlerAdapter</code>，<code>HandlerAdapter</code>是具体使用<code>Handler</code> 来干活的</p></li><li><p>下面还是方法体<code>doDispatch(HttpServletRequest request, HttpServletResponse response)</code> 的处理代码，可以看到得到<code>Handler</code>处理器之后就是遍历所有的 <code>HandlerAdapter</code>，找到可以处理该 <code>Handler</code> 的 <code>HandlerAdapter</code>，找到之后就是<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code> 调用真正的处理方法了</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否是文件上传请求 Multipart，有则将请求转换为 Multipart 请求</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">// 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="comment">// 处理 last-modified 请求头</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行相应拦截器Interceptor的preHandle</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 执行实际的处理程序，执行Controller里的方法</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br></pre></td></tr></table></figure><h2 id="2-1-处理适配器HanlderAdapter解析"><a href="#2-1-处理适配器HanlderAdapter解析" class="headerlink" title="2.1 处理适配器HanlderAdapter解析"></a>2.1 处理适配器HanlderAdapter解析</h2><h3 id="2-1-1-HanlderAdapter-解析"><a href="#2-1-1-HanlderAdapter-解析" class="headerlink" title="2.1.1 HanlderAdapter 解析"></a>2.1.1 HanlderAdapter 解析</h3><ul><li>先看<code>HanlderAdapter</code> 这个接口有哪些方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handler 处理适配器, 适配不同的 Handler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MVC framework SPI, allowing parameterization of the core MVC workflow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Interface that must be implemented for each handler type to handle a request.</span></span><br><span class="line"><span class="comment"> * This interface is used to allow the &#123;<span class="doctag">@link</span> DispatcherServlet&#125; to be indefinitely</span></span><br><span class="line"><span class="comment"> * extensible. The &#123;<span class="doctag">@code</span> DispatcherServlet&#125; accesses all installed handlers through</span></span><br><span class="line"><span class="comment"> * this interface, meaning that it does not contain code specific to any handler type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that a handler can be of type &#123;<span class="doctag">@code</span> Object&#125;. This is to enable</span></span><br><span class="line"><span class="comment"> * handlers from other frameworks to be integrated with this framework without</span></span><br><span class="line"><span class="comment"> * custom coding, as well as to allow for annotation-driven handler objects that</span></span><br><span class="line"><span class="comment"> * do not obey any specific Java interface.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is not intended for application developers. It is available</span></span><br><span class="line"><span class="comment"> * to handlers who want to develop their own web workflow.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note: &#123;<span class="doctag">@code</span> HandlerAdapter&#125; implementors may implement the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.springframework.core.Ordered&#125; interface to be able to specify a sorting</span></span><br><span class="line"><span class="comment"> * order (and thus a priority) for getting applied by the &#123;<span class="doctag">@code</span> DispatcherServlet&#125;.</span></span><br><span class="line"><span class="comment"> * Non-Ordered instances get treated as lowest priority.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.handler.SimpleServletHandlerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检测 HandlerAdapter 是否支持这个 handler</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given a handler instance, return whether or not this &#123;<span class="doctag">@code</span> HandlerAdapter&#125;</span></span><br><span class="line"><span class="comment"> * can support it. Typical HandlerAdapters will base the decision on the handler</span></span><br><span class="line"><span class="comment"> * type. HandlerAdapters will usually only support one handler type each.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A typical implementation:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * return (handler instanceof MyHandler);</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler object to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this object can use the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理 HttpServletRequest 的入口方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use the given handler to handle this request.</span></span><br><span class="line"><span class="comment"> * The workflow that is required may vary widely.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler to use. This object must have previously been passed</span></span><br><span class="line"><span class="comment"> * to the &#123;<span class="doctag">@code</span> supports&#125; method of this interface, which must have</span></span><br><span class="line"><span class="comment"> * returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment"> * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取Http 请求中的lastModifiedTime</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Same contract as for HttpServlet's &#123;<span class="doctag">@code</span> getLastModified&#125; method.</span></span><br><span class="line"><span class="comment"> * Can simply return -1 if there's no support in the handler class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the lastModified value for the given handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> javax.servlet.http.HttpServlet#getLastModified</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.mvc.LastModified#getLastModified</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下图是<code>HanlderAdapter</code>涉及子类的继承关系，看方法名是不是很熟悉，没错和前几章的<code>HandlerMapping</code>是差不多是一一对应的</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/HandlerAdapter.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>查看这些类可以看到除了<code>RequestMappingHandlerAdapter</code> 的实现比较复杂之外，其他的<code>HandlerAdapter</code>都是调用<code>Handler</code>里固定的方法，比如下图的<code>SimpleControllerHandlerAdapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> LastModified) &#123;</span><br><span class="line"><span class="keyword">return</span> ((LastModified) handler).getLastModified(request);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>AbstractHandlerMethodAdapter</code>可以看到内容也很少，<code>HandlerAdapter</code> 接口的实现都转发到自己的抽象方法里去了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract base class for &#123;<span class="doctag">@link</span> HandlerAdapter&#125; implementations that support</span></span><br><span class="line"><span class="comment"> * handlers of type &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandlerMethodAdapter</span> <span class="keyword">extends</span> <span class="title">WebContentGenerator</span> <span class="keyword">implements</span> <span class="title">HandlerAdapter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> order = Ordered.LOWEST_PRECEDENCE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractHandlerMethodAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// no restriction of HTTP methods by default</span></span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify the order value for this HandlerAdapter bean.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Default value is &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125;, meaning that it's non-ordered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.core.Ordered#getOrder()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.order = order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先判断是否是HandlerMethod，然后转向抽象方法supportsInternal</span></span><br><span class="line"><span class="comment"> * This implementation expects the handler to be an &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the handler instance to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this adapter can adapt the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given a handler method, return whether or not this adapter can support it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handlerMethod the handler method to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> whether or not this adapter can adapt the given method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">supportsInternal</span><span class="params">(HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转向抽象方法 handleInternal()</span></span><br><span class="line"><span class="comment"> * This implementation expects the handler to be an &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> handleInternal(request, response, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the given handler method to handle the request.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handlerMethod handler method to use. This object must have previously been passed to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #supportsInternal(HandlerMethod)&#125; this interface, which must have returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ModelAndView object with the name of the view and the required model data,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转向抽象方法 getLastModifiedInternal()</span></span><br><span class="line"><span class="comment"> * This implementation expects the handler to be an &#123;<span class="doctag">@link</span> HandlerMethod&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getLastModifiedInternal(request, (HandlerMethod) handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same contract as for &#123;<span class="doctag">@link</span> javax.servlet.http.HttpServlet#getLastModified(HttpServletRequest)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handlerMethod handler method to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the lastModified value for the given handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getLastModifiedInternal</span><span class="params">(HttpServletRequest request, HandlerMethod handlerMethod)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-2-各个-HandlerAdapter作用"><a href="#2-1-2-各个-HandlerAdapter作用" class="headerlink" title="2.1.2 各个 HandlerAdapter作用"></a>2.1.2 各个 <code>HandlerAdapter</code>作用</h3><h4 id="AnnotationMethodHandlerAdapter"><a href="#AnnotationMethodHandlerAdapter" class="headerlink" title="AnnotationMethodHandlerAdapter"></a>AnnotationMethodHandlerAdapter</h4><p><code>AnnotationMethodHandlerAdapter</code>主要是适配注解类处理器，注解类处理器就是我们经常使用的<code>@Controller</code>的这类处理器，不过该类已经被<code>@Deprecated</code> 标记了（@deprecated as of Spring 3.2, in favor of`） </p><h4 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h4><p><code>HttpRequestHandlerAdapter</code> 主要是适配静态资源处理器，静态资源处理器就是实现了<code>HttpRequestHandler</code>接口的处理器，这类处理器的作用是处理通过<code>SpringMVC</code>来访问的静态资源的请求。        </p><h4 id="SimpleControllerHandlerAdapter"><a href="#SimpleControllerHandlerAdapter" class="headerlink" title="SimpleControllerHandlerAdapter"></a>SimpleControllerHandlerAdapter</h4><p><code>SimpleControllerHandlerAdapter</code> 是<code>Controller</code>处理适配器，适配实现了<code>Controller</code>接口或<code>Controller</code>接口子类的处理器，比如我们经常自己写的<code>Controller</code>来继承<code>MultiActionController</code></p><h4 id="SimpleServletHandlerAdapter"><a href="#SimpleServletHandlerAdapter" class="headerlink" title="SimpleServletHandlerAdapter"></a>SimpleServletHandlerAdapter</h4><p><code>SimpleServletHandlerAdapter</code>是<code>Servlet</code>处理适配器,适配实现了<code>Servlet</code>接口或<code>Servlet</code>的子类的处理器，我们不仅可以在web.xml里面配置Servlet，其实也可以用SpringMVC来配置Servlet，不过这个适配器很少用到，而且SpringMVC默认的适配器没有他，默认的是前面的三种。</p><h3 id="2-1-3-HandlerAdapter-注册过程"><a href="#2-1-3-HandlerAdapter-注册过程" class="headerlink" title="2.1.3 HandlerAdapter 注册过程"></a>2.1.3 <code>HandlerAdapter</code> 注册过程</h3><ul><li><p><code>HandlerAdapter</code> 注册过程 和 <code>HandlerMapping</code> 的注册过程是一样的，回到<code>DispatcherServlet</code> 类中<code>onRefresh</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 上传组件组件初始化</span></span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line"><span class="comment">// 请求映射处理组件初始化</span></span><br><span class="line">initHandlerMappings(context);</span><br><span class="line"><span class="comment">// 处理适配器组建初始化</span></span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line"><span class="comment">// 异常处理组件初始化</span></span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line"><span class="comment">// 视图处理组件初始化</span></span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>initHandlerAdapters(context);</code> 从下面代码也可以看到也是通过扫描<code>HandlerAdapter</code>类 <code>bean</code>的形式来注册<code>HandlerAdapter</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the HandlerAdapters used by this class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no HandlerAdapter beans are defined in the BeanFactory for this namespace,</span></span><br><span class="line"><span class="comment"> * we default to SimpleControllerHandlerAdapter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerAdapters</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerAdapters) &#123;</span><br><span class="line"><span class="comment">// 加载所有实现了HandlerAdapter接口的bean</span></span><br><span class="line"><span class="comment">// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = <span class="keyword">new</span> ArrayList&lt;HandlerAdapter&gt;(matchingBeans.values());</span><br><span class="line"><span class="comment">// We keep HandlerAdapters in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerAdapters);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Ignore, we'll add a default HandlerAdapter later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure we have at least some HandlerAdapters, by registering</span></span><br><span class="line"><span class="comment">// default HandlerAdapters if no other adapters are found.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No HandlerAdapters found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><code>HanlderAdapter</code> 从字面上的意思就是处理适配器，他的作用就是根据用户的请求调用具体的方法，根据<code>HandlerMapping</code>传过来<code>Hanler</code>与注册好的<code>HandlerAdapter</code>一一匹配，如果找到了其中一种<code>HandlerAdapter</code>是支持传过来的<code>controller</code>类型，那么该<code>HandlerAdapter</code>会调用自己的<code>handle</code>方法</li><li>不同的<code>HanlderAdapter</code>可以适应不同的request需求</li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="https://www.jianshu.com/p/3d6df6b725e4" target="_blank" rel="noopener">https://www.jianshu.com/p/3d6df6b725e4</a></p><p><a href="https://blog.csdn.net/weixin_38399962/article/details/85288660" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38399962/article/details/85288660</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前几章介绍了&lt;code&gt;HandlerMapping&lt;/code&gt;处理流程， &lt;code&gt;
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程</title>
    <link href="http://www.songshuiyang.site/2019/02/27/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E5%85%AD)%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E7%9A%84RequestMappingHandlerMapping%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/02/27/backend/spring/sourceCodeAnalysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程/</id>
    <published>2019-02-27T13:59:44.000Z</published>
    <updated>2019-03-03T02:27:39.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li>上一章节介绍了 <code>RequestMappingHandlerMapping</code> 这个 <code>HandlerMapping</code> 的加载过程，这一章节来介绍<code>RequestMappingHandlerMapping</code>实现流程</li></ul><h2 id="2-1-找到与请求对应的-Handler-解析"><a href="#2-1-找到与请求对应的-Handler-解析" class="headerlink" title="2.1 找到与请求对应的 Handler 解析"></a>2.1 找到与请求对应的 Handler 解析</h2><ul><li>还是回到这个方法<code>doDispatch(HttpServletRequest request, HttpServletResponse response)</code> ，下面的代码是发挥<code>RequestMappingHandlerMapping</code>作用的地方</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line"><span class="comment">// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还是进入 <code>getHandler</code>方法，这里会遍历到我们的<code>RequestMappingHandlerMapping</code> 这个<code>HandlerMapping</code>，通过<code>HandlerExecutionChain handler = hm.getHandler(request);</code> 得到<code>HandlerExecutionChain</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping</span></span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(</span><br><span class="line">                    <span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain</span></span><br><span class="line">        HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意这里是找到第一个就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进入<code>hm.getHandler(request);</code> 会跳到我们的<code>AbstractHandlerMapping</code> 类中，<code>RequestMappingHandlerMapping</code> 继承该类，由下面代码可以看到这里这里获取了 <code>handler</code> 及 <code>Interceptor</code> 并封装为<code>HandlerExecutionChain</code> 返回调用者 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look up a handler for the given request, falling back to the default</span></span><br><span class="line"><span class="comment"> * handler if no specific one is found.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the corresponding handler instance, or the default handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getHandlerInternal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里获取 处理器handler，模板方法实现， RequestMappingHandlerMapping 跳到 AbstractHandlerMethodMapping</span></span><br><span class="line">    Object handler = getHandlerInternal(request);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handler = getDefaultHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">    <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String handlerName = (String) handler;</span><br><span class="line">        handler = getApplicationContext().getBean(handlerName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 拦截器Interceptor</span></span><br><span class="line">    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">    <span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">        CorsConfiguration globalConfig = <span class="keyword">this</span>.corsConfigSource.getCorsConfiguration(request);</span><br><span class="line">        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">        CorsConfiguration config = (globalConfig != <span class="keyword">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>Object handler = getHandlerInternal(request);</code> 这里是获取<code>handler</code>的地方，这时又会跳到<code>AbstractHandlerMethodMapping</code> 类中，这样跳来跳去可以看到封装的特性及使用模板方法提高了扩展性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look up a handler method for the given request.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求url路径 localhost:8080/pub/account/list &gt;&gt;&gt; /pub/account/list</span></span><br><span class="line">    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Looking up handler method for path "</span> + lookupPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mappingRegistry添加读锁，其他线程只能读不能写</span></span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据request获取对应的HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlerMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning handler method ["</span> + handlerMethod + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">"Did not find handler method for ["</span> + lookupPath + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注 <code>HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</code> 这行代码，进入该方法，可以看到这个方法的作用是得到<code>HandlerMethod</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找当前request请求 最为匹配的处理方法HandlerMethod，如果有多个匹配结果，则选择最佳匹配结果</span></span><br><span class="line"><span class="comment"> * Look up the best-matching handler method for the current request.</span></span><br><span class="line"><span class="comment"> * If multiple matches are found, the best match is selected.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lookupPath mapping lookup path within the current servlet mapping</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request the current request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the best-matching handler method, or &#123;<span class="doctag">@code</span> null&#125; if no match</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handleMatch(Object, String, HttpServletRequest)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handleNoMatch(Set, String, HttpServletRequest)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;Match&gt;();</span><br><span class="line">    <span class="comment">// 根据URL来获取,springMVC会在初始化的时候建立URL和相应RequestMappingInfo的映射。如果不是restful接口，这里就可以直接获取到了， lookupPath: /pub/account/list</span></span><br><span class="line">    List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">    <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配校验</span></span><br><span class="line">        addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 全盘扫描</span></span><br><span class="line">        <span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">        addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到匹配结果</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">        Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">        Collections.sort(matches, comparator);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Found "</span> + matches.size() + <span class="string">" matching mapping(s) for ["</span> +</span><br><span class="line">                    lookupPath + <span class="string">"] : "</span> + matches);</span><br><span class="line">        &#125;</span><br><span class="line">        Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">                <span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">            &#125;</span><br><span class="line">            Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果最佳匹配 第二佳匹配都是同一个则报错</span></span><br><span class="line">            <span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">                Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">                Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Ambiguous handler methods mapped for HTTP path '"</span> +</span><br><span class="line">                        request.getRequestURL() + <span class="string">"': &#123;"</span> + m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置HttpServletRequest值</span></span><br><span class="line">        handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有找到匹配，返回null</span></span><br><span class="line">        <span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看这行代码可以看到是通过url来获取<code>this.mappingRegistry.getMappingsByUrl(lookupPath);</code>，进入该方法，可以看到<code>this.urlLookup</code>是<code>MappingRegistry</code>类中的一个<code>Map</code>,直接通过 <code>url</code>为<code>key</code>得到值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MappingRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = <span class="keyword">new</span> HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;T, HandlerMethod&gt; mappingLookup = <span class="keyword">new</span> LinkedHashMap&lt;T, HandlerMethod&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MultiValueMap&lt;String, T&gt; urlLookup = <span class="keyword">new</span> LinkedMultiValueMap&lt;String, T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;HandlerMethod&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;HandlerMethod, CorsConfiguration&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getMappingsByUrl</span><span class="params">(String urlPath)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  MultiValueMap&lt;String, T&gt; urlLookup 就是个map</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.urlLookup.get(urlPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>下图是this.urlLookup.get(urlPath) 的到的结果，返回的是个list</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/getMappingsByUrl.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li>返回到<code>lookupHandlerMethod(String lookupPath, HttpServletRequest request)</code> 方法，这里使用了<code>Match</code>做了匹配处理，得到最佳<code>Match bestMatch</code> 对象，最后返回<code>HandlerMethod</code>，在此终于得到了<code>HandlerMethod</code></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><p><code>RequestMappingHandlerMapping</code> 的主要功能就是通过 <code>reqeust</code> 获取 <code>HandlerExecutionChain</code> 的 <code>HandlerMethod</code>、<code>Interceptor</code>。</p></li><li><p>下图是<code>RequestMappingHandlerMapping</code>工作流程图，可以看到<code>RequestMappingHandlerMapping</code> 一个类的实现分了4层，<code>HandlerMapping</code> 接口定义顶级方法，两个抽象类又分两次封装，由上而下，逐渐细分功能</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestMappingInfoHandlerMapping.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一章节介绍了 &lt;code&gt;RequestMappingHandlerMapping&lt;/code
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程</title>
    <link href="http://www.songshuiyang.site/2019/02/26/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%BA%94)%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E7%9A%84RequestMappingHandlerMapping%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/02/26/backend/spring/sourceCodeAnalysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程/</id>
    <published>2019-02-26T12:59:44.000Z</published>
    <updated>2019-02-26T12:19:01.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li>上一章节介绍了<code>请求映射处理组件HandlerMapping</code>的主体处理流程，根据<code>request url</code> 获取对应的处理器<code>Handler</code>，这一章节来详细介绍我们平常最多使用的<code>RequestMappingHandlerMapping</code>的加载，这个<code>HandlerMapping</code> 是怎样加载基于<code>@Controller,@RequestMapping</code> 实现的<code>Controller</code></li></ul><h2 id="2-1-解析"><a href="#2-1-解析" class="headerlink" title="2.1 解析"></a>2.1 解析</h2><ul><li>接下来我们关注<code>RequestMappingHandlerMapping</code>这个<code>HandlerMapping</code>，因为这个是我们开发过程中最为常用的<code>HandlerMapping</code>，那么它是怎样实现<code>HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;</code> 这个方法，先看一下<code>RequestMappingHandlerMapping</code>的继承关系</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/RequestMappingHandlerMapping.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h3 id="2-1-1-RequestMappingHandlerMapping-加载过程"><a href="#2-1-1-RequestMappingHandlerMapping-加载过程" class="headerlink" title="2.1.1 RequestMappingHandlerMapping 加载过程"></a>2.1.1 <code>RequestMappingHandlerMapping</code> 加载过程</h3><ul><li><p>有上图可以看到<code>RequestMappingHandlerMapping</code> 的父类<code>AbstractHandlerMethodMapping</code> 实现了<code>InitializingBean</code> 接口，InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类， 在初始化bean的时候都会执行该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoked by a BeanFactory after it has set all bean properties supplied</span></span><br><span class="line"><span class="comment"> * (and satisfied BeanFactoryAware and ApplicationContextAware).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method allows the bean instance to perform initialization only</span></span><br><span class="line"><span class="comment"> * possible when all bean properties have been set and to throw an</span></span><br><span class="line"><span class="comment"> * exception in the event of misconfiguration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in the event of misconfiguration (such</span></span><br><span class="line"><span class="comment"> * as failure to set an essential property) or if initialization fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>AbstractHandlerMethodMapping</code>类 <code>afterPropertiesSet()</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>又抽象了一个方法，通过方法名可以得到是初始化<code>HandlerMethods</code>，进入<code>initHandlerMethods();</code> 方法，这个方法是扫描<code>ApplicationContext</code> 所有的bean，如果发现了该bean是<code>Handler</code>，并把它注册为<code>handler methods</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #isHandler(Class)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getMappingForMethod(Method, Class)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #handlerMethodsInitialized(Map)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Looking for request mappings in application context: "</span> + getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先拿到容器的所有的beanName数组</span></span><br><span class="line">    String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :</span><br><span class="line">            getApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">            <span class="comment">// 得到bean类型</span></span><br><span class="line">            Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beanType = getApplicationContext().getType(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Could not resolve target class for bean with name '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查bean所在的类是否有Controller注解及RequestMapping注解</span></span><br><span class="line">            <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">                <span class="comment">// 负责将Handler保存到Map里</span></span><br><span class="line">                detectHandlerMethods(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对Handler进行一些初始化，是一个模板方法</span></span><br><span class="line">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>String[] beanNames 示例</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/beanNames.jpg" alt="iamge" title="">                </div>                <div class="image-caption">iamge</div>            </figure><ul><li><p>进入<code>isHandler(beanType)</code>方法，，此方法由<code>RequestMappingHandlerMapping</code>实现， 此方法检查<code>bean</code>所在的类是否有<code>Controller</code>注解及<code>RequestMapping</code>注解，可以看到此方法的实现是在<code>RequestMappingHandlerMapping</code>里，是不是看到了我们熟悉的两个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查bean所在的类是否有Controller注解及RequestMapping注解</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * Expects a handler to have a type-level @&#123;<span class="doctag">@link</span> Controller&#125; annotation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果该<code>bean</code>有 <code>Controller</code>注解及<code>RequestMapping</code>注解，则执行<code>detectHandlerMethods(beanName);</code>方法，下面举个例子，我们有一个<code>UserController</code>里面有五个方法，下面来看是怎么处理这个类的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/pub/account"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/view"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">view</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findById(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">view</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(@RequestBody User user)</span> </span>&#123;</span><br><span class="line">        User user1 = userService.findById(user.getId());</span><br><span class="line">        user1.setUsername(<span class="string">"update"</span>);</span><br><span class="line">        userService.saveSelective(user1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">        userService.logicDeleteOne(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>detectHandlerMethods(beanName);</code>方法，可以看到<code>Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods</code> 获取到了我们五个方法，<code>Map&lt;Method, T&gt; methods</code> 以<code>Method</code>为key，<code>RequestMappingInfo</code>为value</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/detectHandlerMethods.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Look for handler methods in a handler.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler the bean name of a handler or a handler instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Handler的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">            getApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取 RequestMapping方法，会过滤掉普通方法</span></span><br><span class="line">    Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">            <span class="keyword">new</span> MethodIntrospector.MetadataLookup&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> T <span class="title">inspect</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">                                userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(methods.size() + <span class="string">" request handler methods found on "</span> + userType + <span class="string">": "</span> + methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123;</span><br><span class="line">        Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);</span><br><span class="line">        T mapping = entry.getValue();</span><br><span class="line">        <span class="comment">// 注册 mappingRegistry</span></span><br><span class="line">        registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>getMappingForMethod(method, userType)</code> ，此方法在<code>RequestMappingHandlerMapping</code>实现，这里解析分两步解析，一个是方法<code>method</code>解析，另一个是方法所在类<code>handlerType</code>的解析，然后拼接成一个<code>RequestMappingInfo</code>，可以看到也是对<code>RequestMapping</code>注解的解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有使用 &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>&#125; 注解会返回null</span></span><br><span class="line"><span class="comment"> * Uses method and type-level @&#123;<span class="doctag">@link</span> RequestMapping&#125; annotations to create</span></span><br><span class="line"><span class="comment"> * the RequestMappingInfo.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the created RequestMappingInfo, or &#123;<span class="doctag">@code</span> null&#125; if the method</span></span><br><span class="line"><span class="comment"> * does not have a &#123;<span class="doctag">@code</span> <span class="doctag">@RequestMapping</span>&#125; annotation.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCustomMethodCondition(Method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getCustomTypeCondition(Class)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">getMappingForMethod</span><span class="params">(Method method, Class&lt;?&gt; handlerType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析method的@RequestMapping</span></span><br><span class="line">    RequestMappingInfo info = createRequestMappingInfo(method);</span><br><span class="line">    <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析Class的@RequestMapping</span></span><br><span class="line">        RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);</span><br><span class="line">        <span class="keyword">if</span> (typeInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 合并两个RequestMappingInfo 比如url拼接</span></span><br><span class="line">            info = typeInfo.combine(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是RequestMapping方法返回null</span></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestMappingInfo <span class="title">createRequestMappingInfo</span><span class="params">(AnnotatedElement element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拿到注解</span></span><br><span class="line">        RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);</span><br><span class="line">        RequestCondition&lt;?&gt; condition = (element <span class="keyword">instanceof</span> Class ?</span><br><span class="line">                getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));</span><br><span class="line">        <span class="keyword">return</span> (requestMapping != <span class="keyword">null</span> ? createRequestMappingInfo(requestMapping, condition) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestMappingInfo <span class="title">createRequestMappingInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用@RequestMapping的属性生成RequestMappingInfo</span></span><br><span class="line">    <span class="keyword">return</span> RequestMappingInfo</span><br><span class="line">            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))</span><br><span class="line">            .methods(requestMapping.method())</span><br><span class="line">            .params(requestMapping.params())</span><br><span class="line">            .headers(requestMapping.headers())</span><br><span class="line">            .consumes(requestMapping.consumes())</span><br><span class="line">            .produces(requestMapping.produces())</span><br><span class="line">            .mappingName(requestMapping.name())</span><br><span class="line">            .customCondition(customCondition)</span><br><span class="line">            .options(<span class="keyword">this</span>.config)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RequestMappingInfo.java 对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingInfo</span> <span class="keyword">implements</span> <span class="title">RequestCondition</span>&lt;<span class="title">RequestMappingInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PatternsRequestCondition patternsCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestMethodsRequestCondition methodsCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ParamsRequestCondition paramsCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HeadersRequestCondition headersCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConsumesRequestCondition consumesCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ProducesRequestCondition producesCondition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RequestConditionHolder customConditionHolder;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>返回到<code>detectHandlerMethods</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取Handler的类型</span></span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">            getApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里获取 RequestMapping方法，会过滤掉普通方法</span></span><br><span class="line">    Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">            <span class="keyword">new</span> MethodIntrospector.MetadataLookup&lt;T&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> T <span class="title">inspect</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">                                userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(methods.size() + <span class="string">" request handler methods found on "</span> + userType + <span class="string">": "</span> + methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123;</span><br><span class="line">        Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);</span><br><span class="line">        T mapping = entry.getValue();</span><br><span class="line">        <span class="comment">// 注册 mappingRegistry</span></span><br><span class="line">        registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>得到<code>Map&lt;Method, T&gt; methods</code>方法之后，就是把这些信息保存起来，<code>registerHandlerMethod(handler, invocableMethod, mapping);</code> 这行代码就是做的这个功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建HandlerMethod</span></span><br><span class="line">        HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">        assertUniqueMethodMapping(handlerMethod, mapping);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Mapped \""</span> + mapping + <span class="string">"\" onto "</span> + handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">        <span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line">            <span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">            addMappingName(name, handlerMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">        <span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = new HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;();</span></span><br><span class="line"><span class="comment">         * key: RequestMappingInfo</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;T&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry</code> 对象，见下图<code>key</code>值是<code>RequestMappingInfo</code> <code>value</code>是<code>MappingRegistration</code></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/registry.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><blockquote><p>MappingRegistration.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MappingRegistration</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T mapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerMethod handlerMethod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; directUrls;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mappingName;</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><p><code>Spring Mvc</code>提供了各种各样的抽象，你能感受到面向对象的魅力。</p><ul><li><p><code>RequestMappingInfo</code> 这个类是对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。</p></li><li><p><code>HandlerMethod</code>这个类封装了处理器实例<code>（Controller Bean）</code>和 处理方法实例<code>（Method）</code>以及方法参数数组<code>（MethodParameter[]）</code></p></li><li><p><code>MethodParameter</code>  这个类从2.0就有了，它封装了方法某个参数的相关信息及行为，如该参数的索引，该参数所属方法实例或构造器实例，该参数的类型等。</p></li><li><p><code>HandlerMapping</code> 该接口的实现类用来定义请求和处理器之前的映射关系，其中只定义了一个方法<code>getHandler</code>。</p></li><li><p><code>AbstractHandlerMethodMapping</code> 这是<code>HandlerMapping</code>的一个基本实现类，该类定义了请求与<code>HandlerMethod</code>实例的映射关系。</p></li><li><p><code>RequestMappingInfoHandlerMapping</code>这个是<code>AbstractHandlerMethodMapping</code>的实现类，他维护了一个<code>RequestMappingInfo</code>和<code>HandlerMethod</code>的Map属性。</p></li><li><p><code>RequestMappingHandlerMapping</code> 这个是<code>RequestMappingInfoHandlerMapping</code>的子类，它将<code>@RequestMapping</code>注解转化为<code>RequestMappingInfo</code>实例，并为父类使用。也就是我们处理@RequestMapping的终点。</p></li><li><p><code>InitializingBean</code> 这个接口定义了其实现<code>Bean</code>在容器完成属性设置后可以执行自定义初始化操作，我们的<code>AbstractHandlerMethodMapping</code>便实现了这个接口，并且定义了一组自定义操作，就是用来检测处理我们的@RequestMapping注解。</p></li></ul></li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="https://www.cnblogs.com/taotingkai/p/8438360.html" target="_blank" rel="noopener">https://www.cnblogs.com/taotingkai/p/8438360.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;上一章节介绍了&lt;code&gt;请求映射处理组件HandlerMapping&lt;/code&gt;的主体处理流
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(四)请求映射处理组件HandlerMapping</title>
    <link href="http://www.songshuiyang.site/2019/02/25/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E5%9B%9B)%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%A4%84%E7%90%86%E7%BB%84%E4%BB%B6HandlerMapping/"/>
    <id>http://www.songshuiyang.site/2019/02/25/backend/spring/sourceCodeAnalysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping/</id>
    <published>2019-02-25T12:59:44.000Z</published>
    <updated>2019-03-03T02:27:39.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><ul><li><p>上一章节介绍了<code>Spring Mvc</code>执行一个普通请求的整体流程，这一章节介绍其请求映射处理组件<code>HandlerMapping</code> 的作用</p></li><li><p><code>HandlerMapping</code>负责根据<code>request</code>请求找到对应的<code>Handler</code>处理器及<code>Interceptor</code>拦截器,并将它们封装在<code>HandlerExecutionChain</code>对象内，返回给中央调度器</p></li></ul><h2 id="2-1-请求映射处理组件HandlerMapping-解析"><a href="#2-1-请求映射处理组件HandlerMapping-解析" class="headerlink" title="2.1 请求映射处理组件HandlerMapping 解析"></a>2.1 请求映射处理组件<code>HandlerMapping</code> 解析</h2><h3 id="2-1-1-HandlerMapping-解析"><a href="#2-1-1-HandlerMapping-解析" class="headerlink" title="2.1.1 HandlerMapping 解析"></a>2.1.1 <code>HandlerMapping</code> 解析</h3><ul><li>先来回顾核心方法体<code>doDispatch(HttpServletRequest request, HttpServletResponse response)</code>，查看<code>HandlerMapping</code> 对应的处理逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联</span></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 检查是否有 Multipart，有则将请求转换为 Multipart 请求</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line"><span class="comment">// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line"><span class="comment">// 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line"><span class="comment">// 处理 last-modified 请求头</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line"><span class="comment">// 执行实际的处理程序</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"><span class="comment">// 遍历拦截器，执行它们的 postHandle() 方法</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="comment">// 遍历拦截器，执行它们的 afterCompletion() 方法</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>下面是请求映射处理组件<code>HandlerMapping</code> 主要的处理代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line"><span class="comment">// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续在<code>doDispatch</code>方法中<code>mappedHandler = getHandler(processedRequest);</code> 这行代码打好断点，进入该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the HandlerExecutionChain for this request.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Tries all handler mappings in order.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the HandlerExecutionChain, or &#123;<span class="doctag">@code</span> null&#125; if no handler could be found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping</span></span><br><span class="line"><span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(</span><br><span class="line"><span class="string">"Testing handler map ["</span> + hm + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain</span></span><br><span class="line">HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 注意这里是找到第一个就直接返回</span></span><br><span class="line"><span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>this.handlerMappings</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** List of HandlerMappings used by this servlet */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br></pre></td></tr></table></figure><ul><li>可以看到是遍历了<code>this.handlerMappings</code>这个对象，这个对象是个<code>list</code>，<code>HandlerMapping</code>的初始化处理在第二章有其介绍， 在调试过程中，我们可以看到，默认加载的是如下图所示的的<code>HandlerMapping</code>，</li></ul><p><img src="/images/server/spring/spring-mvc/HandlerMapping1.png" alt=""></p><ul><li><p>下面来介绍这三种常用的<code>HandlerMapping</code>的作用 </p><ul><li><p><code>RequestMappingHandlerMapping</code>是三个中最常用的<code>handlerMapping</code>，使用注解方式最为方便快捷，<code>SpringMvc</code>项目开发都是采用这种形式，配合<code>@RequestMapping()</code>相关注释就可以完成开发</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 访问静态资源 --&gt;</span><br><span class="line">&lt;mvc:<span class="keyword">default</span>-servlet-handler /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;!-- 配置扫描的包 --&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.songsy.*"</span> /&gt;</span><br><span class="line">   </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(<span class="keyword">this</span>.getClass());</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SimpleUrlHandlerMapping</code></p><p>  <code>SimpleUrlHandlerMapping</code>的<code>Controller</code>处理类需要实现<code>Controller</code>接口，并注册成<code>Bean</code>就可以完成配置，处理逻辑写在<code>handleRequest</code>方法体内</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"mappings"</span>&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key="/simpleUrlHandlerMapping.do"&gt;welcomeController&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">     &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rob Harrop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"welcomeView"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>BeanNameUrlHandlerMapping</code>需要配置 <code>&lt;bean id=&quot;/index&quot; class=&quot;com.alipay.web.TestController&quot; /&gt;</code>，注意在bean的id中要加上斜杆，Controller方面的测试代码跟前面的SimpleUrlHandlerMapping一样，实现Controller，重写handlerRequest()方法即可。</p></li></ul></li></ul><h3 id="2-1-2-HandlerMapping-注册过程"><a href="#2-1-2-HandlerMapping-注册过程" class="headerlink" title="2.1.2 HandlerMapping 注册过程"></a>2.1.2 <code>HandlerMapping</code> 注册过程</h3><ul><li><p>回到<code>DispatcherServlet</code> 类中<code>onRefresh</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 上传组件组件初始化</span></span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line"><span class="comment">// 请求映射处理组件初始化</span></span><br><span class="line">initHandlerMappings(context);</span><br><span class="line"><span class="comment">// 处理适配器组建初始化</span></span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line"><span class="comment">// 异常处理组件初始化</span></span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line"><span class="comment">// 视图处理组件初始化</span></span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>initHandlerMappings(context);</code>方法，这里实现了<code>HandlerMappings</code>的注册过程， <code>BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);</code> 可以看到用了<code>Spring</code>的工具类 <code>beansOfTypeIncludingAncestors</code> 返回给定类型或子类型的所有bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the HandlerMappings used by this class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace,</span></span><br><span class="line"><span class="comment"> * we default to BeanNameUrlHandlerMapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line"><span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">           <span class="comment">// 在ApplicationContext bean中找到所有HandlerMappings</span></span><br><span class="line">Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class="line"><span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line"><span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下一章节来跟进<code>RequestMappingHandlerMapping</code>这个<code>HandlerMapping</code> 的具体实现</p></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><code>HandlerMapping</code>我们知道他的作用是根据<code>request</code>找到对应的<code>Handler</code>，<code>Handler</code>具体表现形式可以为类，也可以为方法，上面的三种常用的<code>HandlerMapping</code>有其介绍，我们平常使用<code>@RequestMapping</code>注解来标识一个方法，这个注解的作用就是将这个方法注册为<code>Handler</code></li><li>为什么需要要多种<code>HandlerMapping</code>呢，当然是为了其可扩展性，实现<code>HandlerMapping</code>接口就可以实现自定义<code>Handler</code>的获取，从而实现定制化</li><li><code>Spring Mvc</code> 大量使用了<code>模版方法模式</code>，父类定义流程，子类实现，而这些口子都是所谓的模板方法，可以自由指定，从而保证了灵活性，良好的抽象设计，是整个框架变得非常灵活</li><li><code>Spring Mvc</code> 核心类中所有的变量声明，几乎都以接口的形式给出，并没有绑定在具体的实现类上</li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="https://www.jianshu.com/p/e4f1c9326223" target="_blank" rel="noopener">https://www.jianshu.com/p/e4f1c9326223</a></p><p><a href="https://blog.csdn.net/gaoshan12345678910/article/details/81778587" target="_blank" rel="noopener">https://blog.csdn.net/gaoshan12345678910/article/details/81778587</a></p><p><a href="https://blog.csdn.net/lang_programmer/article/details/71598042" target="_blank" rel="noopener">https://blog.csdn.net/lang_programmer/article/details/71598042</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上一章节介绍了&lt;code&gt;Spring Mvc&lt;/code&gt;执行一个普通请求的整体流程，这
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(三)核心分发器DispatcherServlet处理流程</title>
    <link href="http://www.songshuiyang.site/2019/01/28/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%B8%89)%E6%A0%B8%E5%BF%83%E5%88%86%E5%8F%91%E5%99%A8DispatcherServlet%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/01/28/backend/spring/sourceCodeAnalysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程/</id>
    <published>2019-01-28T12:59:44.000Z</published>
    <updated>2019-03-03T02:27:39.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><p>上一章节介绍了<code>DispatcherServlet</code>的初始化过程，这一章节介绍核心分发器<code>DispatcherServlet</code>是怎样处理请求的</p><h2 id="2-1-DispatcherServlet-处理请求过程"><a href="#2-1-DispatcherServlet-处理请求过程" class="headerlink" title="2.1 DispatcherServlet 处理请求过程"></a>2.1 DispatcherServlet 处理请求过程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/spring-mvc-handle.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>既然<code>DispatcherServlet</code>本身是<code>Servlet</code>，我们就要专注于它的<code>service、doGet、doPost</code>等相关方法，在<code>FrameworkServlet</code>里可以看到<code>service、doGet、doPost</code>这些方法的重载实现，可以看到都是流转到<code>processRequest(request, response);</code>这个方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override the parent class implementation in order to intercept PATCH requests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="keyword">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate GET requests to processRequest/doService.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Will also be invoked by HttpServlet's default implementation of &#123;<span class="doctag">@code</span> doHead&#125;,</span></span><br><span class="line"><span class="comment"> * with a &#123;<span class="doctag">@code</span> NoBodyResponse&#125; that just captures the content length.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doHead</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate POST requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate PUT requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPut</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delegate DELETE requests to &#123;<span class="doctag">@link</span> #processRequest&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doService</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doDelete</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据<code>service</code>方法，我们一步步找到一个方法链<code>service –&gt; processRequest –&gt; doService –&gt; doDispatch</code>，我们最终将目光定位在<code>doDispatch</code>，因为从它的方法体就可以看出它是整个<code>SpringMVC</code>的核心方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order.</span></span><br><span class="line"><span class="comment"> * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters</span></span><br><span class="line"><span class="comment"> * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment"> * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联</span></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 检查是否有 Multipart，有则将请求转换为 Multipart 请求</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line"><span class="comment">// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line"><span class="comment">// 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line"><span class="comment">// 处理 last-modified 请求头</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line"><span class="comment">// 执行实际的处理程序</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"><span class="comment">// 遍历拦截器，执行它们的 postHandle() 方法</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="comment">// 遍历拦截器，执行它们的 afterCompletion() 方法</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说它是核心一点也不为过，从上述代码的中文注释可以看出，它包含了解析请求，执行相关拦截器，执行handle方法，这行代码是真正执行我们controller的方法<code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>，那<code>SpringMvc</code>是怎样找到我们的方法的呢，下一章节将介绍</p></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><code>Spring Mvc</code> 的处理方式是先在顶层设计好整体结构，然后将具体的处理交给不同的组件具体去实现</li><li><code>DispatcherServlet</code>中的<code>doDispatch</code>方法完成了具体的请求处理，下面是主要流程<ul><li>遍历所有的 <code>HandlerMapping</code> 找到与请求对应的 <code>Handler</code>，并将其与一堆拦截器封装到 <code>HandlerExecutionChain</code> 对象中</li><li>遍历所有的 <code>HandlerAdapter</code>，找到可以处理该 <code>Handler</code> 的 <code>HandlerAdapter</code></li><li>执行相应拦截器<code>Interceptor</code>的<code>preHandle</code>方法</li><li><code>HandlerAdapter</code> 执行<code>Hander</code>，由<code>Hander</code> 执行实际的处理程序，执行Controller里的方法</li><li>调用<code>processDispatchResult</code>处理结果</li><li>执行相应拦截器<code>Interceptor</code>的<code>postHandle</code>方法</li></ul></li><li>下面是流程图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/dispatcherServlet1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <ul><li>下面的章节将详细介绍这些流程<ul><li>1、请求映射处理组件<code>HandlerMapping</code>处理 </li><li>2、<code>HandlerAdapter</code>处理 </li><li>3、<code>Interceptor</code>的<code>preHandle</code>方法处理</li><li>4、<code>Hander</code> 执行实际的处理程序，执行Controller里的方法 </li><li>5、调用<code>processDispatchResult</code>处理结果</li><li>6、Interceptor<code>的</code>postHandle`方法处理<h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></li></ul></li></ul><p><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html</a></p><p><a href="https://blog.csdn.net/lang_programmer/article/details/71598042" target="_blank" rel="noopener">https://blog.csdn.net/lang_programmer/article/details/71598042</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;p&gt;上一章节介绍了&lt;code&gt;DispatcherServlet&lt;/code&gt;的初始化过程，这一章节介绍核心分发
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(二)核心分发器DispatcherServlet初始化</title>
    <link href="http://www.songshuiyang.site/2019/01/23/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%BA%8C)%E6%A0%B8%E5%BF%83%E5%88%86%E5%8F%91%E5%99%A8DispatcherServlet%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://www.songshuiyang.site/2019/01/23/backend/spring/sourceCodeAnalysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化/</id>
    <published>2019-01-23T12:59:44.000Z</published>
    <updated>2019-03-10T01:44:49.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1 前言"></a>1.1 前言</h2><p>我们都知道<code>DispatcherServlet</code>是所谓前端控制器，是整个<code>Spring Mvc</code>的入口，但是这个前端控制器里面又有很多箱子，每一个箱子都有其独有的功能，当我们翻开一个箱子之后看看里面有什么的时候，又会发现箱子里面装着又一个箱子，所以我们需要一个个的探究这些箱子。</p><h2 id="2-1-DispatcherServlet-初始化过程"><a href="#2-1-DispatcherServlet-初始化过程" class="headerlink" title="2.1 DispatcherServlet 初始化过程"></a>2.1 DispatcherServlet 初始化过程</h2><h3 id="2-1-1-配置-DispatcherServlet"><a href="#2-1-1-配置-DispatcherServlet" class="headerlink" title="2.1.1 配置 DispatcherServlet"></a>2.1.1 配置 DispatcherServlet</h3><ul><li><p>首先，Tomcat每次启动时都会加载并解析/WEB-INF/web.xml文件，所以可以先从web.xml找突破口，主要代码如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span> &gt;</span>spring-mvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- servlet类 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span> &gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 初始化参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span> &gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span> &gt;</span>classpath:/spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 启动时加载 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span> &gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span> &gt;</span>spring-mvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span> &gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以看到 <code>DispatcherServlet</code> 本身就是个<code>Servlet</code>，那么看看<code>DispatcherServlet</code>做了什么呢，我们先看下DispatcherServlet的继承关系，重点关注<code>HttpServletBean</code> 和<code>FrameworkServlet</code> 这两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GenericServlet (javax.servlet)</span><br><span class="line">    HttpServlet (javax.servlet.http)</span><br><span class="line">        HttpServletBean (org.springframework.web.servlet)</span><br><span class="line">            FrameworkServlet (org.springframework.web.servlet)</span><br><span class="line">                DispatcherServlet (org.springframework.web.servlet)</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="source/images/server/spring/spring-mvc/DispatcherServlet.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>通过上图可以看到 <code>DispatcherServlet</code> 实现了Spring 的<code>ApplicationContextAware</code>、<code>EnvironmentCapable</code>、 <code>EnvironmentAware</code>这些<code>Spring</code>中的接口，<code>XXXAware</code>在<code>Spring</code>中表示对XXX可以感知，通俗点可以说在某个类中想使用<code>Spring</code>的一些东西，就可以实现<code>XXXAware</code>接口告诉<code>Spring</code>我要这个东西，比如<code>ApplicationContextAware</code>，该接口只有一个方法就是<code>setApplicationContext(ApplicationContext applicationContext)</code>, 通过该方法可以得到<code>ApplicationContext</code>，<code>Spring</code>容器会检测容器中的所有<code>Bean</code>，如果发现某个<code>Bean</code>实现了<code>ApplicationContextAware</code>接口，Spring容器会在创建该<code>Bean</code>之后，自动调用该<code>Bean</code>的<code>setApplicationContextAware()</code>方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将<code>Spring</code>传入的参数（容器本身）赋给该类对象的<code>applicationContext</code>实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。实现<code>XXXCapable</code>接口表示可以得到某种能力，实现<code>EnvironmentCapable</code>接口说明可以得到<code>Environment</code>的能力，也就是可以提供<code>Environment</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext == <span class="keyword">null</span> &amp;&amp; applicationContext <span class="keyword">instanceof</span> WebApplicationContext) &#123;</span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = (WebApplicationContext) applicationContext;</span><br><span class="line"><span class="keyword">this</span>.webApplicationContextInjected = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>HttpServletBean</code> 覆写了<code>GenericServlet</code> 的<code>init</code>方法，此方法是第一次访问该<code>DispatcherServlet</code>的时候就会执行，对初始化过程做了一些处理，<code>HttpServletBean</code> 这个类的作用主要做一些初始化的工作，将<code>web.xml</code>中配置的参数设置到<code>Servlet</code>中。比如<code>servlet</code>标签的子标签<code>init-param</code>标签中配置的参数(classpath:/spring-mvc.xml)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造过程中会使用ServletConfig对象找出web.xml配置文件中的配置参数并设置到ServletConfigPropertyValues内部</span></span><br><span class="line"><span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 使用BeanWrapper构造DispatcherServlet</span></span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="comment">// 设置DispatcherServlet属性</span></span><br><span class="line">bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让子类去做一些事情，这种在父类定义在子类实现的方式叫做模版方法模式</span></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like</span></span><br><span class="line">initServletBean();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>initServletBean()</code>方法，该方法的实现在<code>FrameworkServlet</code> 类里，这个类的作用是将Servlet与Spring容器上下文关联。其实也就是初始化FrameworkServlet的属性webApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Overridden method of &#123;<span class="doctag">@link</span> HttpServletBean&#125;, invoked after any bean properties</span></span><br><span class="line"><span class="comment"> * have been set. Creates this servlet's WebApplicationContext.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 初始化 WebApplicationContext (即SpringMVC的IOC容器)</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line"><span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>this.webApplicationContext = initWebApplicationContext();</code>方法，这个方法的作用是先得到根上下文<code>rootContext</code> 然后创建<code>webApplicationContext</code>并设置根上下文（将 Spring 的容器设为 SpringMVC 容器的父容器），最后就是发布这个 <code>WebApplicationContext</code> 容器到 <code>ServletContext</code> 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize and publish the WebApplicationContext for this servlet.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Delegates to &#123;<span class="doctag">@link</span> #createWebApplicationContext&#125; for actual creation</span></span><br><span class="line"><span class="comment"> * of the context. Can be overridden in subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the WebApplicationContext instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #FrameworkServlet(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextClass</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setContextConfigLocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取ContextLoaderListener 初始化并注册在 ServletContext 中的根容器，即 Spring 的容器</span></span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"><span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line"><span class="comment">// 将 Spring 的容器设为 SpringMVC 容器的父容器</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"><span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line"><span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line"><span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line"><span class="comment">// 如果 WebApplicationContext 为空，则进行查找，能找到说明上下文已经在别处初始化。</span></span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line"><span class="comment">// 如果 WebApplicationContext 仍为空，则以 Spring 的容器为父上下文建立一个新的，并设置根上下文为父上下文</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line"><span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line"><span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line"><span class="comment">// 模版方法，由 DispatcherServlet 实现</span></span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line"><span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line"><span class="comment">// 发布这个 WebApplicationContext 容器到 ServletContext 中</span></span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line"><span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里的根上下文是<code>web.xml</code>中配置的<code>ContextLoaderListener</code>监听器中根据<code>contextConfigLocation</code>路径生成的上下文。比如这段配置文件中根据<code>classpath:springConfig/applicationContext.xml</code>下的<code>xml</code>文件生成的根上下文。<code>ContextLoaderListener</code> 实现了<code>ServletContextListener</code>，当配置了<code>listener</code>之后启动web容器就会执行它实现的方法，使用<code>ServletContextListener</code>接口，开发者能够在客户端请求提供服务之前向<code>ServletContext</code>中添加任意的对象，<code>ServletContext</code>在web容器运行期间都是可见的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springConfig/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>onRefresh(wac);</code> 由 <code>DispatcherServlet</code> 实现，这里的操作就是<code>Spring Mvc</code>自身的初始化过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This implementation calls &#123;<span class="doctag">@link</span> #initStrategies&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// initStrategies方法内部会初始化各个策略接口的实现类。</span></span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 上传组件组件初始化</span></span><br><span class="line">initMultipartResolver(context);</span><br><span class="line">initLocaleResolver(context);</span><br><span class="line">initThemeResolver(context);</span><br><span class="line"><span class="comment">// 请求映射处理组件初始化</span></span><br><span class="line">initHandlerMappings(context);</span><br><span class="line"><span class="comment">// 处理适配器组建初始化</span></span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line"><span class="comment">// 异常处理组件初始化</span></span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line"><span class="comment">// 视图处理组件初始化</span></span><br><span class="line">initViewResolvers(context);</span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-1-1-DispatcherServlet-默认加载bean"><a href="#2-1-1-DispatcherServlet-默认加载bean" class="headerlink" title="2.1.1 DispatcherServlet 默认加载bean"></a>2.1.1 DispatcherServlet 默认加载bean</h3><ul><li><p><code>DispatcherServlet</code> 初始化的时候会默认加载一些组件，代码如下，可以看到是在<code>static</code>代码块中读取一个配置文件并把它注册为<code>Properties defaultStrategies</code>对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Name of the class path resource (relative to the DispatcherServlet class)</span></span><br><span class="line"><span class="comment"> * that defines DispatcherServlet's default strategy names.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"DispatcherServlet.properties"</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">       <span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">       <span class="comment">// by application developers.</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);</span><br><span class="line">           defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="string">"': "</span> + ex.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>DispatcherServlet.properties</code>文件，该文件在<code>Spring web mvc</code> 包下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Default implementation classes for DispatcherServlet&apos;s strategy interfaces.</span><br><span class="line"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span><br><span class="line"># Not meant to be customized by application developers.</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><span class="line"></span><br><span class="line">org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</span><br></pre></td></tr></table></figure></li><li><p>从如上配置可以看出<code>DispatcherServlet</code> 配置的是一些类的全限定名，那它是在哪里调用的呢，还是回到之前的<code>onRefresh(wac);</code> 的<code>initStrategies(ApplicationContext context)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上传组件组件初始化</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 请求映射处理组件初始化</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    <span class="comment">// 处理适配器组建初始化</span></span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">// 异常处理组件初始化</span></span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 视图处理组件初始化</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>initHandlerMappings(context);</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line"><span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">           <span class="comment">// 在ApplicationContext bean中找到所有HandlerMappings， beansOfTypeIncludingAncestors 返回给定类型或子类型的所有bean</span></span><br><span class="line">Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class="line"><span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line"><span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line"><span class="comment">// a default HandlerMapping if no other mappings are found.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 在这里将设置</span></span><br><span class="line"><span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</code> 这行代码，可以看到<code>this.handlerMappings</code> 在这里赋值，继续进入该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getDefaultStrategies</span><span class="params">(ApplicationContext context, Class&lt;T&gt; strategyInterface)</span> </span>&#123;</span><br><span class="line">    String key = strategyInterface.getName();</span><br><span class="line">    String value = defaultStrategies.getProperty(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] classNames = StringUtils.commaDelimitedListToStringArray(value);</span><br><span class="line">        List&lt;T&gt; strategies = <span class="keyword">new</span> ArrayList&lt;T&gt;(classNames.length);</span><br><span class="line">        <span class="keyword">for</span> (String className : classNames) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());</span><br><span class="line">                Object strategy = createDefaultStrategy(context, clazz);</span><br><span class="line">                strategies.add((T) strategy);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span><br><span class="line">                        <span class="string">"Could not find DispatcherServlet's default strategy class ["</span> + className +</span><br><span class="line">                                <span class="string">"] for interface ["</span> + key + <span class="string">"]"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(</span><br><span class="line">                        <span class="string">"Error loading DispatcherServlet's default strategy class ["</span> + className +</span><br><span class="line">                                <span class="string">"] for interface ["</span> + key + <span class="string">"]: problem with class file or dependent class"</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从可以看到<code>String value = defaultStrategies.getProperty(key);</code> 这里使用了我们的配置对象，<code>createDefaultStrategy</code> 方法就是根据<code>Class</code>对象来创建<code>bean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createDefaultStrategy</span><span class="params">(ApplicationContext context, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.getAutowireCapableBeanFactory().createBean(clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-1-总结"><a href="#3-1-总结" class="headerlink" title="3.1 总结"></a>3.1 总结</h2><ul><li><p>HttpServletBean 主要做一些初始化的工作，将web.xml中配置的参数设置到Servlet中。比如servlet标签的子标签init-param标签中配置的参数。</p></li><li><p>FrameworkServlet 将Servlet与Spring容器上下文关联。其实也就是初始化FrameworkServlet的属性webApplicationContext，这个属性代表SpringMVC上下文，它有个父类上下文，既web.xml中配置的ContextLoaderListener监听器初始化的容器上下文。</p></li><li><p>DispatcherServlet 初始化各个功能的实现类。比如异常处理、视图处理、请求映射处理等。</p></li><li><p><code>DispatcherServlet</code>会自动注册一些特殊的<code>Bean</code>，无需我们注册，如果我们注册了，默认的将不会注册。 因此<code>BeanNameUrlHandlerMapping、SimpleControllerHandlerAdapter</code>是不需要注册的，<code>DispatcherServlet</code>默认会注册这两个<code>Bean</code>。</p></li></ul><h2 id="4-1-参考"><a href="#4-1-参考" class="headerlink" title="4.1 参考"></a>4.1 参考</h2><p>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></p><p><a href="http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html" target="_blank" rel="noopener">http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html</a></p><p><a href="https://blog.csdn.net/lang_programmer/article/details/71598042" target="_blank" rel="noopener">https://blog.csdn.net/lang_programmer/article/details/71598042</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-前言&quot;&gt;&lt;a href=&quot;#1-1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.1 前言&quot;&gt;&lt;/a&gt;1.1 前言&lt;/h2&gt;&lt;p&gt;我们都知道&lt;code&gt;DispatcherServlet&lt;/code&gt;是所谓前端控制器，是整个&lt;code&gt;S
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Mvc源码(一)Spring Mvc介绍</title>
    <link href="http://www.songshuiyang.site/2019/01/23/backend/spring/sourceCodeAnalysis/Spring%20Mvc%E6%BA%90%E7%A0%81(%E4%B8%80)Spring%20Mvc%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.songshuiyang.site/2019/01/23/backend/spring/sourceCodeAnalysis/Spring Mvc源码(一)Spring Mvc介绍/</id>
    <published>2019-01-23T11:59:44.000Z</published>
    <updated>2019-02-26T12:02:32.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-什么是Spring-Mvc"><a href="#1-1-什么是Spring-Mvc" class="headerlink" title="1.1 什么是Spring Mvc"></a>1.1 什么是Spring Mvc</h3><ul><li><p>在JavaEE体系结构中一个应用可以划分为四个层次，从上到下分别是应用层、Web层、业务层、持久层，现在的项目大都是按照这种结构来开发，我们这一系列介绍的是Web层的处理框架<code>Spring Mvc</code></p></li><li><p><code>Spring Web Mvc</code>是一种基于Java的轻量级Web框架，使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。</p></li></ul><h3 id="2-1-为什么要使用Spring-Mvc"><a href="#2-1-为什么要使用Spring-Mvc" class="headerlink" title="2.1 为什么要使用Spring Mvc"></a>2.1 为什么要使用Spring Mvc</h3><h4 id="2-1-1-没有使用Spring-Mvc会怎么样"><a href="#2-1-1-没有使用Spring-Mvc会怎么样" class="headerlink" title="2.1.1 没有使用Spring Mvc会怎么样"></a>2.1.1 没有使用Spring Mvc会怎么样</h4><p>在Web开发模式中，主要有两个开发模式，称为模式一（Mode I）和模式二（Mode II）. 模式二是因为受不了模式一的缺点而进化出来的，而Spring Mvc则是模式二的进化版本，下面是两种模式的介绍：</p><ul><li>模式一（Mode I）指的就是在开发中将显示层、控制层、数据层的操作统一交给JSP或者JavaBean来进行处理！<ul><li>优点<ul><li>开发速度贼快，适合炒鸡简单的应用 </li></ul></li><li>缺点<ul><li>程序的可读性差、复用性低、代码复杂！什么jsp代码、html代码都往上面写，这肯定很难阅读，很难重用！</li><li>要求开发者不仅要掌握 Java ，还要有高超的前端水平</li><li>前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</li></ul></li></ul></li></ul><p><img src="/images/server/spring/spring-mvc/model1.png" alt=""></p><ul><li><p>模式二（Mode II）中所有的开发都是以Servlet为主体展开的，由Servlet接收所有的客户端请求，然后根据请求调用相对应的JavaBean，并所有的显示结果交给JSP完成！，也就是俗称的MVC设计模式</p><ul><li>优点<ul><li>相比模式一，耦合度降低了，添加了Servlet来协调视图处理及业务数据处理</li></ul></li><li><p>缺点</p><ul><li>需要定义大量的Servlet来处理应用</li></ul></li><li><p>MVC设计模式</p><ul><li>模型层（Mode）：模型是什么呢？ 模型就是数据，就是 dao,bean</li><li>显示层（View）：视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</li><li>控制层（Controller）：控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</li></ul></li></ul></li><li><p>很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/model2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>模式二（Mode II）就很完美吗，不不不，还可以进行优化，所以有了Web Mvc框架</p><ul><li>常见的Web Mvc框架有<code>Sturts</code>及主角<code>Spring Mvc</code></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-mvc/model3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="2-1-2-对比其他WEB框架有那些优势"><a href="#2-1-2-对比其他WEB框架有那些优势" class="headerlink" title="2.1.2 对比其他WEB框架有那些优势"></a>2.1.2 对比其他WEB框架有那些优势</h4><ul><li>使用简单，对于开发人员来说实现一个功能肯定是实现越简单越好，Spring Mvc配合一系列注解即可完成Web应用的开发，尤其是在SpringBoot上的体现越明显</li><li>性能上Spring会稍微比Struts快。Spring mvc是基于方法的设计，而Sturts是基于类，每次发一次请求都会实例一个action，每个action都会被注入属性，而Spring基于方法，粒度更细，但要小心把握像在Servlet控制数据一样。</li><li>易于和Spring容器集成，毕竟是自己家里人</li></ul><h3 id="3-1-使用Spring-Mvc"><a href="#3-1-使用Spring-Mvc" class="headerlink" title="3.1 使用Spring Mvc"></a>3.1 使用Spring Mvc</h3><h3 id="4-1-总结"><a href="#4-1-总结" class="headerlink" title="4.1 总结"></a>4.1 总结</h3><ul><li>框架本身就是为了找到一个平衡，用哪个合适，就用哪个</li></ul><h3 id="5-1-参考"><a href="#5-1-参考" class="headerlink" title="5.1 参考"></a>5.1 参考</h3><ul><li>官方文档: <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html</a></li><li><a href="https://www.cnblogs.com/wmyskxz/p/8848461.html" target="_blank" rel="noopener">https://www.cnblogs.com/wmyskxz/p/8848461.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-1-什么是Spring-Mvc&quot;&gt;&lt;a href=&quot;#1-1-什么是Spring-Mvc&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是Spring Mvc&quot;&gt;&lt;/a&gt;1.1 什么是Spring Mvc&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="spring mvc" scheme="http://www.songshuiyang.site/tags/spring-mvc/"/>
    
      <category term="spring" scheme="http://www.songshuiyang.site/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码(二十二)使用拦截器Interceptor完成分页</title>
    <link href="http://www.songshuiyang.site/2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis%E6%BA%90%E7%A0%81(%E4%BA%8C%E5%8D%81%E4%BA%8C)%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E5%AE%8C%E6%88%90%E5%88%86%E9%A1%B5/"/>
    <id>http://www.songshuiyang.site/2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页/</id>
    <published>2018-12-22T12:56:00.000Z</published>
    <updated>2018-12-22T14:06:52.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只要有列表就会有分页功能，利用Mybatis拦截器Interceptor可以十分方便的完成分页功能</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在执行查询sql之前的时候只要添加<code>limit</code>关键字，即可完成分页，除了分页之外需要<code>count(*)</code>获取数据总数，然后通过页码得到页数</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p><code>Page.java</code> 分页对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;                                        <span class="comment">// 当前页尾条记录位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;                                      <span class="comment">// 每页记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> page;                                       <span class="comment">// 当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;                                     <span class="comment">// 总记录数</span></span><br><span class="line">    <span class="keyword">private</span> String sortName;                                <span class="comment">// 排序列</span></span><br><span class="line">    <span class="keyword">private</span> String sortOrder;                               <span class="comment">// 排序方式</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">// 请求参数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; columns = Lists.newArrayList();    <span class="comment">// 查询出来的参数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();               <span class="comment">// 记录</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限制分页长度</span></span><br><span class="line"><span class="comment">     * limit：0 不限制大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Page</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Page</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String param = <span class="keyword">null</span>;</span><br><span class="line">        String value = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        param = <span class="string">"pageIndex"</span>;</span><br><span class="line">        value = request.getParameter(param);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.page = Integer.parseInt(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.page = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        param = <span class="string">"limit"</span>;</span><br><span class="line">        value = request.getParameter(param);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.limit = Integer.parseInt(value);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.limit &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.limit = <span class="number">15</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.limit = <span class="number">15</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        param = <span class="string">"sortName"</span>;</span><br><span class="line">        value = request.getParameter(param);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sortName = CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        param = <span class="string">"sortOrder"</span>;</span><br><span class="line">        value = request.getParameter(param);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sortOrder = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.sortOrder = <span class="string">"asc"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String[]&gt; paramMap = request.getParameterMap();</span><br><span class="line">        <span class="keyword">for</span> (String key : paramMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.startsWith(<span class="string">"s_"</span>)) &#123;</span><br><span class="line">                String vkey = key.substring(<span class="number">2</span>);</span><br><span class="line">                String[] _params = paramMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (_params.length &gt; <span class="number">0</span> &amp;&amp; StringUtils.isNotEmpty(_params[<span class="number">0</span>])) &#123;</span><br><span class="line">                    getParams().put(vkey, StringUtils.join(_params, <span class="string">"&gt;"</span>).trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前页首条记录位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (page - <span class="number">1</span>) * limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总页数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.ceil(total / Double.valueOf(limit));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须和数据库字段一致</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sortName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSortName</span><span class="params">(String sortName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sortName = sortName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置默认排序方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sortName  需要排序的表字段，数据库字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sortOrder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDefault</span><span class="params">(String sortName, String sortOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (org.apache.commons.lang3.StringUtils.isEmpty(getSortName()) || org.apache.commons.lang3.StringUtils.isEmpty(getSortOrder())) &#123;</span><br><span class="line">            setSortName(sortName);</span><br><span class="line">            setSortOrder(sortOrder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSortName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSortOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSortOrder</span><span class="params">(String sortOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sortOrder = sortOrder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.params = params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(key, <span class="string">"key must be not null"</span>);</span><br><span class="line">        Assert.notNull(value, <span class="string">"value must be not null "</span>);</span><br><span class="line">        <span class="keyword">this</span>.params.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getRows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRows</span><span class="params">(List&lt;T&gt; rows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getColumns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> columns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColumns</span><span class="params">(List&lt;String&gt; columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.columns = columns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLimit</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPage</span><span class="params">(<span class="keyword">int</span> page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.page = page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">long</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>PageInterceptor.java</code> 拦截器，此类<code>intercept</code> 方法是完成分页实现方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis拦截器，实现接口分页，拦截Executor接口的query方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123; <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123; MappedStatement.class, Object.class,</span><br><span class="line">        RowBounds.class, ResultHandler.class &#125;) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(PageInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> MAPPED_STATEMENT_INDEX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> PARAMETER_INDEX = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ROWBOUNDS_INDEX = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> RESULT_HANDLER_INDEX = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要拦截的ID(正则匹配)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PAGE_SQL_ID = <span class="string">".*Page$"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * setProperties方法是用于在Mybatis配置文件中指定一些属性的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器用于封装目标对象</span></span><br><span class="line"><span class="comment">     * 在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Executor.class.isAssignableFrom(o.getClass())) &#123;</span><br><span class="line">            <span class="comment">// 在这里返回新的 PageExecutor，用于装饰原Executor</span></span><br><span class="line">            <span class="keyword">return</span> Plugin.wrap(<span class="keyword">new</span> PageExecutor((Executor) o), <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(o, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在这里完成分页及排序操作得到 新的BoundSql 然后执行查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] queryArgs = invocation.getArgs();</span><br><span class="line">        <span class="comment">// MappedStatement对象对应Mapper配置文件中的一个select/update/insert/delete节点，主要描述的是一条SQL语句</span></span><br><span class="line">        <span class="keyword">final</span> MappedStatement mappedStatement = (MappedStatement) queryArgs[MAPPED_STATEMENT_INDEX];</span><br><span class="line">        <span class="comment">// 获取查询参数</span></span><br><span class="line">        <span class="keyword">final</span> Object parameterObject = queryArgs[PARAMETER_INDEX];</span><br><span class="line">        BoundSql boundSql = mappedStatement.getBoundSql(parameterObject);</span><br><span class="line">        <span class="comment">// 拦截以Page结尾的查询方法</span></span><br><span class="line">        <span class="keyword">if</span> (mappedStatement.getId().matches(DEFAULT_PAGE_SQL_ID)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"parameterObject is null!"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果查询参数是Page对象</span></span><br><span class="line">                <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Page&lt;?&gt;) &#123;</span><br><span class="line">                    Page&lt;?&gt; page = (Page&lt;?&gt;) parameterObject;</span><br><span class="line">                    <span class="comment">// 执行总记录数查询</span></span><br><span class="line">                    setTotalRecord(page, mappedStatement, boundSql);</span><br><span class="line">                    <span class="comment">// 拼接排序sql</span></span><br><span class="line">                    String orderSql = getOrderSql(boundSql.getSql(), page);</span><br><span class="line">                    <span class="comment">// 拼接分页sql</span></span><br><span class="line">                    String pageSql = getPageSql(orderSql, page);</span><br><span class="line">                    logger.debug(<span class="string">"page sql :  &#123;&#125; "</span>, pageSql);</span><br><span class="line">                    BoundSql newBoundSql = copyFromBoundSql(mappedStatement, boundSql, pageSql);</span><br><span class="line">                    MappedStatement newMappedStatement = copyFromMappedStatement(mappedStatement,</span><br><span class="line">                            <span class="keyword">new</span> BoundSqlSqlSource(newBoundSql));</span><br><span class="line">                    queryArgs[ROWBOUNDS_INDEX] = <span class="keyword">new</span> RowBounds(RowBounds.NO_ROW_OFFSET, RowBounds.NO_ROW_LIMIT);</span><br><span class="line">                    queryArgs[MAPPED_STATEMENT_INDEX] = newMappedStatement;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到新的 BoundSql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ms</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> boundSql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BoundSql <span class="title">copyFromBoundSql</span><span class="params">(MappedStatement ms, BoundSql boundSql, String sql)</span> </span>&#123;</span><br><span class="line">        BoundSql newBoundSql = <span class="keyword">new</span> BoundSql(ms.getConfiguration(), sql, boundSql.getParameterMappings(),</span><br><span class="line">                boundSql.getParameterObject());</span><br><span class="line">        <span class="keyword">for</span> (ParameterMapping mapping : boundSql.getParameterMappings()) &#123;</span><br><span class="line">            String prop = mapping.getProperty();</span><br><span class="line">            <span class="keyword">if</span> (boundSql.hasAdditionalParameter(prop)) &#123;</span><br><span class="line">                newBoundSql.setAdditionalParameter(prop, boundSql.getAdditionalParameter(prop));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newBoundSql;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到新的 MappedStatement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ms</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newSqlSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MappedStatement <span class="title">copyFromMappedStatement</span><span class="params">(MappedStatement ms, SqlSource newSqlSource)</span> </span>&#123;</span><br><span class="line">        MappedStatement.Builder builder = <span class="keyword">new</span> MappedStatement.Builder(ms.getConfiguration(), ms.getId(), newSqlSource,</span><br><span class="line">                ms.getSqlCommandType());</span><br><span class="line"></span><br><span class="line">        builder.resource(ms.getResource());</span><br><span class="line">        builder.fetchSize(ms.getFetchSize());</span><br><span class="line">        builder.statementType(ms.getStatementType());</span><br><span class="line">        builder.keyGenerator(ms.getKeyGenerator());</span><br><span class="line">        String[] keyProperties = ms.getKeyProperties();</span><br><span class="line">        builder.keyProperty(keyProperties == <span class="keyword">null</span> ? <span class="keyword">null</span> : keyProperties[<span class="number">0</span>]);</span><br><span class="line">        builder.timeout(ms.getTimeout());</span><br><span class="line">        builder.parameterMap(ms.getParameterMap());</span><br><span class="line">        builder.resultMaps(ms.getResultMaps());</span><br><span class="line">        builder.resultSetType(ms.getResultSetType());</span><br><span class="line">        builder.cache(ms.getCache());</span><br><span class="line">        builder.flushCacheRequired(ms.isFlushCacheRequired());</span><br><span class="line">        builder.useCache(ms.isUseCache());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundSqlSqlSource</span> <span class="keyword">implements</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line">        BoundSql boundSql;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BoundSqlSqlSource</span><span class="params">(BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.boundSql = boundSql;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> boundSql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据总数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mappedStatement</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> boundSql</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTotalRecord</span><span class="params">(Page&lt;?&gt; page, MappedStatement mappedStatement, BoundSql boundSql)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String sql = getCountSql(boundSql.getSql());</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        BoundSql countBoundSql = <span class="keyword">new</span> BoundSql(mappedStatement.getConfiguration(), sql, parameterMappings, page);</span><br><span class="line">        ParameterHandler parameterHandler = <span class="keyword">new</span> DefaultParameterHandler(mappedStatement, page, countBoundSql);</span><br><span class="line">        Connection con = mappedStatement.getConfiguration().getEnvironment().getDataSource().getConnection();</span><br><span class="line">        PreparedStatement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">            stmt = con.prepareStatement(sql);</span><br><span class="line">            parameterHandler.setParameters(stmt);</span><br><span class="line">            rs = stmt.executeQuery();</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                total = rs.getInt(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            page.setTotal(total);</span><br><span class="line">            logger.debug(<span class="string">"page count sql   : &#123;&#125;"</span>, sql);</span><br><span class="line">            logger.debug(<span class="string">"page count total : &#123;&#125;"</span>, total);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(rs, stmt);</span><br><span class="line">            JdbcUtils.close(con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到统计总数sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCountSql</span><span class="params">(String sql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = sql.indexOf(<span class="string">"from"</span>) == -<span class="number">1</span> ? sql.indexOf(<span class="string">"FROM"</span>) : sql.indexOf(<span class="string">"from"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"select count(*) "</span> + sql.substring(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到分页sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getPageSql</span><span class="params">(String sql, Page&lt;?&gt; page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (page != <span class="keyword">null</span> &amp;&amp; page.getLimit() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder pageSql = getMySQLPageSql(sql, page);</span><br><span class="line">            <span class="keyword">return</span> pageSql.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到排序sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getOrderSql</span><span class="params">(String sql, Page&lt;?&gt; page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (org.apache.commons.lang3.StringUtils.isNotEmpty(page.getSortName())) &#123;</span><br><span class="line">            StringBuilder pageSql = <span class="keyword">new</span> StringBuilder(<span class="number">100</span>);</span><br><span class="line">            pageSql.append(sql);</span><br><span class="line">            <span class="keyword">if</span> ((page.getSortName().indexOf(<span class="string">"_"</span>) == -<span class="number">1</span>)) &#123;</span><br><span class="line">                page.setSortName(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, page.getSortName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="string">"asc"</span>.equalsIgnoreCase(page.getSortOrder()) || <span class="string">"desc"</span>.equalsIgnoreCase(page.getSortOrder()))) &#123;</span><br><span class="line">                pageSql.append(<span class="string">" order by "</span> + page.getSortName() + <span class="string">" "</span> + page.getSortOrder());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pageSql.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到mysql 分页语句</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">getMySQLPageSql</span><span class="params">(String sql, Page page)</span> </span>&#123;</span><br><span class="line">        StringBuilder pageSql = <span class="keyword">new</span> StringBuilder(<span class="number">100</span>);</span><br><span class="line">        pageSql.append(sql);</span><br><span class="line">        pageSql.append(<span class="string">" limit "</span> + page.getStart() + <span class="string">","</span> + page.getLimit());</span><br><span class="line">        <span class="keyword">return</span> pageSql;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>PageExecutor.java</code> 用于装饰之前的<code>Executor</code>用于将结果赋值到Page对象的rows属性中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(PageExecutor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageExecutor</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">                             CacheKey cacheKey, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;E&gt; rows = executor.query(ms, parameter, rowBounds, resultHandler);</span><br><span class="line">        <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter <span class="keyword">instanceof</span> Page&lt;?&gt;) &#123;</span><br><span class="line">            Page&lt;E&gt; page = (Page&lt;E&gt;) parameter;</span><br><span class="line">            doCache(ms, page, parameter, rowBounds);</span><br><span class="line">            <span class="comment">// 将结果赋值到Page对象的rows属性</span></span><br><span class="line">            page.setRows(rows);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;E&gt; rows = executor.query(ms, parameter, rowBounds, resultHandler);</span><br><span class="line">        <span class="keyword">if</span> (parameter != <span class="keyword">null</span> &amp;&amp; parameter <span class="keyword">instanceof</span> Page&lt;?&gt;) &#123;</span><br><span class="line">            Page&lt;E&gt; page = (Page&lt;E&gt;) parameter;</span><br><span class="line">            doCache(ms, page, parameter, rowBounds);</span><br><span class="line">            <span class="comment">// 将结果赋值到Page对象的rows属性</span></span><br><span class="line">            page.setRows(rows);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">doCache</span><span class="params">(MappedStatement ms, Page&lt;E&gt; result, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Cache cache = ms.getCache();</span><br><span class="line">        <span class="keyword">if</span> (executor.getClass().isAssignableFrom(CachingExecutor.class) &amp;&amp; cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">            BoundSql boundSql = ms.getBoundSql(parameter);</span><br><span class="line">            <span class="keyword">final</span> CacheKey cacheKey = createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"cache executor the cache's kye  is "</span> + cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">            cache.putObject(cacheKey, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutorWrapper</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        executor.setExecutorWrapper(executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.update(ms, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BatchResult&gt; <span class="title">flushStatements</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.flushStatements();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        executor.commit(required);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        executor.rollback(required);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCached</span><span class="params">(MappedStatement ms, CacheKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.isCached(ms, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor.clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deferLoad</span><span class="params">(MappedStatement mappedStatement, MetaObject metaObject, String s, CacheKey cacheKey, Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        executor.deferLoad(mappedStatement, metaObject, s, cacheKey, aClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Transaction <span class="title">getTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.getTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">boolean</span> forceRollback)</span> </span>&#123;</span><br><span class="line">        executor.close(forceRollback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor.isClosed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">Cursor&lt;E&gt; <span class="title">queryCursor</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;只要有列表就会有分页功能，利用Mybatis拦截器Interceptor可以十分方便的完成分页功能&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="mybatis" scheme="http://www.songshuiyang.site/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码(二十三)Mybatis中#{}和${}</title>
    <link href="http://www.songshuiyang.site/2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis%E6%BA%90%E7%A0%81(%E4%BA%8C%E5%8D%81%E4%B8%89)Mybatis%E4%B8%AD#%7B%7D%E5%92%8C$%7B%7D/"/>
    <id>http://www.songshuiyang.site/2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}/</id>
    <published>2018-12-22T10:12:00.000Z</published>
    <updated>2018-12-22T14:07:43.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Mybatis</code>的Sql语句传参有两种方式：<code>#{}</code>和<code>${}</code></p><ul><li><code>#{}</code>是预编译处理<ul><li>Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为?号，调用PreparedStatement的set方法来赋值；</li><li>使用<code>#{}</code>可以有效的防止SQL注入，提高系统安全。</li><li>如：<code>order by #{sortName}#</code>，如果传入的值是111,那么解析成sql时的值为<code>order by &quot;111&quot;</code>,</li></ul></li><li><code>${}</code>是字符串替换<ul><li>Mybatis在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值。</li><li>如果是在SQL语句中插入一个不改变的字符串。比如，像<code>ORDER BY</code>，你可以这样来使用：<code>ORDER BY ${columnName}</code></li></ul></li></ul><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><ul><li>现在通过一个例子来分析其两者的区别<blockquote><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 $ 和 #</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectByUsernameAndPasswordTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"src/test/java/resources/mybatis-config.xml"</span>);</span><br><span class="line">    InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">    <span class="comment">// 构建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">// 得到SqlSession</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">// 得到Mapper</span></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(<span class="string">"songsy"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"root"</span>);</span><br><span class="line">    System.out.println(mapper.selectByUsernameAndPassword(user));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>Mapper.xml 配置文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  *</span><br><span class="line">FROM</span><br><span class="line">  sys_user</span><br><span class="line">WHERE</span><br><span class="line">  username = $&#123;username&#125;</span><br><span class="line">AND password = #&#123;password&#125;</span><br></pre></td></tr></table></figure></p></blockquote><ul><li><p>执行<code>mapper</code>方法，打好断点，进入到<code>Executor</code>的query方法，关注<code>BoundSql boundSql = ms.getBoundSql(parameterObject);</code> 这行，<code>BoundSql</code>对象存放了处理完成之后的sql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   BoundSql boundSql = ms.getBoundSql(parameterObject);</span><br><span class="line"><span class="comment">//query时传入一个cachekey参数</span></span><br><span class="line">   CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);</span><br><span class="line">   <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>如下图所示，<code>${username}</code> 已经替换成了 <code>songsy</code> ， #{password} 替换成了 <code>?</code></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/mybatis/boundSql.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><h2 id="栗子剖析"><a href="#栗子剖析" class="headerlink" title="栗子剖析"></a>栗子剖析</h2><ul><li><p>Mybatis是怎样完成上面的替换解析过程呢，进入<code>BoundSql boundSql = ms.getBoundSql(parameterObject);</code> 方法，可以看到其实就是调用<code>sqlSource.getBoundSql</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 其实就是调用sqlSource.getBoundSql</span></span><br><span class="line">   BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">   List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">   <span class="keyword">if</span> (parameterMappings == <span class="keyword">null</span> || parameterMappings.isEmpty()) &#123;</span><br><span class="line">     boundSql = <span class="keyword">new</span> BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// check for nested result maps in parameter mappings (issue #30)</span></span><br><span class="line">   <span class="keyword">for</span> (ParameterMapping pm : boundSql.getParameterMappings()) &#123;</span><br><span class="line">     String rmId = pm.getResultMapId();</span><br><span class="line">     <span class="keyword">if</span> (rmId != <span class="keyword">null</span>) &#123;</span><br><span class="line">       ResultMap rm = configuration.getResultMap(rmId);</span><br><span class="line">       <span class="keyword">if</span> (rm != <span class="keyword">null</span>) &#123;</span><br><span class="line">         hasNestedResultMaps |= rm.hasNestedResultMaps();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> boundSql;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>sqlSource.getBoundSql(parameterObject);</code> ，因为sql不是静态sql所以进入<code>DynamicSqlSource</code> 类的<code>getBoundSql</code>方法，这里传入了我们的<code>user</code>查询对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态SQL源码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicSqlSource</span> <span class="keyword">implements</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> SqlNode rootSqlNode;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicSqlSource</span><span class="params">(Configuration configuration, SqlNode rootSqlNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.rootSqlNode = rootSqlNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到绑定的SQL</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个动态上下文</span></span><br><span class="line">    DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line"><span class="comment">// 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数</span></span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line"><span class="comment">// 调用SqlSourceBuilder</span></span><br><span class="line">    SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line"><span class="comment">// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法</span></span><br><span class="line">    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line"><span class="comment">// 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用</span></span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boundSql;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下面的语句是动态sql的处理，循环执行<code>SqlNode.apply</code>方法，进入 <code>rootSqlNode.apply(context);</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line"><span class="comment">// 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数</span></span><br><span class="line">rootSqlNode.apply(context);</span><br></pre></td></tr></table></figure></li><li><p>进入<code>rootSqlNode.apply(context);</code> 之后来到了<code>MixedSqlNode</code>类，这里依次调用list里每个元素的apply，如下图所示</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/mybatis/MixeSqlNode.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li>执行<code>sqlNode.apply(context);</code>方法这里进入到<code>TextSqlNode</code>的<code>apply</code>方法，这里又调用了<code>GenericTokenParser</code>类的<code>parser.parse(text)</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextSqlNode</span> <span class="keyword">implements</span> <span class="title">SqlNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String text;</span><br><span class="line">  <span class="keyword">private</span> Pattern injectionFilter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextSqlNode</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(text, <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TextSqlNode</span><span class="params">(String text, Pattern injectionFilter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.text = text;</span><br><span class="line">    <span class="keyword">this</span>.injectionFilter = injectionFilter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//判断是否是动态sql</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDynamic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DynamicCheckerTokenParser checker = <span class="keyword">new</span> DynamicCheckerTokenParser();</span><br><span class="line">    GenericTokenParser parser = createParser(checker);</span><br><span class="line">    parser.parse(text);</span><br><span class="line">    <span class="keyword">return</span> checker.isDynamic();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(DynamicContext context)</span> </span>&#123;</span><br><span class="line">    GenericTokenParser parser = createParser(<span class="keyword">new</span> BindingTokenParser(context, injectionFilter));</span><br><span class="line">    context.appendSql(parser.parse(text));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><ul><li><p>进入 <code>GenericTokenParser</code>类的<code>parser.parse(text)</code>方法，可以看到这个类是处理<code>#{}和${}参数</code>的主要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通记号解析器，处理#&#123;&#125;和$&#123;&#125;参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTokenParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有一个开始和结束记号</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String openToken;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String closeToken;</span><br><span class="line">  <span class="comment">// 记号处理器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TokenHandler handler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GenericTokenParser</span><span class="params">(String openToken, String closeToken, TokenHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.openToken = openToken;</span><br><span class="line">    <span class="keyword">this</span>.closeToken = closeToken;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">parse</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">if</span> (text != <span class="keyword">null</span> &amp;&amp; text.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span>[] src = text.toCharArray();</span><br><span class="line">      <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> start = text.indexOf(openToken, offset);</span><br><span class="line">      <span class="comment">// #&#123;favouriteSection,jdbcType=VARCHAR&#125;</span></span><br><span class="line">      <span class="comment">// 这里是循环解析参数，参考GenericTokenParserTest,比如可以解析$&#123;first_name&#125; $&#123;initial&#125; $&#123;last_name&#125; reporting.这样的字符串,里面有3个 $&#123;&#125;</span></span><br><span class="line">      <span class="keyword">while</span> (start &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断一下 $&#123; 前面是否是反斜杠，这个逻辑在老版的mybatis中（如3.1.0）是没有的</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; src[start - <span class="number">1</span>] == <span class="string">'\\'</span>) &#123;</span><br><span class="line">          <span class="comment">// the variable is escaped. remove the backslash.</span></span><br><span class="line">        <span class="comment">// 新版已经没有调用substring了，改为调用如下的offset方式，提高了效率</span></span><br><span class="line">          <span class="comment">// issue #760</span></span><br><span class="line">          builder.append(src, offset, start - offset - <span class="number">1</span>).append(openToken);</span><br><span class="line">          offset = start + openToken.length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> end = text.indexOf(closeToken, start);</span><br><span class="line">          <span class="keyword">if</span> (end == -<span class="number">1</span>) &#123;</span><br><span class="line">            builder.append(src, offset, src.length - offset);</span><br><span class="line">            offset = src.length;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.append(src, offset, start - offset);</span><br><span class="line">            offset = start + openToken.length();</span><br><span class="line">            String content = <span class="keyword">new</span> String(src, offset, end - offset);</span><br><span class="line">            <span class="comment">// 得到一对大括号里的字符串后，调用handler.handleToken,比如替换变量 $&#123;username&#125;这种功能</span></span><br><span class="line">            builder.append(handler.handleToken(content));</span><br><span class="line">            offset = end + closeToken.length();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        start = text.indexOf(openToken, offset);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (offset &lt; src.length) &#123;</span><br><span class="line">        builder.append(src, offset, src.length - offset);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行完<code>builder.append(handler.handleToken(content));</code> 这行代码之后就可以看到<code>${username}</code> 已经替换成<code>songsy</code>了</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/mybatis/parse.jpg" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>到现在已经完成了<code>${username}</code> 的处理，回到 <code>DynamicSqlSource</code> 类中，现在是处理<code>#{password}</code> 这些参数了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicSqlSource</span> <span class="keyword">implements</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">  <span class="keyword">private</span> SqlNode rootSqlNode;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicSqlSource</span><span class="params">(Configuration configuration, SqlNode rootSqlNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.configuration = configuration;</span><br><span class="line">    <span class="keyword">this</span>.rootSqlNode = rootSqlNode;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到绑定的SQL</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成一个动态上下文</span></span><br><span class="line">    DynamicContext context = <span class="keyword">new</span> DynamicContext(configuration, parameterObject);</span><br><span class="line"><span class="comment">// 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数</span></span><br><span class="line">    rootSqlNode.apply(context);</span><br><span class="line"><span class="comment">// 调用SqlSourceBuilder</span></span><br><span class="line">    SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">    Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line"><span class="comment">// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#&#123;password&#125;都替换成?了，也就是最基本的JDBC的SQL写法</span></span><br><span class="line">    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br><span class="line"><span class="comment">// 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用</span></span><br><span class="line">    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123;</span><br><span class="line">      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boundSql;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下图是处理完动态sql节点及<code>${username}</code>之后的结果</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/mybatis/getBoundSql.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>处理完<code>${username}</code> 节点之后现在就是处理<code>#{password}</code> 节点了，解析完了就把那些参数#{password}都替换成?了，也就是最基本的JDBC的SQL写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用SqlSourceBuilder</span></span><br><span class="line">   SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">   Class&lt;?&gt; parameterType = parameterObject == <span class="keyword">null</span> ? Object.class : parameterObject.getClass();</span><br><span class="line"><span class="comment">// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#&#123;password&#125;都替换成?了，也就是最基本的JDBC的SQL写法</span></span><br><span class="line">   SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</span><br></pre></td></tr></table></figure></li><li><p>进入<code>sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());</code>方法，之后又是进入 <code>GenericTokenParser</code>类的<code>parser.parse(text)</code>方法，只不过<code>handleToken</code>方法执行的是下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">handleToken</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 先构建参数映射</span></span><br><span class="line">   parameterMappings.add(buildParameterMapping(content));</span><br><span class="line">   <span class="comment">// 如何替换很简单，永远是一个问号，但是参数的信息要记录在parameterMappings里面供后续使用</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">"?"</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>最后拼接成的结果如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  sys_user</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  username = songsy</span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">password</span> = ?</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>#{}</code>在一定程度上可以防止SQL的注入</li><li><code>${}</code>一般用在动态表名，动态字段，设置排序字段上</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/a9cb929b533e" target="_blank" rel="noopener">https://www.jianshu.com/p/a9cb929b533e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Mybatis&lt;/code&gt;的Sql语句传参有两种方式：&lt;code&gt;#{}&lt;/code&gt;和&lt;code&gt;${}&lt;/code&gt;&lt;/p
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="mybatis" scheme="http://www.songshuiyang.site/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis源码(二十一)拦截器Interceptor原理探究</title>
    <link href="http://www.songshuiyang.site/2018/12/21/backend/mybatis/sourceCodeAnalysis/Mybatis%E6%BA%90%E7%A0%81(%E4%BA%8C%E5%8D%81%E4%B8%80)%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://www.songshuiyang.site/2018/12/21/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究/</id>
    <published>2018-12-21T12:56:00.000Z</published>
    <updated>2018-12-22T14:02:27.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用，拦截后用户可以完成一些额外的定制操作，比如实现分页，这一章节来介绍拦截器的一些基本知识及实现原理，下一章节将介绍如何用拦截器实现查询分页功能</p></li><li><p>默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拦截执行器的方法</span></span><br><span class="line">Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</span><br><span class="line"><span class="comment">// 拦截参数的处理</span></span><br><span class="line">ParameterHandler (getParameterObject, setParameters)</span><br><span class="line"><span class="comment">// 拦截结果集的处理</span></span><br><span class="line">ResultSetHandler (handleResultSets, handleOutputParameters)</span><br><span class="line"><span class="comment">// 拦截Sql语法构建的处理</span></span><br><span class="line">StatementHandler (prepare, parameterize, batch, update, query)</span><br></pre></td></tr></table></figure></li></ul><h2 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h2><ul><li><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">  type= Executor.class,</span><br><span class="line">  method = <span class="string">"update"</span>,</span><br><span class="line">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上面的插件将会拦截在 <code>Executor</code> 实例中所有的名为<code>update</code> 且参数为<code>(MappedStatement.class,Object.class)</code>的方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。</p><h2 id="拦截器原理探究"><a href="#拦截器原理探究" class="headerlink" title="拦截器原理探究"></a>拦截器原理探究</h2></li></ul><h3 id="拦截器定义"><a href="#拦截器定义" class="headerlink" title="拦截器定义"></a>拦截器定义</h3><ul><li><p>首先我们看下MyBatis拦截器的接口定义 <code>Interceptor.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里完成拦截操作</span></span><br><span class="line">  <span class="function">Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于封装目标对象，我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象</span></span><br><span class="line">  <span class="function">Object <span class="title">plugin</span><span class="params">(Object target)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于在Mybatis配置文件中指定一些属性的。</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Signature</code>注解用于定义拦截方法，规则为：<code>type</code>这个类下方法名为<code>method</code>且参数为<code>args</code>的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 就是定义哪些类，方法，参数需要被拦截</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Signature &#123;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; type();</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt;[] args();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当定义拦截器类之后就是要让<code>Mybatis</code>知道有哪些拦截器了，那<code>Mybatis</code>是怎么知道有哪些拦截器呢，通过以上章节可以知道Spring集成Mybatis有两种方法，一种是通过xml配置的方式，另一种是通过注解的方式，下面来介绍这两种方式是怎样获取定义好的拦截器的</p><ul><li><p>通过xml配置的方式</p><ul><li><p>先是在 <code>mybatis-config.xml</code> 定义好哪些拦截器</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someProperty"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义好之后那么Mybatis就会解析<code>pluginElement</code> 然后将会添加到<code>Configuration</code> 对象的<code>InterceptorChain</code>对象中，这样拦截器就解析完成了</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      String interceptor = child.getStringAttribute(<span class="string">"interceptor"</span>);</span><br><span class="line">      Properties properties = child.getChildrenAsProperties();</span><br><span class="line">      Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">      interceptorInstance.setProperties(properties);</span><br><span class="line">      <span class="comment">//调用InterceptorChain.addInterceptor</span></span><br><span class="line">      configuration.addInterceptor(interceptorInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>看看<code>InterceptorChain</code>类，内部就是一个拦截器的List，可以定义多个拦截器</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器链</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部就是一个拦截器的List，可以定义多个拦截器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;Interceptor&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环调用每个Interceptor.plugin方法</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    interceptors.add(interceptor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Interceptor&gt; <span class="title">getInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableList(interceptors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过注解的方式</p><ul><li><p>通过注解的方式获取拦截器需要准备环境，查看第十九章</p></li><li><p>在拦截器那个类添加<code>@Component</code> 让拦截器类注册成<code>Spring bean</code>，这样此拦截器将会自动装配到<code>Mybatis</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">  type= Executor.class,</span><br><span class="line">  method = <span class="string">"update"</span>,</span><br><span class="line">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么是怎么实现拦截器的自动装配到<code>Mybatis</code>中，可以查看<code>org.mybatis.spring.boot.autoconfigure</code> 包下的<code>MybatisAutoConfiguration</code> 类，查看其构造方法，关注<code>this.interceptors = interceptorsProvider.getIfAvailable();</code> 方法，这里实现了查找实现了<code>Interceptor</code>接口的的类，这个方法是Spring的方法，所以之前需要将拦截器类注册成Bean，这样Spring才能找到对应的拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MybatisAutoConfiguration</span><span class="params">(MybatisProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ResourceLoader resourceLoader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.properties = properties;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = interceptorsProvider.getIfAvailable();</span><br><span class="line">  <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">  <span class="keyword">this</span>.databaseIdProvider = databaseIdProvider.getIfAvailable();</span><br><span class="line">  <span class="keyword">this</span>.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在来看<code>SqlSessionFactory</code>注册为Bean的过程，得到<code>interceptors</code>之后就需要将其添加到万能类<code>Configuration</code>中， 查看<code>SqlSessionFactoryBean</code>的<code>buildSqlSessionFactory</code> 方法，下面的代码就是此操作的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.plugins)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (Interceptor plugin : <span class="keyword">this</span>.plugins) &#123;</span><br><span class="line">     configuration.addInterceptor(plugin);</span><br><span class="line">     <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">       LOGGER.debug(<span class="string">"Registered plugin: '"</span> + plugin + <span class="string">"'"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="拦截器是如何拦截的"><a href="#拦截器是如何拦截的" class="headerlink" title="拦截器是如何拦截的"></a>拦截器是如何拦截的</h3><ul><li>以下4个方法都是<code>Configuration</code>的方法。这些方法在<code>MyBatis</code>的新增，删除，修改，查询这些操作中都会被执行到，执行的先后顺序是<code>Executor，ParameterHandler，ResultSetHandler，StatementHandler</code>(其中ParameterHandler和ResultSetHandler的创建是在创建StatementHandler（3个可用的实现类CallableStatementHandler,PreparedStatementHandler,SimpleStatementHandler）的时候，其构造函数调用的（这3个实现类的构造函数其实都调用了父类BaseStatementHandler的构造函数）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);</span><br><span class="line">    <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">  ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">    <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">    StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);</span><br><span class="line">    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);</span><br><span class="line">    <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这4个方法实例化了对应的对象之后，都会调用interceptorChain的pluginAll方法，InterceptorChain的pluginAll刚才已经介绍过了，就是遍历所有的拦截器，然后调用各个拦截器的plugin方法。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环调用每个Interceptor.plugin方法</span></span><br><span class="line">    <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">      target = interceptor.plugin(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>回到之前的拦截器类，这里查看<code>plugin</code>方法<code>Plugin.wrap(target, this);</code>，这里执行了<code>Plugin</code>类的<code>wrap(target, this)</code> 方法，返回了一个新的对象。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">  type= Executor.class,</span><br><span class="line">  method = <span class="string">"update"</span>,</span><br><span class="line">  args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>Plugin</code>类，可以看到这里用了动态代理模式来实现拦截器的拦截操作<code>Plugin.wrap(target, this);</code>返回的是一个动态代理对象，当其动态代理对象执行方法的时候就会执行本<code>Plugin</code>类的<code>invoke</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插件,用的代理模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> Interceptor interceptor;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">    <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取得签名Map</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    <span class="comment">// 取得要改变行为的类(ParameterHandler|ResultSetHandler|StatementHandler|Executor)</span></span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 取得接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="comment">// 产生代理</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 看看如何拦截</span></span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">      <span class="comment">// 看哪些方法需要拦截</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="comment">// 调用Interceptor.intercept，也即插入了我们自己的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 最后还是执行原来逻辑</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得签名Map</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">    <span class="comment">// 取Intercepts注解，例子可参见ExamplePlugin.java</span></span><br><span class="line">    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);</span><br><span class="line">    <span class="comment">// issue #251</span></span><br><span class="line">    <span class="comment">// 必须得有Intercepts注解，没有报错</span></span><br><span class="line">    <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"No @Intercepts annotation was found in interceptor "</span> + interceptor.getClass().getName());      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// value是数组型，Signature的数组</span></span><br><span class="line">    Signature[] sigs = interceptsAnnotation.value();</span><br><span class="line">    <span class="comment">// 每个class里有多个Method需要被拦截,所以这么定义</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">      <span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">        methods = <span class="keyword">new</span> HashSet&lt;Method&gt;();</span><br><span class="line">        signatureMap.put(sig.type(), methods);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Method method = sig.type().getMethod(sig.method(), sig.args());</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">"Could not find method on "</span> + sig.type() + <span class="string">" named "</span> + sig.method() + <span class="string">". Cause: "</span> + e, e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signatureMap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得接口</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">        <span class="comment">//貌似只能拦截ParameterHandler|ResultSetHandler|StatementHandler|Executor</span></span><br><span class="line">        <span class="comment">//拦截其他的无效</span></span><br><span class="line">        <span class="comment">//当然我们可以覆盖Plugin.wrap方法，达到拦截其他类的功能</span></span><br><span class="line">        <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">          interfaces.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      type = type.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>invoke方法</code>,从而调用了我们之前定义的<code>interceptor.intercept();</code>的方法，这里是实现拦截的核心，<code>interceptor.intercept(new Invocation(target, method, args));</code> 这里插入了我们自己的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 看看如何拦截</span></span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="comment">// 看哪些方法需要拦截</span></span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">      <span class="comment">// 调用Interceptor.intercept，也即插入了我们自己的逻辑</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后还是执行原来逻辑</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>回到之前的节点，在构建<code>Executor</code>的时候，<code>executor = (Executor) interceptorChain.pluginAll(executor);</code>这里返回的是 <code>Plugin.wrap(target, this);</code>一个动态代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor, autoCommit);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所以当<code>SqlSession</code>执行<code>Executor</code>的方法时候，这里<code>Executor</code>是个动态代理之后的<code>Executor</code>，当执行<code>Executor</code>的方法的时候就会执行动态代理的invoke方法，在invoke方法执行我们额外的代码</p></li><li><p>在此拦截器的任务才真正完成</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官网：<a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins</a></p><p><a href="https://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用，拦截后用户可以完成一些额外的定制操作，比如实现分页，这一
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="mybatis" scheme="http://www.songshuiyang.site/tags/mybatis/"/>
    
  </entry>
  
</feed>
