<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋水阳个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.songshuiyang.site/"/>
  <updated>2019-03-26T12:32:55.245Z</updated>
  <id>http://www.songshuiyang.site/</id>
  
  <author>
    <name>songshuiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM虚拟机性能监控与故障处理工具</title>
    <link href="http://www.songshuiyang.site/2019/03/26/backend/Java/JVM/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.songshuiyang.site/2019/03/26/backend/Java/JVM/JVM虚拟机性能监控与故障处理工具/</id>
    <published>2019-03-26T13:59:44.000Z</published>
    <updated>2019-03-26T12:32:55.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><h3 id="jcmd-综合工具"><a href="#jcmd-综合工具" class="headerlink" title="jcmd 综合工具"></a>jcmd 综合工具</h3><ul><li><p><code>jcmd -l</code>  列出当前运行的所有虚拟机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5362</span> sun.tools.jcmd.JCmd -l</span><br><span class="line"><span class="number">1236</span> /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=<span class="number">9080</span> --debug=<span class="number">5</span> --handlerCountMax=<span class="number">100</span> --handlerCountMaxIdle=<span class="number">20</span></span><br><span class="line"><span class="number">7167</span> org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure></li><li><p><code>jcmd [pid] VM.uptime</code>   查看虚拟机启动时间VM.uptime</p></li><li><code>jcmd [pid] Thread.print</code>  打印线程栈信息Thread.print</li><li><code>jcmd [pid] GC.class_histogram</code>  查看系统中类统计信息GC.class_histogram</li><li><code>jcmd [pid] GC.heap_dump [filepath&amp;name]</code>  导出堆信息GC.heap_dump  这个命令功能和 jmap -dump 功能一样</li><li><code>jcmd [pid] VM.system_properties</code> 获取系统Properties内容VM.system_properties</li><li><code>jcmd [pid] VM.flags</code> 获取启动参数VM.flags</li><li><code>jcmd [pid] PerfCounter.print</code>  获取所有性能相关数据PerfCounter.print<h3 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps 虚拟机进程状况工具"></a>jps 虚拟机进程状况工具</h3></li><li>jps（JVM Process Status Tool）可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。虽然功能比较单一，但它是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier,PID）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。</li><li><p>命令格式，其中[option]、[hostid]参数也可以不写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-l : 输出主类全名或jar路径</span><br><span class="line">    •-q : 只输出LVMID</span><br><span class="line">    •-m : 输出JVM启动时传递给main()的参数</span><br><span class="line">    •-v : 输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line"></span><br><span class="line">15232 org.gradle.launcher.daemon.bootstrap.GradleDaemon</span><br><span class="line">3104 sun.tools.jps.Jps</span><br><span class="line">6784 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">8916 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">15976</span><br><span class="line">8936 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">11580 com.songsy.iframe.Application</span><br></pre></td></tr></table></figure></li></ul><h3 id="jinfo-配置信息工具"><a href="#jinfo-配置信息工具" class="headerlink" title="jinfo 配置信息工具"></a>jinfo 配置信息工具</h3><ul><li><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p></li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] [args] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-flag : 输出指定args参数的值</span><br><span class="line">    •-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">    •-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags <span class="number">11580</span></span><br><span class="line"></span><br><span class="line">Attaching to process ID <span class="number">11580</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.121</span>-b13</span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=<span class="number">3</span> -XX:InitialHeapSize=<span class="number">134217728</span> -XX:+ManagementServer -XX:MaxHeapSize=<span class="number">2118123520</span> -XX:MaxNewSize=<span class="number">705691648</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">44564480</span> -XX:OldSize=<span class="number">89653248</span> -XX:TieredStopAtLevel=<span class="number">1</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">Command line:  -agentlib:jdwp=transport=dt_socket,address=<span class="number">127.0</span>.0.1:<span class="number">58771</span>,suspend=y,server=n -XX:TieredStopAtLevel=<span class="number">1</span> -Xverify:none -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=<span class="number">58770</span> -Dcom.sun.management.jmxremote.authenticate=<span class="keyword">false</span> -Dcom.sun.management.jmxremote.ssl=<span class="keyword">false</span> -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=<span class="keyword">true</span> -javaagent:C:\Users\asua\.IntelliJIdea2017.2\system\groovyHotSwap\gragent.jar -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><ul><li>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li><p>命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">    •[option] : 操作参数</span><br><span class="line">    •LVMID : 本地虚拟机进程ID</span><br><span class="line">    •[interval] : 连续输出的时间间隔</span><br><span class="line">    •[count] : 连续输出的次数</span><br><span class="line">    </span><br><span class="line">对于命令格式中的VMID与LVMID需要特别说明一下：</span><br><span class="line">如果是本地虚拟机进程，VMID与LVMID是一致的;</span><br><span class="line">如果是远程虚拟机进程，那VMID的格式应当是：protocol://lvmid@hostname:port/servername</span><br><span class="line">参数interval和count代表查询间隔(单位毫秒)和次数，如果省略这两个参数，说明只查询一次。</span><br><span class="line">假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure></li><li><p>选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考表4-3中的描述。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/jstat.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>option</code>参数详解<blockquote><p><code>jstat -class</code>监视类装载、卸载数量、总空间以及耗费的时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -class 11580</span><br><span class="line"></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line">  7107 13135.3        0     0.0       6.84</span><br><span class="line"></span><br><span class="line">•Loaded : 加载class的数量</span><br><span class="line">•Bytes : class字节大小</span><br><span class="line">•Unloaded : 未加载class的数量</span><br><span class="line">•Bytes : 未加载class的字节大小</span><br><span class="line">•Time : 加载时间</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p><code>jstat -compiler</code>输出JIT编译过的方法数量耗时等<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -compiler  11580</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    4079      3       0     1.62          1 org/springframework/beans/CachedIntrospectionResults &lt;init&gt;</span><br><span class="line"></span><br><span class="line">•Compiled : 编译数量</span><br><span class="line">•Failed : 编译失败数量</span><br><span class="line">•Invalid : 无效数量</span><br><span class="line">•Time : 编译耗时</span><br><span class="line">•FailedType : 失败类型</span><br><span class="line">•FailedMethod : 失败方法的全限定名</span><br></pre></td></tr></table></figure></p><p><code>jstat -gc</code> 垃圾回收堆的行为统计<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc  11580</span><br><span class="line"> S0C    S1C      S0U    S1U      EC       EU        OC         OU       MC      MU      CCSC    CCSU    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">39424.0 29696.0  0.0    0.0      414208.0 353447.8  118272.0   46473.8  35072.0 34285.7 4608.0  4457.1  9       0.233   2      0.149    0.382</span><br><span class="line"></span><br><span class="line">•S0C : survivor0区的总容量</span><br><span class="line">•S1C : survivor1区的总容量</span><br><span class="line">•S0U : survivor0区已使用的容量</span><br><span class="line">•S1C : survivor1区已使用的容量</span><br><span class="line">•EC : Eden区的总容量</span><br><span class="line">•EU : Eden区已使用的容量</span><br><span class="line">•OC : Old区的总容量</span><br><span class="line">•OU : Old区已使用的容量</span><br><span class="line">•PC 当前perm的容量 (KB)</span><br><span class="line">•PU perm的使用 (KB)</span><br><span class="line">•YGC : 新生代垃圾回收次数</span><br><span class="line">•YGCT : 新生代垃圾回收时间</span><br><span class="line">•FGC : 老年代垃圾回收次数</span><br><span class="line">•FGCT : 老年代垃圾回收时间</span><br><span class="line">•GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure></p><p><code>jstat -gccapacity</code>同-gc，不过还会输出Java堆各区域使用到的最大、最小空间<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccapacity  11580</span><br><span class="line"> NGCMN    NGCMX     NGC      S0C     S1C       EC          OGCMN      OGCMX       OGC        OC            MCMN      MCMX         MC          CCSMN   CCSMX       CCSC    YGC    FGC</span><br><span class="line"> 43520.0  689152.0  689152.0 39424.0 29696.0   414208.0    87552.0    1379328.0   118272.0   118272.0      0.0       1079296.0    35072.0      0.0    1048576.0   4608.0  9      2</span><br><span class="line"> </span><br><span class="line">•NGCMN : 新生代占用的最小空间</span><br><span class="line">•NGCMX : 新生代占用的最大空间</span><br><span class="line">•OGCMN : 老年代占用的最小空间</span><br><span class="line">•OGCMX : 老年代占用的最大空间</span><br><span class="line">•OGC：当前年老代的容量 (KB)</span><br><span class="line">•OC：当前年老代的空间 (KB)</span><br><span class="line">•PGCMN : perm占用的最小空间</span><br><span class="line">•PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure></p><p><code>jstat -gcutil</code> 同-gc，不过输出的是已使用空间占总空间的百分比<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0     S1     E      O      M      CCS       YGC     YGCT      FGC    FGCT     GCT</span><br><span class="line">0.00   0.00  85.33   39.29  97.76  96.73      9      0.233     2      0.149    0.382</span><br></pre></td></tr></table></figure></p><p><code>jstat -gccause</code> 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccause  11580</span><br><span class="line">  S0     S1    E      O      M      CCS    YGC  YGCT     FGC  FGCT     GCT    LGCC                 GCC</span><br><span class="line">  0.00   0.00  85.33  39.29  97.76  96.73  9    0.233    2    0.149    0.382  Allocation Failure   No GC</span><br><span class="line"></span><br><span class="line">•LGCC：最近垃圾回收的原因</span><br><span class="line">•GCC：当前垃圾回收的原因</span><br></pre></td></tr></table></figure></p><p><code>jstat -gcnew</code> 统计新生代的行为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnew  11580</span><br><span class="line"> S0C    S1C      S0U    S1U  TT  MTT  DSS      EC       EU            YGC     YGCT</span><br><span class="line">39424.0 29696.0  0.0    0.0  2   15   39424.0  414208.0 353447.8      9       0.233</span><br></pre></td></tr></table></figure></p><p><code>jstat -gcnewcapacity</code> 新生代与其相应的内存空间的统计<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnewcapacity  11580</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   43520.0   689152.0   689152.0 229376.0  39424.0 229376.0  29696.0   688128.0   414208.0     9     2</span><br><span class="line"></span><br><span class="line">•NGC:当前年轻代的容量 (KB)</span><br><span class="line">•S0CMX:最大的S0空间 (KB)</span><br><span class="line">•S0C:当前S0空间 (KB)</span><br><span class="line">•ECMX:最大eden空间 (KB)</span><br><span class="line">•EC:当前eden空间 (KB)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><ul><li>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。</li><li>如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如加-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。</li><li>jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。</li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •dump : 生成堆转储快照，格式为:-dump:[live, ] format=b,file=&lt;filename&gt;,其中live子参数说明是否只dump出存活的对象。</span><br><span class="line">    •finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">    •heap : 显示Java堆详细信息</span><br><span class="line">    •histo : 显示堆中对象的统计信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</span><br><span class="line">    •permstat : to print permanent generation statistics</span><br><span class="line">    •F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 28920</span><br><span class="line"></span><br><span class="line">Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01  </span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC with 4 thread(s)                //GC 方式  </span><br><span class="line">  Heap Configuration:                         //堆内存初始化配置</span><br><span class="line">     MinHeapFreeRatio = 0                     //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">     MaxHeapFreeRatio = 100                   //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">     NewSize          = 1310720 (1.25MB)      //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">     MaxNewSize       = 17592186044415 MB     //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">     OldSize          = 5439488 (5.1875MB)    //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">     NewRatio         = 2                     //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">     SurvivorRatio    = 8                     //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">     PermSize         = 21757952 (20.75MB)    //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">     MaxPermSize      = 85983232 (82.0MB)     //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">     G1HeapRegionSize = 0 (0.0MB)  </span><br><span class="line">  Heap Usage:                                 //堆内存使用情况</span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space:                                 //Eden区内存分布</span><br><span class="line">     capacity = 33030144 (31.5MB)             //Eden区总容量</span><br><span class="line">     used     = 1524040 (1.4534378051757812MB)//Eden区已使用</span><br><span class="line">     free     = 31506104 (30.04656219482422MB)//Eden区剩余容量</span><br><span class="line">     4.614088270399305% used                  //Eden区使用比率</span><br><span class="line">  From Space:                                 //其中一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  To Space:                                   //另一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Old Generation                           //当前的Old区内存分布</span><br><span class="line">     capacity = 86507520 (82.5MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 86507520 (82.5MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Perm Generation                          //当前的 “永生代” 内存分布</span><br><span class="line">     capacity = 22020096 (21.0MB)</span><br><span class="line">     used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">     free     = 19523568 (18.619125366210938MB)</span><br><span class="line">     11.337498256138392% used  </span><br><span class="line">interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>jmap -histo:live 28920 | more 打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">num     #instances         #bytes  class name</span><br><span class="line"><span class="comment">----------------------------------------------</span></span><br><span class="line">   1:         83613       12012248  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         23868       11450280  [B</span><br><span class="line">   3:         83613       10716064  &lt;methodKlass&gt;</span><br><span class="line">   4:         76287       10412128  [C</span><br><span class="line">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         73627        1767048  java.lang.String</span><br><span class="line">   9:          2260        1348848  &lt;methodDataKlass&gt;</span><br><span class="line">  10:          8856         849296  java.lang.Class</span><br><span class="line">  </span><br><span class="line">class name是对象类型，说明如下：</span><br><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><ul><li><p>jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。</p></li><li><p>不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器。二是用于分析的机器一般也是服务器，由于加载dump快照文件需要比生成dump更大的内存，所以一般在64位JDK、大内存的服务器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。</p></li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    jhat [option] [dumpfile]</span><br><span class="line">参数</span><br><span class="line">    •-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line">    •-refs <span class="literal">false</span>|<span class="literal">true</span> 关闭对象引用跟踪(<span class="keyword">tracking</span> <span class="keyword">of</span> <span class="keyword">references</span> <span class="keyword">to</span> objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers <span class="keyword">or</span> incoming <span class="keyword">references</span>), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line">    •-port port-<span class="built_in">number</span> 设置 jhat <span class="keyword">HTTP</span> <span class="keyword">server</span> 的端口号. 默认值 <span class="number">7000.</span>&gt; </span><br><span class="line">    •-<span class="keyword">exclude</span> <span class="keyword">exclude</span>-<span class="keyword">file</span> 指定对象查询时需要排除的数据成员列表文件(a <span class="keyword">file</span> that lists <span class="keyword">data</span> members that should be excluded <span class="keyword">from</span> the reachable objects <span class="keyword">query</span>)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 <span class="keyword">Object</span> o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line">    •-baseline <span class="keyword">exclude</span>-<span class="keyword">file</span> 指定一个基准堆转储(baseline <span class="keyword">heap</span> dump)。 在两个 <span class="keyword">heap</span> dumps 中有相同 <span class="keyword">object</span> <span class="keyword">ID</span> 的对象会被标记为不是新的(marked <span class="keyword">as</span> <span class="keyword">not</span> being <span class="keyword">new</span>). 其他对象被标记为新的(<span class="keyword">new</span>). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line">    •-debug <span class="built_in">int</span> 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line">    •-<span class="keyword">version</span> 启动后只显示版本信息就退出&gt;</span><br><span class="line">    •-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的<span class="keyword">Java</span>虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ~ jhat eclipse.bin </span><br><span class="line">Reading from eclipse.bin...</span><br><span class="line">Dump file created Mon Oct 31 19:32:57 CST 2016</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 185857 objects...</span><br><span class="line">Chasing references, expect 37 dots.....................................</span><br><span class="line">Eliminating duplicate references.....................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br><span class="line"></span><br><span class="line">屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost:7000/就可以看到分析结果.</span><br><span class="line">分析结果默认是以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的“Heap Histogram”（与jmap -histo功能一样）与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计.</span><br></pre></td></tr></table></figure></li></ul><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><ul><li>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</li><li>命令格式<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">    •-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">    •-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure></li></ul><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/wade-luffy/p/6017137.html" target="_blank" rel="noopener">https://www.cnblogs.com/wade-luffy/p/6017137.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK的命令行工具&quot;&gt;&lt;a href=&quot;#JDK的命令行工具&quot; class=&quot;headerlink&quot; title=&quot;JDK的命令行工具&quot;&gt;&lt;/a&gt;JDK的命令行工具&lt;/h2&gt;&lt;h3 id=&quot;jcmd-综合工具&quot;&gt;&lt;a href=&quot;#jcmd-综合工具&quot; class
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型与线程(一)Java内存模型</title>
    <link href="http://www.songshuiyang.site/2019/03/21/backend/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B(%E4%B8%80)Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.songshuiyang.site/2019/03/21/backend/Java/JVM/JVM内存模型与线程(一)Java内存模型/</id>
    <published>2019-03-21T13:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>在说Java内存模型之前，我们先说一下Java的内存结构，也就是运行时的数据区域，这一块前面的章节已经介绍过了，很多人容易把内存结构跟内存模型搞混，内存结构就是下图中内存空间这些东西，而Java内存模型，完全是另外的一个东西。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/neicun.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景下就不许针对不同的平台来编写程序。</li></ul><h3 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1. 主内存与工作内存"></a>1. 主内存与工作内存</h3><ul><li><p>Java内存模型的主要目的是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。注意一下，此处的变量并不包括局部变量与方法参数，因为它们是线程私有的，不会被共享，自然也不会存在竞争，此处的变量应该是实例字段、静态字段和构成数组对象的元素。</p></li><li><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量和主内存副本拷贝（注意这里绝不会是整个对象的拷贝，试想一个10M的对象，在每个用到这个对象的工作内存中有一个10M的拷贝，内存还受得了？也就是一些在线程中用到的对象中的字段罢了），线程对变量所有的操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p></li></ul><h3 id="2-内存间交互操作"><a href="#2-内存间交互操作" class="headerlink" title="2. 内存间交互操作"></a>2. 内存间交互操作</h3><ul><li>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面体积的每一种操作都是原子的、不可再分的<ul><li>1、lock（锁定）：作用于主内存中的变量，它把一个变量标识为一条线程独占的状态</li><li>2、unlock（解锁）：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>3、read（读取）：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>5、use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，没当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作</li><li>6、assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li>7、store（存储）：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用</li><li>8、write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中</li></ul></li><li>Java内存模型还规定了在执行上述8种基本操作时必须满足以下规则：<ul><li>1、不允许read和load、store和write操作之一单独出现</li><li>2、不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了滞后必须把该变化同步回主内存</li><li>3、不允许一个线程无原因地把数据从线程的工作内存同步回主内存中</li><li>4、一个新的变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量</li><li>5、一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li><li>6、如果对同一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值</li><li>7、如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li><li>8、对一个变量执行unlock操作之前，必须先把此变量同步回主内存中</li></ul></li></ul><h3 id="3-对于volatile型变量的特殊规则"><a href="#3-对于volatile型变量的特殊规则" class="headerlink" title="3. 对于volatile型变量的特殊规则"></a>3. 对于volatile型变量的特殊规则</h3><ul><li><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。</p></li><li><p>一个变量被定义为volatile后，它将具备两种特性：</p><ul><li><p>1、保证此变量对所有线程的”可见性”，所谓”可见性”是指当一条线程修改了这个变量的值，新值对于其它线程来说都是可以立即得知的，而普通变量不能做到这一点，普通变量的值在在线程间传递均需要通过主内存来完成，关于volatile关键字的操作请参见volatile关键字使用举例，再强调一遍，volatile只保证了可见性，并不保证基于volatile变量的运算在并罚下是安全的</p></li><li><p>2、使用volatile变量的第二个语义是禁止指令重排序优化，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p></li></ul></li><li>总结一下Java内存模型对volatile变量定义的特殊规则：<ul><li>1、在工作内存中，每次使用某个变量的时候都必须线从主内存刷新最新的值，用于保证能看见其他线程对该变量所做的修改之后的值</li><li>2、在工作内存中，每次修改完某个变量后都必须立刻同步回主内存中，用于保证其他线程能够看见自己对该变量所做的修改</li><li>3、volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同 </li></ul></li></ul><h3 id="4-原子性、可见性与有序性"><a href="#4-原子性、可见性与有序性" class="headerlink" title="4. 原子性、可见性与有序性"></a>4. 原子性、可见性与有序性</h3><ul><li>1、原子性（Atomicity）</li></ul><p>由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store、write，大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大的原子性保证，Java内存模型还提供了lock和unlock，尽管虚拟机没有把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—-synchronized关键字</p><ul><li>2、可见性（Visibility）</li></ul><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile其实已经详细写了这一点，其实synchronized关键字也是可以实现可见性的，synchronized的可见性是由”对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。</p><ul><li>3、有序性（Ordering）</li></ul><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无须的。前半句是指”线程内表现为穿行的语义”，后半句是指”指令重排序”和”工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入</p><h3 id="5-先行发生原则"><a href="#5-先行发生原则" class="headerlink" title="5. 先行发生原则"></a>5. 先行发生原则</h3><ul><li><p>如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将变得很繁琐，但是我们在编写Java代码时并未感觉到这一点，这是因为Java语言中有一个”先行发生（happens-before）”原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则就判断出并发环境下两个操作之间是否可能存在冲突的问题。</p></li><li><p>所谓先行发生原则是指Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，那么操作A产生的影响能够被操作b观察到，”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。Java内存模型下有一些天然的，不需要任何同步协助器就已经存在的先行发生关系：</p><ul><li>1、程序次序规则：在一个线程内，按照控制流顺序，控制流前面的操作先行发生于控制流后面的操作，说”控制流”是因为还要考虑到分支、循环结构</li><li>2、管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li><li>3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li><li>4、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</li><li>5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测</li><li>6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>7、对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li><li>8、传递新：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A必然先行发生于操作C</li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="noopener">https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</a></li><li><a href="https://baijiahao.baidu.com/s?id=1595082600371869908&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1595082600371869908&amp;wfr=spider&amp;for=pc</a></li><li><a href="http://www.importnew.com/28456.html" target="_blank" rel="noopener">http://www.importnew.com/28456.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在说Java内存模型之前，我们先说一下Java的内存结构，也就是运行时的数据区域，这一块前面的章节已经介绍过了，很多人容易把内存
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行(二)基于栈的字节码解释器执行过程</title>
    <link href="http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C(%E4%BA%8C)%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM字节码执行(二)基于栈的字节码解释器执行过程/</id>
    <published>2019-03-19T14:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>根据一个代码实例来介绍虚拟机中解释器的执行过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;  </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;  </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;  </span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由上面的代码可以看出，该方法的逻辑很简单，就是进行简单的四则运算加减乘除，我们编译代码后使用javap -verbose命令查看字节码指令，具体字节码代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span></span>;  </span><br><span class="line">  Code:  </span><br><span class="line">   Stack=<span class="number">2</span>, Locals=<span class="number">4</span>, Args_size=<span class="number">1</span>  </span><br><span class="line">   <span class="number">0</span>:   bipush  <span class="number">100</span>  </span><br><span class="line">   <span class="number">2</span>:   istore_1  </span><br><span class="line">   <span class="number">3</span>:   sipush  <span class="number">200</span>  </span><br><span class="line">   <span class="number">6</span>:   istore_2  </span><br><span class="line">   <span class="number">7</span>:   sipush  <span class="number">300</span>  </span><br><span class="line">   <span class="number">10</span>:  istore_3  </span><br><span class="line">   <span class="number">11</span>:  iload_1  </span><br><span class="line">   <span class="number">12</span>:  iload_2  </span><br><span class="line">   <span class="number">13</span>:  iadd  </span><br><span class="line">   <span class="number">14</span>:  iload_3  </span><br><span class="line">   <span class="number">15</span>:  imul  </span><br><span class="line">   <span class="number">16</span>:  ireturn  </span><br><span class="line">  LineNumberTable:  </span><br><span class="line">   line <span class="number">3</span>: <span class="number">0</span>  </span><br><span class="line">   line <span class="number">4</span>: <span class="number">3</span>  </span><br><span class="line">   line <span class="number">5</span>: <span class="number">7</span>  </span><br><span class="line">   line <span class="number">6</span>: <span class="number">11</span>  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据字节码可以看出，这段代码需要深度为2的操作数栈（Stack=2）和4个Slot的局部变量空间（Locals=4）。下面，使用7张图片来描述上面的字节码代码执行过程中的代码、操作数栈和局部变量表的变化情况。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图展示了执行偏移地址为0的指令的情况，bipush指令的作用是将单字节的整型常量值（-128~127）推入操作数栈顶，后跟一个参数，指明推送的常量值，这里是100。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图则是执行偏移地址为2的指令，istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量Slot中。后面四条指令（3、6、7、10）都是做同样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。后面四条指令的图就不重复画了。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上面展示了执行偏移地址为11的指令，iload_1指令的作用是将局部变量第1个Slot中的整型值复制到操作数栈顶。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图为执行偏移地址12的指令，iload_2指令的执行过程与iload_1类似，把第2个Slot的整型值入栈。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图展示了执行偏移地址为13的指令情况，iadd指令的作用是将操作数栈中前两个栈顶元素出栈，做整型加法，然后把结果重新入栈。在iadd指令执行完毕后，栈中原有的100和200出栈，它们相加后的和300重新入栈。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>上图为执行偏移地址为14的指令的情况，iload_3指令把存放在第3个局部变量Slot中的300入栈到操作数栈中。这时操作数栈为两个整数300,。</p></li><li><p>下一条偏移地址为15的指令imul是将操作数栈中前两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，这里和iadd指令执行过程完全类似，所以就不重复画图了。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>上图是最后一条指令也就是偏移地址为16的指令的执行过程，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给此方法的调用者。到此为止，该方法执行结束。</p></li><li><p>注：上面的执行过程只是一种概念模型，虚拟机最终会对执行过程做出一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述。不过从这段程序的执行过程也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都是以操作数栈的出栈和入栈为信息交换途径。</p><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2></li><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/azhegps/article/details/54092466" target="_blank" rel="noopener">https://blog.csdn.net/azhegps/article/details/54092466</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据一个代码实例来介绍虚拟机中解释器的执行过程&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行(一)运行时栈帧结构</title>
    <link href="http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C(%E4%B8%80)%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
    <id>http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM字节码执行(一)运行时栈帧结构/</id>
    <published>2019-03-19T13:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>前几章介绍了Class类的文件结构及类的加载，有了原材料及已经运送过来了，那么就要生产产品了，那么字节码的执行就在生产产品</li><li>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。</li><li>一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧的概念结构如下图所示：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/stackFrame.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><h3 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h3><ul><li>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。</li><li>在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。</li><li>局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。</li></ul><h3 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2. 操作数栈"></a>2. 操作数栈</h3><ul><li>操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。</li><li>当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。</li><li>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠过程如下图：</li></ul><p><img src="/images/server/java/JVM/stackFrame1.png" alt=""></p><h3 id="3-动态连接"><a href="#3-动态连接" class="headerlink" title="3. 动态连接"></a>3. 动态连接</h3><ul><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。</li></ul><h3 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4. 方法返回地址"></a>4. 方法返回地址</h3><ul><li>当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。</li><li>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。</li><li>无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</li><li>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。</li></ul><h3 id="5-附加信息"><a href="#5-附加信息" class="headerlink" title="5. 附加信息"></a>5. 附加信息</h3><ul><li>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</li></ul><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><ul><li>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul><li><p>如前所述，所有的方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可变的。也就是说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用成为解析。</p></li><li><p>JAVA中符号“编译器可知、运行期不可变”的方法包括：静态方法、私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这就决定了他们都不可能通过继承或别的方式重写其版本。因此都适合在类的加载阶段进行解析。</p></li><li><p>JAVA虚拟机里面提供了5条方法调用字节码指令。分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">invokestatic:调用静态方法</span><br><span class="line"></span><br><span class="line">invokespecial:调用实例构造器&lt;init&gt;方法、私有方法和父类方法（<span class="keyword">super</span>(),<span class="keyword">super</span>.method()）。</span><br><span class="line"></span><br><span class="line">invokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、<span class="keyword">final</span>方法都是非虚方法)。</span><br><span class="line"></span><br><span class="line">invokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象。</span><br><span class="line"></span><br><span class="line">invokedynamic:现在运行时期动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的<span class="number">4</span>条指令，分派逻辑都是固化在虚拟机里面的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</span><br></pre></td></tr></table></figure></li><li><p>只要能被invokestatic和invokespecial指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载阶段就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法（还包括使用final修饰的方法，虽然final方法使用invokevirtual指令调用，因为final方法注定不会被重写，也就是无法被覆盖，也就无需对其进行多态选择）。</p></li><li><p>解析调用一定是一个静态的过程，在编译期间就可以完全确定，在类装载的解析阶段就会把涉及的符号引用全部转化为可确定的直接引用，不会延迟到运行期去完成。而分派调用可能是静态的也可能是动态的，根据分派一句的宗量数可分为单分派和多分派。因此分派可分为：静态单分派、静态多分派、动态单分派、动态多分派。</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/xtayfjpk/article/details/41924283" target="_blank" rel="noopener">https://blog.csdn.net/xtayfjpk/article/details/41924283</a></li><li><a href="https://www.cnblogs.com/chenyangyao/p/5305352.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangyao/p/5305352.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前几章介绍了Class类的文件结构及类的加载，有了原材料及已经运送过来了，那么就要生产产品了，那么字节码的执行就在生产产品&lt;/l
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制(二)类加载器</title>
    <link href="http://www.songshuiyang.site/2019/03/18/backend/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6(%E4%BA%8C)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/18/backend/Java/JVM/JVM类加载机制(二)类加载器/</id>
    <published>2019-03-18T13:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h3><ul><li><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，</p></li><li><p>3种类加载器：</p><ul><li>启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。启动类加载器是无法被Java程序直接引用的。</li><li>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/classLoad.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>例子：<blockquote><p>寻找类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">64f</span>ef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>ddd40f3</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure></p></blockquote><ul><li><p>从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p></li><li><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></li><li><p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></li><li><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul><h3 id="2-自定义类加载器"><a href="#2-自定义类加载器" class="headerlink" title="2. 自定义类加载器"></a>2. 自定义类加载器</h3><ul><li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.neo.classloader.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-类的加载"><a href="#3-类的加载" class="headerlink" title="3. 类的加载"></a>3. 类的加载</h3><ul><li><p>类加载有三种方式</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li><li><p>Class.forName()和ClassLoader.loadClass()区别</p><ul><li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li>注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li></ul></li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul><li><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li><li><p>双亲委派机制:</p><ul><li>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li><li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li></ul></li><li>双亲委派模型意义：<ul><li>系统类防止内存中出现多份同样的字节码 </li><li>保证Java程序安全稳定运行<h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2></li></ul></li><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;h3 id=&quot;1-类加载器&quot;&gt;&lt;a href=&quot;#1-类加载器&quot; class=&quot;headerlink&quot; title=&quot;1. 类加载器&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制(一)类加载时机及过程</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6(%E4%B8%80)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA%E5%8F%8A%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类加载机制(一)类加载时机及过程/</id>
    <published>2019-03-16T03:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h2><ul><li><p>虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</p></li><li><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</p></li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul><li>如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。下面我们就分别来看一下这五个过程。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/jiazai.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><ul><li><p>加载的过程：</p><ul><li>1、通过一个类的全限定名来获取其定义的二进制字节流。</li><li>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul></li><li><p>加载<code>.class</code>文件的方式:</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件，比如java.lang.reflect.Proxy</li></ul></li><li><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p></li><li><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是Java堆中，在hotspot中它是存放在方法区中），这样便可以通过该对象访问方法区中的这些数据。</p></li></ul><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul><li><p>验证是为了确保被加载的类的正确性</p></li><li><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul></li><li>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3></li><li><p>准备是为类的静态变量分配内存，并将其初始化为默认值</p></li><li><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意</p><ul><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li><li>假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行</clinit></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/defalutValue.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><ul><li>解析是把类中的符号引用转换为直接引用</li><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3></li><li><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p></li><li><p>在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul></li><li>JVM初始化步骤<ul><li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul></li><li>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下五种(有且只有)：<ul><li>1、Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li><li>2、创建类的实例，也就是new的方式或者访问某个类或接口的静态变量，或者对该静态变量赋值，以及调用一个类的静态方法</li><li>3、使用java.lang.reflect包的方法对类进行反射调用的时候（如Class.forName(“com.shengsiyuan.Test”)）</li><li>4、初始化某个类的子类，如果父类没有初始化则其父类也会被初始化</li><li>5、当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li></ul></li><li>被动引用<ul><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发此类的初始化</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发</li></ul></li></ul><h3 id="6-结束"><a href="#6-结束" class="headerlink" title="6.结束"></a>6.结束</h3><ul><li>在如下几种情况下，Java虚拟机将结束生命周期<ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul></li><li>研究类加载全过程有助于连接JVM运行过程</li><li>深入了解java动态性（热部署，动态加载），提高程序的灵活性</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是类的加载&quot;&gt;&lt;a href=&quot;#什么是类的加载&quot; class=&quot;headerlink&quot; title=&quot;什么是类的加载&quot;&gt;&lt;/a&gt;什么是类的加载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(三)字节码指令</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%89)%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(三)字节码指令/</id>
    <published>2019-03-16T02:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。由于JAVA虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码</p></li><li><p>伪代码执行模型</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zijie.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="加载、存储指令"><a href="#加载、存储指令" class="headerlink" title="加载、存储指令"></a>加载、存储指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）iload、iload&lt;n&gt;、lload、lload&lt;n&gt;、fload、fload&lt;n&gt;、dload、dload&lt;n&gt;、aload、aload&lt;n&gt;：将一个局部变量加载到操作数栈。</span><br><span class="line">2）istore、istore&lt;n&gt;、lstore、lstore&lt;n&gt;、fstore、fstore&lt;n&gt;、dstore、dstore&lt;n&gt;、astore、astore&lt;n&gt;：将一个数值从操作数栈存储到局部变量表。</span><br><span class="line">3）bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconstm1、iconst&lt;i&gt;、lconst&lt;l&gt;、fconst&lt;f&gt;、dconst_&lt;d&gt;：将一个常量加载到操作数栈。</span><br><span class="line">4）wide：扩充局部变量表的访问索引的指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">methodE</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">300000</span>;</span><br><span class="line">    e++;</span><br><span class="line">    ++e;</span><br><span class="line">    --e;</span><br><span class="line">    e--;</span><br><span class="line">    <span class="keyword">return</span> c + d + e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">methodE</span><span class="params">()</span></span>;</span><br><span class="line">        Signature: ()I</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">        Code:</span><br><span class="line">        stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: sipush        <span class="number">300</span></span><br><span class="line">        <span class="number">6</span>: istore_1</span><br><span class="line">        7: ldc           #5                  // int 300000</span><br><span class="line">        <span class="number">9</span>: istore_2</span><br><span class="line">        <span class="number">10</span>: iinc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">13</span>: iinc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">16</span>: iinc          <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="number">19</span>: iinc          <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="number">22</span>: iload_1</span><br><span class="line">        <span class="number">23</span>: iload_2</span><br><span class="line">        <span class="number">24</span>: iadd</span><br><span class="line">        <span class="number">25</span>: iload_0</span><br><span class="line">        <span class="number">26</span>: iadd</span><br><span class="line">        <span class="number">27</span>: ireturn</span><br><span class="line">        LineNumberTable:</span><br><span class="line">        line <span class="number">40</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">41</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">42</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">43</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">44</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">45</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">46</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">47</span>: <span class="number">22</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）iadd、ladd、fadd、dadd：加法指令。</span><br><span class="line">2）isub、lsub、fsub、dsub：减法指令。</span><br><span class="line">3）imul、lmul、fmul、dmul：乘法指令。</span><br><span class="line">4）idiv、ldiv、fdiv、ddiv：除法指令。</span><br><span class="line">5）irem、lrem、frem、drem：求余指令。</span><br><span class="line">6）ineg、lneg、fneg、dneg：取反指令。</span><br><span class="line">7）ishl、ishr、iushr、lshl、lshr、lushr：位移指令。</span><br><span class="line">8）ior、lor：按位或指令。</span><br><span class="line">9）iand、land：按位与指令。</span><br><span class="line">10）ixor、lxor：按位异或指令。</span><br><span class="line">11）iinc：局部变量自增指令。</span><br><span class="line">12）dcmpg、dcmpl、fcmpg、fcmpl、lcmp：比较指令。</span><br></pre></td></tr></table></figure><ul><li>示例参照上例</li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）int类型到long、float或者double类型，long类型到float、double类型，float类型到double类型：宽化类型转换（虚拟机直接支持）。</span><br><span class="line">2）i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f：窄化类型转换（显式指令）。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">short</span> i2s = (<span class="keyword">short</span>) i;</span><br><span class="line">    <span class="keyword">char</span> i2c = (<span class="keyword">char</span>) i;</span><br><span class="line">    <span class="keyword">long</span> i2l = i;</span><br><span class="line">    <span class="keyword">float</span> i2f = i;</span><br><span class="line">    <span class="keyword">double</span> i2d = i;</span><br><span class="line">    <span class="keyword">float</span> l2f = i2l;</span><br><span class="line">    <span class="keyword">double</span> l2d = i2l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodK</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">11</span>, args_size=<span class="number">0</span></span><br><span class="line">     <span class="number">0</span>: bipush        <span class="number">97</span></span><br><span class="line">     <span class="number">2</span>: istore_0</span><br><span class="line">     <span class="number">3</span>: iload_0</span><br><span class="line">     <span class="number">4</span>: i2s</span><br><span class="line">     <span class="number">5</span>: istore_1</span><br><span class="line">     <span class="number">6</span>: iload_0</span><br><span class="line">     <span class="number">7</span>: i2c</span><br><span class="line">     <span class="number">8</span>: istore_2</span><br><span class="line">     <span class="number">9</span>: iload_0</span><br><span class="line">    <span class="number">10</span>: i2l</span><br><span class="line">    <span class="number">11</span>: lstore_3</span><br><span class="line">    <span class="number">12</span>: iload_0</span><br><span class="line">    <span class="number">13</span>: i2f</span><br><span class="line">    <span class="number">14</span>: fstore        <span class="number">5</span></span><br><span class="line">    <span class="number">16</span>: iload_0</span><br><span class="line">    <span class="number">17</span>: i2d</span><br><span class="line">    <span class="number">18</span>: dstore        <span class="number">6</span></span><br><span class="line">    <span class="number">20</span>: lload_3</span><br><span class="line">    <span class="number">21</span>: l2f</span><br><span class="line">    <span class="number">22</span>: fstore        <span class="number">8</span></span><br><span class="line">    <span class="number">24</span>: lload_3</span><br><span class="line">    <span class="number">25</span>: l2d</span><br><span class="line">    <span class="number">26</span>: dstore        <span class="number">9</span></span><br><span class="line">    <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">100</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">101</span>: <span class="number">3</span></span><br><span class="line">    line <span class="number">102</span>: <span class="number">6</span></span><br><span class="line">    line <span class="number">103</span>: <span class="number">9</span></span><br><span class="line">    line <span class="number">104</span>: <span class="number">12</span></span><br><span class="line">    line <span class="number">105</span>: <span class="number">16</span></span><br><span class="line">    line <span class="number">106</span>: <span class="number">20</span></span><br><span class="line">    line <span class="number">107</span>: <span class="number">24</span></span><br><span class="line">    line <span class="number">108</span>: <span class="number">28</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）new ：创建类实例的指令。</span><br><span class="line">2）newarray、anewarray、multianewarray：创建数组的指令。</span><br><span class="line">3）getstatic、putstatic、getfield、putfield：访问类字段（类变量）和实例字段（实例变量）的指令。</span><br><span class="line">4）baload、caload、saload、iaload、laload、faload、daload、aaload：把一个数组元素加载到操作数栈的指令。</span><br><span class="line">5）bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore：把一个操作数栈的值存储到数组元素中的指令。</span><br><span class="line">6）arraylength：取数组长度的指令。</span><br><span class="line">7）instanceof、checkcast：检查类实例类型的指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodJ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SimpleMethodExecuteProcess();</span><br><span class="line"></span><br><span class="line">    System.out.println(SimpleMethodExecuteProcess.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodJ</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">     0: new           #9                  // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: invokespecial #10                 // Method "&lt;init&gt;":()V</span><br><span class="line">     <span class="number">7</span>: pop</span><br><span class="line">     8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    11: getstatic     #11                 // Field i:I</span><br><span class="line">    14: invokevirtual #12                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">    <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">91</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">93</span>: <span class="number">8</span></span><br><span class="line">    line <span class="number">94</span>: <span class="number">17</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）pop、pop2：将操作数栈的栈顶一个或两个元素出栈。</span><br><span class="line">2）dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。</span><br><span class="line">3）swap：将栈最顶端两个数值互换</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    heavyMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">        Signature: ([Ljava/lang/String;)V</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">        Code:</span><br><span class="line">                        stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">                        0: invokestatic  #23                 // Method heavyMethod:()I</span><br><span class="line">                        <span class="number">3</span>: pop</span><br><span class="line">                        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">                        line <span class="number">115</span>: <span class="number">0</span></span><br><span class="line">                        line <span class="number">116</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。</span><br><span class="line">2）tableswitch、lookupswitch：复合条件分支。</span><br><span class="line">3）goto、goto_w、jsr、jsr_w、ret：无条件分支。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodG</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodG</span><span class="params">()</span></span>;</span><br><span class="line"> Signature: ()V</span><br><span class="line"> flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"> Code:</span><br><span class="line">   stack=<span class="number">3</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">      0: getstatic     #6                  // Field i:I</span><br><span class="line">      <span class="number">3</span>: ifne          <span class="number">15</span></span><br><span class="line">      6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      9: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J</span><br><span class="line">     12: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V</span><br><span class="line">     15: getstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">18</span>: iconst_1</span><br><span class="line">     <span class="number">19</span>: if_icmpge     <span class="number">42</span></span><br><span class="line">     22: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     25: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J</span><br><span class="line">     28: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V</span><br><span class="line">     31: getstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">34</span>: iconst_1</span><br><span class="line">     <span class="number">35</span>: iadd</span><br><span class="line">     36: putstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">39</span>: goto          <span class="number">15</span></span><br><span class="line">     <span class="number">42</span>: <span class="keyword">return</span></span><br><span class="line">   LineNumberTable:</span><br><span class="line">     line <span class="number">62</span>: <span class="number">0</span></span><br><span class="line">     line <span class="number">63</span>: <span class="number">6</span></span><br><span class="line">     line <span class="number">66</span>: <span class="number">15</span></span><br><span class="line">     line <span class="number">67</span>: <span class="number">22</span></span><br><span class="line">     line <span class="number">68</span>: <span class="number">31</span></span><br><span class="line">     line <span class="number">70</span>: <span class="number">42</span></span><br><span class="line">   StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">15</span> <span class="comment">/* same */</span></span><br><span class="line">        frame_type = <span class="number">26</span> <span class="comment">/* same */</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">athrow ：显式抛出异常指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodH</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"nothing ..."</span>);</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodH</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">     0: new           #9                  // class java/lang/NullPointerException</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: ldc           #10                 // String nothing ...</span><br><span class="line">     6: invokespecial #11                 // Method java/lang/NullPointerException."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">     <span class="number">9</span>: athrow</span><br><span class="line">    <span class="number">10</span>: astore_0</span><br><span class="line">    <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         <span class="number">0</span>    <span class="number">10</span>    <span class="number">10</span>   Class java/lang/Throwable</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">77</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">79</span>: <span class="number">10</span></span><br><span class="line">    line <span class="number">82</span>: <span class="number">11</span></span><br><span class="line">  StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">       frame_type = <span class="number">74</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">      stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>同步指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorenter、monitorexit：支持synchronized语句块语义的指令。</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Integer.class)&#123;</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodI</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">     0: ldc_w         #13                 // class java/lang/Integer</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     <span class="number">4</span>: astore_1</span><br><span class="line">     <span class="number">5</span>: monitorenter</span><br><span class="line">     <span class="number">6</span>: aload_1</span><br><span class="line">     <span class="number">7</span>: monitorexit</span><br><span class="line">     <span class="number">8</span>: goto          <span class="number">16</span></span><br><span class="line">    <span class="number">11</span>: astore_2</span><br><span class="line">    <span class="number">12</span>: aload_1</span><br><span class="line">    <span class="number">13</span>: monitorexit</span><br><span class="line">    <span class="number">14</span>: aload_2</span><br><span class="line">    <span class="number">15</span>: athrow</span><br><span class="line">    <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         <span class="number">6</span>     <span class="number">8</span>    <span class="number">11</span>   any</span><br><span class="line">        <span class="number">11</span>    <span class="number">14</span>    <span class="number">11</span>   any</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">88</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">90</span>: <span class="number">6</span></span><br><span class="line">    line <span class="number">91</span>: <span class="number">16</span></span><br><span class="line">  StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">       frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">      offset_delta = <span class="number">11</span></span><br><span class="line">      locals = [ class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess, class java/lang/Object ]</span><br><span class="line">      stack = [ class java/lang/Throwable ]</span><br><span class="line">       frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">      offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>synchronized 修饰方法的语义解析：可以直接从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法，不需要解析出monitorenter、monitorexit同步指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodL</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodL</span><span class="params">()</span></span>;</span><br><span class="line">        Signature: ()V</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">        Code:</span><br><span class="line">            stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">                 <span class="number">0</span>: bipush        <span class="number">97</span></span><br><span class="line">                 <span class="number">2</span>: istore_0</span><br><span class="line">                 <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">            LineNumberTable:</span><br><span class="line">                line <span class="number">120</span>: <span class="number">0</span></span><br><span class="line">                line <span class="number">121</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>方法调用和返回指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）invokestatic：调用静态方法。</span><br><span class="line">2）invokespecial：调用实例构造器&lt;init&gt;方法、私有方法和父类方法。</span><br><span class="line">3）invokevirtual：调用所有的虚方法。非虚方法以外的都是虚方法，非虚方法包括使用invokestatic、invokespecial调用的方法和被final修饰的方法。</span><br><span class="line">4）invokeinterface：调用接口方法，运行时再确定一个实现此接口的对象。</span><br><span class="line">5）invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。</span><br><span class="line">ireturn（返回值是boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn：方法返回指令。</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heavyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> c = methodC(methodA(methodA(a, b), b), methodB(a, b));</span><br><span class="line">    methodD();</span><br><span class="line">    methodE();</span><br><span class="line">    methodF();</span><br><span class="line">    methodG();</span><br><span class="line">    methodH();</span><br><span class="line">    <span class="keyword">new</span> SimpleMethodExecuteProcess().methodI();</span><br><span class="line">    methodJ();</span><br><span class="line">    methodK();</span><br><span class="line">    methodL();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heavyMethod</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()I</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">     <span class="number">0</span>: sipush        <span class="number">200</span></span><br><span class="line">     <span class="number">3</span>: istore_0</span><br><span class="line">     <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">     <span class="number">6</span>: istore_1</span><br><span class="line">     <span class="number">7</span>: iload_0</span><br><span class="line">     <span class="number">8</span>: iload_1</span><br><span class="line">     9: invokestatic  #17                 // Method methodA:(II)I</span><br><span class="line">    <span class="number">12</span>: iload_1</span><br><span class="line">    13: invokestatic  #17                 // Method methodA:(II)I</span><br><span class="line">    <span class="number">16</span>: iload_0</span><br><span class="line">    <span class="number">17</span>: iload_1</span><br><span class="line">    18: invokestatic  #18                 // Method methodB:(II)I</span><br><span class="line">    21: invokestatic  #19                 // Method methodC:(II)I</span><br><span class="line">    <span class="number">24</span>: istore_2</span><br><span class="line">    25: invokestatic  #20                 // Method methodD:()V</span><br><span class="line">    28: invokestatic  #21                 // Method methodE:()I</span><br><span class="line">    <span class="number">31</span>: pop</span><br><span class="line">    32: invokestatic  #22                 // Method methodF:()D</span><br><span class="line">    <span class="number">35</span>: pop2</span><br><span class="line">    36: invokestatic  #23                 // Method methodG:()V</span><br><span class="line">    39: invokestatic  #24                 // Method methodH:()V</span><br><span class="line">    42: new           #14                 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess</span><br><span class="line">    <span class="number">45</span>: dup</span><br><span class="line">    46: invokespecial #15                 // Method "&lt;init&gt;":()V</span><br><span class="line">    49: invokevirtual #25                 // Method methodI:()V</span><br><span class="line">    52: invokestatic  #26                 // Method methodJ:()V</span><br><span class="line">    55: invokestatic  #27                 // Method methodK:()V</span><br><span class="line">    58: invokestatic  #28                 // Method methodL:()V</span><br><span class="line">    <span class="number">61</span>: iload_2</span><br><span class="line">    <span class="number">62</span>: ireturn</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">128</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">129</span>: <span class="number">4</span></span><br><span class="line">    line <span class="number">130</span>: <span class="number">7</span></span><br><span class="line">    line <span class="number">131</span>: <span class="number">25</span></span><br><span class="line">    line <span class="number">132</span>: <span class="number">28</span></span><br><span class="line">    line <span class="number">133</span>: <span class="number">32</span></span><br><span class="line">    line <span class="number">134</span>: <span class="number">36</span></span><br><span class="line">    line <span class="number">135</span>: <span class="number">39</span></span><br><span class="line">    line <span class="number">136</span>: <span class="number">42</span></span><br><span class="line">    line <span class="number">137</span>: <span class="number">52</span></span><br><span class="line">    line <span class="number">138</span>: <span class="number">55</span></span><br><span class="line">    line <span class="number">139</span>: <span class="number">58</span></span><br><span class="line">    line <span class="number">140</span>: <span class="number">61</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.51cto.com/damon188/2131035" target="_blank" rel="noopener">https://blog.51cto.com/damon188/2131035</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(二)Code属性</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%BA%8C)Code%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(二)Code属性/</id>
    <published>2019-03-16T01:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据</p></li><li><p>Java虚拟机执行字节码是基于栈的体系结构</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/yxwkf/p/5222589.html" target="_blank" rel="noopener">https://www.cnblogs.com/yxwkf/p/5222589.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(一)Class类文件结构</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%80)Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(一)Class类文件结构/</id>
    <published>2019-03-16T00:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器直接生成)。</p></li><li><p>Class文件是一组以8位字节为基础单位的二进制流。各个数据项严格按顺序排列，没有不论什么分隔符。</p></li><li><p>Class文件格式採用一种类似于C语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>使用以下的类进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getM</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>javap -verbose 执行后的可视byteCode（只存在两种数据类型：无符号数字与表）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/workspace-github/jvm/target/production/jvm/com/songsy/Test.class</span><br><span class="line">  Last modified <span class="number">2019</span>-<span class="number">3</span>-<span class="number">16</span>; size <span class="number">361</span> bytes</span><br><span class="line">  MD5 checksum bb8e54060828e4bf1f709c2f4434dca8</span><br><span class="line">  Compiled from <span class="string">"Test.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">songsy</span>.<span class="title">Test</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#18         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#19         // com/songsy/Test.m:I</span><br><span class="line">   #3 = Class              #20            // com/songsy/Test</span><br><span class="line">   #4 = Class              #21            // java/lang/Object</span><br><span class="line">   #5 = Utf8               m</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/songsy/Test;</span><br><span class="line">  #14 = Utf8               getM</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               SourceFile</span><br><span class="line">  #17 = Utf8               Test.java</span><br><span class="line">  #18 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #19 = NameAndType        #5:#6          // m:I</span><br><span class="line">  #20 = Utf8               com/songsy/Test</span><br><span class="line">  #21 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.songsy.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/songsy/Test;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getM</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/songsy/Test;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test.java"</span></span><br></pre></td></tr></table></figure></li><li><p>编译后的class文件例如以下：</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-魔数与Class版本"><a href="#1-魔数与Class版本" class="headerlink" title="1. 魔数与Class版本"></a>1. 魔数与Class版本</h3><ul><li>每一个class文件的头4个字节称为魔数，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。非常多文件存储标准中都使用魔数来进行身份识别。譬如图片格式gif、jpeg等。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，由于文件拓展格式能够任意修改。Class文件的魔数为：0xCAFEBABE（咖啡宝贝？）。这个魔数似乎也预示着日后JAVA这个商标名称的出现。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>第五六个字节是次版本（Minor Version）。第7和第8个字节是主版本（Major Version）。</p></li><li><p>高版本号的JDK能够向下兼容曾经版本号的Class文件，可是无法执行以后版本号的Class文件，即使文件格式并未发生变化，虚拟机也必须拒绝执行超过其版本号号的Class文件。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class-version.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h3><ul><li>紧接着版本之后就是常量池，常量池能够理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之中的一个。同一时候也是在Class文件里第一个出现的表类型数据项目</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>常量池中主要存放两大类常量<ul><li>字面量和符号引用。字面量如文本字符串、声明为final的常量值等</li><li>符号引用包含三类常量：类和接口的全限定名、字段的名称和描写叙述符、方法的名称和描写叙述符。</li></ul></li></ul><h3 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3. 访问标志"></a>3. 访问标志</h3><ul><li>在常量池结束之后，紧接着的两个字节代表訪问标志。用于识别一些类或者接口层次的訪问信息。包括：这个类是Class类还是接口；是否定义为public类型，是否被声明为final，具体的标志位及其含义例如以下表所看到的。</li></ul><p><img src="/images/server/java/JVM/class-access.png" alt="image"></p><ul><li>依据上面的表格，測试类的訪问标志0x0021= 0x0001 | 0x0020 =ACC_PUBLIC | ACC_SUPER </li></ul><p><img src="/images/server/java/JVM/class4.png" alt=""></p><h3 id="4-类索引、父类索引和接口索引集合"><a href="#4-类索引、父类索引和接口索引集合" class="headerlink" title="4. 类索引、父类索引和接口索引集合"></a>4. 类索引、父类索引和接口索引集合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>Class文件里由这3项数据来确定这个类的继承关系<ul><li>this_class：类索引，用于确定这个类的全限定名，占2字节</li><li>super_class：父类索引。用于确定这个类父类的全限定名（Java语言不同意多重继承，故父类索引仅仅有一个。除了java.lang.Object类之外全部类都有父类，故除了java.lang.Object类之外，全部类该字段值都不为0），占2字节</li><li>interfaces_count：接口索引计数器。占2字节。接口索引计数器。占2字节。</li><li>interfaces：接口索引集合，一组u2类型数据的集合。用来描写叙述这个类实现了哪些接口。这些被实现的接口将按implements语句（假设该类本身为接口，则为extends语句）后的接口顺序从左至右排列在接口的索引集合中</li></ul></li><li>this_class、super_class与interfaces中保存的索引值均指向常量池中一个CONSTANT_Class_info类型的常量。通过这个常量中保存的索引值能够找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串this_class的值为0x0001，即常量池中第一个常量，super_class的值为0x0003，即常量池中的第三个常量，interfaces_counts的值为0x0000，故接口索引集合大小为0</li></ul><h3 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5. 字段表集合"></a>5. 字段表集合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>字段表用于描写叙述接口或者类中声明的变量，包含类级变量和实例级变量(是否是static)。但不包含在方法内部声明的局部变量。<ul><li>fields_count：字段表计数器。即字段表集合中的字段表数据个数。占2字节，其值为0x0001，即仅仅有一个字段表数据。也就是測试类中仅仅包括一个变量（不算方法内部变量）</li><li>字段表集合，一组字段表类型数据的集合。字段表用于描写叙述接口或类中声明的变量。包含类级别（static）和实例级别变量，不包含在方法内部声明的变量 <h3 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6. 方法表集合"></a>6. 方法表集合</h3></li></ul></li><li><p>methods_count：方法表计数器，即方法表集合中的方法表数据个数。占2字节，其值为0x0002，即測试类中有2个方法(还自己主动添加了一个构造函数）</p></li><li><p>methods：方法表集合，一组方法表类型数据的集合。方法表结构和字段表结构一样：</p></li></ul><h3 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7. 属性表集合"></a>7. 属性表集合</h3><ul><li><p>在Class文件、属性表、方法表中都能够包括自己的属性表集合。用于描写叙述某些场景的专有信息</p></li><li><p>与Class文件里其他数据项对长度、顺序、格式的严格要求不同，属性表集合不要求当中包括的属性表具有严格的顺序，而且仅仅要属性的名称不与已有的属性名称反复。不论什么人实现的编译器可以向属性表中写入自定义的属性信息。虚拟机在执行时会忽略不能识别的属性，为了能正确解析Class文件</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/yxwkf/p/5222589.html" target="_blank" rel="noopener">https://www.cnblogs.com/yxwkf/p/5222589.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(五)GC分析</title>
    <link href="http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%BA%94)GC%E5%88%86%E6%9E%90/"/>
    <id>http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM垃圾回收(五)GC分析/</id>
    <published>2019-03-11T15:59:44.000Z</published>
    <updated>2019-03-26T13:58:09.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC日志查看"><a href="#GC日志查看" class="headerlink" title="GC日志查看"></a>GC日志查看</h2><ul><li>可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。GC的日志是以替换的方式(&gt;)写入的，而不是追加(&gt;&gt;)，如果下次写入到同一个文件中的话，以前的GC内容会被清空。</li><li><p>对应的参数列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br></pre></td></tr></table></figure></li><li><p>示例 <code>-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs</code></p><blockquote><p>新生代回收日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K-&gt;2K(948864K), 0.0059180 secs] 2186589K-&gt;1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">``` </span><br><span class="line">```sql</span><br><span class="line">2014-07-18T16:02:17.606+0800（当前时间戳）: 611.633（时间戳）: [GC（表示Young GC） 611.633: [DefNew（单线程Serial年轻代GC）: 843458K（年轻代垃圾回收前的大小）-&gt;2K（年轻代回收后的大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）] 2186589K（整个堆回收前的大小）-&gt;1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）]</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>老年代回收的日志如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014-07-18T16:19:16.794+0800: 1630.821: [GC 1630.821: [DefNew: 1005567K-&gt;111679K(1005568K), 0.9152360 secs]1631.736: [Tenured:2573912K-&gt;1340650K(2574068K), 1.8511050 secs] 3122548K-&gt;1340650K(3579636K), [Perm : 17882K-&gt;17882K(21248K)], 2.7854350 secs] [Times: user=2.57 sys=0.22, real=2.79 secs]</span><br></pre></td></tr></table></figure></p></blockquote><p># </p><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/qlqwjy/p/7929414.html" target="_blank" rel="noopener">https://www.cnblogs.com/qlqwjy/p/7929414.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GC日志查看&quot;&gt;&lt;a href=&quot;#GC日志查看&quot; class=&quot;headerlink&quot; title=&quot;GC日志查看&quot;&gt;&lt;/a&gt;GC日志查看&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。GC的
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(四)常用参数</title>
    <link href="http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E5%9B%9B)%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
    <id>http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM垃圾回收(四)常用参数/</id>
    <published>2019-03-11T13:59:44.000Z</published>
    <updated>2019-03-26T11:02:02.723Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JVM参数的含义</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-Xms</td><td style="text-align:left">初始堆大小starting</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td style="text-align:left">-Xmx</td><td style="text-align:left">最大堆大小max</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td style="text-align:left">-Xmn</td><td style="text-align:left">年轻代大小(1.4or lator)new</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td style="text-align:left">设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td style="text-align:left">年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:PermSize</td><td style="text-align:left">设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td style="text-align:left">设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td style="text-align:left">-Xss</td><td style="text-align:left">每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:””-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。</td></tr><tr><td style="text-align:left">-XX:ThreadStackSize</td><td style="text-align:left">Thread Stack Size</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td style="text-align:left">年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td style="text-align:left">Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td style="text-align:left">-XX:LargePageSizeInBytes</td><td style="text-align:left">内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>=128m</td></tr><tr><td style="text-align:left">-XX:+UseFastAccessorMethods</td><td style="text-align:left">原始类型的快速优化</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+DisableExplicitGC</td><td style="text-align:left">关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td style="text-align:left">-XX:MaxTenuringThreshold</td><td style="text-align:left">垃圾最大年龄</td><td></td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效</td></tr><tr><td style="text-align:left">-XX:+AggressiveOpts</td><td style="text-align:left">加快编译</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+UseBiasedLocking</td><td style="text-align:left">锁机制的性能改善</td><td></td><td></td></tr><tr><td style="text-align:left">-Xnoclassgc</td><td style="text-align:left">禁用垃圾回收</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:SoftRefLRUPolicyMSPerMB</td><td style="text-align:left">每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td></td></tr><tr><td style="text-align:left">-XX:PretenureSizeThreshold</td><td style="text-align:left">对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td style="text-align:left">-XX:TLABWasteTargetPercent</td><td style="text-align:left">TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td style="text-align:left">-XX:+CollectGen0First</td><td style="text-align:left">FullGC时是否先YGC</td><td>false</td></tr></tbody></table><blockquote><p>并行收集器相关参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+UseParallelGC</td><td style="text-align:left">Full GC采用parallel MSC(此项待验证)</td><td></td><td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td></tr><tr><td style="text-align:left">-XX:+UseParNewGC</td><td style="text-align:left">设置年轻代为并行收集</td><td></td><td>可与CMS收集同时使用JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td></tr><tr><td style="text-align:left">-XX:ParallelGCThreads</td><td style="text-align:left">并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td style="text-align:left">-XX:+UseParallelOldGC</td><td style="text-align:left">年老代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td><td>这个是JAVA 6出现的参数选项</td></tr><tr><td style="text-align:left">-XX:MaxGCPauseMillis</td><td style="text-align:left">每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr><tr><td style="text-align:left">-XX:+UseAdaptiveSizePolicy</td><td style="text-align:left">自动选择年轻代区大小和相应的Survivor区比例</td><td></td><td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td></tr><tr><td style="text-align:left">-XX:GCTimeRatio</td><td style="text-align:left">设置垃圾回收时间占程序运行时间的百分比</td><td></td><td>公式为1/(1+n)</td></tr><tr><td style="text-align:left">-XX:+ScavengeBeforeFullGC</td><td style="text-align:left">Full GC前调用YGC</td><td>true</td><td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td></tr></tbody></table><blockquote><p>CMS相关参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+UseConcMarkSweepGC</td><td style="text-align:left">使用CMS内存收集</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+AggressiveHeap</td><td style="text-align:left"></td><td></td><td>试图是使用大量的物理内存长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td style="text-align:left">-XX:CMSFullGCsBeforeCompaction</td><td style="text-align:left">多少次后进行内存压缩</td><td></td><td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td></tr><tr><td style="text-align:left">-XX:+CMSParallelRemarkEnabled</td><td style="text-align:left">降低标记停顿</td><td></td><td></td></tr><tr><td style="text-align:left">-XX+UseCMSCompactAtFullCollection</td><td style="text-align:left">在FULL GC的时候， 对年老代的压缩</td><td></td><td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片</td></tr><tr><td style="text-align:left">-XX:+UseCMSInitiatingOccupancyOnly</td><td style="text-align:left">使用手动定义初始化定义开始CMS收集</td><td></td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td style="text-align:left">-XX:CMSInitiatingOccupancyFraction=70</td><td style="text-align:left">使用cms作为垃圾回收使用70％后开始CMS收集</td><td>92</td><td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式</td></tr><tr><td style="text-align:left">-XX:CMSInitiatingPermOccupancyFraction</td><td style="text-align:left">设置Perm Gen使用到达多少比率时触发</td><td>92</td><td></td></tr><tr><td style="text-align:left">-XX:+CMSIncrementalMode</td><td style="text-align:left">设置为增量模式</td><td></td><td>用于单CPU情况</td></tr><tr><td style="text-align:left">-XX:+CMSClassUnloadingEnabled</td><td style="text-align:left"></td><td></td></tr></tbody></table><blockquote><p>辅助参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+PrintGC</td><td style="text-align:left"></td><td></td><td>输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143 secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCDetails</td><td style="text-align:left"></td><td></td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCTimeStamps</td><td style="text-align:left"></td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintGCApplicationStoppedTime</td><td style="text-align:left">打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td></td><td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCApplicationConcurrentTime</td><td style="text-align:left">打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td><td></td><td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td></tr><tr><td style="text-align:left">-XX:+PrintHeapAtGC</td><td style="text-align:left">打印GC前后的详细堆栈信息</td><td></td><td></td></tr><tr><td style="text-align:left">-Xloggc:filename</td><td style="text-align:left">把相关日志信息记录到文件以便分析，与上面几个配合使用</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintClassHistogram</td><td style="text-align:left">garbage collects before printing the histogram.</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintTLAB</td><td style="text-align:left">查看TLAB空间的使用情况</td><td></td><td></td></tr><tr><td style="text-align:left">XX:+PrintTenuringDistribution</td><td style="text-align:left">查看每次minor GC后新的存活周期的阈值</td><td></td><td>Desired survivor size 1048576 bytes, new threshold 7 (max 15)new threshold 7即标识新的存活周期的阈值为7。</td></tr></tbody></table><blockquote><p>备注</p><ul><li><code>-X</code> 开头参数的是非标准，不是所有虚拟机都支持，<code>-XX</code>更流氓，不保证其稳定性</li><li></li></ul></blockquote><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;JVM参数的含义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;参数名称&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;含义&lt;/th&gt;
&lt;t
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(三)内存分配及回收策略</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%B8%89)%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%8A%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(三)内存分配及回收策略/</id>
    <published>2019-03-10T14:59:44.000Z</published>
    <updated>2019-03-26T13:00:18.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。</li><li>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。<ul><li>TLAB: 首先讲讲什么是TLAB。内存分配的动作，可以按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。这么做的目的之一，也是为了并发创建一个对象时，保证创建对象的线程安全性。TLAB比较小，直接在TLAB上分配内存的方式称为快速分配方式，而TLAB大小不够，导致内存被分配在Eden区的内存分配方式称为慢速分配方式。</li></ul></li><li>接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。由于条件因素，只能在Client模式下测试，因此CMS和G1并未提及。<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></li></ul><h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h3><ul><li>所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。<ul><li>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。</li><li>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。</li></ul></li></ul><p><img src="/images/server/java/JVM/gc-generation.gif" alt=""></p><ul><li><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。这时会把存活的对象转移进Survivor区。</p><ul><li><code>Minor GC</code> 新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。</li><li><code>Major GC</code> 老年代GC，指发生在老年代的GC。</li><li><code>Full GC</code> 包括前两个</li></ul></li><li><p>举例说明</p><ul><li><p>下面的代码来看一下jvm具体是怎样分配的，下面的代码注释有详细解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：</span></span><br><span class="line"><span class="comment"> *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> * 参数解析：</span></span><br><span class="line"><span class="comment"> *      * 初始堆大小为20兆，不可扩展，年轻代大小为10兆剩下的10兆分配给老年代，PrintGCDetails打印内存回收日志，SurvivorRatio标识 eden与Survivor比例为8:1</span></span><br><span class="line"><span class="comment"> *      * "eden space 8192K from space 1024K to space 1024K" 新生代总可用空间为9216KB (一个Eden区 + 一个Survivor区)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/11 18:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1KB = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * _1KB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1,allocation2, allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到下一步出现一次Minor GC，因为发现Eden已经被占用了6Mb，剩余空间装不下4Mb，</span></span><br><span class="line"><span class="comment">         * 执行gc的时候发现已有3*2Mb的对象无法放入Survivor（只有1mb）空间，所以只好通过</span></span><br><span class="line"><span class="comment">         * 分配担保机制提前转移到老年代去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Gc结束，4Mb的allocation4对象将分配在Eden区，老年代占用6Mb</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">* 输出日志</span><br></pre></td></tr></table></figure><p>[GC[DefNew: 7485K-&gt;526K(9216K), 0.0076710 secs] 7485K-&gt;6671K(19456K), 0.0077381 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>Heap<br>def new generation   total 9216K, used 4952K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)<br>eden space 8192K,  54% used [0x00000000f9a00000, 0x00000000f9e526c8, 0x00000000fa200000)<br>from space 1024K,  51% used [0x00000000fa300000, 0x00000000fa383bd8, 0x00000000fa400000)<br>to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)<br>tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)<br> the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)<br>compacting perm gen  total 21248K, used 2950K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)<br> the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0e1918, 0x00000000fb0e1a00, 0x00000000fc2c0000)<br>No shared spaces configured.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">### 2. 大对象直接进入老年代</span><br><span class="line">* 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）。</span><br><span class="line">* 虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。</span><br><span class="line">* 举例说明</span><br><span class="line">    ```java</span><br><span class="line">    /**</span><br><span class="line">     * 测试大对象直接进入老年代</span><br><span class="line">     *</span><br><span class="line">     * VM参数：</span><br><span class="line">     *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br><span class="line">     * -XX:PretenureSizeThreshold=3145728 可选</span><br><span class="line">     * </span><br><span class="line">     * @author songsy</span><br><span class="line">     * @date 2019/3/11 18:37</span><br><span class="line">     */</span><br><span class="line">    public class Jvm2 &#123;</span><br><span class="line">    </span><br><span class="line">        private static final int _1KB = 1024;</span><br><span class="line">        private static final int _1MB = 1024 * _1KB;</span><br><span class="line">    </span><br><span class="line">        public static void testAllocation() &#123;</span><br><span class="line">            byte [] allocation1;</span><br><span class="line">            // 直接分配在老年代</span><br><span class="line">            allocation1 = new byte[4 * _1MB];</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            testAllocation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>没设置PretenureSizeThreshold，可以看到新生代<code>def new generation   total 9216K, used 5773K</code>，老年代<code>tenured generation   total 10240K, used 0K</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 5773K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)</span><br><span class="line">  eden space 8192K,  70% used [0x00000000f9a00000, 0x00000000f9fa3668, 0x00000000fa200000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000fa400000, 0x00000000fa400000, 0x00000000fa400200, 0x00000000fae00000)</span><br><span class="line"> compacting perm gen  total 21248K, used 3237K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)</span><br><span class="line">   the space 21248K,  15% used [0x00000000fae00000, 0x00000000fb129600, 0x00000000fb129600, 0x00000000fc2c0000)</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>* 设置了PretenureSizeThreshold结果，可以看到新生代`def new generation   total 9216K, used 1671K` ,老年代`tenured generation   total 10240K, used 4096K`<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1671K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)</span><br><span class="line">  eden space 8192K,  20% used [0x00000000f9a00000, 0x00000000f9ba1c08, 0x00000000fa200000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)</span><br><span class="line">   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)</span><br><span class="line"> compacting perm gen  total 21248K, used 2938K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)</span><br><span class="line">   the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0de9e0, 0x00000000fb0dea00, 0x00000000fc2c0000)</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure></code></pre><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><ul><li>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象放在新生代，那些对象放在老年代中</li><li>为了能做到这一点，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数<code>-XX：MaxTenuringThreshold</code>设置。</li><li>举例说明  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试长期存活的对象进入老年代</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * VM参数：</span></span><br><span class="line"><span class="comment"> *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold=1 可选</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/11 18:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1KB = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * _1KB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1,allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">// 虽然此处赋值为null，但未进行Gc空间仍被占用，下一行代码会执行minor GC</span></span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将MaxTenuringThreshold设为1，可以看出第二次Minor GC时，年轻代已经被清空，allocation1对象因为年龄符合MaxTenuringThreshold设置的值，因此进入老年代。</span></span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><ul><li>为了能更好的适应不同程序的内存状态，虚拟机并不是永远的要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升老年代的</li><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li></ul><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><ul><li>内存分配是在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。</li><li>Parallel Scavenge收集器与其他收集器在空间分配担保上有一点差别, 正常是在Minor GC前进行检查, 而Parallel Scavenge收集器在Minor GC后也会进行检查。</li><li>另外当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/v123411739/article/details/78941793" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/78941793</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(二)垃圾回收器</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%BA%8C)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(二)垃圾回收器/</id>
    <published>2019-03-10T13:59:50.000Z</published>
    <updated>2019-03-26T13:22:03.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</li><li>Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的回收器可能会有很大差异，一般是提供参数供用户根据自己的应用特点和要求组合各个年代所使用的回收器</li><li>这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图3-5所示，上半部分是新生代的回收器，下半部分是老年代的回收器</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/hotspot.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><ul><li>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。</li><li>大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</li><li>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcj1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-Serial-Old-收集器"><a href="#2-Serial-Old-收集器" class="headerlink" title="2. Serial Old 收集器"></a>2. Serial Old 收集器</h3><ul><li>Serial收集器的老年代版本，它同样是一个单线程收集器。</li><li>它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</li></ul><h3 id="3-ParNew-收集器"><a href="#3-ParNew-收集器" class="headerlink" title="3. ParNew 收集器"></a>3. ParNew 收集器</h3><ul><li>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</li><li>并行和并发概念补充：<ul><li>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj2.jpg" alt=""></p><h3 id="4-Parallel-Old收集器"><a href="#4-Parallel-Old收集器" class="headerlink" title="4. Parallel Old收集器"></a>4. Parallel Old收集器</h3><ul><li>Parallel Scavenge收集器的老年代版本。</li><li>使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</li></ul><h3 id="5-Parallel-Scavenge收集器"><a href="#5-Parallel-Scavenge收集器" class="headerlink" title="5. Parallel Scavenge收集器"></a>5. Parallel Scavenge收集器</h3><ul><li>Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？</li><li><p>Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代并行</span><br></pre></td></tr></table></figure></li><li><p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</p></li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li></ul><p><img src="/images/server/java/JVM/gcj3.jpg" alt=""></p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><ul><li>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</li><li>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</li><li>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：<ul><li>初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li><li>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj4.jpg" alt=""></p><ul><li><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p><ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h3></li></ul></li><li><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p></li><li><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点</p><ul><li>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul></li><li>G1收集器的运作大致分为以下几个步骤：<ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul></li><li>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html</a></li><li><a href="https://blog.csdn.net/qq_34337272/article/details/82177383" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/82177383</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。&lt;/li&gt;
&lt;li&gt;Java虚拟机规范对垃圾回收器应该如
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(一)垃圾回收算法</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%B8%80)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(一)垃圾回收算法/</id>
    <published>2019-03-10T13:59:44.000Z</published>
    <updated>2019-03-26T13:15:38.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p></li><li><p>而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p></li></ul><h2 id="判断对象是否存活的算法"><a href="#判断对象是否存活的算法" class="headerlink" title="判断对象是否存活的算法"></a>判断对象是否存活的算法</h2><ul><li>垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧）</li></ul><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><p>一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><ul><li>通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcroots.JPEG" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li>上图中每个对象都存在引用链与GCRoots相连，表明对象还在，不能回收。有图中三个对象虽然互相引用，但是没有链接与GCRoots相连，则可判断它们是可回收的对象。<ul><li>什么对象可以为<code>GCRoots</code>，<ul><li>虚拟机栈中本地变量表引用的对象，局部变量</li><li>方法区中的类静态变量引用的对象及常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li></ul></li></ul><ul><li>彻底死亡条件：<ul><li>条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。</li><li>条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。</li></ul></li><li><p>引用</p><ul><li><p>强引用<code>Object o = new Object()</code></p></li><li><p>软引用<code>SoftReference</code> 定义了软引用对象之后，GC可达的算法就切断与此对象的连接，那么下次垃圾回收的时候就会优化回收此对象</p></li><li><p>弱引用</p></li><li><p>虚引用</p></li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>该算法是最基础的收集算法，算法分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象</p></li><li><p>之所以说它是最基础的算法是因为后续的算法都是基于这种思路并对其不足进行改进而得到的</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>效率不足</li><li>会产生大量不连续的内存碎片，碎片过多的话再分配一个较大对象时就无容身之地从而不得不提前触发另一次垃圾收集</li></ol><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>为了解决效率问题，此算法把内存划分为相等大小的两个区域，每一只使用其中一个，回收过程中将存活的对象全部复制到另一个区域中，清空原区域。在年轻代中eden区和两个survivor区就是使用了此种算法。这种算法只复制存活的对象，成本较低，而且不会出现内存碎片问题</p></li><li><p>现在的商业虚拟机都采用这种算法来回收新生代</p></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>费内存，需要2倍的内存空间</li></ol><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>该算法标记阶段和标记-清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。效率比“标记-清理”算法低，但不会产生内存碎片。</li></ul><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/aspirant/p/8662690.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8662690.html</a></li><li><a href="http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存溢出异常(一)OutOfMemoryError</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8(%E4%B8%80)OutOfMemoryError/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM内存溢出异常(一)OutOfMemoryError/</id>
    <published>2019-03-04T05:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.134Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有可能发生OutOfMemoryError（OOM）异常的可能，下面将介绍这些运行时区域出现OOM的场景及解决方法</p></blockquote><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><ul><li><p>Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制之后就会产生内存溢出异常</p></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java堆内存异常测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * VM参数：</span></span><br><span class="line"><span class="comment"> *      -Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * 堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/22 18:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Jvm4&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Jvm4());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid17684.hprof ...</span><br><span class="line">Heap dump file created [29356301 bytes in 0.114 secs]</span><br><span class="line">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:2245)</span><br><span class="line">at java.util.Arrays.copyOf(Arrays.java:2219)</span><br><span class="line">at java.util.ArrayList.grow(ArrayList.java:242)</span><br><span class="line">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216)</span><br><span class="line">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208)</span><br><span class="line">at java.util.ArrayList.add(ArrayList.java:440)</span><br><span class="line">at com.songsy.Jvm4.main(Jvm4.java:24)</span><br></pre></td></tr></table></figure></li><li><p>我们可以在vm参数中配置<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数，配置完成之后如果程序发生了<code>OutOfMemoryError</code>后会生成<code>堆转储快照</code>文件<code>java_pid17684.hprof</code></p></li><li><p>通过<code>JProfiler</code>打开此文件，发现都是<code>com.songsy.Jvm4.main</code>对象，原因是因为虚拟机限制了堆的最大空间(-Xmx20M)。当准备创建的对象需要的内存已经超过虚拟机堆所剩的空间。虚拟机会尝试通过<code>full GC</code>来回收内存，如果不行的话，就会抛出<code>OutOfMemoryError</code></p></li></ul><p><img src="/images/server/java/JVM/dump.jpg" alt=""></p><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><ul><li>由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。</li><li>关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：<ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<code>StackOverflowError</code>异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul></li><li>这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</li><li><p>测试代码：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 StackOverflowError异常</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/22 16:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</span></span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack length:<span class="number">11424</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line">at com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">13</span>)</span><br><span class="line">at com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">14</span>)</span><br><span class="line">at com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">14</span>)</span><br></pre></td></tr></table></figure><ul><li><p>测试代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 StackOverflowError异常</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/22 17:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JavaVMStackSOF1 oom = <span class="keyword">new</span> JavaVMStackSOF1();</span><br><span class="line">        <span class="keyword">long</span> e0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> e9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> q9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> r9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> t9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> y9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> u9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> i9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> o9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> p9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> a9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> s9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> d9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> f9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> g9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> h9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> j9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> k9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> l9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> z9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> c9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> v9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> b9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> n9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> m9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> qq9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww0 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww3 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww5 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww6 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww7 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww8 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> ww9 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p></li><li><p>如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常，如代码清单2-5所示。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p></li><li><p>其实原因不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</p></li></ul><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><ul><li><p>由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。</p></li><li><p><code>String.intern()</code>是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此<code>String</code>对象的字符串，则返回代表池中这个字符串的<code>String</code>对象；否则，将此<code>String</code>对象包含的字符串添加到常量池中，并且返回此<code>String</code>对象的引用。在<code>JDK 1.6</code>及之前的版本中，由于常量池分配在永久代内，我们可以通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>限制方法区大小，从而间接限制其中常量池的容量，如代码清单2-6所示。</p></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/22 17:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">            System.out.println(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: PermGen space  </span><br><span class="line">at java.lang.String.intern(Native Method)  </span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:<span class="number">18</span>)</span><br></pre></td></tr></table></figure></li><li><p>从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。</p></li><li><p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。在代码清单2-8中，笔者借助CGLib直接操作字节码运行时生成了大量的动态类。</p></li><li><p>值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中：当前的很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。另外，JVM上的动态语言（例如Groovy等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与代码清单2-8相似的溢出场景。</p></li><li><p>代码清单2-8　借助CGLib使方法区出现内存溢出异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/22 17:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.OutOfMemoryError: PermGen space  </span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)  </span><br><span class="line">at java.lang.ClassLoader.defineClassCond(ClassLoader.java:<span class="number">632</span>)  </span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">616</span>)  </span><br><span class="line">... <span class="number">8</span> more</span><br></pre></td></tr></table></figure></li><li><p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p></li></ul><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><ul><li><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p></li><li><p>特点</p><ul><li>本机直接内存的分配不会受到Java 堆大小的限制，受到本机总内存大小限制</li><li>直接内存也可以由 -XX:MaxDirectMemorySize 指定</li><li>直接内存申请空间耗费更高的性能</li><li>直接内存IO读写的性能要优于普通的堆内存</li></ul></li><li><p>当我们的需要频繁访问大的内存而不是申请和释放空间时，通过使用直接内存可以提高性能。</p></li><li><p>直接内存溢出测试，测试代码如下，运行时添加参数<code>-Xmx20M -XX:MaxDirectMemorySize=10M</code> 设置降低直接内存的空间来加快异常的抛出</p></li><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本机直接内存溢出</span></span><br><span class="line"><span class="comment"> * VM args:-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/22 18:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError</span><br><span class="line">at sun.misc.Unsafe.allocateMemory(Native Method)</span><br><span class="line">at com.songsy.DirectMemoryOOM.main(DirectMemoryOOM.java:<span class="number">22</span>)</span><br></pre></td></tr></table></figure></li><li><p>由DirectMemory导致的内存溢出，一个明显的特征就是再Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接的使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p></li></ul><h2 id="内存溢出及内存泄漏"><a href="#内存溢出及内存泄漏" class="headerlink" title="内存溢出及内存泄漏"></a>内存溢出及内存泄漏</h2><h3 id="1、内存溢出-out-of-memory"><a href="#1、内存溢出-out-of-memory" class="headerlink" title="1、内存溢出 out of memory"></a>1、内存溢出 out of memory</h3><ul><li>是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出</li></ul><h4 id="1-1-方法区溢出-out-of-memory-PermGen-space"><a href="#1-1-方法区溢出-out-of-memory-PermGen-space" class="headerlink" title="1.1 方法区溢出 out of memory: PermGen space"></a>1.1 方法区溢出 out of memory: PermGen space</h4><h4 id="1-2-本机直接内存溢出"><a href="#1-2-本机直接内存溢出" class="headerlink" title="1.2 本机直接内存溢出"></a>1.2 本机直接内存溢出</h4><h3 id="2、内存泄露-memory-leak"><a href="#2、内存泄露-memory-leak" class="headerlink" title="2、内存泄露 memory leak"></a>2、内存泄露 memory leak</h3><ul><li><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光</p></li><li><p>memory leak会最终会导致out of memory！</p></li><li><p>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 </p></li><li><p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. </p></li><li><p>从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到</p></li></ul><h3 id="3、引起内存溢出的原因"><a href="#3、引起内存溢出的原因" class="headerlink" title="3、引起内存溢出的原因"></a>3、引起内存溢出的原因</h3><ul><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>使用的第三方软件中的BUG；</li><li>启动参数内存值设定的过小；</li></ul><h3 id="4、内存溢出的解决方案"><a href="#4、内存溢出的解决方案" class="headerlink" title="4、内存溢出的解决方案"></a>4、内存溢出的解决方案</h3><ul><li>修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</li><li>检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</li><li>对代码进行走查和分析，找出可能发生内存溢出的位置。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p><ul><li>-Xmx3550m：设置JVM最大可用内存为3550M。</li><li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</li><li>-Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li></ul></blockquote><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/Sharley/p/5285045.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sharley/p/5285045.html</a></li><li><a href="https://blog.csdn.net/u012552052/article/details/44204735" target="_blank" rel="noopener">https://blog.csdn.net/u012552052/article/details/44204735</a></li><li><a href="https://blog.csdn.net/sells2012/article/details/18656263" target="_blank" rel="noopener">https://blog.csdn.net/sells2012/article/details/18656263</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有可能发生OutOfMemoryError（OOM）异常的可能，下面将介绍这些运行时区域出现OOM的场景及解决方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(六)方法区</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E5%85%AD)%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(六)方法区/</id>
    <published>2019-03-04T05:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。</p></li><li><p>对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。</p></li><li><p>Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出<br>OutOfMemoryError 异常。</p></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ul><li><p>运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p></li><li><p>Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规<em> 定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、</em> 装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的<em> 提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除</em> 了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常* 量池中。</p></li><li><p>运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语<em> 言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容</em> 才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发* 人员利用得比较多的便是String 类的intern() 方法。</p></li><li><p>既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无* 法再申请到内存时会抛出OutOfMemoryError 异常 </p></li></ul><h2 id="额外"><a href="#额外" class="headerlink" title="额外"></a>额外</h2><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(五)堆</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%BA%94)%E5%A0%86/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(五)堆/</id>
    <published>2019-03-04T04:59:44.000Z</published>
    <updated>2019-03-26T12:52:09.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。</p></li><li><p>对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p></li><li><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。</p></li><li><p>根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></li><li><p>所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代和永久代，</p></li></ul><h3 id="1-新生代"><a href="#1-新生代" class="headerlink" title="1. 新生代"></a>1. 新生代</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/eden.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>新创建的对象都是用新生代分配内存</li><li><p>新生代又被进一步划分为Eden和Survivor区，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区，而Survivor由FromSpace和ToSpace组成。</p><ul><li>Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。</li><li>ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。</li><li>ServivorTo：保留了一次MinorGC过程中的幸存者。</li></ul></li><li><p>MinorGC的过程：MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。</p></li><li><p>新生代分为Eden、FromSpace、ToSpace是为了尽量让对象在新生代MinorGC，如果到了老年代之后MajorGC执行时间长</p></li></ul><h3 id="2-老年代"><a href="#2-老年代" class="headerlink" title="2. 老年代"></a>2. 老年代</h3><ul><li><p>老年代用于存放经过多次Minor GC之后依然存活的对象。</p></li><li><p>老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。</p></li><li><p>MajorGC采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。</p></li><li><p>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p></li></ul><h3 id="3-永久代"><a href="#3-永久代" class="headerlink" title="3. 永久代"></a>3. 永久代</h3><ul><li><p>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域. 它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。</p></li><li><p>在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p></li><li><p>空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制.</p></li><li><p>采用元空间而不用永久代的几点原因：</p><ul><li>1、为了解决永久代的OOM问题，元数据和class对象存在永久代中，容易出现性能问题和内存溢出。</li><li>2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出（因为堆空间有限，此消彼长）。</li><li>3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>4、Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc-generation.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>-Xmx20M -XX:MaxHeapSize简写，表示设置堆容量的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免堆自动扩展，减少程序运行时的垃圾回收次数，从而提供性能。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高<h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2></li><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/Sharley/p/5285045.html" target="_blank" rel="noopener">https://www.cnblogs.com/Sharley/p/5285045.html</a></li><li><a href="https://www.cnblogs.com/ygj0930/p/6522828.html" target="_blank" rel="noopener">https://www.cnblogs.com/ygj0930/p/6522828.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(四)本地方法栈</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E5%9B%9B)%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(四)本地方法栈/</id>
    <published>2019-03-04T03:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h2 id="Native-Method"><a href="#Native-Method" class="headerlink" title="Native Method"></a>Native Method</h2><ul><li><p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数</p></li><li><p>例如 <code>Object.java</code> 类下就有很多<code>Native Method</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></li><li><p>本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。</p></li><li><p>为什么要使用Native Method</p><ul><li>与java环境外交互：有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。</li><li>与操作系统交互：JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li><li>Sun’s Java： Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/qq_28885149/article/details/52672475" target="_blank" rel="noopener">https://blog.csdn.net/qq_28885149/article/details/52672475</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Jav
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(三)Java虚拟机栈</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%B8%89)Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(三)Java虚拟机栈/</id>
    <published>2019-03-04T02:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为虚拟机栈"><a href="#何为虚拟机栈" class="headerlink" title="何为虚拟机栈"></a>何为虚拟机栈</h2><ul><li><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p></li><li><p>与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。</p></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示： </li></ul><p><img src="/images/server/java/JVM/stackFrame.jpg" alt=""></p><h3 id="栈帧数据结构"><a href="#栈帧数据结构" class="headerlink" title="栈帧数据结构"></a>栈帧数据结构</h3><ul><li><p>每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中</p></li><li><p>我们先来理解一下虚拟机是如何执行一个方法的，这样我们才能理解为什么栈帧需要这些部分，这些部分分别提供了什么功能。首先我们的方法被编译成了字节码，并生成了可执行的命令。通过程序计数器，虚拟机会一行一行的执行命令，直到进入一个新的方法入口，对应虚拟机栈也就是新的栈帧入栈，当前栈帧改变，又或者遇到返回指令或出现异常结束了方法，对应虚拟机也就是出栈。</p></li></ul><h4 id="1、局部变量表"><a href="#1、局部变量表" class="headerlink" title="1、局部变量表"></a>1、局部变量表</h4><ul><li>是一片逻辑连续的内存空间，最小单位是Slot，用来存放方法参数和方法内部定义的局部变量</li></ul><h4 id="2、操作数栈"><a href="#2、操作数栈" class="headerlink" title="2、操作数栈"></a>2、操作数栈</h4><ul><li><p>每个栈帧都包含一个被叫做操作数栈的后进先出的栈。叫操作栈，或者操作数栈。</p></li><li><p>栈桢刚创建时，里面的操作数栈是空的。</p></li><li><p>Java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据、实例的字段等数据入栈。</p></li><li><p>同时也有指令来支持出栈操作。</p></li><li><p>向其他方法传参的参数，也存在操作数栈中。</p></li><li><p>其他方法返回的结果，返回时存在操作数栈中。</p></li></ul><h4 id="3、动态链接"><a href="#3、动态链接" class="headerlink" title="3、动态链接"></a>3、动态链接</h4><ul><li><p>一个方法调用另一个方法，或者一个类使用另一个类的成员变量时，总得知道被调用者的名字吧？(你可以不认识它本身，但调用它就需要知道他的名字)。符号引用就相当于名字，这些被调用者的名字就存放在Java字节码文件里。名字是知道了，但是Java真正运行起来的时候，真的能靠这个名字（符号引用）就能找到相应的类和方法吗？需要解析成相应的直接引用，利用直接引用来准确地找到。</p></li><li><p>举个例子，就相当于我在0X0300H这个地址存入了一个数526，为了方便编程，我把这个给这个地址起了个别名叫A, 以后我编程的时候(运行之前)可以用别名A来暗示访问这个空间的数据，但其实程序运行起来后，实质上还是去寻找0X0300H这片空间来获取526这个数据的。</p></li><li><p>这样的符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。</p><h4 id="4、方法返回地址"><a href="#4、方法返回地址" class="headerlink" title="4、方法返回地址"></a>4、方法返回地址</h4></li><li><p>返回一个值给调用它的方法，方法正常完成发生在一个方法执行过程 中遇到了方法返回的字节码指令（§2.11.8）的时候，使用哪种返回指令取决于方法返回值的数 据类型（如果有返回值的话）。</p></li></ul><h4 id="5、附加信息"><a href="#5、附加信息" class="headerlink" title="5、附加信息"></a>5、附加信息</h4><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/ychenfeng/article/details/77247807" target="_blank" rel="noopener">https://blog.csdn.net/ychenfeng/article/details/77247807</a></li><li><a href="https://blog.csdn.net/u014296316/article/details/82668670" target="_blank" rel="noopener">https://blog.csdn.net/u014296316/article/details/82668670</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;何为虚拟机栈&quot;&gt;&lt;a href=&quot;#何为虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;何为虚拟机栈&quot;&gt;&lt;/a&gt;何为虚拟机栈&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域(二)程序计数器</title>
    <link href="http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F(%E4%BA%8C)%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(二)程序计数器/</id>
    <published>2019-03-04T01:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的<code>行号指示器</code>，在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>线程私有的</li><li>是java虚拟机规范里面， 唯一 一个 没有规定任何 <code>OutOfMemoryError</code> 情况的区域</li><li>生命周期随着线程，线程启动而产生，线程结束而消亡</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>程序计数器，可以看做是当前线程执行的字节码的 行号指示器 ，这句话；要理解这句话，需要先知道字节码文件长什么样子，看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 文件被翻译为字节码的时候，字节码大概类似于下面的样子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 原来的 haha 方法内部的 java 代码，被翻译为下面的类似于汇编语言的指令</span></span><br><span class="line">    <span class="number">0</span> xxxx ....</span><br><span class="line">    <span class="number">2</span> xxxx ....</span><br><span class="line">    <span class="number">4</span> xx  ...</span><br><span class="line">    <span class="number">5</span> xxx ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面左边的 0、2、4、5 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的</p></li><li><p>理解了程序计数器，就好理解它的这些特点了；我们都知道，Java是支持多线程的，当CPU执行权从 A 线程，转移到 B 线程的时候，JVM就要暂时挂起线程 A ，去执行线程 B ；当线程 A 再次得到CPU执行权的时候，又会挂起B线程，继续执行 A 线程 ；</p></li><li><p>我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？</p></li><li><p>答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）；</p></li><li><p>那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，<code>程序计数器的内存空间是线程私有的</code> ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！</p></li><li><p>那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被<code>创建</code>；</p></li><li><p>程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，<code>jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域</code>；</p></li><li><p>当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 ；</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/youngyouth/article/details/79868299" target="_blank" rel="noopener">https://blog.csdn.net/youngyouth/article/details/79868299</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的&lt;code&gt;行号指示器&lt;/code&gt;，在虚拟机的概念模型里（仅仅是概念模
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
</feed>
