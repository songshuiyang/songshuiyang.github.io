<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋水阳个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.songshuiyang.com/"/>
  <updated>2019-08-03T02:56:23.227Z</updated>
  <id>http://www.songshuiyang.com/</id>
  
  <author>
    <name>songshuiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot(五)内嵌Tomcat启动原理解析</title>
    <link href="http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(%E4%BA%94)%E5%86%85%E5%B5%8CTomcat%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(五)内嵌Tomcat启动原理解析/</id>
    <published>2019-08-05T16:00:05.000Z</published>
    <updated>2019-08-03T02:56:23.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>我们知道在使用<code>Spring Boot</code>项目的时候可以不用依赖外部<code>Tomcat</code>就可以启动，那么<code>Spring Boot</code>是怎么做到的呢？其实就是只需要引入<code>spring-boot-starter-web</code>，在应用启动时会自动启动嵌入版的<code>tomcat</code>作为应用服务器，下面我们来学习下其实现原理。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h4 id="TomcatEmbeddedServletContainerFactory-自动配置"><a href="#TomcatEmbeddedServletContainerFactory-自动配置" class="headerlink" title="TomcatEmbeddedServletContainerFactory 自动配置"></a>TomcatEmbeddedServletContainerFactory 自动配置</h4><ul><li><p>嵌入版的<code>tomcat</code>起作用的关键是<code>TomcatEmbeddedServletContainerFactory</code>，下面将讲解该类的注册</p></li><li><p>第四章节已经介绍了自动配置的实现，查看<code>spring-boot-autoconfigure</code>模块的<code>META-INF/spring.factories</code>文件，关注<code>EmbeddedServletContainerAutoConfiguration</code>这个配置类，看类名可以翻译为嵌入式的<code>Servlet</code>容器自动配置类，所以以后如果想知道其他功能是怎么被集成进来的，可以在<code>spring.factories</code>中找找对应的自动配置类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">... </span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line"> ...</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* 进入`EmbeddedServletContainerAutoConfiguration.java`，可以看到使用不同的`<span class="meta">@Conditional</span>`注解可以针对不同的环境情况选择是否注册该`Bean`，下面根据条件会注册不同的`Servlet`容器</span><br><span class="line">    * 注册`Tomcat`容器工厂</span><br><span class="line">    * 注册`Jetty`容器工厂</span><br><span class="line">    * 注册其他容器工厂</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 嵌入式的`Servlet`容器自动配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> EnableAutoConfiguration Auto-configuration&#125; for an embedded servlet containers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ivan Sopov</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stephane Nicoll</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">// 注解表明只有在web环境下才会创建容器相关信息，因此应用无需容器则使用</span></span><br><span class="line"><span class="meta">@Import</span>(BeanPostProcessorsRegistrar.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册Tomcat容器工厂</span></span><br><span class="line"><span class="comment"> * 由于存在<span class="doctag">@ConditionalOnMissingBean</span>注解，因此优先使用用户自定义的EmbeddedServletContainerFactory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Nested configuration if Tomcat is being used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Tomcat.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">tomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册Jetty容器工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Nested configuration if Jetty is being used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Server.class, Loader.class,</span><br><span class="line">WebAppContext.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedJetty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JettyEmbeddedServletContainerFactory <span class="title">jettyEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JettyEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册其他容器工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Nested configuration if Undertow is being used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedUndertow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="title">undertowEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> UndertowEmbeddedServletContainerFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Registers a &#123;<span class="doctag">@link</span> EmbeddedServletContainerCustomizerBeanPostProcessor&#125;. Registered</span></span><br><span class="line"><span class="comment"> * via &#123;<span class="doctag">@link</span> ImportBeanDefinitionRegistrar&#125; for early registration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanPostProcessorsRegistrar</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ConfigurableListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = (ConfigurableListableBeanFactory) beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">registerSyntheticBeanIfMissing(registry,</span><br><span class="line"><span class="string">"embeddedServletContainerCustomizerBeanPostProcessor"</span>,</span><br><span class="line">EmbeddedServletContainerCustomizerBeanPostProcessor.class);</span><br><span class="line">registerSyntheticBeanIfMissing(registry,</span><br><span class="line"><span class="string">"errorPageRegistrarBeanPostProcessor"</span>,</span><br><span class="line">ErrorPageRegistrarBeanPostProcessor.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerSyntheticBeanIfMissing</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">String name, Class&lt;?&gt; beanClass)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ObjectUtils.isEmpty(</span><br><span class="line"><span class="keyword">this</span>.beanFactory.getBeanNamesForType(beanClass, <span class="keyword">true</span>, <span class="keyword">false</span>))) &#123;</span><br><span class="line">RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(beanClass);</span><br><span class="line">beanDefinition.setSynthetic(<span class="keyword">true</span>);</span><br><span class="line">registry.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们这里关注<code>TomcatEmbeddedServletContainerFactory</code>类，下面是类继承关系图：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-boot/TomcatEmbeddedServletContainerFactory.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>TomcatEmbeddedServletContainerFactory</code>类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatEmbeddedServletContainerFactory</span> <span class="keyword">extends</span> <span class="title">AbstractEmbeddedServletContainerFactory</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; NO_CLASSES = Collections.emptySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of default protocol used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PROTOCOL = <span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> File baseDirectory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Valve&gt; engineValves = <span class="keyword">new</span> ArrayList&lt;Valve&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Valve&gt; contextValves = <span class="keyword">new</span> ArrayList&lt;Valve&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;LifecycleListener&gt; contextLifecycleListeners = <span class="keyword">new</span> ArrayList&lt;LifecycleListener&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;TomcatContextCustomizer&gt; tomcatContextCustomizers = <span class="keyword">new</span> ArrayList&lt;TomcatContextCustomizer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;TomcatConnectorCustomizer&gt; tomcatConnectorCustomizers = <span class="keyword">new</span> ArrayList&lt;TomcatConnectorCustomizer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Connector&gt; additionalTomcatConnectors = <span class="keyword">new</span> ArrayList&lt;Connector&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String protocol = DEFAULT_PROTOCOL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; tldSkipPatterns = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(</span><br><span class="line">TldSkipPatterns.DEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Charset uriEncoding = DEFAULT_CHARSET;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> backgroundProcessorDelay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> TomcatEmbeddedServletContainerFactory&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> TomcatEmbeddedServletContainerFactory&#125; that listens for</span></span><br><span class="line"><span class="comment"> * requests using the specified port.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port the port to listen on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatEmbeddedServletContainerFactory</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> TomcatEmbeddedServletContainerFactory&#125; with the specified</span></span><br><span class="line"><span class="comment"> * context path and port.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> contextPath the root context path</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port the port to listen on</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatEmbeddedServletContainerFactory</span><span class="params">(String contextPath, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(contextPath, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取EmbeddedServletContainer</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initializers &#123;<span class="doctag">@link</span> ServletContextInitializer&#125;s that should be applied as</span></span><br><span class="line"><span class="comment"> * the container starts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 构建Tomcat实例</span></span><br><span class="line">Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line"><span class="comment">// 配置Tomcat的基本环境</span></span><br><span class="line">File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">: createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">tomcat.getService().addConnector(connector);</span><br><span class="line">customizeConnector(connector);</span><br><span class="line">tomcat.setConnector(connector);</span><br><span class="line">tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">configureEngine(tomcat.getEngine());</span><br><span class="line"><span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">&#125;</span><br><span class="line">prepareContext(tomcat.getHost(), initializers);</span><br><span class="line"><span class="comment">// 将配置好的Tomcat传入进去。返回一个EmbeddedServletContainer 并且启动tomcat容器</span></span><br><span class="line"><span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p><code>TomcatEmbeddedServletContainerFactory</code>类，这个类是创建<code>Tomcat</code>容器的工厂类，可以看到这个类实现了<code>EmbeddedServletContainerFactory</code>接口</p><ul><li><p>查看<code>EmbeddedServletContainerFactory</code>接口，该接口只有一个方法，该方法用于获取<code>Servlet</code>容器（<code>EmbeddedServletContainer</code>）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            ServletContextInitializer... initializers)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>TomcatEmbeddedServletContainerFactory</code>类实现了<code>getEmbeddedServletContainer()</code>方法，可以看到<code>Tomcat tomcat = new Tomcat()</code>是创建了一个汤姆猫，然后构造为<code>EmbeddedServletContainer</code>对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取EmbeddedServletContainer</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initializers &#123;<span class="doctag">@link</span> ServletContextInitializer&#125;s that should be applied as</span></span><br><span class="line"><span class="comment"> * the container starts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建Tomcat实例</span></span><br><span class="line">    Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    <span class="comment">// 配置Tomcat的基本环境</span></span><br><span class="line">    File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">            : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">    tomcat.getService().addConnector(connector);</span><br><span class="line">    customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">    tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">    configureEngine(tomcat.getEngine());</span><br><span class="line">    <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">        tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">    &#125;</span><br><span class="line">    prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    <span class="comment">// 将配置好的Tomcat传入进去。返回一个EmbeddedServletContainer 并且启动tomcat容器</span></span><br><span class="line">    <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>EmbeddedServletContainer</code>接口，该接口是<code>Servlet</code>容器的抽象，可以看到有三个方法，<code>start()</code> <code>stop()</code> <code>getPort();</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动容器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Starts the embedded servlet container. Calling this method on an already started</span></span><br><span class="line"><span class="comment">     * container has no effect.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> EmbeddedServletContainerException if the container cannot be started</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> EmbeddedServletContainerException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止容器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Stops the embedded servlet container. Calling this method on an already stopped</span></span><br><span class="line"><span class="comment">     * container has no effect.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> EmbeddedServletContainerException if the container cannot be stopped</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> EmbeddedServletContainerException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取服务端口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return the port this server is listening on.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the port (or -1 if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下图是显示了<code>Spring Boot</code>定义了哪些容器</p><ul><li><code>UndertowEmbeddedServletContainer</code> (org.springframework.boot.context.embedded.undertow)</li><li><code>MockEmbeddedServletContainer</code> (org.springframework.boot.context.embedded)</li><li><code>TomcatEmbeddedServletContainer</code> (org.springframework.boot.context.embedded.tomcat)</li><li><code>JettyEmbeddedServletContainer</code> (org.springframework.boot.context.embedded.jetty)</li></ul></li></ul></li><li><code>EmbeddedServletContainer.java</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-boot/EmbeddedServletContainer.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>到这里<code>TomcatEmbeddedServletContainerFactory</code>已经自动注册完成了，使用<code>@Conditional</code>相关注解可以控制只有在web环境下才会创建容器相关信息，有了容器的创建工厂之后就可以使用<code>Servlet</code>容器了<code>EmbeddedServletContainer</code></li></ul><h4 id="TomcatEmbeddedServletContainer-创建及使用"><a href="#TomcatEmbeddedServletContainer-创建及使用" class="headerlink" title="TomcatEmbeddedServletContainer 创建及使用"></a>TomcatEmbeddedServletContainer 创建及使用</h4><ul><li><code>TomcatEmbeddedServletContainer</code>的创建是由<code>TomcatEmbeddedServletContainerFactory</code>类来实现的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatEmbeddedServletContainer</span> <span class="keyword">implements</span> <span class="title">EmbeddedServletContainer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(TomcatEmbeddedServletContainer.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger containerCounter = <span class="keyword">new</span> AtomicInteger(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object monitor = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Service, Connector[]&gt; serviceConnectors = <span class="keyword">new</span> HashMap&lt;Service, Connector[]&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tomcat猫</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Tomcat tomcat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> autoStart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> TomcatEmbeddedServletContainer&#125; instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tomcat the underlying Tomcat server</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatEmbeddedServletContainer</span><span class="params">(Tomcat tomcat)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(tomcat, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> TomcatEmbeddedServletContainer&#125; instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tomcat the underlying Tomcat server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> autoStart if the server should be started</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TomcatEmbeddedServletContainer</span><span class="params">(Tomcat tomcat, <span class="keyword">boolean</span> autoStart)</span> </span>&#123;</span><br><span class="line">Assert.notNull(tomcat, <span class="string">"Tomcat Server must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.tomcat = tomcat;</span><br><span class="line"><span class="keyword">this</span>.autoStart = autoStart;</span><br><span class="line"><span class="comment">// 启动容器</span></span><br><span class="line">initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> EmbeddedServletContainerException </span>&#123;</span><br><span class="line">TomcatEmbeddedServletContainer.logger</span><br><span class="line">.info(<span class="string">"Tomcat initialized with port(s): "</span> + getPortsDescription(<span class="keyword">false</span>));</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.monitor) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">addInstanceIdToEngineName();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Remove service connectors to that protocol binding doesn't happen</span></span><br><span class="line"><span class="comment">// yet</span></span><br><span class="line">removeServiceConnectors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the server to trigger initialization listeners</span></span><br><span class="line"><span class="comment">// 启动 Tomcat</span></span><br><span class="line"><span class="keyword">this</span>.tomcat.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can re-throw failure exception directly in the main thread</span></span><br><span class="line">rethrowDeferredStartupExceptions();</span><br><span class="line"></span><br><span class="line">Context context = findContext();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ContextBindings.bindClassLoader(context, getNamingToken(context),</span><br><span class="line">getClass().getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NamingException ex) &#123;</span><br><span class="line"><span class="comment">// Naming is not enabled. Continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span></span><br><span class="line"><span class="comment">// blocking non-daemon to stop immediate shutdown</span></span><br><span class="line">startDaemonAwaitThread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">containerCounter.decrementAndGet();</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> EmbeddedServletContainerException(</span><br><span class="line"><span class="string">"Unable to start embedded Tomcat"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们知道在使用&lt;code&gt;Spring Boot&lt;/code&gt;项目的时候可以不用依赖外部&lt;code&gt;Tomcat&lt;/code&gt;就
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.songshuiyang.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(四)@EnableAutoConfiguration自动配置</title>
    <link href="http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(%E5%9B%9B)@EnableAutoConfiguration%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(四)@EnableAutoConfiguration自动配置/</id>
    <published>2019-08-05T16:00:04.000Z</published>
    <updated>2019-08-03T02:56:23.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>SpringBoot</code>到底是怎么做到自动配置的？从代码里看项目<code>SpringBoot</code>的项目启动类只有一个注解<code>@SpringBootApplication</code>和一个<code>run</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTomcatJspApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> application.sources(SampleTomcatJspApplication.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SpringApplication.run(SampleTomcatJspApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>查看<code>@SpringBootApplication</code>注解<ul><li><code>@Inherited</code><ul><li><code>java.lang.annotation.@Inherited</code> 注解，使用此注解声明出来的自定义注解，在使用此自定义注解时，如果注解在类上面时，子类会自动继承此注解，否则的话，子类不会继承此注解。这里一定要记住，使用<code>@Inherited</code> 声明出来的注解，只有在类上使用时才会有效，对方法，属性等其他无效。</li></ul></li><li><code>@SpringBootConfiguration</code><ul><li>标记这是一个 <code>Spring Boot</code> 配置类， 它上面继承自 <code>@Configuration</code> 注解，所以两者功能也一致，可以将当前类内声明的一个或多个以 <code>@Bean</code> 注解标记的方法的实例纳入到 <code>Spring</code> 容器中，并且实例名就是方法名。</li></ul></li><li><code>@EnableAutoConfiguration</code><ul><li>用于开启自动配置功能，是 <code>spring-boot-autoconfigure</code> 项目最核心的注解</li></ul></li><li><code>@ComponentScan</code><ul><li>扫描指定路径下的 <code>Component（@Componment、@Configuration、@Service）</code></li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line"><span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class, attribute = <span class="string">"exclude"</span>)</span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration.class, attribute = <span class="string">"excludeName"</span>)</span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackages"</span>)</span><br><span class="line">String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AliasFor</span>(annotation = ComponentScan.class, attribute = <span class="string">"basePackageClasses"</span>)</span><br><span class="line">Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这么多注解我们这里关注<code>@EnableAutoConfiguration</code>注解，可以看到是使用了<code>@Import(EnableAutoConfigurationImportSelector.class)</code>注解，</p></li><li><p><code>@Import</code>用来导入一个或多个类（会被<code>Spring</code>容器管理），或者配置类（配置类里的<code>@Bean</code>标记的类也会被<code>Spring</code>容器管理），有了这个注解我们可以通过添加注解的形式来注册<code>Bean</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">// 主要功能自动配置包，它会获取主程序类所在的包路径，并将包路径（包括子包）下的所有组件注册到 Spring IOC 容器中。</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment"> * applied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看<code>EnableAutoConfigurationImportSelector.class</code>的继承关系图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-boot/EnableAutoConfigurationImportSelector.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>上面的图可以看到<code>EnableAutoConfigurationImportSelector</code>类是实现了<code>ImportSelectors</code>接口</p><ul><li><p>实现了<code>ImportSelectors</code>接口的类通常与常规的<code>@Import</code>注解作用相同，然而，它也可能被延迟处理，直到所有被<code>@Configuration</code>标记的类处理完之后采取处理</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ImportSelector</code>接口的<code>selectImports</code>返回的数组（类的全类名）都会被注册到<code>Spring</code>容器中，所以可以通过这个方法来自定义注册哪些<code>bean</code></p></li><li><p>我们来看它是实现这个接口的，可以看到主体逻辑是调用<code>getCandidateConfigurations(annotationMetadata, attributes);</code>获取了<code>list</code>，然后进行去重、排序、筛选排除</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">// 获取META-INF/spring.factories配置的类名</span></span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// 筛选排除</span></span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>getCandidateConfigurations(annotationMetadata, attributes)</code>方法，从下面的方法可以看到是读取了<code>META-INF/spring.factories</code>的配置，这个文件配置了哪些类需要被注册为<code>Bean</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations,</span><br><span class="line">            <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                    + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">        ArrayList result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = (URL)urls.nextElement();</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">            String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">            result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var8) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load ["</span> + factoryClass.getName() + <span class="string">"] factories from location ["</span> + <span class="string">"META-INF/spring.factories"</span> + <span class="string">"]"</span>, var8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看<code>spring-boot-autoconfigure</code>模块的<code>META-INF/spring.factories</code>文件</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取到了哪些<code>Bean</code>需要自动配置，我们来看下是哪里调用了，下图是这个方法的调用链</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-boot/autoConfiguration.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>由上面的调用链可以看到容器执行了<code>refresh()</code>时触发的，这个方法在之前<code>Spring</code>系列有过介绍，现在来回顾一下</p><ul><li><p>进入<code>refresh()</code>方法，可以看到是执行了<code>invokeBeanFactoryPostProcessors(beanFactory)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开</span></span><br><span class="line">        <span class="comment">// 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 子类覆盖方法做额外的处理</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，</span></span><br><span class="line">            <span class="comment">// 并调用其postProcessBeanFactory接口方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li><li><p>可以看到是执行了工厂后处理器，根据反射机制从<code>BeanDefinitionRegistry</code>中找出所有实现了<code>BeanFactoryPostProcessor</code>接口的<code>bean</code>，查看<code>invokeBeanDefinitionRegistryPostProcessors()</code>方法是执行了<code>BeanDefinitionRegistryPostProcessor</code>接口<code>postProcessBeanDefinitionRegistry(registry)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanDefinitionRegistryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Collection&lt;? extends BeanDefinitionRegistryPostProcessor&gt; postProcessors, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">postProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>BeanDefinitionRegistryPostProcessor</code>接口继承了<code>BeanFactoryPostProcessor</code>接口，这里是执行实现了<code>BeanDefinitionRegistryPostProcessor</code>接口<code>Bean</code>的<code>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</code>方法，用于注册<code>bean</code></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2></li></ul></li><li>使用<code>@Configuration</code>注解的类<code>MyConfig</code>与启动类<code>Application</code>如果不在同一包下,才需要配置<code>spring.factories</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>Spring Boot</code>实现自动配置是通过<code>@EnableAutoConfiguration</code>来实现的，<code>Spring Boot</code> 在启动时扫描项目所依赖的 <code>jar</code> 包，寻找包含<code>spring.factories</code> 文件的 <code>jar</code> 包。</li><li>根据 <code>spring.factories</code> 配置加载 <code>AutoConfigure</code> 类。</li><li>根据 <code>@Conditional</code> 等条件注解 的条件，进行自动配置并将 <code>Bean</code> 注入 <code>Spring IoC</code> 中。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SpringBoot&lt;/code&gt;到底是怎么做到自动配置的？从代码里看项目&lt;code&gt;SpringBoot&lt;/cod
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.songshuiyang.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(三)下载源码及SpringApplication</title>
    <link href="http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(%E4%B8%89)%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E5%8F%8ASpringApplication/"/>
    <id>http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(三)下载源码及SpringApplication/</id>
    <published>2019-08-05T16:00:03.000Z</published>
    <updated>2019-08-03T02:56:23.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>要研究<code>Spring Boot</code> 就需要下载它的源码，传送门：<code>https://github.com/spring-projects/spring-boot</code></li></ul><h4 id="导入Spring-Boot-源码"><a href="#导入Spring-Boot-源码" class="headerlink" title="导入Spring Boot 源码"></a>导入<code>Spring Boot</code> 源码</h4><ul><li>这里是选用了<code>spring-boot-1.5.6.RELEASE</code>版本与之前的<code>spring-framework-4.3.10.RELEASE</code>是相对应的，下面是目录结构</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-boot/Springboot.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>下载后执行<code>clean install  -Dmaven.test.skip=true</code>命令，然而并不是那么顺利，直接运行会报错，和<code>spring-framework-4.3.10.RELEASE</code>的源码的编译一样还是要改文件才能正常编译</p><ul><li><p>注释下面的依赖，不然会报找不到的错</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot&lt;/artifactId&gt;</span><br><span class="line">&lt;type&gt;test-jar&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>注释根<code>pom</code>不必要的模块，不然报错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>spring-boot-test-autoconfigure<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注释根<code>pom</code>不必要的插件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">       &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;maven-checkstyle-plugin&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;2.17&lt;/version&gt;</span><br><span class="line">       &lt;dependencies&gt;</span><br><span class="line">           &lt;dependency&gt;</span><br><span class="line">               &lt;groupId&gt;com.puppycrawl.tools&lt;/groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;checkstyle&lt;/artifactId&gt;</span><br><span class="line">               &lt;version&gt;7.1.1&lt;/version&gt;</span><br><span class="line">           &lt;/dependency&gt;</span><br><span class="line">       &lt;/dependencies&gt;</span><br><span class="line">   &lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li><li><p>注释<code>spring-boot-tools</code>模块下的<code>pom.xml</code>的模块，不然报错</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>spring-boot-gradle-plugin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注释插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将一些报错模块测试包<code>Mark Directory as</code> -&gt; <code>Excluded</code>，也可以直接干掉</p></li></ul></li><li><p>编译通过之后就可以在本地调<code>spring-boot-samples</code>目录下的示例代码了</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></li><li><p>查看<code>Spring Boot</code>的示例代码</p><ul><li>使用 <code>@SpringBootApplication</code> 注解，标明是 <code>Spring Boot</code> 应用。通过它，可以开启自动配置的功能。</li><li>调用 <code>SpringApplication#run(Class&lt;?&gt;... primarySources)</code> 方法，启动 <code>Spring Boot</code> 应用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleTomcatJspApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> application.sources(SampleTomcatJspApplication.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SpringApplication.run(SampleTomcatJspApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h4><ul><li>跟进<code>SpringApplication.run(SampleTomcatJspApplication.class, args)</code>方法，可以看到是调用了<code>SpringApplication</code>的静态方法，最终是创建 <code>SpringApplication</code> 对象并执行<code>public ConfigurableApplicationContext run(String... args)</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object source, String... args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> run(<span class="keyword">new</span> Object[] &#123; source &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Object[] sources, String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建 SpringApplication 对象，并执行运行。</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(sources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>org.springframework.boot.SpringApplication#run(java.lang.String...)</code>方法，可以看到主要逻辑也是构造<code>ApplicationContext</code>容器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the Spring application, creating and refreshing a new</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the application arguments (usually passed from a Java main method)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a running &#123;<span class="doctag">@link</span> ApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  创建 StopWatch 对象，并启动。StopWatch 主要用于简单统计 run 启动过程的时长。</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 配置 headless 属性，这个逻辑，可以无视，和 AWT 相关。</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 获得 SpringApplicationRunListener 的数组，并启动监听</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建  ApplicationArguments 对象</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 application.properties 和外部的属性配置。</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="comment">// 打印 Spring Banner</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">// 创建 Spring 容器。</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">        <span class="comment">// 主要是调用所有初始化类的 initialize 方法</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 初始化 Spring 容器。</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">// 执行 Spring 容器的初始化的后置逻辑</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 通知 SpringApplicationRunListener 的数组，Spring 容器启动完成</span></span><br><span class="line">        listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 停止 StopWatch 统计时长</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">                    .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span></span><br><span class="line">        handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Print-Banner"><a href="#Print-Banner" class="headerlink" title="Print Banner"></a>Print Banner</h4><ul><li><p><code>Banner printedBanner = printBanner(environment);</code>用于打印<code>Spring</code>，也可以自己添加<code>banner.txt</code>修改打印</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  '  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::</span><br></pre></td></tr></table></figure></li><li><p>进入<code>printBanner(environment)</code>方法可以看到是构造了一个<code>SpringApplicationBannerPrinter</code>对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Banner <span class="title">printBanner</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Banner.Mode.OFF) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.resourceLoader</span><br><span class="line">            : <span class="keyword">new</span> DefaultResourceLoader(getClassLoader());</span><br><span class="line">    <span class="comment">// 构造SpringApplicationBannerPrinter</span></span><br><span class="line">    SpringApplicationBannerPrinter bannerPrinter = <span class="keyword">new</span> SpringApplicationBannerPrinter(</span><br><span class="line">            resourceLoader, <span class="keyword">this</span>.banner);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.bannerMode == Mode.LOG) &#123;</span><br><span class="line">        <span class="comment">// 打印在log file中</span></span><br><span class="line">        <span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, logger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bannerPrinter.print(environment, <span class="keyword">this</span>.mainApplicationClass, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查看<code>SpringApplicationBannerPrinter</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationBannerPrinter</span> </span>&#123;</span><br><span class="line"><span class="comment">// 配置该属性用于配置自定义banner的位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BANNER_LOCATION_PROPERTY = <span class="string">"banner.location"</span>;</span><br><span class="line"><span class="comment">// 图片BANNER_IMAGE?</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BANNER_IMAGE_LOCATION_PROPERTY = <span class="string">"banner.image.location"</span>;</span><br><span class="line"><span class="comment">// 默认banner的存放位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_BANNER_LOCATION = <span class="string">"banner.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] IMAGE_EXTENSION = &#123; <span class="string">"gif"</span>, <span class="string">"jpg"</span>, <span class="string">"png"</span> &#125;;</span><br><span class="line"><span class="comment">// 默认打印处理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Banner DEFAULT_BANNER = <span class="keyword">new</span> SpringBootBanner();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Banner fallbackBanner;</span><br><span class="line"></span><br><span class="line">SpringApplicationBannerPrinter(ResourceLoader resourceLoader, Banner fallbackBanner) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line"><span class="keyword">this</span>.fallbackBanner = fallbackBanner;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><code>SpringBootBanner</code>默认打印处理类，可以看到是直接拼接了一个字符数组然后<code>for</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default Banner implementation which writes the 'Spring' banner.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringBootBanner</span> <span class="keyword">implements</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BANNER = &#123; <span class="string">""</span>,</span><br><span class="line"><span class="string">"  .   ____          _            __ _ _"</span>,</span><br><span class="line"><span class="string">" /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\"</span>,</span><br><span class="line"><span class="string">"( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\"</span>,</span><br><span class="line"><span class="string">" \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )"</span>,</span><br><span class="line"><span class="string">"  '  |____| .__|_| |_|_| |_\\__, | / / / /"</span>,</span><br><span class="line"><span class="string">" =========|_|==============|___/=/_/_/_/"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_BOOT = <span class="string">" :: Spring Boot :: "</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRAP_LINE_SIZE = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printBanner</span><span class="params">(Environment environment, Class&lt;?&gt; sourceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">PrintStream printStream)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 循环打印</span></span><br><span class="line"><span class="keyword">for</span> (String line : BANNER) &#123;</span><br><span class="line">printStream.println(line);</span><br><span class="line">&#125;</span><br><span class="line">String version = SpringBootVersion.getVersion();</span><br><span class="line">version = (version == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">" (v"</span> + version + <span class="string">")"</span>);</span><br><span class="line">String padding = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">while</span> (padding.length() &lt; STRAP_LINE_SIZE</span><br><span class="line">- (version.length() + SPRING_BOOT.length())) &#123;</span><br><span class="line">padding += <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT,</span><br><span class="line">AnsiColor.DEFAULT, padding, AnsiStyle.FAINT, version));</span><br><span class="line">printStream.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Create-ApplicationContext"><a href="#Create-ApplicationContext" class="headerlink" title="Create ApplicationContext"></a>Create ApplicationContext</h4><ul><li><code>context = createApplicationContext();</code>用于创建<code>ApplicationContext</code>，不同环境会创建不同的<ul><li>非web环境构造<code>AnnotationConfigApplicationContext</code></li><li>web环境构造<code>AnnotationConfigEmbeddedWebApplicationContext</code></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非web环境构造的application context</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for non-web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="string">"org.springframework.context."</span></span><br><span class="line">        + <span class="string">"annotation.AnnotationConfigApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * web环境构造的application context</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_WEB_CONTEXT_CLASS = <span class="string">"org.springframework."</span></span><br><span class="line">        + <span class="string">"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 webApplicationType 类型，获得 ApplicationContext 类型</span></span><br><span class="line">    Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">    <span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            contextClass = Class.forName(<span class="keyword">this</span>.webEnvironment</span><br><span class="line">                    ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Unable create a default ApplicationContext, "</span></span><br><span class="line">                            + <span class="string">"please specify an ApplicationContextClass"</span>,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 ApplicationContext 对象</span></span><br><span class="line">    <span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Refresh-ApplicationContext"><a href="#Refresh-ApplicationContext" class="headerlink" title="Refresh ApplicationContext"></a>Refresh ApplicationContext</h4><ul><li><code>refreshContext(context);</code>用于初始化 Spring 容器，可以看到主要逻辑也是调用<code>ApplicationContext</code>的<code>refresh()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开启（刷新）Spring 容器</span></span><br><span class="line">    refresh(context);</span><br><span class="line">    <span class="comment">// 注册 ShutdownHook 钩子</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">    ((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Call-Runners"><a href="#Call-Runners" class="headerlink" title="Call Runners"></a>Call Runners</h4><ul><li><p><code>afterRefresh(context, applicationArguments);</code>用于执行 Spring 容器的初始化后的后置逻辑，可以看到是执行了<code>ApplicationRunner</code>及<code>CommandLineRunner</code>接口的<code>run</code>方法，如果你想在<code>Spring Boot</code>容器构造完成之后额外做一些事情，可以实现这两个接口来定义</p><ul><li><p><code>ApplicationRunner</code>中<code>run</code>方法的参数为<code>ApplicationArguments</code></p><ul><li>示例代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(value = <span class="number">10</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentApplicationRun2</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments applicationArguments)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>CommandLineRunner</code>接口中<code>run</code>方法的参数为<code>String</code>数组。想要更详细地获取命令行参数，那就使用<code>ApplicationRunner</code>接口</p><ul><li>示例代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Component</span></span><br><span class="line">        <span class="meta">@Order</span>(value = <span class="number">11</span>)</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentApplicationRun</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ```      </span><br><span class="line">* `ApplicationRunner `</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRefresh</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">    callRunners(context, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得所有 Runner</span></span><br><span class="line">    List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">    <span class="comment">// 获得所有 ApplicationRunner Bean</span></span><br><span class="line">    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">    <span class="comment">// 获得所有 CommandLineRunner Bean</span></span><br><span class="line">    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">    <span class="comment">// 排序 runners</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">    <span class="comment">// 遍历 Runner 数组，执行逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;Object&gt;(runners)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">            callRunner((ApplicationRunner) runner, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">            callRunner((CommandLineRunner) runner, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li><li><a href="https://blog.csdn.net/weixin_38362455/article/details/83023025" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38362455/article/details/83023025</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;要研究&lt;code&gt;Spring Boot&lt;/code&gt; 就需要下载它的源码，传送门：&lt;code&gt;https://github.c
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.songshuiyang.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(二)构建及配置SpringBoot项目</title>
    <link href="http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(%E4%BA%8C)%E6%9E%84%E5%BB%BA%E5%8F%8A%E9%85%8D%E7%BD%AESpringBoot%E9%A1%B9%E7%9B%AE/"/>
    <id>http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(二)构建及配置SpringBoot项目/</id>
    <published>2019-08-05T16:00:01.000Z</published>
    <updated>2019-08-03T02:56:23.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集成Spring-boot"><a href="#集成Spring-boot" class="headerlink" title="集成Spring boot"></a>集成Spring boot</h3><ul><li><p>构建<code>SpringBoot</code>项目，先配置<code>Maven</code>配置，下面有两种方式</p><ul><li><p>方式一</p><ul><li>集成<code>Spring Boot</code>时，官方示例中，都是让我们继承一个<code>Spring</code>的 <code>spring-boot-starter-parent</code> 这个<code>parent</code>，这样就集成了<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式二</p><ul><li><p>一般情况下，在我们自己的项目中，会定义一下自己的<code>Maven parent</code> 项目，这种情况下，上面的这种做法就行不通了。那么，该如何来做呢？其实，在<code>Spring</code>的官网也给出了变通的方法的，在我们自己 <code>parent</code> 项目中，加下下面的声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>请注意，它的 <code>type</code>是<code>pom</code>，<code>scope</code> 是<code>import</code>，这种类型的 <code>dependency</code> 只能在 <code>dependencyManagement</code> 标签中声明，然后，把我们项目中的 子项目 中，<code>parent</code> 的声明，修改为我们自己项目的<code>parent</code> 项目就可以了，比如，我的是： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">          <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.songsy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">        ``` </span><br><span class="line">* 然后新增一个启动类及配置文件`application.properties`就完成了一个`Boot`项目的构建</span><br><span class="line">```java</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SampleTomcatJspApplication extends SpringBootServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;</span><br><span class="line">return application.sources(SampleTomcatJspApplication.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">SpringApplication.run(SampleTomcatJspApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="不同环境不同配置文件"><a href="#不同环境不同配置文件" class="headerlink" title="不同环境不同配置文件"></a>不同环境不同配置文件</h3><ol><li><p>针对各环境新建不同的配置文件 <code>application-dev.properties、application-test.properties、application-prod.properties</code> , 在这三个文件均都设置不同的<code>server.port</code>属性，如：<code>dev</code>环境设置为<code>8080</code>，<code>test</code>环境设置为<code>9090</code>，<code>prod</code>环境设置为<code>80</code></p></li><li><p><code>application.properties</code>中设置<code>spring.profiles.active=dev</code>，就是说默认以dev环境设置</p></li><li><p>采用命令行的形式 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行java -jar xxx.jar，可以观察到服务端口被设置为8080，也就是默认的开发环境（dev）</span><br><span class="line"></span><br><span class="line">执行java -jar xxx.jar <span class="comment">--spring.profiles.active=test，可以观察到服务端口被设置为9090，也就是测试环境的配置（test）</span></span><br><span class="line"></span><br><span class="line">执行java -jar xxx.jar <span class="comment">--spring.profiles.active=prod，可以观察到服务端口被设置为80，也就是生产环境的配置（prod）</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="打包-Spring-Boot-项目"><a href="#打包-Spring-Boot-项目" class="headerlink" title="打包 Spring Boot 项目"></a>打包 Spring Boot 项目</h3><ul><li>引入 <code>spring-boot-maven-plugin</code> 插件，执行 <code>mvn clean package</code> 命令，将 <code>Spring Boot</code> 项目打成一个 <code>Fat Jar</code> 。后续，我们就可以直接使用 <code>java -jar</code> 运行。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;useSystemClassLoader&gt;false&lt;/useSystemClassLoader&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h3 id="数据文件的加载顺序"><a href="#数据文件的加载顺序" class="headerlink" title="数据文件的加载顺序"></a>数据文件的加载顺序</h3><ol><li>在命令行中传入的参数</li><li>SPRING_APPLICATION_JSON: 以JSON格式配置在系统环境变量中的内容</li><li>java:comp/env 的JNDI属性</li><li>Java的系统属性，可以通过System.getProperties()</li><li>操作系统的环境变量</li><li>通过 random.* 配置的随机属性</li><li>位当前jar之外，针对不同{profile}环境的配置文件内容, application-{profile}.yml</li><li>位当前jar之内，针对不同{profile}环境的配置文件内容, application-{profile}.yml</li><li>位当前jar之外，application.yml</li><li>位当前jar之内，application.yml</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li><li>详见： <a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-maven-without-a-parent" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-maven-without-a-parent</a></li><li>参考： <a href="https://blog.csdn.net/rainbow702/article/details/55046298" target="_blank" rel="noopener">https://blog.csdn.net/rainbow702/article/details/55046298</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;集成Spring-boot&quot;&gt;&lt;a href=&quot;#集成Spring-boot&quot; class=&quot;headerlink&quot; title=&quot;集成Spring boot&quot;&gt;&lt;/a&gt;集成Spring boot&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;构建&lt;code&gt;SpringBoo
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.songshuiyang.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(一)前言</title>
    <link href="http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(%E4%B8%80)%E5%89%8D%E8%A8%80/"/>
    <id>http://www.songshuiyang.com/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(一)前言/</id>
    <published>2019-08-05T16:00:01.000Z</published>
    <updated>2019-08-03T02:56:23.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p><code>Spring Boot</code> 是 <code>Spring</code> 的子项目，正如其名字，提供 <code>Spring</code> 的引导<code>Boot</code>的功能。</p></li><li><p>通过 <code>Spring Boot</code> ，我们开发者可以快速配置 <code>Spring</code> 项目，引入各种 <code>Spring MVC、Spring Transaction、Spring AOP、MyBatis</code> 等等框架，而无需不断重复编写繁重的 <code>Spring</code> 配置，降低了 <code>Spring</code> 的使用成本。</p></li></ul><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h3><ul><li>独立运行的<code>Spring</code>项目,可以以<code>jar</code>包的形式独立运行, 运行一个<code>Spring boot</code>项目只要通过 <code>java -jar xx.jar</code></li><li>内嵌<code>Tomcat, Jetty, Undertow</code> 无需以war包形式部署项目</li><li>提供<code>starter</code>简化Maven配置</li><li>自动配置<code>Bean</code>, 极大的减少了我们要使用的配置</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>快速构建项目</li><li>对主流开发框架的无配置集成</li><li>项目可独立运行</li><li>提供运行时的应用监控</li></ol><h4 id="Starter-POMs"><a href="#Starter-POMs" class="headerlink" title="Starter POMs"></a>Starter POMs</h4><blockquote><p>Starter 主要用来简化依赖用的，Spring Boot 通过starter依赖为项目的依赖管理提供帮助.starter依赖起始就是特殊的maven依赖,利用了传递依赖解析,把常用库聚合在一起,组成了几个为特定功能而定制的依赖.</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/spring-boot/spring-boot-starter-web.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>所有的starters遵循一个相似的命名模式：spring-boot-starter-<em>，在这里</em>是一种特殊类型的应用程序。<br>eg:</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>spring-boot-starter</td><td>对自动配置、日志记录和YAML支持，核心starter</td></tr><tr><td>spring-boot-starter-thymeleaf</td><td>对Thymeleaf模板引擎的支持，Spring mvc的集成</td></tr><tr><td>spring-boot-starter-web</td><td>对web支持，包括RESTful，使用tomcat作为默认容器</td></tr><tr><td>spring-boot-starter-data-jpa</td><td>对jpa支持</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt; 是 &lt;code&gt;Spring&lt;/code&gt; 的子项目，正如其名字，提供 
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://www.songshuiyang.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(七四)Spring事务之Mybatis集成事务管理</title>
    <link href="http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%B8%83%E5%9B%9B)Spring%E4%BA%8B%E5%8A%A1%E4%B9%8BMybatis%E9%9B%86%E6%88%90%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring系列(七四)Spring事务之Mybatis集成事务管理/</id>
    <published>2019-08-04T16:00:04.000Z</published>
    <updated>2019-06-30T04:20:00.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>使用 <code>MyBatis-Spring</code> 的主要原因是它允许 <code>MyBatis</code> 参与到 <code>Spring</code> 的事务管理中。而 不是给 <code>MyBatis</code> 创建一个新的特定的事务管理器,<code>MyBatis-Spring</code> 利用了存在于 Spring 中的 <code>DataSourceTransactionManager</code>。</li></ul><h3 id="如何集成-Spring的事务管理"><a href="#如何集成-Spring的事务管理" class="headerlink" title="如何集成 Spring的事务管理"></a>如何集成 <code>Spring</code>的事务管理</h3><ul><li>配置 <code>DataSourceTransactionManager</code> Bean</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 基本属性 url、IUser、password --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;amp;characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"60000"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"60000"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"300000"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        用来检测连接是否有效的sql，要求是一个查询语句。</span></span><br><span class="line"><span class="comment">        如果validationQuery为null，testOnBorrow、testOnReturn、</span></span><br><span class="line"><span class="comment">        testWhileIdle都不会其作用</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1 FROM DUAL"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnReturn"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        打开PSCache，并且指定每个连接上PSCache的大小</span></span><br><span class="line"><span class="comment">        如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolPreparedStatementPerConnectionSize"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span> <span class="attr">value</span>=<span class="string">"stat,wall,log4j"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        如果配置了proxyFilters，此配置可以不配置</span></span><br><span class="line"><span class="comment">        druid.stat.mergeSql=true 合并执行的相同sql，避免因为参数不同而统计多条sql语句</span></span><br><span class="line"><span class="comment">        druid.stat.slowSqlMillis=10000 用来配置SQL慢的标准，执行时间超过slowSqlMillis的就是慢</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &lt;property name="connectionProperties" value="druid.stat.mergeSql=true;druid.stat.slowSqlMillis=10000" /&gt;</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 监控统计拦截的filters --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 并在filters属性中配置了log4j --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="proxyFilters"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;list&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;ref bean="stat-filter" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;ref bean="log-filter" /&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/list&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionProperties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>clientEncoding=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"org.springframework.iframe.entity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"org.springframework.iframe.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>要注意, 为事务管理器指定的 <code>DataSource</code> 必须和用来创建 <code>SqlSessionFactoryBean</code> 的 是同一个数据源,否则事务管理器就无法工作了。</p></li><li><p>一旦 <code>Spring</code> 的 <code>DataSourceTransactionManager</code> 配置好了,你可以在 <code>Spring</code> 中你可以使用<code>@Transactional</code> 注解来完成事物操作。在事务处理期间,一个单独的 <code>SqlSession</code> 对象（线程级别）将会被创建 和使用。当事务完成时,这个 <code>SqlSession</code> 会以合适的方式提交或回滚。相反如果没有开启事物那么<code>SqlSession</code> 对象就是方法级别的了，每次调用<code>Mapper</code>里的方法都会返回一个新的<code>SqlSession</code> 来处理，下面来看其内部是怎么实现的</p></li></ul><h3 id="事务实现解析"><a href="#事务实现解析" class="headerlink" title="事务实现解析"></a>事务实现解析</h3><ul><li><p>与<code>Spring</code>集成以后，<code>Spring</code>提供了一个全局唯一的<code>SqlSessionTemplate</code> 来完成<code>DefailtSqlSession</code>的功能</p></li><li><p>进入<code>SqlSessionTemplate</code> 可以看到里面有个<code>SqlSession</code> 属性，看属性名可以看出这里又用了动态代理，为什么又要代理呢？下面来看看</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqlSession代理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br></pre></td></tr></table></figure><ul><li>观察其构造方法，这里形成<code>SqlSession</code>代理类，再来看动态代理类<code>SqlSessionInterceptor</code>做了什么</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span></span><br><span class="line"><span class="function"><span class="params">     PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   notNull(sqlSessionFactory, <span class="string">"Property 'sqlSessionFactory' is required"</span>);</span><br><span class="line">   notNull(executorType, <span class="string">"Property 'executorType' is required"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">   <span class="keyword">this</span>.executorType = executorType;</span><br><span class="line">   <span class="keyword">this</span>.exceptionTranslator = exceptionTranslator;</span><br><span class="line">   <span class="comment">// 形成SqlSession代理类</span></span><br><span class="line">   <span class="keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">       SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">       <span class="keyword">new</span> Class[] &#123; SqlSession.class &#125;,</span><br><span class="line">       <span class="keyword">new</span> SqlSessionInterceptor());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>SqlSessionInterceptor</code>类，这个<code>SqlSession</code>代理类的出现是为了让<code>Spring</code> 来管理<code>SqlSession</code> 的，从而实现事务管理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession</span></span><br><span class="line"><span class="comment"> * Proxy needed to route MyBatis method calls to the proper SqlSession got</span></span><br><span class="line"><span class="comment"> * from Spring's Transaction Manager</span></span><br><span class="line"><span class="comment"> * It also unwraps exceptions thrown by &#123;<span class="doctag">@code</span> Method#invoke(Object, Object...)&#125; to</span></span><br><span class="line"><span class="comment"> * pass a &#123;<span class="doctag">@code</span> PersistenceException&#125; to the &#123;<span class="doctag">@code</span> PersistenceExceptionTranslator&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 获取SqlSession(这个SqlSession才是真正使用的，它不是线程安全的)</span></span><br><span class="line">    SqlSession sqlSession = getSqlSession(</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.executorType,</span><br><span class="line">        SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用真实SqlSession的方法</span></span><br><span class="line">      Object result = method.invoke(sqlSession, args);</span><br><span class="line">      <span class="comment">// 判断一下当前的sqlSession是否被Spring托管</span></span><br><span class="line">      <span class="keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory)) &#123;</span><br><span class="line">        <span class="comment">// force commit even on non-dirty sessions because some databases require</span></span><br><span class="line">        <span class="comment">// a commit/rollback before calling close()</span></span><br><span class="line">        <span class="comment">// 没有使用事务</span></span><br><span class="line">        sqlSession.commit(<span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      Throwable unwrapped = unwrapThrowable(t);</span><br><span class="line">      <span class="keyword">if</span> (SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator != <span class="keyword">null</span> &amp;&amp; unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">        <span class="comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span></span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">        sqlSession = <span class="keyword">null</span>;</span><br><span class="line">        Throwable translated = SqlSessionTemplate.<span class="keyword">this</span>.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);</span><br><span class="line">        <span class="keyword">if</span> (translated != <span class="keyword">null</span>) &#123;</span><br><span class="line">          unwrapped = translated;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> unwrapped;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1</span></span><br><span class="line">        closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>getSqlSession()</code>方法，这里是获取<code>SqlSession</code> 的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line">  notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder</span></span><br><span class="line">  SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">  SqlSession session = sessionHolder(executorType, holder);</span><br><span class="line">  <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果找不到，则根据执行类型构造一个新的sqlSession</span></span><br><span class="line">  LOGGER.debug(() -&gt; <span class="string">"Creating a new SqlSession"</span>);</span><br><span class="line">  session = sessionFactory.openSession(executorType);</span><br><span class="line"></span><br><span class="line">  registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关注<code>TransactionSynchronizationManager</code> 内部成员，这里使用<code>TreadLocal</code>记录事务的一些属性，用于应用扩展同步器的使用，在事务的开启，挂起，提交等各个点上回调应用的逻辑</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 应用代码随事务的声明周期绑定的对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// synchronizations-使用的同步器，用于应用扩展</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 事务的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 事务是否是只读</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 事务的隔离界别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 事务是否开启</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br></pre></td></tr></table></figure><ul><li>回到<code>SqlSessionInterceptor</code> 类<code>invoke</code>方法，这里有个if判断<code>if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {</code> 来判断是否开启了<code>Spring</code>事务，如果该<code>Session</code>未被<code>Spring</code>托管则自动<code>commit</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSqlSessionTransactional</span><span class="params">(SqlSession session, SqlSessionFactory sessionFactory)</span> </span>&#123;</span><br><span class="line">  notNull(session, NO_SQL_SESSION_SPECIFIED);</span><br><span class="line">  notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line"></span><br><span class="line">  SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (holder != <span class="keyword">null</span>) &amp;&amp; (holder.getSqlSession() == session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关注<code>invoke</code>方法的<code>finally</code>块的 <code>closeSqlSession()方法</code>，如果是开启了事务则没有执行<code>session.close();</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1</span></span><br><span class="line">      closeSqlSession(sqlSession, SqlSessionTemplate.<span class="keyword">this</span>.sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSqlSession</span><span class="params">(SqlSession session, SqlSessionFactory sessionFactory)</span> </span>&#123;</span><br><span class="line">  notNull(session, NO_SQL_SESSION_SPECIFIED);</span><br><span class="line">  notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);</span><br><span class="line"></span><br><span class="line">  SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line">  <span class="keyword">if</span> ((holder != <span class="keyword">null</span>) &amp;&amp; (holder.getSqlSession() == session)) &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">"Releasing transactional SqlSession ["</span> + session + <span class="string">"]"</span>);</span><br><span class="line">    <span class="comment">// 如果是开启了事务 SqlSession是没有被close的，所以方法体内使用的是一个SqlSession，当然一级缓存是生效的</span></span><br><span class="line">    holder.released();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGGER.debug(() -&gt; <span class="string">"Closing non transactional SqlSession ["</span> + session + <span class="string">"]"</span>);</span><br><span class="line">    session.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过上述代码可以得出如果开启了事务，同一事务中同一个<code>sqlSessionFactory</code>创建的唯一<code>sqlSession</code>，一个事务中使用的是同一个<code>sqlSession</code>，为什么要用同一个<code>sqlSession</code>呢，是为了使用同一个<code>connection (JDBC)</code></li><li>如果没有开启事务，调用一次<code>mapper</code>里的方法将会新建一个<code>sqlSession</code>来执行方法</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.mybatis.org/spring/zh/factorybean.html" target="_blank" rel="noopener">http://www.mybatis.org/spring/zh/factorybean.html</a></li><li><a href="https://www.cnblogs.com/daxin/p/3544188.html" target="_blank" rel="noopener">https://www.cnblogs.com/daxin/p/3544188.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;MyBatis-Spring&lt;/code&gt; 的主要原因是它允许 &lt;code&gt;MyBatis&lt;/code&gt; 参与
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(七三)Spring事务之PlatformTransactionManager</title>
    <link href="http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%B8%83%E4%B8%89)Spring%E4%BA%8B%E5%8A%A1%E4%B9%8BPlatformTransactionManager/"/>
    <id>http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring系列(七三)Spring事务之PlatformTransactionManager/</id>
    <published>2019-08-04T16:00:03.000Z</published>
    <updated>2019-06-29T16:16:46.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>Spring</code> 事务的管理，是通过 <code>org.springframework.transaction.PlatformTransactionManager</code> 进行管理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PlatformTransactionManager.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 </span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据情况，提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据情况，回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>PlatformTransactionManager</code> 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。<ul><li><code>#getTransaction(TransactionDefinition definition)</code><ul><li>根据事务定义 <code>TransactionDefinition</code> ，获得 <code>TransactionStatus</code></li><li>为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建</li><li>什么返回的是 <code>TransactionStatus</code> 对象？在 <code>TransactionStatus</code> 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等</li></ul></li><li><code>#commit(TransactionStatus status)</code><ul><li>根据 <code>TransactionStatus</code> 情况，提交事务</li><li>为什么根据 <code>TransactionStatus</code> 情况，进行提交？例如说，带<code>@Transactional</code> 注解的的 <code>A</code> 方法，会调用 <code>@Transactional</code> 注解的的 <code>B</code> 方法。<ul><li>在 <code>B</code> 方法结束调用后，会执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，此处事务是不能、也不会提交的。</li><li>而是在 <code>A</code> 方法结束调用后，执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，提交事务。</li></ul></li></ul></li><li><code>#rollback(TransactionStatus status)</code><ul><li>根据 <code>TransactionStatus</code> 情况，回滚事务</li><li>为什么根据 <code>TransactionStatus</code> 情况，进行回滚？原因同 <code>#commit(TransactionStatus status)</code> 方法。</li></ul></li></ul></li></ul><h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><ul><li>先来一张<code>PlatformTransactionManager</code>接口的子类图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/tx/transaction4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p><code>PlatformTransactionManager</code> 有抽象子类 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code> ，基于 模板方法模式实现事务整体逻辑的骨架，而抽象 <code>#doCommit(DefaultTransactionStatus status)、#doRollback(DefaultTransactionStatus status)</code> 等等方法，交由子类类来实现。</p></li><li><p>不同的数据持久层框架，会有其对应的 <code>PlatformTransactionManager</code> 实现类</p><ul><li><code>HibernateTransactionManager</code><ul><li>和<code>Hibernate5</code> 的事务管理做集成</li></ul></li><li><code>DataSourceTransactionManager</code><ul><li>和 <code>JDBC</code> 的事务管理做集成。所以，它也适用于 <code>MyBatis、Spring JDBC</code> 等等。</li><li>最常使用的</li></ul></li><li><code>JpaTransactionManager</code> <ul><li>和 <code>JPA</code> 的事务管理做集成</li></ul></li></ul></li></ul><h3 id="其他支持类"><a href="#其他支持类" class="headerlink" title="其他支持类"></a>其他支持类</h3><h5 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h5><ul><li><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 事务的传播行为</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 事务的隔离级别</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>; <span class="comment">// 事务的超时时间</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">// 事务的名字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>TransactionDefinition</code>继承关系图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/tx/TransactionDefinition.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>@Transactional</code> 注解的 <code>rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName</code> 属性貌似没体现出来？它们提现在 <code>TransactionDefinition</code> 的实现类 <code>RuleBasedTransactionAttribute</code>中。</li></ul><h5 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h5><ul><li><code>TransactionStatus</code> 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionStatus.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是新创建的事务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否有 Savepoint</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为只回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 flush 操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否事务已经完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>TransactionStatus</code>继承关系图</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/tx/TransactionStatus.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>为什么没有事务对象呢？在 <code>TransactionStatus</code> 的实现类 <code>DefaultTransactionStatus</code> 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li><li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？<ul><li>我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，才能且应该真正的提交事务。</li></ul></li><li>子类<ul><li><code>org.springframework.transaction.interceptor.TransactionAttribute</code><ul><li>支持定义返回异常回滚的事务定义接口</li></ul></li><li><code>org.springframework.transaction.interceptor.RuleBasedTransactionAttribute</code><ul><li>基于 <code>{@link RollbackRuleAttribute}</code> 的事务定义实现类</li><li>每个 <code>@Transactional</code> 注解的方法及每个<code>&lt;tx:method /&gt;``XML</code>的配置 都会被解析成此对象</li></ul></li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用 <code>Spring</code> 事务有什么优点？<ul><li>通过 <code>PlatformTransactionManager</code> ，为不同的数据层持久框架提供统一的 <code>API</code> ，无需关心到底是原生 <code>JDBC、Spring JDBC、JPA、Hibernate</code> 还是 <code>MyBatis</code> 。</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Spring&lt;/code&gt; 事务的管理，是通过 &lt;code&gt;org.springframework.transact
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(七二)Spring事务之具体执行过程</title>
    <link href="http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%B8%83%E4%BA%8C)Spring%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring系列(七二)Spring事务之具体执行过程/</id>
    <published>2019-08-04T16:00:02.000Z</published>
    <updated>2019-06-29T16:16:46.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>我们知道在<code>JDBC</code>中处理事务，都是通过<code>Connection</code>完成的，同一事务中所有的操作，都在使用同一个<code>Connection</code>对象，<code>Connection</code>的三个方法与事务有关，万变不离其宗，<code>Spring</code>的事务也是基于<code>JDBC</code>来实现的，那么<code>Spring</code>是怎么来写这些代码的呢，这就是本章要介绍的内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 设置是否为自动提交事务，如果true（默认值为true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，</span></span><br><span class="line">    <span class="comment">// 如果设置为false，那么相当于开启了事务了；con.setAutoCommit(false) 表示开启事务。</span></span><br><span class="line">    con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 提交事务     </span></span><br><span class="line">    con.commit(); </span><br><span class="line">&#125; <span class="keyword">catch</span>（） &#123;</span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    con.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上一章节介绍了<code>&lt;tx:annotation-driven&gt;</code>标签是开启事务的开关，配置了这个就可以使用注解<code>@Transactional</code>来开启事务了，下面通过一个例子看看<code>Spring</code>事务的执行过程</p></li><li><p>下面的<code>updateUserByRuntimeException()</code>方法添加了<code>@Transactional</code>注解，这个方法先是插入一条记录，然后再更新另一条记录，如果没有开启事务的话，会执行第一条<code>sql</code>语句，第二条<code>sql</code>语句不会执行</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.iframe.service.impl.UserServiceImpl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUserByRuntimeException</span> <span class="params">(IUser iUser)</span> <span class="keyword">throws</span> NullPointerException</span>&#123;</span><br><span class="line">    log.info(<span class="string">"开启事务"</span>);</span><br><span class="line">    <span class="keyword">if</span> (userMapper.insertSelective(iUser) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"运行时异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    IUser iUser2 = userMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">    iUser2.setAge(iUser2.getAge() + <span class="number">1</span>);</span><br><span class="line">    userMapper.updateByPrimaryKeySelective(iUser2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类及配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.iframe.test.transaction.TransactionTests</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassPathXmlApplicationContext xmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans/applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行时异常事务处理</span></span><br><span class="line"><span class="comment">     * 事务会回滚</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runtimeExceptionTransactionTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        UserService userService = xmlApplicationContext.getBean(UserService.class);</span><br><span class="line">        IUser iUser = <span class="keyword">new</span> IUser();</span><br><span class="line">        iUser.setUsername(<span class="string">"运行时异常 事务会回滚"</span>);</span><br><span class="line">        iUser.setAge(<span class="number">1</span>);</span><br><span class="line">        userService.updateUserByRuntimeException(iUser);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// beans/applicationContext.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                              http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ComponentScanBeanDefinitionParser--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"org.springframework.iframe.*"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"applicationContext-dao.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// beans/applicationContext-dao.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;amp;characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"60000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"60000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"300000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1 FROM DUAL"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnReturn"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolPreparedStatementPerConnectionSize"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span> <span class="attr">value</span>=<span class="string">"stat,wall,log4j"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionProperties"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>clientEncoding=UTF-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSession"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"BATCH"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"org.springframework.iframe.entity"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"org.springframework.iframe.mapper"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><ul><li>现在来执行测试类，执行<code>UserService userService = xmlApplicationContext.getBean(UserService.class);</code>见下图可以看到<code>userService</code>是<code>JdkDynamicAopProxy</code>对象，由此可以得到<code>Spring</code>事务是通过<code>AOP</code>来实现的，由<code>AOP</code>来完成事务方法的织入及执行</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/tx/transaction1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>进入<code>userService.updateUserByRuntimeException(iUser);</code>方法，会跳到<code>JdkDynamicAopProxy</code>类的<code>invoke()</code>方法，这些逻辑和我们之前介绍<code>AOP</code>章节的内容是一致的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of &#123;<span class="doctag">@code</span> InvocationHandler.invoke&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span></span><br><span class="line"><span class="comment"> * unless a hook method throws an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation invocation;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">    Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果被代理的目标对象要执行的方法是equal则执行JdkDynamicAopProxy（即代理对象的equal）方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">            <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果被代理的目标对象要执行的方法是hashCode则执行JdkDynamicAopProxy（即代理对象的hashCode）方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">            <span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">            <span class="keyword">return</span> hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">            <span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">            <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">                method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">            <span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">            <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">        <span class="comment">// in case it comes from a pool.</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetClass = target.getClass();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">        <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">        <span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">            <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">            <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            <span class="comment">// 如果没有发现任何拦截器那么直接调用切点方法</span></span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">            <span class="comment">// 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器</span></span><br><span class="line">            invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">            <span class="comment">// 执行拦截器链</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Massage return value if necessary.</span></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">            <span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">            <span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">                    <span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            <span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面要注意的是<code>List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</code>，获取当前方法的拦截器链，由下图可以看到这里得到的是<code>TransactionInterceptor</code>事务拦截器，是不是有些眉目了</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/tx/transaction2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>得到拦截器之后就是执行<code>invocation.proceed();</code>方法了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="comment">// 执行完所有增强后执行切点方法，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取下一个要执行的拦截器 沿着拦截器链执行</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        <span class="comment">// 对方法进行动态匹配，切点的匹配就在这里进行</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="comment">// 不匹配则跳过这个拦截器调用下一个</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">        <span class="comment">//  这是一个拦截器，直接调用它，将this作为参数传递以保证当前实例中调用链的执行</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)</code>方法执行拦截器的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.transaction.interceptor.TransactionInterceptor#invoke</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">    <span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">    <span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adapt to TransactionAspectSupport's invokeWithinTransaction...</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> InvocationCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行<code>invokeWithinTransaction()</code>进入到<code>TransactionInterceptor</code>的父类中<code>TransactionAspectSupport</code>，下面的方法可以说是<code>Spring</code>事务的核心代码了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * General delegate for around-advice-based subclasses, delegating to several other template</span></span><br><span class="line"><span class="comment"> * methods on this class. Able to handle &#123;<span class="doctag">@link</span> CallbackPreferringPlatformTransactionManager&#125;</span></span><br><span class="line"><span class="comment"> * as well as regular &#123;<span class="doctag">@link</span> PlatformTransactionManager&#125; implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method the Method being invoked</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetClass the target class that we're invoking the method on</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invocation the callback to use for proceeding with the target invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the return value of the method, if any</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable propagated from the target invocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the transaction attribute is null, the method is non-transactional.</span></span><br><span class="line">    <span class="comment">// 获取对应的事务属性</span></span><br><span class="line">    <span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">    <span class="comment">// 获取beanFactory中的transactionManager</span></span><br><span class="line">    <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line">    <span class="comment">// 构造方法唯一标识(service.UserServiceImpl.save)</span></span><br><span class="line">    <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明式事务处理</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line">        <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line">        <span class="comment">// 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作</span></span><br><span class="line">        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">        Object retVal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">            <span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">            <span class="comment">// 方法调用</span></span><br><span class="line">            retVal = invocation.proceedWithInvocation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// target invocation exception</span></span><br><span class="line">            <span class="comment">// 回滚事务 注意：只对RuntimeException回滚</span></span><br><span class="line">            completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除信息</span></span><br><span class="line">            cleanupTransactionInfo(txInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        commitTransactionAfterReturning(txInfo);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 编程式事务处理</span></span><br><span class="line">        <span class="comment">// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,</span><br><span class="line">                    <span class="keyword">new</span> TransactionCallback&lt;Object&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">                            TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> invocation.proceedWithInvocation();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line">                                    <span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line">                                    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="keyword">throw</span> <span class="keyword">new</span> ThrowableHolderException(ex);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">                                    <span class="keyword">return</span> <span class="keyword">new</span> ThrowableHolder(ex);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cleanupTransactionInfo(txInfo);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check result: It might indicate a Throwable to rethrow.</span></span><br><span class="line">            <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ThrowableHolder) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ((ThrowableHolder) result).getThrowable();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.getCause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的逻辑分为声明式事务处理及编程式事务处理，我们这里关注声明式事务处理，由上面可以看到主要逻辑分为下面几点，是不是有些上面<code>JDBC</code>事务代码的影子了<ul><li>1、创建事务</li><li>2、方法调用</li><li>3、如有异常回滚事务</li><li>4、提交事务</li></ul></li></ul><h4 id="1、创建事务"><a href="#1、创建事务" class="headerlink" title="1、创建事务"></a>1、创建事务</h4><ul><li><code>TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</code>这行代码是创建事务的逻辑，可以看到是封装了一个<code>TransactionInfo</code>对象，现在先进入<code>createTransactionIfNecessary()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.transaction.interceptor.TransactionAspectSupport#createTransactionIfNecessary</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionInfo <span class="title">createTransactionIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PlatformTransactionManager tm, TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no name specified, apply method identification as transaction name.</span></span><br><span class="line">    <span class="comment">// 如果没有名称指定则使用方法唯一标识，并使用DelegatingTransactionAttribute封装txAttr</span></span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; txAttr.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        txAttr = <span class="keyword">new</span> DelegatingTransactionAttribute(txAttr) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransactionStatus status = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 核心 获取TransactionStatus 这里有建立事务连接</span></span><br><span class="line">            status = tm.getTransaction(txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Skipping transactional joinpoint ["</span> + joinpointIdentification +</span><br><span class="line">                        <span class="string">"] because no transaction manager has been configured"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据指定的属性与status准备一个TransactionInfo</span></span><br><span class="line">    <span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关注<code>status = tm.getTransaction(txAttr);</code>方法，这里是建立事务连接关键</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    Object transaction = doGetTransaction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache debug flag to avoid repeated checks.</span></span><br><span class="line">    <span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (definition == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">        definition = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前线程是否存在事务，判断依据为当前线程记录的连接不为空且连接中(connectionHolder)中的transactionActive属性不为空</span></span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line">        <span class="comment">// 当前线程已经存在事务</span></span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line">    <span class="comment">// 事务超时设置验证</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">"Invalid transaction timeout"</span>, definition.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line">    <span class="comment">// 如果当前线程不存在事务，propagationBehavior声明为PROPAGATION_MANDATORY 抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                <span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// 需要新建事务</span></span><br><span class="line">        SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Creating new transaction with name ["</span> + definition.getName() + <span class="string">"]: "</span> + definition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">            DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">                    definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 构建transaction ，包括设置ConnectionHolder、隔离级别、timout</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            doBegin(transaction, definition);</span><br><span class="line">            <span class="comment">// 新同步事务的设置，针对与当前线程的设置，将事务信息记录在当前线程中</span></span><br><span class="line">            prepareSynchronization(status, definition);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create "empty" transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Custom isolation level specified but no actual transaction initiated; "</span> +</span><br><span class="line">                    <span class="string">"isolation level will effectively be ignored: "</span> + definition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>doBegin(transaction, definition);</code>方法，可以看到<code>Connection newCon = this.dataSource.getConnection();</code>这里获取了<code>JDBC</code>的<code>Connection</code>，然后就是通过<code>con.setAutoCommit(false);</code>来开启事务了，获取数据库连接之后就是通过<code>TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());</code>来将连接绑定到当前线程中（使用<code>ThreadLocal</code>来实现）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建transaction，包括设置ConnectionHolder、隔离级别、timeout</span></span><br><span class="line"><span class="comment"> * 如果是新连接，绑定到当前线程，这个函数已经开始尝试了对数据库连接的获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This implementation sets the isolation level but ignores the timeout.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取连接，当然并不是每次都获取新的连接，如果当前线程中ConnectionHolder已经存在，则不需要再次获取</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.getConnectionHolder() == <span class="keyword">null</span> ||</span><br><span class="line">                txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">            Connection newCon = <span class="keyword">this</span>.dataSource.getConnection();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Acquired Connection ["</span> + newCon + <span class="string">"] for JDBC transaction"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">        con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置隔离级别</span></span><br><span class="line">        Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">        txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,</span></span><br><span class="line">        <span class="comment">// so we don't want to do it unnecessarily (for example if we've explicitly</span></span><br><span class="line">        <span class="comment">// configured the connection pool to set it already).</span></span><br><span class="line">        <span class="comment">// 更改Connection自动提交设置，由Spring控制提交</span></span><br><span class="line">        <span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">            txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Switching JDBC Connection ["</span> + con + <span class="string">"] to manual commit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prepareTransactionalConnection(con, definition);</span><br><span class="line">        <span class="comment">// 设置判断当前线程是否存在事务的依据</span></span><br><span class="line">        txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">int</span> timeout = determineTimeout(definition);</span><br><span class="line">        <span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">            txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bind the connection holder to the thread.</span></span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            <span class="comment">// 将当前获取到的连接绑定到当前线程</span></span><br><span class="line">            TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">            DataSourceUtils.releaseConnection(con, <span class="keyword">this</span>.dataSource);</span><br><span class="line">            txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、方法调用"><a href="#2、方法调用" class="headerlink" title="2、方法调用"></a>2、方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">Object retVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">    <span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">    <span class="comment">// 方法调用</span></span><br><span class="line">    retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// target invocation exception</span></span><br><span class="line">    <span class="comment">// 回滚事务 注意：只对RuntimeException回滚</span></span><br><span class="line">    completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清除信息</span></span><br><span class="line">    cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br></pre></td></tr></table></figure><ul><li>上面获取了<code>TransactionInfo</code>之后就是来执行方法了，进入<code>invocation.proceedWithInvocation();</code>，可以看到又回到了上面的<code>org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction</code>的方法中，这里执行的是<code>invocation.proceed();</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(<span class="keyword">final</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// Work out the target class: may be &#123;@code null&#125;.</span></span><br><span class="line">    <span class="comment">// The TransactionAttributeSource should be passed the target class</span></span><br><span class="line">    <span class="comment">// as well as the method, which may be from an interface.</span></span><br><span class="line">    Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="keyword">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adapt to TransactionAspectSupport's invokeWithinTransaction...</span></span><br><span class="line">    <span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, <span class="keyword">new</span> InvocationCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>invocation.proceed();</code>方法，又回到了<code>ReflectiveMethodInvocation#proceed</code>方法，只不过现在是执行的<code>invokeJoinpoint();</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.ReflectiveMethodInvocation#proceed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="comment">// 执行完所有增强后执行切点方法，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取下一个要执行的拦截器 沿着拦截器链执行</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        <span class="comment">// 对方法进行动态匹配，切点的匹配就在这里进行</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="comment">// 不匹配则跳过这个拦截器调用下一个</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">        <span class="comment">//  这是一个拦截器，直接调用它，将this作为参数传递以保证当前实例中调用链的执行</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>invokeJoinpoint();</code>方法，下面的使用了反射(<code>method.invoke(target, args);</code>)执行了我们的<code>org.springframework.iframe.service.impl.UserServiceImpl#updateUserByRuntimeException</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeJoinpoint</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.target, <span class="keyword">this</span>.method, <span class="keyword">this</span>.arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(Object target, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用反射执行方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(method);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Invoked method threw a checked exception.</span></span><br><span class="line">        <span class="comment">// We must rethrow it. The client won't see the interceptor.</span></span><br><span class="line">        <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"AOP configuration seems to be invalid: tried calling method ["</span> +</span><br><span class="line">                method + <span class="string">"] on target ["</span> + target + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>org.springframework.iframe.service.impl.UserServiceImpl#updateUserByRuntimeException</code>方法，这里插入一条记录之后就抛出一个异常，之后的逻辑就是下面的了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUserByRuntimeException</span> <span class="params">(IUser iUser)</span> <span class="keyword">throws</span> NullPointerException</span>&#123;</span><br><span class="line">    log.info(<span class="string">"开启事务"</span>);</span><br><span class="line">    <span class="keyword">if</span> (userMapper.insertSelective(iUser) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"运行时异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    IUser iUser2 = userMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">    iUser2.setAge(iUser2.getAge() + <span class="number">1</span>);</span><br><span class="line">    userMapper.updateByPrimaryKeySelective(iUser2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、如有异常回滚事务"><a href="#3、如有异常回滚事务" class="headerlink" title="3、如有异常回滚事务"></a>3、如有异常回滚事务</h4><ul><li>上面的<code>throw new NullPointerException(&quot;运行时异常&quot;);</code>抛出了一个空指针异常，所以被我们下面的逻辑给<code>catch</code>到了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">Object retVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">    <span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">    <span class="comment">// 方法调用</span></span><br><span class="line">    retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// target invocation exception</span></span><br><span class="line">    <span class="comment">// 回滚事务 注意：只对RuntimeException回滚</span></span><br><span class="line">    completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清除信息</span></span><br><span class="line">    cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br></pre></td></tr></table></figure><ul><li>关注<code>completeTransactionAfterThrowing(txInfo, ex);</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.transaction.interceptor.TransactionAspectSupport#completeTransactionAfterThrowing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle a throwable, completing the transaction.</span></span><br><span class="line"><span class="comment"> * We may commit or roll back, depending on the configuration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> txInfo information about the current transaction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex throwable encountered</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">completeTransactionAfterThrowing</span><span class="params">(TransactionInfo txInfo, Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当抛出异常时首先判断当前是否存在事务，这是基础依据</span></span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() +</span><br><span class="line">                    <span class="string">"] after exception: "</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里判断是否回滚默认的依据是抛出的异常是否是 (ex instanceof RuntimeException || ex instanceof Error)，我们熟悉的Exception默认是不处理的</span></span><br><span class="line">        <span class="keyword">if</span> (txInfo.transactionAttribute.rollbackOn(ex)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 核心 根据TransactionStatus信息进行回滚处理</span></span><br><span class="line">                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by rollback exception"</span>, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by rollback error"</span>, ex);</span><br><span class="line">                <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不满足回滚条件即使抛出异常也同样会提交</span></span><br><span class="line">            <span class="comment">// We don't roll back on this exception.</span></span><br><span class="line">            <span class="comment">// Will still roll back if TransactionStatus.isRollbackOnly() is true.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">                ex2.initApplicationException(ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (RuntimeException ex2) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by commit exception"</span>, ex);</span><br><span class="line">                <span class="keyword">throw</span> ex2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">                logger.error(<span class="string">"Application exception overridden by commit error"</span>, ex);</span><br><span class="line">                <span class="keyword">throw</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>下面先判断当前是否存在事务，可以看到<code>Spring</code>的严谨，然后就是判断抛出的异常是否是<code>RuntimeException及Error</code>，之后就是<code>rollback</code></p><ul><li><p>判断抛出的异常是否是<code>RuntimeException及Error</code></p><ul><li>进入<code>txInfo.transactionAttribute.rollbackOn(ex)</code>方法一直进入直到看到下面的代码，可以看到这里的异常判断只处理了<code>RuntimeException及Error</code>异常，另一个编译型异常<code>Exception</code>是不处理的，这个在开发过程中需要特别注意<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...      </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollbackOn</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ex <span class="keyword">instanceof</span> RuntimeException || ex <span class="keyword">instanceof</span> Error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>rollback</code></p><ul><li>进入<code>txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());</code>方法之后一直进入直到进入下面的代码，可以看到这里使用<code>txObject.getConnectionHolder().getConnection();</code>获取了我们之前新建的<code>Connection</code>，得到之后就是执行<code>con.rollback();</code>方法了<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.jdbc.datasource.DataSourceTransactionManager#doRollback</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRollback</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Rolling back JDBC transaction on Connection ["</span> + con + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        con.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not roll back JDBC transaction"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="4、提交事务"><a href="#4、提交事务" class="headerlink" title="4、提交事务"></a>4、提交事务</h4><ul><li>上面可以知道如果有异常的话是执行<code>completeTransactionAfterThrowing(txInfo, ex);</code>方法进行事务回滚，然后抛异常之后的逻辑都不执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);</span><br><span class="line">Object retVal = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line">    <span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">    <span class="comment">// 方法调用</span></span><br><span class="line">    retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    <span class="comment">// target invocation exception</span></span><br><span class="line">    <span class="comment">// 回滚事务 注意：只对RuntimeException回滚</span></span><br><span class="line">    completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 清除信息</span></span><br><span class="line">    cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br></pre></td></tr></table></figure><ul><li>如果没有异常的话会执行<code>commitTransactionAfterReturning(txInfo);</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">commitTransactionAfterReturning</span><span class="params">(TransactionInfo txInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (txInfo != <span class="keyword">null</span> &amp;&amp; txInfo.hasTransaction()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Completing transaction for ["</span> + txInfo.getJoinpointIdentification() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入 org.springframework.transaction.support.AbstractPlatformTransactionManager#commit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">                <span class="string">"Transaction is already completed - do not call commit or rollback more than once per transaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line">    <span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Transactional code has requested rollback"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        processRollback(defStatus);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Global transaction is marked as rollback-only but transactional code requested commit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        processRollback(defStatus);</span><br><span class="line">        <span class="comment">// Throw UnexpectedRollbackException only at outermost transaction boundary</span></span><br><span class="line">        <span class="comment">// or if explicitly asked to.</span></span><br><span class="line">        <span class="keyword">if</span> (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">                    <span class="string">"Transaction rolled back because it has been marked as rollback-only"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事务提交</span></span><br><span class="line">    processCommit(defStatus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommit</span><span class="params">(DefaultTransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> beforeCompletionInvoked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 预留口子方法执行额外逻辑</span></span><br><span class="line">            prepareForCommit(status);</span><br><span class="line">            triggerBeforeCommit(status);</span><br><span class="line">            triggerBeforeCompletion(status);</span><br><span class="line">            </span><br><span class="line">            beforeCompletionInvoked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">boolean</span> globalRollbackOnly = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">                globalRollbackOnly = status.isGlobalRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Releasing transaction savepoint"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果存在保存点则清除保存点信息</span></span><br><span class="line">                status.releaseHeldSavepoint();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Initiating transaction commit"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果时独立事务直接提交</span></span><br><span class="line">                doCommit(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Throw UnexpectedRollbackException if we have a global rollback-only</span></span><br><span class="line">            <span class="comment">// marker but still didn't get a corresponding exception from commit.</span></span><br><span class="line">            <span class="keyword">if</span> (globalRollbackOnly) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line">                        <span class="string">"Transaction silently rolled back because it has been marked as rollback-only"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (UnexpectedRollbackException ex) &#123;</span><br><span class="line">            <span class="comment">// can only be caused by doCommit</span></span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TransactionException ex) &#123;</span><br><span class="line">            <span class="comment">// can only be caused by doCommit</span></span><br><span class="line">            <span class="keyword">if</span> (isRollbackOnCommitFailure()) &#123;</span><br><span class="line">                doRollbackOnCommitException(status, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beforeCompletionInvoked) &#123;</span><br><span class="line">                triggerBeforeCompletion(status);</span><br><span class="line">            &#125;</span><br><span class="line">            doRollbackOnCommitException(status, ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!beforeCompletionInvoked) &#123;</span><br><span class="line">                triggerBeforeCompletion(status);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 提交过程中出现异常则回滚</span></span><br><span class="line">            doRollbackOnCommitException(status, err);</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Trigger afterCommit callbacks, with an exception thrown there</span></span><br><span class="line">        <span class="comment">// propagated to callers but the transaction still considered as committed.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            triggerAfterCommit(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        cleanupAfterCompletion(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关注核心方法<code>doCommit(status);</code>这里是提交事务的关键，当然如果提交事务的时候发生了异常也会执行回滚操作，由下图可以看到<code>Spring</code>由那些类实现了此方法</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/tx/transaction3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>我们这里进入的是<code>org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit</code>方法，终于看到我们熟悉的<code>con.commit();</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">(DefaultTransactionStatus status)</span> </span>&#123;</span><br><span class="line">    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();</span><br><span class="line">    Connection con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Committing JDBC transaction on Connection ["</span> + con + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        con.commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TransactionSystemException(<span class="string">"Could not commit JDBC transaction"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在此<code>Spring</code>事务的执行完成!!!</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>为什么在 <code>Spring</code> 事务中不能切换数据源？<ul><li>在 Spring 的事务管理中所使用的数据库连接会和当前线程所绑定，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</li></ul></li><li></li><li><p>什么是事务的传播级别？分成哪些传播级别？</p><ul><li>事务的传播行为，指的是当前带有事务配置的方法，需要怎么处理事务。<ul><li>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</li><li>有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，而是 Spring 自身所定义的。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。</li></ul></li><li><p>在<code>TransactionDefinition</code> 接口中，定义了三类七种传播级别。代码如下</p><ul><li><p><code>TransactionDefinition.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionDefinition.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则创建一个新的事务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则以非事务的方式继续运行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则使用该事务。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 不支持当前事务的情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个新的事务。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则把当前事务挂起。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以非事务方式运行。</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========== 其他情况 ========== </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</span></span><br><span class="line"><span class="comment"> * 如果当前没有事务，则等价于 &#123;<span class="doctag">@link</span> TransactionDefinition#PROPAGATION_REQUIRED&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br></pre></td></tr></table></figure></li><li><p>分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 <code>PROPAGATION_REQUIRED</code> 传播级别。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul></li></ul></li><li>事务说白了就是“绑架”一个数据库连接，更改数据库的自动提交功能，使用手动提交机制。<code>Spring</code>把这一系列操作属性及数据库连接放到了<code>ThreadLocal</code>中，而<code>ThreadLocal</code>的<code>key</code>为“当前线程的值”，可以说一个线程一个连接一个事务`</li><li>声明式事务管理建立在<code>AOP</code>之上的，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务</li><li>默认情况下<code>Spring</code>中的事务处理只对<code>RuntimeException</code>运行时异常进行回滚，对<code>Exception</code>编译性异常不会进行回滚</li><li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 源码深度解析》</li><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我们知道在&lt;code&gt;JDBC&lt;/code&gt;中处理事务，都是通过&lt;code&gt;Connection&lt;/code&gt;完成的，同一事务中
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(七一)Spring事务之解析事务自定义标签</title>
    <link href="http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%B8%83%E4%B8%80)Spring%E4%BA%8B%E5%8A%A1%E4%B9%8B%E8%A7%A3%E6%9E%90%E4%BA%8B%E5%8A%A1%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/"/>
    <id>http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring系列(七一)Spring事务之解析事务自定义标签/</id>
    <published>2019-08-04T16:00:01.000Z</published>
    <updated>2019-06-30T06:10:26.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p><code>Spring</code>事务让我们从复杂的事务处理中得到解脱，使我们再不需要去处理获得连接、关闭连接、事务提交和回滚等操作，<code>Spring</code>事务分为声明式事务和编程式事务，其中编程式事务因为对代码入侵较大所以不被推荐使用，我们平常最常使用的是声明式事务也就是通过<code>@Transactional</code>注解的形式开启事务</p><ul><li><p>编程式事务</p><ul><li>示例代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务保存数据</span></span><br><span class="line"><span class="keyword">boolean</span> result = transactionTemplate.execute(<span class="keyword">new</span> TransactionCallback&lt;Boolean&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">doInTransaction</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TODO something</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); //手动开启事务回滚</span></span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>声明式事务</p><ul><li><p><code>xml</code>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>&lt;tx:annotation-driven&gt;</code>标签是开启声明式事务的开关，配置了这个就可以使用注解<code>@Transactional</code>来开启事务了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.iframe.service.impl.UserServiceImpl#updateUserByRuntimeException      </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUserByRuntimeException</span> <span class="params">(IUser iUser)</span> <span class="keyword">throws</span> NullPointerException</span>&#123;</span><br><span class="line">    log.info(<span class="string">"开启事务"</span>);</span><br><span class="line">    <span class="keyword">if</span> (userMapper.insertSelective(iUser) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"运行时异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    IUser iUser2 = userMapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">    iUser2.setAge(iUser2.getAge() + <span class="number">1</span>);</span><br><span class="line">    userMapper.updateByPrimaryKeySelective(iUser2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以用xml的方式配置那些方法需要加事务</p><ul><li><p><code>xml</code>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务通知属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义事务传播属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"edit*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"new*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"set*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"remove*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"change*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"check*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"load*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 配置事务切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"serviceOperation"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">expression</span>=<span class="string">"execution(* org.springframework.iframe.service.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"serviceOperation"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>从上面可以看到编程式事务需要配置哪些方法需要事务控制，比如<code>&lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;</code>配置的就是<code>insert</code>开头的方法会有事务控制，然后<code>aop:config</code>配置了事务切面，上面的配置是<code>org.springframework.iframe.service</code>包下方法名符合<code>insert*、update*</code>规则的方法会有事务控制</p></li></ul></li></ul></li></ul></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="声明式事务原理解析"><a href="#声明式事务原理解析" class="headerlink" title="声明式事务原理解析"></a>声明式事务原理解析</h3><ul><li>由上面介绍可以看到开启声明式事务的关键是<code>&lt;tx:annotation-driven&gt;</code>标签，由前些章节知识积累可以发现这个标签也是自定义标签，所以需要找到对应的<code>NamespaceHandler</code><ul><li>先查看<code>NamespaceHandler</code>的实现类<br><img src="/images/server/spring/analysis/tx/NamespaceHandler.png" alt=""></li><li>根据名称可以定位到<code>TxNamespaceHandler</code>，下面代码可以看到<tx:advice>标签的解析是给通过<code>TxAdviceBeanDefinitionParser</code>类进行解析，<tx:annotation-driven>标签的解析是通过<code>AnnotationDrivenBeanDefinitionParser</code>类进行解析<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TRANSACTION_MANAGER_ATTRIBUTE = <span class="string">"transaction-manager"</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = <span class="string">"transactionManager"</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getTransactionManagerName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?</span><br><span class="line">                element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对&lt;tx:advice/&gt;标签的解析</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"advice"</span>, <span class="keyword">new</span> TxAdviceBeanDefinitionParser());</span><br><span class="line">        <span class="comment">// 对&lt;tx:annotation-driven/&gt;标签的解析</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation-driven"</span>, <span class="keyword">new</span> AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"jta-transaction-manager"</span>, <span class="keyword">new</span> JtaTransactionManagerBeanDefinitionParser());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></tx:annotation-driven></tx:advice></li></ul></li></ul><h4 id="AnnotationDrivenBeanDefinitionParser"><a href="#AnnotationDrivenBeanDefinitionParser" class="headerlink" title="AnnotationDrivenBeanDefinitionParser"></a>AnnotationDrivenBeanDefinitionParser</h4><ul><li>进入<code>parse()</code>方法开始解析</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    registerTransactionalEventListenerFactory(parserContext);</span><br><span class="line">    String mode = element.getAttribute(<span class="string">"mode"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"aspectj"</span>.equals(mode)) &#123;</span><br><span class="line">        <span class="comment">// mode="aspectj"</span></span><br><span class="line">        registerTransactionAspect(element, parserContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mode="proxy"</span></span><br><span class="line">        <span class="comment">// 提供对aspectj方式进行事务切入的支持</span></span><br><span class="line">        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>我们这里是进入<code>AopAutoProxyConfigurer.configueAutoProxyCreator(element, parserContext);</code>方法，可以看到下面逻辑主要是注册了一些<code>bean</code>，这些<code>bean</code>支撑了整个事务功能，后面会详细说明</p><ul><li><code>InfrastructureAdvisorAutoProxyCreator</code></li><li><code>AnnotationTransactionAttributeSource</code></li><li><code>TransactionInterceptor</code></li><li><code>BeanFactoryTransactionAttributeSourceAdvisor</code></li></ul></li><li><p>进入<code>AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</code>方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Inner class to just introduce an AOP framework dependency when actually in proxy mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoProxyConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">configureAutoProxyCreator</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注册 InfrastructureAdvisorAutoProxyCreator bean 这个类继承了 BeanPostProcessor，这里实现了AOP代理对象的创建</span></span><br><span class="line">        AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line"></span><br><span class="line">        String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;</span><br><span class="line">        <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) &#123;</span><br><span class="line">            Object eleSource = parserContext.extractSource(element);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 AnnotationTransactionAttributeSource definition.</span></span><br><span class="line">            RootBeanDefinition sourceDef = <span class="keyword">new</span> RootBeanDefinition(</span><br><span class="line">                    <span class="string">"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"</span>);</span><br><span class="line">            sourceDef.setSource(eleSource);</span><br><span class="line">            sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">            <span class="comment">// 注册TransactionAttributeSource bean，并使用Spring中的定义规则生成beanname</span></span><br><span class="line">            String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 TransactionInterceptor definition.</span></span><br><span class="line">            RootBeanDefinition interceptorDef = <span class="keyword">new</span> RootBeanDefinition(TransactionInterceptor.class);</span><br><span class="line">            interceptorDef.setSource(eleSource);</span><br><span class="line">            interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &lt;tx:annotation-driven/&gt;标签在不指定transaction-manager属性的时候，会默认寻找id固定名为transactionManager的bean作为事务管理器</span></span><br><span class="line">            registerTransactionManager(element, interceptorDef);</span><br><span class="line">            interceptorDef.getPropertyValues().add(<span class="string">"transactionAttributeSource"</span>, <span class="keyword">new</span> RuntimeBeanReference(sourceName));</span><br><span class="line">            <span class="comment">// 注册TransactionInterceptor bean，</span></span><br><span class="line">            String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建 BeanFactoryTransactionAttributeSourceAdvisor definition.</span></span><br><span class="line">            RootBeanDefinition advisorDef = <span class="keyword">new</span> RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);</span><br><span class="line">            advisorDef.setSource(eleSource);</span><br><span class="line">            advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">            <span class="comment">// 将sourceName的bean注入advisorDef的transactionAttributeSource属性中</span></span><br><span class="line">            <span class="comment">// 并将前两个BeanDefinition添加到第三个BeanDefinition的属性当中</span></span><br><span class="line">            advisorDef.getPropertyValues().add(<span class="string">"transactionAttributeSource"</span>, <span class="keyword">new</span> RuntimeBeanReference(sourceName));</span><br><span class="line">            advisorDef.getPropertyValues().add(<span class="string">"adviceBeanName"</span>, interceptorName);</span><br><span class="line">            <span class="keyword">if</span> (element.hasAttribute(<span class="string">"order"</span>)) &#123;</span><br><span class="line">                advisorDef.getPropertyValues().add(<span class="string">"order"</span>, element.getAttribute(<span class="string">"order"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注册BeanFactoryTransactionAttributeSourceAdvisor bean</span></span><br><span class="line">            parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建CompositeComponentDefinition</span></span><br><span class="line">            CompositeComponentDefinition compositeDef = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), eleSource);</span><br><span class="line">            compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(sourceDef, sourceName));</span><br><span class="line">            compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(interceptorDef, interceptorName));</span><br><span class="line">            compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(advisorDef, txAdvisorBeanName));</span><br><span class="line">            parserContext.registerComponent(compositeDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);</code>，这里注册了 <code>InfrastructureAdvisorAutoProxyCreator</code> <code>bean</code> 这个类继承了 <code>BeanPostProcessor</code>，这里实现了<code>AOP</code>代理对象的创建</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/tx/InfrastructureAdvisorAutoProxyCreator.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>所以关注<code>InfrastructureAdvisorAutoProxyCreator</code>的<code>postProcessAfterInitialization()</code>方法，进入其父类<code>AbstractAutoProxyCreator</code>中，这行代码是不是很熟悉没错就是创建<code>AOP</code>动态代理对象的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据给定的bean的class和name构建出个key，格式: beanClassName_beanName</span></span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 如果它适合被代理，则需要封装指定的bean</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经处理过</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无需增强</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 如果存在增强方法则创建代理</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果获取到了增强则需要针对增强创建代理</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建代理 1、获取增强方法或者增强器 2、根据获取的增强进行代理</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关注<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code>这里是检查是否存在增强方法，如果有的话则创建代理，这里的内容<code>AOP</code>章节已经介绍了些</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">    <span class="comment">// 获取所有的增强以及寻找所有增强中适用于bean的增强并应用</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有增强器</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 从所有增强器中找出适合的增强器</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到先是获取了所有的增强器，然后在所有增强器中找出适合的增强器并返回</p><ul><li><p>获取所有增强器</p><ul><li>进入<code>findCandidateAdvisors();</code>方法之后直接跳到<code>findAdvisorBeans()</code>方法，关注<code>advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false);</code>方法这里获取所有对应<code>Advisor.class</code>的类</li><li>回顾之前的<code>AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);</code>方法是注册了<code>BeanFactoryTransactionAttributeSourceAdvisor</code>，看名称可以知道是继承了<code>Advisor</code>接口，所以这里获取增强器也会把这个类添加进来<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">findAdvisorBeans</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Determine list of advisor bean names, if not cached already.</span></span><br><span class="line">    String[] advisorNames = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        advisorNames = <span class="keyword">this</span>.cachedAdvisorBeanNames;</span><br><span class="line">        <span class="keyword">if</span> (advisorNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">            <span class="comment">// uninitialized to let the auto-proxy creator apply to them!</span></span><br><span class="line">            <span class="comment">// 获取所有的beanName</span></span><br><span class="line">            advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(<span class="keyword">this</span>.beanFactory, Advisor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">this</span>.cachedAdvisorBeanNames = advisorNames;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (advisorNames.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="comment">// 循环所有的beanname找出对应的增强方法</span></span><br><span class="line">    <span class="keyword">for</span> (String name : advisorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEligibleBean(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(name)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Skipping currently created advisor '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    advisors.add(<span class="keyword">this</span>.beanFactory.getBean(name, Advisor.class));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                    Throwable rootCause = ex.getMostSpecificCause();</span><br><span class="line">                    <span class="keyword">if</span> (rootCause <span class="keyword">instanceof</span> BeanCurrentlyInCreationException) &#123;</span><br><span class="line">                        BeanCreationException bce = (BeanCreationException) rootCause;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isCurrentlyInCreation(bce.getBeanName())) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(<span class="string">"Skipping advisor '"</span> + name +</span><br><span class="line">                                        <span class="string">"' with dependency on currently created bean: "</span> + ex.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// Ignore: indicates a reference back to the bean we're trying to advise.</span></span><br><span class="line">                            <span class="comment">// We want to find advisors other than the currently created bean itself.</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>从所有增强器中找出适合的增强器</p><ul><li><p>上面已经获取了所有增强器，接下来就是匹配符合条件的增强器了，下面关注最后一个<code>canApply()</code>方法可以看到<code>if (advisor instanceof PointcutAdvisor)</code>判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤已经得到的advisors</span></span><br><span class="line">        <span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="comment">// 首先处理引介增强</span></span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="comment">// canApply真正的匹配</span></span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            <span class="comment">// 引介增强已经处理</span></span><br><span class="line">            <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于普通bean的处理</span></span><br><span class="line">        <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">        <span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当前我们分析<code>UserService</code>是否适用于此增强方法，那么当前的<code>advisor</code>就是之前自定义标签解析的<code>BeanFactoryTransactionAttributeSourceAdvisor</code>，这个类间接实现了<code>PointcutAdvisor</code>，然后调用<code>canApply(pca.getPointcut(), targetClass, hasIntroductions)</code>方法，所以现在就将<code>AOP</code>和<code>TX</code>联系起来了</p></li><li><p>进入<code>canApply(pca.getPointcut(), targetClass, hasIntroductions)</code>方法，这里<code>pca.getPointcut()</code>返回的是<code>TransactionAttributeSourcePointcut</code>，这也是上面解析自定义标签时注入进入的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TransactionAttributeSourcePointcut里的MethodMatcher</span></span><br><span class="line">    MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">        <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">    classes.add(targetClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">        <span class="comment">// 获取对应类的所有接口并连同类本身一起遍历，在遍历过程中又对类中的方法再次遍历，一但匹配成功便认为这个类使用于当前增强器</span></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">                    methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到先是获取<code>TransactionAttributeSourcePointcut</code>里的<code>MethodMatcher</code>，然后就是获取对应类的所有接口并连同类本身一起遍历，在遍历过程中又对类中的方法再次遍历，一但匹配成功便认为这个类使用于当前增强器，所以关注<code>TransactionAttributeSourcePointcut</code>里的<code>MethodMatcher</code>里的<code>matches(method, targetClass)</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TransactionalProxy.class.isAssignableFrom(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义标签解析时注入，这里tas是AnnotationTransactionAttributeSource</span></span><br><span class="line">    TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line">    <span class="keyword">return</span> (tas == <span class="keyword">null</span> || tas.getTransactionAttribute(method, targetClass) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>tas.getTransactionAttribute()</code>方法，这里跳到<code>org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource#getTransactionAttribute</code>，这里是判断我们的业务方法或者类上是否有<code>@Transactional</code>注解并且做了一下缓存处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断我们的业务方法或者类上是否有<span class="doctag">@Transactional</span>注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Determine the transaction attribute for this method invocation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Defaults to the class's transaction attribute if no method attribute is found.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method the method for the current invocation (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetClass the target class for this invocation (may be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> TransactionAttribute for this method, or &#123;<span class="doctag">@code</span> null&#125; if the method</span></span><br><span class="line"><span class="comment"> * is not transactional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">getTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// First, see if we have a cached value.</span></span><br><span class="line">    Object cacheKey = getCacheKey(method, targetClass);</span><br><span class="line">    Object cached = <span class="keyword">this</span>.attributeCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Value will either be canonical value indicating there is no transaction attribute,</span></span><br><span class="line">        <span class="comment">// or an actual transaction attribute.</span></span><br><span class="line">        <span class="keyword">if</span> (cached == NULL_TRANSACTION_ATTRIBUTE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (TransactionAttribute) cached;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We need to work it out.</span></span><br><span class="line">        <span class="comment">// 获取事物属性</span></span><br><span class="line">        TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);</span><br><span class="line">        <span class="comment">// Put it in the cache.</span></span><br><span class="line">        <span class="keyword">if</span> (txAttr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);</span><br><span class="line">            <span class="keyword">if</span> (txAttr <span class="keyword">instanceof</span> DefaultTransactionAttribute) &#123;</span><br><span class="line">                ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Adding transactional method '"</span> + methodIdentification + <span class="string">"' with attribute: "</span> + txAttr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存入缓存</span></span><br><span class="line">            <span class="keyword">this</span>.attributeCache.put(cacheKey, txAttr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>computeTransactionAttribute(method, targetClass);</code>，可以看到如果方法中存在事务属性，则使用方法上的事务属性，否则使用方法所在类上的事务属性，如果还是没找到就搜寻接口中的方法的事务属性，再没有就找接口类上的事务属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don't allow no-public methods as required.</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ignore CGLIB subclasses - introspect the actual user class.</span></span><br><span class="line">    Class&lt;?&gt; userClass = ClassUtils.getUserClass(targetClass);</span><br><span class="line">    <span class="comment">// The method may be on an interface, but we need attributes from the target class.</span></span><br><span class="line">    <span class="comment">// If the target class is null, the method will be unchanged.</span></span><br><span class="line">    Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass);</span><br><span class="line">    <span class="comment">// If we are dealing with method with generic parameters, find the original method.</span></span><br><span class="line">    specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// First try is the method in the target class.</span></span><br><span class="line">    <span class="comment">// 查看方法中是否存在事务声明</span></span><br><span class="line">    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Second try is the transaction attribute on the target class.</span></span><br><span class="line">    <span class="comment">// 查看方法所在类中是否有事务声明</span></span><br><span class="line">    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">        <span class="keyword">return</span> txAttr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (specificMethod != method) &#123;</span><br><span class="line">        <span class="comment">// Fallback is to look at the original method.</span></span><br><span class="line">        <span class="comment">// 查看接口方法中是否有事务声明</span></span><br><span class="line">        txAttr = findTransactionAttribute(method);</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Last fallback is the class of the original method.</span></span><br><span class="line">        <span class="comment">// 查看接口类中是否有事务声明</span></span><br><span class="line">        txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">        <span class="keyword">if</span> (txAttr != <span class="keyword">null</span> &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> txAttr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体查找逻辑在<code>findTransactionAttribute()</code>方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">findTransactionAttribute</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> determineTransactionAttribute(method);</span><br><span class="line">&#125;      </span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">determineTransactionAttribute</span><span class="params">(AnnotatedElement ae)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ae.getAnnotations().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (TransactionAnnotationParser annotationParser : <span class="keyword">this</span>.annotationParsers) &#123;</span><br><span class="line">            TransactionAttribute attr = annotationParser.parseTransactionAnnotation(ae);</span><br><span class="line">            <span class="keyword">if</span> (attr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> attr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后就是跳到<code>org.springframework.transaction.annotation.SpringTransactionAnnotationParser#parseTransactionAnnotation(java.lang.reflect.AnnotatedElement)</code>方法上，这里的方法就是解析 <code>{@link Transactional}</code> 注解，并封装成<code>TransactionAttribute</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotatedElement ae)</span> </span>&#123;</span><br><span class="line">    AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ae, Transactional.class);</span><br><span class="line">    <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> parseTransactionAnnotation(attributes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析 &#123;<span class="doctag">@link</span> Transactional&#125; 注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attributes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">parseTransactionAnnotation</span><span class="params">(AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    RuleBasedTransactionAttribute rbta = <span class="keyword">new</span> RuleBasedTransactionAttribute();</span><br><span class="line">    Propagation propagation = attributes.getEnum(<span class="string">"propagation"</span>);</span><br><span class="line">    rbta.setPropagationBehavior(propagation.value());</span><br><span class="line">    Isolation isolation = attributes.getEnum(<span class="string">"isolation"</span>);</span><br><span class="line">    rbta.setIsolationLevel(isolation.value());</span><br><span class="line">    rbta.setTimeout(attributes.getNumber(<span class="string">"timeout"</span>).intValue());</span><br><span class="line">    rbta.setReadOnly(attributes.getBoolean(<span class="string">"readOnly"</span>));</span><br><span class="line">    rbta.setQualifier(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">    ArrayList&lt;RollbackRuleAttribute&gt; rollBackRules = <span class="keyword">new</span> ArrayList&lt;RollbackRuleAttribute&gt;();</span><br><span class="line">    Class&lt;?&gt;[] rbf = attributes.getClassArray(<span class="string">"rollbackFor"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : rbf) &#123;</span><br><span class="line">        RollbackRuleAttribute rule = <span class="keyword">new</span> RollbackRuleAttribute(rbRule);</span><br><span class="line">        rollBackRules.add(rule);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] rbfc = attributes.getStringArray(<span class="string">"rollbackForClassName"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String rbRule : rbfc) &#123;</span><br><span class="line">        RollbackRuleAttribute rule = <span class="keyword">new</span> RollbackRuleAttribute(rbRule);</span><br><span class="line">        rollBackRules.add(rule);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] nrbf = attributes.getClassArray(<span class="string">"noRollbackFor"</span>);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; rbRule : nrbf) &#123;</span><br><span class="line">        NoRollbackRuleAttribute rule = <span class="keyword">new</span> NoRollbackRuleAttribute(rbRule);</span><br><span class="line">        rollBackRules.add(rule);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] nrbfc = attributes.getStringArray(<span class="string">"noRollbackForClassName"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String rbRule : nrbfc) &#123;</span><br><span class="line">        NoRollbackRuleAttribute rule = <span class="keyword">new</span> NoRollbackRuleAttribute(rbRule);</span><br><span class="line">        rollBackRules.add(rule);</span><br><span class="line">    &#125;</span><br><span class="line">    rbta.getRollbackRules().addAll(rollBackRules);</span><br><span class="line">    <span class="keyword">return</span> rbta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>回到<code>AbstractAutoProxyCreator#postProcessAfterInitialization</code>方法，这里是创建<code>AOP</code>代理对象的逻辑</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据给定的bean的class和name构建出个key，格式: beanClassName_beanName</span></span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 如果它适合被代理，则需要封装指定的bean</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经处理过</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无需增强</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 如果存在增强方法则创建代理</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果获取到了增强则需要针对增强创建代理</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建代理 1、获取增强方法或者增强器 2、根据获取的增强进行代理</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在来看看<code>UserService</code>的获取到的增强器，可以看到是获取到了<code>BeanFactoryTransactionAttributeSourceAdvisor</code>，这里是根据该<code>Advisor</code>来创建代理对象，到这里<code>Spring</code>事务自定义标签的解析过程已经介绍完了，可以总结为下面几个步骤：<ul><li>1、解析事务自定义标签<code>&lt;tx:annotation-driven&gt;</code>，注册<code>InfrastructureAdvisorAutoProxyCreator</code>及<code>BeanFactoryTransactionAttributeSourceAdvisor</code>等<code>bean</code></li><li>2、<code>InfrastructureAdvisorAutoProxyCreator</code>实现了<code>BeanPostProcessor</code>，所以可以遍历所有的<code>bean</code>用于创建代理对象</li><li>3、那些类需要创建事务代理对象，则由<code>BeanFactoryTransactionAttributeSourceAdvisor</code>提供实现</li></ul></li></ul><p><img src="/images/server/spring/analysis/tx/transaction5.png" alt=""></p><h3 id="编程式事务原理解析"><a href="#编程式事务原理解析" class="headerlink" title="编程式事务原理解析"></a>编程式事务原理解析</h3><ul><li>可以看到编程式事务是通过<code>TransactionTemplate</code>及<code>PlatformTransactionManager</code>硬编码的形式来实现的，实际使用起来比声明式事务麻烦，而且侵入性强，因为这个很少使用所以不解析</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>&lt;tx:annotation-driven&gt;</code>标签是开启事务的开关，配置了这个就可以使用注解<code>@Transactional</code>来开启事务了，解析该标签的过程就是注册<code>bean</code>的过程<ul><li>注册<code>BeanFactoryTransactionAttributeSourceAdvisor</code>是整个事务功能的基础，这个类是判断这个<code>bean</code>是否需要适用事务增强，如果需要的话就创建<code>AOP</code>代理对象</li><li>在解析事务自定义标签时<code>Spring</code>将<code>TransactionInterceptor</code>类注入到了<code>BeanFactoryTransactionAttributeSourceAdvisor</code>，所以在调用事务增强器增强的代理类时会首先执行<code>TransactionInterceptor</code>进行增强，同时其<code>invoke</code>方法完成了整个事务的逻辑</li></ul></li><li><code>Spring</code>事务的初始化过程的大概逻辑是检查所有的<code>bean</code>是否需要创建<code>AOP</code>代理，判断逻辑是判断所在类及所在类的方法是否有<code>@Transactional</code>注解，如果有的话就创建代理，创建代理之后就是执行代理方法了，下章介绍<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li><li>《Spring 源码深度解析》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;事务让我们从复杂的事务处理中得到解脱，使我们再不需要去处理获得连接、关闭连接、事务提
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(七十)Spring事务之基础概念</title>
    <link href="http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%B8%83%E5%8D%81)Spring%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.songshuiyang.com/2019/08/05/backend/framework/spring/analysis/Spring系列(七十)Spring事务之基础概念/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-06-29T15:53:30.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4><ul><li>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</li></ul><h4 id="事务的特性ACID"><a href="#事务的特性ACID" class="headerlink" title="事务的特性ACID"></a>事务的特性ACID</h4><h5 id="1、原子性-Atomicity"><a href="#1、原子性-Atomicity" class="headerlink" title="1、原子性 Atomicity"></a>1、原子性 Atomicity</h5><ul><li>一个事务<code>（transaction）</code>中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复<code>（Rollback）</code>到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li></ul><h5 id="2、一致性-Consistency"><a href="#2、一致性-Consistency" class="headerlink" title="2、一致性 Consistency"></a>2、一致性 Consistency</h5><ul><li>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器)、级联回滚等。</li></ul><h5 id="3、隔离性-Isolation"><a href="#3、隔离性-Isolation" class="headerlink" title="3、隔离性 Isolation"></a>3、隔离性 Isolation</h5><ul><li>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 </li></ul><h5 id="4、持久性-Durability"><a href="#4、持久性-Durability" class="headerlink" title="4、持久性 Durability"></a>4、持久性 Durability</h5><ul><li>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h4 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h4><ul><li>MySQL数据库针对这四种特性，为我们提供的四种隔离级别，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(五四)AOP源码解析之代理对象方法执行</title>
    <link href="http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%94%E5%9B%9B)AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C/"/>
    <id>http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring系列(五四)AOP源码解析之代理对象方法执行/</id>
    <published>2019-07-31T16:00:04.000Z</published>
    <updated>2019-06-29T12:54:25.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>上一章节介绍了<code>AOP</code>代理对象的创建，那么实际方法的运行是通过代理对象来操作的，本章节将介绍代理对象方法的执行过程</p></li><li><p><code>AopProxy</code>它有两个子类，所以不同代理对象方法执行过程是不一样的</p><ul><li><code>JdkDynamicAopProxy</code>是基于 <code>JDK</code> 的 <code>AOP</code> 代理实现类</li><li><code>ObjenesisCglibAopProxy</code>是基于 <code>CGLIB</code> 的 <code>AOP</code> 的代理实现类</li></ul></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h4 id="1、JdkDynamicAopProxy"><a href="#1、JdkDynamicAopProxy" class="headerlink" title="1、JdkDynamicAopProxy"></a>1、JdkDynamicAopProxy</h4><ul><li><p>我们知道<code>JDK</code>的动态代理是通过<code>Proxy</code>,<code>InvocationHandler</code>来实现的，所以抓住这两个点来分析这个<code>JdkDynamicAopProxy</code></p></li><li><p>先看一下<code>JdkDynamicAopProxy</code>这个类的继承关系，可以看到这个类实现了<code>InvocationHandler</code>接口，所以关注里面的<code>invoke</code>方法，同时还继承了<code>AopProxy</code>接口，这个接口的作用是返回对应的代理对象</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/aop/JdkDynamicAopProxy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>下面是<code>JdkDynamicAopProxy</code>的主体代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5531744639992436476L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(JdkDynamicAopProxy.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Config used to configure this proxy */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is the &#123;<span class="doctag">@link</span> #equals&#125; method defined on the proxied interfaces?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> equalsDefined;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is the &#123;<span class="doctag">@link</span> #hashCode&#125; method defined on the proxied interfaces?</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> hashCodeDefined;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new JdkDynamicAopProxy for the given AOP configuration.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config the AOP configuration as AdvisedSupport object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AopConfigException if the config is invalid. We try to throw an informative</span></span><br><span class="line"><span class="comment"> * exception in this case, rather than let a mysterious failure happen later.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdkDynamicAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">Assert.notNull(config, <span class="string">"AdvisedSupport must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (config.getAdvisors().length == <span class="number">0</span> &amp;&amp; config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"No advisors and no TargetSource specified"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.advised = config;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getProxy(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finds any &#123;<span class="doctag">@link</span> #equals&#125; or &#123;<span class="doctag">@link</span> #hashCode&#125; method that may be defined</span></span><br><span class="line"><span class="comment"> * on the supplied set of interfaces.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxiedInterfaces the interfaces to introspect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findDefinedEqualsAndHashCodeMethods</span><span class="params">(Class&lt;?&gt;[] proxiedInterfaces)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; proxiedInterface : proxiedInterfaces) &#123;</span><br><span class="line">Method[] methods = proxiedInterface.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line"><span class="keyword">if</span> (AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="keyword">this</span>.equalsDefined = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="keyword">this</span>.hashCodeDefined = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.equalsDefined &amp;&amp; <span class="keyword">this</span>.hashCodeDefined) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of &#123;<span class="doctag">@code</span> InvocationHandler.invoke&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span></span><br><span class="line"><span class="comment"> * unless a hook method throws an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">MethodInvocation invocation;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果被代理的目标对象要执行的方法是equal则执行JdkDynamicAopProxy（即代理对象的equal）方法</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line"><span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果被代理的目标对象要执行的方法是hashCode则执行JdkDynamicAopProxy（即代理对象的hashCode）方法</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line"><span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line"><span class="keyword">return</span> hashCode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line"><span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line"><span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line"><span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line"><span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"><span class="comment">// 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line"><span class="comment">// in case it comes from a pool.</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">targetClass = target.getClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the interception chain for this method.</span></span><br><span class="line"><span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line"><span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line"><span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line"><span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line"><span class="comment">// 如果没有发现任何拦截器那么直接调用切点方法</span></span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We need to create a method invocation...</span></span><br><span class="line"><span class="comment">// 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line"><span class="comment">// 执行拦截器链</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Massage return value if necessary.</span></span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line"><span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line"><span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line"><span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">retVal = proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回结果</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line"><span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line"><span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">targetSource.releaseTarget(target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line"><span class="comment">// Restore old proxy.</span></span><br><span class="line">AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p>关注<code>invoke</code>方法，根据上面代码可以看到如果执行的是<code>equals</code>或者<code>hashCode</code>方法则执行<code>JdkDynamicAopProxy</code>里面对应的内部方法，然后就是获取当前获取当前方法的拦截器链，对于没有拦截器的方法直接调用原有方法，有拦截器的方法会构造<code>ReflectiveMethodInvocation</code>，并沿着拦截器链进行调用。整个调用链的入口在其<code>proceed</code>方法中</p><ul><li><p>1、获取当前方法的拦截器链</p><ul><li><p><code>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</code>方法，这个方法做了一下缓存处理，因为那些方法需要执行代理都是之前写好固定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中寻找该方法的拦截链是否已经获取过（可能被代理对象的某个方法被调用过多次，</span></span><br><span class="line">    <span class="comment">// 调用第一次就会获取一次，后面多次调用时，则需从缓存中直接获取，无需多次获取，</span></span><br><span class="line">    <span class="comment">// 这样就会提高性能），如果已经获取过，直接返回</span></span><br><span class="line">    MethodCacheKey cacheKey = <span class="keyword">new</span> MethodCacheKey(method);</span><br><span class="line">    List&lt;Object&gt; cached = <span class="keyword">this</span>.methodCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (cached == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cached = <span class="keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(</span><br><span class="line">                <span class="keyword">this</span>, method, targetClass);</span><br><span class="line">        <span class="keyword">this</span>.methodCache.put(cacheKey, cached);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续跟进<code>this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);</code>方法，可以看到这边就是一个拦截器的过滤，可以看到主体逻辑是循环<code>Advisor</code>通过切点匹配<code>MethodMatchers.matches(mm, method, actualClass, hasIntroductions)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其实这边就是一个拦截器的过滤，我们在生产环境中，我们一般会用正则表达来定义切点（expression），</span></span><br><span class="line"><span class="comment"> * 因为并不是每个方法都需要切，会影响性能，所以matches这个方法很重要</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> config the AOP configuration in the form of an Advised object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method the proxied method</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetClass the target class (may be &#123;<span class="doctag">@code</span> null&#125; to indicate a proxy without</span></span><br><span class="line"><span class="comment"> * target object, in which case the method's declaring class is the next best option)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Advised config, Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This is somewhat tricky... We have to process introductions first,</span></span><br><span class="line">    <span class="comment">// but we need to preserve order in the ultimate list.</span></span><br><span class="line">    <span class="comment">// 先定义了一个拦截链的List大小最大为我们传入advisor的个数</span></span><br><span class="line">    List&lt;Object&gt; interceptorList = <span class="keyword">new</span> ArrayList&lt;Object&gt;(config.getAdvisors().length);</span><br><span class="line">    Class&lt;?&gt; actualClass = (targetClass != <span class="keyword">null</span> ? targetClass : method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);</span><br><span class="line">    AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">            <span class="comment">// Add it conditionally.</span></span><br><span class="line">            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;</span><br><span class="line">            <span class="keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                MethodInterceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();</span><br><span class="line">                <span class="keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mm.isRuntime()) &#123;</span><br><span class="line">                        <span class="comment">// Creating a new object instance in the getInterceptors() method</span></span><br><span class="line">                        <span class="comment">// isn't a problem as we normally cache created chains.</span></span><br><span class="line">                        <span class="keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;</span><br><span class="line">                            interceptorList.add(<span class="keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            IntroductionAdvisor ia = (IntroductionAdvisor) advisor;</span><br><span class="line">            <span class="keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;</span><br><span class="line">                Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">                interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Interceptor[] interceptors = registry.getInterceptors(advisor);</span><br><span class="line">            interceptorList.addAll(Arrays.asList(interceptors));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> interceptorList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2、对于没有拦截器的方法直接调用原有方法</p><ul><li><p>如果上面获取的<code>chain</code>是<code>isEmpty()</code>，下面就是直接调用<code>method.invoke(target, args);</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">    <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">    <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">    <span class="comment">// 如果没有发现任何拦截器那么直接调用切点方法</span></span><br><span class="line">    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">invokeJoinpointUsingReflection</span><span class="params">(Object target, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 使用反射执行方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ReflectionUtils.makeAccessible(method);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="comment">// Invoked method threw a checked exception.</span></span><br><span class="line">        <span class="comment">// We must rethrow it. The client won't see the interceptor.</span></span><br><span class="line">        <span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"AOP configuration seems to be invalid: tried calling method ["</span> +</span><br><span class="line">                method + <span class="string">"] on target ["</span> + target + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(<span class="string">"Could not access method ["</span> + method + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p>3、有拦截器的方法会构造<code>ReflectiveMethodInvocation</code>执行<code>proceed()</code>方法</p><ul><li><p>如果上面获取的<code>chain</code>是<code>isNotEmpty()</code>，就需要执行相应拦截器的方法了，可以看到是封装了一个<code>ReflectiveMethodInvocation</code>对象，然后执行其<code>proceed()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">    <span class="comment">// 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器</span></span><br><span class="line">    invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">    <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">    <span class="comment">// 执行拦截器链</span></span><br><span class="line">    retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>invocation.proceed();</code>方法，可以看到这里使用了一个拦截器链的操作，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">//We start with an index of -1 and increment early.</span></span><br><span class="line">    <span class="comment">// 执行完所有增强后执行切点方法，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.currentInterceptorIndex == <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取下一个要执行的拦截器 沿着拦截器链执行</span></span><br><span class="line">    Object interceptorOrInterceptionAdvice =</span><br><span class="line">            <span class="keyword">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="keyword">this</span>.currentInterceptorIndex);</span><br><span class="line">    <span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line">        <span class="comment">// Evaluate dynamic method matcher here: static part will already have</span></span><br><span class="line">        <span class="comment">// been evaluated and found to match.</span></span><br><span class="line">        <span class="comment">// 对方法进行动态匹配，切点的匹配就在这里进行</span></span><br><span class="line">        InterceptorAndDynamicMethodMatcher dm =</span><br><span class="line">                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">        <span class="keyword">if</span> (dm.methodMatcher.matches(<span class="keyword">this</span>.method, <span class="keyword">this</span>.targetClass, <span class="keyword">this</span>.arguments)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dm.interceptor.invoke(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dynamic matching failed.</span></span><br><span class="line">            <span class="comment">// Skip this interceptor and invoke the next in the chain.</span></span><br><span class="line">            <span class="comment">// 不匹配则跳过这个拦截器调用下一个</span></span><br><span class="line">            <span class="keyword">return</span> proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It's an interceptor, so we just invoke it: The pointcut will have</span></span><br><span class="line">        <span class="comment">// been evaluated statically before this object was constructed.</span></span><br><span class="line">        <span class="comment">//  这是一个拦截器，直接调用它，将this作为参数传递以保证当前实例中调用链的执行</span></span><br><span class="line">        <span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="2、ObjenesisCglibAopProxy"><a href="#2、ObjenesisCglibAopProxy" class="headerlink" title="2、ObjenesisCglibAopProxy"></a>2、ObjenesisCglibAopProxy</h4><ul><li>先看一下<code>ObjenesisCglibAopProxy</code>这个类的继承关系</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/aop/ObjenesisCglibAopProxy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>Cglib</code>调用方法的核心逻辑在<code>DynamicAdvisedInterceptor</code>的<code>intercept</code>方法中，和<code>jdk</code>方式实现代理的<code>invoke</code>方法大同小异</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = advised;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">        Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">        Object target = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// May be null. Get as late as possible to minimize the time we</span></span><br><span class="line">            <span class="comment">// "own" the target, in case it comes from a pool...</span></span><br><span class="line">            target = getTarget();</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetClass = target.getClass();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取拦截器链</span></span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">            <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">            <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">                <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">                <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">                <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">                <span class="comment">// 拦截器链为空直接激活原方法</span></span><br><span class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                <span class="comment">// 进入链</span></span><br><span class="line">                retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">                <span class="comment">// Restore old proxy.</span></span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>关注<code>retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</code>这行代码，这里构造了<code>CglibMethodInvocation</code>查看这个类，然后执行<code>proceed()</code>方法，可以发现这个类继承了<code>ReflectiveMethodInvocation</code>这个类，所以这里的<code>proceed()</code>方法和我们上面<code>jdk</code>动态代理执行的<code>proceed()</code>方法是一样的</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 源码深度解析》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上一章节介绍了&lt;code&gt;AOP&lt;/code&gt;代理对象的创建，那么实际方法的运行是通过代理对象来操作的，本章节将介绍代理对
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(五三)AOP源码解析之创建AOP代理</title>
    <link href="http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%94%E4%B8%89)AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%88%9B%E5%BB%BAAOP%E4%BB%A3%E7%90%86/"/>
    <id>http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring系列(五三)AOP源码解析之创建AOP代理/</id>
    <published>2019-07-31T16:00:03.000Z</published>
    <updated>2019-06-29T06:53:15.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>上一章节介绍了<code>&lt;aop:aspectj-autoproxy/&gt;</code>的解析过程，最终结果是得到<code>AnnotationAwareAspectJAutoProxyCreator</code> 这个<code>bean</code>，这个类用于创建<code>AOP</code>的代理类，那么这个类到底做了什么工作来完成<code>AOP</code>的功能的呢？</p></li><li><p>先看一下<code>AnnotationAwareAspectJAutoProxyCreator</code> 的类继承关系</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/aop/AnnotationAwareAspectJAutoProxyCreator.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AspectJAwareAdvisorAutoProxyCreator (org.springframework.aop.aspectj.autoproxy)</span><br><span class="line">    AbstractAdvisorAutoProxyCreator (org.springframework.aop.framework.autoproxy)</span><br><span class="line">        AbstractAutoProxyCreator (org.springframework.aop.framework.autoproxy)</span><br><span class="line">            ProxyProcessorSupport (org.springframework.aop.framework)</span><br><span class="line">                ProxyConfig (org.springframework.aop.framework)</span><br><span class="line">                    Object (java.lang)</span><br><span class="line">                    Serializable (java.io)</span><br><span class="line">                Ordered (org.springframework.core)</span><br><span class="line">                BeanClassLoaderAware (org.springframework.beans.factory)</span><br><span class="line">                    Aware (org.springframework.beans.factory)</span><br><span class="line">                AopInfrastructureBean (org.springframework.aop.framework)</span><br><span class="line">            SmartInstantiationAwareBeanPostProcessor (org.springframework.beans.factory.config)</span><br><span class="line">                InstantiationAwareBeanPostProcessor (org.springframework.beans.factory.config)</span><br><span class="line">                    BeanPostProcessor (org.springframework.beans.factory.config)</span><br><span class="line">            BeanFactoryAware (org.springframework.beans.factory)</span><br><span class="line">                Aware (org.springframework.beans.factory)</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>由<code>AnnotationAwareAspectJAutoProxyCreator</code>的继承关系图可以注意到此类实现了 <code>BeanPostProcessor</code>接口，这个接口前面经常看见，实现了这个接口是可以在<code>bean</code>初始化之前和初始化之后添加一些逻辑，到这里，我们大概可以猜出代理类是怎样和目标对象联系在一起的，实现偷天换日</p><ul><li><p>先回顾下<code>doCreateBean</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 创建实例</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 装载属性</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 初始化</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上面第 3 步 <code>initializeBean(...)</code>初始化方法中会调用 <code>BeanPostProcessor</code> 中的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   Object wrappedBean = bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// 1. 执行每一个 BeanPostProcessor 的 postProcessBeforeInitialization 方法</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 激活用户自定义的init方法 1、InitializingBean接口afterPropertiesSet方法 2、bean 定义的init-method=""方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// 我们关注的重点是这里！！！</span></span><br><span class="line">      <span class="comment">// 2. 执行每一个 BeanPostProcessor 的 postProcessAfterInitialization 方法</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>由上面的代码可以看到<code>Spring AOP</code> 会在 <code>IOC</code> 容器创建 <code>bean</code> 实例的最后对 <code>bean</code> 进行处理，其实就是在这一步进行代理增强。 我们来看一下它是怎么实现  <code>BeanPostProcessor</code>接口的，具体实现在父类<code>AbstractAutoProxyCreator#postProcessAfterInitialization</code>中，下面的代码可以看到先是判断这个<code>bean</code>是否需要被代理，如果要的话就是返回对应的代理类了，具体逻辑在<code>wrapIfNecessary(bean, beanName, cacheKey);</code>方法中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a proxy with the configured interceptors if the bean is</span></span><br><span class="line"><span class="comment"> * identified as one to proxy by the subclass.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getAdvicesAndAdvisorsForBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据给定的bean的class和name构建出个key，格式: beanClassName_beanName</span></span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 如果它适合被代理，则需要封装指定的bean</span></span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean the raw bean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cacheKey the cache key for metadata access</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a proxy wrapping the bean, or the raw bean instance as-is</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经处理过</span></span><br><span class="line">    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无需增强</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理</span></span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">    <span class="comment">// 核心方法 如果存在增强方法则创建代理</span></span><br><span class="line">    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果获取到了增强则需要针对增强创建代理</span></span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建代理 1、获取增强方法或者增强器 2、根据获取的增强进行代理</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从上面的代码可以看到代理创建的雏形，主要步骤分为两步<ul><li>1、获取增强方法或者增强器</li><li>2、根据获取的增强进行代理</li></ul></li></ul><h3 id="1、获取增强方法或者增强器"><a href="#1、获取增强方法或者增强器" class="headerlink" title="1、获取增强方法或者增强器"></a>1、获取增强方法或者增强器</h3><ul><li>先来看获取增强方法的实现逻辑<code>getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123;</span><br><span class="line">    <span class="comment">// 获取所有的增强以及寻找所有增强中适用于bean的增强并应用</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (advisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> DO_NOT_PROXY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors.toArray();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有增强器</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 从所有增强器中找出适合的增强器</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到先是获取了所有的增强器，然后在所有增强器中找出适合的增强器并返回</p><ul><li><p>获取所有增强器</p><ul><li><p>当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持，在这里调用父类方法加载配置文件中的AOP声明，然后再<code>add</code>使用注解配置的<code>Advisor</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add all the Spring advisors found according to superclass rules.</span></span><br><span class="line">    <span class="comment">// 当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持</span></span><br><span class="line">    <span class="comment">// 在这里调用父类方法加载配置文件中的AOP声明</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// Build Advisors for all AspectJ aspects in the bean factory.</span></span><br><span class="line"><span class="comment">// 获取注解配置的Advisor</span></span><br><span class="line">    advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>this.aspectJAdvisorsBuilder.buildAspectJAdvisors()</code>方法是获取注解配置的<code>Advisor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">buildAspectJAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            aspectNames = <span class="keyword">this</span>.aspectBeanNames;</span><br><span class="line">            <span class="keyword">if</span> (aspectNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">                aspectNames = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">                <span class="comment">// 获取所有的beanName</span></span><br><span class="line">                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                        <span class="keyword">this</span>.beanFactory, Object.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 循环所有的beanName找出对应的增强方法</span></span><br><span class="line">                <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">                    <span class="comment">// 不合法的bean则略过</span></span><br><span class="line">                    <span class="keyword">if</span> (!isEligibleBean(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// We must be careful not to instantiate beans eagerly as in this case they</span></span><br><span class="line">                    <span class="comment">// would be cached by the Spring conainer but would not have been weaved.</span></span><br><span class="line">                    <span class="comment">// 获取对应的bean的类型</span></span><br><span class="line">                    Class&lt;?&gt; beanType = <span class="keyword">this</span>.beanFactory.getType(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (beanType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果存在Aspect注解</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.advisorFactory.isAspect(beanType)) &#123;</span><br><span class="line">                        aspectNames.add(beanName);</span><br><span class="line">                        AspectMetadata amd = <span class="keyword">new</span> AspectMetadata(beanType, beanName);</span><br><span class="line">                        <span class="keyword">if</span> (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123;</span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                    <span class="keyword">new</span> BeanFactoryAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                            <span class="comment">// TODO 核心 解析标记AspectJ注解中的增强方法 委托 advisorFactory.getAdvisors</span></span><br><span class="line">                            List&lt;Advisor&gt; classAdvisors = <span class="keyword">this</span>.advisorFactory.getAdvisors(factory);</span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.advisorsCache.put(beanName, classAdvisors);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            &#125;</span><br><span class="line">                            advisors.addAll(classAdvisors);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Per target or per this.</span></span><br><span class="line">                            <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.isSingleton(beanName)) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bean with name '"</span> + beanName +</span><br><span class="line">                                        <span class="string">"' is a singleton, but aspect instantiation model is not singleton"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            MetadataAwareAspectInstanceFactory factory =</span><br><span class="line">                                    <span class="keyword">new</span> PrototypeAspectInstanceFactory(<span class="keyword">this</span>.beanFactory, beanName);</span><br><span class="line">                            <span class="keyword">this</span>.aspectFactoryCache.put(beanName, factory);</span><br><span class="line">                            advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.aspectBeanNames = aspectNames;</span><br><span class="line">                <span class="keyword">return</span> advisors;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (aspectNames.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录在缓存中</span></span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String aspectName : aspectNames) &#123;</span><br><span class="line">        List&lt;Advisor&gt; cachedAdvisors = <span class="keyword">this</span>.advisorsCache.get(aspectName);</span><br><span class="line">        <span class="keyword">if</span> (cachedAdvisors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.addAll(cachedAdvisors);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            MetadataAwareAspectInstanceFactory factory = <span class="keyword">this</span>.aspectFactoryCache.get(aspectName);</span><br><span class="line">            advisors.addAll(<span class="keyword">this</span>.advisorFactory.getAdvisors(factory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面的逻辑可以看到先是获取所有的<code>beanName</code>然后遍历，找出声明<code>AspectJ</code>注解的类，并将结果加入到缓存中</p></li><li><p><code>this.advisorFactory.getAdvisors(factory);</code>是最为重要及最为复杂的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Advisor&gt; <span class="title">getAdvisors</span><span class="params">(MetadataAwareAspectInstanceFactory aspectInstanceFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取标记为AspectJ的类</span></span><br><span class="line">    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();</span><br><span class="line">    <span class="comment">// 获取标记为AspectJ的name</span></span><br><span class="line">    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();</span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    validate(aspectClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We need to wrap the MetadataAwareAspectInstanceFactory with a decorator</span></span><br><span class="line">    <span class="comment">// so that it will only instantiate once.</span></span><br><span class="line">    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =</span><br><span class="line">            <span class="keyword">new</span> LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);</span><br><span class="line">    </span><br><span class="line">    List&lt;Advisor&gt; advisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : getAdvisorMethods(aspectClass)) &#123;</span><br><span class="line">        <span class="comment">// TODO 普通增强器的获取</span></span><br><span class="line">        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If it's a per target aspect, emit the dummy instantiating aspect.</span></span><br><span class="line">    <span class="comment">// 如果寻找的增强器不为空而且又配置了延迟初始化那么需要在首位加入同步实例化增强器</span></span><br><span class="line">    <span class="keyword">if</span> (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123;</span><br><span class="line">        Advisor instantiationAdvisor = <span class="keyword">new</span> SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);</span><br><span class="line">        advisors.add(<span class="number">0</span>, instantiationAdvisor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find introduction fields.</span></span><br><span class="line">    <span class="comment">// 获取DeclaredField注解</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : aspectClass.getDeclaredFields()) &#123;</span><br><span class="line">        Advisor advisor = getDeclareParentsAdvisor(field);</span><br><span class="line">        <span class="keyword">if</span> (advisor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            advisors.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>for (Method method : getAdvisorMethods(aspectClass))</code>方法，循环切点方法，然后调用<code>Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);</code>获取增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Advisor <span class="title">getAdvisor</span><span class="params">(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> declarationOrderInAspect, String aspectName)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 切点信息的获取</span></span><br><span class="line">    AspectJExpressionPointcut expressionPointcut = getPointcut(</span><br><span class="line">            candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());</span><br><span class="line">    <span class="keyword">if</span> (expressionPointcut == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据切点信息生成增强器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,</span><br><span class="line">            <span class="keyword">this</span>, aspectInstanceFactory, declarationOrderInAspect, aspectName);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> AspectJExpressionPointcut <span class="title">getPointcut</span><span class="params">(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取方法上的注解</span></span><br><span class="line">    AspectJAnnotation&lt;?&gt; aspectJAnnotation =</span><br><span class="line">            AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);</span><br><span class="line">    <span class="keyword">if</span> (aspectJAnnotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用AspectJExpressionPointcut实例封装获取的信息</span></span><br><span class="line">    AspectJExpressionPointcut ajexp =</span><br><span class="line">            <span class="keyword">new</span> AspectJExpressionPointcut(candidateAspectClass, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>]);</span><br><span class="line">    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());</span><br><span class="line">    ajexp.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">    <span class="comment">// 提取到的注解中表达式如 @Pointcut("execution(* *.*test*(..))")中的execution(* *.*test*(..)</span></span><br><span class="line">    <span class="keyword">return</span> ajexp;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">// 看到了熟悉的注解类</span></span><br><span class="line">    Class&lt;?&gt;[] classesToLookFor = <span class="keyword">new</span> Class&lt;?&gt;[] &#123;</span><br><span class="line">            Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : classesToLookFor) &#123;</span><br><span class="line">        AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c);</span><br><span class="line">        <span class="keyword">if</span> (foundAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> foundAnnotation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里找出了两个<code>List&lt;Advisor&gt; candidateAdvisors</code>，可以看到第二个是<code>serviceAspectj</code><br><img src="/images/server/spring/analysis/aop/allAdvisor.png" alt=""></p></li></ul></li><li><p>找出适合的增强器</p><ul><li><p>上面是获取了所有的增强器，但是对应所有增强器来将并不一定都适用于当前的<code>Bean</code>,还要挑取出合适的增强器，也就是满足我们配置的通配符的增强器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有增强器</span></span><br><span class="line">    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line">    <span class="comment">// 从所有增强器中找出适合的增强器</span></span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line">    extendAdvisors(eligibleAdvisors);</span><br><span class="line">    <span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">        eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行<code>List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</code>方法从所有增强器中找出适合的增强器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ProxyCreationContext.setCurrentProxiedBeanName(beanName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤已经得到的advisors</span></span><br><span class="line">        <span class="keyword">return</span> AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        ProxyCreationContext.setCurrentProxiedBeanName(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Advisor&gt; <span class="title">findAdvisorsThatCanApply</span><span class="params">(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (candidateAdvisors.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> candidateAdvisors;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Advisor&gt; eligibleAdvisors = <span class="keyword">new</span> LinkedList&lt;Advisor&gt;();</span><br><span class="line">    <span class="comment">// 首先处理引介增强</span></span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="comment">// canApply真正的匹配</span></span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> hasIntroductions = !eligibleAdvisors.isEmpty();</span><br><span class="line">    <span class="keyword">for</span> (Advisor candidate : candidateAdvisors) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">            <span class="comment">// 引介增强已经处理</span></span><br><span class="line">            <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于普通bean的处理</span></span><br><span class="line">        <span class="keyword">if</span> (canApply(candidate, clazz, hasIntroductions)) &#123;</span><br><span class="line">            eligibleAdvisors.add(candidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真正的匹配在<code>canApply()</code>方法，可以看到使用了<code>MethodMatcher</code>接口的<code>boolean matches(Method method, Class&lt;?&gt; targetClass, boolean hasIntroductions);</code>方法进行匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Advisor advisor, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> IntroductionAdvisor) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (advisor <span class="keyword">instanceof</span> PointcutAdvisor) &#123;</span><br><span class="line">        PointcutAdvisor pca = (PointcutAdvisor) advisor;</span><br><span class="line">        <span class="keyword">return</span> canApply(pca.getPointcut(), targetClass, hasIntroductions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// It doesn't have a pointcut so we assume it applies.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(pc, <span class="string">"Pointcut must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    MethodMatcher methodMatcher = pc.getMethodMatcher();</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;</span><br><span class="line">        <span class="comment">// No need to iterate the methods if we're matching any method anyway...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;</span><br><span class="line">        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));</span><br><span class="line">    classes.add(targetClass);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;</span><br><span class="line">        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||</span><br><span class="line">                    methodMatcher.matches(method, targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="2、根据获取的增强创建代理"><a href="#2、根据获取的增强创建代理" class="headerlink" title="2、根据获取的增强创建代理"></a>2、根据获取的增强创建代理</h3><ul><li>获取了所有对应<code>bean</code>的增强器后，便可以进行代理的创建了，对于代理类的创建及处理，<code>Spring</code>委托给了<code>ProxyFactory</code>（创建 <code>Proxy</code> 的工厂类）去处理，下面的函数主要是对<code>ProxyFactory</code>的初始化操作，进而对真正的创建代理做准备</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="keyword">this</span>.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于代理类的创建及处理，Spring委托给了ProxyFactory去处理</span></span><br><span class="line">    ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    <span class="comment">// 获取当前类中相关属性</span></span><br><span class="line">    proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 决定对于给定的bean是否应该使用targetClass而不是她的接口代理。检查ProxyTargetClass设置</span></span><br><span class="line">    <span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将拦截器封装为增强器</span></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : advisors) &#123;</span><br><span class="line">        <span class="comment">// 加入增强器</span></span><br><span class="line">        proxyFactory.addAdvisor(advisor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置要代理的类</span></span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    <span class="comment">// 定制dialing</span></span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line">    <span class="comment">// 用来控制代理工厂被配置之后是否还允许修改通知 缺省值为false（即在代理被配置之后不允许修改代理的配置）</span></span><br><span class="line">    proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">    <span class="keyword">if</span> (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建代理</span></span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继续进入<code>proxyFactory.getProxy(getProxyClassLoader())</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可以看到先是调用<code>createAopProxy()</code>创建<code>AopProxy</code>，由下图可以看到一个是<code>cglib</code>的代理，一个是<code>jdk</code>的代理</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/aop/AopProxy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p><code>AopProxy</code> 用于生成代理对象的委托类，就俩方法获取代理对象<code>Proxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入<code>createAopProxy()</code>方法，这里根据逻辑判断返回<code>ObjenesisCglibAopProxy</code>或者<code>JdkDynamicAopProxy</code>，如果目标对象实现了接口，默认情况下采用<code>jdk</code>的动态代理，也可以强制使用<code>cglib</code>实现<code>aop</code>(设置方式 <code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">activate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line"><span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果目标对象实现了接口，默认情况下采用jdk的动态代理，也可以强制使用cglib实现aop</span></span><br><span class="line"><span class="comment">    * 如果目标对象没有实现了接口，必须采用cglib</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> config the AOP configuration in the form of an</span></span><br><span class="line"><span class="comment">    * AdvisedSupport object</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> AopConfigException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * optimize        ：用来控制通过cglib创建的代理是否使用激进的优化策略，仅对cglib有效，一般不推荐用户使用这个设置</span></span><br><span class="line"><span class="comment">        * proxyTargetClass：为true时，目标类本身被代理而不是目标类的接口，那么cglib代理将被创建，设置方式 &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</span></span><br><span class="line"><span class="comment">        * hasNoUserSuppliedProxyInterfaces: 是否存在代理接口</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">           Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">           <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                       <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>调用<code>createAopProxy()</code>的到<code>AopProxy</code>之后就是调用<code>AopProxy</code>的<code>getProxy(ClassLoader classLoader)</code> 获取代理对象了，<code>AopProxy</code>它有两个子类<code>JdkDynamicAopProxy</code>基于 <code>JDK</code> 的 <code>AOP</code> 代理实现类，<code>ObjenesisCglibAopProxy</code>基于 <code>CGLIB</code> 的 <code>AOP</code> 的代理实现类。</p><ul><li><p><code>JdkDynamicAopProxy</code></p><ul><li><p>下面看到了我们熟悉的<code>Proxy.newProxyInstance</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以看到<code>JdkDynamicAopProxy</code>实现了<code>InvocationHandler</code>接口，那么我们可以推断这一定有一个<code>invoke</code>函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p><code>JdkDynamicAopProxy</code>的<code>invoke</code>函数最重要的工作就是创建了一个拦截器链，并实现了拦截器链的逐一调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of &#123;<span class="doctag">@code</span> InvocationHandler.invoke&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Callers will see exactly the exception thrown by the target,</span></span><br><span class="line"><span class="comment"> * unless a hook method throws an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    MethodInvocation invocation;</span><br><span class="line">    Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">    Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">    Object target = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果被代理的目标对象要执行的方法是equal则执行JdkDynamicAopProxy（即代理对象的equal）方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123;</span><br><span class="line">            <span class="comment">// The target does not implement the equals(Object) method itself.</span></span><br><span class="line">            <span class="keyword">return</span> equals(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果被代理的目标对象要执行的方法是hashCode则执行JdkDynamicAopProxy（即代理对象的hashCode）方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123;</span><br><span class="line">            <span class="comment">// The target does not implement the hashCode() method itself.</span></span><br><span class="line">            <span class="keyword">return</span> hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (method.getDeclaringClass() == DecoratingProxy.class) &#123;</span><br><span class="line">            <span class="comment">// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.</span></span><br><span class="line">            <span class="keyword">return</span> AopProxyUtils.ultimateTargetClass(<span class="keyword">this</span>.advised);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;</span><br><span class="line">                method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123;</span><br><span class="line">            <span class="comment">// Service invocations on ProxyConfig with the proxy config...</span></span><br><span class="line">            <span class="keyword">return</span> AopUtils.invokeJoinpointUsingReflection(<span class="keyword">this</span>.advised, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        Object retVal;</span><br><span class="line">        <span class="comment">// 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">            oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">            setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// May be null. Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line">        <span class="comment">// in case it comes from a pool.</span></span><br><span class="line">        target = targetSource.getTarget();</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetClass = target.getClass();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">        <span class="comment">// 获取当前方法的拦截器链</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Check whether we have any advice. If we don't, we can fallback on direct</span></span><br><span class="line">        <span class="comment">// reflective invocation of the target, and avoid creating a MethodInvocation.</span></span><br><span class="line">        <span class="keyword">if</span> (chain.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly</span></span><br><span class="line">            <span class="comment">// Note that the final invoker must be an InvokerInterceptor so we know it does</span></span><br><span class="line">            <span class="comment">// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.</span></span><br><span class="line">            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">            <span class="comment">// 如果没有发现任何拦截器那么直接调用切点方法</span></span><br><span class="line">            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">            <span class="comment">// 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器</span></span><br><span class="line">            invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">            <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">            <span class="comment">// 执行拦截器链</span></span><br><span class="line">            retVal = invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Massage return value if necessary.</span></span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; retVal == target &amp;&amp;</span><br><span class="line">                returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;</span><br><span class="line">                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="comment">// Special case: it returned "this" and the return type of the method</span></span><br><span class="line">            <span class="comment">// is type-compatible. Note that we can't help if the target sets</span></span><br><span class="line">            <span class="comment">// a reference to itself in another returned object.</span></span><br><span class="line">            retVal = proxy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (retVal == <span class="keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopInvocationException(</span><br><span class="line">                    <span class="string">"Null return value from advice does not match primitive return type for: "</span> + method);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;</span><br><span class="line">            <span class="comment">// Must have come from TargetSource.</span></span><br><span class="line">            targetSource.releaseTarget(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">            <span class="comment">// Restore old proxy.</span></span><br><span class="line">            AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>ObjenesisCglibAopProxy</code></p><ul><li><p><code>Cglib</code>获取代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating CGLIB proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">        Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line">    </span><br><span class="line">        Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">            proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">            Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line">                <span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">        validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">        Enhancer enhancer = createEnhancer();</span><br><span class="line">        <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            enhancer.setClassLoader(classLoader);</span><br><span class="line">            <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">                    ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">                enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">        enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line">    </span><br><span class="line">        Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">        Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">            types[x] = callbacks[x].getClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line">                <span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">        enhancer.setCallbackTypes(types);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line">        <span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CodeGenerationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line">                <span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line">                <span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of class ["</span> +</span><br><span class="line">                <span class="keyword">this</span>.advised.getTargetClass() + <span class="string">"]: "</span> +</span><br><span class="line">                <span class="string">"Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Cglib</code>是一个强大的高性能代码生成包，底层通过使用一个小而快的字节码处理框架<code>ASM</code>，来转化字节码并生成新类</p></li><li><code>Cglib</code>调用方法的核心逻辑在<code>DynamicAdvisedInterceptor</code>的<code>intercept</code>方法中，和<code>jdk</code>方式实现代理的<code>invoke</code>方法大同小异<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心逻辑</span></span><br><span class="line"><span class="comment"> * General purpose AOP callback. Used when the target is dynamic or when the</span></span><br><span class="line"><span class="comment"> * proxy is not frozen.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicAdvisedInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AdvisedSupport advised;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicAdvisedInterceptor</span><span class="params">(AdvisedSupport advised)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.advised = advised;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line">        Class&lt;?&gt; targetClass = <span class="keyword">null</span>;</span><br><span class="line">        Object target = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line">                <span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">                oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">                setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// May be null. Get as late as possible to minimize the time we</span></span><br><span class="line">            <span class="comment">// "own" the target, in case it comes from a pool...</span></span><br><span class="line">            target = getTarget();</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                targetClass = target.getClass();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取拦截器链</span></span><br><span class="line">            List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">            Object retVal;</span><br><span class="line">            <span class="comment">// Check whether we only have one InvokerInterceptor: that is,</span></span><br><span class="line">            <span class="comment">// no real advice, but just reflective invocation of the target.</span></span><br><span class="line">            <span class="keyword">if</span> (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                <span class="comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span></span><br><span class="line">                <span class="comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span></span><br><span class="line">                <span class="comment">// it does nothing but a reflective operation on the target, and no hot</span></span><br><span class="line">                <span class="comment">// swapping or fancy proxying.</span></span><br><span class="line">                <span class="comment">// 拦截器链为空直接激活原方法</span></span><br><span class="line">                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">                retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">                <span class="comment">// 进入链</span></span><br><span class="line">                retVal = <span class="keyword">new</span> CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</span><br><span class="line">            &#125;</span><br><span class="line">            retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                releaseTarget(target);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (setProxyContext) &#123;</span><br><span class="line">                <span class="comment">// Restore old proxy.</span></span><br><span class="line">                AopContext.setCurrentProxy(oldProxy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/aop/jdkcglib.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>由<code>AnnotationAwareAspectJAutoProxyCreator</code>的继承关系图可以注意到此类实现了 <code>BeanPostProcessor</code>接口，<code>BeanPostProcessor</code>接口是<code>IOC</code>与<code>AOP</code>连接的桥梁</li><li>在研究源码之前可以尝试着自己想象一下解析思路，看看自己的思路和<code>Spring</code>是否有差别</li><li>在 <code>Spring</code> 的容器中，我们面向的对象是一个个的 <code>bean</code> 实例，当我们需要<code>bean</code>的时候通过<code>IOC</code> 容器的 <code>getBean(…)</code> 方法从容器中获取 <code>bean</code> 实例，只不过大部分的场景下，我们都用了依赖注入，所以很少手动调用 <code>getBean(...)</code> 方法。借助<code>IOC</code>的话实现<code>AOP</code>就很简单了，只要在<code>getBean(...)</code>返回新的代理类就可以了</li><li><code>Spring</code>使用<code>JDK</code>动态代理和<code>CGLib</code>动态代理技术在运行期织入增强，要使用<code>JDK</code>动态代理，目标类必须实现接口，而<code>CGLib</code>不对目标类作任何限制，他是通过动态生成目标类子类的方式提供代理</li><li><code>JDK</code>在创建代理对象时的性能高于<code>CGLib</code>，但生成的代理对象的运行性能却比<code>CGLib</code>的低，如果无需频繁的创建代理对象比较适合采用<code>CGLib</code>动态代理技术，反之比较适合<code>JDK</code>动态代理技术</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 源码深度解析》</li><li><a href="https://www.javadoop.com/post/spring-aop-source" target="_blank" rel="noopener">https://www.javadoop.com/post/spring-aop-source</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上一章节介绍了&lt;code&gt;&amp;lt;aop:aspectj-autoproxy/&amp;gt;&lt;/code&gt;的解析过程，最终结果是
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(五二)AOP源码解析之解析AOP自定义标签</title>
    <link href="http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%94%E4%BA%8C)AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%A7%A3%E6%9E%90AOP%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE/"/>
    <id>http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring系列(五二)AOP源码解析之解析AOP自定义标签/</id>
    <published>2019-07-31T16:00:02.000Z</published>
    <updated>2019-06-27T14:42:25.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><ul><li>创建切面类<code>ServiceAspectj</code>，这个方法用于定义切面，功能是打印方法的执行前的输入参数及输出结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAspectj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"execution(* org.springframework.iframe.service..*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String className = pjp.getSignature().getDeclaringType().getSimpleName();</span><br><span class="line">        String methodName = pjp.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"=&gt; [request method: &#123;&#125;#&#123;&#125;]"</span>,className, methodName);</span><br><span class="line">        log.info(<span class="string">"=&gt; [request body: &#123;&#125;]"</span>, JSONObject.toJSONString(pjp.getArgs()));</span><br><span class="line"></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"=&lt; [response method: &#123;&#125;#&#123;&#125;]"</span>,className, methodName);</span><br><span class="line">        log.info(<span class="string">"=&lt; [response result: &#123;&#125; ]"</span>, JSONObject.toJSONString(result));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要切的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findUserByName</span><span class="params">(String userName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(userName,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Role role = roleService.findRoleByUserName(userName);</span></span><br><span class="line">        user.setRole(<span class="keyword">new</span> Role());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Spring</code> 配置文件 <code>beans/bean.xml</code> 添加<code>&lt;aop:aspectj-autoproxy/&gt;</code>配置，开启AOP开关</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                              http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.iframe.entity.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"shop"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ComponentScanBeanDefinitionParser--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"org.springframework.iframe.*"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试类及测试结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext xmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans/bean.xml"</span>);</span><br><span class="line">    UserService userService = xmlApplicationContext.getBean(UserService.class);</span><br><span class="line">    User user1 = userService.findUserByName(<span class="string">"sd"</span>);</span><br><span class="line">    log.info(<span class="string">"user1:&#123;&#125;"</span>, user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:12:06,216 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request method: UserService#findUserByName]</span><br><span class="line">11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request body: ["sd"]]</span><br><span class="line">11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =<span class="tag">&lt; [<span class="attr">response</span> <span class="attr">method:</span> <span class="attr">UserService</span>#<span class="attr">findUserByName</span>]</span></span><br><span class="line">11:12:06,372 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&lt; [response result: &#123;"age":18,"role":&#123;&#125;,"userName":"sd"&#125; ]</span><br></pre></td></tr></table></figure><ul><li><p>从上面的例子可以看到已经实现了这个功能，那么是怎么设计呢？</p><ul><li>首先我们知道<code>AOP</code>是实现横切逻辑的增强，比如在方法执行前额外做一些事，方法执行后额外做一些事</li><li>那我们是不是需要在一个地方定义好什么人在什么时候做什么事情，<code>ServiceAspectj</code>切面类就是做这个事<ul><li>什么人：<code>execution(* org.springframework.iframe.service..*(..))</code> 这里定义了这个包下的所有方法，这些方法就是这些人</li><li>什么时候：<code>@Around</code>注解是环绕的意思，也就是做完正常工作之前和之后做一些额外的事情</li><li>做什么事情：<code>Object doAround(ProceedingJoinPoint pjp)</code>这个方法就是定义了具体做什么事（打印报告）</li></ul></li><li>上面只是些做了些规划书，还没真正起作用，那么这就需要包工头根据规划书来统一规划了，那些人需要做这些事，那些人不需要做这些事</li><li>确认了那些人需要做这些事之后就是通知这些人需要多做一些事了，那么这些人就会执行打印报告的操作</li></ul></li><li><p>那么<code>Spring</code>究竟是如何实现<code>AOP</code>的呢，以后的几个章节将介绍着一块</p></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><code>beans/bean.xml</code> 配置开启<code>AOP</code>开关</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 默认标签</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.iframe.entity.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"shop"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 自定义标签</span><br><span class="line"><span class="comment">&lt;!-- ComponentScanBeanDefinitionParser--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"org.springframework.iframe.*"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">// 自定义标签</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>关注上面配置文件 <code>beans/bean.xml</code> 中的 <code>&lt;aop:aspectj-autoproxy/&gt;</code>配置，之前的<code>Spring系列(五)Document读取器BeanDefinitionDocumentReader</code>章节就介绍了<code>Spring</code>的配置文件分为默认标签的解析及自定义标签的解析，我们现在这个<code>&lt;aop:aspectj-autoproxy/&gt;</code>配置和之前扫包的<code>&lt;context:component-scan</code>配置都属于自定义标签</p><ul><li><p>回顾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the elements at the root level in the document:</span></span><br><span class="line"><span class="comment"> * "import", "alias", "bean".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root the DOM root element of the document</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是默认命名空间 xmlns="http://www.springframework.org/schema/beans"</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="comment">// 默认标签解析 如&lt;bean class=""/&gt;</span></span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 自定义标签解析 如：&lt;context:component-scan base-package = "*"/&gt;</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 自定义标签解析</span></span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入自定义标签解析方法<code>delegate.parseCustomElement(root);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parseCustomElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取xml配置文件中的命名空间http://www.springframework.org/schema/aop</span></span><br><span class="line">String namespaceUri = getNamespaceURI(ele);</span><br><span class="line"><span class="comment">// 根据命名空间找到命名空间处理类AopNamespaceHandler</span></span><br><span class="line">NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析命名空间支持的标签</span></span><br><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里有个<code>NamespaceHandler</code>这个接口是命名空间处理器，它可以根据需求自己来处理我们设置的标签元素。 主要功能是 通过<code>Element</code>标签找到对于的<code>BeanDefinitionParser</code>，找到之后然后调用<code>BeanDefinitionParser</code>接口的<code>parse</code>方法来解析</p><ul><li><code>NamespaceHandler</code>接口 <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/NamespaceHandler.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>命名空间处理器，我们就可以根据需求自己来处理我们设置的标签元素。</li><li>可能需要配置如<code>&lt;aop:config /&gt;</code>这样的标签, 在配置这个标签之前，通常我们需要在<code>xml</code>中引入这个aop所在的命名空间，<code>xmlns:aop=&quot;http://www.springframework.org/schema/aop</code></li><li>只有通过配置<code>aop</code>的命名空间才会找到<code>AOP</code>标签的处理器<code>org.springframework.aop.config.AopNamespaceHandler</code>，在<code>AOP</code>的<code>jar</code>中的<code>spring.handlers</code>配置文件中配置了命名空间和命名空间处理器之间的关系。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>比如我们这里是<code>&lt;aop:aspectj-autoproxy/&gt;</code>标签，所以得到的命名空间处理类是<code>AopNamespaceHandler</code>，那么是怎么得到的呢，关注<code>this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</code>可以看到传入了一个<code>namespaceUri</code></p><ul><li><p>这里是进入到<code>DefaultNamespaceHandlerResolver#resolve</code>方法，可以看到先是调用了<code>getHandlerMappings()</code> 方法读取<code>spring.handlers</code>配置的命名空间的对应关系，保存到了<code>Map&lt;String, Object&gt; handlerMappings</code>中，然后就是调用<code>NamespaceHandler</code>接口的<code>init()</code>方法注册解析类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册handlerMappings</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Locate the &#123;<span class="doctag">@link</span> NamespaceHandler&#125; for the supplied namespace URI</span></span><br><span class="line"><span class="comment"> * from the configured mappings.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> namespaceUri the relevant namespace URI</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the located &#123;<span class="doctag">@link</span> NamespaceHandler&#125;, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">    Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">        <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        String className = (String) handlerOrClassName;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">            <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Class ["</span> + className + <span class="string">"] for namespace ["</span> + namespaceUri +</span><br><span class="line">                        <span class="string">"] does not implement the ["</span> + NamespaceHandler.class.getName() + <span class="string">"] interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// init方法</span></span><br><span class="line">            NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">            namespaceHandler.init();</span><br><span class="line">            handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">            <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line">                    namespaceUri + <span class="string">"] not found"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">"Invalid NamespaceHandler class ["</span> + className + <span class="string">"] for namespace ["</span> +</span><br><span class="line">                    namespaceUri + <span class="string">"]: problem with handler class file or dependent class"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the specified NamespaceHandler mappings lazily.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getHandlerMappings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 在 META-INF/spring.handlers配置文件中有配置对应关系</span></span><br><span class="line">                    Properties mappings = PropertiesLoaderUtils.loadAllProperties(<span class="keyword">this</span>.handlerMappingsLocation, <span class="keyword">this</span>.classLoader);</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Loaded NamespaceHandler mappings: "</span> + mappings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Map&lt;String, Object&gt; handlerMappings = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(mappings.size());</span><br><span class="line">                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);</span><br><span class="line">                    <span class="comment">// 赋值到 Map&lt;String, Object&gt; handlerMappings中</span></span><br><span class="line">                    <span class="keyword">this</span>.handlerMappings = handlerMappings;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                            <span class="string">"Unable to load NamespaceHandler mappings from location ["</span> + <span class="keyword">this</span>.handlerMappingsLocation + <span class="string">"]"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handlerMappings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>namespaceHandler.init();</code>上下几行代码，这里有执行<code>init()</code>方法，下面的逻辑会调用，这个方法是注册标签与相应解析类对应关系的方法</p></li></ul></li><li><p>AopNamespaceHandler.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register the &#123;<span class="doctag">@link</span> BeanDefinitionParser BeanDefinitionParsers&#125; for the</span></span><br><span class="line"><span class="comment">     * '&#123;<span class="doctag">@code</span> config&#125;', '&#123;<span class="doctag">@code</span> spring-configured&#125;', '&#123;<span class="doctag">@code</span> aspectj-autoproxy&#125;'</span></span><br><span class="line"><span class="comment">     * and '&#123;<span class="doctag">@code</span> scoped-proxy&#125;' tags.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// In 2.0 XSD as well as in 2.1 XSD.</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"config"</span>, <span class="keyword">new</span> ConfigBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"aspectj-autoproxy"</span>, <span class="keyword">new</span> AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">        registerBeanDefinitionDecorator(<span class="string">"scoped-proxy"</span>, <span class="keyword">new</span> ScopedProxyBeanDefinitionDecorator());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only in 2.0 XSD: moved to context namespace as of 2.1</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注<code>registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());</code>这行代码这里注册了标签命名与对应解析类的对应关系，并存放在<code>Map&lt;String, BeanDefinitionParser&gt; parsers</code> 对象中，所以现在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinitionParser&gt; parsers = <span class="keyword">new</span> HashMap&lt;String, BeanDefinitionParser&gt;();  </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionParser</span><span class="params">(String elementName, BeanDefinitionParser parser)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.parsers.put(elementName, parser);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h3><ul><li>上面的步骤已经得到了<code>AopNamespaceHandler</code>，然后就是进入<code>handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));</code> 方法开始解析，可以看到逻辑很简单，就是在<code>Map&lt;String, BeanDefinitionParser&gt; parsers</code>中<code>get</code>相应的解析类并调用其<code>parse</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 先找到对应的BeanDefinitionParser 然后执行parse(element, parserContext)方法</span></span><br><span class="line"><span class="comment"> * Parses the supplied &#123;<span class="doctag">@link</span> Element&#125; by delegating to the &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; that is</span></span><br><span class="line"><span class="comment"> * registered for that &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据标签名得到相应的解析类，NamespaceHandler这里起到了一个中介的作用</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> parsers&#125; Map&lt;String, BeanDefinitionParser&gt; 存放着所有的解析类，这个</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locates the &#123;<span class="doctag">@link</span> BeanDefinitionParser&#125; from the register implementations using</span></span><br><span class="line"><span class="comment"> * the local name of the supplied &#123;<span class="doctag">@link</span> Element&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">                <span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们这里<code>&lt;aop:aspectj-autoproxy/&gt;</code>标签得到的是<code>AspectJAutoProxyBeanDefinitionParser</code>解析类</li></ul><h4 id="AspectJAutoProxyBeanDefinitionParser"><a href="#AspectJAutoProxyBeanDefinitionParser" class="headerlink" title="AspectJAutoProxyBeanDefinitionParser"></a>AspectJAutoProxyBeanDefinitionParser</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator AOP的实现基本上是靠这个类来完成的</span></span><br><span class="line">AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line"><span class="comment">// 对于注解中子类的处理</span></span><br><span class="line">extendBeanDefinition(element, parserContext);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendBeanDefinition</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">BeanDefinition beanDef =</span><br><span class="line">parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line"><span class="keyword">if</span> (element.hasChildNodes()) &#123;</span><br><span class="line">addIncludePatterns(element, parserContext, beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addIncludePatterns</span><span class="params">(Element element, ParserContext parserContext, BeanDefinition beanDef)</span> </span>&#123;</span><br><span class="line">ManagedList&lt;TypedStringValue&gt; includePatterns = <span class="keyword">new</span> ManagedList&lt;TypedStringValue&gt;();</span><br><span class="line">NodeList childNodes = element.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childNodes.getLength(); i++) &#123;</span><br><span class="line">Node node = childNodes.item(i);</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">Element includeElement = (Element) node;</span><br><span class="line">TypedStringValue valueHolder = <span class="keyword">new</span> TypedStringValue(includeElement.getAttribute(<span class="string">"name"</span>));</span><br><span class="line">valueHolder.setSource(parserContext.extractSource(includeElement));</span><br><span class="line">includePatterns.add(valueHolder);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!includePatterns.isEmpty()) &#123;</span><br><span class="line">includePatterns.setSource(parserContext.extractSource(element));</span><br><span class="line">beanDef.getPropertyValues().add(<span class="string">"includePatterns"</span>, includePatterns);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关注<code>parse</code>方法，可以看到主要逻辑是注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>这个<code>bean</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册 AnnotationAwareAspectJAutoProxyCreator 对应AOP的实现基本上是靠这个类来完成的</span></span><br><span class="line">    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</span><br><span class="line">    <span class="comment">// 对于注解中子类的处理</span></span><br><span class="line">    extendBeanDefinition(element, parserContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);</code>方法这里是注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>这个<code>bean</code>，<code>RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);</code>这里就把<code>AnnotationAwareAspectJAutoProxyCreator.class</code>给<code>BeanDefinition</code>绑定在一起了，<code>registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</code>方法是将<code>BeanDefinition</code>注册到<code>BeanFactory</code>中了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ParserContext parserContext, Element sourceElement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关键逻辑 注册或升级AutoProxyCreator定义为beanName为org.springframework.aop.config.internalAutoProxyCreator</span></span><br><span class="line">    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(</span><br><span class="line">            parserContext.getRegistry(), parserContext.extractSource(sourceElement));</span><br><span class="line">    <span class="comment">// 对于proxy-target-class(强制使用CGLIB)以及expose-proxy属性的处理</span></span><br><span class="line">    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);</span><br><span class="line">    <span class="comment">// 注册组件并通知，便于监听器做进一步处理</span></span><br><span class="line">    registerComponentIfNecessary(beanDefinition, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// AopConfigUtils#registerAspectJAnnotationAutoProxyCreatorIfNecessary(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line">    <span class="comment">// 如果已经存在了自动代理创建器且存在的自动代理创建器与现在的不一致那么需要根据优先级来判断到底需要使用哪个</span></span><br><span class="line">    <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">            <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">            <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                <span class="comment">// 改变bean最重要的就是改变bean所对应的className属性</span></span><br><span class="line">                apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经存在自动代理创建器并且与将要创建的一致，那么无需再次创建</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">    beanDefinition.setSource(source);</span><br><span class="line">    beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">    <span class="keyword">return</span> beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理<code>proxy-target-class</code>属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">useClassProxyingIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, Element sourceElement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sourceElement != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对proxy-target-class属性的处理 JDK动态代理或者CGLIB</span></span><br><span class="line">        <span class="keyword">boolean</span> proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));</span><br><span class="line">        <span class="keyword">if</span> (proxyTargetClass) &#123;</span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对expose-proxy属性的处理</span></span><br><span class="line">        <span class="keyword">boolean</span> exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));</span><br><span class="line">        <span class="keyword">if</span> (exposeProxy) &#123;</span><br><span class="line">            <span class="comment">// 强制使用的过程其实也是一个属性设置的过程</span></span><br><span class="line">            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConfigBeanDefinitionParser"><a href="#ConfigBeanDefinitionParser" class="headerlink" title="ConfigBeanDefinitionParser"></a>ConfigBeanDefinitionParser</h4><ul><li><code>ConfigBeanDefinitionParser</code>用于解析<code>&lt;aop:config&gt;</code>标签，这种方法是<code>Spring</code>之前版本定义增强切面的方法，不过现在都是使用<code>@AspectJ</code>注解的形式来定义了，所以暂不细究</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用&lt;aop:aspect&gt;元素标签定义切面, 其内部可以定义多个增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"adviceMethods"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"afterExecution"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* com.aop.learn.service.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--adviceMethods bean, 该bean是增强方法所在的类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"adviceMethods"</span> <span class="attr">class</span>=<span class="string">"com.aop.learn.advice.UserAdvice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.aop.learn.service.impl.UserServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>ConfigBeanDefinitionParser</code> 类成员及<code>parse</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigBeanDefinitionParser</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT = <span class="string">"aspect"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXPRESSION = <span class="string">"expression"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ID = <span class="string">"id"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT = <span class="string">"pointcut"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVICE_BEAN_NAME = <span class="string">"adviceBeanName"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVISOR = <span class="string">"advisor"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ADVICE_REF = <span class="string">"advice-ref"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POINTCUT_REF = <span class="string">"pointcut-ref"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REF = <span class="string">"ref"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEFORE = <span class="string">"before"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DECLARE_PARENTS = <span class="string">"declare-parents"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_PATTERN = <span class="string">"types-matching"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_IMPL = <span class="string">"default-impl"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELEGATE_REF = <span class="string">"delegate-ref"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IMPLEMENT_INTERFACE = <span class="string">"implement-interface"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER = <span class="string">"after"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_RETURNING_ELEMENT = <span class="string">"after-returning"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AFTER_THROWING_ELEMENT = <span class="string">"after-throwing"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String AROUND = <span class="string">"around"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RETURNING = <span class="string">"returning"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RETURNING_PROPERTY = <span class="string">"returningName"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THROWING = <span class="string">"throwing"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String THROWING_PROPERTY = <span class="string">"throwingName"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_NAMES = <span class="string">"arg-names"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ARG_NAMES_PROPERTY = <span class="string">"argumentNames"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ASPECT_NAME_PROPERTY = <span class="string">"aspectName"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DECLARATION_ORDER_PROPERTY = <span class="string">"declarationOrder"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORDER_PROPERTY = <span class="string">"order"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> METHOD_INDEX = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> POINTCUT_INDEX = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ASPECT_INSTANCE_FACTORY_INDEX = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ParseState parseState = <span class="keyword">new</span> ParseState();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">CompositeComponentDefinition compositeDef =</span><br><span class="line"><span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));</span><br><span class="line">parserContext.pushContainingComponent(compositeDef);</span><br><span class="line"></span><br><span class="line">configureAutoProxyCreator(parserContext, element);</span><br><span class="line"></span><br><span class="line">List&lt;Element&gt; childElts = DomUtils.getChildElements(element);</span><br><span class="line"><span class="keyword">for</span> (Element elt: childElts) &#123;</span><br><span class="line">String localName = parserContext.getDelegate().getLocalName(elt);</span><br><span class="line"><span class="keyword">if</span> (POINTCUT.equals(localName)) &#123;</span><br><span class="line">parsePointcut(elt, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ADVISOR.equals(localName)) &#123;</span><br><span class="line">parseAdvisor(elt, parserContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ASPECT.equals(localName)) &#123;</span><br><span class="line">parseAspect(elt, parserContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parserContext.popAndRegisterContainingComponent();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在<code>Spring</code>中如果是用<code>xml</code>的方式配置<code>Spring</code>如果需要使用<code>AOP</code>功能，就需要在配置文件中添加<code>&lt;aop:aspectj-autoproxy/&gt;</code>属性，这个是打开<code>AOP</code>功能的开关，这是标签是自定义标签所以具体的解析工作是给<code>AspectJAutoProxyBeanDefinitionParser</code>来完成的，那么<code>Spring</code>是怎么知道这个<code>&lt;aop:aspectj-autoproxy/&gt;</code>由这个类来解析的呢，<code>NamespaceHandler</code>这个接口设计就发挥作用了，<code>aop</code>对应的命名空间处理器是<code>AopNamespaceHandler</code>（对应关系在<code>aop</code>的炸包里的<code>META-INF/spring.handlers</code>里设置），<code>AopNamespaceHandler</code>里面有配置（init方法）<code>aspectj-autoproxy</code>标签对应的解析类是<code>AspectJAutoProxyBeanDefinitionParser</code></li><li><code>&lt;aop:aspectj-autoproxy/&gt;</code> 的最终结果是注册<code>AnnotationAwareAspectJAutoProxyCreator</code> 这个<code>bean</code>，这个类用于创建<code>AOP</code>的代理类</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 源码深度解析》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;简单示例&quot;&gt;&lt;a href=&quot;#简单示例&quot; class=&quot;headerlink&quot; title=&quot;简单示例&quot;&gt;&lt;/a&gt;简单示例&lt;/h
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(五一)AOP切点表达式函数</title>
    <link href="http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%94%E4%B8%80)AOP%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0/"/>
    <id>http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring系列(五一)AOP切点表达式函数/</id>
    <published>2019-07-31T16:00:01.000Z</published>
    <updated>2019-06-22T03:16:27.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Spring支持9个@ApsectJ切点表达式函数，它们用不同的方式描述目标类的连接点，根据描述对象的不同，可以将它们大致分为4种类型： <ul><li>方法切点函数：通过描述目标类方法信息定义连接点； </li><li>方法入参切点函数：通过描述目标类方法入参的信息定义连接点； </li><li>目标类切点函数：通过描述目标类类型信息定义连接点； </li><li>代理类切点函数：通过描述目标类的代理类的信息定义连接点； </li></ul></li><li>这4种类型的切点函数，通过下面的表格进行说明：  <table>      <tr>    <th>类别</th>    <th>函数</th>    <th>入参</th>    <th>说明</th>  </tr>     <tr>    <td rowspan="2">方法切点函数</td>    <td>execution()</td>    <td>方法匹配模式串</td>    <td>表示满足某一匹配模式的所有目标类方法连接点。如execution(* greetTo(..))表示所有目标类中的greetTo()方法。</td>  </tr>      <tr>    <td>@annotation()</td>    <td>方法注解类名</td>    <td>表示标注了特定注解的目标方法连接点。如@annotation(com.baobaotao.anno.NeedTest)表示任何标注了@NeedTest注解的目标类方法。</td>  </tr>    <tr>    <td rowspan="2">方法入参切点函数</td>    <td>args()</td>    <td>类名</td>    <td>通过判别目标类方法运行时入参对象的类型定义指定连接点。如args(com.baobaotao.Waiter)表示所有有且仅有一个按类型匹配于Waiter的入参的方法。</td>  </tr>      <tr>    <td>@args()</td>    <td>类型注解类名</td>    <td>通过判别目标方法的运行时入参对象的类是否标注特定注解来指定连接点。如@args(com.baobaotao.Monitorable)表示任何这样的一个目标方法：它有一个入参且入参对象的类标注@Monitorable注解。</td>  </tr>    <tr>    <td rowspan="4">目标类切点函数</td>    <td>within()</td>    <td>类名匹配串</td>    <td>  表示特定域下的所有连接点。如within(com.baobaotao.service.*)表示com.baobaotao.service包中的所有连接点，也即包中所有类的所有方法，而within(com.baobaotao.service.*Service)表示在com.baobaotao.service包中，所有以Service结尾的类的所有连接点。</td>  </tr>      <tr>    <td>target()</td>    <td>类名</td>    <td>假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过target(com.baobaotao.Waiter)定义的切点，Waiter、以及Waiter实现类NaiveWaiter中所有连接点都匹配该切点。</td>  </tr>    <tr>    <td>@within()</td>    <td>类型注解类名</td>    <td>假如目标类按类型匹配于某个类A，且类A标注了特定注解，则目标类的所有连接点匹配这个切点。如@within(com.baobaotao.Monitorable)定义的切点，假如Waiter类标注了@Monitorable注解，则Waiter以及Waiter实现类NaiveWaiter类的所有连接点都匹配。</td>  </tr>    <tr>    <td>@target()</td>    <td>类型注解类名</td>    <td>  目标类标注了特定注解，则目标类所有连接点匹配该切点。如@target(com.baobaotao.Monitorable)，假如NaiveWaiter标注了@Monitorable，则NaiveWaiter所有连接点匹配切点。</td>  </tr>    <tr>    <td>代理类切点函数</td>    <td>this()</td>    <td>类名</td>    <td>代理类按类型匹配于指定类，则被代理的目标类所有连接点匹配切点。限制连接点匹配 AOP 代理的 Bean 引用为指定类型的类</td>  </tr>    </table></li></ul><h3 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h3><h3 id="execution"><a href="#execution" class="headerlink" title="execution()"></a>execution()</h3><blockquote><p>execution() 是最常见的切点函数,语法形式为</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">excution(&lt;修饰符模式&gt; ? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?)</span><br></pre></td></tr></table></figure><h3 id="切点复合运算"><a href="#切点复合运算" class="headerlink" title="切点复合运算"></a>切点复合运算</h3><ul><li>&amp;&amp;  与运算符<ul><li>&amp; 是特殊运算符，在xml可以使用 &amp;&amp;</li><li>Spring 提供一个等效的运算符<code>and</code></li></ul></li><li>|| 或运算符<ul><li>Spring 提供一个等效的运算符<code>or</code></li></ul></li><li>! 非运算符<ul><li>Spring 提供一个等效的运算符<code>not</code></li></ul></li></ul><p>示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"!target(com.baobaotao.NaiveWaiter) "</span>+</span><br><span class="line"><span class="string">"&amp;&amp; execution(* serveTo(..)))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notServeInNaiveWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"--notServeInNaiveWaiter() executed!--"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"within(com.baobaotao.*) "</span></span><br><span class="line">+ <span class="string">" &amp;&amp; execution(* greetTo(..)))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greeToFun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"--greeToFun() executed!--"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning</span>(<span class="string">"target(com.baobaotao.Waiter) || "</span>+</span><br><span class="line">        <span class="string">" target(com.baobaotao.Seller)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waiterOrSeller</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"--waiterOrSeller() executed!--"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="命名切点"><a href="#命名切点" class="headerlink" title="命名切点"></a>命名切点</h3><ul><li>运用命名切点，可以实现切点表达式的复用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNamePointcut</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只能在本切面类中使用</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.smart.*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inPackage</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在切面类、子切面类中使用</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* greetTo(..)))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共使用</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"inPackage() and greetTo()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inPkgGreetTo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="访问连接点信息"><a href="#访问连接点信息" class="headerlink" title="访问连接点信息"></a>访问连接点信息</h3><h4 id="JoinPoint"><a href="#JoinPoint" class="headerlink" title="JoinPoint"></a>JoinPoint</h4><ul><li>java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；</li><li>Signature getSignature() ：获取连接点的方法签名对象；</li><li>java.lang.Object getTarget() ：获取连接点所在的目标对象；</li><li>java.lang.Object getThis() ：获取代理对象本身；</li></ul><h4 id="ProceedingJoinPoint-（ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：）"><a href="#ProceedingJoinPoint-（ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：）" class="headerlink" title="ProceedingJoinPoint （ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：）"></a>ProceedingJoinPoint （ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：）</h4><ul><li><p>java.lang.Object proceed() throws java.lang.Throwable：通过反射执行目标对象的连接点处的方法；</p></li><li><p>java.lang.Object proceed(java.lang.Object[] args) throws java.lang.Throwable：通过反射执行目标对象连接点处的方法，不过使用新的入参替换原来的入参。</p></li></ul><h2 id="切点表达式例子"><a href="#切点表达式例子" class="headerlink" title="切点表达式例子"></a>切点表达式例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配所有目标类的public方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public * *(..))"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配所有以To为后缀的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* *To(..))"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配Waiter接口中的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.aop.learn.service.Writer.*(..))"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配Waiter接口中及其实现类的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.aop.learn.service.Writer+.*(..))"</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 com.aop.learn.service 包下所有类的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.aop.learn.service.*(..))"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 com.aop.learn.service 包,子孙包下所有类的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.aop.learn.service..*(..))"</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 包名前缀为com的任何包下类名后缀为ive的方法,方法必须以Smart为前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com..*.*ive.Smart*(..))"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 save(String name,int age) 函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* save(String,int))"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 save(String name,*) 函数 第二个参数为任意类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* save(String,*))"</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 save(String name,..) 函数 除第一个参数固定外,接受后面有任意个入参且入参类型不限</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* save(String,..))"</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 save(String+) 函数  String+ 表示入参类型是String的子类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* save(String+))"</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最详细的切入点表达式  具体到包、类名、方法名、方法返回值、参数个数及类型类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public void com.bwlu.aop.MathCalculator.add(int, int))"</span>)</span><br><span class="line">      </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最模糊的切入点表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution (* *.*(..))"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MathCalculator中的任意方法,任意参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public void com.bwlu.aop.MathCalculator.*(..))"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * MathCalculator中的任意方法,任意参数列表，任意返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public * com.bwlu.aop.MathCalculator.*(..))"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * MathCalculator中的任意方法,任意参数列表，任意返回值，任意访问修饰符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution( * com.bwlu.aop.MathCalculator.*(..))"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匹配Controller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@within</span> :使用 “<span class="doctag">@within</span>(注解类型)” 匹配所以持有指定注解类型内的方法;注解类型也必须是全限定类型名;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excudeService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《精通Spring+4.x++企业应用开发实战》</li><li><a href="https://blog.csdn.net/yangshangwei/article/details/77943720" target="_blank" rel="noopener">https://blog.csdn.net/yangshangwei/article/details/77943720</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Spring支持9个@ApsectJ切点表达式函数，它们用不同的方式描述目标类的连接点，根据描述对象的不同，可以将它们大致分为4
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(五十)面向切面编程AOP</title>
    <link href="http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%94%E5%8D%81)%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8BAOP/"/>
    <id>http://www.songshuiyang.com/2019/08/01/backend/framework/spring/analysis/Spring系列(五十)面向切面编程AOP/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-06-24T15:27:09.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3><ul><li>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。</li></ul><h3 id="为什么要用Aop"><a href="#为什么要用Aop" class="headerlink" title="为什么要用Aop"></a>为什么要用Aop</h3><ul><li><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></li><li><p>在不改变原有方法的基础添加一些功能 , 比如:</p><ul><li>日志记录</li><li>性能统计</li><li>安全控制</li><li>事务处理</li><li>异常处理等等</li></ul></li></ul><a id="more"></a><h3 id="Aop-术语"><a href="#Aop-术语" class="headerlink" title="Aop 术语"></a>Aop 术语</h3><blockquote><p>连接点(JoinPoint)</p></blockquote><p> 程序执行到某个特定位置，如类开始初始化前，类初始化后，某个方法调用前/后，方法抛出异常后，一些具有边界性质的特定点就是连接点， Spring 仅支持方法级的连接点(方法执行前，方法完成后，抛出异常后)</p><blockquote><p>切点(Pointcut)</p></blockquote><p> 从连接点的基础上引出的概念，是指特定的连接点，一个类有好多方法,每个方法又有多个连接点，则需要切点来限定一个小范围的连接点，在Spring中是使用类和方法作为连接点的查询条件</p><blockquote><p>通知、增强处理(Advice)</p></blockquote><p> 就是指你所需要添加的功能及这个功能什么时候(通知)实现 , 比如一个业务方法需要实现日志功能 , 那么就需要专门在一个地方定义好需要做什么，然后定义什么时候执行(方法执行前？，方法完成后？，抛出异常？。。。)</p><p>   Spring 切面可应用的 5 种通知类型：</p><ol><li>Before——在方法调用之前调用通知</li><li>After——在方法完成之后调用通知，无论方法执行成功与否</li><li>After-returning——在方法执行成功之后调用通知</li><li>After-throwing——在方法抛出异常后进行通知</li><li>Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li></ol><blockquote><p>引入(introduction)</p></blockquote><p>  特殊的增强，为类添加一些属性和方法，这样即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类</p><blockquote><p>切面(Aspect)</p></blockquote><p> 切面由切点和增强组成 , 及包括横切逻辑的定义，也包括切点的定义, </p><blockquote><p>目标对象(Target)</p></blockquote><p> 增强逻辑的织入目标类 , 如果没有Aop,那么目标对象就要自己实现(日志记录，性能统计，安全控制，事务处理，异常处理)这些功能，那么一个方法就会变成很杂乱</p><blockquote><p>织入(Weaing)</p></blockquote><p> 将增强添加到目标对象的具体连接点上, Spring使用动态代理织入</p><p> Aop有三种织入方式</p><ol><li>编译期织入</li><li>类装载期织入</li><li>动态代理织入: 在运行期间为目标类添加增强生成子类的方式</li></ol><h3 id="Aop-实现"><a href="#Aop-实现" class="headerlink" title="Aop 实现"></a>Aop 实现</h3><ul><li><p><code>JDK</code>动态代理</p></li><li><p><code>CGLib</code>动态代理</p></li></ul><h4 id="代理知识总结"><a href="#代理知识总结" class="headerlink" title="代理知识总结"></a>代理知识总结</h4><ul><li><code>Spring</code>使用<code>JDK</code>动态代理和<code>CGLib</code>动态代理技术在运行期织入增强，要使用<code>JDK</code>动态代理，目标类必须实现接口，而<code>CGLib</code>不对目标类作任何限制，他是通过动态生成目标类子类的方式提供代理</li><li><code>JDK</code>在创建代理对象时的性能高于<code>CGLib</code>，但生成的代理对象的运行性能却比<code>CGLib</code>的低，如果无需频繁的创建代理对象比较适合采用<code>CGLib</code>动态代理技术，反之比较适合<code>JDK</code>动态代理技术</li></ul><h3 id="AOP示例"><a href="#AOP示例" class="headerlink" title="AOP示例"></a>AOP示例</h3><ul><li>创建切面类<code>ServiceAspectj</code>，这个方法用于定义切面，功能是打印方法的执行前的输入参数及输出结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAspectj</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(value = <span class="string">"execution(* org.springframework.iframe.service..*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String className = pjp.getSignature().getDeclaringType().getSimpleName();</span><br><span class="line">        String methodName = pjp.getSignature().getName();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"=&gt; [request method: &#123;&#125;#&#123;&#125;]"</span>,className, methodName);</span><br><span class="line">        log.info(<span class="string">"=&gt; [request body: &#123;&#125;]"</span>, JSONObject.toJSONString(pjp.getArgs()));</span><br><span class="line"></span><br><span class="line">        Object result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"=&lt; [response method: &#123;&#125;#&#123;&#125;]"</span>,className, methodName);</span><br><span class="line">        log.info(<span class="string">"=&lt; [response result: &#123;&#125; ]"</span>, JSONObject.toJSONString(result));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要切的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findUserByName</span><span class="params">(String userName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserByName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(userName,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Role role = roleService.findRoleByUserName(userName);</span></span><br><span class="line">        user.setRole(<span class="keyword">new</span> Role());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Spring</code> 配置文件 <code>beans/bean.xml</code> 添加<code>&lt;aop:aspectj-autoproxy/&gt;</code>配置，开启AOP开关</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                              http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.iframe.entity.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"shop"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ComponentScanBeanDefinitionParser--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span> = <span class="string">"org.springframework.iframe.*"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试类及测试结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext xmlApplicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans/bean.xml"</span>);</span><br><span class="line">    UserService userService = xmlApplicationContext.getBean(UserService.class);</span><br><span class="line">    User user1 = userService.findUserByName(<span class="string">"sd"</span>);</span><br><span class="line">    log.info(<span class="string">"user1:&#123;&#125;"</span>, user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:12:06,216 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request method: UserService#findUserByName]</span><br><span class="line">11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request body: ["sd"]]</span><br><span class="line">11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =<span class="tag">&lt; [<span class="attr">response</span> <span class="attr">method:</span> <span class="attr">UserService</span>#<span class="attr">findUserByName</span>]</span></span><br><span class="line">11:12:06,372 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&lt; [response result: &#123;"age":18,"role":&#123;&#125;,"userName":"sd"&#125; ]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>AOP的工作重心就是将增强应用与目标对象的连接点上，这里包括两部分内容：<ul><li>如何通过切点和增强定位到连接点上</li><li>如何在增强中编写切面的逻辑</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《精通Spring+4.x++企业应用开发实战》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;什么是AOP&quot;&gt;&lt;a href=&quot;#什么是AOP&quot; class=&quot;headerlink&quot; title=&quot;什么是AOP&quot;&gt;&lt;/a&gt;什么是AOP&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为什么要用Aop&quot;&gt;&lt;a href=&quot;#为什么要用Aop&quot; class=&quot;headerlink&quot; title=&quot;为什么要用Aop&quot;&gt;&lt;/a&gt;为什么要用Aop&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在不改变原有方法的基础添加一些功能 , 比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志记录&lt;/li&gt;
&lt;li&gt;性能统计&lt;/li&gt;
&lt;li&gt;安全控制&lt;/li&gt;
&lt;li&gt;事务处理&lt;/li&gt;
&lt;li&gt;异常处理等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(三十)ApplicationContext分析</title>
    <link href="http://www.songshuiyang.com/2019/07/02/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%B8%89%E4%B8%80)ApplicationContext%E5%88%86%E6%9E%90/"/>
    <id>http://www.songshuiyang.com/2019/07/02/backend/framework/spring/analysis/Spring系列(三一)ApplicationContext分析/</id>
    <published>2019-07-02T14:02:46.000Z</published>
    <updated>2019-06-24T15:36:10.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>BeanFactory</code> 是容器的顶级抽象，它并不适用于我们生产环境，在生产环境我们通常会选择 <code>ApplicationContext</code> ，相对于大多数人而言，它才是正规军，相比于 <code>BeanFactory</code> 这个杂牌军而言，它由如下几个区别：<ul><li>继承 <code>MessageSource</code>，提供国际化的标准访问策略。</li><li>继承 <code>ApplicationEventPublisher</code> ，提供强大的事件机制。</li><li>扩展 <code>ResourceLoader</code>，可以用来加载多个 <code>Resource</code>，可以灵活访问不同的资源。</li><li>对 <code>Web</code> 应用的支持。</li></ul></li></ul><h3 id="ApplicationContext-接口"><a href="#ApplicationContext-接口" class="headerlink" title="ApplicationContext 接口"></a>ApplicationContext 接口</h3><ul><li>接口代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">EnvironmentCapable</span>, <span class="title">ListableBeanFactory</span>, <span class="title">HierarchicalBeanFactory</span>,</span></span><br><span class="line"><span class="class"><span class="title">MessageSource</span>, <span class="title">ApplicationEventPublisher</span>, <span class="title">ResourcePatternResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getApplicationName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">getDisplayName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getStartupDate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ApplicationContext <span class="title">getParent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">AutowireCapableBeanFactory <span class="title">getAutowireCapableBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类继承关系<ul><li><code>BeanFactory</code><ul><li><code>Spring</code> 管理 <code>Bean</code> 的顶层接口，我们可以认为他是一个简易版的 <code>Spring</code> 容器。<code>ApplicationContext</code> 继承 <code>BeanFactory</code> 的两个子类：<code>HierarchicalBeanFactory</code> 和 <code>ListableBeanFactory</code>。</li></ul></li><li><code>HierarchicalBeanFactory</code> 是一个具有层级关系的 <code>BeanFactory</code>，拥有属性 <code>parentBeanFactory</code> 。</li><li><code>ListableBeanFactory</code> 实现了枚举方法可以列举出当前 <code>BeanFactory</code> 中所有的 <code>bean</code> 对象而不必根据 <code>name</code> 一个一个的获取。</li><li><code>ApplicationEventPublisher</code><ul><li>用于封装事件发布功能的接口，向事件监听器（<code>Listener</code>）发送事件消息。</li></ul></li><li><code>ResourceLoader</code><ul><li>Spring 加载资源的顶层接口，用于从一个源加载资源文件。<code>ApplicationContext</code> 继承 <code>ResourceLoader</code> 的子类 <code>ResourcePatternResolver</code>，该接口是将 <code>location</code> 解析为 <code>Resource</code> 对象的策略接口。</li></ul></li><li><code>MessageSource</code><ul><li>解析 <code>message</code> 的策略接口，用不支撑国际化等功能。</li></ul></li><li><code>EnvironmentCapable</code><ul><li>用于获取 <code>Environment</code> 的接口。</li></ul></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/ApplicationContext.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>接口方法(包括父类方法)</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/ApplicationContextMethod.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="ApplicationContext-常用子类"><a href="#ApplicationContext-常用子类" class="headerlink" title="ApplicationContext 常用子类"></a>ApplicationContext 常用子类</h3><h5 id="1、-WebApplicationContext"><a href="#1、-WebApplicationContext" class="headerlink" title="1、 WebApplicationContext"></a>1、 WebApplicationContext</h5><ul><li>该接口只有一个 <code>#getServletContext()</code> 方法，用于给 <code>Servlet</code> 提供上下文信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServletContext <span class="title">getServletContext</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、-ClassPathXmlApplicationContext"><a href="#2、-ClassPathXmlApplicationContext" class="headerlink" title="2、 ClassPathXmlApplicationContext"></a>2、 ClassPathXmlApplicationContext</h5><ul><li><code>ClassPathXmlApplicationContext</code> 是我们在学习 <code>Spring</code> 过程中用的非常多的一个类</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/ClassPathXmlApplicationContext.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>ClassPathXmlApplicationContext</code> 设计的顶级接口<ul><li><code>BeanFactory</code><ul><li>Spring 容器 Bean 的管理</li></ul></li><li><code>MessageSource</code><ul><li>管理 message ，实现国际化等功能</li></ul></li><li><code>ApplicationEventPublisher</code><ul><li>事件发布,用于封装事件发布功能的接口，向事件监听器（Listener）发送事件消息。</li></ul></li><li><code>ResourcePatternResolver</code><ul><li>资源加载</li></ul></li><li><code>EnvironmentCapable</code><ul><li>系统 Environment（profile + Properties） 相关</li></ul></li><li><code>Lifecycle</code><ul><li>管理生命周期</li></ul></li><li><code>Closable</code><ul><li>关闭，释放资源,用于关闭 ApplicationContext 销毁所有 Bean </li></ul></li><li><code>InitializingBean</code><ul><li>自定义初始化</li></ul></li><li><code>BeanNameAware</code><ul><li>设置 beanName 的 Aware 接口</li></ul></li></ul></li></ul><h5 id="3、ConfigurableApplicationContext"><a href="#3、ConfigurableApplicationContext" class="headerlink" title="3、ConfigurableApplicationContext"></a>3、ConfigurableApplicationContext</h5><ul><li>接口 <code>ConfigurableApplicationContext</code> 对 <code>ApplicationContext</code> 接口再次进行扩展，提供了生命周期的管理功能。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>Spring</code> 真的是一个非常优秀的框架，具有良好的结构设计和接口抽象，它的每一个接口职能单一，且都是具体功能到各个模块的高度抽象，且几乎每套接口都提供了一个默认的实现<code>（defaultXXX）</code>。</p></li><li><p>抽象类 <code>ApplicationContext</code> 对整套接口提供了大部分的默认实现，将其中“不易变动”的部分进行了封装，通过“组合”的方式将“容易变动”的功能委托给其他类来实现，同时利用模板方法模式将一些方法的实现开放出去由子类实现，从而实现“对扩展开放，对修改封闭”的设计原则。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanFactory&lt;/code&gt; 是容器的顶级抽象，它并不适用于我们生产环境，在生产环境我们通常会选择 &lt;cod
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(三十)IOC容器技术内幕</title>
    <link href="http://www.songshuiyang.com/2019/07/02/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%B8%89%E5%8D%81)IOC%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/"/>
    <id>http://www.songshuiyang.com/2019/07/02/backend/framework/spring/analysis/Spring系列(三十)IOC容器技术内幕/</id>
    <published>2019-07-02T14:02:45.000Z</published>
    <updated>2019-06-22T01:59:21.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="IOC是什么"><a href="#IOC是什么" class="headerlink" title="IOC是什么"></a>IOC是什么</h3><ul><li><code>Ioc—Inversion of Control</code>，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：<ul><li>谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；<code>谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</code></li><li>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；<code>而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</code></li></ul></li><li>用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/ioc1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/ioc2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><ul><li><p><code>Dependency Injection</code> 即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p></li><li><p>那么IOC和DI这两者又是什么关系呢？　IOC就是一种软件设计思想，DI是这种软件设计思想的一个实现。而Spring中的核心机制就是DI。</p></li></ul><h3 id="IOC注入形式"><a href="#IOC注入形式" class="headerlink" title="IOC注入形式"></a>IOC注入形式</h3><ul><li>构造函数注入<ul><li>通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 </li></ul></li><li>setter 方法注入<ul><li>当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中</li></ul></li><li>接口注入<ul><li>接口方式注入需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</li></ul></li></ul><blockquote><p>Spring支持前两种依赖注入方式</p></blockquote><h2 id="Spring-容器"><a href="#Spring-容器" class="headerlink" title="Spring 容器"></a>Spring 容器</h2><blockquote><p>该图为 ClassPathXmlApplicationContext 的类继承体系结构，虽然只有一部分，但是它基本上包含了 IoC 体系中大部分的核心类和接口。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/ioc.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>如果将Spring容器比作一辆车，那么可以将<code>BeanFactory</code>看成汽车的发动机，而<code>ApplicationContext</code>则是一辆完整的汽车，它不但包括发动机，还包括离合器、变速器及底盘、车身、电气设备等其他组件。在<code>ApplicationContext</code>内，各个组件按部就班、有条不絮地完成汽车的各项功能。</li></ul><h3 id="内部工作机制"><a href="#内部工作机制" class="headerlink" title="内部工作机制"></a>内部工作机制</h3><h4 id="Spring-容器启动逻辑"><a href="#Spring-容器启动逻辑" class="headerlink" title="Spring 容器启动逻辑"></a>Spring 容器启动逻辑</h4><ul><li>Spring的<code>AbstractApplicationContext</code>是<code>ApplicationContext</code>的抽象实现类，该抽象类的<code>refresh()</code>方法定义了Spring容器在加载配置文件后的各项处理过程，这些处理过程清新地刻画了Spring容器启动时所执行地各项操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 初始化BeanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，</span></span><br><span class="line">            <span class="comment">// 并调用其postProcessBeanFactory接口方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean，</span></span><br><span class="line">            <span class="comment">// 并将它们注册到容器Bean后处理器的注册表中</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 初始化消息源 初始化容器的国际化消息资源</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// 初始化应用上下文事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 初始化其他特殊的bean，由具体子类实现，这是个钩子方法</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 注册事件监听器</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 初始化所有单实例的Bean，使用懒加载模式的bean除外，初始化Bean后将它们放到Spring容器的缓冲池中</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">// 完成刷新并发布容器刷新事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="处理流程图"><a href="#处理流程图" class="headerlink" title="处理流程图"></a>处理流程图</h4><ul><li>Spring容器从加载配置文件到创建一个完整Bean的作业流程及参与的角色</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/ioc4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>由上图可以得到Spring容器的构造逻辑，如下：</p><ul><li>1、ResourceLoader从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件资源；</li><li>2、BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个<bean>解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中；</bean></li><li>3、容器扫描BeanDefintionRegistry中的BeanDefintion，使用Java反射机制自动识别出Bean工厂后处理器(实现BeanFactoryPostProcessor接口的Bean)，然后调用这些Bean工厂后处理对BeanDefinitionRegistry中的BeanDefinition进行加工处理。主要完成一下两项工作:<ul><li>1). 对使用占位符的&lt; bean &gt;元素标签进行解析，得到最终的配置值。这意味着对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象；</li><li>2). 对BeanDefinitionRegistry中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean(实现java.beans.PropertyEditor接口的Bean)，并自动将它们注册到Spring容器的属性器注册表中(PropertyEditorRegistry)。</li></ul></li><li>4、Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，并调用InstantiationStarategy着手进行Bean实例化的工作；</li><li>5、在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装。BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefintion及容器中的属性编辑器，完成Bean属性注入工作；</li><li>6、利用容器中的Bean后处理器(实现BeanPostProcessor接口的Bean)对己经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean；<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4></li></ul></li><li><p>Spring容器堪称一部设计精密的机器，其内部拥有众多的组件和装置。Spring的高明之处在于，它使用众多接口描绘除了所有的装置的协作蓝图，构建好Spring的骨架，继而通过继承体系层层推演、不断丰富，最终让Spring成为有血有肉的完整的框架。所有在查看Spring框架的源码时，有两条清晰可见的脉络：</p><ul><li>接口层描述了容器的重要组件及组件间的协作关系</li><li>继承体系逐步实现组件的各项功能。</li></ul></li><li>接口层清晰地勾勒出Spring框架地高层功能，框架脉络呼之欲出。有了接口层抽象地描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同的实现，可以说Spring完善的接口层使框架的扩展性得到了很好的保证</li><li>纵向继承体系的逐步发展，分步骤地实现框架地功能，这种实现方案保证了框架功能不会堆积在某些类身上，从而造成过重地代码逻辑负载，框架的复杂度被完美地分解开了。</li><li>Spring可以就像一个餐馆，为顾客提供各种各样的美味佳肴，那么它是怎样做出美味的饭菜呢？<ul><li>Spring的设计者就是餐馆的老板，统筹规划餐馆的运作</li><li>原始食材：<code>xml配置的bean</code> ，高级一点的原始食材<code>注解配置的bean</code>，加工后的食材：<code>Resource</code> <code>BeanDefinition</code> <code>PropertyEditor</code></li><li>采购员：<code>ResourceLoader</code>，择菜员：<code>BeanDefinitionReader</code>，仓库：<code>BeanDefintionRegistry</code> ,厨师就是将准备好的食材烹饪为菜肴<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></li></ul></li></ul><h4 id="在Spring也可以注入List-Map"><a href="#在Spring也可以注入List-Map" class="headerlink" title="在Spring也可以注入List/Map"></a>在Spring也可以注入List/Map</h4><ul><li><p>之前一直使用xml的方式进行Spring配置，对于内部元素为String的List和Map属性的注入一般为如下方式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id = <span class="string">"testBean"</span> <span class="class"><span class="keyword">class</span> </span>= <span class="string">"com.a.b.c.TestBean"</span>&gt;</span><br><span class="line">    &lt;property name = <span class="string">"fieldMap"</span>&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key = "field1" value = "value1"&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key = "field2" value = "value2"&gt;&lt;/entry&gt;</span><br><span class="line">            &lt;entry key = "field3" value = "value3"&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name = <span class="string">"fieldList"</span>&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果内部元素为Bean，则将value替换为value-ref或元素即可。</p></li><li><p>当然，我们也可以使用Spring提供的schema扩展util来实现List和Map的声明、注入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:util=<span class="string">"http://www.springframework.org/schema/util"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/util</span></span><br><span class="line"><span class="string">    http://www.springframework.org/schema/util/spring-util-2.5.xsd"</span>&gt;</span><br><span class="line">    &lt;util:list list-<span class="class"><span class="keyword">class</span></span>=<span class="string">"java.util.ArrayList"</span>&gt;</span><br><span class="line">        &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;/util:list&gt;</span><br><span class="line">    &lt;util:map map-<span class="class"><span class="keyword">class</span></span>=<span class="string">"java.util.HashMap"</span>&gt;</span><br><span class="line">        &lt;entry key=<span class="string">"Key1"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">        &lt;entry key=<span class="string">"Key2"</span> value=<span class="string">"2"</span> /&gt;</span><br><span class="line">        &lt;entry key=<span class="string">"Key3"</span> value=<span class="string">"3"</span> /&gt;</span><br><span class="line">    &lt;/util:map&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>目前多用注解的方式来注入String类型的List和Map：</p></li></ul><blockquote><p>properties.yml<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.map = &#123;key1:<span class="string">'value1'</span>,key2:<span class="string">'value2'</span>,key3:<span class="string">'value3'</span>&#125;</span><br><span class="line">test.list = value1,value2,value3</span><br></pre></td></tr></table></figure></p><p>在目标Bean中使用@Value注解进行注入：</p><pre><code class="java"><span class="meta">@Value</span>(<span class="string">"#{'${test.list}'.split(',')}"</span>)<span class="keyword">private</span> List&lt;String&gt; testList;<span class="meta">@Value</span>(<span class="string">"#{${test.map}}"</span>)<span class="keyword">private</span> Map&lt;String,String&gt; testMap;</code></pre></blockquote><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《精通Spring+4.x++企业应用开发实战》</li><li><a href="https://jinnianshilongnian.iteye.com/blog/1413846" target="_blank" rel="noopener">https://jinnianshilongnian.iteye.com/blog/1413846</a></li><li><a href="http://www.cnblogs.com/xdp-gacl/p/4249939.html" target="_blank" rel="noopener">http://www.cnblogs.com/xdp-gacl/p/4249939.html</a></li><li><a href="https://blog.csdn.net/li_xiao_dai/article/details/80667246" target="_blank" rel="noopener">https://blog.csdn.net/li_xiao_dai/article/details/80667246</a></li><li><a href="https://www.cnblogs.com/xiao2/p/7706902.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiao2/p/7706902.html</a></li><li><a href="http://svip.iocoder.cn/Spring/IoC-intro/" target="_blank" rel="noopener">http://svip.iocoder.cn/Spring/IoC-intro/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;IOC是什么&quot;&gt;&lt;a href=&quot;#IOC是什么&quot; class=&quot;headerlink&quot; title=&quot;IOC是什么&quot;&gt;&lt;/a&gt;I
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(二三)PropertySource及Environment及Profile接口分析</title>
    <link href="http://www.songshuiyang.com/2019/07/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%8C%E4%B8%89)PropertySource%E5%8F%8AEnvironment%E5%8F%8AProfile%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/"/>
    <id>http://www.songshuiyang.com/2019/07/01/backend/framework/spring/analysis/Spring系列(二三)PropertySource及Environment及Profile接口分析/</id>
    <published>2019-07-01T15:01:46.000Z</published>
    <updated>2019-06-22T03:26:43.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>spring.profiles.active</code> 和 <code>@Profile</code> 这两个我相信各位都熟悉吧，主要功能是可以实现不同环境下（开发、测试、生产）参数配置的切换。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><code>Spring</code> 环境 &amp; 属性由四个部分组成：<code>PropertySource、PropertyResolver、Profile</code> 和 <code>Environment</code>。</li></ul><h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="PropertySource"></a>PropertySource</h3><ul><li>属性源，<code>key-value</code> 属性对抽象，用于配置数据。</li></ul><h3 id="PropertyResolver"><a href="#PropertyResolver" class="headerlink" title="PropertyResolver"></a>PropertyResolver</h3><ul><li>属性解析器，用于解析任何基础源的属性的接口</li></ul><h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><ul><li>剖面，只有激活的剖面的组件/配置才会注册到 <code>Spring</code> 容器，类似于 <code>Spring Boot</code> 中的 <code>profile</code> 。</li></ul><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><ul><li><code>Environment</code> 对象的作用，是确定哪些配置文件（如果有）当前处于活动状态，以及默认情况下哪些配置文件（如果有）应处于活动状态。properties 在几乎所有应用程序中都发挥着重要作用，并且有多种来源：属性文件，JVM 系统属性，系统环境变量，JNDI，servlet 上下文参数，ad-hoc 属性对象，映射等。同时它继承 PropertyResolver 接口，所以与属性相关的 Environment 对象其主要是为用户提供方便的服务接口，用于配置属性源和从中属性源中解析属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Environment.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Environment</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回此环境下激活的配置文件集</span></span><br><span class="line">    String[] getActiveProfiles();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未设置激活配置文件，则返回默认的激活的配置文件集</span></span><br><span class="line">    String[] getDefaultProfiles();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 源码深度解析》</li><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;spring.profiles.active&lt;/code&gt; 和 &lt;code&gt;@Profile&lt;/code&gt; 这两个我
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(二二)BeanFactoryPostProcessor接口分析</title>
    <link href="http://www.songshuiyang.com/2019/07/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%8C%E4%BA%8C)BeanFactoryPostProcessor%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/"/>
    <id>http://www.songshuiyang.com/2019/07/01/backend/framework/spring/analysis/Spring系列(二二)BeanFactoryPostProcessor接口分析/</id>
    <published>2019-07-01T14:01:47.000Z</published>
    <updated>2019-06-27T12:50:57.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>前面我们知道<code>BeanPostProcessor</code>是<code>Spring</code> 的一个工厂钩子，使用户可以对实例化后的<code>Bean</code>初始化之际对 <code>Bean</code> 进行增强处理（前、后置处理），同样在 <code>Spring</code> 容器启动阶段，<code>Spring</code> 也提供了一种容器扩展机制：<code>BeanFactoryPostProcessor</code>，该机制作用于容器启动阶段，允许我们在容器实例化 <code>Bean</code> 之前对注册到该容器的 <code>BeanDefinition</code> 做出修改。</p></li><li><p><code>BeanFactoryPostProcessor</code> 的机制，就相当于给了我们在 <code>Bean</code> 实例化之前最后一次修改 <code>BeanDefinition</code> 的机会，我们可以利用这个机会对 <code>BeanDefinition</code> 来进行一些额外的操作，比如更改某些 <code>bean</code> 的一些属性，给某些 <code>Bean</code> 增加一些其他的信息等等操作。</p></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="BeanFactoryPostProcessor-接口定义"><a href="#BeanFactoryPostProcessor-接口定义" class="headerlink" title="BeanFactoryPostProcessor 接口定义"></a>BeanFactoryPostProcessor 接口定义</h3><ul><li><code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code> 接口，定义如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这个方法工作于 <code>BeanDefinition</code> 加载完成之后，<code>Bean</code>实例化之前，其主要作用是对加载 <code>BeanDefinition</code> 进行修改</p></li><li><p>有一点需要需要注意的是在 <code>#postProcessBeanFactory(...)</code> 方法中千万不能进行 <code>Bean</code> 的实例化工作，因为这样会导致 <code>Bean</code> 过早实例化，会产生严重后果</p></li><li><p>我们始终需要注意的是 <code>BeanFactoryPostProcessor</code> 是与 <code>BeanDefinition</code> 打交道的，如果想要与 <code>Bean</code> 打交道，请使用 <code>BeanPostProcessor</code> 。</p></li><li><p>与 <code>BeanPostProcessor</code> 一样，<code>BeanFactoryPostProcessor</code> 同样支持排序，一个容器可以同时拥有多个 <code>BeanFactoryPostProcessor</code> ，这个时候如果我们比较在乎他们的顺序的话，可以实现 <code>Ordered</code> 接口。</p></li></ul><h3 id="BeanFactoryPostProcessor-在哪里调用"><a href="#BeanFactoryPostProcessor-在哪里调用" class="headerlink" title="BeanFactoryPostProcessor 在哪里调用"></a>BeanFactoryPostProcessor 在哪里调用</h3><ul><li>回到<code>org.springframework.context.support.AbstractApplicationContext#refresh</code>方法，关注<code>invokeBeanFactoryPostProcessors(beanFactory);</code>方法，见名知其意执行<code>BeanFactoryPostProcessor</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        <span class="comment">// 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开</span></span><br><span class="line">        <span class="comment">// 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 子类覆盖方法做额外的处理</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，</span></span><br><span class="line">            <span class="comment">// 并调用其postProcessBeanFactory接口方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            </span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><ul><li>进入<code>invokeBeanFactoryPostProcessors(beanFactory);</code>方法，这里出现了一个新的委托类<code>PostProcessorRegistrationDelegate</code> ，委托执行<code>post processors</code>任务的工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化BeanFactoryPostProcessor实例及执行其接口方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进入<code>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the given BeanFactoryPostProcessor beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        postProcessor.postProcessBeanFactory(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanFactoryPostProcessor-子类"><a href="#BeanFactoryPostProcessor-子类" class="headerlink" title="BeanFactoryPostProcessor 子类"></a>BeanFactoryPostProcessor 子类</h3><h5 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h5><ul><li>允许我们在 <code>XML</code> 配置文件中使用占位符并将这些占位符所代表的资源单独配置到简单的 <code>properties</code> 文件中来加载</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 源码深度解析》</li><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li><li><a href="https://blog.csdn.net/andy_zhang2007/article/details/78530137" target="_blank" rel="noopener">https://blog.csdn.net/andy_zhang2007/article/details/78530137</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;前面我们知道&lt;code&gt;BeanPostProcessor&lt;/code&gt;是&lt;code&gt;Spring&lt;/code&gt; 的一个工
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列(二一)BeanPostProcessor接口分析</title>
    <link href="http://www.songshuiyang.com/2019/07/01/backend/framework/spring/analysis/Spring%E7%B3%BB%E5%88%97(%E4%BA%8C%E4%B8%80)BeanPostProcessor%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/"/>
    <id>http://www.songshuiyang.com/2019/07/01/backend/framework/spring/analysis/Spring系列(二一)BeanPostProcessor接口分析/</id>
    <published>2019-07-01T14:01:46.000Z</published>
    <updated>2019-06-26T14:19:49.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><code>BeanPostProcessor</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>BeanPostProcessor</code> 可以理解为是 <code>Spring</code> 的一个工厂钩子（其实 <code>Spring</code> 提供一系列的钩子，如 <code>Aware 、InitializingBean、DisposableBean）</code>，它是 <code>Spring</code> 提供的对象实例化阶段强有力的扩展点，允许 <code>Spring</code> 在实例化 <code>bean</code> 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如 <code>AOP</code>）。</p></li><li><p><code>#postProcessBeforeInitialization(Object bean, String beanName)</code> 和 <code>#postProcessAfterInitialization(Object bean, String beanName)</code> 两个方法，都接收一个 <code>Object</code> 类型的 <code>bean</code> ，一个 <code>String</code> 类型的 <code>beanName</code> ，其中<code>bean</code> 是已经实例化了的 <code>instanceBean</code> ，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 <code>bean</code> 的前后置处理器，他们应用 <code>#invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)</code>方法的前后。如下图:</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/spring/analysis/201808231001.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="BeanPostProcessor接口方法调用"><a href="#BeanPostProcessor接口方法调用" class="headerlink" title="BeanPostProcessor接口方法调用"></a>BeanPostProcessor接口方法调用</h3><ul><li><p>接口的两个方法是哪里调用了呢，又回到回到<code>doCreateBean(...)</code> 方法，这个方法主要用于完成 <code>bean</code> 的创建和初始化工作，我们可以将其分为一下几个过程</p><ul><li><code>createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)</code> 方法，实例化 <code>bean</code> 。</li><li><code>populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</code> 方法，进行属性填充。</li><li><code>initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法，初始化 <code>Bean</code> 。</li></ul></li><li><p>还是关注<code>initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)</code> 方法，从下面的代码关注重点1及重点2两行，可以看到中间就夹了个<code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法，这个方法用于初始化<code>bean</code>，也就是用于激活用户自定义的初始化方法</p><ul><li><p>进入<code>invokeInitMethods(beanName, wrappedBean, mbd);</code>方法，可以看到下面是检测当前 <code>bean</code> 对象是否实现了 <code>InitializingBean</code>接口。如果是，则会调用其 <code>#afterPropertiesSet()</code> 方法，进一步调整 <code>bean</code> 实例对象的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// 检测当前 bean 对象是否实现了 InitializingBean 接口。如果是，则会调用其 #afterPropertiesSet() 方法，进一步调整 bean 实例对象的状态。</span></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 调用afterPropertiesSet方法</span></span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 属性初始化的处理</span></span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line"><span class="comment">// 调用自定义初始化方法</span></span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，再检查是否也指定了 <code>init-method</code>，如果指定了则通过反射机制调用指定的 <code>init-method</code> 方法。</p><ul><li>但是如果真的让我们的业务对象来实现这个<code>InitializingBean</code>接口就显得不是那么的友好了，<code>Spring</code> 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 <code>Spring</code> 容器具有侵入性了。所以 Spring 还提供了另外一种实现的方式：<code>init-method</code> 方法</li><li>使用<code>init-method</code>完全可以达到和 <code>InitializingBean</code> 一样的效果，而且在代码中我们没有看到丝毫 <code>Spring</code> 侵入的现象。所以通过 <code>init-method</code> 我们可以使用业务对象中定义的任何方法来实现 <code>bean</code> 实例对象的初始化定制化，而不再受制于 <code>InitializingBean的 #afterPropertiesSet()</code> 方法。同时我们可以使用 <code>&lt;beans&gt;</code> 标签的 <code>default-init-method</code> 属性来统一指定初始化方法，这样就省了需要在每个 <code>&lt;bean&gt;</code> 标签中都设置 <code>init-method</code> 这样的繁琐工作了</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 对特殊的bean处理 Aware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line">invokeAwareMethods(beanName, bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object wrappedBean = bean;</span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 重点1：BeanPostProcessor前置处理</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//  激活用户自定义的init方法 1、InitializingBean接口afterPropertiesSet方法 2、bean 定义的init-method=""方法</span></span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line"><span class="comment">// 重点2：BeanPostProcessor后置处理</span></span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重点1：BeanPostProcessor前置处理 <code>wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重点2：BeanPostProcessor后置处理 <code>wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="comment">// 实现 BeanPostProcessor 接口用户可以根据自己的业务需求进行响应的处理</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanPostProcessor自动检测并注册"><a href="#BeanPostProcessor自动检测并注册" class="headerlink" title="BeanPostProcessor自动检测并注册"></a>BeanPostProcessor自动检测并注册</h3><ul><li><p><code>#getBeanPostProcessors()</code> 方法，返回的是 <code>BeanPostProcessor</code> 集合，该集合里面存放就是我们自定义的 <code>BeanPostProcessor</code></p></li><li><p>如果该集合中存在元素则调用相应的方法，否则就直接返回 <code>bean</code> 了。这也是为什么使用 <code>BeanFactory</code> 容器是无法输出自定义 <code>BeanPostProcessor</code> 里面的内容，因为在 <code>BeanFactory#getBean(...)</code> 方法的过程中根本就没有将我们自定义的 <code>BeanPostProcessor</code> 注入进来，所以要想 <code>BeanFactory</code> 容器 的 <code>BeanPostProcessor</code> 生效我们必须手动调用 <code>#addBeanPostProcessor(BeanPostProcessor, beanPostProcessor)</code> 方法，将定义的 <code>BeanPostProcessor</code> 注册到相应的 <code>BeanFactory</code> 中。但是 <code>ApplicationContext</code> 不需要手动，因为 <code>ApplicationContext</code> 会自动检测并完成注册。 </p></li><li><p><code>ApplicationContext</code> 实现自动注册的原因，在于我们构造一个 <code>ApplicationContext</code> 实例对象的时候会调用 <code>#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory)</code> 方法，将检测到的 <code>BeanPostProcessor</code> 注入到 <code>ApplicationContext</code> 容器中，同时应用到该容器创建的 <code>bean</code> 中。代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">// 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">// 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开</span></span><br><span class="line"><span class="comment">// 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">// 子类覆盖方法做额外的处理</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">// 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，</span></span><br><span class="line"><span class="comment">// 并调用其postProcessBeanFactory接口方法</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean，</span></span><br><span class="line"><span class="comment">// 并将它们注册到容器Bean后处理器的注册表中，这里只是注册，真正的调用在getBean时候</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>进入<code>registerBeanPostProcessors(beanFactory);</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例化并调用已经注入的 BeanPostProcessor 必须在应用中 bean 实例化之前调用</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有的 BeanPostProcessor 的 beanName</span></span><br><span class="line">    <span class="comment">// 这些 beanName 都已经全部加载到容器中去，但是没有实例化</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">    <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">    <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">    <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    <span class="comment">// 第一步，注册所有实现了 PriorityOrdered 的 BeanPostProcessor</span></span><br><span class="line">    <span class="comment">// 先排序</span></span><br><span class="line">    sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">    <span class="comment">// 第二步，注册所有实现了 Ordered 的 BeanPostProcessor</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">    <span class="comment">// 后注册</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 第三步注册所有无序的 BeanPostProcessor</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;BeanPostProcessor&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册，无需排序</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 最后，注册所有的 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor</span></span><br><span class="line">    sortPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">    <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">    <span class="comment">// 加入ApplicationListenerDetector（探测器）</span></span><br><span class="line">    <span class="comment">// 重新注册 BeanPostProcessor 以检测内部 bean，因为 ApplicationListeners 将其移动到处理器链的末尾</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注册代码如下，可以看到是存放在<code>AbstractBeanFactory</code>类的<code>private final List&lt;BeanPostProcessor&gt; beanPostProcessors</code>属性中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register the given BeanPostProcessor beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor postProcessor : postProcessors) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanPostProcessor</span><span class="params">(BeanPostProcessor beanPostProcessor)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanPostProcessor, <span class="string">"BeanPostProcessor must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanPostProcessors.remove(beanPostProcessor);</span><br><span class="line">    <span class="keyword">this</span>.beanPostProcessors.add(beanPostProcessor);</span><br><span class="line">    <span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanPostProcessor <span class="keyword">instanceof</span> DestructionAwareBeanPostProcessor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hasDestructionAwareBeanPostProcessors = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>Spring</code>对对象的可扩展性主要就是依靠<code>BeanPostProcessor</code>来完成的，使用<code>BeanPostProcessor</code>可以对实例化后的<code>bean</code>为所欲为，添加自己的逻辑，不过一般项目开发中很少用到这个类</li><li><code>BeanFactory</code> 和 <code>ApplicationContext</code> 对 <code>BeanPostProcessor</code> 的处理不同，<code>ApplicationContext</code> 会自动检测所有实现了 <code>BeanPostProcessor</code> 接口的 bean，并完成注册，但是使用 <code>BeanFactory</code> 容器时则需要手动调用 <code>AbstractBeanFactory#addBeanPostProcessor(BeanPostProcessor beanPostProcessor)</code> 方法来完成注册</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《Spring 源码深度解析》</li><li>芋道源码 <a href="http://www.iocoder.cn" target="_blank" rel="noopener">http://www.iocoder.cn</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.com/categories/server/"/>
    
    
      <category term="Spring" scheme="http://www.songshuiyang.com/tags/Spring/"/>
    
  </entry>
  
</feed>
