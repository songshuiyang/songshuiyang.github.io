<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宋水阳个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.songshuiyang.site/"/>
  <updated>2019-04-28T03:55:59.845Z</updated>
  <id>http://www.songshuiyang.site/</id>
  
  <author>
    <name>songshuiyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并发多线程(六)ThreadLocal</title>
    <link href="http://www.songshuiyang.site/2019/04/20/backend/Java/Concurrent/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%85%AD)ThreadLocal/"/>
    <id>http://www.songshuiyang.site/2019/04/20/backend/Java/Concurrent/并发多线程(六)ThreadLocal/</id>
    <published>2019-04-20T14:59:44.000Z</published>
    <updated>2019-04-28T03:55:59.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal-作用"><a href="#ThreadLocal-作用" class="headerlink" title="ThreadLocal 作用"></a>ThreadLocal 作用</h3><p>在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。</p><p>如果是你，该如何实现上述功能？常规的思路如下：<br>使用一个线程共享的Map<thread,object>，Map中的key为线程对象，value即为需要存储的值。那么，我们只需要通过map.get(Thread.currentThread())即可获取本线程中该变量的值。</thread,object></p><p>这种方式确实可以实现我们的需求，但它有何缺点呢？——答案就是：需要同步，效率低！</p><p>由于这个map对象需要被所有线程共享，因此需要加锁来保证线程安全性。当然我们可以使用java.util.concurrent.*包下的ConcurrentHashMap提高并发效率，但这种方法只能降低锁的粒度，不能从根本上避免同步锁。而JDK提供的ThreadLocal就能很好地解决这一问题。下面来看看ThreadLocal是如何高效地实现这一需求的。</p><h3 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h3><blockquote><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p></blockquote><h3 id="ThreadLocal-解析"><a href="#ThreadLocal-解析" class="headerlink" title="ThreadLocal 解析"></a>ThreadLocal 解析</h3><blockquote><p>ThreadLocal的内部结构图</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/三高/threadLocal.jpg" alt="threadLocal" title="">                </div>                <div class="image-caption">threadLocal</div>            </figure><p>从上面的结构图，我们已经窥见ThreadLocal的核心机制：</p><p>每个Thread线程内部都有一个Map。</p><p>Map里面存储线程本地对象（key）和线程的变量副本（value）</p><p>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</p><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p><p>Thread线程内部的Map在类中描述如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></p><h4 id="ThreadLocal类提供如下几个核心方法："><a href="#ThreadLocal类提供如下几个核心方法：" class="headerlink" title="ThreadLocal类提供如下几个核心方法："></a>ThreadLocal类提供如下几个核心方法：</h4><ul><li>get()方法用于获取当前线程的副本变量值。</li><li>set()方法用于保存当前线程的副本变量值。</li><li>initialValue()为当前线程初始副本变量值。</li><li>remove()方法移除当前前程的副本变量值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程的副本变量</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 返回Thread 对象中的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有值的话调用默认setInitialValue()方法</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存放在Thread的 threadLocals</span></span><br><span class="line"><span class="comment"> * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置初始值</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 赋值</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> initialValue&#125; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">     <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">         m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><ul><li>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象   </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">     * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">     * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">     * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="comment">// Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。</span></span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="ThreadLocalMap的问题"><a href="#ThreadLocalMap的问题" class="headerlink" title="ThreadLocalMap的问题"></a>ThreadLocalMap的问题</h3><p>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><h4 id="Java的四种引用方式"><a href="#Java的四种引用方式" class="headerlink" title="Java的四种引用方式"></a>Java的四种引用方式</h4><ul><li><p>Java的数据类型分为两类：基本数据类型、引用数据类型。</p><ul><li>基本数据类型的值存储在栈内存中</li><li>引用数据类型需要开辟两块存储空间，一块在堆内存中，用于存储该类型的对象；另一块在栈内存中，用于存储堆内存中该对象的引用。</li></ul></li><li><p>Java对象的引用类型包括: <code>强引用，软引用，弱引用，虚引用</code></p></li><li><p>Java中提供这四种引用类型主要有两个目的：</p><ul><li>第一是可以让程序员通过代码的方式决定某些对象的生命周期，随着 java.lang.ref这个包下的类的引进，程序员拥有了一点点控制你创建的对象何时释放，销毁的权利</li><li>第二是有利于JVM进行垃圾回收<blockquote><p>强引用</p></blockquote></li></ul></li><li>强引用，就是我们最常见的普通对象引用，我们 new 出来的对象就是强引用，只要尚且存在强引用指向某一个对象，那就能表明该对象还存活，GC 不能去回收这种对象。需要回收强引用指向的对象，可以等待超出引用区域，或者是显式设置对象为 null，就可以通知让 GC 回收，当然实际的回收时间要看 GC 策略。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个对象，new出来的对象都是分配在java堆中的</span></span><br><span class="line">        Sample sample = <span class="keyword">new</span> Sample();   <span class="comment">// sample这个引用就是强引用</span></span><br><span class="line">        </span><br><span class="line">        sample = <span class="keyword">null</span>;                  <span class="comment">// 将这个引用指向空指针,</span></span><br><span class="line">                                        <span class="comment">// 那么上面那个刚new来的对象就没用任何其它有效的引用指向它了</span></span><br><span class="line">                                        <span class="comment">// 也就说该对象对于垃圾收集器是符合条件的</span></span><br><span class="line">                                        <span class="comment">// 因此在接下来某个时间点 GC进行收集动作的时候, 该对象将会被销毁，内存被释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>也可以画个简单的图理解一下：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/Concurrent/threadlocal.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>软引用</p></blockquote><ul><li><p>当内存资源充足的时候，垃圾回收器不会回收软引用对应的对象的内存空间；但当内存资源紧张时，软引用所对应的对象就会被垃圾回收器回收。</p></li><li><p>软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。   SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。</p></li><li><p>也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个对象，new出来的对象都是分配在java堆中的</span></span><br><span class="line">        Sample sample = <span class="keyword">new</span> Sample();   <span class="comment">//sample这个引用就是强引用</span></span><br><span class="line">        <span class="comment">// 创建一个软引用指向这个对象   那么此时就有两个引用指向Sample对象</span></span><br><span class="line">        SoftReference&lt;Sample&gt; softRef = <span class="keyword">new</span> SoftReference&lt;Sample&gt;(sample);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将强引用指向空指针 那么此时只有一个软引用指向Sample对象</span></span><br><span class="line">        <span class="comment">// 注意：softRef这个引用也是强引用，它是指向SoftReference这个对象的</span></span><br><span class="line">        <span class="comment">// 那么这个软引用在哪呢？ 可以跟一下java.lang.Reference的源码 </span></span><br><span class="line">        <span class="comment">// private T referent; 这个才是软引用， 只被jvm使用</span></span><br><span class="line">        sample = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以重新获得Sample对象，并用一个强引用指向它</span></span><br><span class="line">        sample = softRef.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/Concurrent/threadLocal1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>利用软引用解决OOM问题<ul><li>下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</li><li>示例代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = <span class="keyword">new</span> HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToCache</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 强引用的Bitmap对象</span></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeFile(path);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 软引用的Bitmap对象</span></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bitmap);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 添加该对象到Map中使其缓存</span></span><br><span class="line">    imageCache.put(path, softBitmap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从缓存中取软引用的Bitmap对象</span></span><br><span class="line">    SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否存在软引用</span></span><br><span class="line">    <span class="keyword">if</span> (softBitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空</span></span><br><span class="line">    Bitmap bitmap = softBitmap.get();</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>弱引用</p><ul><li>弱引用会被Jvm忽略，也就说在GC进行垃圾收集的时候，如果一个对象只有弱引用指向它，那么和没有引用指向它是一样的效果，jvm都会对它就行果断的销毁，释放内存。</li><li>那么，ThreadLocalMap中的key使用弱引用的原因也是如此。当一条线程中的ThreadLocal对象使用完毕，没有强引用指向它的时候，垃圾收集器就会自动回收这个Key，从而达到节约内存的目的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Person&gt; wr = <span class="keyword">new</span> WeakReference&lt;Person&gt;(<span class="keyword">new</span> Person());</span><br></pre></td></tr></table></figure></li></ul><p>虚引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚引用等于没有引用，无法通过虚引用访问其对应的对象。</span><br><span class="line"></span><br><span class="line">虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个<span class="keyword">null</span>，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="如何避免泄漏"><a href="#如何避免泄漏" class="headerlink" title="如何避免泄漏"></a>如何避免泄漏</h4><p>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。</p><p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><h3 id="ThreadLocal-应用场景"><a href="#ThreadLocal-应用场景" class="headerlink" title="ThreadLocal 应用场景"></a>ThreadLocal 应用场景</h3><blockquote><p>Hibernate的session获取场景：每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Session</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Session session =  threadLocal.get();</span><br><span class="line">    <span class="comment">// 判断Session是否为空，如果为空，将创建一个session，并设置到本地线程变量中</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(session == <span class="keyword">null</span> &amp;&amp; !session.isOpen())&#123;</span><br><span class="line">            <span class="keyword">if</span>(sessionFactory == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 创建Hibernate的SessionFactory</span></span><br><span class="line">                rbuildSessionFactory();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                session = sessionFactory.openSession();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.set(session);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。</li><li>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。</li><li>适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="noopener">https://www.jianshu.com/p/98b68c97df9b</a></li><li><a href="https://www.jianshu.com/p/3f3620f9011d" target="_blank" rel="noopener">https://www.jianshu.com/p/3f3620f9011d</a></li><li><a href="https://blog.csdn.net/rodbate/article/details/72857447" target="_blank" rel="noopener">https://blog.csdn.net/rodbate/article/details/72857447</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3784171.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3784171.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ThreadLocal-作用&quot;&gt;&lt;a href=&quot;#ThreadLocal-作用&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 作用&quot;&gt;&lt;/a&gt;ThreadLocal 作用&lt;/h3&gt;&lt;p&gt;在并发编程中时常有这样一种需求：每条线程都需
      
    
    </summary>
    
      <category term="server" scheme="http://www.songshuiyang.site/categories/server/"/>
    
    
      <category term="Java" scheme="http://www.songshuiyang.site/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>并发多线程(五)ThreadPoolExecutor线程池</title>
    <link href="http://www.songshuiyang.site/2019/04/05/backend/Java/Concurrent/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%94)ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://www.songshuiyang.site/2019/04/05/backend/Java/Concurrent/并发多线程(五)ThreadPoolExecutor线程池/</id>
    <published>2019-04-05T14:59:44.000Z</published>
    <updated>2019-04-23T12:04:15.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p></li><li><p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的ThreadPoolExecutor类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。</p><h2 id="Java中的ThreadPoolExecutor类"><a href="#Java中的ThreadPoolExecutor类" class="headerlink" title="Java中的ThreadPoolExecutor类"></a>Java中的ThreadPoolExecutor类</h2></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/Concurrent/ThreadPoolExecutor.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p><code>java.uitl.concurrent.ThreadPoolExecutor</code>类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下<code>ThreadPoolExecutor</code>类的具体实现源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p></li><li><p>下面解释下一下构造器中各个参数的含义：</p><ul><li>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；</li><li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li><li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li><li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               //天</span><br><span class="line">TimeUnit.HOURS;             //小时</span><br><span class="line">TimeUnit.MINUTES;           //分钟</span><br><span class="line">TimeUnit.SECONDS;           //秒</span><br><span class="line">TimeUnit.MILLISECONDS;      //毫秒</span><br><span class="line">TimeUnit.MICROSECONDS;      //微妙</span><br><span class="line">TimeUnit.NANOSECONDS;       //纳秒</span><br></pre></td></tr></table></figure></li><li><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br></pre></td></tr></table></figure></li><li><p>threadFactory：线程工厂，主要用来创建线程；</p></li><li>handler：表示当拒绝处理任务时的策略，有以下四种取值：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></li></ul></li><li><p>从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。我们接着看ExecutorService接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现： Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在ThreadPoolExecutor类中有几个非常重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">execute()</span><br><span class="line">submit()</span><br><span class="line">shutdown()</span><br><span class="line">shutdownNow()</span><br></pre></td></tr></table></figure></li><li><p>方法讲解</p><ul><li>execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</li><li>submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</li><li>shutdown()和shutdownNow()是用来关闭线程池的。</li><li>还有很多其他的方法，比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。　　<h2 id="深入剖析线程池实现原理"><a href="#深入剖析线程池实现原理" class="headerlink" title="深入剖析线程池实现原理"></a>深入剖析线程池实现原理</h2></li></ul></li><li>在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.线程池状态</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.任务的执行</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.线程池中的线程初始化</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.任务缓存队列及排队策略</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.任务拒绝策略</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.线程池的关闭</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.线程池容量的动态调整</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1.线程池状态"></a>1.线程池状态</h3><ul><li>在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">runState表示当前线程池的状态，它是一个<span class="keyword">volatile</span>变量用来保证线程之间的可见性；</span><br><span class="line">下面的几个<span class="keyword">static</span> <span class="keyword">final</span>变量表示runState可能的几个取值。</span><br><span class="line">当创建线程池后，初始时，线程池处于RUNNING状态；</span><br><span class="line">如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</span><br><span class="line">如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</span><br><span class="line">当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-任务的执行"><a href="#2-任务的执行" class="headerlink" title="2.任务的执行"></a>2.任务的执行</h3><ul><li><p>在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;                <span class="comment">// 任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();     <span class="comment">// 线程池的主要状态锁，对线程池状态（比如线程池大小runState等）的改变都要使用这个锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">// 用来存放工作集</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;                           <span class="comment">// 线程存活时间   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;                <span class="comment">// 是否允许为核心线程设置存活时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;                            <span class="comment">// 核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;                         <span class="comment">// 线程池最大的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;                                <span class="comment">// 线程池中当前的线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;              <span class="comment">// 任务拒绝策略</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;                   <span class="comment">// 线程工厂，用来创建线程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;                                    <span class="comment">// 用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;                                <span class="comment">// 用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure></li><li><p>每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p><p> corePoolSize这个就是线程池的大小。举个简单的例子：</p><p> -</p></li></ul><p>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>　　然后就将任务也分配给这4个临时工人做；</p><p>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p><p>　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p><p>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p><p>　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p><ul><li>在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment"> * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment"> * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment"> * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 1.如果当前线程数量小于corePoolSize，则创建并启动线程。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.步骤1失败，则尝试进入阻塞队列，</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 入队列成功，检查线程池状态，如果状态部署RUNNING而且remove成功，则拒绝任务</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="comment">// 3. 步骤1和2失败，尝试将线程池的数量有corePoolSize扩充至maxPoolSize，如果失败，则拒绝任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/Concurrent/ThreadPoolExecuter.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>任务提交给线程池之后的处理策略<ul><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。<h3 id="3-线程池中的线程初始化"><a href="#3-线程池中的线程初始化" class="headerlink" title="3.线程池中的线程初始化"></a>3.线程池中的线程初始化</h3></li></ul></li><li>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：<ul><li>prestartCoreThread()：初始化一个核心线程；</li><li>prestartAllCoreThreads()：初始化所有核心线程</li></ul></li></ul><h3 id="4-任务缓存队列及排队策略"><a href="#4-任务缓存队列及排队策略" class="headerlink" title="4.任务缓存队列及排队策略"></a>4.任务缓存队列及排队策略</h3><ul><li>在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：<ul><li>1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</li><li>2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</li><li>3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</li></ul></runnable></li></ul><h3 id="5-任务拒绝策略"><a href="#5-任务拒绝策略" class="headerlink" title="5.任务拒绝策略"></a>5.任务拒绝策略</h3><ul><li>当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-线程池的关闭"><a href="#6-线程池的关闭" class="headerlink" title="6.线程池的关闭"></a>6.线程池的关闭</h3><ul><li>ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：<ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务<h3 id="7-线程池容量的动态调整"><a href="#7-线程池容量的动态调整" class="headerlink" title="7.线程池容量的动态调整"></a>7.线程池容量的动态调整</h3></li></ul></li><li>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，<ul><li>setCorePoolSize：设置核心池大小</li><li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小</li></ul></li><li>当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="ThreadPoolExecutor-使用示例"><a href="#ThreadPoolExecutor-使用示例" class="headerlink" title="ThreadPoolExecutor 使用示例"></a>ThreadPoolExecutor 使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            MyTask myTask = <span class="keyword">new</span> MyTask(i);</span><br><span class="line">            executor.execute(myTask);</span><br><span class="line">            System.out.println(</span><br><span class="line">                    <span class="string">"线程池中线程数目："</span> + executor.getPoolSize() + </span><br><span class="line">                    <span class="string">"，队列中等待执行的任务数目："</span> + executor.getQueue().size() + </span><br><span class="line">                    <span class="string">"，已执行玩别的任务数目："</span> + executor.getCompletedTaskCount());</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> taskNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskNum = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行task "</span> + taskNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"task "</span> + taskNum + <span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">线程池中线程数目：<span class="number">1</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">2</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">3</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">4</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">2</span></span><br><span class="line">正在执行task <span class="number">1</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">0</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">1</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">3</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">2</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">4</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">3</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">4</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">5</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">6</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">10</span></span><br><span class="line">线程池中线程数目：<span class="number">7</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">11</span></span><br><span class="line">线程池中线程数目：<span class="number">8</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">线程池中线程数目：<span class="number">9</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">12</span></span><br><span class="line">正在执行task <span class="number">13</span></span><br><span class="line">线程池中线程数目：<span class="number">10</span>，队列中等待执行的任务数目：<span class="number">5</span>，已执行玩别的任务数目：<span class="number">0</span></span><br><span class="line">正在执行task <span class="number">14</span></span><br><span class="line">task <span class="number">1</span>执行完毕</span><br><span class="line">task <span class="number">0</span>执行完毕</span><br><span class="line">task <span class="number">4</span>执行完毕</span><br><span class="line">task <span class="number">2</span>执行完毕</span><br><span class="line">正在执行task <span class="number">7</span></span><br><span class="line">task <span class="number">3</span>执行完毕</span><br><span class="line">正在执行task <span class="number">6</span></span><br><span class="line">正在执行task <span class="number">5</span></span><br><span class="line">正在执行task <span class="number">8</span></span><br><span class="line">正在执行task <span class="number">9</span></span><br><span class="line">task <span class="number">12</span>执行完毕</span><br><span class="line">task <span class="number">14</span>执行完毕</span><br><span class="line">task <span class="number">10</span>执行完毕</span><br><span class="line">task <span class="number">11</span>执行完毕</span><br><span class="line">task <span class="number">13</span>执行完毕</span><br><span class="line">task <span class="number">7</span>执行完毕</span><br><span class="line">task <span class="number">5</span>执行完毕</span><br><span class="line">task <span class="number">8</span>执行完毕</span><br><span class="line">task <span class="number">6</span>执行完毕</span><br><span class="line">task <span class="number">9</span>执行完毕</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</p></li></ul><h3 id="Executors提供四种线程池的创建实现"><a href="#Executors提供四种线程池的创建实现" class="headerlink" title="Executors提供四种线程池的创建实现"></a>Executors提供四种线程池的创建实现</h3><ul><li>将线程放入线程池的两种方法<ul><li>1、ExecutorService 类中的 submit(Runnable task)  submit(Callable<t> task)</t></li><li>2、Executor 接口中的execute(Runnable command)</li></ul></li></ul><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><code>newCachedThreadPool</code></h4><ul><li>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池的规模不存在限制。</li><li>缓存线程池，缓存的线程默认存活60秒。线程的核心池corePoolSize大小为0，核心池最大为Integer.MAX_VALUE,阻塞队列使用的是SynchronousQueue。是一个直接提交的阻塞队列，    他总会迫使线程池增加新的线程去执行新的任务。在没有任务执行时，当线程的空闲时间超过keepAliveTime（60秒），则工作线程将会终止被回收，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。如果同时又大量任务被提交，而且任务执行的时间不是特别快，那么线程池便会新增出等量的线程池处理任务，这很可能会很快耗尽系统的资源。</li><li><p>构造ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCachedThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(index * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1- 在未来某个时间执行给定的命令。</span></span><br><span class="line">            <span class="comment">// 该命令可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。</span></span><br><span class="line">            cachedThreadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2- 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。</span></span><br><span class="line">            <span class="comment">// 该 Future 的 get 方法在成功完成时将会返回给定的结果</span></span><br><span class="line">            cachedThreadPool.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><code>newFixedThreadPool</code></h4><ul><li>创建一个固定长度线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>构造ThreadPoolExecutor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><code>newScheduledThreadPool</code></h4><ul><li>创建一个固定长度线程池，支持定时及周期性任务执行。</li><li>构造ThreadPoolExecutor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><code>newSingleThreadExecutor</code></h4><ul><li>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li><li><p>构造ThreadPoolExecutor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p></li><li><p>虽然jdk提供了以上线程池的创建实现，但在实际项目中不推荐使用，在阿里巴巴编码规范插件中是这么提示的：线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </p></li><li><p>说明：Executors各个方法的弊端：</p><ul><li><p>1）newCachedThreadPool和newScheduledThreadPool:</p><p>主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</p></li><li><p>2）newFixedThreadPool和newSingleThreadExecutor:</p><p>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</p></li></ul></li><li><p>正确使用例子：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Positive example <span class="number">1</span>：</span><br><span class="line">  <span class="comment">//org.apache.commons.lang3.concurrent.BasicThreadFactory</span></span><br><span class="line">  ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>,</span><br><span class="line">      <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">"example-schedule-pool-%d"</span>).daemon(<span class="keyword">true</span>).build());</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">          </span><br><span class="line">Positive example <span class="number">2</span>：</span><br><span class="line">  ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">      .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Common Thread Pool</span></span><br><span class="line">  ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">  pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">  pool.shutdown();<span class="comment">//gracefully shutdown</span></span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">          </span><br><span class="line">Positive example <span class="number">3</span>：</span><br><span class="line">  &lt;bean id=<span class="string">"userThreadPool"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"</span>&gt;</span><br><span class="line">      &lt;property name=<span class="string">"corePoolSize"</span> value=<span class="string">"10"</span> /&gt;</span><br><span class="line">      &lt;property name=<span class="string">"maxPoolSize"</span> value=<span class="string">"100"</span> /&gt;</span><br><span class="line">      &lt;property name=<span class="string">"queueCapacity"</span> value=<span class="string">"2000"</span> /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property name=<span class="string">"threadFactory"</span> value= threadFactory /&gt;</span><br><span class="line">      &lt;property name=<span class="string">"rejectedExecutionHandler"</span>&gt;</span><br><span class="line">          &lt;ref local=<span class="string">"rejectedExecutionHandler"</span> /&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">  <span class="comment">//in code</span></span><br><span class="line">  userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>为什么要用线程池，因为每次new Thread新建对象性能差，使用线程池可以重用存在的线程，减少对象创建、消亡的开销，性能佳。</li><li>相比普通线程的执行，使用线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，同时还提供了定时执行、定期执行、单线程、并发数控制等功能。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></li><li><a href="https://blog.csdn.net/tanghui270270/article/details/80595961" target="_blank" rel="noopener">https://blog.csdn.net/tanghui270270/article/details/80595961</a></li><li><a href="https://www.cnblogs.com/superfj/p/7544971.html" target="_blank" rel="noopener">https://www.cnblogs.com/superfj/p/7544971.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>并发多线程(四)Lock同步锁</title>
    <link href="http://www.songshuiyang.site/2019/04/04/backend/Java/Concurrent/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E5%9B%9B)Lock%E5%90%8C%E6%AD%A5%E9%94%81/"/>
    <id>http://www.songshuiyang.site/2019/04/04/backend/Java/Concurrent/并发多线程(四)Lock同步锁/</id>
    <published>2019-04-04T14:59:44.000Z</published>
    <updated>2019-04-23T12:04:15.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>在上上篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。</p></li><li><p>也许有朋友会问，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西</p></li></ul><h2 id="一：synchronized的缺陷"><a href="#一：synchronized的缺陷" class="headerlink" title="一：synchronized的缺陷"></a>一：synchronized的缺陷</h2><ul><li>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：<ul><li>1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>2）线程执行发生异常，此时JVM会让线程自动释放锁。</li></ul></li><li><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p></li><li><p>再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p></li></ul><h2 id="二-java-util-concurrent-locks包下常用的类"><a href="#二-java-util-concurrent-locks包下常用的类" class="headerlink" title="二.java.util.concurrent.locks包下常用的类"></a>二.java.util.concurrent.locks包下常用的类</h2><blockquote><p>下面我们就来探讨一下java.util.concurrent.locks包中常用的类和接口。</p></blockquote><h3 id="1-Lock"><a href="#1-Lock" class="headerlink" title="1.Lock"></a>1.Lock</h3><ul><li><p>首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。</p></li><li><p>在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？</p><ul><li><p>lock()</p><ul><li>首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>tryLock()</p><ul><li>tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</li><li>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li><li>所以，一般情况下通过tryLock来获取锁时是这样使用的：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line"><span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         <span class="comment">//处理任务</span></span><br><span class="line">     &#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果不能获取锁，则直接做其他事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>lockInterruptibly()</p><ul><li>lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</li><li>由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。</li><li><p>因此lockInterruptibly()一般的使用形式如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">     <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。</p></li><li>而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。<h3 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h3></li></ul></li></ul></li><li><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p></li><li><p>lock()的错误使用方法</p><ul><li><p>代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>各位朋友先想一下这段代码的输出结果是什么？</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>得到了锁</span><br><span class="line">Thread-<span class="number">1</span>得到了锁</span><br><span class="line">Thread-<span class="number">0</span>释放了锁</span><br><span class="line">Thread-<span class="number">1</span>释放了锁</span><br></pre></td></tr></table></figure></li><li><p>也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。</p></li><li><p>知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                arrayList.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这样就是正确地使用Lock的方法了。</p></li></ul></li><li><p>tryLock()的使用方法</p><ul><li><p>代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//注意这个地方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.insert(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lock.tryLock()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                    arrayList.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"获取锁失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>得到了锁</span><br><span class="line">Thread-<span class="number">1</span>获取锁失败</span><br><span class="line">Thread-<span class="number">0</span>释放了锁</span><br></pre></td></tr></table></figure></li></ul></li><li><p>lockInterruptibly()响应中断的使用方法：</p><ul><li><p>代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lockInterruptibly();   <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</span><br><span class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//插入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行finally"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行之后，发现thread2能够被正确中断</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>得到了锁</span><br><span class="line">Thread-<span class="number">1</span>被中断</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.ReadWriteLock</p><ul><li><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。</p></li></ul></li><li><p>4.ReentrantReadWriteLock</p><ul><li>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</li><li>下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</li><li><p>假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>读操作完毕</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>读操作完毕</span><br></pre></td></tr></table></figure></li><li><p>而改成用读写锁的话：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                test.get(Thread.currentThread());</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">"正在进行读操作"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"读操作完毕"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>此时打印的结果为：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">1</span>正在进行读操作</span><br><span class="line">Thread-<span class="number">0</span>读操作完毕</span><br><span class="line">Thread-<span class="number">1</span>读操作完毕</span><br></pre></td></tr></table></figure></li><li><p>说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p></li></ul></li></ul></li></ul><h2 id="三-锁的相关概念介绍"><a href="#三-锁的相关概念介绍" class="headerlink" title="三.锁的相关概念介绍"></a>三.锁的相关概念介绍</h2><h3 id="1-可重入锁"><a href="#1-可重入锁" class="headerlink" title="1.可重入锁"></a>1.可重入锁</h3><ul><li><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p></li><li><p>看下面这段代码就明白了：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p></li><li><p>而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p></li></ul><h3 id="2-可中断锁"><a href="#2-可中断锁" class="headerlink" title="2.可中断锁"></a>2.可中断锁</h3><ul><li>可中断锁：顾名思义，就是可以相应中断的锁。</li><li>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</li><li>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</li><li>在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。</li></ul><h3 id="3-公平锁"><a href="#3-公平锁" class="headerlink" title="3.公平锁"></a>3.公平锁</h3><ul><li>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</li><li>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</li><li>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。<br>*而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</li></ul><h3 id="4-读写锁"><a href="#4-读写锁" class="headerlink" title="4.读写锁"></a>4.读写锁</h3><ul><li>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</li><li>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。</li></ul><h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四.总结"></a>四.总结</h2><ul><li>1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</li><li>2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li><li>3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li><li>4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li><li>5）Lock可以提高多个线程进行读操作的效率。</li><li>6）在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3932921.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在上上篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>并发多线程(三)volatile关键字</title>
    <link href="http://www.songshuiyang.site/2019/04/01/backend/Java/Concurrent/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%89)volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.songshuiyang.site/2019/04/01/backend/Java/Concurrent/并发多线程(三)volatile关键字/</id>
    <published>2019-04-01T14:59:44.000Z</published>
    <updated>2019-04-23T13:41:02.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剖析volatile关键字"><a href="#剖析volatile关键字" class="headerlink" title="剖析volatile关键字"></a>剖析volatile关键字</h2><h3 id="1-volatile关键字的两层语义"><a href="#1-volatile关键字的两层语义" class="headerlink" title="1. volatile关键字的两层语义"></a>1. volatile关键字的两层语义</h3><ul><li>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。</li></ul></li><li><p>先看一段代码，假如线程1先执行，线程2后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p></li><li><p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p></li><li><p>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p></li><li><p>但是用volatile修饰之后就变得不一样了：</p><ul><li>第一：使用volatile关键字会强制将修改的值立即写入主存；</li><li>第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</li><li>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</li><li>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</li><li>那么线程1读取到的就是最新的正确的值。</li></ul></li></ul><h3 id="2-volatile保证原子性吗"><a href="#2-volatile保证原子性吗" class="headerlink" title="2. volatile保证原子性吗?"></a>2. volatile保证原子性吗?</h3><ul><li>从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p><p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p><p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p><p>在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>假如某个时刻变量inc的值为10，</p><p>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p><p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p><p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p><p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p><p>i++ 的操作实际上分为三个步骤 1、<code>读 int temp = i;</code> 2、<code>改 i = i + 1</code> 3、<code>写 i = temp</code> </p><p>解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p><p>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p><p>把上面的代码改成以下任何一种都可以达到效果：</p><blockquote><p>采用synchronized：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>采用Lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="3-volatile能保证有序性吗？"><a href="#3-volatile能保证有序性吗？" class="headerlink" title="3.volatile能保证有序性吗？"></a>3.volatile能保证有序性吗？</h3><ul><li><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p></li><li><p>volatile关键字禁止指令重排序有两层意思：</p><ul><li>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li><li>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</li></ul></li><li><p>可能上面说的比较绕，举个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure></li><li><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p></li><li><p>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p></li><li><p>那么我们回到前面举的一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></li><li><p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p></li><li><p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p></li></ul><h3 id="4-volatile的原理和实现机制"><a href="#4-volatile的原理和实现机制" class="headerlink" title="4.volatile的原理和实现机制"></a>4.volatile的原理和实现机制</h3><ul><li><p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p></li><li><p>下面这段话摘自《深入理解Java虚拟机》：</p><ul><li><p>“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　* 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>　　* 2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　* 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><h3 id="5-volatile-使用场景"><a href="#5-volatile-使用场景" class="headerlink" title="5.volatile 使用场景"></a>5.volatile 使用场景</h3></li></ul></li><li>只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</li></ul><p>　　（1）对变量的写操作不依赖于当前值。</p><p>　　（2）该变量没有包含在具有其他变量的不变式中。</p><ul><li>状态标志</li><li><p>实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 其他线程调用，通知需要结束，并改变状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123; shutdownRequested = <span class="keyword">true</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) &#123; </span><br><span class="line">        <span class="comment">// do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用清单 2 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。</p></li><li><p>这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></li><li><a href="https://blog.csdn.net/y874961524/article/details/82934831" target="_blank" rel="noopener">https://blog.csdn.net/y874961524/article/details/82934831</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;剖析volatile关键字&quot;&gt;&lt;a href=&quot;#剖析volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;剖析volatile关键字&quot;&gt;&lt;/a&gt;剖析volatile关键字&lt;/h2&gt;&lt;h3 id=&quot;1-volatile关键字的两层语义&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>并发多线程(二)synchronized关键字</title>
    <link href="http://www.songshuiyang.site/2019/04/01/backend/Java/Concurrent/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%BA%8C)synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://www.songshuiyang.site/2019/04/01/backend/Java/Concurrent/并发多线程(二)synchronized关键字/</id>
    <published>2019-04-01T13:59:44.000Z</published>
    <updated>2019-04-24T15:18:12.616Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/%E4%BA%8C%20%20Synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E3%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%81JDK1.6%20%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%20%E5%92%8CReenTrantLock%20%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比" title="">                </div>                <div class="image-caption">Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比</div>            </figure><h3 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h3><ul><li><p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p></li><li><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p></li></ul><h3 id="synchronized关键字最主要的三种使用方式"><a href="#synchronized关键字最主要的三种使用方式" class="headerlink" title="synchronized关键字最主要的三种使用方式"></a>synchronized关键字最主要的三种使用方式</h3><ul><li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li><li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</strong> 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li></ul><p>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="synchronized-关键字底层原理"><a href="#synchronized-关键字底层原理" class="headerlink" title="synchronized 关键字底层原理"></a>synchronized 关键字底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>① synchronized 同步语句块的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images.gitbook.cn/abc37c80-d21d-11e8-aab3-09d30029e0d5" alt="synchronized 关键字原理" title="">                </div>                <div class="image-caption">synchronized 关键字原理</div>            </figure><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/Concurrent/duixiangtui.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>对象被创建在堆中。并且对象在内存中的存储布局方式可以分为3块区域：对象头、实例数据、对齐填充。对于对象头来说，主要是包括俩部分信息:</p><pre><code>* 1、自身运行时的数据，比如：如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。（此部分内容被称之为Mark Word） * 2、另一部分是类型指针：JVM通过这个指针来确定这个对象是哪个类的实例。</code></pre><p><strong>② synchronized 修饰方法的的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://images.gitbook.cn/7d407bf0-d21e-11e8-b2d6-1188c7e0dd7e" alt="synchronized 关键字原理" title="">                </div>                <div class="image-caption">synchronized 关键字原理</div>            </figure><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><h3 id="JDK-1-6锁优化"><a href="#JDK-1-6锁优化" class="headerlink" title="JDK 1.6锁优化"></a>JDK 1.6锁优化</h3><h4 id="1、自旋锁"><a href="#1、自旋锁" class="headerlink" title="1、自旋锁"></a>1、自旋锁</h4><blockquote><p>由来</p></blockquote><p>线程的阻塞和唤醒，需要 <code>CPU 从用户态转为核心态</code>。频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时，我们发现在许多应用上面，<code>对象锁的锁状态只会持续很短一段时间</code>。为了这一段很短的时间，频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><blockquote><p>定义 </p></blockquote><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。</p><p>怎么等待呢？<code>执行一段无意义的循环即可（自旋）。</code></p><p>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。</p><p>所以说，自旋等待的时间（自旋的<code>次数</code>）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p><p>自旋锁在 JDK 1.4.2 中引入，默认关闭，但是可以使用<code>-XX:+UseSpinning</code> 开开启。</p><p>在 JDK1.6 中默认开启。同时自旋的默认次数为 10 次，可以通过参数 <code>-XX:PreBlockSpin</code> 来调整。</p><p>如果通过参数 <code>-XX:PreBlockSpin</code> 来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为 10 ，但是系统很多线程都是等你刚刚退出的时候，就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是 JDK 1.6 引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><blockquote><p>适应自旋锁</p></blockquote><ul><li>JDK 1.6 引入了更加聪明的自旋锁，即自适应自旋锁。<ul><li>线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。</li><li>反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</li></ul></li><li>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</li></ul><h4 id="2、锁消除"><a href="#2、锁消除" class="headerlink" title="2、锁消除"></a>2、锁消除</h4><blockquote><p>由来</p></blockquote><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制。但是，在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。</p><blockquote><p>定义</p></blockquote><p>锁消除的依据是逃逸分析的数据支持。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些 JDK 的内置 API 时，如 StringBuffer、Vector、HashTable 等，这个时候会存在隐性的加锁操作。比如 StringBuffer 的 #append(..)方法，Vector 的 add(…) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">    vector.add(i + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM 可以明显检测到变量 vector 没有逃逸出方法 #vectorTest() 之外，所以 JVM 可以大胆地将 vector 内部的加锁操作消除。</p><h4 id="3、锁粗化"><a href="#3、锁粗化" class="headerlink" title="3、锁粗化"></a>3、锁粗化</h4><blockquote><p>由来</p></blockquote><p>我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小：仅在共享数据的实际作用域中才进行同步。这样做的目的，是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。</p><p>在大多数的情况下，上述观点是正确的，LZ 也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。</p><blockquote><p>定义</p></blockquote><p>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</p><p>如上面实例：vector 每次 add 的时候都需要加锁操作，JVM 检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到 for 循环之外。</p><h4 id="4、锁升级"><a href="#4、锁升级" class="headerlink" title="4、锁升级"></a>4、锁升级</h4><ul><li>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。它们会随着竞争的激烈而逐渐升级。注意，锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</li></ul><h5 id="4-1-重量级锁"><a href="#4-1-重量级锁" class="headerlink" title="4.1 重量级锁"></a>4.1 重量级锁</h5><p>重量级锁通过对象内部的监视器（Monitor）实现。</p><p>其中，Monitor 的本质是，依赖于底层操作系统的 Mutex Lock 实现。操作系统实现线程之间的切换，需要从用户态到内核态的切换，切换成本非常高。</p><h5 id="4-1-轻量级锁"><a href="#4-1-轻量级锁" class="headerlink" title="4.1 轻量级锁"></a>4.1 轻量级锁</h5><p>引入轻量级锁的主要目的，是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>当关闭偏向锁功能或者多个线程竞争偏向锁，导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁其步骤如下：</p><ul><li><p>获取锁</p><ul><li>判断当前对象是否处于无锁状态？若是，则 JVM 首先将在当前线程的栈帧中，建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word的 拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）；否则，执行步骤（3）；</li><li>JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指正。如果成功，表示竞争到锁，则将锁标志位变成 00（表示此对象处于轻量级锁状态），执行同步操作；如果失败，则执行步骤（3）；</li><li>判断当前对象的 Mark Word 是否指向当前线程的栈帧？如果是，则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则，只能说明该锁对象已经被其他线程抢占了，当前线程便尝试使用自旋来获取锁。若自旋后没有获得锁，此时轻量级锁会升级为重量级锁，锁标志位变成 10，当前线程会被阻塞。</li></ul></li><li><p>释放锁 轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：</p><ul><li>取出在获取轻量级锁保存在 Displaced Mark Word 中 数据。</li><li>使用 CAS 操作将取出的数据替换当前对象的 Mark Word 中。如果成功，则说明释放锁成功；否则，执行（3）。</li><li>无论（2）是否释放成功，都会唤醒被挂起的线程，重新争夺锁，访问同步代码块。</li></ul></li><li><p>下图是争夺锁导致的锁膨胀的流程图：其中，绿框的 0 指的是无偏向锁，01 指的是无锁状态。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/Concurrent/markword.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>注意事项: 对于轻量级锁，其性能提升的依据是：“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”。如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。</li></ul><h5 id="4-1-偏向锁"><a href="#4-1-偏向锁" class="headerlink" title="4.1 偏向锁"></a>4.1 偏向锁</h5><h5 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h5><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li><a href="https://github.com/Snailclimb/JavaGuide/edit/master/docs/java/synchronized.md" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide/edit/master/docs/java/synchronized.md</a></li><li><a href="http://www.iocoder.cn/JUC/sike/synchronized/" target="_blank" rel="noopener">http://www.iocoder.cn/JUC/sike/synchronized/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>并发多线程(一)Thread的创建及使用</title>
    <link href="http://www.songshuiyang.site/2019/04/01/backend/Java/Concurrent/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B(%E4%B8%80)Thread%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.songshuiyang.site/2019/04/01/backend/Java/Concurrent/并发多线程(一)Thread的创建及使用/</id>
    <published>2019-04-01T12:59:44.000Z</published>
    <updated>2019-04-23T12:04:15.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-线程创建及使用"><a href="#1-线程创建及使用" class="headerlink" title="1. 线程创建及使用"></a>1. 线程创建及使用</h3><h4 id="1-1-继承Thread类创建线程类"><a href="#1-1-继承Thread类创建线程类" class="headerlink" title="1.1 继承Thread类创建线程类"></a>1.1 继承Thread类创建线程类</h4><ul><li>实现最简单，如果要访问当前线程，则无需使用 <code>Thread.currentThread()</code>直接使用<code>this</code>即可得到当前线程</li><li>不能再继承其他父类，因为线程类已经继承了<code>Thread</code>类</li><li><code>Thread</code>类继承<code>Runnable</code>类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomThread customThread = <span class="keyword">new</span> CustomThread();</span><br><span class="line">        customThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CustomThread doing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-实现Runnable类创建线程类"><a href="#1-2-实现Runnable类创建线程类" class="headerlink" title="1.2 实现Runnable类创建线程类"></a>1.2 实现Runnable类创建线程类</h4><ul><li>线程类只是实现了<code>Runnable</code>类，还可以继承其他类</li><li>访问线程需要使用 <code>Thread.currentThread()</code>访问当前线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CustomRunnable对象作为Thread构造参数</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CustomRunnable());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CustomRunnable doing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-使用Callable和Future创建线程"><a href="#1-3-使用Callable和Future创建线程" class="headerlink" title="1.3 使用Callable和Future创建线程"></a>1.3 使用Callable和Future创建线程</h4><ul><li>线程类只是实现了<code>Runnable</code>类，还可以继承其他类</li><li>访问线程需要使用 <code>Thread.currentThread()</code>访问当前线程</li><li>可以得到线程方法体的结果，得到<code>call()</code>方法返回值</li><li>可以得到执行异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CustomCallable customCallable = <span class="keyword">new</span> CustomCallable();</span><br><span class="line">        <span class="comment">// 使用Callable方式创建线程，需要FutureTask类的支持，用于接收运算结果，可以使用泛型指定返回值的类型</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask(customCallable);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 接收运算结果，只有当该线程执行完毕后才会获取到运算结果，等同于闭锁的效果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sum = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sum is "</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 计算1-100的和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-线程的生命周期"><a href="#2-线程的生命周期" class="headerlink" title="2. 线程的生命周期"></a>2. 线程的生命周期</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/Concurrent/threadprocess.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、消亡（dead）。</p></li><li><p>当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。</p></li><li><p>线程上下文切换，线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行，上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p></li><li><p>虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。</p></li></ul><h3 id="3-控制线程"><a href="#3-控制线程" class="headerlink" title="3. 控制线程"></a>3. 控制线程</h3><h4 id="3-1-join线程"><a href="#3-1-join线程" class="headerlink" title="3.1 join线程"></a>3.1 join线程</h4><ul><li>让一个线程等待另一个线程完成的方法，当在某个程序执行流中调用其他线程的<code>join()</code>方法时，调用线程将被阻塞，直到加入的<code>join()</code>线程执行完为止</li></ul><h4 id="3-2-sleep睡眠线程"><a href="#3-2-sleep睡眠线程" class="headerlink" title="3.2 sleep睡眠线程"></a>3.2 sleep睡眠线程</h4><ul><li>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。</li></ul><h4 id="3-3-yield线程让步"><a href="#3-3-yield线程让步" class="headerlink" title="3.3 yield线程让步"></a>3.3 yield线程让步</h4><ul><li>调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。</li></ul><h4 id="3-4-setPriority-改变线程优先级"><a href="#3-4-setPriority-改变线程优先级" class="headerlink" title="3.4 setPriority() 改变线程优先级"></a>3.4 setPriority() 改变线程优先级</h4><ul><li>优先级高的线程获得较多的执行机会</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li><a href="https://www.cnblogs.com/dolphin0520/p/3920357.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920357.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-线程创建及使用&quot;&gt;&lt;a href=&quot;#1-线程创建及使用&quot; class=&quot;headerlink&quot; title=&quot;1. 线程创建及使用&quot;&gt;&lt;/a&gt;1. 线程创建及使用&lt;/h3&gt;&lt;h4 id=&quot;1-1-继承Thread类创建线程类&quot;&gt;&lt;a href=&quot;#1-1-继
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机性能监控与故障处理工具</title>
    <link href="http://www.songshuiyang.site/2019/03/26/backend/Java/JVM/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.songshuiyang.site/2019/03/26/backend/Java/JVM/JVM虚拟机性能监控与故障处理工具/</id>
    <published>2019-03-26T13:59:44.000Z</published>
    <updated>2019-03-26T12:32:55.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK的命令行工具"><a href="#JDK的命令行工具" class="headerlink" title="JDK的命令行工具"></a>JDK的命令行工具</h2><h3 id="jcmd-综合工具"><a href="#jcmd-综合工具" class="headerlink" title="jcmd 综合工具"></a>jcmd 综合工具</h3><ul><li><p><code>jcmd -l</code>  列出当前运行的所有虚拟机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5362</span> sun.tools.jcmd.JCmd -l</span><br><span class="line"><span class="number">1236</span> /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=<span class="number">9080</span> --debug=<span class="number">5</span> --handlerCountMax=<span class="number">100</span> --handlerCountMaxIdle=<span class="number">20</span></span><br><span class="line"><span class="number">7167</span> org.apache.catalina.startup.Bootstrap start</span><br></pre></td></tr></table></figure></li><li><p><code>jcmd [pid] VM.uptime</code>   查看虚拟机启动时间VM.uptime</p></li><li><code>jcmd [pid] Thread.print</code>  打印线程栈信息Thread.print</li><li><code>jcmd [pid] GC.class_histogram</code>  查看系统中类统计信息GC.class_histogram</li><li><code>jcmd [pid] GC.heap_dump [filepath&amp;name]</code>  导出堆信息GC.heap_dump  这个命令功能和 jmap -dump 功能一样</li><li><code>jcmd [pid] VM.system_properties</code> 获取系统Properties内容VM.system_properties</li><li><code>jcmd [pid] VM.flags</code> 获取启动参数VM.flags</li><li><code>jcmd [pid] PerfCounter.print</code>  获取所有性能相关数据PerfCounter.print<h3 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps 虚拟机进程状况工具"></a>jps 虚拟机进程状况工具</h3></li><li>jps（JVM Process Status Tool）可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。虽然功能比较单一，但它是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier,PID）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。</li><li><p>命令格式，其中[option]、[hostid]参数也可以不写。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-l : 输出主类全名或jar路径</span><br><span class="line">    •-q : 只输出LVMID</span><br><span class="line">    •-m : 输出JVM启动时传递给main()的参数</span><br><span class="line">    •-v : 输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l</span><br><span class="line"></span><br><span class="line">15232 org.gradle.launcher.daemon.bootstrap.GradleDaemon</span><br><span class="line">3104 sun.tools.jps.Jps</span><br><span class="line">6784 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br><span class="line">8916 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">15976</span><br><span class="line">8936 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">11580 com.songsy.iframe.Application</span><br></pre></td></tr></table></figure></li></ul><h3 id="jinfo-配置信息工具"><a href="#jinfo-配置信息工具" class="headerlink" title="jinfo 配置信息工具"></a>jinfo 配置信息工具</h3><ul><li><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p></li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] [args] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-flag : 输出指定args参数的值</span><br><span class="line">    •-flags : 不需要args参数，输出所有JVM参数的值</span><br><span class="line">    •-sysprops : 输出系统属性，等同于System.getProperties()</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags <span class="number">11580</span></span><br><span class="line"></span><br><span class="line">Attaching to process ID <span class="number">11580</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.121</span>-b13</span><br><span class="line">Non-<span class="keyword">default</span> VM flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=<span class="number">3</span> -XX:InitialHeapSize=<span class="number">134217728</span> -XX:+ManagementServer -XX:MaxHeapSize=<span class="number">2118123520</span> -XX:MaxNewSize=<span class="number">705691648</span> -XX:MinHeapDeltaBytes=<span class="number">524288</span> -XX:NewSize=<span class="number">44564480</span> -XX:OldSize=<span class="number">89653248</span> -XX:TieredStopAtLevel=<span class="number">1</span> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">Command line:  -agentlib:jdwp=transport=dt_socket,address=<span class="number">127.0</span>.0.1:<span class="number">58771</span>,suspend=y,server=n -XX:TieredStopAtLevel=<span class="number">1</span> -Xverify:none -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=<span class="number">58770</span> -Dcom.sun.management.jmxremote.authenticate=<span class="keyword">false</span> -Dcom.sun.management.jmxremote.ssl=<span class="keyword">false</span> -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=<span class="keyword">true</span> -javaagent:C:\Users\asua\.IntelliJIdea2017.2\system\groovyHotSwap\gragent.jar -Dfile.encoding=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><ul><li>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li><li><p>命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">    •[option] : 操作参数</span><br><span class="line">    •LVMID : 本地虚拟机进程ID</span><br><span class="line">    •[interval] : 连续输出的时间间隔</span><br><span class="line">    •[count] : 连续输出的次数</span><br><span class="line">    </span><br><span class="line">对于命令格式中的VMID与LVMID需要特别说明一下：</span><br><span class="line">如果是本地虚拟机进程，VMID与LVMID是一致的;</span><br><span class="line">如果是远程虚拟机进程，那VMID的格式应当是：protocol://lvmid@hostname:port/servername</span><br><span class="line">参数interval和count代表查询间隔(单位毫秒)和次数，如果省略这两个参数，说明只查询一次。</span><br><span class="line">假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20</span><br></pre></td></tr></table></figure></li><li><p>选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考表4-3中的描述。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/jstat.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><code>option</code>参数详解<blockquote><p><code>jstat -class</code>监视类装载、卸载数量、总空间以及耗费的时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -class 11580</span><br><span class="line"></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time</span><br><span class="line">  7107 13135.3        0     0.0       6.84</span><br><span class="line"></span><br><span class="line">•Loaded : 加载class的数量</span><br><span class="line">•Bytes : class字节大小</span><br><span class="line">•Unloaded : 未加载class的数量</span><br><span class="line">•Bytes : 未加载class的字节大小</span><br><span class="line">•Time : 加载时间</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p><code>jstat -compiler</code>输出JIT编译过的方法数量耗时等<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -compiler  11580</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    4079      3       0     1.62          1 org/springframework/beans/CachedIntrospectionResults &lt;init&gt;</span><br><span class="line"></span><br><span class="line">•Compiled : 编译数量</span><br><span class="line">•Failed : 编译失败数量</span><br><span class="line">•Invalid : 无效数量</span><br><span class="line">•Time : 编译耗时</span><br><span class="line">•FailedType : 失败类型</span><br><span class="line">•FailedMethod : 失败方法的全限定名</span><br></pre></td></tr></table></figure></p><p><code>jstat -gc</code> 垃圾回收堆的行为统计<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc  11580</span><br><span class="line"> S0C    S1C      S0U    S1U      EC       EU        OC         OU       MC      MU      CCSC    CCSU    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">39424.0 29696.0  0.0    0.0      414208.0 353447.8  118272.0   46473.8  35072.0 34285.7 4608.0  4457.1  9       0.233   2      0.149    0.382</span><br><span class="line"></span><br><span class="line">•S0C : survivor0区的总容量</span><br><span class="line">•S1C : survivor1区的总容量</span><br><span class="line">•S0U : survivor0区已使用的容量</span><br><span class="line">•S1C : survivor1区已使用的容量</span><br><span class="line">•EC : Eden区的总容量</span><br><span class="line">•EU : Eden区已使用的容量</span><br><span class="line">•OC : Old区的总容量</span><br><span class="line">•OU : Old区已使用的容量</span><br><span class="line">•PC 当前perm的容量 (KB)</span><br><span class="line">•PU perm的使用 (KB)</span><br><span class="line">•YGC : 新生代垃圾回收次数</span><br><span class="line">•YGCT : 新生代垃圾回收时间</span><br><span class="line">•FGC : 老年代垃圾回收次数</span><br><span class="line">•FGCT : 老年代垃圾回收时间</span><br><span class="line">•GCT : 垃圾回收总消耗时间</span><br></pre></td></tr></table></figure></p><p><code>jstat -gccapacity</code>同-gc，不过还会输出Java堆各区域使用到的最大、最小空间<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccapacity  11580</span><br><span class="line"> NGCMN    NGCMX     NGC      S0C     S1C       EC          OGCMN      OGCMX       OGC        OC            MCMN      MCMX         MC          CCSMN   CCSMX       CCSC    YGC    FGC</span><br><span class="line"> 43520.0  689152.0  689152.0 39424.0 29696.0   414208.0    87552.0    1379328.0   118272.0   118272.0      0.0       1079296.0    35072.0      0.0    1048576.0   4608.0  9      2</span><br><span class="line"> </span><br><span class="line">•NGCMN : 新生代占用的最小空间</span><br><span class="line">•NGCMX : 新生代占用的最大空间</span><br><span class="line">•OGCMN : 老年代占用的最小空间</span><br><span class="line">•OGCMX : 老年代占用的最大空间</span><br><span class="line">•OGC：当前年老代的容量 (KB)</span><br><span class="line">•OC：当前年老代的空间 (KB)</span><br><span class="line">•PGCMN : perm占用的最小空间</span><br><span class="line">•PGCMX : perm占用的最大空间</span><br></pre></td></tr></table></figure></p><p><code>jstat -gcutil</code> 同-gc，不过输出的是已使用空间占总空间的百分比<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0     S1     E      O      M      CCS       YGC     YGCT      FGC    FGCT     GCT</span><br><span class="line">0.00   0.00  85.33   39.29  97.76  96.73      9      0.233     2      0.149    0.382</span><br></pre></td></tr></table></figure></p><p><code>jstat -gccause</code> 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccause  11580</span><br><span class="line">  S0     S1    E      O      M      CCS    YGC  YGCT     FGC  FGCT     GCT    LGCC                 GCC</span><br><span class="line">  0.00   0.00  85.33  39.29  97.76  96.73  9    0.233    2    0.149    0.382  Allocation Failure   No GC</span><br><span class="line"></span><br><span class="line">•LGCC：最近垃圾回收的原因</span><br><span class="line">•GCC：当前垃圾回收的原因</span><br></pre></td></tr></table></figure></p><p><code>jstat -gcnew</code> 统计新生代的行为<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnew  11580</span><br><span class="line"> S0C    S1C      S0U    S1U  TT  MTT  DSS      EC       EU            YGC     YGCT</span><br><span class="line">39424.0 29696.0  0.0    0.0  2   15   39424.0  414208.0 353447.8      9       0.233</span><br></pre></td></tr></table></figure></p><p><code>jstat -gcnewcapacity</code> 新生代与其相应的内存空间的统计<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnewcapacity  11580</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   43520.0   689152.0   689152.0 229376.0  39424.0 229376.0  29696.0   688128.0   414208.0     9     2</span><br><span class="line"></span><br><span class="line">•NGC:当前年轻代的容量 (KB)</span><br><span class="line">•S0CMX:最大的S0空间 (KB)</span><br><span class="line">•S0C:当前S0空间 (KB)</span><br><span class="line">•ECMX:最大eden空间 (KB)</span><br><span class="line">•EC:当前eden空间 (KB)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><ul><li>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。</li><li>如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如加-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。</li><li>jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。</li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •dump : 生成堆转储快照，格式为:-dump:[live, ] format=b,file=&lt;filename&gt;,其中live子参数说明是否只dump出存活的对象。</span><br><span class="line">    •finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</span><br><span class="line">    •heap : 显示Java堆详细信息</span><br><span class="line">    •histo : 显示堆中对象的统计信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</span><br><span class="line">    •permstat : to print permanent generation statistics</span><br><span class="line">    •F : 当-dump没有响应时，强制生成dump快照</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 28920</span><br><span class="line"></span><br><span class="line">Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01  </span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC with 4 thread(s)                //GC 方式  </span><br><span class="line">  Heap Configuration:                         //堆内存初始化配置</span><br><span class="line">     MinHeapFreeRatio = 0                     //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">     MaxHeapFreeRatio = 100                   //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">     NewSize          = 1310720 (1.25MB)      //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">     MaxNewSize       = 17592186044415 MB     //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">     OldSize          = 5439488 (5.1875MB)    //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">     NewRatio         = 2                     //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">     SurvivorRatio    = 8                     //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">     PermSize         = 21757952 (20.75MB)    //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">     MaxPermSize      = 85983232 (82.0MB)     //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">     G1HeapRegionSize = 0 (0.0MB)  </span><br><span class="line">  Heap Usage:                                 //堆内存使用情况</span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space:                                 //Eden区内存分布</span><br><span class="line">     capacity = 33030144 (31.5MB)             //Eden区总容量</span><br><span class="line">     used     = 1524040 (1.4534378051757812MB)//Eden区已使用</span><br><span class="line">     free     = 31506104 (30.04656219482422MB)//Eden区剩余容量</span><br><span class="line">     4.614088270399305% used                  //Eden区使用比率</span><br><span class="line">  From Space:                                 //其中一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  To Space:                                   //另一个Survivor区的内存分布</span><br><span class="line">     capacity = 5242880 (5.0MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Old Generation                           //当前的Old区内存分布</span><br><span class="line">     capacity = 86507520 (82.5MB)</span><br><span class="line">     used     = 0 (0.0MB)</span><br><span class="line">     free     = 86507520 (82.5MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Perm Generation                          //当前的 “永生代” 内存分布</span><br><span class="line">     capacity = 22020096 (21.0MB)</span><br><span class="line">     used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">     free     = 19523568 (18.619125366210938MB)</span><br><span class="line">     11.337498256138392% used  </span><br><span class="line">interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>jmap -histo:live 28920 | more 打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">num     #instances         #bytes  class name</span><br><span class="line"><span class="comment">----------------------------------------------</span></span><br><span class="line">   1:         83613       12012248  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         23868       11450280  [B</span><br><span class="line">   3:         83613       10716064  &lt;methodKlass&gt;</span><br><span class="line">   4:         76287       10412128  [C</span><br><span class="line">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         73627        1767048  java.lang.String</span><br><span class="line">   9:          2260        1348848  &lt;methodDataKlass&gt;</span><br><span class="line">  10:          8856         849296  java.lang.Class</span><br><span class="line">  </span><br><span class="line">class name是对象类型，说明如下：</span><br><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><ul><li><p>jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。</p></li><li><p>不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器。二是用于分析的机器一般也是服务器，由于加载dump快照文件需要比生成dump更大的内存，所以一般在64位JDK、大内存的服务器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。</p></li><li><p>命令格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    jhat [option] [dumpfile]</span><br><span class="line">参数</span><br><span class="line">    •-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation <span class="keyword">call</span> stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</span><br><span class="line">    •-refs <span class="literal">false</span>|<span class="literal">true</span> 关闭对象引用跟踪(<span class="keyword">tracking</span> <span class="keyword">of</span> <span class="keyword">references</span> <span class="keyword">to</span> objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers <span class="keyword">or</span> incoming <span class="keyword">references</span>), 会统计/计算堆中的所有对象。&gt;</span><br><span class="line">    •-port port-<span class="built_in">number</span> 设置 jhat <span class="keyword">HTTP</span> <span class="keyword">server</span> 的端口号. 默认值 <span class="number">7000.</span>&gt; </span><br><span class="line">    •-<span class="keyword">exclude</span> <span class="keyword">exclude</span>-<span class="keyword">file</span> 指定对象查询时需要排除的数据成员列表文件(a <span class="keyword">file</span> that lists <span class="keyword">data</span> members that should be excluded <span class="keyword">from</span> the reachable objects <span class="keyword">query</span>)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 <span class="keyword">Object</span> o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</span><br><span class="line">    •-baseline <span class="keyword">exclude</span>-<span class="keyword">file</span> 指定一个基准堆转储(baseline <span class="keyword">heap</span> dump)。 在两个 <span class="keyword">heap</span> dumps 中有相同 <span class="keyword">object</span> <span class="keyword">ID</span> 的对象会被标记为不是新的(marked <span class="keyword">as</span> <span class="keyword">not</span> being <span class="keyword">new</span>). 其他对象被标记为新的(<span class="keyword">new</span>). 在比较两个不同的堆转储时很有用.&gt;</span><br><span class="line">    •-debug <span class="built_in">int</span> 设置 debug 级别. <span class="number">0</span> 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</span><br><span class="line">    •-<span class="keyword">version</span> 启动后只显示版本信息就退出&gt;</span><br><span class="line">    •-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的<span class="keyword">Java</span>虚拟机使用的最大堆内存为 <span class="number">512</span> MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ~ jhat eclipse.bin </span><br><span class="line">Reading from eclipse.bin...</span><br><span class="line">Dump file created Mon Oct 31 19:32:57 CST 2016</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 185857 objects...</span><br><span class="line">Chasing references, expect 37 dots.....................................</span><br><span class="line">Eliminating duplicate references.....................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br><span class="line"></span><br><span class="line">屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost:7000/就可以看到分析结果.</span><br><span class="line">分析结果默认是以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的“Heap Histogram”（与jmap -histo功能一样）与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计.</span><br></pre></td></tr></table></figure></li></ul><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><ul><li>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</li><li>命令格式<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] LVMID</span><br><span class="line"></span><br><span class="line">option参数</span><br><span class="line">    •-F : 当正常输出请求不被响应时，强制输出线程堆栈</span><br><span class="line">    •-l : 除堆栈外，显示关于锁的附加信息</span><br><span class="line">    •-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</span><br></pre></td></tr></table></figure></li></ul><h2 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h2><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/wade-luffy/p/6017137.html" target="_blank" rel="noopener">https://www.cnblogs.com/wade-luffy/p/6017137.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK的命令行工具&quot;&gt;&lt;a href=&quot;#JDK的命令行工具&quot; class=&quot;headerlink&quot; title=&quot;JDK的命令行工具&quot;&gt;&lt;/a&gt;JDK的命令行工具&lt;/h2&gt;&lt;h3 id=&quot;jcmd-综合工具&quot;&gt;&lt;a href=&quot;#jcmd-综合工具&quot; class
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型与线程(一)Java内存模型</title>
    <link href="http://www.songshuiyang.site/2019/03/21/backend/Java/JVM/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B(%E4%B8%80)Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.songshuiyang.site/2019/03/21/backend/Java/JVM/JVM内存模型与线程(一)Java内存模型/</id>
    <published>2019-03-21T13:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li>在说Java内存模型之前，我们先说一下Java的内存结构，也就是运行时的数据区域，这一块前面的章节已经介绍过了，很多人容易把内存结构跟内存模型搞混，内存结构就是下图中内存空间这些东西，而Java内存模型，完全是另外的一个东西。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/neicun.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景下就不许针对不同的平台来编写程序。</li></ul><h3 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1. 主内存与工作内存"></a>1. 主内存与工作内存</h3><ul><li><p>Java内存模型的主要目的是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。注意一下，此处的变量并不包括局部变量与方法参数，因为它们是线程私有的，不会被共享，自然也不会存在竞争，此处的变量应该是实例字段、静态字段和构成数组对象的元素。</p></li><li><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量和主内存副本拷贝（注意这里绝不会是整个对象的拷贝，试想一个10M的对象，在每个用到这个对象的工作内存中有一个10M的拷贝，内存还受得了？也就是一些在线程中用到的对象中的字段罢了），线程对变量所有的操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p></li></ul><h3 id="2-内存间交互操作"><a href="#2-内存间交互操作" class="headerlink" title="2. 内存间交互操作"></a>2. 内存间交互操作</h3><ul><li>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面体积的每一种操作都是原子的、不可再分的<ul><li>1、lock（锁定）：作用于主内存中的变量，它把一个变量标识为一条线程独占的状态</li><li>2、unlock（解锁）：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>3、read（读取）：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li><li>5、use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，没当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作</li><li>6、assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li>7、store（存储）：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用</li><li>8、write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中</li></ul></li><li>Java内存模型还规定了在执行上述8种基本操作时必须满足以下规则：<ul><li>1、不允许read和load、store和write操作之一单独出现</li><li>2、不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了滞后必须把该变化同步回主内存</li><li>3、不允许一个线程无原因地把数据从线程的工作内存同步回主内存中</li><li>4、一个新的变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量</li><li>5、一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li><li>6、如果对同一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值</li><li>7、如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定的变量</li><li>8、对一个变量执行unlock操作之前，必须先把此变量同步回主内存中</li></ul></li></ul><h3 id="3-对于volatile型变量的特殊规则"><a href="#3-对于volatile型变量的特殊规则" class="headerlink" title="3. 对于volatile型变量的特殊规则"></a>3. 对于volatile型变量的特殊规则</h3><ul><li><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。</p></li><li><p>一个变量被定义为volatile后，它将具备两种特性：</p><ul><li><p>1、保证此变量对所有线程的”可见性”，所谓”可见性”是指当一条线程修改了这个变量的值，新值对于其它线程来说都是可以立即得知的，而普通变量不能做到这一点，普通变量的值在在线程间传递均需要通过主内存来完成，关于volatile关键字的操作请参见volatile关键字使用举例，再强调一遍，volatile只保证了可见性，并不保证基于volatile变量的运算在并罚下是安全的</p></li><li><p>2、使用volatile变量的第二个语义是禁止指令重排序优化，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p></li></ul></li><li>总结一下Java内存模型对volatile变量定义的特殊规则：<ul><li>1、在工作内存中，每次使用某个变量的时候都必须线从主内存刷新最新的值，用于保证能看见其他线程对该变量所做的修改之后的值</li><li>2、在工作内存中，每次修改完某个变量后都必须立刻同步回主内存中，用于保证其他线程能够看见自己对该变量所做的修改</li><li>3、volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同 </li></ul></li></ul><h3 id="4-原子性、可见性与有序性"><a href="#4-原子性、可见性与有序性" class="headerlink" title="4. 原子性、可见性与有序性"></a>4. 原子性、可见性与有序性</h3><ul><li>1、原子性（Atomicity）</li></ul><p>由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store、write，大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大的原子性保证，Java内存模型还提供了lock和unlock，尽管虚拟机没有把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—-synchronized关键字</p><ul><li>2、可见性（Visibility）</li></ul><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile其实已经详细写了这一点，其实synchronized关键字也是可以实现可见性的，synchronized的可见性是由”对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。</p><ul><li>3、有序性（Ordering）</li></ul><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无须的。前半句是指”线程内表现为穿行的语义”，后半句是指”指令重排序”和”工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入</p><h3 id="5-先行发生原则"><a href="#5-先行发生原则" class="headerlink" title="5. 先行发生原则"></a>5. 先行发生原则</h3><ul><li><p>如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将变得很繁琐，但是我们在编写Java代码时并未感觉到这一点，这是因为Java语言中有一个”先行发生（happens-before）”原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则就判断出并发环境下两个操作之间是否可能存在冲突的问题。</p></li><li><p>所谓先行发生原则是指Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，那么操作A产生的影响能够被操作b观察到，”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。Java内存模型下有一些天然的，不需要任何同步协助器就已经存在的先行发生关系：</p><ul><li>1、程序次序规则：在一个线程内，按照控制流顺序，控制流前面的操作先行发生于控制流后面的操作，说”控制流”是因为还要考虑到分支、循环结构</li><li>2、管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</li><li>3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li><li>4、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</li><li>5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测</li><li>6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>7、对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始</li><li>8、传递新：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A必然先行发生于操作C</li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="noopener">https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html</a></li><li><a href="https://baijiahao.baidu.com/s?id=1595082600371869908&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1595082600371869908&amp;wfr=spider&amp;for=pc</a></li><li><a href="http://www.importnew.com/28456.html" target="_blank" rel="noopener">http://www.importnew.com/28456.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在说Java内存模型之前，我们先说一下Java的内存结构，也就是运行时的数据区域，这一块前面的章节已经介绍过了，很多人容易把内存
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行(二)基于栈的字节码解释器执行过程</title>
    <link href="http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C(%E4%BA%8C)%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM字节码执行(二)基于栈的字节码解释器执行过程/</id>
    <published>2019-03-19T14:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>根据一个代码实例来介绍虚拟机中解释器的执行过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;  </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;  </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;  </span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由上面的代码可以看出，该方法的逻辑很简单，就是进行简单的四则运算加减乘除，我们编译代码后使用javap -verbose命令查看字节码指令，具体字节码代码如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span></span>;  </span><br><span class="line">  Code:  </span><br><span class="line">   Stack=<span class="number">2</span>, Locals=<span class="number">4</span>, Args_size=<span class="number">1</span>  </span><br><span class="line">   <span class="number">0</span>:   bipush  <span class="number">100</span>  </span><br><span class="line">   <span class="number">2</span>:   istore_1  </span><br><span class="line">   <span class="number">3</span>:   sipush  <span class="number">200</span>  </span><br><span class="line">   <span class="number">6</span>:   istore_2  </span><br><span class="line">   <span class="number">7</span>:   sipush  <span class="number">300</span>  </span><br><span class="line">   <span class="number">10</span>:  istore_3  </span><br><span class="line">   <span class="number">11</span>:  iload_1  </span><br><span class="line">   <span class="number">12</span>:  iload_2  </span><br><span class="line">   <span class="number">13</span>:  iadd  </span><br><span class="line">   <span class="number">14</span>:  iload_3  </span><br><span class="line">   <span class="number">15</span>:  imul  </span><br><span class="line">   <span class="number">16</span>:  ireturn  </span><br><span class="line">  LineNumberTable:  </span><br><span class="line">   line <span class="number">3</span>: <span class="number">0</span>  </span><br><span class="line">   line <span class="number">4</span>: <span class="number">3</span>  </span><br><span class="line">   line <span class="number">5</span>: <span class="number">7</span>  </span><br><span class="line">   line <span class="number">6</span>: <span class="number">11</span>  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据字节码可以看出，这段代码需要深度为2的操作数栈（Stack=2）和4个Slot的局部变量空间（Locals=4）。下面，使用7张图片来描述上面的字节码代码执行过程中的代码、操作数栈和局部变量表的变化情况。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图展示了执行偏移地址为0的指令的情况，bipush指令的作用是将单字节的整型常量值（-128~127）推入操作数栈顶，后跟一个参数，指明推送的常量值，这里是100。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图则是执行偏移地址为2的指令，istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量Slot中。后面四条指令（3、6、7、10）都是做同样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。后面四条指令的图就不重复画了。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix3.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上面展示了执行偏移地址为11的指令，iload_1指令的作用是将局部变量第1个Slot中的整型值复制到操作数栈顶。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图为执行偏移地址12的指令，iload_2指令的执行过程与iload_1类似，把第2个Slot的整型值入栈。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix5.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>上图展示了执行偏移地址为13的指令情况，iadd指令的作用是将操作数栈中前两个栈顶元素出栈，做整型加法，然后把结果重新入栈。在iadd指令执行完毕后，栈中原有的100和200出栈，它们相加后的和300重新入栈。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix6.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>上图为执行偏移地址为14的指令的情况，iload_3指令把存放在第3个局部变量Slot中的300入栈到操作数栈中。这时操作数栈为两个整数300,。</p></li><li><p>下一条偏移地址为15的指令imul是将操作数栈中前两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，这里和iadd指令执行过程完全类似，所以就不重复画图了。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zhix7.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>上图是最后一条指令也就是偏移地址为16的指令的执行过程，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给此方法的调用者。到此为止，该方法执行结束。</p></li><li><p>注：上面的执行过程只是一种概念模型，虚拟机最终会对执行过程做出一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述。不过从这段程序的执行过程也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都是以操作数栈的出栈和入栈为信息交换途径。</p><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2></li><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/azhegps/article/details/54092466" target="_blank" rel="noopener">https://blog.csdn.net/azhegps/article/details/54092466</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据一个代码实例来介绍虚拟机中解释器的执行过程&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>字节码执行(一)运行时栈帧结构</title>
    <link href="http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C(%E4%B8%80)%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
    <id>http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/JVM字节码执行(一)运行时栈帧结构/</id>
    <published>2019-03-19T13:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>前几章介绍了Class类的文件结构及类的加载，有了原材料及已经运送过来了，那么就要生产产品了，那么字节码的执行就在生产产品</li><li>栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。</li><li>一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧的概念结构如下图所示：</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/stackFrame.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><h3 id="1-局部变量表"><a href="#1-局部变量表" class="headerlink" title="1. 局部变量表"></a>1. 局部变量表</h3><ul><li>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。</li><li>在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。</li><li>局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。</li></ul><h3 id="2-操作数栈"><a href="#2-操作数栈" class="headerlink" title="2. 操作数栈"></a>2. 操作数栈</h3><ul><li>操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。</li><li>当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。</li><li>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠过程如下图：</li></ul><p><img src="/images/server/java/JVM/stackFrame1.png" alt=""></p><h3 id="3-动态连接"><a href="#3-动态连接" class="headerlink" title="3. 动态连接"></a>3. 动态连接</h3><ul><li>每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。</li></ul><h3 id="4-方法返回地址"><a href="#4-方法返回地址" class="headerlink" title="4. 方法返回地址"></a>4. 方法返回地址</h3><ul><li>当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。</li><li>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。</li><li>无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。</li><li>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。</li></ul><h3 id="5-附加信息"><a href="#5-附加信息" class="headerlink" title="5. 附加信息"></a>5. 附加信息</h3><ul><li>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</li></ul><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><ul><li>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul><li><p>如前所述，所有的方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可变的。也就是说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用成为解析。</p></li><li><p>JAVA中符号“编译器可知、运行期不可变”的方法包括：静态方法、私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这就决定了他们都不可能通过继承或别的方式重写其版本。因此都适合在类的加载阶段进行解析。</p></li><li><p>JAVA虚拟机里面提供了5条方法调用字节码指令。分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">invokestatic:调用静态方法</span><br><span class="line"></span><br><span class="line">invokespecial:调用实例构造器&lt;init&gt;方法、私有方法和父类方法（<span class="keyword">super</span>(),<span class="keyword">super</span>.method()）。</span><br><span class="line"></span><br><span class="line">invokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、<span class="keyword">final</span>方法都是非虚方法)。</span><br><span class="line"></span><br><span class="line">invokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象。</span><br><span class="line"></span><br><span class="line">invokedynamic:现在运行时期动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的<span class="number">4</span>条指令，分派逻辑都是固化在虚拟机里面的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</span><br></pre></td></tr></table></figure></li><li><p>只要能被invokestatic和invokespecial指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载阶段就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法（还包括使用final修饰的方法，虽然final方法使用invokevirtual指令调用，因为final方法注定不会被重写，也就是无法被覆盖，也就无需对其进行多态选择）。</p></li><li><p>解析调用一定是一个静态的过程，在编译期间就可以完全确定，在类装载的解析阶段就会把涉及的符号引用全部转化为可确定的直接引用，不会延迟到运行期去完成。而分派调用可能是静态的也可能是动态的，根据分派一句的宗量数可分为单分派和多分派。因此分派可分为：静态单分派、静态多分派、动态单分派、动态多分派。</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/xtayfjpk/article/details/41924283" target="_blank" rel="noopener">https://blog.csdn.net/xtayfjpk/article/details/41924283</a></li><li><a href="https://www.cnblogs.com/chenyangyao/p/5305352.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyangyao/p/5305352.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;前几章介绍了Class类的文件结构及类的加载，有了原材料及已经运送过来了，那么就要生产产品了，那么字节码的执行就在生产产品&lt;/l
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制(二)类加载器</title>
    <link href="http://www.songshuiyang.site/2019/03/18/backend/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6(%E4%BA%8C)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/18/backend/Java/JVM/JVM类加载机制(二)类加载器/</id>
    <published>2019-03-18T13:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="1-类加载器"><a href="#1-类加载器" class="headerlink" title="1. 类加载器"></a>1. 类加载器</h3><ul><li><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，</p></li><li><p>3种类加载器：</p><ul><li>启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。启动类加载器是无法被Java程序直接引用的。</li><li>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/classLoad.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>例子：<blockquote><p>寻找类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">64f</span>ef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1</span>ddd40f3</span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure></p></blockquote><ul><li><p>从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p></li><li><p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></li><li><p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p></li><li><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul><h3 id="2-自定义类加载器"><a href="#2-自定义类加载器" class="headerlink" title="2. 自定义类加载器"></a>2. 自定义类加载器</h3><ul><li>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.neo.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String className) &#123;</span><br><span class="line">        String fileName = root + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(String root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        classLoader.setRoot(<span class="string">"E:\\temp"</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testClass = classLoader.loadClass(<span class="string">"com.neo.classloader.Test2"</span>);</span><br><span class="line">            Object object = testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-类的加载"><a href="#3-类的加载" class="headerlink" title="3. 类的加载"></a>3. 类的加载</h3><ul><li><p>类加载有三种方式</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul></li><li><p>Class.forName()和ClassLoader.loadClass()区别</p><ul><li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li>注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li></ul></li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul><li><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li><li><p>双亲委派机制:</p><ul><li>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li><li>如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；</li></ul></li><li>双亲委派模型意义：<ul><li>系统类防止内存中出现多份同样的字节码 </li><li>保证Java程序安全稳定运行<h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2></li></ul></li><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;h3 id=&quot;1-类加载器&quot;&gt;&lt;a href=&quot;#1-类加载器&quot; class=&quot;headerlink&quot; title=&quot;1. 类加载器&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载机制(一)类加载时机及过程</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6(%E4%B8%80)%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA%E5%8F%8A%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类加载机制(一)类加载时机及过程/</id>
    <published>2019-03-16T03:59:44.000Z</published>
    <updated>2019-03-25T13:02:01.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h2><ul><li><p>虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型</p></li><li><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口</p></li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul><li>如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。下面我们就分别来看一下这五个过程。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/jiazai.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><ul><li><p>加载的过程：</p><ul><li>1、通过一个类的全限定名来获取其定义的二进制字节流。</li><li>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li></ul></li><li><p>加载<code>.class</code>文件的方式:</p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件，比如java.lang.reflect.Proxy</li></ul></li><li><p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p></li><li><p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是Java堆中，在hotspot中它是存放在方法区中），这样便可以通过该对象访问方法区中的这些数据。</p></li></ul><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><ul><li><p>验证是为了确保被加载的类的正确性</p></li><li><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li><li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li><li>符号引用验证：确保解析动作能正确执行。</li></ul></li><li>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3></li><li><p>准备是为类的静态变量分配内存，并将其初始化为默认值</p></li><li><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意</p><ul><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中</li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li><li>假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行</clinit></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/defalutValue.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><ul><li>解析是把类中的符号引用转换为直接引用</li><li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</li><li>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3></li><li><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p></li><li><p>在Java中对类变量进行初始值设定有两种方式：</p><ul><li>声明类变量是指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ul></li><li>JVM初始化步骤<ul><li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul></li><li>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下五种(有且只有)：<ul><li>1、Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</li><li>2、创建类的实例，也就是new的方式或者访问某个类或接口的静态变量，或者对该静态变量赋值，以及调用一个类的静态方法</li><li>3、使用java.lang.reflect包的方法对类进行反射调用的时候（如Class.forName(“com.shengsiyuan.Test”)）</li><li>4、初始化某个类的子类，如果父类没有初始化则其父类也会被初始化</li><li>5、当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li></ul></li><li>被动引用<ul><li>通过子类引用父类的静态字段，不会导致子类初始化</li><li>通过数组定义来引用类，不会触发此类的初始化</li><li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发</li></ul></li></ul><h3 id="6-结束"><a href="#6-结束" class="headerlink" title="6.结束"></a>6.结束</h3><ul><li>在如下几种情况下，Java虚拟机将结束生命周期<ul><li>执行了System.exit()方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li></ul></li><li>研究类加载全过程有助于连接JVM运行过程</li><li>深入了解java动态性（热部署，动态加载），提高程序的灵活性</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.importnew.com/25295.html" target="_blank" rel="noopener">http://www.importnew.com/25295.html</a></li><li><a href="https://www.cnblogs.com/ityouknow/p/5603287.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5603287.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是类的加载&quot;&gt;&lt;a href=&quot;#什么是类的加载&quot; class=&quot;headerlink&quot; title=&quot;什么是类的加载&quot;&gt;&lt;/a&gt;什么是类的加载&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(三)字节码指令</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%89)%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(三)字节码指令/</id>
    <published>2019-03-16T02:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。由于JAVA虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码</p></li><li><p>伪代码执行模型</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/zijie.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="加载、存储指令"><a href="#加载、存储指令" class="headerlink" title="加载、存储指令"></a>加载、存储指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）iload、iload&lt;n&gt;、lload、lload&lt;n&gt;、fload、fload&lt;n&gt;、dload、dload&lt;n&gt;、aload、aload&lt;n&gt;：将一个局部变量加载到操作数栈。</span><br><span class="line">2）istore、istore&lt;n&gt;、lstore、lstore&lt;n&gt;、fstore、fstore&lt;n&gt;、dstore、dstore&lt;n&gt;、astore、astore&lt;n&gt;：将一个数值从操作数栈存储到局部变量表。</span><br><span class="line">3）bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconstm1、iconst&lt;i&gt;、lconst&lt;l&gt;、fconst&lt;f&gt;、dconst_&lt;d&gt;：将一个常量加载到操作数栈。</span><br><span class="line">4）wide：扩充局部变量表的访问索引的指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">methodE</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">300000</span>;</span><br><span class="line">    e++;</span><br><span class="line">    ++e;</span><br><span class="line">    --e;</span><br><span class="line">    e--;</span><br><span class="line">    <span class="keyword">return</span> c + d + e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">methodE</span><span class="params">()</span></span>;</span><br><span class="line">        Signature: ()I</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">        Code:</span><br><span class="line">        stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: sipush        <span class="number">300</span></span><br><span class="line">        <span class="number">6</span>: istore_1</span><br><span class="line">        7: ldc           #5                  // int 300000</span><br><span class="line">        <span class="number">9</span>: istore_2</span><br><span class="line">        <span class="number">10</span>: iinc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">13</span>: iinc          <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="number">16</span>: iinc          <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="number">19</span>: iinc          <span class="number">0</span>, -<span class="number">1</span></span><br><span class="line">        <span class="number">22</span>: iload_1</span><br><span class="line">        <span class="number">23</span>: iload_2</span><br><span class="line">        <span class="number">24</span>: iadd</span><br><span class="line">        <span class="number">25</span>: iload_0</span><br><span class="line">        <span class="number">26</span>: iadd</span><br><span class="line">        <span class="number">27</span>: ireturn</span><br><span class="line">        LineNumberTable:</span><br><span class="line">        line <span class="number">40</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">41</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">42</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">43</span>: <span class="number">10</span></span><br><span class="line">        line <span class="number">44</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">45</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">46</span>: <span class="number">19</span></span><br><span class="line">        line <span class="number">47</span>: <span class="number">22</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）iadd、ladd、fadd、dadd：加法指令。</span><br><span class="line">2）isub、lsub、fsub、dsub：减法指令。</span><br><span class="line">3）imul、lmul、fmul、dmul：乘法指令。</span><br><span class="line">4）idiv、ldiv、fdiv、ddiv：除法指令。</span><br><span class="line">5）irem、lrem、frem、drem：求余指令。</span><br><span class="line">6）ineg、lneg、fneg、dneg：取反指令。</span><br><span class="line">7）ishl、ishr、iushr、lshl、lshr、lushr：位移指令。</span><br><span class="line">8）ior、lor：按位或指令。</span><br><span class="line">9）iand、land：按位与指令。</span><br><span class="line">10）ixor、lxor：按位异或指令。</span><br><span class="line">11）iinc：局部变量自增指令。</span><br><span class="line">12）dcmpg、dcmpl、fcmpg、fcmpl、lcmp：比较指令。</span><br></pre></td></tr></table></figure><ul><li>示例参照上例</li></ul><h3 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1）int类型到long、float或者double类型，long类型到float、double类型，float类型到double类型：宽化类型转换（虚拟机直接支持）。</span><br><span class="line">2）i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f：窄化类型转换（显式指令）。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodK</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">short</span> i2s = (<span class="keyword">short</span>) i;</span><br><span class="line">    <span class="keyword">char</span> i2c = (<span class="keyword">char</span>) i;</span><br><span class="line">    <span class="keyword">long</span> i2l = i;</span><br><span class="line">    <span class="keyword">float</span> i2f = i;</span><br><span class="line">    <span class="keyword">double</span> i2d = i;</span><br><span class="line">    <span class="keyword">float</span> l2f = i2l;</span><br><span class="line">    <span class="keyword">double</span> l2d = i2l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodK</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">11</span>, args_size=<span class="number">0</span></span><br><span class="line">     <span class="number">0</span>: bipush        <span class="number">97</span></span><br><span class="line">     <span class="number">2</span>: istore_0</span><br><span class="line">     <span class="number">3</span>: iload_0</span><br><span class="line">     <span class="number">4</span>: i2s</span><br><span class="line">     <span class="number">5</span>: istore_1</span><br><span class="line">     <span class="number">6</span>: iload_0</span><br><span class="line">     <span class="number">7</span>: i2c</span><br><span class="line">     <span class="number">8</span>: istore_2</span><br><span class="line">     <span class="number">9</span>: iload_0</span><br><span class="line">    <span class="number">10</span>: i2l</span><br><span class="line">    <span class="number">11</span>: lstore_3</span><br><span class="line">    <span class="number">12</span>: iload_0</span><br><span class="line">    <span class="number">13</span>: i2f</span><br><span class="line">    <span class="number">14</span>: fstore        <span class="number">5</span></span><br><span class="line">    <span class="number">16</span>: iload_0</span><br><span class="line">    <span class="number">17</span>: i2d</span><br><span class="line">    <span class="number">18</span>: dstore        <span class="number">6</span></span><br><span class="line">    <span class="number">20</span>: lload_3</span><br><span class="line">    <span class="number">21</span>: l2f</span><br><span class="line">    <span class="number">22</span>: fstore        <span class="number">8</span></span><br><span class="line">    <span class="number">24</span>: lload_3</span><br><span class="line">    <span class="number">25</span>: l2d</span><br><span class="line">    <span class="number">26</span>: dstore        <span class="number">9</span></span><br><span class="line">    <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">100</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">101</span>: <span class="number">3</span></span><br><span class="line">    line <span class="number">102</span>: <span class="number">6</span></span><br><span class="line">    line <span class="number">103</span>: <span class="number">9</span></span><br><span class="line">    line <span class="number">104</span>: <span class="number">12</span></span><br><span class="line">    line <span class="number">105</span>: <span class="number">16</span></span><br><span class="line">    line <span class="number">106</span>: <span class="number">20</span></span><br><span class="line">    line <span class="number">107</span>: <span class="number">24</span></span><br><span class="line">    line <span class="number">108</span>: <span class="number">28</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1）new ：创建类实例的指令。</span><br><span class="line">2）newarray、anewarray、multianewarray：创建数组的指令。</span><br><span class="line">3）getstatic、putstatic、getfield、putfield：访问类字段（类变量）和实例字段（实例变量）的指令。</span><br><span class="line">4）baload、caload、saload、iaload、laload、faload、daload、aaload：把一个数组元素加载到操作数栈的指令。</span><br><span class="line">5）bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore：把一个操作数栈的值存储到数组元素中的指令。</span><br><span class="line">6）arraylength：取数组长度的指令。</span><br><span class="line">7）instanceof、checkcast：检查类实例类型的指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodJ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SimpleMethodExecuteProcess();</span><br><span class="line"></span><br><span class="line">    System.out.println(SimpleMethodExecuteProcess.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodJ</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">     0: new           #9                  // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: invokespecial #10                 // Method "&lt;init&gt;":()V</span><br><span class="line">     <span class="number">7</span>: pop</span><br><span class="line">     8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    11: getstatic     #11                 // Field i:I</span><br><span class="line">    14: invokevirtual #12                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">    <span class="number">17</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">91</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">93</span>: <span class="number">8</span></span><br><span class="line">    line <span class="number">94</span>: <span class="number">17</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）pop、pop2：将操作数栈的栈顶一个或两个元素出栈。</span><br><span class="line">2）dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。</span><br><span class="line">3）swap：将栈最顶端两个数值互换</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    heavyMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">        Signature: ([Ljava/lang/String;)V</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">        Code:</span><br><span class="line">                        stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">                        0: invokestatic  #23                 // Method heavyMethod:()I</span><br><span class="line">                        <span class="number">3</span>: pop</span><br><span class="line">                        <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">        LineNumberTable:</span><br><span class="line">                        line <span class="number">115</span>: <span class="number">0</span></span><br><span class="line">                        line <span class="number">116</span>: <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。</span><br><span class="line">2）tableswitch、lookupswitch：复合条件分支。</span><br><span class="line">3）goto、goto_w、jsr、jsr_w、ret：无条件分支。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodG</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodG</span><span class="params">()</span></span>;</span><br><span class="line"> Signature: ()V</span><br><span class="line"> flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"> Code:</span><br><span class="line">   stack=<span class="number">3</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">      0: getstatic     #6                  // Field i:I</span><br><span class="line">      <span class="number">3</span>: ifne          <span class="number">15</span></span><br><span class="line">      6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      9: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J</span><br><span class="line">     12: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V</span><br><span class="line">     15: getstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">18</span>: iconst_1</span><br><span class="line">     <span class="number">19</span>: if_icmpge     <span class="number">42</span></span><br><span class="line">     22: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">     25: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J</span><br><span class="line">     28: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V</span><br><span class="line">     31: getstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">34</span>: iconst_1</span><br><span class="line">     <span class="number">35</span>: iadd</span><br><span class="line">     36: putstatic     #6                  // Field i:I</span><br><span class="line">     <span class="number">39</span>: goto          <span class="number">15</span></span><br><span class="line">     <span class="number">42</span>: <span class="keyword">return</span></span><br><span class="line">   LineNumberTable:</span><br><span class="line">     line <span class="number">62</span>: <span class="number">0</span></span><br><span class="line">     line <span class="number">63</span>: <span class="number">6</span></span><br><span class="line">     line <span class="number">66</span>: <span class="number">15</span></span><br><span class="line">     line <span class="number">67</span>: <span class="number">22</span></span><br><span class="line">     line <span class="number">68</span>: <span class="number">31</span></span><br><span class="line">     line <span class="number">70</span>: <span class="number">42</span></span><br><span class="line">   StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">15</span> <span class="comment">/* same */</span></span><br><span class="line">        frame_type = <span class="number">26</span> <span class="comment">/* same */</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">athrow ：显式抛出异常指令。</span><br></pre></td></tr></table></figure><ul><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodH</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"nothing ..."</span>);</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodH</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">     0: new           #9                  // class java/lang/NullPointerException</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     4: ldc           #10                 // String nothing ...</span><br><span class="line">     6: invokespecial #11                 // Method java/lang/NullPointerException."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">     <span class="number">9</span>: athrow</span><br><span class="line">    <span class="number">10</span>: astore_0</span><br><span class="line">    <span class="number">11</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         <span class="number">0</span>    <span class="number">10</span>    <span class="number">10</span>   Class java/lang/Throwable</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">77</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">79</span>: <span class="number">10</span></span><br><span class="line">    line <span class="number">82</span>: <span class="number">11</span></span><br><span class="line">  StackMapTable: number_of_entries = <span class="number">1</span></span><br><span class="line">       frame_type = <span class="number">74</span> <span class="comment">/* same_locals_1_stack_item */</span></span><br><span class="line">      stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>同步指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitorenter、monitorexit：支持synchronized语句块语义的指令。</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodI</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Integer.class)&#123;</span><br><span class="line">        <span class="comment">// do nothing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodI</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">     0: ldc_w         #13                 // class java/lang/Integer</span><br><span class="line">     <span class="number">3</span>: dup</span><br><span class="line">     <span class="number">4</span>: astore_1</span><br><span class="line">     <span class="number">5</span>: monitorenter</span><br><span class="line">     <span class="number">6</span>: aload_1</span><br><span class="line">     <span class="number">7</span>: monitorexit</span><br><span class="line">     <span class="number">8</span>: goto          <span class="number">16</span></span><br><span class="line">    <span class="number">11</span>: astore_2</span><br><span class="line">    <span class="number">12</span>: aload_1</span><br><span class="line">    <span class="number">13</span>: monitorexit</span><br><span class="line">    <span class="number">14</span>: aload_2</span><br><span class="line">    <span class="number">15</span>: athrow</span><br><span class="line">    <span class="number">16</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">     from    to  target type</span><br><span class="line">         <span class="number">6</span>     <span class="number">8</span>    <span class="number">11</span>   any</span><br><span class="line">        <span class="number">11</span>    <span class="number">14</span>    <span class="number">11</span>   any</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">88</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">90</span>: <span class="number">6</span></span><br><span class="line">    line <span class="number">91</span>: <span class="number">16</span></span><br><span class="line">  StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">       frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">      offset_delta = <span class="number">11</span></span><br><span class="line">      locals = [ class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess, class java/lang/Object ]</span><br><span class="line">      stack = [ class java/lang/Throwable ]</span><br><span class="line">       frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">      offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>synchronized 修饰方法的语义解析：可以直接从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法，不需要解析出monitorenter、monitorexit同步指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodL</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodL</span><span class="params">()</span></span>;</span><br><span class="line">        Signature: ()V</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">        Code:</span><br><span class="line">            stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">0</span></span><br><span class="line">                 <span class="number">0</span>: bipush        <span class="number">97</span></span><br><span class="line">                 <span class="number">2</span>: istore_0</span><br><span class="line">                 <span class="number">3</span>: <span class="keyword">return</span></span><br><span class="line">            LineNumberTable:</span><br><span class="line">                line <span class="number">120</span>: <span class="number">0</span></span><br><span class="line">                line <span class="number">121</span>: <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>方法调用和返回指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1）invokestatic：调用静态方法。</span><br><span class="line">2）invokespecial：调用实例构造器&lt;init&gt;方法、私有方法和父类方法。</span><br><span class="line">3）invokevirtual：调用所有的虚方法。非虚方法以外的都是虚方法，非虚方法包括使用invokestatic、invokespecial调用的方法和被final修饰的方法。</span><br><span class="line">4）invokeinterface：调用接口方法，运行时再确定一个实现此接口的对象。</span><br><span class="line">5）invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。</span><br><span class="line">ireturn（返回值是boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn：方法返回指令。</span><br></pre></td></tr></table></figure></li><li><p>示例：</p><ul><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heavyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> c = methodC(methodA(methodA(a, b), b), methodB(a, b));</span><br><span class="line">    methodD();</span><br><span class="line">    methodE();</span><br><span class="line">    methodF();</span><br><span class="line">    methodG();</span><br><span class="line">    methodH();</span><br><span class="line">    <span class="keyword">new</span> SimpleMethodExecuteProcess().methodI();</span><br><span class="line">    methodJ();</span><br><span class="line">    methodK();</span><br><span class="line">    methodL();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对应的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">heavyMethod</span><span class="params">()</span></span>;</span><br><span class="line">Signature: ()I</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">  stack=<span class="number">3</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">     <span class="number">0</span>: sipush        <span class="number">200</span></span><br><span class="line">     <span class="number">3</span>: istore_0</span><br><span class="line">     <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">     <span class="number">6</span>: istore_1</span><br><span class="line">     <span class="number">7</span>: iload_0</span><br><span class="line">     <span class="number">8</span>: iload_1</span><br><span class="line">     9: invokestatic  #17                 // Method methodA:(II)I</span><br><span class="line">    <span class="number">12</span>: iload_1</span><br><span class="line">    13: invokestatic  #17                 // Method methodA:(II)I</span><br><span class="line">    <span class="number">16</span>: iload_0</span><br><span class="line">    <span class="number">17</span>: iload_1</span><br><span class="line">    18: invokestatic  #18                 // Method methodB:(II)I</span><br><span class="line">    21: invokestatic  #19                 // Method methodC:(II)I</span><br><span class="line">    <span class="number">24</span>: istore_2</span><br><span class="line">    25: invokestatic  #20                 // Method methodD:()V</span><br><span class="line">    28: invokestatic  #21                 // Method methodE:()I</span><br><span class="line">    <span class="number">31</span>: pop</span><br><span class="line">    32: invokestatic  #22                 // Method methodF:()D</span><br><span class="line">    <span class="number">35</span>: pop2</span><br><span class="line">    36: invokestatic  #23                 // Method methodG:()V</span><br><span class="line">    39: invokestatic  #24                 // Method methodH:()V</span><br><span class="line">    42: new           #14                 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess</span><br><span class="line">    <span class="number">45</span>: dup</span><br><span class="line">    46: invokespecial #15                 // Method "&lt;init&gt;":()V</span><br><span class="line">    49: invokevirtual #25                 // Method methodI:()V</span><br><span class="line">    52: invokestatic  #26                 // Method methodJ:()V</span><br><span class="line">    55: invokestatic  #27                 // Method methodK:()V</span><br><span class="line">    58: invokestatic  #28                 // Method methodL:()V</span><br><span class="line">    <span class="number">61</span>: iload_2</span><br><span class="line">    <span class="number">62</span>: ireturn</span><br><span class="line">  LineNumberTable:</span><br><span class="line">    line <span class="number">128</span>: <span class="number">0</span></span><br><span class="line">    line <span class="number">129</span>: <span class="number">4</span></span><br><span class="line">    line <span class="number">130</span>: <span class="number">7</span></span><br><span class="line">    line <span class="number">131</span>: <span class="number">25</span></span><br><span class="line">    line <span class="number">132</span>: <span class="number">28</span></span><br><span class="line">    line <span class="number">133</span>: <span class="number">32</span></span><br><span class="line">    line <span class="number">134</span>: <span class="number">36</span></span><br><span class="line">    line <span class="number">135</span>: <span class="number">39</span></span><br><span class="line">    line <span class="number">136</span>: <span class="number">42</span></span><br><span class="line">    line <span class="number">137</span>: <span class="number">52</span></span><br><span class="line">    line <span class="number">138</span>: <span class="number">55</span></span><br><span class="line">    line <span class="number">139</span>: <span class="number">58</span></span><br><span class="line">    line <span class="number">140</span>: <span class="number">61</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.51cto.com/damon188/2131035" target="_blank" rel="noopener">https://blog.51cto.com/damon188/2131035</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(二)Code属性</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%BA%8C)Code%E5%B1%9E%E6%80%A7/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(二)Code属性/</id>
    <published>2019-03-16T01:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据</p></li><li><p>Java虚拟机执行字节码是基于栈的体系结构</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/yxwkf/p/5222589.html" target="_blank" rel="noopener">https://www.cnblogs.com/yxwkf/p/5222589.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM类文件结构(一)Class类文件结构</title>
    <link href="http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(%E4%B8%80)Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(一)Class类文件结构/</id>
    <published>2019-03-16T00:59:44.000Z</published>
    <updated>2019-03-19T14:43:16.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ul><li><p>不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器直接生成)。</p></li><li><p>Class文件是一组以8位字节为基础单位的二进制流。各个数据项严格按顺序排列，没有不论什么分隔符。</p></li><li><p>Class文件格式採用一种类似于C语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。</p><ul><li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li><li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。</li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class.png" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li><p>使用以下的类进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getM</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>javap -verbose 执行后的可视byteCode（只存在两种数据类型：无符号数字与表）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/workspace-github/jvm/target/production/jvm/com/songsy/Test.class</span><br><span class="line">  Last modified <span class="number">2019</span>-<span class="number">3</span>-<span class="number">16</span>; size <span class="number">361</span> bytes</span><br><span class="line">  MD5 checksum bb8e54060828e4bf1f709c2f4434dca8</span><br><span class="line">  Compiled from <span class="string">"Test.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">songsy</span>.<span class="title">Test</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">51</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#18         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#19         // com/songsy/Test.m:I</span><br><span class="line">   #3 = Class              #20            // com/songsy/Test</span><br><span class="line">   #4 = Class              #21            // java/lang/Object</span><br><span class="line">   #5 = Utf8               m</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/songsy/Test;</span><br><span class="line">  #14 = Utf8               getM</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               SourceFile</span><br><span class="line">  #17 = Utf8               Test.java</span><br><span class="line">  #18 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #19 = NameAndType        #5:#6          // m:I</span><br><span class="line">  #20 = Utf8               com/songsy/Test</span><br><span class="line">  #21 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.songsy.Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/songsy/Test;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getM</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field m:I</span><br><span class="line">         <span class="number">4</span>: iconst_1</span><br><span class="line">         <span class="number">5</span>: iadd</span><br><span class="line">         <span class="number">6</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/songsy/Test;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Test.java"</span></span><br></pre></td></tr></table></figure></li><li><p>编译后的class文件例如以下：</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-魔数与Class版本"><a href="#1-魔数与Class版本" class="headerlink" title="1. 魔数与Class版本"></a>1. 魔数与Class版本</h3><ul><li>每一个class文件的头4个字节称为魔数，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。非常多文件存储标准中都使用魔数来进行身份识别。譬如图片格式gif、jpeg等。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，由于文件拓展格式能够任意修改。Class文件的魔数为：0xCAFEBABE（咖啡宝贝？）。这个魔数似乎也预示着日后JAVA这个商标名称的出现。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>第五六个字节是次版本（Minor Version）。第7和第8个字节是主版本（Major Version）。</p></li><li><p>高版本号的JDK能够向下兼容曾经版本号的Class文件，可是无法执行以后版本号的Class文件，即使文件格式并未发生变化，虚拟机也必须拒绝执行超过其版本号号的Class文件。</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class-version.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-常量池"><a href="#2-常量池" class="headerlink" title="2. 常量池"></a>2. 常量池</h3><ul><li>紧接着版本之后就是常量池，常量池能够理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之中的一个。同一时候也是在Class文件里第一个出现的表类型数据项目</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>常量池中主要存放两大类常量<ul><li>字面量和符号引用。字面量如文本字符串、声明为final的常量值等</li><li>符号引用包含三类常量：类和接口的全限定名、字段的名称和描写叙述符、方法的名称和描写叙述符。</li></ul></li></ul><h3 id="3-访问标志"><a href="#3-访问标志" class="headerlink" title="3. 访问标志"></a>3. 访问标志</h3><ul><li>在常量池结束之后，紧接着的两个字节代表訪问标志。用于识别一些类或者接口层次的訪问信息。包括：这个类是Class类还是接口；是否定义为public类型，是否被声明为final，具体的标志位及其含义例如以下表所看到的。</li></ul><p><img src="/images/server/java/JVM/class-access.png" alt="image"></p><ul><li>依据上面的表格，測试类的訪问标志0x0021= 0x0001 | 0x0020 =ACC_PUBLIC | ACC_SUPER </li></ul><p><img src="/images/server/java/JVM/class4.png" alt=""></p><h3 id="4-类索引、父类索引和接口索引集合"><a href="#4-类索引、父类索引和接口索引集合" class="headerlink" title="4. 类索引、父类索引和接口索引集合"></a>4. 类索引、父类索引和接口索引集合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>Class文件里由这3项数据来确定这个类的继承关系<ul><li>this_class：类索引，用于确定这个类的全限定名，占2字节</li><li>super_class：父类索引。用于确定这个类父类的全限定名（Java语言不同意多重继承，故父类索引仅仅有一个。除了java.lang.Object类之外全部类都有父类，故除了java.lang.Object类之外，全部类该字段值都不为0），占2字节</li><li>interfaces_count：接口索引计数器。占2字节。接口索引计数器。占2字节。</li><li>interfaces：接口索引集合，一组u2类型数据的集合。用来描写叙述这个类实现了哪些接口。这些被实现的接口将按implements语句（假设该类本身为接口，则为extends语句）后的接口顺序从左至右排列在接口的索引集合中</li></ul></li><li>this_class、super_class与interfaces中保存的索引值均指向常量池中一个CONSTANT_Class_info类型的常量。通过这个常量中保存的索引值能够找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串this_class的值为0x0001，即常量池中第一个常量，super_class的值为0x0003，即常量池中的第三个常量，interfaces_counts的值为0x0000，故接口索引集合大小为0</li></ul><h3 id="5-字段表集合"><a href="#5-字段表集合" class="headerlink" title="5. 字段表集合"></a>5. 字段表集合</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/class6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>字段表用于描写叙述接口或者类中声明的变量，包含类级变量和实例级变量(是否是static)。但不包含在方法内部声明的局部变量。<ul><li>fields_count：字段表计数器。即字段表集合中的字段表数据个数。占2字节，其值为0x0001，即仅仅有一个字段表数据。也就是測试类中仅仅包括一个变量（不算方法内部变量）</li><li>字段表集合，一组字段表类型数据的集合。字段表用于描写叙述接口或类中声明的变量。包含类级别（static）和实例级别变量，不包含在方法内部声明的变量 <h3 id="6-方法表集合"><a href="#6-方法表集合" class="headerlink" title="6. 方法表集合"></a>6. 方法表集合</h3></li></ul></li><li><p>methods_count：方法表计数器，即方法表集合中的方法表数据个数。占2字节，其值为0x0002，即測试类中有2个方法(还自己主动添加了一个构造函数）</p></li><li><p>methods：方法表集合，一组方法表类型数据的集合。方法表结构和字段表结构一样：</p></li></ul><h3 id="7-属性表集合"><a href="#7-属性表集合" class="headerlink" title="7. 属性表集合"></a>7. 属性表集合</h3><ul><li><p>在Class文件、属性表、方法表中都能够包括自己的属性表集合。用于描写叙述某些场景的专有信息</p></li><li><p>与Class文件里其他数据项对长度、顺序、格式的严格要求不同，属性表集合不要求当中包括的属性表具有严格的顺序，而且仅仅要属性的名称不与已有的属性名称反复。不论什么人实现的编译器可以向属性表中写入自定义的属性信息。虚拟机在执行时会忽略不能识别的属性，为了能正确解析Class文件</p></li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/yxwkf/p/5222589.html" target="_blank" rel="noopener">https://www.cnblogs.com/yxwkf/p/5222589.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; class=&quot;headerlink&quot; title=&quot;解析&quot;&gt;&lt;/a&gt;解析&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(五)GC分析</title>
    <link href="http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%BA%94)GC%E5%88%86%E6%9E%90/"/>
    <id>http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM垃圾回收(五)GC分析/</id>
    <published>2019-03-11T15:59:44.000Z</published>
    <updated>2019-03-26T13:58:09.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC日志查看"><a href="#GC日志查看" class="headerlink" title="GC日志查看"></a>GC日志查看</h2><ul><li>可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。GC的日志是以替换的方式(&gt;)写入的，而不是追加(&gt;&gt;)，如果下次写入到同一个文件中的话，以前的GC内容会被清空。</li><li><p>对应的参数列表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:../logs/gc.log 日志文件的输出路径</span><br></pre></td></tr></table></figure></li><li><p>示例 <code>-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs</code></p><blockquote><p>新生代回收日志</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K-&gt;2K(948864K), 0.0059180 secs] 2186589K-&gt;1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">``` </span><br><span class="line">```sql</span><br><span class="line">2014-07-18T16:02:17.606+0800（当前时间戳）: 611.633（时间戳）: [GC（表示Young GC） 611.633: [DefNew（单线程Serial年轻代GC）: 843458K（年轻代垃圾回收前的大小）-&gt;2K（年轻代回收后的大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）] 2186589K（整个堆回收前的大小）-&gt;1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）]</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>老年代回收的日志如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2014-07-18T16:19:16.794+0800: 1630.821: [GC 1630.821: [DefNew: 1005567K-&gt;111679K(1005568K), 0.9152360 secs]1631.736: [Tenured:2573912K-&gt;1340650K(2574068K), 1.8511050 secs] 3122548K-&gt;1340650K(3579636K), [Perm : 17882K-&gt;17882K(21248K)], 2.7854350 secs] [Times: user=2.57 sys=0.22, real=2.79 secs]</span><br></pre></td></tr></table></figure></p></blockquote><p># </p><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/qlqwjy/p/7929414.html" target="_blank" rel="noopener">https://www.cnblogs.com/qlqwjy/p/7929414.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GC日志查看&quot;&gt;&lt;a href=&quot;#GC日志查看&quot; class=&quot;headerlink&quot; title=&quot;GC日志查看&quot;&gt;&lt;/a&gt;GC日志查看&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。GC的
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(四)常用参数</title>
    <link href="http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E5%9B%9B)%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
    <id>http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM垃圾回收(四)常用参数/</id>
    <published>2019-03-11T13:59:44.000Z</published>
    <updated>2019-03-26T11:02:02.723Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JVM参数的含义</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-Xms</td><td style="text-align:left">初始堆大小starting</td><td>物理内存的1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td style="text-align:left">-Xmx</td><td style="text-align:left">最大堆大小max</td><td>物理内存的1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td style="text-align:left">-Xmn</td><td style="text-align:left">年轻代大小(1.4or lator)new</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</td></tr><tr><td style="text-align:left">-XX:NewSize</td><td style="text-align:left">设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:MaxNewSize</td><td style="text-align:left">年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:PermSize</td><td style="text-align:left">设置持久代(perm gen)初始值</td><td>物理内存的1/64</td><td></td></tr><tr><td style="text-align:left">-XX:MaxPermSize</td><td style="text-align:left">设置持久代最大值</td><td>物理内存的1/4</td><td></td></tr><tr><td style="text-align:left">-Xss</td><td style="text-align:left">每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:””-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。</td></tr><tr><td style="text-align:left">-XX:ThreadStackSize</td><td style="text-align:left">Thread Stack Size</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:NewRatio</td><td style="text-align:left">年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置</td></tr><tr><td style="text-align:left">-XX:SurvivorRatio</td><td style="text-align:left">Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10</td></tr><tr><td style="text-align:left">-XX:LargePageSizeInBytes</td><td style="text-align:left">内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>=128m</td></tr><tr><td style="text-align:left">-XX:+UseFastAccessorMethods</td><td style="text-align:left">原始类型的快速优化</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+DisableExplicitGC</td><td style="text-align:left">关闭System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td style="text-align:left">-XX:MaxTenuringThreshold</td><td style="text-align:left">垃圾最大年龄</td><td></td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效</td></tr><tr><td style="text-align:left">-XX:+AggressiveOpts</td><td style="text-align:left">加快编译</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+UseBiasedLocking</td><td style="text-align:left">锁机制的性能改善</td><td></td><td></td></tr><tr><td style="text-align:left">-Xnoclassgc</td><td style="text-align:left">禁用垃圾回收</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:SoftRefLRUPolicyMSPerMB</td><td style="text-align:left">每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td></td></tr><tr><td style="text-align:left">-XX:PretenureSizeThreshold</td><td style="text-align:left">对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td style="text-align:left">-XX:TLABWasteTargetPercent</td><td style="text-align:left">TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td style="text-align:left">-XX:+CollectGen0First</td><td style="text-align:left">FullGC时是否先YGC</td><td>false</td></tr></tbody></table><blockquote><p>并行收集器相关参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+UseParallelGC</td><td style="text-align:left">Full GC采用parallel MSC(此项待验证)</td><td></td><td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td></tr><tr><td style="text-align:left">-XX:+UseParNewGC</td><td style="text-align:left">设置年轻代为并行收集</td><td></td><td>可与CMS收集同时使用JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td></tr><tr><td style="text-align:left">-XX:ParallelGCThreads</td><td style="text-align:left">并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td style="text-align:left">-XX:+UseParallelOldGC</td><td style="text-align:left">年老代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td><td>这个是JAVA 6出现的参数选项</td></tr><tr><td style="text-align:left">-XX:MaxGCPauseMillis</td><td style="text-align:left">每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr><tr><td style="text-align:left">-XX:+UseAdaptiveSizePolicy</td><td style="text-align:left">自动选择年轻代区大小和相应的Survivor区比例</td><td></td><td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td></tr><tr><td style="text-align:left">-XX:GCTimeRatio</td><td style="text-align:left">设置垃圾回收时间占程序运行时间的百分比</td><td></td><td>公式为1/(1+n)</td></tr><tr><td style="text-align:left">-XX:+ScavengeBeforeFullGC</td><td style="text-align:left">Full GC前调用YGC</td><td>true</td><td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td></tr></tbody></table><blockquote><p>CMS相关参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+UseConcMarkSweepGC</td><td style="text-align:left">使用CMS内存收集</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+AggressiveHeap</td><td style="text-align:left"></td><td></td><td>试图是使用大量的物理内存长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td style="text-align:left">-XX:CMSFullGCsBeforeCompaction</td><td style="text-align:left">多少次后进行内存压缩</td><td></td><td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td></tr><tr><td style="text-align:left">-XX:+CMSParallelRemarkEnabled</td><td style="text-align:left">降低标记停顿</td><td></td><td></td></tr><tr><td style="text-align:left">-XX+UseCMSCompactAtFullCollection</td><td style="text-align:left">在FULL GC的时候， 对年老代的压缩</td><td></td><td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片</td></tr><tr><td style="text-align:left">-XX:+UseCMSInitiatingOccupancyOnly</td><td style="text-align:left">使用手动定义初始化定义开始CMS收集</td><td></td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td style="text-align:left">-XX:CMSInitiatingOccupancyFraction=70</td><td style="text-align:left">使用cms作为垃圾回收使用70％后开始CMS收集</td><td>92</td><td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式</td></tr><tr><td style="text-align:left">-XX:CMSInitiatingPermOccupancyFraction</td><td style="text-align:left">设置Perm Gen使用到达多少比率时触发</td><td>92</td><td></td></tr><tr><td style="text-align:left">-XX:+CMSIncrementalMode</td><td style="text-align:left">设置为增量模式</td><td></td><td>用于单CPU情况</td></tr><tr><td style="text-align:left">-XX:+CMSClassUnloadingEnabled</td><td style="text-align:left"></td><td></td></tr></tbody></table><blockquote><p>辅助参数</p></blockquote><table><thead><tr><th style="text-align:left">参数名称</th><th style="text-align:left">含义</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left">-XX:+PrintGC</td><td style="text-align:left"></td><td></td><td>输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143 secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCDetails</td><td style="text-align:left"></td><td></td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCTimeStamps</td><td style="text-align:left"></td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintGCApplicationStoppedTime</td><td style="text-align:left">打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td></td><td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td></tr><tr><td style="text-align:left">-XX:+PrintGCApplicationConcurrentTime</td><td style="text-align:left">打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td><td></td><td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td></tr><tr><td style="text-align:left">-XX:+PrintHeapAtGC</td><td style="text-align:left">打印GC前后的详细堆栈信息</td><td></td><td></td></tr><tr><td style="text-align:left">-Xloggc:filename</td><td style="text-align:left">把相关日志信息记录到文件以便分析，与上面几个配合使用</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintClassHistogram</td><td style="text-align:left">garbage collects before printing the histogram.</td><td></td><td></td></tr><tr><td style="text-align:left">-XX:+PrintTLAB</td><td style="text-align:left">查看TLAB空间的使用情况</td><td></td><td></td></tr><tr><td style="text-align:left">XX:+PrintTenuringDistribution</td><td style="text-align:left">查看每次minor GC后新的存活周期的阈值</td><td></td><td>Desired survivor size 1048576 bytes, new threshold 7 (max 15)new threshold 7即标识新的存活周期的阈值为7。</td></tr></tbody></table><blockquote><p>备注</p><ul><li><code>-X</code> 开头参数的是非标准，不是所有虚拟机都支持，<code>-XX</code>更流氓，不保证其稳定性</li><li></li></ul></blockquote><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;JVM参数的含义&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;参数名称&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;含义&lt;/th&gt;
&lt;t
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(三)内存分配及回收策略</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%B8%89)%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%8A%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(三)内存分配及回收策略/</id>
    <published>2019-03-10T14:59:44.000Z</published>
    <updated>2019-03-26T13:00:18.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。</li><li>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。<ul><li>TLAB: 首先讲讲什么是TLAB。内存分配的动作，可以按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。这么做的目的之一，也是为了并发创建一个对象时，保证创建对象的线程安全性。TLAB比较小，直接在TLAB上分配内存的方式称为快速分配方式，而TLAB大小不够，导致内存被分配在Eden区的内存分配方式称为慢速分配方式。</li></ul></li><li>接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。由于条件因素，只能在Client模式下测试，因此CMS和G1并未提及。<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2></li></ul><h3 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h3><ul><li>所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。<ul><li>新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。</li><li>老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。</li></ul></li></ul><p><img src="/images/server/java/JVM/gc-generation.gif" alt=""></p><ul><li><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。这时会把存活的对象转移进Survivor区。</p><ul><li><code>Minor GC</code> 新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。</li><li><code>Major GC</code> 老年代GC，指发生在老年代的GC。</li><li><code>Full GC</code> 包括前两个</li></ul></li><li><p>举例说明</p><ul><li><p>下面的代码来看一下jvm具体是怎样分配的，下面的代码注释有详细解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：</span></span><br><span class="line"><span class="comment"> *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> * 参数解析：</span></span><br><span class="line"><span class="comment"> *      * 初始堆大小为20兆，不可扩展，年轻代大小为10兆剩下的10兆分配给老年代，PrintGCDetails打印内存回收日志，SurvivorRatio标识 eden与Survivor比例为8:1</span></span><br><span class="line"><span class="comment"> *      * "eden space 8192K from space 1024K to space 1024K" 新生代总可用空间为9216KB (一个Eden区 + 一个Survivor区)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/11 18:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1KB = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * _1KB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1,allocation2, allocation3,allocation4,allocation5;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 执行到下一步出现一次Minor GC，因为发现Eden已经被占用了6Mb，剩余空间装不下4Mb，</span></span><br><span class="line"><span class="comment">         * 执行gc的时候发现已有3*2Mb的对象无法放入Survivor（只有1mb）空间，所以只好通过</span></span><br><span class="line"><span class="comment">         * 分配担保机制提前转移到老年代去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Gc结束，4Mb的allocation4对象将分配在Eden区，老年代占用6Mb</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">* 输出日志</span><br></pre></td></tr></table></figure><p>[GC[DefNew: 7485K-&gt;526K(9216K), 0.0076710 secs] 7485K-&gt;6671K(19456K), 0.0077381 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]<br>Heap<br>def new generation   total 9216K, used 4952K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)<br>eden space 8192K,  54% used [0x00000000f9a00000, 0x00000000f9e526c8, 0x00000000fa200000)<br>from space 1024K,  51% used [0x00000000fa300000, 0x00000000fa383bd8, 0x00000000fa400000)<br>to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)<br>tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)<br> the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)<br>compacting perm gen  total 21248K, used 2950K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)<br> the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0e1918, 0x00000000fb0e1a00, 0x00000000fc2c0000)<br>No shared spaces configured.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">### 2. 大对象直接进入老年代</span><br><span class="line">* 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）。</span><br><span class="line">* 虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。</span><br><span class="line">* 举例说明</span><br><span class="line">    ```java</span><br><span class="line">    /**</span><br><span class="line">     * 测试大对象直接进入老年代</span><br><span class="line">     *</span><br><span class="line">     * VM参数：</span><br><span class="line">     *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br><span class="line">     * -XX:PretenureSizeThreshold=3145728 可选</span><br><span class="line">     * </span><br><span class="line">     * @author songsy</span><br><span class="line">     * @date 2019/3/11 18:37</span><br><span class="line">     */</span><br><span class="line">    public class Jvm2 &#123;</span><br><span class="line">    </span><br><span class="line">        private static final int _1KB = 1024;</span><br><span class="line">        private static final int _1MB = 1024 * _1KB;</span><br><span class="line">    </span><br><span class="line">        public static void testAllocation() &#123;</span><br><span class="line">            byte [] allocation1;</span><br><span class="line">            // 直接分配在老年代</span><br><span class="line">            allocation1 = new byte[4 * _1MB];</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            testAllocation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>没设置PretenureSizeThreshold，可以看到新生代<code>def new generation   total 9216K, used 5773K</code>，老年代<code>tenured generation   total 10240K, used 0K</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 5773K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)</span><br><span class="line">  eden space 8192K,  70% used [0x00000000f9a00000, 0x00000000f9fa3668, 0x00000000fa200000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)</span><br><span class="line"> tenured generation   total 10240K, used 0K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)</span><br><span class="line">   the space 10240K,   0% used [0x00000000fa400000, 0x00000000fa400000, 0x00000000fa400200, 0x00000000fae00000)</span><br><span class="line"> compacting perm gen  total 21248K, used 3237K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)</span><br><span class="line">   the space 21248K,  15% used [0x00000000fae00000, 0x00000000fb129600, 0x00000000fb129600, 0x00000000fc2c0000)</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>* 设置了PretenureSizeThreshold结果，可以看到新生代`def new generation   total 9216K, used 1671K` ,老年代`tenured generation   total 10240K, used 4096K`<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1671K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)</span><br><span class="line">  eden space 8192K,  20% used [0x00000000f9a00000, 0x00000000f9ba1c08, 0x00000000fa200000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)</span><br><span class="line">   the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)</span><br><span class="line"> compacting perm gen  total 21248K, used 2938K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)</span><br><span class="line">   the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0de9e0, 0x00000000fb0dea00, 0x00000000fc2c0000)</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure></code></pre><h3 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h3><ul><li>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象放在新生代，那些对象放在老年代中</li><li>为了能做到这一点，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数<code>-XX：MaxTenuringThreshold</code>设置。</li><li>举例说明  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试长期存活的对象进入老年代</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * VM参数：</span></span><br><span class="line"><span class="comment"> *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold=1 可选</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songsy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/3/11 18:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jvm3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1KB = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * _1KB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> [] allocation1,allocation2, allocation3;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">        <span class="comment">// 虽然此处赋值为null，但未进行Gc空间仍被占用，下一行代码会执行minor GC</span></span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将MaxTenuringThreshold设为1，可以看出第二次Minor GC时，年轻代已经被清空，allocation1对象因为年龄符合MaxTenuringThreshold设置的值，因此进入老年代。</span></span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h3><ul><li>为了能更好的适应不同程序的内存状态，虚拟机并不是永远的要求对象的年龄必须达到<code>MaxTenuringThreshold</code>才能晋升老年代的</li><li>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li></ul><h3 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h3><ul><li>内存分配是在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。</li><li>Parallel Scavenge收集器与其他收集器在空间分配担保上有一点差别, 正常是在Minor GC前进行检查, 而Parallel Scavenge收集器在Minor GC后也会进行检查。</li><li>另外当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://blog.csdn.net/v123411739/article/details/78941793" target="_blank" rel="noopener">https://blog.csdn.net/v123411739/article/details/78941793</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(二)垃圾回收器</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%BA%8C)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(二)垃圾回收器/</id>
    <published>2019-03-10T13:59:50.000Z</published>
    <updated>2019-03-26T13:22:03.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</li><li>Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的回收器可能会有很大差异，一般是提供参数供用户根据自己的应用特点和要求组合各个年代所使用的回收器</li><li>这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图3-5所示，上半部分是新生代的回收器，下半部分是老年代的回收器</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/hotspot.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. Serial 收集器</h3><ul><li>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。</li><li>大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</li><li>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcj1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-Serial-Old-收集器"><a href="#2-Serial-Old-收集器" class="headerlink" title="2. Serial Old 收集器"></a>2. Serial Old 收集器</h3><ul><li>Serial收集器的老年代版本，它同样是一个单线程收集器。</li><li>它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</li></ul><h3 id="3-ParNew-收集器"><a href="#3-ParNew-收集器" class="headerlink" title="3. ParNew 收集器"></a>3. ParNew 收集器</h3><ul><li>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li><li>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</li><li>并行和并发概念补充：<ul><li>并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj2.jpg" alt=""></p><h3 id="4-Parallel-Old收集器"><a href="#4-Parallel-Old收集器" class="headerlink" title="4. Parallel Old收集器"></a>4. Parallel Old收集器</h3><ul><li>Parallel Scavenge收集器的老年代版本。</li><li>使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</li></ul><h3 id="5-Parallel-Scavenge收集器"><a href="#5-Parallel-Scavenge收集器" class="headerlink" title="5. Parallel Scavenge收集器"></a>5. Parallel Scavenge收集器</h3><ul><li>Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？</li><li><p>Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC </span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用Parallel收集器+ 老年代并行</span><br></pre></td></tr></table></figure></li><li><p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</p></li><li>新生代采用复制算法，老年代采用标记-整理算法。 </li></ul><p><img src="/images/server/java/JVM/gcj3.jpg" alt=""></p><h3 id="6-CMS收集器"><a href="#6-CMS收集器" class="headerlink" title="6. CMS收集器"></a>6. CMS收集器</h3><ul><li>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</li><li>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</li><li>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：<ul><li>初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 </li><li>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li></ul></li></ul><p><img src="/images/server/java/JVM/gcj4.jpg" alt=""></p><ul><li><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：</p><ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生<h3 id="7-G1收集器"><a href="#7-G1收集器" class="headerlink" title="7. G1收集器"></a>7. G1收集器</h3></li></ul></li><li><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</p></li><li><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点</p><ul><li>G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li>与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li>可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul></li><li>G1收集器的运作大致分为以下几个步骤：<ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul></li><li>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html</a></li><li><a href="https://blog.csdn.net/qq_34337272/article/details/82177383" target="_blank" rel="noopener">https://blog.csdn.net/qq_34337272/article/details/82177383</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。&lt;/li&gt;
&lt;li&gt;Java虚拟机规范对垃圾回收器应该如
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收(一)垃圾回收算法</title>
    <link href="http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6(%E4%B8%80)%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(一)垃圾回收算法/</id>
    <published>2019-03-10T13:59:44.000Z</published>
    <updated>2019-04-23T12:04:15.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p></li><li><p>而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</p></li></ul><h2 id="判断对象是否存活的算法"><a href="#判断对象是否存活的算法" class="headerlink" title="判断对象是否存活的算法"></a>判断对象是否存活的算法</h2><ul><li>垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧）</li></ul><h3 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h3><ul><li><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p></li><li><p>一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。</p></li></ul><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h3><ul><li>通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gcroots.JPEG" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure><ul><li>上图中每个对象都存在引用链与GCRoots相连，表明对象还在，不能回收。有图中三个对象虽然互相引用，但是没有链接与GCRoots相连，则可判断它们是可回收的对象。<ul><li>什么对象可以为<code>GCRoots</code>，<ul><li>虚拟机栈中本地变量表引用的对象，局部变量</li><li>方法区中的类静态变量引用的对象及常量引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li></ul></li></ul><ul><li>彻底死亡条件：<ul><li>条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。</li><li>条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。</li></ul></li><li><p>引用</p><ul><li><p>强引用<code>Object o = new Object()</code></p></li><li><p>软引用<code>SoftReference</code> 定义了软引用对象之后，GC可达的算法就切断与此对象的连接，那么下次垃圾回收的时候就会优化回收此对象</p></li><li><p>弱引用</p></li><li><p>虚引用</p></li></ul></li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc1.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>该算法是最基础的收集算法，算法分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象</p></li><li><p>之所以说它是最基础的算法是因为后续的算法都是基于这种思路并对其不足进行改进而得到的</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>效率不足</li><li>会产生大量不连续的内存碎片，碎片过多的话再分配一个较大对象时就无容身之地从而不得不提前触发另一次垃圾收集</li></ol><h3 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2. 复制算法"></a>2. 复制算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc2.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li><p>为了解决效率问题，此算法把内存划分为相等大小的两个区域，每一只使用其中一个，回收过程中将存活的对象全部复制到另一个区域中，清空原区域。在年轻代中eden区和两个survivor区就是使用了此种算法。这种算法只复制存活的对象，成本较低，而且不会出现内存碎片问题</p></li><li><p>现在的商业虚拟机都采用这种算法来回收新生代</p></li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>费内存，需要2倍的内存空间</li></ol><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc3.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>该算法标记阶段和标记-清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。效率比“标记-清理”算法低，但不会产生内存碎片。</li></ul><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/server/java/JVM/gc4.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</li></ul><h2 id="参考转载"><a href="#参考转载" class="headerlink" title="参考转载"></a>参考转载</h2><ul><li>周志明版  《深入理解Java虚拟机》</li><li><a href="https://www.cnblogs.com/aspirant/p/8662690.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8662690.html</a></li><li><a href="http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法
      
    
    </summary>
    
      <category term="服务器" scheme="http://www.songshuiyang.site/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="java" scheme="http://www.songshuiyang.site/tags/java/"/>
    
      <category term="jvm" scheme="http://www.songshuiyang.site/tags/jvm/"/>
    
  </entry>
  
</feed>
