[{"title":"SpringCloud(八)Zuul工作原理源码分析之执行流程","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud()Zuul工作原理源码分析之执行流程/","content":"### 前言\n\n* 上一章节已经介绍了使用`@EnableZuulServer`注解会开启 `ZuulProxyAutoConfiguration`自动注册功能，这个类会自动注册`Zuul`服务启动所需要的`Bean`，因为我们这里是网关服务，所以是需要接受外部应用的`Http`请求的\n\n* 回顾`ZuulProxyAutoConfiguration` 的父类`ZuulServerAutoConfiguration`，从下面可以看到是注册了`ZuulController`，`ZuulHandlerMapping`，`ZuulServlet`三个`Bean`，所以我们可以猜测入口应该是`Spring MVC DispatcherServlet`\n\n```java\n/**\n * @author Spencer Gibb\n * @author Dave Syer\n * @author Biju Kunjummen\n */\n@Configuration // 声明是配置类\n@EnableConfigurationProperties({ ZuulProperties.class }) // 激活 zuul配置\n@ConditionalOnClass(ZuulServlet.class) // 条件1 存在ZuulServlet.class\n@ConditionalOnBean(ZuulServerMarkerConfiguration.Marker.class) // 条件2 存在ZuulServerMarkerConfiguration.Marker.class bean, 即应用使用@EnableZuulServer注解\n// Make sure to get the ServerProperties from the same place as a normal web app would\n@Import(ServerPropertiesAutoConfiguration.class) // 配置ServerProperties实例\npublic class ZuulServerAutoConfiguration {\n\n\t@Autowired\n\tprotected ZuulProperties zuulProperties;\n\n\t@Autowired\n\tprotected ServerProperties server;\n\n\t@Autowired(required = false)\n\tprivate ErrorController errorController;\n\n\t@Bean\n\tpublic HasFeatures zuulFeature() {\n\t\treturn HasFeatures.namedFeature(\"Zuul (Simple)\", ZuulServerAutoConfiguration.class);\n\t}\n\n\t@Bean\n\t@Primary\n\tpublic CompositeRouteLocator primaryRouteLocator(\n\t\t\tCollection<RouteLocator> routeLocators) {\n\t\treturn new CompositeRouteLocator(routeLocators);\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean(SimpleRouteLocator.class)\n\tpublic SimpleRouteLocator simpleRouteLocator() {\n\t\treturn new SimpleRouteLocator(this.server.getServletPrefix(),\n\t\t\t\tthis.zuulProperties);\n\t}\n\n\t/**\n\t * zuulController, 包装了一个ZuulServlet类型的servlet, 实现对ZuulServlet类型的servlet的初始化.\n\t *\n\t * @return\n\t */\n\t@Bean\n\tpublic ZuulController zuulController() {\n\t\treturn new ZuulController();\n\t}\n\n\t@Bean\n\tpublic ZuulHandlerMapping zuulHandlerMapping(RouteLocator routes) {\n\t\tZuulHandlerMapping mapping = new ZuulHandlerMapping(routes, zuulController());\n\t\tmapping.setErrorController(this.errorController);\n\t\treturn mapping;\n\t}\n\n\t@Bean\n\tpublic ApplicationListener<ApplicationEvent> zuulRefreshRoutesListener() {\n\t\treturn new ZuulRefreshListener();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean(name = \"zuulServlet\")\n\tpublic ServletRegistrationBean zuulServlet() {\n\t\tServletRegistrationBean servlet = new ServletRegistrationBean(new ZuulServlet(),\n\t\t\t\tthis.zuulProperties.getServletPattern());\n\t\t// The whole point of exposing this servlet is to provide a route that doesn't\n\t\t// buffer requests.\n\t\tservlet.addInitParameter(\"buffer-requests\", \"false\");\n\t\treturn servlet;\n\t}\n\n    ... \n```\n\n### 解析\n\n* 查看源码是怎样执行调用的可以在代码里打好断点，观察其执行链，第六章节已经介绍了`Zuul`的一个简单例子，我们可以在自己定义的`Filter`的`run()`方法里打好断点，只要没配置错误，这里是一定会执行的\n\n\n```java\n@Slf4j\n@Component\npublic class AuthenticationFilter extends ZuulFilter {\n\n    private Pattern p = Pattern.compile(\"/*/pub/*\");\n\n    @Override\n    public Object run() {\n        ResponseMO resMO = new ResponseMO();\n        RequestContext ctx = RequestContext.getCurrentContext();\n        HttpServletRequest request = ctx.getRequest();\n\n        String relativeURL = extractRelativePath(request);\n        if (p.matcher(relativeURL).find()) {\n            return null;\n        }\n        log.info(\">> 鉴权开始[{}]\",relativeURL);\n        ResponseMO resModel = null;\n        if (relativeURL.startsWith(ApplicationConstants.APPLICATION_USER)) {\n            // TODO\n            resModel = new ResponseMO();\n        } else if (relativeURL.startsWith(ApplicationConstants.APPLICATION_ZUUL)) {\n            // TODO\n            resModel = new ResponseMO();\n        } else {\n            // 其他服务不对其进行路由\n            authorizationFailed(relativeURL, ctx, resMO);\n            return null;\n        }\n        if (resModel.getCode() != ResponseMO.RESPONSE_CODE_SUCCESS) {\n            // 鉴权失败不对其进行路由\n            authorizationFailed(relativeURL, ctx, resMO);\n            return null;\n        }\n        // 从jwt解析后的userId\n        ctx.addZuulRequestHeader(\"userId\", \"reUserId\");\n        log.info(\"<< 鉴权通过[{}]] \", relativeURL);\n        return null;\n    }\n\n    /**\n     * 返回一个boolean值来判断该过滤器是否要执行，true表示执行，false表示不执行\n     * @return\n     */\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    /**\n     * gives the order in which this filter will be executed, relative to other\n     * filters\n     * @return\n     */\n    @Override\n    public int filterOrder() {\n        // TODO Auto-generated method stub\n        return 0;\n    }\n\n    @Override\n    public String filterType() {\n        return \"pre\";\n    }\n\n    /**\n     * 鉴权失败\n     * @param relativeURL\n     * @param ctx\n     * @param resMO\n     */\n    private void authorizationFailed (String relativeURL, RequestContext ctx, ResponseMO resMO) {\n        ctx.setSendZuulResponse(false);\n        ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());\n        resMO.setAnonymous();\n        String resBody = convertToString(resMO);\n        ctx.setResponseBody(resBody);\n        log.info(\"<< 鉴权失败[{}]\",relativeURL);\n    }\n\n    private String convertToString(ResponseMO resMO) {\n        String result = \"\";\n        ObjectMapper mapper = new ObjectMapper();\n        try {\n            result = mapper.writeValueAsString(resMO);\n        } catch (JsonProcessingException e) {\n            log.error(e.getMessage());\n        }\n        return result;\n    }\n\n    /**\n     * 获取相对访问路径\n     * @param request\n     * @return\n     */\n    private String extractRelativePath(HttpServletRequest request) {\n        String requestURI = request.getRequestURI();\n        return requestURI;\n    }\n}\n```\n\n* 下图是其方法调用链路图，可以看到入口是`Spring MVC`的`DispatcherServlet`，然后就是`doDispatch`到了`ZuulController`上，`ZuulController`又转发到了`ZuulServlet`的`service`方法\n  \n![](/images/server/spring/spring-cloud/ZuulController.jpg)\n\n* 根据上图可以梳理出大致的执行流程\n    * 1、内置`tomcat`容器接受`Http`请求\n    * 2、进入`DispatcherServlet`进行`doDispatch`请求转发\n    * 3、转发到`ZuulController`上，执行其`handleRequest()`方法\n    * 4、然后转发到`ZuulServlet`上的`service()`方法上，这个是个`HttpServlet`，这里会执行一系列的拦截器\n\n#### 1、ZuulController\n\n![](/images/server/spring/spring-cloud/ZuulController.png)\n\n* 我们平常开发使用 `Spring MVC`一般都是通过`@Controller`注解的形式来定义其执行方法，`Spring`也提供通过实现接口的形式来定义其执行方法，下面的`ZuulController`就是这个例子，可以看到这个类十分简单，就只有主体方法`handleRequest()`，此方法是定义在`Controller`接口上\n\n* 那是`DispatcherServlet`是怎样找到`ZuulController`这个执行类的呢，可以看到`ZuulServerAutoConfiguration`是注册了`ZuulController`及`ZuulHandlerMapping`这两个`bean`，`ZuulHandlerMapping`和我们平常使用的`RequestMappingHandlerMapping`都是继承`HandlerMapping`接口，这个接口是定义请求与具体执行者的映射关系，所以`DispatcherServlet`就能发现`ZuulController`这个执行类\n\n```java\n/**\n * zuulController, 包装了一个ZuulServlet类型的servlet, 实现对ZuulServlet类型的servlet的初始化.\n *\n * @return\n */\n@Bean\npublic ZuulController zuulController() {\n    return new ZuulController();\n}\n\n@Bean\npublic ZuulHandlerMapping zuulHandlerMapping(RouteLocator routes) {\n    ZuulHandlerMapping mapping = new ZuulHandlerMapping(routes, zuulController());\n    mapping.setErrorController(this.errorController);\n    return mapping;\n}\n```\n\n> org.springframework.web.servlet.mvc.Controller#handleRequest\n\n```java\npublic interface Controller {\n\n\t/**\n\t * Process the request and return a ModelAndView object which the DispatcherServlet\n\t * will render. A {@code null} return value is not an error: it indicates that\n\t * this object completed request processing itself and that there is therefore no\n\t * ModelAndView to render.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @return a ModelAndView to render, or {@code null} if handled directly\n\t * @throws Exception in case of errors\n\t */\n\tModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception;\n\n}\n```\n\n> org.springframework.cloud.netflix.zuul.web.ZuulController#handleRequest\n\n```java\n/**\n * @author Spencer Gibb\n */\npublic class ZuulController extends ServletWrappingController {\n\n\tpublic ZuulController() {\n\t\tsetServletClass(ZuulServlet.class);\n\t\tsetServletName(\"zuul\");\n\t\tsetSupportedMethods((String[]) null); // Allow all\n\t}\n\n\t@Override\n\tpublic ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\ttry {\n\t\t\t// We don't care about the other features of the base class, just want to\n\t\t\t// handle the request\n\t\t\treturn super.handleRequestInternal(request, response);\n\t\t}\n\t\tfinally {\n\t\t\t// @see com.netflix.zuul.context.ContextLifecycleFilter.doFilter\n\t\t\tRequestContext.getCurrentContext().unset();\n\t\t}\n\t}\n\n}\n```\n\n* 查看`ZuulController`的构造函数里面`setServletClass(ZuulServlet.class)`可以看到是设置了父类`ServletWrappingController`的`servletClass`为`ZuulServlet.class`\n    * 看看父类`ServletWrappingController`\n        * 代码如下，可以看到成员变量是记录了`Servlet`的`name`及`Class`对象，`Servlet servletInstance`是在`afterPropertiesSet()`赋值的，这个函数是`Spring`的钩子函数\n        ```java\n        public class ServletWrappingController extends AbstractController\n                implements BeanNameAware, InitializingBean, DisposableBean {\n        \n            private Class<? extends Servlet> servletClass;\n        \n            private String servletName;\n        \n            private Properties initParameters = new Properties();\n        \n            private String beanName;\n        \n            private Servlet servletInstance;\n        \n        \n            public ServletWrappingController() {\n                super(false);\n            }\n        \n        \n            /**\n             * Set the class of the servlet to wrap.\n             * Needs to implement {@code javax.servlet.Servlet}.\n             * @see javax.servlet.Servlet\n             */\n            public void setServletClass(Class<? extends Servlet> servletClass) {\n                this.servletClass = servletClass;\n            }\n        \n            /**\n             * Set the name of the servlet to wrap.\n             * Default is the bean name of this controller.\n             */\n            public void setServletName(String servletName) {\n                this.servletName = servletName;\n            }\n        \n            /**\n             * Specify init parameters for the servlet to wrap,\n             * as name-value pairs.\n             */\n            public void setInitParameters(Properties initParameters) {\n                this.initParameters = initParameters;\n            }\n        \n            @Override\n            public void setBeanName(String name) {\n                this.beanName = name;\n            }\n        \n        \n            /**\n             * Initialize the wrapped Servlet instance.\n             * @see javax.servlet.Servlet#init(javax.servlet.ServletConfig)\n             */\n            @Override\n            public void afterPropertiesSet() throws Exception {\n                if (this.servletClass == null) {\n                    throw new IllegalArgumentException(\"'servletClass' is required\");\n                }\n                if (this.servletName == null) {\n                    this.servletName = this.beanName;\n                }\n                this.servletInstance = this.servletClass.newInstance();\n                this.servletInstance.init(new DelegatingServletConfig());\n            }\n        \n        \n            /**\n             * Invoke the wrapped Servlet instance.\n             * @see javax.servlet.Servlet#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n             */\n            @Override\n            protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n                    throws Exception {\n        \n                this.servletInstance.service(request, response);\n                return null;\n            }\n        ...\n        ```\n    * 进入`ZuulController`的`handleRequest()`方法，可以看到就一个入口`super.handleRequestInternal(request, response);`，进入此方法，可以看到实际上就是执行了`ZuulServlet`的`service()`方法，`Spring`将一个`Servlet`包裹在一个`Controller`里面了\n    ```java\n\t/**\n     * 执行被包裹的Servlet\n     * \n\t * Invoke the wrapped Servlet instance.\n\t * @see javax.servlet.Servlet#service(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n\t */\n\t@Override\n\tprotected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tthis.servletInstance.service(request, response);\n\t\treturn null;\n\t}\n    ```\n#### 2、ZuulServlet\n\n* 先看代码，可以看到`ZuulServlet`就是个`Servlet`，所以我们关心他的`service()`方法，注意这个类是属于`com.netflix.zuul`包下的，不是`Spring`的类，\n\n```java\n/**\n * Core Zuul servlet which intializes and orchestrates zuulFilter execution\n *\n * @author Mikey Cohen\n *         Date: 12/23/11\n *         Time: 10:44 AM\n */\npublic class ZuulServlet extends HttpServlet {\n\n    private static final long serialVersionUID = -3374242278843351500L;\n    private ZuulRunner zuulRunner;\n\n\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n\n        String bufferReqsStr = config.getInitParameter(\"buffer-requests\");\n        boolean bufferReqs = bufferReqsStr != null && bufferReqsStr.equals(\"true\") ? true : false;\n\n        zuulRunner = new ZuulRunner(bufferReqs);\n    }\n\n    @Override\n    public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException {\n        try {\n            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);\n\n            // Marks this request as having passed through the \"Zuul engine\", as opposed to servlets\n            // explicitly bound in web.xml, for which requests will not have the same data attached\n            RequestContext context = RequestContext.getCurrentContext();\n            context.setZuulEngineRan();\n\n            try {\n                preRoute();\n            } catch (ZuulException e) {\n                error(e);\n                postRoute();\n                return;\n            }\n            try {\n                route();\n            } catch (ZuulException e) {\n                error(e);\n                postRoute();\n                return;\n            }\n            try {\n                postRoute();\n            } catch (ZuulException e) {\n                error(e);\n                return;\n            }\n\n        } catch (Throwable e) {\n            error(new ZuulException(e, 500, \"UNHANDLED_EXCEPTION_\" + e.getClass().getName()));\n        } finally {\n            RequestContext.getCurrentContext().unset();\n        }\n    }\n\n    /**\n     * executes \"post\" ZuulFilters\n     *\n     * @throws ZuulException\n     */\n    void postRoute() throws ZuulException {\n        zuulRunner.postRoute();\n    }\n\n    /**\n     * executes \"route\" filters\n     *\n     * @throws ZuulException\n     */\n    void route() throws ZuulException {\n        zuulRunner.route();\n    }\n\n    /**\n     * executes \"pre\" filters\n     *\n     * @throws ZuulException\n     */\n    void preRoute() throws ZuulException {\n        zuulRunner.preRoute();\n    }\n\n    /**\n     * initializes request\n     *\n     * @param servletRequest\n     * @param servletResponse\n     */\n    void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n        zuulRunner.init(servletRequest, servletResponse);\n    }\n\n    /**\n     * sets error context info and executes \"error\" filters\n     *\n     * @param e\n     */\n    void error(ZuulException e) {\n        RequestContext.getCurrentContext().setThrowable(e);\n        zuulRunner.error();\n    }\n\n    @RunWith(MockitoJUnitRunner.class)\n    public static class UnitTest {\n\n        @Mock\n        HttpServletRequest servletRequest;\n        @Mock\n        HttpServletResponseWrapper servletResponse;\n        @Mock\n        FilterProcessor processor;\n        @Mock\n        PrintWriter writer;\n\n        @Before\n        public void before() {\n            MockitoAnnotations.initMocks(this);\n        }\n\n        @Test\n        public void testProcessZuulFilter() {\n\n            ZuulServlet zuulServlet = new ZuulServlet();\n            zuulServlet = spy(zuulServlet);\n            RequestContext context = spy(RequestContext.getCurrentContext());\n\n\n            try {\n                FilterProcessor.setProcessor(processor);\n                RequestContext.testSetCurrentContext(context);\n                when(servletResponse.getWriter()).thenReturn(writer);\n\n                zuulServlet.init(servletRequest, servletResponse);\n                verify(zuulServlet, times(1)).init(servletRequest, servletResponse);\n                assertTrue(RequestContext.getCurrentContext().getRequest() instanceof HttpServletRequestWrapper);\n                assertTrue(RequestContext.getCurrentContext().getResponse() instanceof HttpServletResponseWrapper);\n\n                zuulServlet.preRoute();\n                verify(processor, times(1)).preRoute();\n\n                zuulServlet.postRoute();\n                verify(processor, times(1)).postRoute();\n//                verify(context, times(1)).unset();\n\n                zuulServlet.route();\n                verify(processor, times(1)).route();\n                RequestContext.testSetCurrentContext(null);\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n\n        }\n    }\n}\n```\n\n* 关注`service()`方法，可以说这里是`zuul`的核心方法，看到这里的代码再来理解之前章节截的图就十分形象了，可以看到这里主要逻辑就是执行`filter`了，可以发现`preRoute()`及`route()`都是跳转到`ZuulRunner zuulRunner`里对应的方法执行\n\n```java\npublic void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n    try {\n        this.init((HttpServletRequest)servletRequest, (HttpServletResponse)servletResponse);\n        RequestContext context = RequestContext.getCurrentContext();\n        context.setZuulEngineRan();\n\n        try {\n            // 执行 pre filter\n            this.preRoute();\n        } catch (ZuulException var12) {\n            // 发生异常 执行error 及 post filter\n            this.error(var12);\n            this.postRoute();\n            return;\n        }\n\n        try {\n            // 执行 routing filter\n            this.route();\n        } catch (ZuulException var13) {\n            // 发生异常 执行error 及 post filter\n            this.error(var13);\n            this.postRoute();\n            return;\n        }\n\n        try {\n            // 执行 post filter\n            this.postRoute();\n        } catch (ZuulException var11) {\n            this.error(var11);\n        }\n    } catch (Throwable var14) {\n        this.error(new ZuulException(var14, 500, \"UNHANDLED_EXCEPTION_\" + var14.getClass().getName()));\n    } finally {\n        RequestContext.getCurrentContext().unset();\n    }\n}\n```\n\n![](/images/server/spring/spring-cloud/zuul.png)\n\n* 我们现在来调试`service()`方法\n    * 先来看第一行`this.init((HttpServletRequest)servletRequest, (HttpServletResponse)servletResponse);`\n        * 代码\n        ```java\n        void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n            zuulRunner.init(servletRequest, servletResponse);\n        }\n        ```\n        * 跳转到`zuulRunner.init（）`方法，可以看到下面使用了构造了一个`RequestContext`，并设置`HttpServlet request and HttpResponse`，不出所外这个类就是`ThreadLocal`来实现的\n        ```java\n        /**\n         * sets HttpServlet request and HttpResponse\n         *\n         * @param servletRequest\n         * @param servletResponse\n         */\n        public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n    \n            RequestContext ctx = RequestContext.getCurrentContext();\n            if (bufferRequests) {\n                ctx.setRequest(new HttpServletRequestWrapper(servletRequest));\n            } else {\n                ctx.setRequest(servletRequest);\n            }\n    \n            ctx.setResponse(new HttpServletResponseWrapper(servletResponse));\n        }\n        ```\n        * 查看`RequestContext`类，查看本地变量可以发现`ThreadLocal<? extends RequestContext> threadLocal`，而且这个类继承了`ConcurrentHashMap`所以这个类应该是存放每次请求的各种参数的，使用`ThreadLocal`变量来达到线程隔离的效果\n        ```java\n        /**\n         * The Request Context holds request, response,  state information and data for ZuulFilters to access and share.\n         * The RequestContext lives for the duration of the request and is ThreadLocal.\n         * extensions of RequestContext can be substituted by setting the contextClass.\n         * Most methods here are convenience wrapper methods; the RequestContext is an extension of a ConcurrentHashMap\n         *\n         * @author Mikey Cohen\n         *         Date: 10/13/11\n         *         Time: 10:21 AM\n         */\n        public class RequestContext extends ConcurrentHashMap<String, Object> {\n        \n            private static final Logger LOG = LoggerFactory.getLogger(RequestContext.class);\n        \n            protected static Class<? extends RequestContext> contextClass = RequestContext.class;\n        \n            private static RequestContext testContext = null;\n        \n            protected static final ThreadLocal<? extends RequestContext> threadLocal = new ThreadLocal<RequestContext>() {\n                @Override\n                protected RequestContext initialValue() {\n                    try {\n                        return contextClass.newInstance();\n                    } catch (Throwable e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            };\n        \n        \n            public RequestContext() {\n                super();\n            }\n        ```\n    * 看完第一行我们知道构造了一个`RequestContext`，再来回去看第二三行代码\n        * 可以看到重新获取了一下`RequestContext`,`context.setZuulEngineRan();`用于标记这个请求是`Zuul engine`\n        ```java\n        // Marks this request as having passed through the \"Zuul engine\", as opposed to servlets\n        // explicitly bound in web.xml, for which requests will not have the same data attached\n        RequestContext context = RequestContext.getCurrentContext();\n        context.setZuulEngineRan();\n        ```\n    * 下面就是执行各种`Route`了\n##### 2.1、preRoute()\n\n* 先来看`preRoute()`，这个`filters`是最先执行的\n\n```java\nvoid preRoute() throws ZuulException {\n    zuulRunner.preRoute();\n}\n```\n\n* 进入`com.netflix.zuul.ZuulRunner#preRoute()`，可以看到又包装了一个`FilterProcessor`\n\n```java\npublic void preRoute() throws ZuulException {\n    FilterProcessor.getInstance().preRoute();\n}\n```\n\n* 查看`FilterProcessor`类，这个类是执行`filters`的核心类，可以看到这个类的使用是用了单例模式\n    * 代码\n    ```java\n    /**\n     * This the the core class to execute filters.\n     *\n     * @author Mikey Cohen\n     *         Date: 10/24/11\n     *         Time: 12:47 PM\n     */\n    public class FilterProcessor {\n    \n        static FilterProcessor INSTANCE = new FilterProcessor();\n        protected static final Logger logger = LoggerFactory.getLogger(FilterProcessor.class);\n    \n        private FilterUsageNotifier usageNotifier;\n    \n    \n        public FilterProcessor() {\n            usageNotifier = new BasicFilterUsageNotifier();\n        }\n    \n        /**\n         * @return the singleton FilterProcessor\n         */\n        public static FilterProcessor getInstance() {\n            return INSTANCE;\n        }\n    \n        /**\n         * sets a singleton processor in case of a need to override default behavior\n         *\n         * @param processor\n         */\n        public static void setProcessor(FilterProcessor processor) {\n            INSTANCE = processor;\n        }\n    ```\n* 进入`com.netflix.zuul.FilterProcessor#preRoute()`，看注释可以看到本方法是在请求路由之前执行所有的`\"pre\" filters`，可以看到得到`List<ZuulFilter> list`然后`for`循环执行\n\n```java\n/**\n * runs all \"pre\" filters. These filters are run before routing to the orgin.\n *\n * @throws ZuulException\n */\npublic void preRoute() throws ZuulException {\n    try {\n        runFilters(\"pre\");\n    } catch (ZuulException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_IN_PRE_FILTER_\" + e.getClass().getName());\n    }\n}\n/**\n * runs all filters of the filterType sType/ Use this method within filters to run custom filters by type\n *\n * @param sType the filterType.\n * @return\n * @throws Throwable throws up an arbitrary exception\n */\npublic Object runFilters(String sType) throws Throwable {\n    if (RequestContext.getCurrentContext().debugRouting()) {\n        Debug.addRoutingDebug(\"Invoking {\" + sType + \"} type filters\");\n    }\n    boolean bResult = false;\n    List<ZuulFilter> list = FilterLoader.getInstance().getFiltersByType(sType);\n    if (list != null) {\n        for (int i = 0; i < list.size(); i++) {\n            ZuulFilter zuulFilter = list.get(i);\n            // 执行ZuulFilter\n            Object result = processZuulFilter(zuulFilter);\n            if (result != null && result instanceof Boolean) {\n                bResult |= ((Boolean) result);\n            }\n        }\n    }\n    return bResult;\n}\n```\n\n> List<ZuulFilter> list 结果\n\n![](/images/server/spring/spring-cloud/pre-filter.jpg)\n\n* 上面代码可以看到已经筛选出上图这些`\"pre\" filters`\n    * 这些`\"pre\" filters` 也有我们自己定义的`AuthenticationFilter`\n    * 可以看到`ServletDetectionFilter`是最先执行的`filter`，因为`filterOrder()`是最小，这个`filter`用于标识请求是否是`DispatcherServletRequest`\n    ```java\n    public class ServletDetectionFilter extends ZuulFilter {\n    \n        public ServletDetectionFilter() {\n        }\n    \n        @Override\n        public String filterType() {\n            return PRE_TYPE;\n        }\n    \n        /**\n         * Must run before other filters that rely on the difference between \n         * DispatcherServlet and ZuulServlet.\n         */\n        @Override\n        public int filterOrder() {\n            return SERVLET_DETECTION_FILTER_ORDER;\n        }\n    \n        @Override\n        public boolean shouldFilter() {\n            return true; \n        }\n    \n        @Override\n        public Object run() {\n            RequestContext ctx = RequestContext.getCurrentContext();\n            HttpServletRequest request = ctx.getRequest();\n            if (!(request instanceof HttpServletRequestWrapper) \n                    && isDispatcherServletRequest(request)) {\n                ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, true);\n            } else {\n                ctx.set(IS_DISPATCHER_SERVLET_REQUEST_KEY, false);\n            }\n    \n            return null;\n        }\n        \n        private boolean isDispatcherServletRequest(HttpServletRequest request) {\n            return request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null;\n        }\t \t\n    \n    }\n    ```\n\n\n* 进入`Object result = processZuulFilter(zuulFilter)` 查看`ZuulFilter`执行逻辑\n    * `com.netflix.zuul.FilterProcessor#processZuulFilter`\n        ```java\n        /**\n         * Processes an individual ZuulFilter. This method adds Debug information. Any uncaught Thowables are caught by this method and converted to a ZuulException with a 500 status code.\n         *\n         * @param filter\n         * @return the return value for that filter\n         * @throws ZuulException\n         */\n        public Object processZuulFilter(ZuulFilter filter) throws ZuulException {\n    \n            RequestContext ctx = RequestContext.getCurrentContext();\n            boolean bDebug = ctx.debugRouting();\n            final String metricPrefix = \"zuul.filter-\";\n            long execTime = 0;\n            String filterName = \"\";\n            try {\n                long ltime = System.currentTimeMillis();\n                filterName = filter.getClass().getSimpleName();\n                \n                RequestContext copy = null;\n                Object o = null;\n                Throwable t = null;\n    \n                if (bDebug) {\n                    Debug.addRoutingDebug(\"Filter \" + filter.filterType() + \" \" + filter.filterOrder() + \" \" + filterName);\n                    copy = ctx.copy();\n                }\n                // 执行方法\n                ZuulFilterResult result = filter.runFilter();\n                ExecutionStatus s = result.getStatus();\n                execTime = System.currentTimeMillis() - ltime;\n    \n                switch (s) {\n                    case FAILED:\n                        t = result.getException();\n                        ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);\n                        break;\n                    case SUCCESS:\n                        o = result.getResult();\n                        ctx.addFilterExecutionSummary(filterName, ExecutionStatus.SUCCESS.name(), execTime);\n                        if (bDebug) {\n                            Debug.addRoutingDebug(\"Filter {\" + filterName + \" TYPE:\" + filter.filterType() + \" ORDER:\" + filter.filterOrder() + \"} Execution time = \" + execTime + \"ms\");\n                            Debug.compareContextState(filterName, copy);\n                        }\n                        break;\n                    default:\n                        break;\n                }\n                \n                if (t != null) throw t;\n    \n                usageNotifier.notify(filter, s);\n                return o;\n    \n            } catch (Throwable e) {\n                if (bDebug) {\n                    Debug.addRoutingDebug(\"Running Filter failed \" + filterName + \" type:\" + filter.filterType() + \" order:\" + filter.filterOrder() + \" \" + e.getMessage());\n                }\n                usageNotifier.notify(filter, ExecutionStatus.FAILED);\n                if (e instanceof ZuulException) {\n                    throw (ZuulException) e;\n                } else {\n                    ZuulException ex = new ZuulException(e, \"Filter threw Exception\", 500, filter.filterType() + \":\" + filterName);\n                    ctx.addFilterExecutionSummary(filterName, ExecutionStatus.FAILED.name(), execTime);\n                    throw ex;\n                }\n            }\n        }\n        ```\n    * 进入`ZuulFilterResult result = filter.runFilter();`可以看到是直接调用了`run()`方法\n    ```java\n    public ZuulFilterResult runFilter() {\n        ZuulFilterResult zr = new ZuulFilterResult();\n        if (!isFilterDisabled()) {\n            if (shouldFilter()) {\n                Tracer t = TracerFactory.instance().startMicroTracer(\"ZUUL::\" + this.getClass().getSimpleName());\n                try {\n                    // 执行run方法\n                    Object res = run();\n                    zr = new ZuulFilterResult(res, ExecutionStatus.SUCCESS);\n                } catch (Throwable e) {\n                    t.setName(\"ZUUL::\" + this.getClass().getSimpleName() + \" failed\");\n                    zr = new ZuulFilterResult(ExecutionStatus.FAILED);\n                    zr.setException(e);\n                } finally {\n                    t.stopAndLog();\n                }\n            } else {\n                zr = new ZuulFilterResult(ExecutionStatus.SKIPPED);\n            }\n        }\n        return zr;\n    }\n    ```\n##### 2.2、route()\n\n* `preRoute()`执行完成之后就是执行`route()`了，我们进入`com.netflix.zuul.ZuulRunner#route()`，可以看到这里和`preRoute()`方法执行一样也是执行了`runFilters()`方法，只不过是用参数进行区分\n\n```java\n/**\n * executes \"route\" filterType  ZuulFilters\n *\n * @throws ZuulException\n */\npublic void route() throws ZuulException {\n    FilterProcessor.getInstance().route();\n}\n\n// com.netflix.zuul.FilterProcessor#route \npublic void route() throws ZuulException {\n    try {\n        runFilters(\"route\");\n    } catch (ZuulException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_IN_ROUTE_FILTER_\" + e.getClass().getName());\n    }\n}\n```\n\n> List<ZuulFilter> list\n\n![](/images/server/spring/spring-cloud/route.jpg)\n\n\n* 查看上图可以发现默认是有三个`routing filter`，我们这里关注的是`RibbonRoutingFilter`，这里是进行负载均衡路由转发的操作\n    * 进入`processZuulFilter(ZuulFilter filter)`方法，查看`RequestContext`变量已经发现有一些关键信息了，这些信息是`pre filter`添加上去的，为路由转发为准备\n    ![](/images/server/spring/spring-cloud/routing-filter.jpg)\n    * 进入`RibbonRoutingFilter`的`run()`方法，可以看到是封装了一个`Ribbon`请求，执行请求，设置请求结果\n    ```java\n\t@Override\n\tpublic Object run() {\n\t\tRequestContext context = RequestContext.getCurrentContext();\n\t\tthis.helper.addIgnoredHeaders();\n\t\ttry {\n\t\t\t// 根据RequestContext封装为一个Ribbon请求命名对象，里面有请求链接及请求参数\n\t\t\tRibbonCommandContext commandContext = buildCommandContext(context);\n\t\t\t// 执行请求\n\t\t\tClientHttpResponse response = forward(commandContext);\n\t\t\t// 设置请求结果\n\t\t\tsetResponse(response);\n\t\t\treturn response;\n\t\t}\n\t\tcatch (ZuulException ex) {\n\t\t\tthrow new ZuulRuntimeException(ex);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new ZuulRuntimeException(ex);\n\t\t}\n\t}\n    ```\n    * 进入`forward(commandContext)`方法，`command.execute();`就是通过服务名来找出具体可以接受服务的`ip`及`port`，然后请求执行，这里涉及到从注册中心获取服务`ip`及`port`，负载均衡处理，断路器处理\n    * 最终结果会放在`ClientHttpResponse`中\n    ```java\n\tprotected ClientHttpResponse forward(RibbonCommandContext context) throws Exception {\n\t\tMap<String, Object> info = this.helper.debug(context.getMethod(),\n\t\t\t\tcontext.getUri(), context.getHeaders(), context.getParams(),\n\t\t\t\tcontext.getRequestEntity());\n        // 创建请求\n\t\tRibbonCommand command = this.ribbonCommandFactory.create(context);\n\t\ttry {\n\t\t\t// 执行请求\n\t\t\tClientHttpResponse response = command.execute();\n\t\t\tthis.helper.appendDebug(info, response.getRawStatusCode(), response.getHeaders());\n\t\t\treturn response;\n\t\t}\n\t\tcatch (HystrixRuntimeException ex) {\n\t\t\treturn handleException(info, ex);\n\t\t}\n\t}\n    ```\n    * 进入`this.ribbonCommandFactory.create(context);`，下图是获取了`RibbonLoadBalancingHttpClient`，查看参数可以看到一些关键信息，比如链接超时时间\n    ![](/images/server/spring/spring-cloud/ribbonCommand.jpg)\n\n##### 2.3、postRoute()\n\n* 进入`com.netflix.zuul.ZuulRunner#postRoute()` 与上面同理\n\n```java\npublic void postRoute() throws ZuulException {\n    FilterProcessor.getInstance().postRoute();\n}\n\n// com.netflix.zuul.FilterProcessor#postRoute \npublic void postRoute() throws ZuulException {\n    try {\n        runFilters(\"post\");\n    } catch (ZuulException e) {\n        throw e;\n    } catch (Throwable e) {\n        throw new ZuulException(e, 500, \"UNCAUGHT_EXCEPTION_IN_POST_FILTER_\" + e.getClass().getName());\n    }\n}\n```\n\n##### 2.4、error()\n\n```java\npublic void error() {\n    try {\n        runFilters(\"error\");\n    } catch (Throwable e) {\n        logger.error(e.getMessage(), e);\n    }\n}\n\n// com.netflix.zuul.FilterProcessor#error \npublic void error() {\n    try {\n        runFilters(\"error\");\n    } catch (Throwable e) {\n        logger.error(e.getMessage(), e);\n    }\n}\n```\n\n### 其他\n\n### 总结\n* `ZuulController`是`SpringCloud Zuul`的统一入口，因为要和`Spring`联系起来，所以这里遵循的`Spring MVC DispatcherServlet`的模式，这个`ZuulController`将`com.netflix.zuul`包下的`ZuulServlet`整合起来，实际请求是跳转到`ZuulServlet`来处理的\n* `Zuul`组件的核心是一系列的过滤器`filters`，通过一系列的`filters`流式处理，按照阶段分为`pre`、`routing` 、`post`、`error`四种类型的`filter`，在流式处理过程中使用`RequestContext`保存整个请求需要的参数及结果\n\n### 参考\n","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(七)Zuul工作原理源码分析之初始化","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud()Zuul工作原理源码分析之初始化/","content":"### 前言\n* 由上一章节可以知道要创建一个`zuul`应用，只需添加`spring-cloud-starter-zuul` `maven`依赖及启动类上添加`@EnableZuulProxy`就可创建一个`zuul`应用，那么要知道`Zuul`工作原理就需从这个两个地方作为入口进行研究\n\n* zuul版本: `1.4.3.RELEASE`\n\n### 解析\n\n#### Zuul 初始化\n\n##### spring-cloud-starter-zuul starter\n\n* 我们先查看`spring-cloud-starter-zuul starter`包下有什么，这里的重点就是`pom.xml`文件，`ZuulDeprecationWarningAutoConfiguration.java`此类已经被`@Deprecated`\n\n![](/images/server/spring/spring-cloud/zuul-starter.jpg)\n\n* 打开`org.springframework.cloud/spring-cloud-starter-zuul/pom.xml` ，可以看到是依赖了`spring-cloud-starter-netflix-zuul`\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.cloud</groupId>\n\t\t<artifactId>spring-cloud-netflix</artifactId>\n\t\t<version>1.4.3.RELEASE</version>\n\t\t<relativePath>..</relativePath> <!-- lookup parent from repository -->\n\t</parent>\n\t<artifactId>spring-cloud-starter-zuul</artifactId>\n\t<name>spring-cloud-starter-zuul</name>\n\t<description>Spring Cloud Starter Zuul (deprecated, please use spring-cloud-starter-netflix-zuul)</description>\n\t<url>https://projects.spring.io/spring-cloud</url>\n\t<organization>\n\t\t<name>Pivotal Software, Inc.</name>\n\t\t<url>https://www.spring.io</url>\n\t</organization>\n\t<properties>\n\t\t<main.basedir>${basedir}/../..</main.basedir>\n\t</properties>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.cloud</groupId>\n\t\t\t<artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n\t\t</dependency>\n\t</dependencies>\n</project>\n\n```\n\n* 我们查看`spring-cloud-starter-netflix-zuul`包\n\n![](/images/server/spring/spring-cloud/zuul-starter2.jpg)\n\n* 这里关注`spring-cloud-starter-netflix-zuul/pom.xml`及`spring-cloud-starter-netflix-zuul-1.4.3.RELEASE.jar!/META-INF/spring.provides`\n    * 打开`/pom.xml`可以看到依赖了`com.netflix.zuul`，所以说`Spring Cloud Zuul`是基于`netflix`公司的`zuul`实现的，除此之外还添加了`hystrix`及`ribbon`依赖，所以`zuul`是自带这两个功能的，`spring-boot-starter-web`依赖可以使应用成为`web`应用，`spring-boot-starter-actuator`是监控依赖\n        ```xml\n        <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n            <modelVersion>4.0.0</modelVersion>\n            <parent>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-netflix</artifactId>\n                <version>1.4.3.RELEASE</version>\n            </parent>\n            <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n            <name>Spring Cloud Starter Netflix Zuul</name>\n            <description>Spring Cloud Starter Netflix Zuul</description>\n            <url>https://projects.spring.io/spring-cloud</url>\n            <organization>\n                <name>Pivotal Software, Inc.</name>\n                <url>https://www.spring.io</url>\n            </organization>\n            <properties>\n                <main.basedir>${basedir}/../../..</main.basedir>\n            </properties>\n            <dependencies>\n                <dependency>\n                    <groupId>org.springframework.cloud</groupId>\n                    <artifactId>spring-cloud-starter</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-starter-web</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-starter-actuator</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.cloud</groupId>\n                    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.cloud</groupId>\n                    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.cloud</groupId>\n                    <artifactId>spring-cloud-starter-netflix-archaius</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>com.netflix.zuul</groupId>\n                    <artifactId>zuul-core</artifactId>\n                </dependency>\n            </dependencies>\n        </project>\n        ```\n    * `/META-INF/spring.provides` 依赖`spring-platform-netflix-core`模块及`zuul-core`模块\n        ```xml\n        provides: spring-platform-netflix-core, zuul-core\n        ```\n* 现在我们进入`spring-platform-netflix-core`，看看`Spring`是怎样集成`Netflix`的一系列框架了，下面是代码框架图\n\n![](/images/server/spring/spring-cloud/netflix-core.jpg)\n\n* 可以看到这个炸包也包含了`spring.factories`文件，所以`SpringBoot`项目启动的时候会检索此配置文件，此文件是`zuul`实现自动注册配置的关键，下面可以看到熟悉的`zuul`,`hystrix`,`feign`,`ribbon`的自动配置类\n\n```xml\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.cloud.netflix.archaius.ArchaiusAutoConfiguration,\\\norg.springframework.cloud.netflix.feign.ribbon.FeignRibbonClientAutoConfiguration,\\\norg.springframework.cloud.netflix.feign.FeignAutoConfiguration,\\\norg.springframework.cloud.netflix.feign.encoding.FeignAcceptGzipEncodingAutoConfiguration,\\\norg.springframework.cloud.netflix.feign.encoding.FeignContentGzipEncodingAutoConfiguration,\\\norg.springframework.cloud.netflix.hystrix.HystrixAutoConfiguration,\\\norg.springframework.cloud.netflix.hystrix.security.HystrixSecurityAutoConfiguration,\\\norg.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration,\\\norg.springframework.cloud.netflix.rx.RxJavaAutoConfiguration,\\\norg.springframework.cloud.netflix.metrics.servo.ServoMetricsAutoConfiguration,\\\norg.springframework.cloud.netflix.zuul.ZuulServerAutoConfiguration,\\\norg.springframework.cloud.netflix.zuul.ZuulProxyAutoConfiguration\n\norg.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\\\norg.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration\n\norg.springframework.boot.env.EnvironmentPostProcessor=\\\norg.springframework.cloud.netflix.metrics.ServoEnvironmentPostProcessor\n```\n\n* 我们现在关心`Zuul`的自动配置类，从上面`spring.factories`文件可以看到和`Zuul`相关的是自动配置了两个类，下图可以看到这两个有继承关系，`ZuulProxyAutoConfiguration`功能最为完全\n\n![](/images/server/spring/spring-cloud/ZuulProxyAutoConfiguration.png)\n\n* `ZuulServerAutoConfiguration` 与  `ZuulProxyAutoConfiguration`\n    * `ZuulServerAutoConfiguration`自动配置类，启动类上如果有`@EnableZuulServer`则此类生效\n        * 下面代码可以看到大量使用了`@Conditional`作为条件判断，注意这个`ZuulController`这个`Bean`，它是我们`Zuul`的请求入口，这个类实现了`Controller`了，说明这里也使用了`Spring MVC DispatcherServlet`，\n        * 同时此类注册了大量的`ZuulFilter`\n        * 代码:\n        ```java\n        /**\n         * @author Spencer Gibb\n         * @author Dave Syer\n         * @author Biju Kunjummen\n         */\n        @Configuration // 声明是配置类\n        @EnableConfigurationProperties({ ZuulProperties.class }) // 激活 zuul配置\n        @ConditionalOnClass(ZuulServlet.class) // 条件1 存在ZuulServlet.class\n        @ConditionalOnBean(ZuulServerMarkerConfiguration.Marker.class) // 条件2 存在ZuulServerMarkerConfiguration.Marker.class bean, 即应用使用@EnableZuulServer注解\n        // Make sure to get the ServerProperties from the same place as a normal web app would\n        @Import(ServerPropertiesAutoConfiguration.class) // 配置ServerProperties实例\n        public class ZuulServerAutoConfiguration {\n        \n            @Autowired\n            protected ZuulProperties zuulProperties;\n        \n            @Autowired\n            protected ServerProperties server;\n        \n            @Autowired(required = false)\n            private ErrorController errorController;\n        \n            @Bean\n            public HasFeatures zuulFeature() {\n                return HasFeatures.namedFeature(\"Zuul (Simple)\", ZuulServerAutoConfiguration.class);\n            }\n        \n            @Bean\n            @Primary\n            public CompositeRouteLocator primaryRouteLocator(\n                    Collection<RouteLocator> routeLocators) {\n                return new CompositeRouteLocator(routeLocators);\n            }\n        \n            @Bean\n            @ConditionalOnMissingBean(SimpleRouteLocator.class)\n            public SimpleRouteLocator simpleRouteLocator() {\n                return new SimpleRouteLocator(this.server.getServletPrefix(),\n                        this.zuulProperties);\n            }\n        \n            /**\n             * zuulController, 包装了一个ZuulServlet类型的servlet, 实现对ZuulServlet类型的servlet的初始化.\n             *\n             * @return\n             */\n            @Bean\n            public ZuulController zuulController() {\n                return new ZuulController();\n            }\n        \n            @Bean\n            public ZuulHandlerMapping zuulHandlerMapping(RouteLocator routes) {\n                ZuulHandlerMapping mapping = new ZuulHandlerMapping(routes, zuulController());\n                mapping.setErrorController(this.errorController);\n                return mapping;\n            }\n        \n            @Bean\n            public ApplicationListener<ApplicationEvent> zuulRefreshRoutesListener() {\n                return new ZuulRefreshListener();\n            }\n        \n            @Bean\n            @ConditionalOnMissingBean(name = \"zuulServlet\")\n            public ServletRegistrationBean zuulServlet() {\n                ServletRegistrationBean servlet = new ServletRegistrationBean(new ZuulServlet(),\n                        this.zuulProperties.getServletPattern());\n                // The whole point of exposing this servlet is to provide a route that doesn't\n                // buffer requests.\n                servlet.addInitParameter(\"buffer-requests\", \"false\");\n                return servlet;\n            }\n        \n            // pre filters\n        \n            @Bean\n            public ServletDetectionFilter servletDetectionFilter() {\n                return new ServletDetectionFilter();\n            }\n        \n            @Bean\n            public FormBodyWrapperFilter formBodyWrapperFilter() {\n                return new FormBodyWrapperFilter();\n            }\n        \n            @Bean\n            public DebugFilter debugFilter() {\n                return new DebugFilter();\n            }\n        \n            @Bean\n            public Servlet30WrapperFilter servlet30WrapperFilter() {\n                return new Servlet30WrapperFilter();\n            }\n        \n            // post filters\n        \n            @Bean\n            public SendResponseFilter sendResponseFilter() {\n                return new SendResponseFilter();\n            }\n        \n            @Bean\n            public SendErrorFilter sendErrorFilter() {\n                return new SendErrorFilter();\n            }\n        \n            @Bean\n            public SendForwardFilter sendForwardFilter() {\n                return new SendForwardFilter();\n            }\n        \n            @Bean\n            @ConditionalOnProperty(value = \"zuul.ribbon.eager-load.enabled\", matchIfMissing = false)\n            public ZuulRouteApplicationContextInitializer zuulRoutesApplicationContextInitiazer(\n                    SpringClientFactory springClientFactory) {\n                return new ZuulRouteApplicationContextInitializer(springClientFactory,\n                        zuulProperties);\n            }\n        \n            @Configuration\n            protected static class ZuulFilterConfiguration {\n        \n                @Autowired\n                private Map<String, ZuulFilter> filters;\n        \n                @Bean\n                public ZuulFilterInitializer zuulFilterInitializer(\n                        CounterFactory counterFactory, TracerFactory tracerFactory) {\n                    FilterLoader filterLoader = FilterLoader.getInstance();\n                    FilterRegistry filterRegistry = FilterRegistry.instance();\n                    return new ZuulFilterInitializer(this.filters, counterFactory, tracerFactory, filterLoader, filterRegistry);\n                }\n        \n            }\n        \n            @Configuration\n            @ConditionalOnClass(CounterService.class)\n            protected static class ZuulCounterFactoryConfiguration {\n        \n                @Bean\n                @ConditionalOnBean(CounterService.class)\n                public CounterFactory counterFactory(CounterService counterService) {\n                    return new DefaultCounterFactory(counterService);\n                }\n            }\n        \n            @Configuration\n            protected static class ZuulMetricsConfiguration {\n        \n                @Bean\n                @ConditionalOnMissingBean(CounterFactory.class)\n                public CounterFactory counterFactory() {\n                    return new EmptyCounterFactory();\n                }\n        \n                @ConditionalOnMissingBean(TracerFactory.class)\n                @Bean\n                public TracerFactory tracerFactory() {\n                    return new EmptyTracerFactory();\n                }\n        \n            }\n        \n            private static class ZuulRefreshListener\n                    implements ApplicationListener<ApplicationEvent> {\n        \n                @Autowired\n                private ZuulHandlerMapping zuulHandlerMapping;\n        \n                private HeartbeatMonitor heartbeatMonitor = new HeartbeatMonitor();\n        \n                @Override\n                public void onApplicationEvent(ApplicationEvent event) {\n                    if (event instanceof ContextRefreshedEvent\n                            || event instanceof RefreshScopeRefreshedEvent\n                            || event instanceof RoutesRefreshedEvent) {\n                        this.zuulHandlerMapping.setDirty(true);\n                    }\n                    else if (event instanceof HeartbeatEvent) {\n                        if (this.heartbeatMonitor.update(((HeartbeatEvent) event).getValue())) {\n                            this.zuulHandlerMapping.setDirty(true);\n                        }\n                    }\n                }\n        \n            }\n        \n        }\n        ```\n    * `ZuulProxyAutoConfiguration`自动配置类，启动类上如果有对应`@EnableZuulProxy`则此类生效\n        * 由上面此类的继承图可以发现这个类继承了`ZuulServerAutoConfiguration`，所以此类拥有`ZuulServerAutoConfiguration`的所有功能，并在此基础上添加了使用了服务发现作为路由寻址功能\n        * 代码：\n        ```java\n        /**\n         * @author Spencer Gibb\n         * @author Dave Syer\n         * @author Biju Kunjummen\n         */\n        @Configuration // 声明是配置类\n        @Import({ RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class, // 引入RibbonCommandFactory配置\n                RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,\n                RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class,\n                HttpClientConfiguration.class })\n        @ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class) // 条件2 存在ZuulProxyMarkerConfiguration.Marker.class bean, 即应用使用@EnableZuulProxy注解\n        public class ZuulProxyAutoConfiguration extends ZuulServerAutoConfiguration {\n        \n            @SuppressWarnings(\"rawtypes\")\n            @Autowired(required = false)\n            private List<RibbonRequestCustomizer> requestCustomizers = Collections.emptyList();\n        \n            /**\n             * 网关服务注册实例信息\n             */\n            @Autowired(required = false)\n            private Registration registration;\n        \n            /**\n             * 服务发现客户端\n             */\n            @Autowired\n            private DiscoveryClient discovery;\n        \n            /**\n             * serviceId和路由的映射逻辑\n             */\n            @Autowired\n            private ServiceRouteMapper serviceRouteMapper;\n        \n            @Override\n            public HasFeatures zuulFeature() {\n                return HasFeatures.namedFeature(\"Zuul (Discovery)\",\n                        ZuulProxyAutoConfiguration.class);\n            }\n        \n            /**\n             * 静态和动态路由寻址: 静态从配置文件获取, 动态通过服务发现客户端完成. 后者优先级更高\n             * @return\n             */\n            @Bean\n            @ConditionalOnMissingBean(DiscoveryClientRouteLocator.class)\n            public DiscoveryClientRouteLocator discoveryRouteLocator() {\n                return new DiscoveryClientRouteLocator(this.server.getServletPrefix(),\n                        this.discovery, this.zuulProperties, this.serviceRouteMapper, this.registration);\n            }\n        \n            // pre filters\n            @Bean\n            public PreDecorationFilter preDecorationFilter(RouteLocator routeLocator,\n                    ProxyRequestHelper proxyRequestHelper) {\n                return new PreDecorationFilter(routeLocator, this.server.getServletPrefix(),\n                        this.zuulProperties, proxyRequestHelper);\n            }\n        \n            // route filters\n            @Bean\n            public RibbonRoutingFilter ribbonRoutingFilter(ProxyRequestHelper helper,\n                    RibbonCommandFactory<?> ribbonCommandFactory) {\n                RibbonRoutingFilter filter = new RibbonRoutingFilter(helper, ribbonCommandFactory,\n                        this.requestCustomizers);\n                return filter;\n            }\n        \n            @Bean\n            @ConditionalOnMissingBean({SimpleHostRoutingFilter.class, CloseableHttpClient.class})\n            public SimpleHostRoutingFilter simpleHostRoutingFilter(ProxyRequestHelper helper,\n                    ZuulProperties zuulProperties,\n                    ApacheHttpClientConnectionManagerFactory connectionManagerFactory,\n                    ApacheHttpClientFactory httpClientFactory) {\n                return new SimpleHostRoutingFilter(helper, zuulProperties,\n                        connectionManagerFactory, httpClientFactory);\n            }\n        \n            @Bean\n            @ConditionalOnMissingBean({SimpleHostRoutingFilter.class})\n            public SimpleHostRoutingFilter simpleHostRoutingFilter2(ProxyRequestHelper helper,\n                                                                   ZuulProperties zuulProperties,\n                                                                   CloseableHttpClient httpClient) {\n                return new SimpleHostRoutingFilter(helper, zuulProperties,\n                        httpClient);\n            }\n        \n            @Bean\n            public ApplicationListener<ApplicationEvent> zuulDiscoveryRefreshRoutesListener() {\n                return new ZuulDiscoveryRefreshListener();\n            }\n        \n            @Bean\n            @ConditionalOnMissingBean(ServiceRouteMapper.class)\n            public ServiceRouteMapper serviceRouteMapper() {\n                return new SimpleServiceRouteMapper();\n            }\n        \n            @Configuration\n            @ConditionalOnMissingClass(\"org.springframework.boot.actuate.endpoint.Endpoint\")\n            protected static class NoActuatorConfiguration {\n        \n                @Bean\n                public ProxyRequestHelper proxyRequestHelper(ZuulProperties zuulProperties) {\n                    ProxyRequestHelper helper = new ProxyRequestHelper();\n                    helper.setIgnoredHeaders(zuulProperties.getIgnoredHeaders());\n                    helper.setTraceRequestBody(zuulProperties.isTraceRequestBody());\n                    return helper;\n                }\n        \n            }\n        \n            /**\n             * 添加 Endpoint\n             */\n            @Configuration\n            @ConditionalOnClass(Endpoint.class)\n            protected static class EndpointConfiguration {\n        \n                @Autowired(required = false)\n                private TraceRepository traces;\n        \n                @ConditionalOnEnabledEndpoint(\"routes\")\n                @Bean\n                public RoutesEndpoint routesEndpoint(RouteLocator routeLocator) {\n                    return new RoutesEndpoint(routeLocator);\n                }\n        \n                @ConditionalOnEnabledEndpoint(\"routes\")\n                @Bean\n                public RoutesMvcEndpoint routesMvcEndpoint(RouteLocator routeLocator,\n                        RoutesEndpoint endpoint) {\n                    return new RoutesMvcEndpoint(endpoint, routeLocator);\n                }\n        \n                @ConditionalOnEnabledEndpoint(\"filters\")\n                @Bean\n                public FiltersEndpoint filtersEndpoint() {\n                    FilterRegistry filterRegistry = FilterRegistry.instance();\n                    return new FiltersEndpoint(filterRegistry);\n                }\n        \n                @Bean\n                public ProxyRequestHelper proxyRequestHelper(ZuulProperties zuulProperties) {\n                    TraceProxyRequestHelper helper = new TraceProxyRequestHelper();\n                    if (this.traces != null) {\n                        helper.setTraces(this.traces);\n                    }\n                    helper.setIgnoredHeaders(zuulProperties.getIgnoredHeaders());\n                    helper.setTraceRequestBody(zuulProperties.isTraceRequestBody());\n                    return helper;\n                }\n            }\n        \n            private static class ZuulDiscoveryRefreshListener\n                    implements ApplicationListener<ApplicationEvent> {\n        \n                private HeartbeatMonitor monitor = new HeartbeatMonitor();\n        \n                @Autowired\n                private ZuulHandlerMapping zuulHandlerMapping;\n        \n                @Override\n                public void onApplicationEvent(ApplicationEvent event) {\n                    if (event instanceof InstanceRegisteredEvent) {\n                        reset();\n                    }\n                    else if (event instanceof ParentHeartbeatEvent) {\n                        ParentHeartbeatEvent e = (ParentHeartbeatEvent) event;\n                        resetIfNeeded(e.getValue());\n                    }\n                    else if (event instanceof HeartbeatEvent) {\n                        HeartbeatEvent e = (HeartbeatEvent) event;\n                        resetIfNeeded(e.getValue());\n                    }\n        \n                }\n        \n                private void resetIfNeeded(Object value) {\n                    if (this.monitor.update(value)) {\n                        reset();\n                    }\n                }\n        \n                private void reset() {\n                    this.zuulHandlerMapping.setDirty(true);\n                }\n        \n            }\n        \n        }\n        ```\n* `ZuulServerAutoConfiguration` 与  `ZuulProxyAutoConfiguration`具体使用哪种模式，是分别通过`@EnableZuulServer` 和`@EnableZuulProxy`注解来区别的\n    * 前者使用了`ZuulProperties`进行配置路由寻址;\n    * 后者在原来的基础上添加了使用了服务发现作为路由寻址功能, 并使用`Ribbon`做客户端的负载均衡，这个最为常用;\n\n##### @EnableZuulProxy\n\n* `@EnableZuulProxy`注解\n\n```java\n/**\n * Sets up a Zuul server endpoint and installs some reverse proxy filters in it, so it can\n * forward requests to backend servers. The backends can be registered manually through\n * configuration or via DiscoveryClient.\n *\n * @see EnableZuulServer for how to get a Zuul server without any proxying\n *\n * @author Spencer Gibb\n * @author Dave Syer\n * @author Biju Kunjummen\n */\n@EnableCircuitBreaker\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Import(ZuulProxyMarkerConfiguration.class)\npublic @interface EnableZuulProxy {\n}\n```\n\n* `@EnableZuulProxy`分析\n    * `@EnableCircuitBreaker`注解用于开启短路器功能\n    ```java\n    /**\n     * Annotation to enable a CircuitBreaker implementation.\n     * http://martinfowler.com/bliki/CircuitBreaker.html\n     * @author Spencer Gibb\n     */\n    @Target(ElementType.TYPE)\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Inherited\n    @Import(EnableCircuitBreakerImportSelector.class)\n    public @interface EnableCircuitBreaker {\n    \n    }\n    ```\n    * `@Import(ZuulProxyMarkerConfiguration.class)`注解用于注册`ZuulProxyMarkerConfiguration.Marker.class`这个`Bean`，这个`Bean`与上面的`ZuulProxyAutoConfiguration`的条件注解相对应`@ConditionalOnBean(ZuulProxyMarkerConfiguration.Marker.class)`，所以说如果启动类带了这个`@EnableZuulProxy`注解将会开启`ZuulProxyMarkerConfiguration`自动注册的功能，`Spring`这个可配置化对使用者来说十分方便\n    ```java\n    @Configuration\n    public class ZuulProxyMarkerConfiguration {\n        @Bean\n        public Marker zuulProxyMarkerBean() {\n            return new Marker();\n        }\n    \n        class Marker {\n        }\n    }\n    ```\n##### 使用Consul作为注册中心\n\n* `@EnableZuulProxy`模式下的`zuul`需要注册中心的支持，因为`eureka`已经被抛弃了，我们这里选用的是`Consul`\n    * 添加`Maven`依赖\n    ```java\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n    </dependency>\n    ```\n    * 启动类上加上`@EnableDiscoveryClient`注解\n    ```java\n    @EnableZuulProxy\n    @EnableDiscoveryClient\n    @SpringBootApplication\n    public class ZuulApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ZuulApplication.class, args);\n        }\n    \n    }\n    ```\n    * 这样`Zuul`应用就可以发挥作用了\n### 总结\n* 本章节对`Zuul`的初始化进行了一次梳理，可以发现`Zuul`的初始化就是注册各种需要的`Bean`,粮草备好之后就是要发挥作用了，下一章节将介绍其具体是怎样发挥作用的\n* `Spring Cloud`对`Netflix Zuul`做了封装集成, 使得在`Spring Cloud`环境中使用`Zuul`更方便，只需添加`spring-cloud-starter-zuul` `maven`依赖及启动类上添加`@EnableZuulProxy`就可创建一个`zuul`应用\n* `Spring Cloud Zuul` 实际上就是在`Servlet`的基础上添加了一些`ZuulFilter`去完成一些额外事情，封装了就成框架了\n\n### 参考\n* https://www.cnblogs.com/lexiaofei/p/7080257.html","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(六)网关服务Zuul","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud()网关服务Zuul/","content":"### Zuul 简介\n\n#### Zuul是什么\n\n* `Zuul` 是`Netflix`开源的一个`API Gateway` 服务器, 本质上是一个`Web servlet`应用，他可以和`Eureka,Ribbon,Hystrix`等组件配合使用。\n\n* `Zuul`组件的核心是一系列的过滤器`filters`，其作用可以类比`Servlet`框架的`Filter`，或者`AOP`。\n\n\n#### 为什么要用Zuul\n* 在分布式架构中，对外提供的服务，在无网关的情况下，`API`接口直接暴露给服务调用方，当调用方增多，不同业务调用方各不相同，势必需要添加定制化访问权限、校验等逻辑。当添加`API`网关后，再第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。`Zuul`就是提供负载均衡、反向代理、权限认证的这么一个`API gateway`。\n\n\n* 微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关\n\n![logo](/images/server/spring/spring-cloud/zuul1.png)\n\n\n#### Zuul 提供什么功能\n* `Zuul`组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：\n    * 身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求\n    * 审查与监控：\n    * 动态路由：动态将请求路由到不同后端集群\n    * 压力测试：逐渐增加指向集群的流量，以了解性能\n    * 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求\n    * 静态响应处理：边缘位置进行响应，避免转发到内部集群\n    * 多区域弹性：跨域`AWS Region`进行请求路由，旨在实现`ELB(ElasticLoad Balancing)`使用多样化\n\n* `Spring Cloud`对`Zuul`进行了整合和增强。目前`Zuul`使用的默认是`Apache`的`HTTP Client`，也可以使用`Rest Client`，可以设置`ribbon.restclient.enabled=true`.\n\n### 简单示例\n\n> 添加Maven依赖配置\n\n```xml\n<dependencies>\n\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-zuul</artifactId>\n    </dependency>\n    \n</dependencies>\n```\n\n> 添加配置文件application.yml\n\n```xml\nserver:\n  port: 9001\nspring:\n  application:\n    name: zuul-gateway\neureka:\n  instance:\n    hostname: localhost\n  client:\n    service-url:\n      defaultZone: http://localhost:9010/eureka/,http://localhost:9011/eureka/\nzuul:\n  routes:\n    baidu-url: #传统路由方式\n      path: /baidu/**\n      url: http://www.baidu.com/\n    provider:  #面向服务的路由\n      path: /provider/**\n      serviceId: eureka-provider\n    consumer:  #面向服务的路由\n      path: /consumer/**\n      serviceId: eureka-consumer\n```\n\n> 启动类加上@EnableZuulProxy注解\n\n```java\n@EnableZuulProxy\n@SpringBootApplication\npublic class ZuulApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ZuulApplication.class, args);\n\t}\n}\n```\n\n> 添加一个过滤器 AccessFilter.java\n\n```java\npublic class AccessFilter extends ZuulFilter{\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 定义过滤器的类型，决定过滤器在请求的那个生命周期中执行\n     * pre     请求被路由之前 \n     * routing 在路由请求时被调用\n     * post    在routing和error过滤器之后被调用\n     * error   处理请求时发生错误时被调用\n     * @return\n     */\n    @Override\n    public String filterType() {\n        // 代表会在请求被路由之前被执行\n        return \"pre\";\n    }\n\n    /**\n     * 定义过滤器的顺序，当请求在一个阶段中存在多个过滤器时，可以根据该值来决定执行顺序\n     * @return\n     */\n    @Override\n    public int filterOrder() {\n        return 0;\n    }\n\n    /**\n     * 判断过滤器是否需要被执行\n     * @return\n     */\n    @Override\n    public boolean shouldFilter() {\n        return true;\n    }\n\n    /**\n     * 过滤器的具体实现\n     * @return\n     */\n    @Override\n    public Object run() {\n        RequestContext ctx = RequestContext.getCurrentContext();\n        HttpServletRequest request = ctx.getRequest();\n        logger.info(\"send {} request to {}\", request.getMethod(), request.getRequestURL().toString());\n        Object accessToken = request.getParameter(\"accessToken\");\n        if (accessToken == null) {\n            logger.error(\"access check failed\");\n            ctx.setSendZuulResponse(false);\n            ctx.setResponseStatusCode(401);\n            return null;\n        }\n        logger.error(\"access check passs\");\n        return null;\n    }\n}\n```\n\n\n### 解析\n\n#### zuul默认支持hystrix和ribbon\n\n```xml\nhystrix:\n  command:\n    default:\n      execution:\n        timeout:\n          enabled: true\n        isolation:\n          thread: \n            timeoutInMilliseconds: 60000 // 设置API网关中路由转发请求的HystrixCommand执行超时时间，就是整个路由转发请求的执行时间\nribbon:\n  ConnectTimeout: 60000 // 设置创建请求连接的超时时间，如果该值小于上面的HystrixCommand执行超时时间，会自动进行重试路由请求\n  ReadTimeout: 60000 // 设置请求连接建立之后执行处理的超时时间，如果该值小于上面的HystrixCommand执行超时时间，会自动进行重试路由请求\n```\n\n* `Zuul`的过滤器之间没有直接的相互通信，他们之间通过一个`RequestContext`的静态类来进行数据传递的。`RequestContext`类中有`ThreadLocal`变量来记录每个`Request`所需要传递的数据。\n\n* `Zuul`的过滤器是由`Groovy`写成，这些过滤器文件被放在`Zuul Server`上的特定目录下面，Zuul会定期轮询这些目录，修改过的过滤器会动态的加载到`Zuul Server`中以便过滤请求使用。\n\n#### 过滤器机制\n\n![](/images/server/spring/spring-cloud/zuul3.png)\n\n* `Zuul`大部分功能都是通过过滤器来实现的。Zuul中定义了四种标准过滤器类型，这些过滤器类型对应于请求的典型生命周期，下面有几种标准的过滤器类型：\n    * (1) PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。\n    * (2) ROUTING：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用`Apache HttpClient`或`Netfilx Ribbon`请求微服务。\n    * (3) POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的`HTTP Header`、收集统计信息和指标、将响应从微服务发送给客户端等。\n    * (4) ERROR：在其他阶段发生错误时执行该过滤器。\n\n##### 过滤器的生命周期\n\n* 各种不同类型的过滤器流转流程\n    * 当客户端请求过来首先会到 `pre filters` 这样的一个前置过滤器做一些处理，然后调用自定义的过滤器\n    * 前置过滤器执行完了之后会调用 `routing filters` 过滤器 ，看名字都知道这是做路由分发的过滤器\n    * 在路由的过程中出现了异常，那么会走 `error filters`过滤器，然后再走 `post filters` 过滤器 ，或者正常路由完成也会走到`post filters`\n    * `post filters`过滤器负责处理响应 ，最后把结果响应给客户端\n    \n![](/images/server/spring/spring-cloud/zuul.png)\n\n##### 内置的特殊过滤器\n\n* 下面是`zuul`默认实现的过滤器\n\n![](/images/server/spring/spring-cloud/zuul2.png)\n\n#### 其他\n* 当我们为`Spring Cloud Zuul`构建的`API`网关服务引入`Spring Cloud Eureka`之后，它会为`Eureka`中的每个服务都自动创建一个默认路由规则，这些默认规则的`path`会使用`ServiceId`配置的服务名作为请求前缀\n\n* `Spring Cloud Zuul`还特别提供了`/routes`端点来返回当前的所有路由规则\n\n### 总结\n\n\n### 参考\n* https://www.cnblogs.com/lexiaofei/p/7080257.html\n* https://www.jianshu.com/p/fd0d8a0019d6","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(五)声明式服务调用Feign","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud()声明式服务调用Feign/","content":"### Feign 简介\n\n#### 是什么\nFeign是一个声明式的Web Service客户端，整合了`Spring Cloud Ribbon`与`Spring Cloud Hystrix`\n\n#### 为什么要使用\n* 只需创建一个接口并用注解的方式来配置它，即可完成服务提供方的接口绑定\n* 在使用过程中与`Spring MVC`完美衔接\n* 整合了`Spring Cloud Ribbon`，可实现负载均衡，实现服务高可用\n* 整合了`Spring Cloud Hystrix`，可实现服务断路及服务降级\n\n#### 简单例子\n> pom.xml\n```xml\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-web</artifactId>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-eureka</artifactId>\n    </dependency>\n\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-feign</artifactId>\n    </dependency>\n\n    <dependency>\n      <groupId>com.fasterxml.jackson.core</groupId>\n      <artifactId>jackson-databind</artifactId>\n      <version>2.7.0</version>\n    </dependency>\n    <dependency>\n      <groupId>com.fasterxml.jackson.core</groupId>\n      <artifactId>jackson-annotations</artifactId>\n      <version>2.7.0</version>\n    </dependency>\n  </dependencies>\n```\n\n> PersonService.java\n\n```java\n/**\n * name 为服务提供者 application-name，fallback 指定服务接口的断路器实现方法，自带Ribbon负债均衡及重试机制\n * @author songshuiyang\n * @date 2018/10/22 21:53\n */\n@FeignClient(name = \"eureka-provider\", fallback = PersonHystrixFallback.class)\npublic interface PersonService {\n\n    @RequestMapping(\"getPersonName\")\n    String getPersonName();\n\n    @RequestMapping(\"getPerson\")\n    Person getPerson();\n\n}\n```\n\n> PersonHystrixFallback.java\n\n```java\n/**\n * Hystrix服务降级 每一个服务接口的断路器实现就是实现类中重写函数的实现\n * @author songshuiyang\n * @date 2018/10/22 22:26\n */\n@Component\npublic class PersonHystrixFallback implements PersonService {\n\n    @Override\n    public String getPersonName() {\n        return \"HystrixFallbackService ERROR\";\n    }\n\n    @Override\n    public Person getPerson() {\n        return new Person(0,\"HystrixFallbackService ERROR\",88);\n    }\n}\n```\n\n> FeignAppliacation.java\n\n```java\n/**\n * @author songshuiyang\n * @date 2018/10/22 21:50\n */\n@EnableFeignClients\n@EnableDiscoveryClient\n@SpringBootApplication\npublic class FeignAppliacation {\n    public static void main(String[] args) {\n        SpringApplication.run(FeignAppliacation.class,args);\n    }\n}\n```\n\n>application.yml\n\n```xml\nserver:\n  port: 9031\nspring:\n  application:\n    name: feign-consumer\neureka:\n  instance:\n    hostname: localhost\n  client:\n    service-url:\n      defaultZone: http://localhost:9010/eureka/,http://localhost:9011/eureka/\nribbon:\n  ConnectTimeout: 500\n  ReadTimeout: 5000\nfeign:\n  hystrix:\n    enabled: true\n```\n","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(四)服务容错保护Hystrix","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud()服务容错保护Hystrix/","content":"### Hystrix 简介\n\n#### Hystrix是什么\nHystrix对应的中文名字是“豪猪”，豪猪周身长满了刺，能保护自己不受天敌的伤害，代表了一种防御机制，这与hystrix本身的功能不谋而合，因此Netflix团队将该框架命名为Hystrix，并使用了对应的卡通形象做作为logo。\n\n#### 为什么要使用\n在一个分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，这个就是Hystrix需要做的事情。\n\n#### 提供哪些功能\n\nHystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。\n\n\n\n","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud()负载均衡Ribbon源码分析","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud()负载均衡Ribbon源码分析/","content":"### 前言\n\n### 三：源码分析\n> Ribbon实现客户端负债均衡是通过@LoadBalanced注解来开启的\n\n- @LoadBalanced 注解\n```java\n/**\n* 使用 LoadBalancerClient 该类来配置\n * Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient\n * @author Spencer Gibb\n */\n@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Qualifier\npublic @interface LoadBalanced {\n}\n```\n- LoadBalancerClient.java\n\n```java\n/**\n * Represents a client side load balancer\n * @author Spencer Gibb\n */\npublic interface LoadBalancerClient extends ServiceInstanceChooser {\n\n\t/**\n\t * 根据挑选出来服务实例执行请求\n\t * execute request using a ServiceInstance from the LoadBalancer for the specified\n\t * service\n\t * @param serviceId the service id to look up the LoadBalancer\n\t * @param request allows implementations to execute pre and post actions such as\n\t * incrementing metrics\n\t * @return the result of the LoadBalancerRequest callback on the selected\n\t * ServiceInstance\n\t */\n\t<T> T execute(String serviceId, LoadBalancerRequest<T> request) throws IOException;\n\n\t/**\n\t * 根据服务实例执行请求\n\t * execute request using a ServiceInstance from the LoadBalancer for the specified\n\t * service\n\t * @param serviceId the service id to look up the LoadBalancer\n\t * @param serviceInstance the service to execute the request to\n\t * @param request allows implementations to execute pre and post actions such as\n\t * incrementing metrics\n\t * @return the result of the LoadBalancerRequest callback on the selected\n\t * ServiceInstance\n\t */\n\t<T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest<T> request) throws IOException;\n\n\t/**\n\t * 将 http://myservice/path/to/service 构建一个真实的host:port形式的url\n\t * Create a proper URI with a real host and port for systems to utilize.\n\t * Some systems use a URI with the logical serivce name as the host,\n\t * such as http://myservice/path/to/service.  This will replace the\n\t * service name with the host:port from the ServiceInstance.\n\t * @param instance\n\t * @param original a URI with the host as a logical service name\n\t * @return a reconstructed URI\n\t */\n\tURI reconstructURI(ServiceInstance instance, URI original);\n}\n```\n- ServiceInstanceChooser.java\n```java\npublic interface ServiceInstanceChooser {\n\n    /**\n    *  根据传入的服务实例名serviceId，从负债均衡中挑选一个对应服务的实例\n     * Choose a ServiceInstance from the LoadBalancer for the specified service\n     * @param serviceId the service id to look up the LoadBalancer\n     * @return a ServiceInstance that matches the serviceId\n     */\n    ServiceInstance choose(String serviceId);\n}\n```\n\n\n### 主要负载均衡策略\n\n#### 1、简单轮询负载均衡（RoundRobin）\n\n以轮询的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。\n\n#### 2、随机负载均衡 （Random）\n\n随机选择状态为UP的Server\n\n#### 3、加权响应时间负载均衡 （WeightedResponseTime）\n\n根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。\n\n#### 4、区域感知轮询负载均衡（ZoneAvoidanceRule）\n\n复合判断server所在区域的性能和server的可用性选择server\n\n### 其他\n\n* 它内部提供了一个叫做`ILoadBalance`的接口代表负载均衡器的操作，比如有添加服务器操作、选择服务器操作、获取所有的服务器列表、获取可用的服务器列表等等。\n\n### 总结\n* 负载均衡器的目的主要是根据负责均衡策略选取合适的服务端实例","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(四)负载均衡Ribbon介绍","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud()负载均衡Ribbon介绍/","content":"### 前言\n\n#### 什么是Spring Cloud Ribbon\n\n* `Ribbon`是为客户端提供负载均衡功能的服务\n\n* 百度百科：\n    * 英文名称为`Load Balance`\n    * 其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行\n\n\n### 简单示例\n\n#### 1、集成ribbon\n```xml\n    <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-ribbon</artifactId>\n    </dependency>\n```\n#### 2、消费方\n> 消费方调用方法\n```java\n@Configuration\n@RestController\npublic class DemoController {\n    /**\n     * 主要用来调用REST服务，本身并不具备调用分布式服务的能力，但通过LoadBalanced注解开启客户端负债均衡\n     * @return\n     */\n    @Bean\n    @LoadBalanced\n    public RestTemplate getRestTemplate() {\n        return new RestTemplate();\n    }\n\n    @RequestMapping(value = \"/router\", method = RequestMethod.GET,\n            produces = MediaType.APPLICATION_JSON_VALUE)\n    public String router() {\n        RestTemplate restTpl = getRestTemplate();\n        // 根据应用名称调用服务\n        String json = restTpl.getForObject(\"http://eureka-provider/person/1\", String.class);\n        return json;\n    }\n}\n```\n> 消费方配置文件\n```java\nserver:\n  port: 9050\nspring:\n  application:\n    name: eureka-consumer\neureka:\n  instance:\n    hostname: localhost\n  client:\n    service-url:\n      defaultZone: http://localhost:9010/eureka/,http://localhost:9020/eureka/\n```\n\n#### 3、服务方\n> 服务提供方法, 这里就是简单模拟了一下根据personId获取人员信息，并返回对应服务的端口\n```java\n   @RequestMapping(value = \"/person/{personId}\", method = RequestMethod.GET,\n            produces = MediaType.APPLICATION_JSON_VALUE)\n    public Person findPerson(@PathVariable(\"personId\") Integer personId, HttpServletRequest request) {\n        Person person = new Person(personId, \"songsy\", 18);\n        person.setName(person.getName() + \"端口：\" + IpConfigurationUtils.getPort());\n        return person;\n    }\n```\n\n> 配置文件\n```xml\nspring:\n  application:\n    name: eureka-provider\neureka:\n  instance:\n    hostname: localhost\n  client:\n    service-url:\n      defaultZone: http://localhost:9010/eureka/,http://localhost:9020/eureka/\n```\n##### 3.1 服务方1 以9011端口启动\n```java\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Slave1ProviderApplication.class).properties(\"server.port=9011\").run(args);\n    }\n```\n##### 3.2 服务方2 以9023端口启动\n```java\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(Slave1ProviderApplication.class).properties(\"server.port=9023\").run(args);\n    }\n```\n#### 4、测试结果\n连续访问 `http://localhost:9050/router` 会得到不同的结果， 可以看到已经实现了负载均衡\n```xml\n{\"id\":1,\"name\":\"songsy端口：9023\",\"age\":18}\n\n{\"id\":1,\"name\":\"songsy端口：9011\",\"age\":18}\n```\n### 二：RestTemplate 使用\n> GET 请求\n\n提供 `getForObject()、 getForEntity()`\n\n> POST 请求\n\n提供 `postForObject()、 postForObject()、postForLocation()`\n\n> PUT 请求\n\n提供 `put(), put()` 函数没有返回内容\n\n> DELETE 请求\n\n提供 `delete()`\n\n### 其他\n\n### 总结\n* 负载均衡器的目的主要是根据负责均衡策略选取合适的服务端实例","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(五)集成Consul源码分析之执行流程二","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud(五)集成Consul源码分析之执行流程二/","content":"### 前言\n\n* 上一章节通过日志信息定位`ConsulServiceRegistry`这个类会进行注册操作，通过断点调试发现是由`ConsulAutoServiceRegistration`这个类来指挥的，这一章节来介绍这个类\n\n### 解析\n\n#### ConsulAutoServiceRegistration的配置\n\n![](/images/server/spring/spring-cloud/consul0d-dsd.png)\n\n* 这个类是哪里配置呢，查看`spring.factories`里面配置了一个类`ConsulAutoServiceRegistrationAutoConfiguration`\n\n```\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.cloud.consul.discovery.RibbonConsulAutoConfiguration,\\\norg.springframework.cloud.consul.discovery.configclient.ConsulConfigServerAutoConfiguration,\\\norg.springframework.cloud.consul.serviceregistry.ConsulAutoServiceRegistrationAutoConfiguration,\\\norg.springframework.cloud.consul.serviceregistry.ConsulServiceRegistryAutoConfiguration,\\\norg.springframework.cloud.consul.discovery.ConsulDiscoveryClientConfiguration\n\n\norg.springframework.cloud.bootstrap.BootstrapConfiguration=\\\norg.springframework.cloud.consul.discovery.configclient.ConsulDiscoveryClientConfigServiceBootstrapConfiguration\n```\n\n* 查看`ConsulAutoServiceRegistrationAutoConfiguration.java`类可以发现里面配置了`@Bean`\n\n```java\n/**\n * @author Spencer Gibb\n */\n@Configuration\n@ConditionalOnBean(AutoServiceRegistrationProperties.class)\n@ConditionalOnMissingBean(type = \"org.springframework.cloud.consul.discovery.ConsulLifecycle\")\n@ConditionalOnConsulEnabled\n@ConditionalOnProperty(value = \"spring.cloud.service-registry.auto-registration.enabled\", matchIfMissing = true)\n@AutoConfigureAfter({AutoServiceRegistrationConfiguration.class, ConsulServiceRegistryAutoConfiguration.class})\npublic class ConsulAutoServiceRegistrationAutoConfiguration {\n\n    @Autowired\n    AutoServiceRegistrationProperties autoServiceRegistrationProperties;\n    // 注册ConsulAutoServiceRegistration\n    @Bean\n    @ConditionalOnMissingBean\n    public ConsulAutoServiceRegistration consulAutoServiceRegistration(\n            ConsulServiceRegistry registry,\n            AutoServiceRegistrationProperties autoServiceRegistrationProperties,\n            ConsulDiscoveryProperties properties,\n            ConsulAutoRegistration consulRegistration) {\n        return new ConsulAutoServiceRegistration(registry,\n                autoServiceRegistrationProperties, properties, consulRegistration);\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public ConsulAutoRegistration consulRegistration(AutoServiceRegistrationProperties autoServiceRegistrationProperties,\n            ConsulDiscoveryProperties properties, ApplicationContext applicationContext,\n            ObjectProvider<List<ConsulRegistrationCustomizer>> registrationCustomizers, HeartbeatProperties heartbeatProperties) {\n        return ConsulAutoRegistration.registration(autoServiceRegistrationProperties, properties,\n            applicationContext, registrationCustomizers.getIfAvailable(), heartbeatProperties);\n    }\n\n    @Configuration\n    @ConditionalOnClass(ServletContext.class)\n    protected static class ConsulServletConfiguration {\n        @Bean\n        public ConsulRegistrationCustomizer servletConsulCustomizer(ObjectProvider<ServletContext> servletContext) {\n            return new ConsulServletRegistrationCustomizer(servletContext);\n        }\n    }\n}\n```\n\n#### ConsulAutoServiceRegistration 类解析\n\n##### ConsulAutoServiceRegistration 继承关系图\n\n![](/images/server/spring/spring-cloud/ConsulAutoServiceRegistration.png)\n\n* 由上图可以看到此类实现了`Lifecycle`接口，也就是说`Spring`容器启动时或者关闭时会找出所有实现了`LifeCycle`及其子类接口的类，并一一调用其接口方法\n    * 下面是`Lifecycle`接口， `start()`方法对应容器启动时执行的方法，`stop()`方法对应容器关闭时执行的方法\n    ```java\n    public interface Lifecycle {\n        void start();\n        void stop();\n        boolean isRunning();\n    }\n    ```\n    * 所以可以猜出`ConsulAutoServiceRegistration`就是借助了`Lifecycle`接口来达到启动应用时会自动注册到`Consul`，应用关闭时自动注销在`Consul`的注册信息\n    * 回顾下上一章节的内容，可以看到是调用了`start()`方法\n    ![](/images/server/spring/spring-cloud/consul-register.png)\n\n* 下面来看看`ConsulAutoServiceRegistration`是怎么实现这两个方法的，`ConsulAutoServiceRegistration`对这两个方法的实现在`AbstractDiscoveryLifecycle`类上\n\n##### start()\n\n* `org.springframework.cloud.client.discovery.AbstractDiscoveryLifecycle#start()` 下面可以看到是调用了`register()`方法，这个方法是抽象方法，由子类来实现\n\n```java\n@Override\npublic void start() {\n    if (!isEnabled()) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Discovery Lifecycle disabled. Not starting\");\n        }\n        return;\n    }\n\n    // only set the port if the nonSecurePort is 0 and this.port != 0\n    if (this.port.get() != 0 && getConfiguredPort() == 0) {\n        setConfiguredPort(this.port.get());\n    }\n    // only initialize if nonSecurePort is greater than 0 and it isn't already running\n    // because of containerPortInitializer below\n    if (!this.running.get() && getConfiguredPort() > 0) {\n        register();\n        if (shouldRegisterManagement()) {\n            registerManagement();\n        }\n        this.context.publishEvent(new InstanceRegisteredEvent<>(this,\n                getConfiguration()));\n        this.running.compareAndSet(false, true);\n    }\n}\n```\n\n* 进入此方法 `org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration#register()`，可以看到调用了` ServiceRegistry<R> serviceRegistry`对象的注册方法\n\n```java\n/**\n * Register the local service with the {@link ServiceRegistry}\n */\n@Override\nprotected void register() {\n    this.serviceRegistry.register(getRegistration());\n}\n```\n\n* 进入`org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistry#register()`方法，可以看到有两步操作\n    * 添加`ttlScheduler`定时任务\n    * `agentServiceRegister`注册服务\n\n```java\n@Override\npublic void register(ConsulRegistration reg) {\n    log.info(\"Registering service with consul: \" + reg.getService());\n    try {\n        client.agentServiceRegister(reg.getService(), properties.getAclToken());\n        if (heartbeatProperties.isEnabled() && ttlScheduler != null) {\n            ttlScheduler.add(reg.getInstanceId());\n        }\n    }\n    catch (ConsulException e) {\n        if (this.properties.isFailFast()) {\n            log.error(\"Error registering service with consul: \" + reg.getService(), e);\n            ReflectionUtils.rethrowRuntimeException(e);\n        }\n        log.warn(\"Failfast is false. Error registering service with consul: \" + reg.getService(), e);\n    }\n}\n```\n\n* 继续跳入，直到进入`com.ecwid.consul.v1.agent.AgentConsulClient#agentServiceRegister()`，这个方法是`consul`的包里面的，不是`Spring`的，可以发现底层就是发送了一个`RESTFUL API`请求\n\n```java\n@Override\npublic Response<Void> agentServiceRegister(NewService newService, String token) {\n    UrlParameters tokenParam = token != null ? new SingleUrlParameters(\"token\", token) : null;\n\n    String json = GsonFactory.getGson().toJson(newService);\n    RawResponse rawResponse = rawClient.makePutRequest(\"/v1/agent/service/register\", json, tokenParam);\n\n    if (rawResponse.getStatusCode() == 200) {\n        return new Response<Void>(null, rawResponse);\n    } else {\n        throw new OperationException(rawResponse);\n    }\n}\n```\n\n\n##### stop()\n\n* `org.springframework.cloud.client.discovery.AbstractDiscoveryLifecycle#stop()`下面可以看到是调用了`deregister()`方法，这个方法是抽象方法，由子类来实现\n\n```java\n@Override\npublic void stop() {\n    if (this.running.compareAndSet(true, false) && isEnabled()) {\n        deregister();\n        if (shouldRegisterManagement()) {\n            deregisterManagement();\n        }\n    }\n}\n```\n\n* 进入此方法 `org.springframework.cloud.client.serviceregistry.AbstractAutoServiceRegistration#deregister()`，可以看到调用了` ServiceRegistry<R> serviceRegistry`对象的注册方法\n\n```java\n/**\n * De-register the local service with the {@link ServiceRegistry}\n */\n@Override\nprotected void deregister() {\n    this.serviceRegistry.deregister(getRegistration());\n}\n```\n\n* 进入`org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistry#deregister()`方法，可以看到有两步操作\n    * 去除`ttlScheduler`定时\n    * `agentServiceDeregister`注销服务\n```java\n@Override\npublic void deregister(ConsulRegistration reg) {\n    if (ttlScheduler != null) {\n        ttlScheduler.remove(reg.getInstanceId());\n    }\n    if (log.isInfoEnabled()) {\n        log.info(\"Deregistering service with consul: \" + reg.getInstanceId());\n    }\n    client.agentServiceDeregister(reg.getInstanceId());\n}\n```\n\n* 继续跳入，直到进入`com.ecwid.consul.v1.agent.AgentConsulClient#agentServiceDeregister()`方法，可以发现底层就是发送了一个`RESTFUL API`请求\n\n```java\n@Override\npublic Response<Void> agentServiceDeregister(String serviceId, String token) {\n    UrlParameters tokenParam = token != null ? new SingleUrlParameters(\"token\", token) : null;\n\n    RawResponse rawResponse = rawClient.makePutRequest(\"/v1/agent/service/deregister/\" + serviceId, \"\", tokenParam);\n\n    if (rawResponse.getStatusCode() == 200) {\n        return new Response<Void>(null, rawResponse);\n    } else {\n        throw new OperationException(rawResponse);\n    }\n}\n```\n\n### 总结\n* `ConsulAutoServiceRegistration`就是借助了`Lifecycle`接口来达到启动应用时会自动注册到`Consul`，应用关闭时自动注销在`Consul`的注册信息\n* 如果我们有需求在应用启动时或者关闭时做一些额外的事情，那么借助`Lifecycle`接口就可以达到我们的目的，不过需要注意的在使用`Lifecycle`接口方法时，如果`Spring`容器上下文没有显式的调用容器的`start`和`destory(或者close,stop)`等方法时是不会触发接口方法的，我们可以借助`SmartLifecycle`接口， 实现这个接口类会在所在的上下文在调用`refresh`时，希望能够自己自动进行回调\n\n### 参考\n","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(四)集成Consul源码分析之执行流程一","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud(四)集成Consul源码分析之执行流程一/","content":"### 前言\n\n* 上一章节我们知道了`SpringCloud`集成`Consul`过程就是注册`bean`的过程，那么有了这些`bean`，那它们是怎样发挥作用的呢，如果要实现微服务之间的通信就是要将本地服务信息注册得到注册中心上，那`SpringCloudConsul`是怎么实现的，这个是我们本章要探究的。\n\n* 因为`SpringCloudConsul`自动配置的类很多，一个一个去找十分麻烦，所以我们这里先关注它是怎么将本地服务注册得到注册中心上，通过之前章节可以知道只要启动应用，应用就会自动将自己注册到注册中心上，因为`Spring`有很多钩子接口及一套生命周期，所以我们看看它是怎么实现的，我们可以将`log`日志改为`debug`，通过日志来找出那些关键信息\n\n### 解析\n\n* 通过启动日志查看关键字`registe`我们可以定位到这行日志，这些信息就是我们在`SpringCloud(二)注册中心Consul`章节中介绍注册服务的信息是一一对应的，所以我们可以知道`SpringCloudConsul`注册服务也是通过`RESTful HTTP API`来注册服务的 \n\n```sql\no.s.c.c.s.ConsulServiceRegistry          : Registering service with consul: NewService{id='cloudUser-dev-2010', name='cloudUser', tags=[], address='10.135.95.34', port=2010, enableTagOverride=null, check=Check{script='null', interval='10s', ttl='null', http='http://10.135.95.34:2010/health', tcp='null', timeout='null', deregisterCriticalServiceAfter='null', tlsSkipVerify=null, status='null'}, checks=null}\n```\n\n* 日志拆解\n\n```\n{\nid='cloudUser-dev-2010',   // 服务id\nname='cloudUser',          // 服务名\ntags=[],                   // 服务的tag，自定义，可以根据这个tag来区分同一个服务名的服务\naddress='10.135.95.34',    // 服务注册到consul的IP，服务发现，发现的就是这个IP\nport=2010,                 // 服务注册consul的PORT，发现的就是这个PORT\nenableTagOverride=null, \ncheck = Check{             // 健康检查部分\n    script='null',\n           interval='10s',                   // 健康检查间隔时间，每隔10s，调用一次上面的URL\n    ttl='null', \n    http='http://10.135.95.34:2010/health',  // 指定健康检查的URL，调用后只要返回20X，consul都认为是健康的\n    tcp='null', \n    timeout='null', \n    deregisterCriticalServiceAfter='null', \n    tlsSkipVerify=null, \n    status='null'\n}, \nchecks=null\n}\n```\n\n* 看日志定位到`org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistry`，这个类是在`spring-cloud-consul-discovery`包下的，上一章节有涉及到\n\n![](/images/server/spring/spring-cloud/consul0d-dsd.png)\n\n* 通过类名字及方法名我们可以知道这个类是`Consul`服务的注册及下架的处理类\n\n```java\n/**\n * @author Spencer Gibb\n */\npublic class ConsulServiceRegistry implements ServiceRegistry<ConsulRegistration> {\n\n\tprivate static Log log = LogFactory.getLog(ConsulServiceRegistry.class);\n\n\tprivate final ConsulClient client;\n\n\tprivate final ConsulDiscoveryProperties properties;\n\n\tprivate final TtlScheduler ttlScheduler;\n\n\tprivate final HeartbeatProperties heartbeatProperties;\n\n\tpublic ConsulServiceRegistry(ConsulClient client, ConsulDiscoveryProperties properties, TtlScheduler ttlScheduler, HeartbeatProperties heartbeatProperties) {\n\t\tthis.client = client;\n\t\tthis.properties = properties;\n\t\tthis.ttlScheduler = ttlScheduler;\n\t\tthis.heartbeatProperties = heartbeatProperties;\n\t}\n\n\t@Override\n\tpublic void register(ConsulRegistration reg) {\n\t\tlog.info(\"Registering service with consul: \" + reg.getService());\n\t\ttry {\n\t\t\tclient.agentServiceRegister(reg.getService(), properties.getAclToken());\n\t\t\tif (heartbeatProperties.isEnabled() && ttlScheduler != null) {\n\t\t\t\tttlScheduler.add(reg.getInstanceId());\n\t\t\t}\n\t\t}\n\t\tcatch (ConsulException e) {\n\t\t\tif (this.properties.isFailFast()) {\n\t\t\t\tlog.error(\"Error registering service with consul: \" + reg.getService(), e);\n\t\t\t\tReflectionUtils.rethrowRuntimeException(e);\n\t\t\t}\n\t\t\tlog.warn(\"Failfast is false. Error registering service with consul: \" + reg.getService(), e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void deregister(ConsulRegistration reg) {\n\t\tif (ttlScheduler != null) {\n\t\t\tttlScheduler.remove(reg.getInstanceId());\n\t\t}\n\t\tif (log.isInfoEnabled()) {\n\t\t\tlog.info(\"Deregistering service with consul: \" + reg.getInstanceId());\n\t\t}\n\t\tclient.agentServiceDeregister(reg.getInstanceId());\n\t}\n\n\t@Override\n\tpublic void close() {\n\n\t}\n\n\t@Override\n\tpublic void setStatus(ConsulRegistration registration, String status) {\n\t\tif (status.equalsIgnoreCase(OUT_OF_SERVICE.getCode())) {\n\t\t\tclient.agentServiceSetMaintenance(registration.getInstanceId(), true);\n\t\t} else if (status.equalsIgnoreCase(UP.getCode())) {\n\t\t\tclient.agentServiceSetMaintenance(registration.getInstanceId(), false);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"Unknown status: \"+status);\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic Object getStatus(ConsulRegistration registration) {\n\t\tString serviceId = registration.getServiceId();\n\t\tResponse<List<Check>> response = client.getHealthChecksForService(serviceId, QueryParams.DEFAULT);\n\t\tList<Check> checks = response.getValue();\n\n\t\tfor (Check check : checks) {\n\t\t\tif (check.getServiceId().equals(registration.getInstanceId())) {\n\t\t\t\tif (check.getName().equalsIgnoreCase(\"Service Maintenance Mode\")) {\n\t\t\t\t\treturn OUT_OF_SERVICE.getCode();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn UP.getCode();\n\t}\n}\n```\n\n* 下面来看`ConsulServiceRegistry`是如何发挥作用的\n\n#### ConsulServiceRegistry bean注册初始化\n\n* 点击`ConsulServiceRegistry`的引用可以进入到`org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistryAutoConfiguration`类，这个类是见名是自动配置类\n\n```java\n/**\n * @author Spencer Gibb\n */\n@Configuration\n@ConditionalOnConsulEnabled\n@ConditionalOnProperty(value = \"spring.cloud.service-registry.enabled\", matchIfMissing = true)\n@AutoConfigureBefore(ServiceRegistryAutoConfiguration.class)\npublic class ConsulServiceRegistryAutoConfiguration {\n\n\t@Autowired(required = false)\n\tprivate TtlScheduler ttlScheduler;\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic ConsulServiceRegistry consulServiceRegistry(ConsulClient consulClient, ConsulDiscoveryProperties properties,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   HeartbeatProperties heartbeatProperties) {\n\t\treturn new ConsulServiceRegistry(consulClient, properties, ttlScheduler, heartbeatProperties);\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\t@ConditionalOnProperty(\"spring.cloud.consul.discovery.heartbeat.enabled\")\n\tpublic TtlScheduler ttlScheduler(ConsulClient consulClient, HeartbeatProperties heartbeatProperties) {\n\t\treturn new TtlScheduler(heartbeatProperties, consulClient);\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic HeartbeatProperties heartbeatProperties() {\n\t\treturn new HeartbeatProperties();\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic ConsulDiscoveryProperties consulDiscoveryProperties(InetUtils inetUtils) {\n\t\treturn new ConsulDiscoveryProperties(inetUtils);\n\t}\n\n}\n```\n\n* 回顾上一章节，我们知道`spring.factories`里面配置了这个类，所以这个类会被`Spring`自动注册\n\n```\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.cloud.consul.discovery.RibbonConsulAutoConfiguration,\\\norg.springframework.cloud.consul.discovery.configclient.ConsulConfigServerAutoConfiguration,\\\norg.springframework.cloud.consul.serviceregistry.ConsulAutoServiceRegistrationAutoConfiguration,\\\norg.springframework.cloud.consul.serviceregistry.ConsulServiceRegistryAutoConfiguration,\\\norg.springframework.cloud.consul.discovery.ConsulDiscoveryClientConfiguration\n\n\norg.springframework.cloud.bootstrap.BootstrapConfiguration=\\\norg.springframework.cloud.consul.discovery.configclient.ConsulDiscoveryClientConfigServiceBootstrapConfiguration\n```\n\n* 观察`ConsulServiceRegistryAutoConfiguration`类\n    * 关注`@ConditionalOnProperty(value = \"spring.cloud.service-registry.enabled\", matchIfMissing = true)`这个条件注解，这里是说需要配置了该属性`ConsulServiceRegistryAutoConfiguration`类才生效，这个属性名是不是很熟悉，没错就是上一章节`@EnableDiscoveryClient`注解自动注册的`AutoServiceRegistrationConfiguration `类相对应的，`AutoServiceRegistrationConfiguration `类就是配置了这个属性\n    ```java\n    /**\n     * @author Spencer Gibb\n     */\n    @Configuration\n    @EnableConfigurationProperties(AutoServiceRegistrationProperties.class)\n    @ConditionalOnProperty(value = \"spring.cloud.service-registry.auto-registration.enabled\", matchIfMissing = true)\n    public class AutoServiceRegistrationConfiguration {\n    }\n  \n    @ConfigurationProperties(\"spring.cloud.service-registry.auto-registration\")\n    public class AutoServiceRegistrationProperties {\n  \n    ...\n    } \n    ```\n    * 在这里可以得出结论`@EnableDiscoveryClient`是开启服务自动注册类的开关，因为`@SpringCloudApplication`注解默认自带这个注解，所以在`SpringCloud`中只要添加了注册中心的依赖，就会默认开启注册中心的功能\n    * `TtlScheduler`这个`Bean`，这个是个定时器\n    * `HeartbeatProperties` 属性配置类，对应的属性前缀：`spring.cloud.consul.discovery.heartbeat`，这个是心跳检测的属性配置类\n    ```java\n    @ConfigurationProperties(prefix = \"spring.cloud.consul.discovery.heartbeat\")\n    @Data\n    @CommonsLog\n    @Validated\n    public class HeartbeatProperties {\n    \n        // TODO: change enabled to default to true when I stop seeing messages like\n        // [WARN] agent: Check 'service:testConsulApp:xtest:8080' missed TTL, is now critical\n        boolean enabled = false;\n    \n        @Min(1)\n        private int ttlValue = 30;\n    \n        @NotNull\n        private String ttlUnit = \"s\";\n    \n        @DecimalMin(\"0.1\")\n        @DecimalMax(\"0.9\")\n        private double intervalRatio = 2.0 / 3.0;\n    \n        private Period heartbeatInterval;\n    ```\n    * `ConsulDiscoveryProperties`属性配置类，对应的属性前缀：`spring.cloud.consul.discovery`，这个是`Consul`的主要配置类，我们平常最常使用的\n    ```java\n    @ConfigurationProperties(\"spring.cloud.consul.discovery\")\n    @Data\n    public class ConsulDiscoveryProperties {\n    \n        protected static final String MANAGEMENT = \"management\";\n    \n        @Getter(AccessLevel.PRIVATE)\n        @Setter(AccessLevel.PRIVATE)\n        private InetUtils.HostInfo hostInfo;\n    \n        @Value(\"${consul.token:${CONSUL_TOKEN:${spring.cloud.consul.token:${SPRING_CLOUD_CONSUL_TOKEN:}}}}\")\n        private String aclToken;\n    \n        /** Tags to use when registering service */\n        private List<String> tags = new ArrayList<>();\n    \n        /** Is service discovery enabled? */\n        private boolean enabled = true;\n    \n        /** Tags to use when registering management service */\n        private List<String> managementTags = Arrays.asList(MANAGEMENT);\n    \n        /** Alternate server path to invoke for health checking */\n        private String healthCheckPath = \"/health\";\n    \n        /** Custom health check url to override default */\n        private String healthCheckUrl;\n    \n        /** How often to perform the health check (e.g. 10s), defaults to 10s. */\n        private String healthCheckInterval = \"10s\";\n    \n        /** Timeout for health check (e.g. 10s). */\n        private String healthCheckTimeout;\n    \n        /**\n         * Timeout to deregister services critical for longer than timeout (e.g. 30m).\n         * Requires consul version 7.x or higher.\n         */\n        private String healthCheckCriticalTimeout;\n    \n        /** IP address to use when accessing service (must also set preferIpAddress to use) */\n        private String ipAddress;\n    \n        /** Hostname to use when accessing server */\n        private String hostname;\n    \n        /** Port to register the service under (defaults to listening port) */\n        private Integer port;\n    \n        /** Port to register the management service under (defaults to management port) */\n        private Integer managementPort;\n    \n        private Lifecycle lifecycle = new Lifecycle();\n    \n        /** Use ip address rather than hostname during registration */\n        private boolean preferIpAddress = false;\n        \n        /** Source of how we will determine the address to use */\n        private boolean preferAgentAddress = false;\n        \n        private int catalogServicesWatchDelay = 10;\n    \n        private int catalogServicesWatchTimeout = 2;\n    \n        /** Service name */\n        private String serviceName;\n    \n        /** Unique service instance id */\n        private String instanceId;\n    \n        /** Service instance zone */\n        private String instanceZone;\n    \n        /** Service instance group*/\n        private String instanceGroup;\n    \n        /**\n         * Service instance zone comes from metadata.\n         * This allows changing the metadata tag name.\n         */\n        private String defaultZoneMetadataName = \"zone\";\n    \n        /** Whether to register an http or https service */\n        private String scheme = \"http\";\n    \n        /** Suffix to use when registering management service */\n        private String managementSuffix = MANAGEMENT;\n    \n        /**\n         * Map of serviceId's -> tag to query for in server list.\n         * This allows filtering services by a single tag.\n         */\n        private Map<String, String> serverListQueryTags = new HashMap<>();\n    \n        /**\n         * Map of serviceId's -> datacenter to query for in server list.\n         * This allows looking up services in another datacenters.\n         */\n        private Map<String, String> datacenters = new HashMap<>();\n    \n        /** Tag to query for in service list if one is not listed in serverListQueryTags. */\n        private String defaultQueryTag;\n    \n        /**\n         * Add the 'passing` parameter to /v1/health/service/serviceName.\n         * This pushes health check passing to the server.\n         */\n        private boolean queryPassing = false;\n    \n        /** Register as a service in consul. */\n        private boolean register = true;\n    \n        /** Disable automatic de-registration of service in consul. */\n        private boolean deregister = true;\n    \n        /** Register health check in consul. Useful during development of a service. */\n        private boolean registerHealthCheck = true;\n    \n        /**\n         * Throw exceptions during service registration if true, otherwise, log\n         * warnings (defaults to true).\n         */\n        private boolean failFast = true;\n    \n        /**\n         * Skips certificate verification during service checks if true, otherwise\n         * runs certificate verification.\n         */\n        private Boolean healthCheckTlsSkipVerify;\n    \n        @SuppressWarnings(\"unused\")\n        private ConsulDiscoveryProperties() {}\n    \n        public ConsulDiscoveryProperties(InetUtils inetUtils) {\n            this.hostInfo = inetUtils.findFirstNonLoopbackHostInfo();\n            this.ipAddress = this.hostInfo.getIpAddress();\n            this.hostname = this.hostInfo.getHostname();\n        }\n    \n        /**\n         * @param serviceId The service who's filtering tag is being looked up\n         * @return The tag the given service id should be filtered by, or null.\n         */\n        public String getQueryTagForService(String serviceId){\n            String tag = serverListQueryTags.get(serviceId);\n            return tag != null ? tag : defaultQueryTag;\n        }\n    \n        public String getHostname() {\n            return this.preferIpAddress ? this.ipAddress : this.hostname;\n        }\n    \n        public void setHostname(String hostname) {\n            this.hostname = hostname;\n            this.hostInfo.override = true;\n        }\n    \n        public void setIpAddress(String ipAddress) {\n            this.ipAddress = ipAddress;\n            this.hostInfo.override = true;\n        }\n    \n        @Data\n        public static class Lifecycle {\n            private boolean enabled = true;\n        }\n    }\n    ```\n\n#### 如何注册服务的\n\n* `Bean`注册完成了就要发挥作用了，我们在日志处`log.info(\"Registering service with consul: \" + reg.getService());`打断点\n\n```java\n\t@Override\n\tpublic void register(ConsulRegistration reg) {\n\t\tlog.info(\"Registering service with consul: \" + reg.getService());\n\t\ttry {\n\t\t\tclient.agentServiceRegister(reg.getService(), properties.getAclToken());\n\t\t\tif (heartbeatProperties.isEnabled() && ttlScheduler != null) {\n\t\t\t\tttlScheduler.add(reg.getInstanceId());\n\t\t\t}\n\t\t}\n\t\tcatch (ConsulException e) {\n\t\t\tif (this.properties.isFailFast()) {\n\t\t\t\tlog.error(\"Error registering service with consul: \" + reg.getService(), e);\n\t\t\t\tReflectionUtils.rethrowRuntimeException(e);\n\t\t\t}\n\t\t\tlog.warn(\"Failfast is false. Error registering service with consul: \" + reg.getService(), e);\n\t\t}\n\t}\n```\n\n* 查看方法执行链\n\n![](/images/server/spring/spring-cloud/consul-register.png)\n\n\n* 下面来看看具体执行流程，可以看到还是老样子的`refresh()`方法\n    * 进入`org.springframework.context.support.AbstractApplicationContext#refresh()`方法\n    ```java\n\t/**\n\t * refresh()统一入口 \n\t * \n\t * @throws BeansException\n\t * @throws IllegalStateException\n\t */\n\t@Override\n\tpublic void refresh() throws BeansException, IllegalStateException {\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\t// Prepare this context for refreshing.\n\t\t\t// 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证\n\t\t\tprepareRefresh();\n\n\t\t\t// Tell the subclass to refresh the internal bean factory.\n\t\t\t// 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t\t\t// Prepare the bean factory for use in this context.\n\t\t\t// 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开\n\t\t\t// 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持\n\t\t\tprepareBeanFactory(beanFactory);\n\n\t\t\ttry {\n\t\t\t\t// Allows post-processing of the bean factory in context subclasses.\n\t\t\t\t// 子类覆盖方法做额外的处理\n\t\t\t\tpostProcessBeanFactory(beanFactory);\n\n\n\t\t\t\t// Invoke factory processors registered as beans in the context.\n\t\t\t\t// 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，\n\t\t\t\t// 并调用其postProcessBeanFactory接口方法\n\t\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t\t\t// Register bean processors that intercept bean creation.\n\t\t\t\t// 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean，\n\t\t\t\t// 并将它们注册到容器Bean后处理器的注册表中，这里只是注册，真正的调用在getBean时候\n\t\t\t\tregisterBeanPostProcessors(beanFactory);\n\n\t\t\t\t// Initialize message source for this context.\n\t\t\t\t// 初始化消息源 初始化容器的国际化消息资源\n\t\t\t\tinitMessageSource();\n\n\t\t\t\t// Initialize event multicaster for this context.\n\t\t\t\t// 初始化应用上下文事件广播器\n\t\t\t\tinitApplicationEventMulticaster();\n\n\t\t\t\t// Initialize other special beans in specific context subclasses.\n\t\t\t\t// 初始化其他特殊的bean，由具体子类实现，这是个钩子方法\n\t\t\t\tonRefresh();\n\n\t\t\t\t// Check for listener beans and register them.\n\t\t\t\t// 注册事件监听器\n\t\t\t\tregisterListeners();\n\n\t\t\t\t// Instantiate all remaining (non-lazy-init) singletons.\n\t\t\t\t// 重点：初始化所有单实例的Bean，使用懒加载模式的bean除外，初始化Bean后将它们放到Spring容器的缓冲池中\n\t\t\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t\t\t// Last step: publish corresponding event.\n\t\t\t\t// 完成刷新并发布容器刷新事件\n\t\t\t\tfinishRefresh();\n\t\t\t}\n    ```\n    * 可以看到注册中心的注册动作是放到最后一步`finishRefresh()`来执行的\n    ```java\n    protected void finishRefresh() {\n        super.finishRefresh();\n        EmbeddedServletContainer localContainer = this.startEmbeddedServletContainer();\n        if (localContainer != null) {\n            // 发布事件\n            this.publishEvent(new EmbeddedServletContainerInitializedEvent(this, localContainer));\n        }\n\n    }\n    ```\n    * 我们跳入`org.springframework.context.event.SimpleApplicationEventMulticaster#multicastEvent()`方法可以看到这里出现了`ConsulAutoServiceRegistration`这个类\n    ![](/images/server/spring/spring-cloud/consul-auto-service.png)\n    * 查看`ConsulAutoServiceRegistration`这个类，我们可以看到这个类实现了`Spring`的很多接口，比如继承了`EventListener`，这里涉及到了事件监听，还有继承了`Lifecycle`，可以猜测`Spirng`容器销毁时用这个接口来向`consul`注销服务，因为这个类比较复杂，所以放到下一章节详细介绍\n    ![](/images/server/spring/spring-cloud/ConsulAutoServiceRegistration.png)\n    * 然后跳到`org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistry#register)`方法，这个方法打印了我们上面的日志\n    ```java\n\t@Override\n\tpublic void register(ConsulRegistration reg) {\n\t\tlog.info(\"Registering service with consul: \" + reg.getService());\n\t\ttry {\n\t\t\tclient.agentServiceRegister(reg.getService(), properties.getAclToken());\n\t\t\tif (heartbeatProperties.isEnabled() && ttlScheduler != null) {\n\t\t\t\tttlScheduler.add(reg.getInstanceId());\n\t\t\t}\n\t\t}\n\t\tcatch (ConsulException e) {\n\t\t\tif (this.properties.isFailFast()) {\n\t\t\t\tlog.error(\"Error registering service with consul: \" + reg.getService(), e);\n\t\t\t\tReflectionUtils.rethrowRuntimeException(e);\n\t\t\t}\n\t\t\tlog.warn(\"Failfast is false. Error registering service with consul: \" + reg.getService(), e);\n\t\t}\n\t}\n    ```\n    * 上面只是些执行流程，下一章节将详细介绍`ConsulAutoServiceRegistration`这个类\n\n### 总结\n* 由于各种自动配置类的作用，`SpringCloudConsul`会在应用启动的时候通过`RESTful HTTP API` 向`consul`注册本地服务信息\n* 通过日志信息定位`ConsulServiceRegistry`类，这个类会进行注册操作，通过断点调试发现是由`ConsulAutoServiceRegistration`这个类来指挥的，这个类比较复杂所以放到下一章节介绍\n\n### 参考\n","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(三)集成Consul源码分析之初始化","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud(三)集成Consul源码分析之初始化/","content":"### 前言\n* 上一章节介绍了`Consul`的一些基本概念，这一章节来介绍`SpringCloud`是怎样集成`Consul`的，按照`SpringBoot`的一贯作法来说这里会有一个`starter pom`\n\n### 简单示例\n\n* 下面来集成`Consul`\n    * 第一步：导入`starter pom`\n    ```xml\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n    </dependency>\n    ```\n    * 第二步：直接启动就可以了，使用起来十分方便\n    ```java\n    /**\n     * @author songsy\n     * @date 2019/8/14 17:43\n     */\n    @SpringCloudApplication\n    public class UserApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(UserApplication.class, args);\n        }\n    \n    }\n    ```\n\n### 解析\n\n* 从上面可以看到要让`SpringCloud`集成`Consul`主要是一个`spring-cloud-starter-consul-discovery`的`Maven`依赖\n\n##### spring-cloud-starter-consul-discovery\n\n* 我们先来看这个`starter`\n\n![](/images/server/spring/spring-cloud/consul11.png)\n\n* 因为是个`starter`，所以我们关注`pom`及`spring.provides`文件\n    * `pom`文件： 可以看到有`spring-cloud-starter-consul`及`spring-cloud-consul-discovery`两个依赖，除此之外还依赖了`spring-cloud-netflix-core`及`spring-cloud-starter-ribbon`，这两个依赖是为了开启负债均衡吧\n    ```xml\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n        <parent>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-consul</artifactId>\n            <version>1.3.2.RELEASE</version>\n            <relativePath>..</relativePath>\n        </parent>\n        <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        <name>Spring Cloud Starter Consul Discovery</name>\n        <description>Spring Cloud Starter Consul Discovery</description>\n        <url>https://projects.spring.io/spring-cloud</url>\n        <organization>\n            <name>Pivotal Software, Inc.</name>\n            <url>https://www.spring.io</url>\n        </organization>\n        <properties>\n            <main.basedir>${basedir}/../..</main.basedir>\n        </properties>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-consul</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-consul-discovery</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-netflix-core</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-ribbon</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <!-- Only needed at compile time -->\n                <scope>provided</scope>\n            </dependency>\n            <dependency>\n                <groupId>joda-time</groupId>\n                <artifactId>joda-time</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n            </dependency>\n        </dependencies>\n    </project>\n\n    ```\n    * `spring.provides`\n    ```xml\n    provides: spring-cloud-consul-discovery\n    ```\n    \n* 我们现在关注`spring-cloud-starter-consul`及`spring-cloud-consul-discovery`这两个依赖\n    * 1、`spring-cloud-starter-consul`，这里核心依赖是`spring-cloud-consul-core`及`com.ecwid.consul:consul-api`，第二包是`consul`依赖包\n        * 打开`pom.xml`\n        ```xml\n        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n            <modelVersion>4.0.0</modelVersion>\n            <parent>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-consul</artifactId>\n                <version>1.3.2.RELEASE</version>\n                <relativePath>..</relativePath>\n            </parent>\n            <artifactId>spring-cloud-starter-consul</artifactId>\n            <name>Spring Cloud Starter Consul</name>\n            <description>Spring Cloud Starter Consul</description>\n            <url>https://projects.spring.io/spring-cloud</url>\n            <organization>\n                <name>Pivotal Software, Inc.</name>\n                <url>https://www.spring.io</url>\n            </organization>\n            <properties>\n                <main.basedir>${basedir}/../..</main.basedir>\n            </properties>\n            <dependencies>\n                <dependency>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-starter-web</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.cloud</groupId>\n                    <artifactId>spring-cloud-commons</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.cloud</groupId>\n                    <artifactId>spring-cloud-context</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.springframework.cloud</groupId>\n                    <artifactId>spring-cloud-consul-core</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>com.ecwid.consul</groupId>\n                    <artifactId>consul-api</artifactId>\n                </dependency>\n                <!-- required by com.ecwid.consul but not as a pom dependency -->\n                <dependency>\n                    <groupId>com.google.code.gson</groupId>\n                    <artifactId>gson</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.apache.httpcomponents</groupId>\n                    <artifactId>httpclient</artifactId>\n                </dependency>\n                <dependency>\n                    <groupId>org.apache.httpcomponents</groupId>\n                    <artifactId>httpcore</artifactId>\n                </dependency>\n            </dependencies>\n        </project>\n        ```\n    * 2、`spring-cloud-consul-discovery`\n        * 先看有什么\n        ![](/images/server/spring/spring-cloud/consul-discovery.png)\n        * `pom`依赖\n        ```xml\n        <modelVersion>4.0.0</modelVersion>\n    \n        <artifactId>spring-cloud-consul-discovery</artifactId>\n        <packaging>jar</packaging>\n        <name>Spring Cloud Consul Discovery</name>\n        <description>Spring Cloud Consul Discovery</description>\n    \n        <parent>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-consul</artifactId>\n            <version>1.3.2.RELEASE</version>\n            <relativePath>..</relativePath>\n        </parent>\n    \n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-configuration-processor</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-consul-core</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-commons</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-context</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-config-client</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-config-server</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>com.ecwid.consul</groupId>\n                <artifactId>consul-api</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <!-- required by com.ecwid.consul but not as a pom dependency -->\n            <dependency>\n                <groupId>com.google.code.gson</groupId>\n                <artifactId>gson</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.apache.httpcomponents</groupId>\n                <artifactId>httpclient</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.apache.httpcomponents</groupId>\n                <artifactId>httpcore</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-netflix-core</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-starter-archaius</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>com.netflix.ribbon</groupId>\n                <artifactId>ribbon</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>com.netflix.ribbon</groupId>\n                <artifactId>ribbon-core</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>com.netflix.ribbon</groupId>\n                <artifactId>ribbon-httpclient</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>com.netflix.ribbon</groupId>\n                <artifactId>ribbon-loadbalancer</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.retry</groupId>\n                <artifactId>spring-retry</artifactId>\n                <optional>true</optional>\n                <exclusions>\n                    <exclusion>\n                        <groupId>org.springframework</groupId>\n                        <artifactId>spring-core</artifactId>\n                    </exclusion>\n                </exclusions>\n            </dependency>\n            <dependency>\n                <groupId>org.projectlombok</groupId>\n                <artifactId>lombok</artifactId>\n                <!-- Only needed at compile time -->\n                <scope>provided</scope>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-test</artifactId>\n                <scope>test</scope>\n            </dependency>\n            <dependency>\n                <groupId>joda-time</groupId>\n                <artifactId>joda-time</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-actuator</artifactId>\n                <optional>true</optional>\n            </dependency>\n        </dependencies>\n        ```\n        * `spring.factories`，这里我们看到了一些自动配置类，这个是`SpringCloud`集成`Consul`的关键\n        ```xml\n        org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n        org.springframework.cloud.consul.discovery.RibbonConsulAutoConfiguration,\\\n        org.springframework.cloud.consul.discovery.configclient.ConsulConfigServerAutoConfiguration,\\\n        org.springframework.cloud.consul.serviceregistry.ConsulAutoServiceRegistrationAutoConfiguration,\\\n        org.springframework.cloud.consul.serviceregistry.ConsulServiceRegistryAutoConfiguration,\\\n        org.springframework.cloud.consul.discovery.ConsulDiscoveryClientConfiguration\n        \n        \n        org.springframework.cloud.bootstrap.BootstrapConfiguration=\\\n        org.springframework.cloud.consul.discovery.configclient.ConsulDiscoveryClientConfigServiceBootstrapConfiguration\n        ```\n        * 其他代码\n\n##### @EnableDiscoveryClient注解\n\n* `@SpringCloudApplication`注解里面可以看到默认有`@EnableDiscoveryClient`注解\n\n```java\n/**\n * @author Spencer Gibb\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableCircuitBreaker\npublic @interface SpringCloudApplication {\n}\n```\n\n* 我们现在看`@EnableDiscoveryClient`注解，查看注释可以知道这个注解开启了就会自动将本地服务注册到相应的注册中心\n\n```java\n/**\n * Annotation to enable a DiscoveryClient implementation.\n * @author Spencer Gibb\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@Import(EnableDiscoveryClientImportSelector.class)\npublic @interface EnableDiscoveryClient {\n\n\t/**\n\t * If true, the ServiceRegistry will automatically register the local server.\n\t */\n\tboolean autoRegister() default true;\n}\n```\n\n* 进入`@Import(EnableDiscoveryClientImportSelector.class)`\n\n![](/images/server/spring/spring-cloud/EnableDiscoveryClientImportSelector.png)\n\n* 可以看到这个类实现了`ImportSelector`接口，我们在之前的`SpringBoot`系列的`@EnableAutoConfiguration自动配置`章节就接触到了这个接口，`ImportSelector`接口的`selectImports`返回的数组（类的全类名）都会被注册到`Spring`容器中，所以可以通过这个方法来自定义注册哪些`bean`\n\n* 从下面代码可以看到`String[]`是只有一个`org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration`类，所以可以得到结果`@EnableDiscoveryClient`注解用于注册`AutoServiceRegistrationConfiguration`这个`Bean`\n\n```java\n@Order(Ordered.LOWEST_PRECEDENCE - 100)\npublic class EnableDiscoveryClientImportSelector\n\t\textends SpringFactoryImportSelector<EnableDiscoveryClient> {\n\n\t@Override\n\tpublic String[] selectImports(AnnotationMetadata metadata) {\n\t\tString[] imports = super.selectImports(metadata);\n\n\t\tAnnotationAttributes attributes = AnnotationAttributes.fromMap(\n\t\t\t\tmetadata.getAnnotationAttributes(getAnnotationClass().getName(), true));\n\n\t\tboolean autoRegister = attributes.getBoolean(\"autoRegister\");\n\n\t\tif (autoRegister) {\n\t\t\tList<String> importsList = new ArrayList<>(Arrays.asList(imports));\n\t\t\timportsList.add(\"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration\");\n\t\t\timports = importsList.toArray(new String[0]);\n\t\t} else {\n\t\t\tEnvironment env = getEnvironment();\n\t\t\tif(ConfigurableEnvironment.class.isInstance(env)) {\n\t\t\t\tConfigurableEnvironment configEnv = (ConfigurableEnvironment)env;\n\t\t\t\tLinkedHashMap<String, Object> map = new LinkedHashMap<>();\n\t\t\t\tmap.put(\"spring.cloud.service-registry.auto-registration.enabled\", false);\n\t\t\t\tMapPropertySource propertySource = new MapPropertySource(\n\t\t\t\t\t\t\"springCloudDiscoveryClient\", map);\n\t\t\t\tconfigEnv.getPropertySources().addLast(propertySource);\n\t\t\t}\n\n\t\t}\n\n\t\treturn imports;\n\t}\n\n\t@Override\n\tprotected boolean isEnabled() {\n\t\treturn new RelaxedPropertyResolver(getEnvironment()).getProperty(\n\t\t\t\t\"spring.cloud.discovery.enabled\", Boolean.class, Boolean.TRUE);\n\t}\n\n\t@Override\n\tprotected boolean hasDefaultFactory() {\n\t\treturn true;\n\t}\n\n}\n```\n\n* 下面我们来关注`org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationConfiguration`，这里是注册了`AutoServiceRegistrationProperties`配置类\n\n```java\n/**\n * @author Spencer Gibb\n */\n@Configuration\n@EnableConfigurationProperties(AutoServiceRegistrationProperties.class)\n@ConditionalOnProperty(value = \"spring.cloud.service-registry.auto-registration.enabled\", matchIfMissing = true)\npublic class AutoServiceRegistrationConfiguration {\n}\n```\n\n\n### 总结\n* `spring-cloud-starter-consul-discovery`利用了`Maven`传递依赖的功能定义了集成`Consul`所需的各种依赖，先备粮草\n* `SpringCloud`集成`Consul`过程就是注册`bean`的过程，具体实现还是通过`spring.factories`、`EnableAutoConfiguration`自动配置来实现的","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(二)注册中心Consul","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud(二)注册中心Consul/","content":"### Consul 介绍\n* `Consul` 是 `HashiCorp` 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，`Consul` 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、`Key/Value` 存储、多数据中心方案，不再需要依赖其它工具（比如 `ZooKeeper` 等）。\n\n* 使用起来也较 为简单。`Consul` 使用 Go 语言编写，因此具有天然可移植性(支持`Linux、windows`和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。\n\n#### Consul 基础概念\n* `Agent`: agent 就是实际运行的 consul 服务，启动时可选以 server 或者 client 模式运行，每个集群至少有 1 个 server，由于使用了 Raft 算法，所以对于每个集群你应该把它的 server 数设置成 3 或 5 个。\n    * `Server`: 核心的 consul 服务，存储了所有服务注册的信息，响应查询操作，跨数据中心通信等。\n    * `Client`: 用来在集群中每个机器上运行，进行服务注册 / 健康检查的进程。\n* `Cluster`: 集群，由多台共同提供服务的机器组成的集合称为集群，agent 在集群的每个成员上都要运行。\n* `DataCenter`: 数据中心。consul 支持跨数据中心组成集群。\n* `Node`: 安装了 agent，接入集群的机器称为 node。\n* `Service`: 你的服务，即服务注册和服务发现之类操作的对象。通过提供 config 文件或者调用 consul 的 HTTP API 来定义一个服务。\n\n#### Consul 角色 \n\n`client`: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。\n\n`server`: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 server 数量推荐为 3 个或是 5 个。\n\n\n#### Consul 模式\n\n* `CLIENT`：表示`consul`的`client`模式，就是客户端模式。是`consul`节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。\n\n* `SERVER`：表示`consul`的`server`模式，表明这个`consul`是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。\n\n* `SERVER-LEADER`：中间那个`SERVER`下面有`LEADER`的字眼，表明这个`SERVER`是它们的老大，它和其它`SERVER`不一样的一点是，它需要负责同步注册的信息给其它的`SERVER`，同时也要负责各个节点的健康监测。\n\n* 其它信息：其它信息包括它们之间的通信方式，还有一些协议信息，算法。它们是用于保证节点之间的数据同步，实时性要求等等一系列集群问题的解决。这些有兴趣的自己看看官方文档。\n\n\n#### Consul 基本使用\n\n##### 启动consul\n\n* 启动节点1（server模式）\n    * -node：节点的名称 \n    * -bind：绑定的一个地址，用于节点之间通信的地址，可以是内外网，必须是可以访问到的地址 \n    * -server：这个就是表示这个节点是个SERVER \n    * -bootstrap-expect：这个就是表示期望提供的SERVER节点数目，数目一达到，它就会被激活，然后就是LEADER了\n\n```\nconsul agent -server -bind=172.17.0.2  -bootstrap-expect=3 -node=node1\n```\n\n* 启动节点2-3（server模式）\n    * -join：这个表示启动的时候，要加入到哪个集群内，这里就是说要加入到节点1的集群 \n    * -node-id：这个貌似版本8才加入的，这里用这个来指定唯一的节点ID，可以查看这个issue \n    * -client：这个表示注册或者查询等一系列客户端对它操作的IP，如果不指定这个IP，默认是127.0.0.1。\n\n```java\nconsul agent -server -bind=172.17.0.3  -join=172.17.0.2 -node-id=$(uuidgen | awk '{print tolower($0)}')  -node=node2\n```\n\n* 启动节点4（client模式）\n    * 除了没有-server，其它都是一样的，没有这个就说明这个节点是CLIENT\n```java\nconsul agent -bind=172.17.0.5 -retry-join=172.17.0.2 -node-id=$(uuidgen | awk '{print tolower($0)}')  -node=node4\n```\n\n* Consul集群 \n    * `consul members`查看下集群的状态\n        * 4个节点都列出来了。Status表示它们的状态，都是alive。Type表示它们的类型，三个SERVER一个CLIENT，和我们之前启动的一样。DC表示数据中心，都是dc1。\n    * `consul join 10.201.102.198` 加入集群\n\n\n![](/images/server/spring/spring-cloud/consul-members.png)\n\n* Consul同时提供了一个漂亮的功能齐全的WEB界面,开箱即用.界面可以用来查看所有的节点,可以查看健康检查和他们的当前状态.可以读取和设置K/V 存储的数据，启动完成之后就可以使用`http://127.0.0.1:8500`来查询服务状态，有界面查看还是挺人性化的\n\n![](/images/server/spring/spring-cloud/consul-dc.jpg)\n\n* 节点异常consul的处理\n    * LEADER 挂了 \n        * leader挂了，consul会重新选取出新的leader，只要超过一半的SERVER还活着，集群是可以正常工作的。node1是leader，所以把这个容器停了。\n        * 日志打印，心跳检查node1的ip超时，接着开始选举。node2被选举为新的leader\n\n##### 使用consul\n\n* 操作 `Consul` 有 `Commands` 和 `RESTful HTTP API` 两种方式，具体详情可以到[官网API链接](https://www.consul.io/api/index.html)里查看，使用起来十分方便\n\n* 注册服务\n\n```\nPUT http://127.0.0.1:8500/v1/agent/service/register\n\n{\n  \"ID\": \"userServiceId1\",  //服务id\n  \"Name\": \"userServiceName1\", //服务名\n  \"Tags\": [              //服务的tag，自定义，可以根据这个tag来区分同一个服务名的服务\n    \"userService1\",\n    \"v1\"\n  ],\n  \"Address\": \"127.0.0.1\",//服务注册到consul的IP，服务发现，发现的就是这个IP\n  \"Port\": 8000,          //服务注册consul的PORT，发现的就是这个PORT\n  \"EnableTagOverride\": false,\n  \"Check\": {             //健康检查部分\n    \"DeregisterCriticalServiceAfter\": \"90m\",\n    \"HTTP\": \"http://www.baidu.com\", //指定健康检查的URL，调用后只要返回20X，consul都认为是健康的\n    \"Interval\": \"10s\"   //健康检查间隔时间，每隔10s，调用一次上面的URL\n  }\n}\n```\n\n* 下架服务\n\n> Sample Request\n\n```\nPUT  http://127.0.0.1:8500/v1/catalog/service/{serviceId}\n```\n\n> Sample Response\n\n```java\nstatus 200 ok\n```\n\n\n* 查看所有的服务\n\n> Sample Request\n\n```\nGET http://127.0.0.1:8500/v1/agent/services\n```\n\n> Sample Response\n\n```\n{\n    \"userServiceId1\": {\n        \"Kind\": \"\",\n        \"ID\": \"userServiceId1\",\n        \"Service\": \"userServiceName1\",\n        \"Tags\": [\n            \"userService1\",\n            \"v1\"\n        ],\n        \"Meta\": {},\n        \"Port\": 8001,\n        \"Address\": \"127.0.0.1\",\n        \"EnableTagOverride\": false,\n        \"CreateIndex\": 0,\n        \"ModifyIndex\": 0,\n        \"ProxyDestination\": \"\",\n        \"Connect\": null\n    },\n    \"userServiceId2\": {\n        \"Kind\": \"\",\n        \"ID\": \"userServiceId2\",\n        \"Service\": \"userServiceName2\",\n        \"Tags\": [\n            \"userService2\",\n            \"v1\"\n        ],\n        \"Meta\": {},\n        \"Port\": 8001,\n        \"Address\": \"127.0.0.1\",\n        \"EnableTagOverride\": false,\n        \"CreateIndex\": 0,\n        \"ModifyIndex\": 0,\n        \"ProxyDestination\": \"\",\n        \"Connect\": null\n    },\n    \"userServiceId3\": {\n        \"Kind\": \"\",\n        \"ID\": \"userServiceId3\",\n        \"Service\": \"userServiceName3\",\n        \"Tags\": [\n            \"userService3\",\n            \"v1\"\n        ],\n        \"Meta\": {},\n        \"Port\": 8001,\n        \"Address\": \"127.0.0.1\",\n        \"EnableTagOverride\": false,\n        \"CreateIndex\": 0,\n        \"ModifyIndex\": 0,\n        \"ProxyDestination\": \"\",\n        \"Connect\": null\n    }\n}\n```\n\n* 查看某个服务\n\n> Sample Request\n\n```\nGET  http://127.0.0.1:8500/v1/catalog/service/{serviceName}\n```\n\n> Sample Response\n\n```\n[\n    {\n        \"ID\": \"3c1b78a3-701a-2625-f617-94cade896b47\",\n        \"Node\": \"DESKTOP-DT6DIHG\",\n        \"Address\": \"127.0.0.1\",\n        \"Datacenter\": \"dc1\",\n        \"TaggedAddresses\": {\n            \"lan\": \"127.0.0.1\",\n            \"wan\": \"127.0.0.1\"\n        },\n        \"NodeMeta\": {\n            \"consul-network-segment\": \"\"\n        },\n        \"ServiceKind\": \"\",\n        \"ServiceID\": \"userServiceId1\",\n        \"ServiceName\": \"userServiceName1\",\n        \"ServiceTags\": [\n            \"userService1\",\n            \"v1\"\n        ],\n        \"ServiceAddress\": \"127.0.0.1\",\n        \"ServiceMeta\": {},\n        \"ServicePort\": 8001,\n        \"ServiceEnableTagOverride\": false,\n        \"ServiceProxyDestination\": \"\",\n        \"ServiceConnect\": {\n            \"Native\": false,\n            \"Proxy\": null\n        },\n        \"CreateIndex\": 3220,\n        \"ModifyIndex\": 3220\n    }\n]\n```\n\n* KV Store 存值\n\n* 列出所有节点\n\n```java\nGET http://consul.rocks/v1/catelog/nodes\n```\n\n\n#### Consul 工作原理\n\n![logo](/images/server/spring/spring-cloud/consul1.png)\n\n* 1、当 `Producer` 启动的时候，会向 `Consul` 发送一个 `post` 请求，告诉 `Consul` 自己的 `IP` 和 `Port`\n* 2、`Consul` 接收到 `Producer` 的注册后，每隔`10s`（默认）会向 `Producer` 发送一个健康检查的请求，检验`Producer`是否健康\n* 3、当 `Consumer` 发送 `GET` 方式请求 `/api/address` 到 `Producer` 时，会先从 `Consul` 中拿到一个存储服务 `IP` 和 `Port` 的临时表，从表中拿到 `Producer` 的 `IP` 和 `Port` 后再发送 `GET` 方式请求 `/api/address`\n* 4、该临时表每隔`10s`会更新，只包含有通过了健康检查的 `Producer`\n\n\n#### Consul 的优势\n* 使用 `Raft` 算法来保证一致性, 比复杂的 `Paxos` 算法更直接. 相比较而言, `zookeeper` 采用的是 `Paxos`, 而 `etcd` 使用的则是 `Raft`。\n* 支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。` zookeeper `和 `etcd` 均不提供多数据中心功能的支持。\n* 支持健康检查。 `etcd` 不提供此功能。\n* 支持 `http` 和 `dns` 协议接口。 `zookeeper` 的集成较为复杂, `etcd` 只支持 `http` 协议。\n* 官方提供 `web` 管理界面, `etcd` 无此功能。\n* 综合比较, `Consul` 作为服务注册和配置管理的新星, 比较值得关注和研究。\n\n### 其他\n* `consul` 默认使用下列端口\n    * 8300(tcp): Server RPC，server 用于接受其他 agent 的请求\n    * 8301(tcp,udp): Serf LAN，数据中心内 gossip 交换数据用\n    * 8302(tcp,udp): Serf WAN，跨数据中心 gossip 交换数据用\n    * 8400(tcp): CLI RPC，接受命令行的 RPC 调用\n    * 8500(tcp): HTTP API 及 Web UI\n    * 8600(tcp udp): DNS 服务，可以把它配置到 53 端口来响应 dns 请求\n* 测试开发环境下可以使用`consul agent -dev`来启动`consul`，该模式下（该节点的启动不能用于生产环境，因为该模式下不会持久化任何状态），该启动模式仅仅是为了快速便捷的启动单节点`consul`，该节点处于`server`模式且是`leader`\n\n### 参考\n* 官网：https://www.consul.io\n* https://www.cnblogs.com/xiaohanlin/p/8016803.html\n* https://farer.org/2018/05/17/consul-notes/\n* 参考：http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(一)服务治理Eureka","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud(一)服务治理Eureka/","content":"\n### 前言\n\n#### 什么是 Eureka\n\n* `Eureka`是`Netflix`开发的服务发现框架，本身是一个基于`REST`的服务，主要用于定位运行在`AWS`域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。`SpringCloud`将它集成在其子项目`spring-cloud-netflix`中，以实现`SpringCloud`的服务发现功能。\n\n![](/images/server/spring/spring-cloud/eureka1.png)\n\n### 解析\n\n#### 服务发现\n\n* 服务发现就像聊天室一个,每个用户来的时候去服务器上注册,这样他的好友们就能看到你,你同时也将获取好友的上线列表.在微服务中,服务就相当于聊天室的用户,而服务注册中心就像聊天室服务器一样。\n\n* 目前服务发现的解决方案有`Eureka,Consul,Etcd,Zookeeper,SmartStack`等等\n\n* `Eureka Client`通过`HTTP`(或者`TCP,UDP`)去`Eureka Server`册和获取服务列表,为了高可用一般会有多个\n\n* `Eureka Server`可以组成集群，`Eureka`会移除那些心跳检查未到达的服务.\n\n\n### 其他\n\n* 因为此组件官方没有在维护了，所以在此没有更多研究，可以参考其他解决方案比如`Consul`","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringCloud(零)SpringCloudNetflix","url":"/2019/08/07/backend/framework/spring/spring-cloud/SpringCloud(零)SpringCloudNetflix/","content":"\n### Spring Cloud\n\n* `Spring Cloud`是一系列框架的有序集合。它利用`Spring Boot`的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用`Spring Boot`的开发风格做到一键启动和部署。\n\n* `Spring Cloud`并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过`Spring Boot`风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。\n\n#### Spring Cloud组成\n\n* `Spring Cloud`的子项目，大致可分成两类，对于我们想快速实践微服务的开发者来说，第一类子项目就已经足够使用\n    * 第一类是对现有成熟框架`Spring Boot`的封装和抽象，比如对`Netflix`服务组件的封装，也是数量最多的项目\n    * 第二类是开发了一部分分布式系统的基础设施的实现，如`Spring Cloud Stream`扮演的就是`kafka, ActiveMQ`这样的角色\n\n#### Spring Cloud Netflix\n\n* `SpringCloud`下包含了多个工程，其中的`Spring Cloud Netflix`提供了一系列搭建微服务基础架构的功能组件，`Netflix`的部分组件及功能特性如下：\n    * `Eureka`（服务注册与发现框架）：一个基于`REST`风格的服务组件，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移\n    * `Hystrix`（服务容错组件）：容错管理工具，旨在通过控制服务和第三方库的节点，从而对延迟和故障提供强大的容村能力\n    * `Zuul`（服务网关）：边缘服务工具，提供动态路由、监控、贪心、安全等边缘服务\n    * `Ribbon`（客户端负载均衡器）：提供客户端负载均衡算法，将`Netflix`的中间层服务连接起来\n    * `Feign`（声明式HTTP客户端）：可以创建声明式、模板化的`HTTP`客户端，进行微服务调用\n\n* 下面的章节将详细介绍这些`Spring Cloud Netflix`组件\n\n### 总结\n* 专人做专事，`Spring Cloud`并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，提供了标准化的、全站式的技术方案\n\n\n### 参考 \n* 官网传送：https://spring.io/projects/spring-cloud\n* 百度百科 https://baike.baidu.com/item/spring%20cloud/20269825?fr=aladdin","tags":["Spring Cloud"],"categories":["server"]},{"title":"SpringBoot(七)内嵌Tomcat启动原理解析","url":"/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(七)内嵌Tomcat启动原理解析/","content":"## 前言\n\n* 我们知道在使用`Spring Boot`项目的时候可以不用依赖外部`Tomcat`就可以启动，那么`Spring Boot`是怎么做到的呢？其实就是只需要引入`spring-boot-starter-web`，在应用启动时会自动启动嵌入版的`tomcat`作为应用服务器，下面我们来学习下其实现原理。\n\n## 解析\n\n#### TomcatEmbeddedServletContainerFactory 自动配置\n\n* 嵌入版的`tomcat`起作用的关键是`TomcatEmbeddedServletContainerFactory`，下面将讲解该类的注册\n\n* 第四章节已经介绍了自动配置的实现，查看`spring-boot-autoconfigure`模块的`META-INF/spring.factories`文件，关注`EmbeddedServletContainerAutoConfiguration`这个配置类，看类名可以翻译为嵌入式的`Servlet`容器自动配置类，所以以后如果想知道其他功能是怎么被集成进来的，可以在`spring.factories`中找找对应的自动配置类\n\n```java\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n... \norg.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\\n...\norg.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration\n```\n\n* 进入`EmbeddedServletContainerAutoConfiguration.java`，可以看到使用不同的`@Conditional`注解可以针对不同的环境情况选择注册不同的`Bean`，下面根据条件会注册不同的`Servlet`容器\n    * 注册`Tomcat`容器工厂\n    * 注册`Jetty`容器工厂\n    * 注册`Undertow`容器工厂\n\n```java\n/**\n * 嵌入式的`Servlet`容器自动配置类\n *\n * {@link EnableAutoConfiguration Auto-configuration} for an embedded servlet containers.\n *\n * @author Phillip Webb\n * @author Dave Syer\n * @author Ivan Sopov\n * @author Stephane Nicoll\n */\n@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)\n@Configuration\n@ConditionalOnWebApplication // 注解表明只有在web环境下才会创建容器相关信息，因此应用无需容器则使用\n@Import(BeanPostProcessorsRegistrar.class)\npublic class EmbeddedServletContainerAutoConfiguration {\n\n\t/**\n\t * 注册Tomcat容器工厂\n\t * 由于存在@ConditionalOnMissingBean注解，因此优先使用用户自定义的EmbeddedServletContainerFactory\n\t *\n\t * Nested configuration if Tomcat is being used.\n\t */\n\t@Configuration\n\t@ConditionalOnClass({ Servlet.class, Tomcat.class })\n\t@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\n\tpublic static class EmbeddedTomcat {\n\n\t\t@Bean\n\t\tpublic TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() {\n\t\t\treturn new TomcatEmbeddedServletContainerFactory();\n\t\t}\n\n\t}\n\n\t/**\n\t * 注册Jetty容器工厂\n\t *\n\t * Nested configuration if Jetty is being used.\n\t */\n\t@Configuration\n\t@ConditionalOnClass({ Servlet.class, Server.class, Loader.class,\n\t\t\tWebAppContext.class })\n\t@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\n\tpublic static class EmbeddedJetty {\n\n\t\t@Bean\n\t\tpublic JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() {\n\t\t\treturn new JettyEmbeddedServletContainerFactory();\n\t\t}\n\n\t}\n\n\t/**\n\t * 注册Undertow容器工厂\n\t *\n\t * Nested configuration if Undertow is being used.\n\t */\n\t@Configuration\n\t@ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })\n\t@ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)\n\tpublic static class EmbeddedUndertow {\n\n\t\t@Bean\n\t\tpublic UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() {\n\t\t\treturn new UndertowEmbeddedServletContainerFactory();\n\t\t}\n\n\t}\n\n\t/**\n\t * Registers a {@link EmbeddedServletContainerCustomizerBeanPostProcessor}. Registered\n\t * via {@link ImportBeanDefinitionRegistrar} for early registration.\n\t */\n\tpublic static class BeanPostProcessorsRegistrar\n\t\t\timplements ImportBeanDefinitionRegistrar, BeanFactoryAware {\n\n\t\tprivate ConfigurableListableBeanFactory beanFactory;\n\n\t\t@Override\n\t\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\t\tif (beanFactory instanceof ConfigurableListableBeanFactory) {\n\t\t\t\tthis.beanFactory = (ConfigurableListableBeanFactory) beanFactory;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,\n\t\t\t\tBeanDefinitionRegistry registry) {\n\t\t\tif (this.beanFactory == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tregisterSyntheticBeanIfMissing(registry,\n\t\t\t\t\t\"embeddedServletContainerCustomizerBeanPostProcessor\",\n\t\t\t\t\tEmbeddedServletContainerCustomizerBeanPostProcessor.class);\n\t\t\tregisterSyntheticBeanIfMissing(registry,\n\t\t\t\t\t\"errorPageRegistrarBeanPostProcessor\",\n\t\t\t\t\tErrorPageRegistrarBeanPostProcessor.class);\n\t\t}\n\n\t\tprivate void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry,\n\t\t\t\tString name, Class<?> beanClass) {\n\t\t\tif (ObjectUtils.isEmpty(\n\t\t\t\t\tthis.beanFactory.getBeanNamesForType(beanClass, true, false))) {\n\t\t\t\tRootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass);\n\t\t\t\tbeanDefinition.setSynthetic(true);\n\t\t\t\tregistry.registerBeanDefinition(name, beanDefinition);\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n```\n\n* 我们这里关注`TomcatEmbeddedServletContainerFactory`类，下面是类继承关系图：\n\n![](/images/server/spring/spring-boot/TomcatEmbeddedServletContainerFactory.png)\n\n* `TomcatEmbeddedServletContainerFactory`类\n\n```java\npublic class TomcatEmbeddedServletContainerFactory extends AbstractEmbeddedServletContainerFactory implements ResourceLoaderAware {\n\n\tprivate static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n\n\tprivate static final Set<Class<?>> NO_CLASSES = Collections.emptySet();\n\n\t/**\n\t * The class name of default protocol used.\n\t */\n\tpublic static final String DEFAULT_PROTOCOL = \"org.apache.coyote.http11.Http11NioProtocol\";\n\n\tprivate File baseDirectory;\n\n\tprivate List<Valve> engineValves = new ArrayList<Valve>();\n\n\tprivate List<Valve> contextValves = new ArrayList<Valve>();\n\n\tprivate List<LifecycleListener> contextLifecycleListeners = new ArrayList<LifecycleListener>();\n\n\tprivate List<TomcatContextCustomizer> tomcatContextCustomizers = new ArrayList<TomcatContextCustomizer>();\n\n\tprivate List<TomcatConnectorCustomizer> tomcatConnectorCustomizers = new ArrayList<TomcatConnectorCustomizer>();\n\n\tprivate List<Connector> additionalTomcatConnectors = new ArrayList<Connector>();\n\n\tprivate ResourceLoader resourceLoader;\n\n\tprivate String protocol = DEFAULT_PROTOCOL;\n\n\tprivate Set<String> tldSkipPatterns = new LinkedHashSet<String>(\n\t\t\tTldSkipPatterns.DEFAULT);\n\n\tprivate Charset uriEncoding = DEFAULT_CHARSET;\n\n\tprivate int backgroundProcessorDelay;\n\n\t/**\n\t * Create a new {@link TomcatEmbeddedServletContainerFactory} instance.\n\t */\n\tpublic TomcatEmbeddedServletContainerFactory() {\n\t\tsuper();\n\t}\n\n\t/**\n\t * Create a new {@link TomcatEmbeddedServletContainerFactory} that listens for\n\t * requests using the specified port.\n\t * @param port the port to listen on\n\t */\n\tpublic TomcatEmbeddedServletContainerFactory(int port) {\n\t\tsuper(port);\n\t}\n\n\t/**\n\t * Create a new {@link TomcatEmbeddedServletContainerFactory} with the specified\n\t * context path and port.\n\t * @param contextPath the root context path\n\t * @param port the port to listen on\n\t */\n\tpublic TomcatEmbeddedServletContainerFactory(String contextPath, int port) {\n\t\tsuper(contextPath, port);\n\t}\n\n\t/**\n\t * 获取EmbeddedServletContainer\n\t * \n\t * @param initializers {@link ServletContextInitializer}s that should be applied as\n\t * the container starts\n\t * @return\n\t */\n\t@Override\n\tpublic EmbeddedServletContainer getEmbeddedServletContainer(\n\t\t\tServletContextInitializer... initializers) {\n\t\t// 构建Tomcat实例\n\t\tTomcat tomcat = new Tomcat();\n\t\t// 配置Tomcat的基本环境\n\t\tFile baseDir = (this.baseDirectory != null ? this.baseDirectory\n\t\t\t\t: createTempDir(\"tomcat\"));\n\t\ttomcat.setBaseDir(baseDir.getAbsolutePath());\n\t\tConnector connector = new Connector(this.protocol);\n\t\ttomcat.getService().addConnector(connector);\n\t\tcustomizeConnector(connector);\n\t\ttomcat.setConnector(connector);\n\t\ttomcat.getHost().setAutoDeploy(false);\n\t\tconfigureEngine(tomcat.getEngine());\n\t\tfor (Connector additionalConnector : this.additionalTomcatConnectors) {\n\t\t\ttomcat.getService().addConnector(additionalConnector);\n\t\t}\n\t\tprepareContext(tomcat.getHost(), initializers);\n\t\t// 将配置好的Tomcat传入进去。返回一个EmbeddedServletContainer 并且启动tomcat容器\n\t\treturn getTomcatEmbeddedServletContainer(tomcat);\n\t}\n\t\n\t...\n```\n\n* `TomcatEmbeddedServletContainerFactory`类，这个类是创建`Tomcat`容器的工厂类，可以看到这个类实现了`EmbeddedServletContainerFactory`接口\n    * 查看`EmbeddedServletContainerFactory`接口，该接口只有一个方法，该方法用于获取`Servlet`容器（`EmbeddedServletContainer`）\n        ```java\n        public interface EmbeddedServletContainerFactory {\n            EmbeddedServletContainer getEmbeddedServletContainer(\n                    ServletContextInitializer... initializers); \n        }\n        ```\n    * `TomcatEmbeddedServletContainerFactory`类实现了`getEmbeddedServletContainer()`方法，可以看到`Tomcat tomcat = new Tomcat()`是创建了一个汤姆猫，然后构造为`EmbeddedServletContainer`对象\n        ```java\n        /**\n         * 获取EmbeddedServletContainer\n         * \n         * @param initializers {@link ServletContextInitializer}s that should be applied as\n         * the container starts\n         * @return\n         */\n        @Override\n         public EmbeddedServletContainer getEmbeddedServletContainer(\n                ServletContextInitializer... initializers) {\n            // 构建Tomcat实例\n            Tomcat tomcat = new Tomcat();\n            // 配置Tomcat的基本环境\n            File baseDir = (this.baseDirectory != null ? this.baseDirectory\n                    : createTempDir(\"tomcat\"));\n            tomcat.setBaseDir(baseDir.getAbsolutePath());\n            Connector connector = new Connector(this.protocol);\n            tomcat.getService().addConnector(connector);\n            customizeConnector(connector);\n            tomcat.setConnector(connector);\n            tomcat.getHost().setAutoDeploy(false);\n            configureEngine(tomcat.getEngine());\n            for (Connector additionalConnector : this.additionalTomcatConnectors) {\n                tomcat.getService().addConnector(additionalConnector);\n            }\n            prepareContext(tomcat.getHost(), initializers);\n            // 将配置好的Tomcat传入进去。返回一个EmbeddedServletContainer 并且启动tomcat容器\n            return getTomcatEmbeddedServletContainer(tomcat);\n        }\n        ```\n    * 查看`EmbeddedServletContainer`接口，该接口是`Servlet`容器的抽象，可以看到有三个方法，`start()` `stop()` `getPort();`\n        ```java\n        public interface EmbeddedServletContainer {\n        \n            /**\n             * 启动容器\n             *\n             * Starts the embedded servlet container. Calling this method on an already started\n             * container has no effect.\n             * @throws EmbeddedServletContainerException if the container cannot be started\n             */\n            void start() throws EmbeddedServletContainerException;\n        \n            /**\n             * 停止容器\n             *\n             * Stops the embedded servlet container. Calling this method on an already stopped\n             * container has no effect.\n             * @throws EmbeddedServletContainerException if the container cannot be stopped\n             */\n            void stop() throws EmbeddedServletContainerException;\n        \n            /**\n             * 获取服务端口\n             *\n             * Return the port this server is listening on.\n             * @return the port (or -1 if none)\n             */\n            int getPort(); \n        }\n        ```\n    * 下图是显示了`Spring Boot`定义了哪些容器\n        * `UndertowEmbeddedServletContainer` (org.springframework.boot.context.embedded.undertow)\n        * `MockEmbeddedServletContainer` (org.springframework.boot.context.embedded)\n        * `TomcatEmbeddedServletContainer` (org.springframework.boot.context.embedded.tomcat)\n        * `JettyEmbeddedServletContainer` (org.springframework.boot.context.embedded.jetty)\n* `EmbeddedServletContainer.java`\n\n![](/images/server/spring/spring-boot/EmbeddedServletContainer.png)\n\n* 到这里`TomcatEmbeddedServletContainerFactory`已经自动注册完成了，使用`@Conditional`相关注解可以控制只有在web环境下才会创建容器相关信息，有了容器的创建工厂之后就可以使用`Servlet`容器了`EmbeddedServletContainer`\n\n#### TomcatEmbeddedServletContainer 创建\n\n* 由上面可以知道`TomcatEmbeddedServletContainer`的创建是由`TomcatEmbeddedServletContainerFactory`类的`getEmbeddedServletContainer()`方法来实现的，从下面``private final Tomcat tomcat;``可以看到我们的`Tomcat`猫\n\n```java\npublic class TomcatEmbeddedServletContainer implements EmbeddedServletContainer {\n\n\tprivate static final Log logger = LogFactory.getLog(TomcatEmbeddedServletContainer.class);\n\n\tprivate static final AtomicInteger containerCounter = new AtomicInteger(-1);\n\n\tprivate final Object monitor = new Object();\n\n\tprivate final Map<Service, Connector[]> serviceConnectors = new HashMap<Service, Connector[]>();\n\n\t// Tomcat猫\n\tprivate final Tomcat tomcat;\n\n\tprivate final boolean autoStart;\n\n\tprivate volatile boolean started;\n\n\t/**\n\t * Create a new {@link TomcatEmbeddedServletContainer} instance.\n\t * @param tomcat the underlying Tomcat server\n\t */\n\tpublic TomcatEmbeddedServletContainer(Tomcat tomcat) {\n\t\tthis(tomcat, true);\n\t}\n\n\t/**\n\t * Create a new {@link TomcatEmbeddedServletContainer} instance.\n\t * @param tomcat the underlying Tomcat server\n\t * @param autoStart if the server should be started\n\t */\n\tpublic TomcatEmbeddedServletContainer(Tomcat tomcat, boolean autoStart) {\n\t\tAssert.notNull(tomcat, \"Tomcat Server must not be null\");\n\t\tthis.tomcat = tomcat;\n\t\tthis.autoStart = autoStart;\n\t\t// 启动容器\n\t\tinitialize();\n\t}\n\n\tprivate void initialize() throws EmbeddedServletContainerException {\n\t\tTomcatEmbeddedServletContainer.logger\n\t\t\t\t.info(\"Tomcat initialized with port(s): \" + getPortsDescription(false));\n\t\tsynchronized (this.monitor) {\n\t\t\ttry {\n\t\t\t\taddInstanceIdToEngineName();\n\t\t\t\ttry {\n\t\t\t\t\t// Remove service connectors to that protocol binding doesn't happen\n\t\t\t\t\t// yet\n\t\t\t\t\tremoveServiceConnectors();\n\n\t\t\t\t\t// Start the server to trigger initialization listeners\n\t\t\t\t\t// 启动 Tomcat\n\t\t\t\t\tthis.tomcat.start();\n\n\t\t\t\t\t// We can re-throw failure exception directly in the main thread\n\t\t\t\t\trethrowDeferredStartupExceptions();\n\n\t\t\t\t\tContext context = findContext();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tContextBindings.bindClassLoader(context, getNamingToken(context),\n\t\t\t\t\t\t\t\tgetClass().getClassLoader());\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NamingException ex) {\n\t\t\t\t\t\t// Naming is not enabled. Continue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Unlike Jetty, all Tomcat threads are daemon threads. We create a\n\t\t\t\t\t// blocking non-daemon to stop immediate shutdown\n\t\t\t\t\tstartDaemonAwaitThread();\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tcontainerCounter.decrementAndGet();\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new EmbeddedServletContainerException(\n\t\t\t\t\t\t\"Unable to start embedded Tomcat\", ex);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t... \n```\n\n#### TomcatEmbeddedServletContainer 使用\n\n* 有了`TomcatServletContainer`之后就需要启动了，那么`Spring Boot`是哪里触发调用的呢，可以在`TomcatEmbeddedServletContainer`的`initialize()`方法里打个断点\n\n![](/images/server/spring/spring-boot/tomcat1.png)\n\n* 打好断点之后就是启动`Spring Boot`项目了，由下图可以看到是从`ApplicationContext`的`refresh()`开始触发的\n\n![](/images/server/spring/spring-boot/tomcat2.png)\n\n* 现在我们从`main`方法开始一步步跟进\n    * 1、`main`方法开始\n    ```java\n    public static void main(String[] args) throws Exception {\n        SpringApplication.run(SampleTomcatJspApplication.class, args);\n    }\n\tpublic static ConfigurableApplicationContext run(Object[] sources, String[] args) {\n\t\t// 创建 SpringApplication 对象，并执行运行。\n\t\treturn new SpringApplication(sources).run(args);\n\t}\n    ```\n    * 2、进入`org.springframework.boot.SpringApplication#run(java.lang.String...)`方法，由之前的第三章节可以知道这里我们的到的`ApplicationContext`实现类是`AnnotationConfigEmbeddedWebApplicationContext`，看名字可以知道这个类是基于注解配置的嵌入式Web应用容器\n    ```java\n\tpublic ConfigurableApplicationContext run(String... args) {\n\t\t//  创建 StopWatch 对象，并启动。StopWatch 主要用于简单统计 run 启动过程的时长。\n\t\tStopWatch stopWatch = new StopWatch();\n\t\tstopWatch.start();\n\t\tConfigurableApplicationContext context = null;\n\t\tFailureAnalyzers analyzers = null;\n\t\t// 配置 headless 属性，这个逻辑，可以无视，和 AWT 相关。\n\t\tconfigureHeadlessProperty();\n\t\t// 获得 SpringApplicationRunListener 的数组，并启动监听\n\t\tSpringApplicationRunListeners listeners = getRunListeners(args);\n\t\tlisteners.starting();\n\t\ttry {\n\t\t\t// 创建  ApplicationArguments 对象\n\t\t\tApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n\t\t\t// 加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 application.properties 和外部的属性配置。\n\t\t\tConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n\t\t\t// 打印 Spring Banner\n\t\t\tBanner printedBanner = printBanner(environment);\n\t\t\t// 创建 Spring 容器。\n\t\t\tcontext = createApplicationContext();\n\t\t\tanalyzers = new FailureAnalyzers(context);\n\t\t\t// 主要是调用所有初始化类的 initialize 方法\n\t\t\tprepareContext(context, environment, listeners, applicationArguments, printedBanner);\n\t\t\t// 初始化 Spring 容器。\n\t\t\trefreshContext(context);\n    ```\n    * 3、进入`refreshContext(context);`方法，下面可以看到是调用了`refresh(context);`方法\n    ```java\n\tprivate void refreshContext(ConfigurableApplicationContext context) {\n\t\t// 开启（刷新）Spring 容器\n\t\trefresh(context);\n\t\t// 注册 ShutdownHook 钩子\n\t\tif (this.registerShutdownHook) {\n\t\t\ttry {\n\t\t\t\tcontext.registerShutdownHook();\n\t\t\t}\n\t\t\tcatch (AccessControlException ex) {\n\t\t\t\t// Not allowed in some environments.\n\t\t\t}\n\t\t}\n\t}\n    ```\n    * 4、一直跳入可以发现进入到了`org.springframework.boot.context.embedded.EmbeddedWebApplicationContext#onRefresh`方法，`EmbeddedWebApplicationContext`重写了`onRefresh()`方法，在调父类`super.onRefresh();`方法之后又调用了`createEmbeddedServletContainer();`方法用于创建及启动容器\n    ```java\n\t@Override\n\tprotected void onRefresh() {\n\t\tsuper.onRefresh();\n\t\ttry {\n\t\t\t// 创建及启动容器\n\t\t\tcreateEmbeddedServletContainer();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new ApplicationContextException(\"Unable to start embedded container\",\n\t\t\t\t\tex);\n\t\t}\n\t}\n    ```\n    * 5、进入`createEmbeddedServletContainer()`方法可以看到通过`org.springframework.boot.context.embedded.EmbeddedServletContainerFactory#getEmbeddedServletContainer()`方法来创建了`EmbeddedServletContainer`，到现在就是和之前的内容联系起来了\n    ```java\n\tprivate void createEmbeddedServletContainer() {\n\t\tEmbeddedServletContainer localContainer = this.embeddedServletContainer;\n\t\tServletContext localServletContext = getServletContext();\n\t\tif (localContainer == null && localServletContext == null) {\n\t\t\tEmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();\n\t\t\t// 获取EmbeddedServletContainer\n\t\t\tthis.embeddedServletContainer = containerFactory.getEmbeddedServletContainer(getSelfInitializer());\n\t\t}\n\t\telse if (localServletContext != null) {\n\t\t\ttry {\n\t\t\t\tgetSelfInitializer().onStartup(localServletContext);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tthrow new ApplicationContextException(\"Cannot initialize servlet context\",\n\t\t\t\t\t\tex);\n\t\t\t}\n\t\t}\n\t\tinitPropertySources();\n\t}\n    ```\n    * 6、可以看到`containerFactory.getEmbeddedServletContainer(getSelfInitializer());` 的参数`getSelfInitializer()`是个`ServletContextInitializer`对象\n    * `getSelfInitializer()`方法获得的`Servlet`初始化器内部会去构造一个`ServletContextInitializerBeans`(`Servlet`初始化器的集合)，`ServletContextInitializerBeans`构造的时候会去`Spring`容器中查找`ServletContextInitializer`类型的`bean`，其中`ServletRegistrationBean、FilterRegistrationBean、ServletListenerRegistrationBean`会被找出(如果有定义)，这3种`ServletContextInitializer`会在`onStartup`方法中将`Servlet、Filter、Listener`添加到`Servlet`容器中(如果我们只定义了`Servlet、Filter`或者`Listener，ServletContextInitializerBeans`内部会调用`addAdaptableBeans`方法把它们包装成`RegistrationBean`\n    ```java\n\tprivate org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {\n\t\treturn new ServletContextInitializer() {\n\t\t\t@Override\n\t\t\tpublic void onStartup(ServletContext servletContext) throws ServletException {\n\t\t\t\tselfInitialize(servletContext);\n\t\t\t}\n\t\t};\n\t}\n    ```\n    * 7、进入`containerFactory.getEmbeddedServletContainer(getSelfInitializer());`继续跳入，就来到了`TomcatEmbeddedServletContainer.initialize();`方法\n    ```java\n\tpublic TomcatEmbeddedServletContainer(Tomcat tomcat, boolean autoStart) {\n\t\tAssert.notNull(tomcat, \"Tomcat Server must not be null\");\n\t\tthis.tomcat = tomcat;\n\t\tthis.autoStart = autoStart;\n\t\t// 启动容器\n\t\tinitialize();\n\t}\n\t\n    private void initialize() throws EmbeddedServletContainerException {\n        TomcatEmbeddedServletContainer.logger\n                .info(\"Tomcat initialized with port(s): \" + getPortsDescription(false));\n        synchronized (this.monitor) {\n            try {\n                addInstanceIdToEngineName();\n                try {\n                    // Remove service connectors to that protocol binding doesn't happen\n                    // yet\n                    removeServiceConnectors();\n\n                    // Start the server to trigger initialization listeners\n                    // 启动 Tomcat\n                    this.tomcat.start();\n    ```\n## 其他\n\n## 总结\n* `SpringBoot`内置了`Servlet`容器，这样项目的发布、部署就不需要额外的`Servlet`容器，直接启动`jar`包即可\n* 如果是`Web`程序，那么会构造`AnnotationConfigEmbeddedWebApplicationContext`类型的`Spring`容器，`AnnotationConfigEmbeddedWebApplicationContext`类型的`Spring`容器在`refresh`的过程中会在`onRefresh`方法中创建内置的`Servlet`容器。\n\n## 参考\n* 芋道源码 http://www.iocoder.cn\n* https://www.jianshu.com/p/043579ae733f","tags":["Spring Boot"],"categories":["server"]},{"title":"SpringBoot(六)Starter解析及自己定制实现","url":"/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(六)Starter解析及自己定制实现/","content":"## 前言\n* `SpringBoot` 能够快速的接入各种框架的关键是靠各种`Starter`来实现的，比如我们想搭建一个`Web`应用，只要在`POM`依赖中添加`spring-boot-starter-web`就可以完成，它会帮我们自动引入各种`Web`应用所需的依赖并完成`Bean`的自动注册\n\n* `Starter` 主要用来简化依赖用的，`Spring Boot` 通过`starter`依赖为项目的依赖管理提供帮助，`starter`依赖起始就是特殊的`maven`依赖，利用了传递依赖解析，把常用库聚合在一起,组成了几个为特定功能而定制的依赖\n\n* `SpringBoot`自带的`Starter`见下图，因为太多了所以只截了部分\n\n![](/images/server/spring/spring-boot/startes.jpg)\n\n## 解析\n\n#### spring-boot-starter-web 解析\n\n* 查看`spring-boot-starter-web`的源码，见下图可以发现就两个文件，`pom.xml`定义了会自动导入哪些依赖，`spring.provides`也是告诉我们，通过在我们的构建中包含 `spring-webmvc,spring-web,jackson-databind` 作为依赖\n\n* 为什么`spring.provides`定义了依赖又要在`pom.xml`再次定义？这个问题还需研究\n\n![](/images/server/spring/spring-boot/starter-web.jpg)\n\n> META-INF/spring.provides\n\n```xml\nprovides: spring-webmvc,spring-web,jackson-databind\n```\n\n> spring-boot-starters/spring-boot-starter-web/pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starters</artifactId>\n\t\t<version>1.5.6.RELEASE</version>\n\t</parent>\n\t<artifactId>spring-boot-starter-web</artifactId>\n\t<name>Spring Boot Web Starter</name>\n\t<description>Starter for building web, including RESTful, applications using Spring\n\t\tMVC. Uses Tomcat as the default embedded container</description>\n\t<url>http://projects.spring.io/spring-boot/</url>\n\t<organization>\n\t\t<name>Pivotal Software, Inc.</name>\n\t\t<url>http://www.spring.io</url>\n\t</organization>\n\t<properties>\n\t\t<main.basedir>${basedir}/../..</main.basedir>\n\t</properties>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-tomcat</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.hibernate</groupId>\n\t\t\t<artifactId>hibernate-validator</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-web</artifactId>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-webmvc</artifactId>\n\t\t</dependency>\n\t</dependencies>\n</project>\n\n```\n\n### 自己定制实现Starter\n\n* 我们知道`spring-boot-actuator` 中已经内置了非常多的 `Endpoint`比如`health、info、beans、metrics、httptrace、shutdown`，只要添加`spring-boot-actuator`依赖就可以获得这些功能\n\n* 如果要我们自己来实现这些功能要怎么实现呢，下面我们将创建自己`Starter`来实现一个简单的功能，比如实现一个 `可以获取系统应用状态`的功能，只要在应用中导入`Starter`依赖并开启注解就可以使用该功能\n \n* 创建项目，项目结构如下图所示：\n\n![](/images/server/spring/spring-boot/cloud-starter.jpg)\n\n* 我们这里为了方便所以将`Starter`的定义及实现（添加了几个类）放到了一起，一般是`Starter`里面就一个`META-INF/spring.factories`及`pom.xml`文件\n\n* `META-INF/spring.factories` 这里配置了一个自动配置的类，只要导入了`Starter Pom`依赖，启动`SpringBoot`应用的时候就会自动注册这个类`com.songsy.springcloud.plus.starter.CloudAutoConfiguration`\n\n```java\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\ncom.songsy.springcloud.plus.starter.CloudAutoConfiguration\n```\n\n* `CloudAutoConfiguration.java`此类定义了一个`Bean`，这个`Bean`是个`Controller`，可以看到调用此链接`/system/info`就返回了一些应用信息，这里只是为了测试功能所以就返回了固定值\n    * `@Configuration` 标识此类是`Spring`的配置类，相当于一个`bean.xml`文件\n    * `@ConditionalOnBean(CloudMarkerConfiguration.Marker.class)` 标识只有当前`Spring`容器注册了`CloudMarkerConfiguration.Marker`这个`Bean`的时候此`CloudAutoConfiguration`配置类才生效\n    \n* `CloudAutoConfiguration.java`\n\n```java\n@Configuration\n@ConditionalOnBean(CloudMarkerConfiguration.Marker.class)\npublic class CloudAutoConfiguration {\n\n    @RestController\n    @RequestMapping(\"/system\")\n    class SystemController {\n\n        @GetMapping(\"/info\")\n        public Map<String, Object> getInfo() {\n            Map<String, Object> objectMap = new HashMap<String, Object>(8);\n            objectMap.put(\"appName\",\"spring-cloud-plus-parent\");\n            objectMap.put(\"groupId\",\"com.songsy.springcloud.plus\");\n            objectMap.put(\"artifactId\",\"cloud-parent\");\n            objectMap.put(\"version\",\"1.0-SNAPSHOT\");\n            objectMap.put(\"currentTimeMillis\",System.currentTimeMillis());\n            return objectMap;\n        }\n\n    }\n}\n```\n\n* `CloudMarkerConfiguration.Marker` 这个是个标识类\n\n```java\n/**\n * 注册Marker标记bean，使{@link CloudAutoConfiguration}配置类生效\n *\n * @author songsy\n * @date 2019/8/15 18:09\n */\n@Configuration\npublic class CloudMarkerConfiguration {\n\n    @Bean\n    public Marker zuulProxyMarkerBean() {\n        return new Marker();\n    }\n\n    class Marker {\n    }\n\n}\n```\n\n* `@EnableCloudAutoConfig` 注解是开启此功能的开关，可以看到只要使用了此注解，就会注册`CloudMarkerConfiguration.class` 这个`Bean`，有了此`Bean`之后`CloudAutoConfiguration.java`的条件(`@ConditionalOnBean(CloudMarkerConfiguration.Marker.class`))就成立了\n\n```java\n/**\n * 开启自动配置\n *\n * @author songsy\n * @date 2019/8/15 18:15\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Import(CloudMarkerConfiguration.class)\npublic @interface EnableCloudAutoConfig {\n\n}\n```\n\n* 如何使用\n    * 把上面的`Starter`打成`maven` `jar`包\n    * 在其他应用中导入`pom`依赖\n    ```xml\n    <dependency>\n        <groupId>com.songsy.springcloud.plus</groupId>\n        <artifactId>cloud-starter</artifactId>\n    </dependency>\n    ```\n    * 启动类加上`@EnableCloudAutoConfig`注解\n    ```java\n    @EnableCloudAutoConfig\n    @SpringBootApplication\n    public class ZuulApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ZuulApplication.class, args);\n        }\n    \n    }\n    ```\n    * 启动访问`/system/info`链接，可以看到可以得到结果\n    ```json\n    {\n        \"artifactId\": \"cloud-parent\",\n        \"version\": \"1.0-SNAPSHOT\",\n        \"appName\": \"spring-cloud-plus-parent\",\n        \"groupId\": \"com.songsy.springcloud.plus\",\n        \"currentTimeMillis\": 1565939848850\n    }\n    ```\n## 其他\n\n## 总结\n* `Starter`可以说是`SpringBoot`的灵魂，官方已经将一些常用的功能封装了，要什么就添加什么，万物皆可配置，我们也可以根据自己业务需求实现自己的`Starter`\n\n\n## 参考\n","tags":["Spring Boot"],"categories":["server"]},{"title":"SpringBoot(五)@Conditional按条件注册Bean","url":"/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(五)@Conditional按条件注册Bean/","content":"## 前言\n* 从`@EnableAutoConfiguration`自动配置功能实现可以看到`SpringBoot`大量使用了各种`@Conditional`根据条件，决定类是否加载到`Spring Ioc`容器中\n\n## 解析\n\n### 定义解析\n\n* 下面是`@Conditional`的定义，可以看到可以在类或者方法上面使用，`value`需要传入一个`Class`数组，并且这个类需要继承`Condition`接口\n\n```java\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Conditional {\n\n\t/**\n\t * All {@link Condition}s that must {@linkplain Condition#matches match}\n\t * in order for the component to be registered.\n\t */\n\tClass<? extends Condition>[] value();\n\n}\n```\n\n* `Condition.java`\n\n```java\npublic interface Condition {\n\n\t/**\n\t * Determine if the condition matches.\n\t * @param context the condition context\n\t * @param metadata metadata of the {@link org.springframework.core.type.AnnotationMetadata class}\n\t * or {@link org.springframework.core.type.MethodMetadata method} being checked.\n\t * @return {@code true} if the condition matches and the component can be registered\n\t * or {@code false} to veto registration.\n\t */\n\tboolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);\n\n}\n```\n\n* `Condition.java`接口用于定义是否符合条件\n    * `@param conditionContext`:判断条件能使用的上下文环境\n        * `ConditionContext.java`\n        ```java\n        public interface ConditionContext {\n\n            BeanDefinitionRegistry getRegistry();\n   \n            ConfigurableListableBeanFactory getBeanFactory();\n     \n            Environment getEnvironment();\n     \n            ResourceLoader getResourceLoader();\n  \n            ClassLoader getClassLoader();  \n        }\n        ```\n    * `@param annotatedTypeMetadata`:注解所在位置的注释信息\n\n### 使用示例\n\n* 这是一个简单的例子，现在问题来了，如果我想根据当前操作系统来注入`Person`实例，`windows`下注入`bill`，`linux`下注入`linus`，怎么实现呢？\n\n* 首先，创建一个`WindowsCondition`类，`conditionContext`提供了多种方法，方便获取各种信息，也是`SpringBoot`中 `@ConditonalOnXX`注解多样扩展的基础。\n\n```java\npublic class WindowsCondition implements Condition {\n\n    @Override\n    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {\n        // 获取ioc使用的beanFactory\n        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();\n        // 获取类加载器\n        ClassLoader classLoader = conditionContext.getClassLoader();\n        // 获取当前环境信息\n        Environment environment = conditionContext.getEnvironment();\n        // 获取bean定义的注册类\n        BeanDefinitionRegistry registry = conditionContext.getRegistry();\n \n        // 获得当前系统名\n        String property = environment.getProperty(\"os.name\");\n        // 包含Windows则说明是windows系统，返回true\n        if (property.contains(\"Windows\")){\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n* 接着，创建`LinuxCondition`类：\n\n```java\npublic class LinuxCondition implements Condition {\n \n    @Override\n    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {\n \n        Environment environment = conditionContext.getEnvironment();\n \n        String property = environment.getProperty(\"os.name\");\n        if (property.contains(\"Linux\")){\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n* 1、标注在方法上，一个方法只能注入一个`bean`实例，所以`@Conditional`标注在方法上只能控制一个bean实例是否注入。\n\n```java\n\n@Configuration\npublic class BeanConfig {\n    \n    // 只有一个类时，大括号可以省略\n    // 如果WindowsCondition的实现方法返回true，则注入这个bean    \n    @Conditional({WindowsCondition.class})\n    @Bean(name = \"bill\")\n    public Person person1(){\n        return new Person(\"Bill Gates\",62);\n    }\n \n    // 如果LinuxCondition的实现方法返回true，则注入这个bean\n    @Conditional({LinuxCondition.class})\n    @Bean(\"linus\")\n    public Person person2(){\n        return new Person(\"Linus\",48);\n    }\n}\n```\n* 2、标注在类上，一个类中可以注入很多实例，`@Conditional`标注在类上就决定了一批`bean`是否注入。\n\n```java\n@Conditional({WindowsCondition.class})\n@Configuration\npublic class BeanConfig {\n \n    @Bean(name = \"bill\")\n    public Person person1(){\n        return new Person(\"Bill Gates\",62);\n    }\n \n    @Bean(\"linus\")\n    public Person person2(){\n        return new Person(\"Linus\",48);\n    }\n}\n```\n\n### SpringBootCondition 的进击\n\n* 为了满足更加丰富的 `Condition`（条件）的需要，`Spring Boot` 进一步拓展了更多的实现类，如下图所示：\n\n![](/images/server/spring/spring-boot/spring-boot-condition.jpg)\n\n* `org.springframework.boot.autoconfigure.condition.SpringBootCondition` ，是 `Spring Boot` 实现` Condition` 的抽象类，且是 `Spring Boot` 所有 `Condition` 实现类的基类，分别对应如下注解：\n    * `@ConditionalOnBean`：当容器里有指定 `Bean` 的条件下。\n    * `@ConditionalOnMissingBean`：当容器里没有指定 `Bean` 的情况下。\n    * `@ConditionalOnSingleCandidate`：当指定 `Bean` 在容器中只有一个，或者虽然有多个但是指定首选 `Bean` 。\n    * `@ConditionalOnClass`：当类路径下有指定类的条件下。\n    * `@ConditionalOnMissingClass`：当类路径下没有指定类的条件下。\n    * `@ConditionalOnProperty`：指定的属性是否有指定的值\n    * `@ConditionalOnResource`：类路径是否有指定的值\n    * `@ConditionalOnExpression`：基于 `SpEL` 表达式作为判断条件。\n    * `@ConditionalOnJava`：基于 `Java` 版本作为判断条件\n    * `@ConditionalOnJndi`：在 `JNDI` 存在的条件下差在指定的位置\n    * `@ConditionalOnNotWebApplication`：当前项目不是 `Web` 项目的条件下\n    * `@ConditionalOnWebApplication`：当前项目是 `Web`项 目的条件下。\n\n* `@ConditionalOnBean` 注解解析\n    * 查看该注解，可以看到实际上还是在`@Conditional`的基础上进行了包装\n    ```java\n    @Target({ ElementType.TYPE, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Conditional(OnBeanCondition.class)\n    public @interface ConditionalOnBean {\n\n        Class<?>[] value() default {};\n\n        String[] type() default {};\n\n        Class<? extends Annotation>[] annotation() default {};\n\n        String[] name() default {};\n\n        SearchStrategy search() default SearchStrategy.ALL;\n    }\n    ```\n    * `OnBeanCondition.class`\n    ![](/images/server/spring/spring-boot/OnBeanCondition.png)\n\n### 哪里生效的\n\n* 查看哪里生效的可以直接在`matches()`方法打好断点，见下图可以看到是从`refresh()`方法开始触发，然后执行`BeanFactoryPostProcessor`钩子接口，最终跳到`org.springframework.context.annotation.ConditionEvaluator#shouldSkip()`方法\n\n![](/images/server/spring/spring-boot/shouldSkip.jpg)\n\n* 进入`org.springframework.context.annotation.ConditionEvaluator#shouldSkip()`方法，这里的`condition.matches(this.context, metadata)`方法就执行了`Condition`的接口方法\n\n```java\nclass ConditionEvaluator {\n\n\tprivate final ConditionContextImpl context;\n\n\n\t/**\n\t * Create a new {@link ConditionEvaluator} instance.\n\t */\n\tpublic ConditionEvaluator(BeanDefinitionRegistry registry, Environment environment, ResourceLoader resourceLoader) {\n\t\tthis.context = new ConditionContextImpl(registry, environment, resourceLoader);\n\t}\n\n\n\t/**\n\t * Determine if an item should be skipped based on {@code @Conditional} annotations.\n\t * The {@link ConfigurationPhase} will be deduced from the type of item (i.e. a\n\t * {@code @Configuration} class will be {@link ConfigurationPhase#PARSE_CONFIGURATION})\n\t * @param metadata the meta data\n\t * @return if the item should be skipped\n\t */\n\tpublic boolean shouldSkip(AnnotatedTypeMetadata metadata) {\n\t\treturn shouldSkip(metadata, null);\n\t}\n\n\t/**\n\t * Determine if an item should be skipped based on {@code @Conditional} annotations.\n\t * @param metadata the meta data\n\t * @param phase the phase of the call\n\t * @return if the item should be skipped\n\t */\n\tpublic boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {\n\t\tif (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (phase == null) {\n\t\t\tif (metadata instanceof AnnotationMetadata &&\n\t\t\t\t\tConfigurationClassUtils.isConfigurationCandidate((AnnotationMetadata) metadata)) {\n\t\t\t\treturn shouldSkip(metadata, ConfigurationPhase.PARSE_CONFIGURATION);\n\t\t\t}\n\t\t\treturn shouldSkip(metadata, ConfigurationPhase.REGISTER_BEAN);\n\t\t}\n\n\t\tList<Condition> conditions = new ArrayList<Condition>();\n\t\tfor (String[] conditionClasses : getConditionClasses(metadata)) {\n\t\t\tfor (String conditionClass : conditionClasses) {\n\t\t\t\tCondition condition = getCondition(conditionClass, this.context.getClassLoader());\n\t\t\t\tconditions.add(condition);\n\t\t\t}\n\t\t}\n\n\t\tAnnotationAwareOrderComparator.sort(conditions);\n\n\t\tfor (Condition condition : conditions) {\n\t\t\tConfigurationPhase requiredPhase = null;\n\t\t\tif (condition instanceof ConfigurationCondition) {\n\t\t\t\trequiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();\n\t\t\t}\n\t\t\tif (requiredPhase == null || requiredPhase == phase) {\n\t\t\t\t// 执行matches()方法\n\t\t\t    if (!condition.matches(this.context, metadata)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n```\n\n## 其他\n\n## 总结\n\n* 使用`@Condition`注解可以根据不同条件创建不同`Bean`，`SpringBoot`在此基础上又定义了一些定制版的`@Condition`，这样可以更方便的实现自动配置\n\n* `@Condition`实现原理：\n  * 是在执行`AnnotationConfigApplicationContext#refresh`方法，调用`invokeBeanFactoryPostProcessors`，执行 `BeanFactoryPostProcessor`的`postProcessBeanDefinitionRegistry` 方法\n  * 会加载`bean`的定义信息\n  * 会执行`ConditionEvaluator#shouldSkip`判断这个类是否应该被跳过\n  * 然后就会调用我们自定义的`ColorCondition#matches`方法\n  * 如果返回`false`，则不会注册对应`bean`到`ioc`容器中\n\n## 参考\n* https://blog.csdn.net/xcy1193068639/article/details/81491071","tags":["Spring Boot"],"categories":["server"]},{"title":"SpringBoot(四)@EnableAutoConfiguration自动配置","url":"/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(四)@EnableAutoConfiguration自动配置/","content":"## 前言\n* `SpringBoot`到底是怎么做到自动配置的？从代码里看项目`SpringBoot`的项目启动类只有一个注解`@SpringBootApplication`和一个`run`方法。\n\n```java\n@SpringBootApplication\npublic class SampleTomcatJspApplication extends SpringBootServletInitializer {\n\n\t@Override\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n\t\treturn application.sources(SampleTomcatJspApplication.class);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSpringApplication.run(SampleTomcatJspApplication.class, args);\n\t}\n\n}\n```\n\n## 解析\n\n* 查看`@SpringBootApplication`注解，可以看到这个注解又被其他注解修饰了\n    * `@Inherited`\n        * `java.lang.annotation.@Inherited` 注解，使用此注解声明出来的自定义注解，在使用此自定义注解时，如果注解在类上面时，子类会自动继承此注解，否则的话，子类不会继承此注解。这里一定要记住，使用`@Inherited` 声明出来的注解，只有在类上使用时才会有效，对方法，属性等其他无效。\n    * `@SpringBootConfiguration`\n        * 标记这是一个 `Spring Boot` 配置类， 它上面继承自 `@Configuration` 注解，所以两者功能也一致，可以将当前类内声明的一个或多个以 `@Bean` 注解标记的方法的实例纳入到 `Spring` 容器中，并且实例名就是方法名。\n    * `@EnableAutoConfiguration`\n        * 用于开启自动配置功能，是 `spring-boot-autoconfigure` 项目最核心的注解\n    * `@ComponentScan`\n        * 扫描指定路径下的 `Component（@Componment、@Configuration、@Service）`\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n\t\t@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\n\t@AliasFor(annotation = EnableAutoConfiguration.class, attribute = \"exclude\")\n\tClass<?>[] exclude() default {};\n\n\t@AliasFor(annotation = EnableAutoConfiguration.class, attribute = \"excludeName\")\n\tString[] excludeName() default {};\n\n\t@AliasFor(annotation = ComponentScan.class, attribute = \"basePackages\")\n\tString[] scanBasePackages() default {};\n\n\t@AliasFor(annotation = ComponentScan.class, attribute = \"basePackageClasses\")\n\tClass<?>[] scanBasePackageClasses() default {};\n}\n```\n\n* 这么多注解我们这里关注`@EnableAutoConfiguration`注解，可以看到是使用了`@Import(EnableAutoConfigurationImportSelector.class)`注解，\n\n* `@Import`用来导入一个或多个类（会被`Spring`容器管理），或者配置类（配置类里的`@Bean`标记的类也会被`Spring`容器管理），有了这个注解我们可以通过添加注解的形式来注册`Bean`\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage // 主要功能自动配置包，它会获取主程序类所在的包路径，并将包路径（包括子包）下的所有组件注册到 Spring IOC 容器中。\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\n\tString ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\";\n\n\t/**\n\t * Exclude specific auto-configuration classes such that they will never be applied.\n\t * @return the classes to exclude\n\t */\n\tClass<?>[] exclude() default {};\n\n\t/**\n\t * Exclude specific auto-configuration class names such that they will never be\n\t * applied.\n\t * @return the class names to exclude\n\t * @since 1.3.0\n\t */\n\tString[] excludeName() default {};\n\n}\n```\n\n* 查看`EnableAutoConfigurationImportSelector.class`的继承关系图\n\n![](/images/server/spring/spring-boot/EnableAutoConfigurationImportSelector.png)\n\n* 上面的图可以看到`EnableAutoConfigurationImportSelector`类是实现了`ImportSelectors`接口\n    * 实现了`ImportSelectors`接口的类通常与常规的`@Import`注解作用相同，然而，它也可能被延迟处理，直到所有被`@Configuration`标记的类处理完之后采取处理\n        ```java\n        public interface ImportSelector {\n        \n            /**\n             * Select and return the names of which class(es) should be imported based on\n             * the {@link AnnotationMetadata} of the importing @{@link Configuration} class.\n             */\n            String[] selectImports(AnnotationMetadata importingClassMetadata);\n        \n        }\n        ```\n    * `ImportSelector`接口的`selectImports`返回的数组（类的全类名）都会被注册到`Spring`容器中，所以可以通过这个方法来自定义注册哪些`bean`\n    * 我们来看它是实现这个接口的，可以看到主体逻辑是调用`getCandidateConfigurations(annotationMetadata, attributes);`获取了`list`，然后进行去重、排序、筛选排除\n        ```java\n        @Override\n        public String[] selectImports(AnnotationMetadata annotationMetadata) {\n            if (!isEnabled(annotationMetadata)) {\n                return NO_IMPORTS;\n            }\n            try {\n                AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n                        .loadMetadata(this.beanClassLoader);\n                AnnotationAttributes attributes = getAttributes(annotationMetadata);\n                // 获取META-INF/spring.factories配置的类名\n                List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\n                // 去重\n                configurations = removeDuplicates(configurations);\n                // 排序\n                configurations = sort(configurations, autoConfigurationMetadata);\n                // 筛选排除\n                Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n                checkExcludedClasses(configurations, exclusions);\n                configurations.removeAll(exclusions);\n                configurations = filter(configurations, autoConfigurationMetadata);\n                fireAutoConfigurationImportEvents(configurations, exclusions);\n                return configurations.toArray(new String[configurations.size()]);\n            }\n            catch (IOException ex) {\n                throw new IllegalStateException(ex);\n            }\n        }\n        ```\n    * 进入`getCandidateConfigurations(annotationMetadata, attributes)`方法，从下面的方法可以看到是读取了`META-INF/spring.factories`的配置，这个文件配置了哪些类需要被注册为`Bean`\n        ```java\n        protected List<String> getCandidateConfigurations(AnnotationMetadata metadata,\n                AnnotationAttributes attributes) {\n            List<String> configurations = SpringFactoriesLoader.loadFactoryNames(\n                    getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());\n            Assert.notEmpty(configurations,\n                    \"No auto configuration classes found in META-INF/spring.factories. If you \"\n                            + \"are using a custom packaging, make sure that file is correct.\");\n            return configurations;\n        }\n        \n        public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {\n            String factoryClassName = factoryClass.getName();\n    \n            try {\n                Enumeration<URL> urls = classLoader != null ? classLoader.getResources(\"META-INF/spring.factories\") : ClassLoader.getSystemResources(\"META-INF/spring.factories\");\n                ArrayList result = new ArrayList();\n    \n                while(urls.hasMoreElements()) {\n                    URL url = (URL)urls.nextElement();\n                    Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\n                    String factoryClassNames = properties.getProperty(factoryClassName);\n                    result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\n                }\n    \n                return result;\n            } catch (IOException var8) {\n                throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() + \"] factories from location [\" + \"META-INF/spring.factories\" + \"]\", var8);\n            }\n        }\n        ```\n    * 查看`spring-boot-autoconfigure`模块的`META-INF/spring.factories`文件\n        ```java\n        # Initializers\n        org.springframework.context.ApplicationContextInitializer=\\\n        org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\\n        org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer\n        \n        # Application Listeners\n        org.springframework.context.ApplicationListener=\\\n        org.springframework.boot.autoconfigure.BackgroundPreinitializer\n        \n        # Auto Configuration Import Listeners\n        org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\\n        org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener\n        \n        # Auto Configuration Import Filters\n        org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\\n        org.springframework.boot.autoconfigure.condition.OnClassCondition\n        \n        # Auto Configure\n        org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\n        org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\\n        org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\\n        org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration\n        \n        # Failure analyzers\n        org.springframework.boot.diagnostics.FailureAnalyzer=\\\n        org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\\\n        org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\\\n        org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer\n        \n        # Template availability providers\n        org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\\\n        org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\\n        org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\\\n        org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\\\n        org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\\\n        org.springframework.boot.autoconfigure.web.JspTemplateAvailabilityProvider\n        ```\n* 获取到了哪些`Bean`需要自动配置，我们来看下是哪里调用了，下图是这个方法的调用链\n\n![](/images/server/spring/spring-boot/autoConfiguration.png)\n\n* 由上面的调用链可以看到容器执行了`refresh()`时触发的，这个方法在之前`Spring`系列有过介绍，现在来回顾一下\n    * 进入`refresh()`方法，可以看到是执行了`invokeBeanFactoryPostProcessors(beanFactory)`方法\n    ```java\n        @Override\n        public void refresh() throws BeansException, IllegalStateException {\n            synchronized (this.startupShutdownMonitor) {\n                // Prepare this context for refreshing.\n                // 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证\n                prepareRefresh();\n    \n                // Tell the subclass to refresh the internal bean factory.\n                // 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能\n                ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n    \n                // Prepare the bean factory for use in this context.\n                // 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开\n                // 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持\n                prepareBeanFactory(beanFactory);\n    \n                try {\n                    // Allows post-processing of the bean factory in context subclasses.\n                    // 子类覆盖方法做额外的处理\n                    postProcessBeanFactory(beanFactory);\n    \n    \n                    // Invoke factory processors registered as beans in the context.\n                    // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，\n                    // 并调用其postProcessBeanFactory接口方法\n                    invokeBeanFactoryPostProcessors(beanFactory);\n                ...\n    ```\n    * 可以看到是执行了工厂后处理器，根据反射机制从`BeanDefinitionRegistry`中找出所有实现了`BeanFactoryPostProcessor`接口的`bean`，查看`invokeBeanDefinitionRegistryPostProcessors()`方法是执行了`BeanDefinitionRegistryPostProcessor`接口`postProcessBeanDefinitionRegistry(registry)`方法\n    ```java\n\tprivate static void invokeBeanDefinitionRegistryPostProcessors(\n\t\t\tCollection<? extends BeanDefinitionRegistryPostProcessor> postProcessors, BeanDefinitionRegistry registry) {\n\n\t\tfor (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {\n\t\t\tpostProcessor.postProcessBeanDefinitionRegistry(registry);\n\t\t}\n\t}\n    ```\n    * `BeanDefinitionRegistryPostProcessor`接口继承了`BeanFactoryPostProcessor`接口，这里是执行实现了`BeanDefinitionRegistryPostProcessor`接口`Bean`的`postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)`方法，用于注册`bean`\n\n## 其他\n* 使用`@Configuration`注解的类`MyConfig`与启动类`Application`如果不在同一包下,才需要配置`spring.factories`\n\n### AopAutoConfiguration 自动配置\n\n```java\n@Configuration\n@ConditionalOnClass({ EnableAspectJAutoProxy.class, Aspect.class, Advice.class })\n@ConditionalOnProperty(prefix = \"spring.aop\", name = \"auto\", havingValue = \"true\", matchIfMissing = true)\npublic class AopAutoConfiguration {\n\n\t@Configuration\n\t@EnableAspectJAutoProxy(proxyTargetClass = false)\n\t@ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"false\", matchIfMissing = true)\n\tpublic static class JdkDynamicAutoProxyConfiguration {\n\n\t}\n\n\t@Configuration\n\t@EnableAspectJAutoProxy(proxyTargetClass = true)\n\t@ConditionalOnProperty(prefix = \"spring.aop\", name = \"proxy-target-class\", havingValue = \"true\", matchIfMissing = false)\n\tpublic static class CglibAutoProxyConfiguration {\n\n\t}\n\n}\n```\n\n### CacheAutoConfiguration 自动配置\n\n```java\n@Configuration\n@ConditionalOnClass(CacheManager.class)\n@ConditionalOnBean(CacheAspectSupport.class)\n@ConditionalOnMissingBean(value = CacheManager.class, name = \"cacheResolver\")\n@EnableConfigurationProperties(CacheProperties.class)\n@AutoConfigureBefore(HibernateJpaAutoConfiguration.class)\n@AutoConfigureAfter({ CouchbaseAutoConfiguration.class, HazelcastAutoConfiguration.class,\n\t\tRedisAutoConfiguration.class })\n@Import(CacheConfigurationImportSelector.class)\npublic class CacheAutoConfiguration {\n\n\tstatic final String VALIDATOR_BEAN_NAME = \"cacheAutoConfigurationValidator\";\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic CacheManagerCustomizers cacheManagerCustomizers(\n\t\t\tObjectProvider<List<CacheManagerCustomizer<?>>> customizers) {\n\t\treturn new CacheManagerCustomizers(customizers.getIfAvailable());\n\t}\n\n\t@Bean\n\t@Role(BeanDefinition.ROLE_INFRASTRUCTURE)\n\tpublic static CacheManagerValidatorPostProcessor cacheAutoConfigurationValidatorPostProcessor() {\n\t\treturn new CacheManagerValidatorPostProcessor();\n\t}\n\n\t@Bean(name = VALIDATOR_BEAN_NAME)\n\tpublic CacheManagerValidator cacheAutoConfigurationValidator() {\n\t\treturn new CacheManagerValidator();\n\t}\n\n\t@Configuration\n\t@ConditionalOnClass(LocalContainerEntityManagerFactoryBean.class)\n\t@ConditionalOnBean(AbstractEntityManagerFactoryBean.class)\n\tprotected static class CacheManagerJpaDependencyConfiguration\n\t\t\textends EntityManagerFactoryDependsOnPostProcessor {\n\n\t\tpublic CacheManagerJpaDependencyConfiguration() {\n\t\t\tsuper(\"cacheManager\");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link BeanFactoryPostProcessor} to ensure that the {@link CacheManagerValidator}\n\t * is triggered before {@link CacheAspectSupport} but without causing early\n\t * instantiation.\n\t */\n\tstatic class CacheManagerValidatorPostProcessor implements BeanFactoryPostProcessor {\n\n\t\t@Override\n\t\tpublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)\n\t\t\t\tthrows BeansException {\n\t\t\tfor (String name : beanFactory.getBeanNamesForType(CacheAspectSupport.class,\n\t\t\t\t\tfalse, false)) {\n\t\t\t\tBeanDefinition definition = beanFactory.getBeanDefinition(name);\n\t\t\t\tdefinition.setDependsOn(\n\t\t\t\t\t\tappend(definition.getDependsOn(), VALIDATOR_BEAN_NAME));\n\t\t\t}\n\t\t}\n\n\t\tprivate String[] append(String[] array, String value) {\n\t\t\tString[] result = new String[array == null ? 1 : array.length + 1];\n\t\t\tif (array != null) {\n\t\t\t\tSystem.arraycopy(array, 0, result, 0, array.length);\n\t\t\t}\n\t\t\tresult[result.length - 1] = value;\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\t/**\n\t * Bean used to validate that a CacheManager exists and provide a more meaningful\n\t * exception.\n\t */\n\tstatic class CacheManagerValidator {\n\n\t\t@Autowired\n\t\tprivate CacheProperties cacheProperties;\n\n\t\t@Autowired(required = false)\n\t\tprivate CacheManager cacheManager;\n\n\t\t@PostConstruct\n\t\tpublic void checkHasCacheManager() {\n\t\t\tAssert.notNull(this.cacheManager,\n\t\t\t\t\t\"No cache manager could \"\n\t\t\t\t\t\t\t+ \"be auto-configured, check your configuration (caching \"\n\t\t\t\t\t\t\t+ \"type is '\" + this.cacheProperties.getType() + \"')\");\n\t\t}\n\n\t}\n\n\t/**\n\t * {@link ImportSelector} to add {@link CacheType} configuration classes.\n\t */\n\tstatic class CacheConfigurationImportSelector implements ImportSelector {\n\n\t\t@Override\n\t\tpublic String[] selectImports(AnnotationMetadata importingClassMetadata) {\n\t\t\tCacheType[] types = CacheType.values();\n\t\t\tString[] imports = new String[types.length];\n\t\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\t\timports[i] = CacheConfigurations.getConfigurationClass(types[i]);\n\t\t\t}\n\t\t\treturn imports;\n\t\t}\n\n\t}\n\n}\n```\n\n## 总结\n* `Spring Boot`实现自动配置是通过`@EnableAutoConfiguration`来实现的，这个注解使用了`@Import`注解，`@Import`用来导入一个或多个类（会被`Spring`容器管理），或者配置类（配置类里的`@Bean`标记的类也会被`Spring`容器管理），有了这个注解我们可以通过添加注解的形式来注册`Bean`\n* `@Import`注解一般和`ImportSelectors`接口搭配使用， 实现了`ImportSelectors`接口的类通常与常规的`@Import`注解作用相同，`ImportSelector`接口的`selectImports`返回的数组（类的全类名）都会被注册到`Spring`容器中，所以可以通过这个方法来自定义注册哪些`bean`，然而，它也可能被延迟处理，直到所有被`@Configuration`标记的类处理完之后采取处理\n* `Spring Boot` 在启动时扫描项目所依赖的 `jar` 包，寻找包含`spring.factories` 文件的 `jar` 包，根据 `spring.factories` 配置加载 `AutoConfigure` 类。\n* 在自动配置类`AutoConfigure` 类下然后将满足条件(`@ConditionalOnXxx`)的`@Bean`放入到`Spring`容器中`Spring Context`\n\n\n## 参考\n* 芋道源码 http://www.iocoder.cn","tags":["Spring Boot"],"categories":["server"]},{"title":"SpringBoot(三)下载源码及SpringApplication","url":"/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(三)下载源码及SpringApplication/","content":"## 前言\n\n* 要研究`Spring Boot` 就需要下载它的源码，传送门：`https://github.com/spring-projects/spring-boot`\n\n#### 导入`Spring Boot` 源码\n* 这里是选用了`spring-boot-1.5.6.RELEASE`版本与之前的`spring-framework-4.3.10.RELEASE`是相对应的，下面是目录结构\n\n![](/images/server/spring/spring-boot/Springboot.jpg)\n\n* 下载后执行`clean install  -Dmaven.test.skip=true`命令，然而并不是那么顺利，直接运行会报错，和`spring-framework-4.3.10.RELEASE`的源码的编译一样还是要改文件才能正常编译\n    * 注释下面的依赖，不然会报找不到的错\n    ```java\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot</artifactId>\n\t\t\t<type>test-jar</type>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n    ```\n    * 注释根`pom`不必要的模块，不然报错\n    ```xml\n    <module>spring-boot-test-autoconfigure</module>\n    <module>spring-boot-devtools</module>\n    ```\n    * 注释根`pom`不必要的插件\n    ```java\n\t<plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-checkstyle-plugin</artifactId>\n        <version>2.17</version>\n        <dependencies>\n            <dependency>\n                <groupId>com.puppycrawl.tools</groupId>\n                <artifactId>checkstyle</artifactId>\n                <version>7.1.1</version>\n            </dependency>\n        </dependencies>\n    </plugin>\n    ```\n    * 注释`spring-boot-tools`模块下的`pom.xml`的模块，不然报错\n    ```xml\n    <module>spring-boot-gradle-plugin</module>\n    <module>spring-boot-maven-plugin</module>\n    ```\n    * 将一些报错模块测试包`Mark Directory as` -> `Excluded`，也可以直接干掉\n* 编译通过之后就可以在本地调`spring-boot-samples`目录下的示例代码了\n## 解析\n\n* 查看`Spring Boot`的示例代码\n    * 使用 `@SpringBootApplication` 注解，标明是 `Spring Boot` 应用。通过它，可以开启自动配置的功能。\n    * 调用 `SpringApplication#run(Class<?>... primarySources)` 方法，启动 `Spring Boot` 应用。\n```java\n@SpringBootApplication\npublic class SampleTomcatJspApplication extends SpringBootServletInitializer {\n\n\t@Override\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n\t\treturn application.sources(SampleTomcatJspApplication.class);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSpringApplication.run(SampleTomcatJspApplication.class, args);\n\t}\n}\n```\n\n#### SpringApplication\n\n* 跟进`SpringApplication.run(SampleTomcatJspApplication.class, args)`方法，可以看到是调用了`SpringApplication`的静态方法，最终是创建 `SpringApplication` 对象并执行`public ConfigurableApplicationContext run(String... args) `方法\n\n```java\n\tpublic static ConfigurableApplicationContext run(Object source, String... args) {\n\t\treturn run(new Object[] { source }, args);\n\t}\n\n\tpublic static ConfigurableApplicationContext run(Object[] sources, String[] args) {\n\t\t// 创建 SpringApplication 对象，并执行运行。\n\t\treturn new SpringApplication(sources).run(args);\n\t}\n```\n\n* 进入`org.springframework.boot.SpringApplication#run(java.lang.String...)`方法，可以看到主要逻辑也是构造`ApplicationContext`容器\n\n```java\n/**\n * Run the Spring application, creating and refreshing a new\n * {@link ApplicationContext}.\n * @param args the application arguments (usually passed from a Java main method)\n * @return a running {@link ApplicationContext}\n */\npublic ConfigurableApplicationContext run(String... args) {\n    //  创建 StopWatch 对象，并启动。StopWatch 主要用于简单统计 run 启动过程的时长。\n    StopWatch stopWatch = new StopWatch();\n    stopWatch.start();\n    ConfigurableApplicationContext context = null;\n    FailureAnalyzers analyzers = null;\n    // 配置 headless 属性，这个逻辑，可以无视，和 AWT 相关。\n    configureHeadlessProperty();\n    // 获得 SpringApplicationRunListener 的数组，并启动监听\n    SpringApplicationRunListeners listeners = getRunListeners(args);\n    listeners.starting();\n    try {\n        // 创建  ApplicationArguments 对象\n        ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);\n        // 加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 application.properties 和外部的属性配置。\n        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);\n        // 打印 Spring Banner\n        Banner printedBanner = printBanner(environment);\n        // 创建 Spring 容器。\n        context = createApplicationContext();\n        analyzers = new FailureAnalyzers(context);\n        // 主要是调用所有初始化类的 initialize 方法\n        prepareContext(context, environment, listeners, applicationArguments, printedBanner);\n        // 初始化 Spring 容器。\n        refreshContext(context);\n        // 执行 Spring 容器的初始化的后置逻辑\n        afterRefresh(context, applicationArguments);\n        // 通知 SpringApplicationRunListener 的数组，Spring 容器启动完成\n        listeners.finished(context, null);\n        // 停止 StopWatch 统计时长\n        stopWatch.stop();\n        if (this.logStartupInfo) {\n            new StartupInfoLogger(this.mainApplicationClass)\n                    .logStarted(getApplicationLog(), stopWatch);\n        }\n        return context;\n    }\n    catch (Throwable ex) {\n        // 如果发生异常，则进行处理，并抛出 IllegalStateException 异常\n        handleRunFailure(context, listeners, analyzers, ex);\n        throw new IllegalStateException(ex);\n    }\n}\n```\n\n#### Print Banner\n\n* `Banner printedBanner = printBanner(environment);`用于打印`Spring`，也可以自己添加`banner.txt`修改打印\n```html\n  .   ____          _            __ _ _\n /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  '  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::     \n```\n\n* 进入`printBanner(environment)`方法可以看到是构造了一个`SpringApplicationBannerPrinter`对象\n\n```java\nprivate Banner printBanner(ConfigurableEnvironment environment) {\n    if (this.bannerMode == Banner.Mode.OFF) {\n        return null;\n    }\n    ResourceLoader resourceLoader = this.resourceLoader != null ? this.resourceLoader\n            : new DefaultResourceLoader(getClassLoader());\n    // 构造SpringApplicationBannerPrinter\n    SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(\n            resourceLoader, this.banner);\n    if (this.bannerMode == Mode.LOG) {\n        // 打印在log file中\n        return bannerPrinter.print(environment, this.mainApplicationClass, logger);\n    }\n    return bannerPrinter.print(environment, this.mainApplicationClass, System.out);\n}\n```\n\n* 查看`SpringApplicationBannerPrinter`\n\n```java\nclass SpringApplicationBannerPrinter {\n\t// 配置该属性用于配置自定义banner的位置\n\tstatic final String BANNER_LOCATION_PROPERTY = \"banner.location\";\n\t// 图片BANNER_IMAGE?\n\tstatic final String BANNER_IMAGE_LOCATION_PROPERTY = \"banner.image.location\";\n\t// 默认banner的存放位置\n\tstatic final String DEFAULT_BANNER_LOCATION = \"banner.txt\";\n\n\tstatic final String[] IMAGE_EXTENSION = { \"gif\", \"jpg\", \"png\" };\n\t// 默认打印处理类\n\tprivate static final Banner DEFAULT_BANNER = new SpringBootBanner();\n\n\tprivate final ResourceLoader resourceLoader;\n\n\tprivate final Banner fallbackBanner;\n\n\tSpringApplicationBannerPrinter(ResourceLoader resourceLoader, Banner fallbackBanner) {\n\t\tthis.resourceLoader = resourceLoader;\n\t\tthis.fallbackBanner = fallbackBanner;\n\t}\n    \n\t... \n```\n\n* `SpringBootBanner`默认打印处理类，可以看到是直接拼接了一个字符数组然后`for`\n\n```java\n/**\n * Default Banner implementation which writes the 'Spring' banner.\n *\n * @author Phillip Webb\n */\nclass SpringBootBanner implements Banner {\n\n\tprivate static final String[] BANNER = { \"\",\n\t\t\t\"  .   ____          _            __ _ _\",\n\t\t\t\" /\\\\\\\\ / ___'_ __ _ _(_)_ __  __ _ \\\\ \\\\ \\\\ \\\\\",\n\t\t\t\"( ( )\\\\___ | '_ | '_| | '_ \\\\/ _` | \\\\ \\\\ \\\\ \\\\\",\n\t\t\t\" \\\\\\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\",\n\t\t\t\"  '  |____| .__|_| |_|_| |_\\\\__, | / / / /\",\n\t\t\t\" =========|_|==============|___/=/_/_/_/\" };\n\n\tprivate static final String SPRING_BOOT = \" :: Spring Boot :: \";\n\n\tprivate static final int STRAP_LINE_SIZE = 42;\n\n\t@Override\n\tpublic void printBanner(Environment environment, Class<?> sourceClass,\n\t\t\tPrintStream printStream) {\n\t\t// 循环打印\n\t\tfor (String line : BANNER) {\n\t\t\tprintStream.println(line);\n\t\t}\n\t\tString version = SpringBootVersion.getVersion();\n\t\tversion = (version == null ? \"\" : \" (v\" + version + \")\");\n\t\tString padding = \"\";\n\t\twhile (padding.length() < STRAP_LINE_SIZE\n\t\t\t\t- (version.length() + SPRING_BOOT.length())) {\n\t\t\tpadding += \" \";\n\t\t}\n\n\t\tprintStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT,\n\t\t\t\tAnsiColor.DEFAULT, padding, AnsiStyle.FAINT, version));\n\t\tprintStream.println();\n\t}\n\n}\n```\n\n#### Create ApplicationContext\n\n* `context = createApplicationContext();`用于创建`ApplicationContext`，不同环境会创建不同的\n    * 非web环境构造`AnnotationConfigApplicationContext`\n    * web环境构造`AnnotationConfigEmbeddedWebApplicationContext`\n\n```java\n/**\n * 非web环境构造的application context\n * The class name of application context that will be used by default for non-web\n * environments.\n */\npublic static final String DEFAULT_CONTEXT_CLASS = \"org.springframework.context.\"\n        + \"annotation.AnnotationConfigApplicationContext\";\n\n/**\n * web环境构造的application context\n * The class name of application context that will be used by default for web\n * environments.\n */\npublic static final String DEFAULT_WEB_CONTEXT_CLASS = \"org.springframework.\"\n        + \"boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext\";\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n    // 根据 webApplicationType 类型，获得 ApplicationContext 类型\n    Class<?> contextClass = this.applicationContextClass;\n    if (contextClass == null) {\n        try {\n            contextClass = Class.forName(this.webEnvironment\n                    ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);\n        }\n        catch (ClassNotFoundException ex) {\n            throw new IllegalStateException(\n                    \"Unable create a default ApplicationContext, \"\n                            + \"please specify an ApplicationContextClass\",\n                    ex);\n        }\n    }\n    // 创建 ApplicationContext 对象\n    return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);\n}\n```\n\n#### Refresh ApplicationContext\n\n* `refreshContext(context);`用于初始化 Spring 容器，可以看到主要逻辑也是调用`ApplicationContext`的`refresh()`方法\n\n```java\nprivate void refreshContext(ConfigurableApplicationContext context) {\n    // 开启（刷新）Spring 容器\n    refresh(context);\n    // 注册 ShutdownHook 钩子\n    if (this.registerShutdownHook) {\n        try {\n            context.registerShutdownHook();\n        }\n        catch (AccessControlException ex) {\n            // Not allowed in some environments.\n        }\n    }\n}\n\nprotected void refresh(ApplicationContext applicationContext) {\n    Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);\n    ((AbstractApplicationContext) applicationContext).refresh();\n}\n```\n\n#### Call Runners\n\n* `afterRefresh(context, applicationArguments);`用于执行 Spring 容器的初始化后的后置逻辑，可以看到是执行了`ApplicationRunner`及`CommandLineRunner`接口的`run`方法，如果你想在`Spring Boot`容器构造完成之后额外做一些事情，可以实现这两个接口来定义\n    * `ApplicationRunner`中`run`方法的参数为`ApplicationArguments`\n        * 示例代码：\n          ```java\n            @Component\n            @Order(value = 10)\n            public class AgentApplicationRun2 implements ApplicationRunner {\n                @Override\n                public void run(ApplicationArguments applicationArguments) throws Exception {\n            \n                }\n            }\n          ```\n    * `CommandLineRunner`接口中`run`方法的参数为`String`数组。想要更详细地获取命令行参数，那就使用`ApplicationRunner`接口\n        * 示例代码\n        ```java\n        @Component\n        @Order(value = 11)\n        public class AgentApplicationRun implements CommandLineRunner {\n        \n            @Override\n            public void run(String... strings) throws Exception {\n        \n            }\n        }\n        ```      \n* `ApplicationRunner `\n```java\nprotected void afterRefresh(ConfigurableApplicationContext context,\n        ApplicationArguments args) {\n    callRunners(context, args);\n}\n\nprivate void callRunners(ApplicationContext context, ApplicationArguments args) {\n    // 获得所有 Runner\n    List<Object> runners = new ArrayList<Object>();\n    // 获得所有 ApplicationRunner Bean\n    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());\n    // 获得所有 CommandLineRunner Bean\n    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());\n    // 排序 runners\n    AnnotationAwareOrderComparator.sort(runners);\n    // 遍历 Runner 数组，执行逻辑\n    for (Object runner : new LinkedHashSet<Object>(runners)) {\n        if (runner instanceof ApplicationRunner) {\n            callRunner((ApplicationRunner) runner, args);\n        }\n        if (runner instanceof CommandLineRunner) {\n            callRunner((CommandLineRunner) runner, args);\n        }\n    }\n}\n```\n\n* \n\n## 总结\n\n## 参考\n* 芋道源码 http://www.iocoder.cn\n* https://blog.csdn.net/weixin_38362455/article/details/83023025","tags":["Spring Boot"],"categories":["server"]},{"title":"SpringBoot(二)构建及配置SpringBoot项目","url":"/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(二)构建及配置SpringBoot项目/","content":"### 集成Spring boot\n\n* 构建`SpringBoot`项目，先配置`Maven`配置，下面有两种方式\n    * 方式一\n        * 集成`Spring Boot`时，官方示例中，都是让我们继承一个`Spring`的 `spring-boot-starter-parent` 这个`parent`，这样就集成了\n        ```xml\n        <parent>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>1.5.6.RELEASE</version>\n        </parent>\n        \n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n            </dependency>\n        </dependencies>\n        ```\n    * 方式二\n        * 一般情况下，在我们自己的项目中，会定义一下自己的`Maven parent` 项目，这种情况下，上面的这种做法就行不通了。那么，该如何来做呢？其实，在`Spring`的官网也给出了变通的方法的，在我们自己 `parent` 项目中，加下下面的声明：\n        ```xml\n        <dependencyManagement>\n            <dependencies>\n                <dependency>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-dependencies</artifactId>\n                    <version>1.5.1.RELEASE</version>\n                    <type>pom</type>\n                    <scope>import</scope>\n                </dependency>\n            </dependencies>\n        </dependencyManagement>\n        ```\n        * 请注意，它的 `type`是` pom`，`scope` 是` import`，这种类型的 `dependency` 只能在 `dependencyManagement` 标签中声明，然后，把我们项目中的 子项目 中，`parent` 的声明，修改为我们自己项目的` parent` 项目就可以了，比如，我的是： \n        ```xml\n          <parent>\n            <groupId>com.songsy</groupId>\n            <artifactId>spring-cloud-parent</artifactId>\n            <version>1.0-SNAPSHOT</version>\n          </parent>\n        ``` \n* 然后新增一个启动类及配置文件`application.properties`就完成了一个`Boot`项目的构建\n```java\n@SpringBootApplication\npublic class SampleTomcatJspApplication extends SpringBootServletInitializer {\n\n\t@Override\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n\t\treturn application.sources(SampleTomcatJspApplication.class);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tSpringApplication.run(SampleTomcatJspApplication.class, args);\n\t}\n\n}\n```\n\n### 不同环境不同配置文件\n1. 针对各环境新建不同的配置文件 `application-dev.properties、application-test.properties、application-prod.properties` , 在这三个文件均都设置不同的`server.port`属性，如：`dev`环境设置为`8080`，`test`环境设置为`9090`，`prod`环境设置为`80`\n \n2. `application.properties`中设置`spring.profiles.active=dev`，就是说默认以dev环境设置\n \n3. 采用命令行的形式 \n```sql\n执行java -jar xxx.jar，可以观察到服务端口被设置为8080，也就是默认的开发环境（dev）\n\n执行java -jar xxx.jar --spring.profiles.active=test，可以观察到服务端口被设置为9090，也就是测试环境的配置（test）\n\n执行java -jar xxx.jar --spring.profiles.active=prod，可以观察到服务端口被设置为80，也就是生产环境的配置（prod）\n```\n\n### 打包 Spring Boot 项目\n\n* 引入 `spring-boot-maven-plugin` 插件，执行 `mvn clean package` 命令，将 `Spring Boot` 项目打成一个 `Fat Jar` 。后续，我们就可以直接使用 `java -jar` 运行。\n\n```java\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-surefire-plugin</artifactId>\n            <configuration>\n                <useSystemClassLoader>false</useSystemClassLoader>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n### 数据文件的加载顺序\n1. 在命令行中传入的参数\n2. SPRING_APPLICATION_JSON: 以JSON格式配置在系统环境变量中的内容\n3. java:comp/env 的JNDI属性\n4. Java的系统属性，可以通过System.getProperties()\n5. 操作系统的环境变量\n6. 通过 random.* 配置的随机属性\n7. 位当前jar之外，针对不同{profile}环境的配置文件内容, application-{profile}.yml\n8. 位当前jar之内，针对不同{profile}环境的配置文件内容, application-{profile}.yml\n9. 位当前jar之外，application.yml\n10. 位当前jar之内，application.yml\n\n\n## 总结\n\n## 参考\n* 芋道源码 http://www.iocoder.cn\n* 详见： http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-maven-without-a-parent\n* 参考： https://blog.csdn.net/rainbow702/article/details/55046298 ","tags":["Spring Boot"],"categories":["server"]},{"title":"SpringBoot(一)前言","url":"/2019/08/06/backend/framework/spring/spring-boot/SpringBoot(一)前言/","content":"## 前言\n* `Spring Boot` 是 `Spring` 的子项目，正如其名字，提供 `Spring` 的引导`Boot`的功能。\n\n* 通过 `Spring Boot` ，我们开发者可以快速配置 `Spring` 项目，引入各种 `Spring MVC、Spring Transaction、Spring AOP、MyBatis` 等等框架，而无需不断重复编写繁重的 `Spring` 配置，降低了 `Spring` 的使用成本。\n\n### 核心功能\n* 独立运行的`Spring`项目,可以以`jar`包的形式独立运行, 运行一个`Spring boot`项目只要通过 `java -jar xx.jar`\n* 内嵌`Tomcat, Jetty, Undertow` 无需以war包形式部署项目\n* 提供`starter`简化Maven配置\n* 自动配置`Bean`, 极大的减少了我们要使用的配置\n\n\n### 优点\n1. 快速构建项目\n2. 对主流开发框架的无配置集成\n3. 项目可独立运行\n4. 提供运行时的应用监控\n\n#### Starter POMs\n> Starter 主要用来简化依赖用的，Spring Boot 通过starter依赖为项目的依赖管理提供帮助.starter依赖起始就是特殊的maven依赖,利用了传递依赖解析,把常用库聚合在一起,组成了几个为特定功能而定制的依赖.\n\n![](/images/server/spring/spring-boot/spring-boot-starter-web.png)\n\n所有的starters遵循一个相似的命名模式：spring-boot-starter-*，在这里*是一种特殊类型的应用程序。\neg:\n\n名称 | 描述\n---|---\nspring-boot-starter | 对自动配置、日志记录和YAML支持，核心starter\nspring-boot-starter-thymeleaf | 对Thymeleaf模板引擎的支持，Spring mvc的集成\nspring-boot-starter-web | 对web支持，包括RESTful，使用tomcat作为默认容器\nspring-boot-starter-data-jpa | 对jpa支持\n\n\n## 总结\n\n## 参考\n* 芋道源码 http://www.iocoder.cn","tags":["Spring Boot"],"categories":["server"]},{"title":"Spring Mvc源码(十)RequestBody注解解析之RequestResponseBodyMethodProcessor","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(十)RequestBody注解解析之RequestResponseBodyMethodProcessor/","content":"## 1.1 前言\n* `RequestResponseBodyMethodProcessor` 的作用是处理被`@RequestBody`注解的参数，和`@ResponseBody`注解的返回值\n\n* 查看`RequestResponseBodyMethodProcessor`继承关系，可以看到它是同时继承了`HandlerMethodArgumentResolver`和`HandlerMethodReturnValueHandler`，所以就是说它同时具有参数对象解析及结果对象解析的功能，野心很大\n\n![](/images/server/spring/spring-mvc/RequestResponseBodyMethodProcessor.png)\n\n## 2.1 解析\n> RequestResponseBodyMethodProcessor.java\n```java\n/**\n * 处理被@RequestBody注解的参数，和@ResponseBody注解的返回值\n *\n * Resolves method arguments annotated with {@code @RequestBody} and handles return\n * values from methods annotated with {@code @ResponseBody} by reading and writing\n * to the body of the request or response with an {@link HttpMessageConverter}.\n *\n * <p>An {@code @RequestBody} method argument is also validated if it is annotated\n * with {@code @javax.validation.Valid}. In case of validation failure,\n * {@link MethodArgumentNotValidException} is raised and results in an HTTP 400\n * response status code if {@link DefaultHandlerExceptionResolver} is configured.\n *\n * @author Arjen Poutsma\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n */\npublic class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor {\n\n\t/**\n\t * Basic constructor with converters only. Suitable for resolving\n\t * {@code @RequestBody}. For handling {@code @ResponseBody} consider also\n\t * providing a {@code ContentNegotiationManager}.\n\t */\n\tpublic RequestResponseBodyMethodProcessor(List<HttpMessageConverter<?>> converters) {\n\t\tsuper(converters);\n\t}\n\n\t/**\n\t * Basic constructor with converters and {@code ContentNegotiationManager}.\n\t * Suitable for resolving {@code @RequestBody} and handling\n\t * {@code @ResponseBody} without {@code Request~} or\n\t * {@code ResponseBodyAdvice}.\n\t */\n\tpublic RequestResponseBodyMethodProcessor(List<HttpMessageConverter<?>> converters,\n\t\t\tContentNegotiationManager manager) {\n\n\t\tsuper(converters, manager);\n\t}\n\n\t/**\n\t * Complete constructor for resolving {@code @RequestBody} method arguments.\n\t * For handling {@code @ResponseBody} consider also providing a\n\t * {@code ContentNegotiationManager}.\n\t * @since 4.2\n\t */\n\tpublic RequestResponseBodyMethodProcessor(List<HttpMessageConverter<?>> converters,\n\t\t\tList<Object> requestResponseBodyAdvice) {\n\n\t\tsuper(converters, null, requestResponseBodyAdvice);\n\t}\n\n\t/**\n\t * Complete constructor for resolving {@code @RequestBody} and handling\n\t * {@code @ResponseBody}.\n\t */\n\tpublic RequestResponseBodyMethodProcessor(List<HttpMessageConverter<?>> converters,\n\t\t\tContentNegotiationManager manager, List<Object> requestResponseBodyAdvice) {\n\n\t\tsuper(converters, manager, requestResponseBodyAdvice);\n\t}\n\n\t/**\n\t * 检测参数是否使用了@RequestBody注解\n\t *\n\t * @param parameter the method parameter to check\n\t * @return\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn parameter.hasParameterAnnotation(RequestBody.class);\n\t}\n\n\t/**\n\t * 检测返回结果是否使用了@ResponseBody注解\n\t *\n\t * @param returnType the method return type to check\n\t * @return\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||\n\t\t\t\treturnType.hasMethodAnnotation(ResponseBody.class));\n\t}\n\n\t/**\n\t * 处理被@RequestBody注解的参数\n\t *\n\t * Throws MethodArgumentNotValidException if validation fails.\n\t * @throws HttpMessageNotReadableException if {@link RequestBody#required()}\n\t * is {@code true} and there is no body content or if there is no suitable\n\t * converter to read the content with.\n\t */\n\t@Override\n\tpublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\tObject arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n\t\tString name = Conventions.getVariableNameForParameter(parameter);\n\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n\t\tif (arg != null) {\n\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t}\n\t\t}\n\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\n\t\treturn adaptArgumentIfNecessary(arg, parameter);\n\t}\n\n\t/**\n\t *\n\t * @param webRequest the current request\n\t * @param parameter the method parameter descriptor (may be {@code null})\n\t * @param paramType the type of the argument value to be created\n\t * @param <T>\n\t * @return\n\t * @throws IOException\n\t * @throws HttpMediaTypeNotSupportedException\n\t * @throws HttpMessageNotReadableException\n\t */\n\t@Override\n\tprotected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tHttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\tServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest);\n\n\t\tObject arg = readWithMessageConverters(inputMessage, parameter, paramType);\n\t\tif (arg == null) {\n\t\t\tif (checkRequired(parameter)) {\n\t\t\t\tthrow new HttpMessageNotReadableException(\"Required request body is missing: \" +\n\t\t\t\t\t\tparameter.getMethod().toGenericString());\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}\n\n\t/**\n\t * 检查RequestBody注解是否required\n\t * @param parameter\n\t * @return\n\t */\n\tprotected boolean checkRequired(MethodParameter parameter) {\n\t\treturn (parameter.getParameterAnnotation(RequestBody.class).required() && !parameter.isOptional());\n\t}\n\n\t/**\n\t * 处理@ResponseBody注解的返回值\n\t *\n\t * @param returnValue the value returned from the handler method\n\t * @param returnType the type of the return value. This type must have\n\t * previously been passed to {@link #supportsReturnType} which must\n\t * have returned {@code true}.\n\t * @param mavContainer the ModelAndViewContainer for the current request\n\t * @param webRequest the current request\n\t * @throws IOException\n\t * @throws HttpMediaTypeNotAcceptableException\n\t * @throws HttpMessageNotWritableException\n\t */\n\t@Override\n\tpublic void handleReturnValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tmavContainer.setRequestHandled(true);\n\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\n\t\t// Try even with null return value. ResponseBodyAdvice could get involved.\n\t\twriteWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n\t}\n\n}\n```\n\n### 2.1.1 处理被@RequestBody注解的参数解析\n\n* 参数解析需要关注此类是怎么实现的`HandlerMethodArgumentResolver`接口的\n\n```java\npublic interface HandlerMethodArgumentResolver {\n\n\t/**\n\t * 是否支持\n\t *\n\t * Whether the given {@linkplain MethodParameter method parameter} is\n\t * supported by this resolver.\n\t * @param parameter the method parameter to check\n\t * @return {@code true} if this resolver supports the supplied parameter;\n\t * {@code false} otherwise\n\t */\n\tboolean supportsParameter(MethodParameter parameter);\n\n\t/**\n\t * 根据request解析方法参数值\n\t *\n\t * Resolves a method parameter into an argument value from a given request.\n\t * A {@link ModelAndViewContainer} provides access to the model for the\n\t * request. A {@link WebDataBinderFactory} provides a way to create\n\t * a {@link WebDataBinder} instance when needed for data binding and\n\t * type conversion purposes.\n\t * @param parameter the method parameter to resolve. This parameter must\n\t * have previously been passed to {@link #supportsParameter} which must\n\t * have returned {@code true}.\n\t * @param mavContainer the ModelAndViewContainer for the current request\n\t * @param webRequest the current request\n\t * @param binderFactory a factory for creating {@link WebDataBinder} instances\n\t * @return the resolved argument value, or {@code null}\n\t * @throws Exception in case of errors with the preparation of argument values\n\t */\n\tObject resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;\n\n}\n```\n\n* 查看`boolean supportsParameter(MethodParameter parameter);`方法的实现，实现很简单就是判断是否使用了`@RequestBody`注解\n\n```java\n\t/**\n\t * 检测参数是否使用了@RequestBody注解\n\t *\n\t * @param parameter the method parameter to check\n\t * @return\n\t */\n\t@Override\n\tpublic boolean supportsParameter(MethodParameter parameter) {\n\t\treturn parameter.hasParameterAnnotation(RequestBody.class);\n\t}\n```\n\n* 查看`public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) ` 方法的实现\n\n```java\n\t/**\n\t * 处理被@RequestBody注解的参数\n\t *\n\t * Throws MethodArgumentNotValidException if validation fails.\n\t * @throws HttpMessageNotReadableException if {@link RequestBody#required()}\n\t * is {@code true} and there is no body content or if there is no suitable\n\t * converter to read the content with.\n\t */\n\t@Override\n\tpublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tparameter = parameter.nestedIfOptional();\n\t\t// 主体逻辑\n\t\tObject arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());\n\t\tString name = Conventions.getVariableNameForParameter(parameter);\n\n\t\tWebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);\n\t\tif (arg != null) {\n\t\t\t// 校验参数是否正确 @Valid注解开启\n\t\t\tvalidateIfApplicable(binder, parameter);\n\t\t\tif (binder.getBindingResult().hasErrors() && isBindExceptionRequired(binder, parameter)) {\n\t\t\t\tthrow new MethodArgumentNotValidException(parameter, binder.getBindingResult());\n\t\t\t}\n\t\t}\n\t\tmavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());\n\t\treturn adaptArgumentIfNecessary(arg, parameter);\n\t}\n```\n\n* 进入`Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());` \n\n```java\n\t@Override\n\tprotected <T> Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter,\n\t\t\tType paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tHttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);\n\t\tServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest);\n\t    // 主体逻辑\n\t\tObject arg = readWithMessageConverters(inputMessage, parameter, paramType);\n\t\tif (arg == null) {\n\t\t\tif (checkRequired(parameter)) {\n\t\t\t\tthrow new HttpMessageNotReadableException(\"Required request body is missing: \" +\n\t\t\t\t\t\tparameter.getMethod().toGenericString());\n\t\t\t}\n\t\t}\n\t\treturn arg;\n\t}\n```\n\n* 继续进入`Object arg = readWithMessageConverters(inputMessage, parameter, paramType);` ，可以看到是遍历 `this.messageConverters` ，通过`canRead`方法判断转换器是否支持对参数的转换，然后执行`read`方法完成转换。\n\n```java\n\t/**\n\t * Create the method argument value of the expected parameter type by reading\n\t * from the given HttpInputMessage.\n\t * @param <T> the expected type of the argument value to be created\n\t * @param inputMessage the HTTP input message representing the current request\n\t * @param parameter the method parameter descriptor (may be {@code null})\n\t * @param targetType the target type, not necessarily the same as the method\n\t * parameter type, e.g. for {@code HttpEntity<String>}.\n\t * @return the created method argument value\n\t * @throws IOException if the reading from the request fails\n\t * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,\n\t\t\tType targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {\n\n\t\tMediaType contentType;\n\t\tboolean noContentType = false;\n\t\ttry {\n\t\t\tcontentType = inputMessage.getHeaders().getContentType();\n\t\t}\n\t\tcatch (InvalidMediaTypeException ex) {\n\t\t\tthrow new HttpMediaTypeNotSupportedException(ex.getMessage());\n\t\t}\n\t\tif (contentType == null) {\n\t\t\tnoContentType = true;\n\t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n\t\t}\n\n\t\tClass<?> contextClass = (parameter != null ? parameter.getContainingClass() : null);\n\t\tClass<T> targetClass = (targetType instanceof Class ? (Class<T>) targetType : null);\n\t\tif (targetClass == null) {\n\t\t\tResolvableType resolvableType = (parameter != null ?\n\t\t\t\t\tResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType));\n\t\t\ttargetClass = (Class<T>) resolvableType.resolve();\n\t\t}\n\n\t\tHttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod();\n\t\tObject body = NO_VALUE;\n\n\t\ttry {\n\t\t\tinputMessage = new EmptyBodyCheckingHttpInputMessage(inputMessage);\n\n\t\t\t// 遍历 this.messageConverters 选择适合的消息处理器来处理参数\n\t\t\tfor (HttpMessageConverter<?> converter : this.messageConverters) {\n\t\t\t\tClass<HttpMessageConverter<?>> converterType = (Class<HttpMessageConverter<?>>) converter.getClass();\n\t\t\t\tif (converter instanceof GenericHttpMessageConverter) {\n\t\t\t\t\tGenericHttpMessageConverter<?> genericConverter = (GenericHttpMessageConverter<?>) converter;\n\t\t\t\t\t// 判断是否适合处理参数\n\t\t\t\t\tif (genericConverter.canRead(targetType, contextClass, contentType)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (inputMessage.getBody() != null) {\n\t\t\t\t\t\t\tinputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);\n\t\t\t\t\t\t\tbody = genericConverter.read(targetType, contextClass, inputMessage);\n\t\t\t\t\t\t\tbody = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbody = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (targetClass != null) {\n\t\t\t\t\tif (converter.canRead(targetClass, contentType)) {\n\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\tlogger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (inputMessage.getBody() != null) {\n\t\t\t\t\t\t\tinputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType);\n\t\t\t\t\t\t\tbody = ((HttpMessageConverter<T>) converter).read(targetClass, inputMessage);\n\t\t\t\t\t\t\tbody = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tbody = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\"I/O error while reading input message\", ex);\n\t\t}\n\n\t\tif (body == NO_VALUE) {\n\t\t\tif (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) ||\n\t\t\t\t\t(noContentType && inputMessage.getBody() == null)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes);\n\t\t}\n\n\t\treturn body;\n\t}\n```\n\n* 查看`this.messageConverters`有哪些呢？见下图\n\n![](/images/server/spring/spring-mvc/MessageConverters.jpg)\n\n* 下图是主要`MessageConverter`的功能介绍\n\n![](/images/server/spring/spring-mvc/MessageConverter.png)\n\n### 2.1.2 处理被@ResponseBody注解的返回值解析\n\n* 返回值解析需要关注此类是怎样实现`HandlerMethodArgumentResolver`接口的方法的\n\n```java\npublic interface HandlerMethodReturnValueHandler {\n\n\t/**\n\t * 是否支持\n\t *\n\t * Whether the given {@linkplain MethodParameter method return type} is\n\t * supported by this handler.\n\t * @param returnType the method return type to check\n\t * @return {@code true} if this handler supports the supplied return type;\n\t * {@code false} otherwise\n\t */\n\tboolean supportsReturnType(MethodParameter returnType);\n\n\t/**\n\t * 处理结果集\n\t *\n\t * Handle the given return value by adding attributes to the model and\n\t * setting a view or setting the\n\t * {@link ModelAndViewContainer#setRequestHandled} flag to {@code true}\n\t * to indicate the response has been handled directly.\n\t * @param returnValue the value returned from the handler method\n\t * @param returnType the type of the return value. This type must have\n\t * previously been passed to {@link #supportsReturnType} which must\n\t * have returned {@code true}.\n\t * @param mavContainer the ModelAndViewContainer for the current request\n\t * @param webRequest the current request\n\t * @throws Exception if the return value handling results in an error\n\t */\n\tvoid handleReturnValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;\n\n}\n```\n\n* 查看`boolean supportsReturnType(MethodParameter returnType);`的方法的实现，实现也很简单就是判断是否使用了`@ResponseBody`注解\n\n```java\n\t/**\n\t * 检测返回结果是否使用了@ResponseBody注解\n\t *\n\t * @param returnType the method return type to check\n\t * @return\n\t */\n\t@Override\n\tpublic boolean supportsReturnType(MethodParameter returnType) {\n\t\treturn (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) ||\n\t\t\t\treturnType.hasMethodAnnotation(ResponseBody.class));\n\t}\n```\n* 查看`public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)`的实现\n```java\n\t/**\n\t * 处理@ResponseBody注解的返回值\n\t *\n\t * @param returnValue the value returned from the handler method\n\t * @param returnType the type of the return value. This type must have\n\t * previously been passed to {@link #supportsReturnType} which must\n\t * have returned {@code true}.\n\t * @param mavContainer the ModelAndViewContainer for the current request\n\t * @param webRequest the current request\n\t * @throws IOException\n\t * @throws HttpMediaTypeNotAcceptableException\n\t * @throws HttpMessageNotWritableException\n\t */\n\t@Override\n\tpublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)\n\t\t\tthrows IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {\n\n\t\tmavContainer.setRequestHandled(true);\n\t\tServletServerHttpRequest inputMessage = createInputMessage(webRequest);\n\t\tServletServerHttpResponse outputMessage = createOutputMessage(webRequest);\n\n\t\t// Try even with null return value. ResponseBodyAdvice could get involved.\n\t\twriteWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);\n\t}\n```\n\n\n### 2.1.3 HttpMessageConverter\n\n* `HttpMessageConverter`接口定义了5个方法，用于将`HTTP`请求报文转换为`Java`对象，以及将`Java`对象转换为`HTTP`响应报文。 对应到`SpringMVC`的`Controller`方法，`read`方法即是读取`HTTP`请求转换为参数对象，`write`方法即是将返回值对象转换为`HTTP`响应报文。\n\n* 代码：\n\n```java\n/**\n * Strategy interface that specifies a converter that can convert from and to HTTP requests and responses.\n *\n * @author Arjen Poutsma\n * @author Juergen Hoeller\n * @since 3.0\n */\npublic interface HttpMessageConverter<T> {\n\n\t/**\n\t * 当前转换器是否能将HTTP报文转换为对象类型\n\t *\n\t * Indicates whether the given class can be read by this converter.\n\t * @param clazz the class to test for readability\n\t * @param mediaType the media type to read (can be {@code null} if not specified);\n\t * typically the value of a {@code Content-Type} header.\n\t * @return {@code true} if readable; {@code false} otherwise\n\t */\n\tboolean canRead(Class<?> clazz, MediaType mediaType);\n\n\t/**\n\t * 当前转换器是否能将对象类型转换为HTTP报文\n\t *\n\t * Indicates whether the given class can be written by this converter.\n\t * @param clazz the class to test for writability\n\t * @param mediaType the media type to write (can be {@code null} if not specified);\n\t * typically the value of an {@code Accept} header.\n\t * @return {@code true} if writable; {@code false} otherwise\n\t */\n\tboolean canWrite(Class<?> clazz, MediaType mediaType);\n\n\t/**\n\t * 转换器能支持的HTTP媒体类型\n\t *\n\t * Return the list of {@link MediaType} objects supported by this converter.\n\t * @return the list of supported media types\n\t */\n\tList<MediaType> getSupportedMediaTypes();\n\n\t/**\n\t * 转换HTTP报文为特定类型\n\t *\n\t * Read an object of the given type from the given input message, and returns it.\n\t * @param clazz the type of object to return. This type must have previously been passed to the\n\t * {@link #canRead canRead} method of this interface, which must have returned {@code true}.\n\t * @param inputMessage the HTTP input message to read from\n\t * @return the converted object\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotReadableException in case of conversion errors\n\t */\n\tT read(Class<? extends T> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException;\n\n\t/**\n\t * 将特定类型对象转换为HTTP报文\n\t *\n\t * Write an given object to the given output message.\n\t * @param t the object to write to the output message. The type of this object must have previously been\n\t * passed to the {@link #canWrite canWrite} method of this interface, which must have returned {@code true}.\n\t * @param contentType the content type to use when writing. May be {@code null} to indicate that the\n\t * default content type of the converter must be used. If not {@code null}, this media type must have\n\t * previously been passed to the {@link #canWrite canWrite} method of this interface, which must have\n\t * returned {@code true}.\n\t * @param outputMessage the message to write to\n\t * @throws IOException in case of I/O errors\n\t * @throws HttpMessageNotWritableException in case of conversion errors\n\t */\n\tvoid write(T t, MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException;\n\n}\n```\n\n![](/images/server/spring/spring-mvc/requesBody.png)\n\n* `Spring MVC`定义了两个接口来操作这两个过程，参数解析器和返回值处理器在底层处理时，都是通过`HttpMessageConverter`进行转换。流程如下：\n    * 参数解析器`HandlerMethodArgumentResolver`\n    * 返回值处理器`HandlerMethodReturnValueHandler`\n\n* 下图是`HttpMessageConverter`的工作流程图\n \n![](/images/server/spring/spring-mvc/HttpMessageConverter.png)\n\n\n* 在`Spring mvc`启动时默认会加载下面的几种`HttpMessageConverter`，相关代码在`org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport中的addDefaultHttpMessageConverters`\n\n```java\n/**\n * Adds a set of default HttpMessageConverter instances to the given list.\n * Subclasses can call this method from {@link #configureMessageConverters(List)}.\n * @param messageConverters the list to add the default message converters to\n */\nprotected final void addDefaultHttpMessageConverters(List<HttpMessageConverter<?>> messageConverters) {\n    StringHttpMessageConverter stringConverter = new StringHttpMessageConverter();\n    stringConverter.setWriteAcceptCharset(false);\n\n    messageConverters.add(new ByteArrayHttpMessageConverter());\n    messageConverters.add(stringConverter);\n    messageConverters.add(new ResourceHttpMessageConverter());\n    messageConverters.add(new SourceHttpMessageConverter<Source>());\n    messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\n    if (romePresent) {\n        messageConverters.add(new AtomFeedHttpMessageConverter());\n        messageConverters.add(new RssChannelHttpMessageConverter());\n    }\n\n    if (jackson2XmlPresent) {\n        ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.xml().applicationContext(this.applicationContext).build();\n        messageConverters.add(new MappingJackson2XmlHttpMessageConverter(objectMapper));\n    }\n    else if (jaxb2Present) {\n        messageConverters.add(new Jaxb2RootElementHttpMessageConverter());\n    }\n\n    if (jackson2Present) {\n        ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json().applicationContext(this.applicationContext).build();\n        messageConverters.add(new MappingJackson2HttpMessageConverter(objectMapper));\n    }\n    else if (gsonPresent) {\n        messageConverters.add(new GsonHttpMessageConverter());\n    }\n}\n```\n\n## 3.1 总结\n\n* 我们知道，`Http`请求和响应报文本质上都是一串字符串，当请求报文来到`Java`世界，它会被封装成为一个`ServletInputStream`的输入流，供我们读取报文。响应报文则是通过一个`ServletOutputStream`的输出流，来输出响应报文，我们得到输入输出流之后需要把它转成我们的`Java`实体类对象，这个是怎样转换的呢，就是通过我们的`HttpMessageConverter`消息转换器来实现的\n\n\n\n## 4.1 参考\n\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\nhttps://my.oschina.net/lichhao/blog/172562\n\nhttp://www.chinacion.cn/article/608.html","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(九)方法参数解析器HandlerMethodArgumentResolver","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(九)方法参数解析器HandlerMethodArgumentResolver/","content":"## 1.1 前言\n\n* 回顾上一章节的方法参数解析器的入口，可以看到`Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);`这行代码是获取方法参数值，这里是返回的是个数组， `getMethodArgumentValues(request, mavContainer, providedArgs)`里面的逻辑就是遍历每一个参数进行解析\n\n```java\n// org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest\npublic Object invokeForRequest(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,\n        Object... providedArgs) throws Exception {\n\n    // 1、这里得到了方法参数值\n    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n    if (logger.isTraceEnabled()) {\n        logger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n                \"' with arguments \" + Arrays.toString(args));\n    }\n    // 2、传入方法参数值并执行方法\n    Object returnValue = doInvoke(args);\n    if (logger.isTraceEnabled()) {\n        logger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n                \"] returned [\" + returnValue + \"]\");\n    }\n    // 3、返回结果\n    return returnValue;\n}\n\n/**\n * 根据当前请求获取方法的请求参数\n * Get the method argument values for the current request.\n * 先是判断相应类型的参数已经在providedArgs中提供了，如果有的话就是直接返回，否则则使用argumentResolvers解析\n *\n */\nprivate Object[] getMethodArgumentValues(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,\n        Object... providedArgs) throws Exception {\n    // 获取方法的参数，在HanderMethod中\n    MethodParameter[] parameters = getMethodParameters();\n    // 用于保存解析出参数的值\n    Object[] args = new Object[parameters.length];\n    // 遍历每一个参数进行解析\n    for (int i = 0; i < parameters.length; i++) {\n        MethodParameter parameter = parameters[i];\n        // 给Parameter设置参数名解析器\n        parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n        // 如果相应类型的参数已经在providedArgs中提供了，则直接设置到parameter\n        args[i] = resolveProvidedArgument(parameter, providedArgs);\n        if (args[i] != null) {\n            continue;\n        }\n        if (this.argumentResolvers.supportsParameter(parameter)) {\n            try {\n                // 使用argumentResolvers解析参数\n                args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n                continue;\n            }\n            catch (Exception ex) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(getArgumentResolutionErrorMessage(\"Failed to resolve\", i), ex);\n                }\n                throw ex;\n            }\n        }\n        // 解析不出来，抛异常\n        if (args[i] == null) {\n            throw new IllegalStateException(\"Could not resolve method parameter at index \" +\n                    parameter.getParameterIndex() + \" in \" + parameter.getMethod().toGenericString() +\n                    \": \" + getArgumentResolutionErrorMessage(\"No suitable resolver for\", i));\n        }\n    }\n    return args;\n}\n```\n\n* `Spring Mvc`的方法参数解析是交给`HandlerMethodArgumentResolver`来实现的，由下面可以看到是这个接口就两个方法，第一个方法是判断解析器是否支持该参数，第二个方法是根据`request`并将`http`的请求参数解析为`Java Bean`\n\n```java\n/**\n * 方法参数解析器\n *\n * Strategy interface for resolving method parameters into argument values in\n * the context of a given request.\n *\n * @author Arjen Poutsma\n * @since 3.1\n * @see HandlerMethodReturnValueHandler\n */\npublic interface HandlerMethodArgumentResolver {\n\n\t/**\n\t * 是否支持\n\t *\n\t * Whether the given {@linkplain MethodParameter method parameter} is\n\t * supported by this resolver.\n\t * @param parameter the method parameter to check\n\t * @return {@code true} if this resolver supports the supplied parameter;\n\t * {@code false} otherwise\n\t */\n\tboolean supportsParameter(MethodParameter parameter);\n\n\t/**\n\t * 根据request解析方法参数值\n\t *\n\t * Resolves a method parameter into an argument value from a given request.\n\t * A {@link ModelAndViewContainer} provides access to the model for the\n\t * request. A {@link WebDataBinderFactory} provides a way to create\n\t * a {@link WebDataBinder} instance when needed for data binding and\n\t * type conversion purposes.\n\t * @param parameter the method parameter to resolve. This parameter must\n\t * have previously been passed to {@link #supportsParameter} which must\n\t * have returned {@code true}.\n\t * @param mavContainer the ModelAndViewContainer for the current request\n\t * @param webRequest the current request\n\t * @param binderFactory a factory for creating {@link WebDataBinder} instances\n\t * @return the resolved argument value, or {@code null}\n\t * @throws Exception in case of errors with the preparation of argument values\n\t */\n\tObject resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;\n\n}\n```\n\n* 通过调试可以看到有下面这些`argumentResolvers`，看类名称是不是很熟悉，就是我们平常使用的`@RequestBody` `@RequestParam` 是一一对应的，还是专人做专事，可以得出不同的参数是有不同的参数解析组件来专门处理的\n\n![](/images/server/spring/spring-mvc/argumentResolvers.jpg)\n\n* 下面来看主要`XXXArgumentResolver`的作用\n\n```java\n1. SessionAttributeMethodArgumentResolver\n    针对 被 @SessionAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_SESSION)    \n2. RequestParamMethodArgumentResolver\n    针对被 @RequestParam 注解修饰, 但类型不是 Map, 或类型是 Map, 并且 @RequestParam 中指定 name, 一般通过 MultipartHttpServletRequest | HttpServletRequest 获取数据\n3. RequestHeaderMethodArgumentResolver\n    针对 参数被 RequestHeader 注解, 并且 参数不是 Map 类型, 数据通过 HttpServletRequest.getHeaderValues(name) 获取\n4. RequestAttributeMethodArgumentResolver\n    针对 被 @RequestAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_REQUEST)\n5. PathVariableMethodArgumentResolver\n    解决被注解 @PathVariable 注释的参数 <- 这个注解对应的是 uri 中的数据, 在解析 URI 中已经进行解析好了 <- 在 RequestMappingInfoHandlerMapping.handleMatch -> getPathMatcher().extractUriTemplateVariables\n6. MatrixVariableMethodArgumentResolver\n    针对被 @MatrixVariable 注解修饰的参数起作用,  从 HttpServletRequest 中获取去除 ; 的 URI Template Variables 获取数据\n7. ExpressionValueMethodArgumentResolver\n    针对被 @Value 修饰, 返回 ExpressionValueNamedValueInfo\n8. ServletCookieValueMethodArgumentResolver\n    针对被 @CookieValue 修饰, 通过 HttpServletRequest.getCookies 获取对应数据\n```\n\n## 2.1 解析\n\n#### 2.1.1 PathVariableMethodArgumentResolver\n\n* 这个`ArgumentResolver`解析类是解析被注解 `@PathVariable` 注释的参数，这个注解会把`url`上面的值解析到对应的方法参数上，比如下面的例子，参数`id`会解析为`1`，参数`name`会解析为`name`\n\n```java\n// http://127.0.0.1/user/view/1/songsy\n\n@GetMapping(\"/view/{id}/{name}\")\npublic ResponseMO view(@PathVariable Integer id, @PathVariable String name) {\n    IUser iUser = userService.selectByPrimaryKey(id);\n    iUser.setUsername(name);\n    return success(iUser);\n}\n```\n\n* 下面来看`Spring MVC`是怎样把`url`上面的值解析到对应的方法参数上，首先要获取`url`上面的值，那么是在哪里获取的呢？，回顾之前的`org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod`方法，这个方法是查找当前`request`请求 最为匹配的处理方法`HandlerMethod`，如果有多个匹配结果，则选择最佳匹配结果\n\n```java\n/**\n * 查找当前request请求 最为匹配的处理方法HandlerMethod，如果有多个匹配结果，则选择最佳匹配结果\n *\n * Look up the best-matching handler method for the current request.\n * If multiple matches are found, the best match is selected.\n * @param lookupPath mapping lookup path within the current servlet mapping\n * @param request the current request\n * @return the best-matching handler method, or {@code null} if no match\n * @see #handleMatch(Object, String, HttpServletRequest)\n * @see #handleNoMatch(Set, String, HttpServletRequest)\n */\nprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {\n    List<Match> matches = new ArrayList<Match>();\n    // 根据URL来获取,springMVC会在初始化的时候建立URL和相应RequestMappingInfo的映射。如果不是restful接口，这里就可以直接获取到了\n    List<T> directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);\n    if (directPathMatches != null) {\n        // 匹配校验 根据directPathMatches获取到List<Match> matches中\n        addMatchingMappings(directPathMatches, matches, request);\n    }\n    if (matches.isEmpty()) {\n        // 全盘扫描\n        // No choice but to go through all mappings...\n        addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);\n    }\n    // 得到匹配结果\n    if (!matches.isEmpty()) {\n        Comparator<Match> comparator = new MatchComparator(getMappingComparator(request));\n        Collections.sort(matches, comparator);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Found \" + matches.size() + \" matching mapping(s) for [\" +\n                    lookupPath + \"] : \" + matches);\n        }\n        Match bestMatch = matches.get(0);\n        if (matches.size() > 1) {\n            if (CorsUtils.isPreFlightRequest(request)) {\n                return PREFLIGHT_AMBIGUOUS_MATCH;\n            }\n            Match secondBestMatch = matches.get(1);\n            // 如果最佳匹配 第二佳匹配都是同一个则报错\n            if (comparator.compare(bestMatch, secondBestMatch) == 0) {\n                Method m1 = bestMatch.handlerMethod.getMethod();\n                Method m2 = secondBestMatch.handlerMethod.getMethod();\n                throw new IllegalStateException(\"Ambiguous handler methods mapped for HTTP path '\" +\n                        request.getRequestURL() + \"': {\" + m1 + \", \" + m2 + \"}\");\n            }\n        }\n        // 设置HttpServletRequest值 如解析url上的属性值\n        handleMatch(bestMatch.mapping, lookupPath, request);\n        return bestMatch.handlerMethod;\n    }\n    else {\n        // 没有找到匹配，返回null\n        return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);\n    }\n}\n```\n\n* 关注`handleMatch(bestMatch.mapping, lookupPath, request);`方法，看注释可以看到是`Expose URI template variables`，这里主要是对`HttpServletRequest`进行`setAttribute`\n\n```java\n/**\n * Expose URI template variables, matrix variables, and producible media types in the request.\n * @see HandlerMapping#URI_TEMPLATE_VARIABLES_ATTRIBUTE\n * @see HandlerMapping#MATRIX_VARIABLES_ATTRIBUTE\n * @see HandlerMapping#PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE\n */\n@Override\nprotected void handleMatch(RequestMappingInfo info, String lookupPath, HttpServletRequest request) {\n    super.handleMatch(info, lookupPath, request);\n\n    String bestPattern;\n    Map<String, String> uriVariables;\n    Map<String, String> decodedUriVariables;\n\n    Set<String> patterns = info.getPatternsCondition().getPatterns();\n    if (patterns.isEmpty()) {\n        bestPattern = lookupPath;\n        uriVariables = Collections.emptyMap();\n        decodedUriVariables = Collections.emptyMap();\n    }\n    else {\n        bestPattern = patterns.iterator().next();\n        // 获取url上的参数值\n        uriVariables = getPathMatcher().extractUriTemplateVariables(bestPattern, lookupPath);\n        decodedUriVariables = getUrlPathHelper().decodePathVariables(request, uriVariables);\n    }\n\n    request.setAttribute(BEST_MATCHING_PATTERN_ATTRIBUTE, bestPattern);\n    request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, decodedUriVariables);\n\n    if (isMatrixVariableContentAvailable()) {\n        Map<String, MultiValueMap<String, String>> matrixVars = extractMatrixVariables(request, uriVariables);\n        request.setAttribute(HandlerMapping.MATRIX_VARIABLES_ATTRIBUTE, matrixVars);\n    }\n\n    if (!info.getProducesCondition().getProducibleMediaTypes().isEmpty()) {\n        Set<MediaType> mediaTypes = info.getProducesCondition().getProducibleMediaTypes();\n        request.setAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE, mediaTypes);\n    }\n}\n```\n\n* 注意下面这个方法，可以看到是获取了`url`上面的参数值封装为`Map<String, String>`并赋值到`request`中\n\n```java\nMap<String, String> uriVariables;\nMap<String, String> decodedUriVariables;\n\n...\n\n// 获取url上的参数值\nuriVariables = getPathMatcher().extractUriTemplateVariables(bestPattern, lookupPath);\ndecodedUriVariables = getUrlPathHelper().decodePathVariables(request, uriVariables);\n\n... \n\nrequest.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, decodedUriVariables);\n```\n\n* 到这里`HttpServletRequest`已经有参数值了，现在是如何赋值到对应的参数中，这里我们的`PathVariableMethodArgumentResolver`就发挥作用了\n\n![](/images/server/spring/analysis/mvc/PathVariableMethodArgumentResolver.png)\n\n* 我们关注它是怎么实现`HandlerMethodArgumentResolver`接口的两个方法的\n    * `supportsParameter()`方法\n        * 代码如下，可以看到是看参数值有没有被`PathVariable`注解修饰\n        ```java\n        @Override\n        public boolean supportsParameter(MethodParameter parameter) {\n            if (!parameter.hasParameterAnnotation(PathVariable.class)) {\n                return false;\n            }\n            if (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {\n                String paramName = parameter.getParameterAnnotation(PathVariable.class).value();\n                return StringUtils.hasText(paramName);\n            }\n            return true;\n        }\n        ```\n    * `resolveArgument()`方法\n        * 代码如下\n        ```java\n        @Override\n        public final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n                NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n    \n    \n            NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);\n            MethodParameter nestedParameter = parameter.nestedIfOptional();\n    \n            // 获取参数名\n            Object resolvedName = resolveStringValue(namedValueInfo.name);\n            if (resolvedName == null) {\n                throw new IllegalArgumentException(\n                        \"Specified name must not resolve to null: [\" + namedValueInfo.name + \"]\");\n            }\n    \n            // 根据参数名获取参数值\n            Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);\n            if (arg == null) {\n                if (namedValueInfo.defaultValue != null) {\n                    arg = resolveStringValue(namedValueInfo.defaultValue);\n                }\n                else if (namedValueInfo.required && !nestedParameter.isOptional()) {\n                    handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);\n                }\n                arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());\n            }\n            else if (\"\".equals(arg) && namedValueInfo.defaultValue != null) {\n                arg = resolveStringValue(namedValueInfo.defaultValue);\n            }\n    \n            if (binderFactory != null) {\n                WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);\n                try {\n                    arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);\n                }\n                catch (ConversionNotSupportedException ex) {\n                    throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),\n                            namedValueInfo.name, parameter, ex.getCause());\n                }\n                catch (TypeMismatchException ex) {\n                    throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),\n                            namedValueInfo.name, parameter, ex.getCause());\n    \n                }\n            }\n    \n            handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);\n    \n            return arg;\n        }\n        ```\n#### 2.1.1 RequestParamMethodArgumentResolver\n\n#### 2.1.1 RequestAttributeMethodArgumentResolver\n\n## 3.1 总结\n\n* `HandlerMethodArgumentResolver` 的方法参数绑定处理是针对于不同的方法参数有专门的`ArgumentResolver` 专人做专事，专业\n\n## 4.1 参考\n\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\n","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(八)RequestMappingHandlerAdapter","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(八)RequestMappingHandlerAdapter/","content":"## 1.1 前言\n\n* `RequestMappingHandlerAdapter`是 `HanlderAdapter` 中最复杂的也是最常用的处理适配器，他的作用是根据`HanlderMapping`找到的`Handler`调用我们`Controller` 里的方法\n\n* 既然是调用方法我们推测它的工作应该主要设及3步: \n    * 1、方法参数绑定\n    * 2、方法执行\n    * 3、返回结果处理   \n* 方法执行的流程已经在代码里写好了，重点是参数绑定及结果处理，各个方法参数类型不同个数不同，想想就复杂，下面来看人家是怎么做的\n\n## 2.1 RequestMappingHandlerAdapter初始化解析\n\n* 查看`RequestMappingHandlerAdapter`的继承关系\n\n![](/images/server/spring/spring-mvc/RequestMappingHandlerAdapter.png)\n\n> RequestMappingHandlerAdapter.java\n\n```java\n/**\n * An {@link AbstractHandlerMethodAdapter} that supports {@link HandlerMethod}s\n * with their method argument and return type signature, as defined via\n * {@code @RequestMapping}.\n *\n * <p>Support for custom argument and return value types can be added via\n * {@link #setCustomArgumentResolvers} and {@link #setCustomReturnValueHandlers}.\n * Or alternatively, to re-configure all argument and return value types,\n * use {@link #setArgumentResolvers} and {@link #setReturnValueHandlers}.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n * @see HandlerMethodArgumentResolver\n * @see HandlerMethodReturnValueHandler\n */\npublic class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter\n\t\timplements BeanFactoryAware, InitializingBean {\n\n\tprivate List<HandlerMethodArgumentResolver> customArgumentResolvers;\n\n\t// 用于给处理器方法和注释了@ModelAttribute的方法设置参数\n\tprivate HandlerMethodArgumentResolverComposite argumentResolvers;\n\n\t// 用于添加了@initBinder的方法设置参数\n\tprivate HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;\n\n\tprivate List<HandlerMethodReturnValueHandler> customReturnValueHandlers;\n\n\t// 用于将处理器的返回值处理为ModelAndView类型\n\tprivate HandlerMethodReturnValueHandlerComposite returnValueHandlers;\n\n\tprivate List<ModelAndViewResolver> modelAndViewResolvers;\n\n\tprivate ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager();\n\n\tprivate List<HttpMessageConverter<?>> messageConverters;\n\n\tprivate List<Object> requestResponseBodyAdvice = new ArrayList<Object>();\n\n\tprivate WebBindingInitializer webBindingInitializer;\n\n\tprivate AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(\"MvcAsync\");\n\n\tprivate Long asyncRequestTimeout;\n\n\tprivate CallableProcessingInterceptor[] callableInterceptors = new CallableProcessingInterceptor[0];\n\n\tprivate DeferredResultProcessingInterceptor[] deferredResultInterceptors = new DeferredResultProcessingInterceptor[0];\n\n\tprivate boolean ignoreDefaultModelOnRedirect = false;\n\n\tprivate int cacheSecondsForSessionAttributeHandlers = 0;\n\n\tprivate boolean synchronizeOnSession = false;\n\n\tprivate SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\tprivate ConfigurableBeanFactory beanFactory;\n\n\n\tprivate final Map<Class<?>, SessionAttributesHandler> sessionAttributesHandlerCache =\n\t\t\tnew ConcurrentHashMap<Class<?>, SessionAttributesHandler>(64);\n\n\tprivate final Map<Class<?>, Set<Method>> initBinderCache = new ConcurrentHashMap<Class<?>, Set<Method>>(64);\n\n\tprivate final Map<ControllerAdviceBean, Set<Method>> initBinderAdviceCache =\n\t\t\tnew LinkedHashMap<ControllerAdviceBean, Set<Method>>();\n\n\tprivate final Map<Class<?>, Set<Method>> modelAttributeCache = new ConcurrentHashMap<Class<?>, Set<Method>>(64);\n\n\tprivate final Map<ControllerAdviceBean, Set<Method>> modelAttributeAdviceCache =\n\t\t\tnew LinkedHashMap<ControllerAdviceBean, Set<Method>>();\n\n\n\tpublic RequestMappingHandlerAdapter() {\n\t\tStringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();\n\t\tstringHttpMessageConverter.setWriteAcceptCharset(false);  // see SPR-7316\n\n\t\tthis.messageConverters = new ArrayList<HttpMessageConverter<?>>(4);\n\t\tthis.messageConverters.add(new ByteArrayHttpMessageConverter());\n\t\tthis.messageConverters.add(stringHttpMessageConverter);\n\t\tthis.messageConverters.add(new SourceHttpMessageConverter<Source>());\n\t\tthis.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n\t}\n\n```\n\n* 可以看到实现了`InitializingBean`接口，这个方法注册了`this.argumentResolvers` `this.initBinderArgumentResolvers` `this.returnValueHandlers`\n\n```java\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\t// Do this first, it may add ResponseBody advice beans\n\t\tinitControllerAdviceCache();\n\n\t\tif (this.argumentResolvers == null) {\n\t\t\tList<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n\t\t\tthis.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n\t\t}\n\t\tif (this.initBinderArgumentResolvers == null) {\n\t\t\tList<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();\n\t\t\tthis.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n\t\t}\n\t\tif (this.returnValueHandlers == null) {\n\t\t\tList<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n\t\t\tthis.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n\t\t}\n\t}\n```\n\n* 例如`getDefaultArgumentResolvers方法`，可以看到是直接写死了有那些默认的参数解析组件\n\n```java\n\t/**\n\t * Return the list of argument resolvers to use including built-in resolvers\n\t * and custom resolvers provided via {@link #setCustomArgumentResolvers}.\n\t */\n\tprivate List<HandlerMethodArgumentResolver> getDefaultArgumentResolvers() {\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));\n\t\tresolvers.add(new RequestParamMapMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.PathVariableMapMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMapMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(false));\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));\n\t\tresolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory()));\n\t\tresolvers.add(new RequestHeaderMapMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver(getBeanFactory()));\n\t\tresolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.SessionAttributeMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestAttributeMethodArgumentResolver());\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletResponseMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RedirectAttributesMethodArgumentResolver());\n\t\tresolvers.add(new ModelMethodProcessor());\n\t\tresolvers.add(new MapMethodProcessor());\n\t\tresolvers.add(new ErrorsMethodArgumentResolver());\n\t\tresolvers.add(new SessionStatusMethodArgumentResolver());\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.UriComponentsBuilderMethodArgumentResolver());\n\n\t\t// Custom arguments\n\t\tif (getCustomArgumentResolvers() != null) {\n\t\t\tresolvers.addAll(getCustomArgumentResolvers());\n\t\t}\n\n\t\t// Catch-all\n\t\tresolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));\n\t\tresolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(true));\n\n\t\treturn resolvers;\n\t}\n\n```\n\n## 2.2 处理解析\n\n* 查看 `RequestMappingHandlerAdapter` 类是怎么实现的`HandlerAdapter`接口的`handle`方法的，由下面代码可以看到是转到了`handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod) `这个方法来处理，进入该方法\n\n```java\n    // org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle\n\t@Override\n\tpublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn handleInternal(request, response, (HandlerMethod) handler);\n\t}\n\n    // org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handleInternal\n\t@Override\n\tprotected ModelAndView handleInternal(HttpServletRequest request,\n\t\t\t\t\t\t\t\t\t\t  HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\t\tModelAndView mav;\n\t\t// 检查是否支持当前的请求，如果不支持则抛出异常\n\t\tcheckRequest(request);\n\t\t// Execute invokeHandlerMethod in synchronized block if required.\n\t\tif (this.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\tsynchronized (mutex) {\n\t\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// No HttpSession available -> no mutex necessary\n\t\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t\t}\n\t\t} else {\n\t\t\t// 具体执行请求的处理\n\t\t\t// No synchronization on session demanded at all...\n\t\t\tmav = invokeHandlerMethod(request, response, handlerMethod);\n\t\t}\n\t\tif (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n\t\t\tif (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n\t\t\t\tapplyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n\t\t\t} else {\n\t\t\t\tprepareResponse(response);\n\t\t\t}\n\t\t}\n\t\treturn mav;\n\t}\n```\n\n* 关注`mav = invokeHandlerMethod(request, response, handlerMethod);`方法，进入该方法之后可以看到该方法主要是一些参数准备及组装各种处理单元，先备兵粮\n\n```java\n\t/**\n\t * Invoke the {@link RequestMapping} handler method preparing a {@link ModelAndView}\n\t * if view resolution is required.\n\t * @since 4.2\n\t * @see #createInvocableHandlerMethod(HandlerMethod)\n\t */\n\tprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n\t\tServletWebRequest webRequest = new ServletWebRequest(request, response);\n\t\ttry {\n\t\t\t// 创建WebDataBinder，WebDataBinder用于参数绑定，将符合条件的注释了@InitBinder的方法找出来\n\t\t\tWebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n\t\t\t// 用来处理Model，在处理器具体处理之前对Model进行初始化，在处理完请求之后对Model参数进行更新\n\t\t\tModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n\t\t\t// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成\n\t\t\torg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n\t\t\tinvocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n\t\t\tinvocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n\t\t\tinvocableMethod.setDataBinderFactory(binderFactory);\n\t\t\tinvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\n\t\t\t// ModelAndViewContainer承载着整个请求过程中数据的传递工作\n\t\t\tModelAndViewContainer mavContainer = new ModelAndViewContainer();\n\t\t\tmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n\t\t\tmodelFactory.initModel(webRequest, mavContainer, invocableMethod);\n\t\t\tmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\n\t\t\tAsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n\t\t\tasyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n\t\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\t\t\tasyncManager.setTaskExecutor(this.taskExecutor);\n\t\t\tasyncManager.setAsyncWebRequest(asyncWebRequest);\n\t\t\tasyncManager.registerCallableInterceptors(this.callableInterceptors);\n\t\t\tasyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\n\t\t\tif (asyncManager.hasConcurrentResult()) {\n\t\t\t\tObject result = asyncManager.getConcurrentResult();\n\t\t\t\tmavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\n\t\t\t\tasyncManager.clearConcurrentResult();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Found concurrent result value [\" + result + \"]\");\n\t\t\t\t}\n\t\t\t\tinvocableMethod = invocableMethod.wrapConcurrentResult(result);\n\t\t\t}\n\t\t\t// 执行方法\n\t\t\tinvocableMethod.invokeAndHandle(webRequest, mavContainer);\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn getModelAndView(mavContainer, modelFactory, webRequest);\n\t\t}\n\t\tfinally {\n\t\t\twebRequest.requestCompleted();\n\t\t}\n\t}\n```\n\n* 这个方法重点关注`ServletInvocableHandlerMethod`此对象，该类继承自`HandlerMethod`，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成\n\n```java\n// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成\norg.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\ninvocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\ninvocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\ninvocableMethod.setDataBinderFactory(binderFactory);\ninvocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n```\n\n* 查看上面代码可以看到这里设置了参数解析器 结果解析器 等等\n\n* `ServletInvocableHandlerMethod` 解析\n\n    * 先查看`ServletInvocableHandlerMethod`的继承关系，此类的继承关系有三层\n        \n    ![](/images/server/spring/spring-mvc/ServletInvocableHandlerMethod.png)\n    \n    * 顶层`HandlerMethod`类，该类封装了方法调用相关信息，比如是属于哪个`bean`下的的，那个`Method`，方法的参数`MethodParameter[]`等等\n    ```java\n        /**\n         * 封装了方法调用相关信息,子类还提供调用,参数准备和返回值处理的职责\n         * \n         * Encapsulates information about a handler method consisting of a\n         * {@linkplain #getMethod() method} and a {@linkplain #getBean() bean}.\n         * Provides convenient access to method parameters, the method return value,\n         * method annotations, etc.\n         *\n         * <p>The class may be created with a bean instance or with a bean name\n         * (e.g. lazy-init bean, prototype bean). Use {@link #createWithResolvedBean()}\n         * to obtain a {@code HandlerMethod} instance with a bean instance resolved\n         * through the associated {@link BeanFactory}.\n         *\n         * @author Arjen Poutsma\n         * @author Rossen Stoyanchev\n         * @author Juergen Hoeller\n         * @author Sam Brannen\n         * @since 3.1\n         */\n        public class HandlerMethod {\n        \n            /** Logger that is available to subclasses */\n            protected final Log logger = LogFactory.getLog(getClass());\n        \n            private final Object bean;\n        \n            private final BeanFactory beanFactory;\n        \n            private final Class<?> beanType;\n        \n            private final Method method;\n        \n            private final Method bridgedMethod;\n        \n            /**\n             * 方法的参数\n             */\n            private final MethodParameter[] parameters;\n        \n            private HttpStatus responseStatus;\n        \n            private String responseStatusReason;\n        \n            private HandlerMethod resolvedFromHandlerMethod;\n          \n            ...\n    ```\n    * `InvocableHandlerMethod` 类 `HandlerMethod`类的基础上添加了方法调用功能及注册了参数解析组件\n    ```java\n        /**\n         * 在 HandlerMethod类的基础上添加了方法调用功能及注册了参数解析组件\n         *\n         * Provides a method for invoking the handler method for a given request after resolving its\n         * method argument values through registered {@link HandlerMethodArgumentResolver}s.\n         *\n         * <p>Argument resolution often requires a {@link WebDataBinder} for data binding or for type\n         * conversion. Use the {@link #setDataBinderFactory(WebDataBinderFactory)} property to supply\n         * a binder factory to pass to argument resolvers.\n         *\n         * <p>Use {@link #setHandlerMethodArgumentResolvers} to customize the list of argument resolvers.\n         *\n         * @author Rossen Stoyanchev\n         * @author Juergen Hoeller\n         * @since 3.1\n         */\n        public class InvocableHandlerMethod extends HandlerMethod {\n        \n            /**\n             * 用于参数解析器ArgumentResolver\n             */\n            private WebDataBinderFactory dataBinderFactory;\n        \n            /**\n             * 解析参数\n             */\n            private org.springframework.web.method.support.HandlerMethodArgumentResolverComposite argumentResolvers = new org.springframework.web.method.support.HandlerMethodArgumentResolverComposite();\n        \n            /**\n             * 用来获取参数名\n             */\n            private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n        \n        \n            /**\n             * Create an instance from a {@code HandlerMethod}.\n             */\n            public InvocableHandlerMethod(HandlerMethod handlerMethod) {\n                super(handlerMethod);\n            }\n            \n            ...\n    ```\n* 得到`ServletInvocableHandlerMethod` 对象之后进入到`ServletInvocableHandlerMethod` 类的`invocableMethod.invokeAndHandle(webRequest, mavContainer);` 方法，可以说这个方法是`RequestMappingHandlerAdapter`的核心方法，可以看到`Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);` 是执行了方法体，得到`returnValue` 之后就是调用`this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);`该方法处理结果对象\n\n```java\n\t/**\n\t * Invoke the method and handle the return value through one of the\n\t * configured {@link HandlerMethodReturnValueHandler}s.\n\t * @param webRequest the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type (not resolved)\n\t */\n\tpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\t\tsetResponseStatus(webRequest);\n\n\t\tif (returnValue == null) {\n\t\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n\t\t\t\tmavContainer.setRequestHandled(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.hasText(getResponseStatusReason())) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tmavContainer.setRequestHandled(false);\n\t\ttry {\n\t\t\tthis.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(getReturnValueHandlingErrorMessage(\"Error handling return value\", returnValue), ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n```\n\n* 进入`Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);` 方法，可以看到该方法很简单，先是得到方法参数`Object[] args`，然后执行`Object returnValue = doInvoke(args);` 该方法得到结果\n\n```java\n\t/**\n\t * Invoke the method after resolving its argument values in the context of the given request.\n\t * <p>Argument values are commonly resolved through {@link HandlerMethodArgumentResolver}s.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution. Examples of provided argument values include a\n\t * {@link WebDataBinder}, a {@link SessionStatus}, or a thrown exception instance.\n\t * Provided argument values are checked before argument resolvers.\n\t * @param request the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @exception Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t */\n\tpublic Object invokeForRequest(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\t// 1、这里得到了方法参数值\n\t\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n\t\t\t\t\t\"' with arguments \" + Arrays.toString(args));\n\t\t}\n\t\t// 2、传入方法参数值并执行方法\n\t\tObject returnValue = doInvoke(args);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n\t\t\t\t\t\"] returned [\" + returnValue + \"]\");\n\t\t}\n\t\t// 3、返回结果\n\t\treturn returnValue;\n\t}\n```\n\n### 2.1.1 方法参数绑定\n\n* 方法参数的绑定需要关注`Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);` 这行代码，先进入该方法，可以看到该方法先是判断相应类型的参数已经在`providedArgs`中提供了，如果有的话就是直接返回，否则则使用`argumentResolvers`解析\n\n```java\n\t/**\n\t * 根据当前请求获取方法的请求参数\n\t * Get the method argument values for the current request.\n\t *\n\t */\n\tprivate Object[] getMethodArgumentValues(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\t\t// 获取方法的参数，在HanderMethod中\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\t// 用于保存解析出参数的值\n\t\tObject[] args = new Object[parameters.length];\n\t\t// 遍历每一个参数进行解析\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\t// 给Parameter设置参数名解析器\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\t// 如果相应类型的参数已经在providedArgs中提供了，则直接设置到parameter\n\t\t\targs[i] = resolveProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.argumentResolvers.supportsParameter(parameter)) {\n\t\t\t\ttry {\n\t\t\t\t\t// 使用argumentResolvers解析参数\n\t\t\t\t\targs[i] = this.argumentResolvers.resolveArgument(\n\t\t\t\t\t\t\tparameter, mavContainer, request, this.dataBinderFactory);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(getArgumentResolutionErrorMessage(\"Failed to resolve\", i), ex);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 解析不出来，抛异常\n\t\t\tif (args[i] == null) {\n\t\t\t\tthrow new IllegalStateException(\"Could not resolve method parameter at index \" +\n\t\t\t\t\t\tparameter.getParameterIndex() + \" in \" + parameter.getMethod().toGenericString() +\n\t\t\t\t\t\t\": \" + getArgumentResolutionErrorMessage(\"No suitable resolver for\", i));\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}\n```\n* 在`RequestMappingHandlerAdapter`中只有`argumentResolvers`解析，因为`invocableMethod.invokeAndHandle(webRequest, mavContainer);` 只传了两个参数，到了`Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);` 方法之后也是没有传入`providedArgs`的，由上面代码可以看到先是调用`supportsParameter()`方法判断当前解析器是否支持这个参数解析，如果支持的话就是调用`resolveArgument()`方法来解析，这两个方法都是`HandlerMethodArgumentResolver`接口的方法\n\n* `argumentResolvers` 存放在`HandlerMethodArgumentResolverComposite` 类中，所有的`ArgumentResolver`都存放在`List<HandlerMethodArgumentResolver> argumentResolvers`中，也可以看到该类也做了一个`argumentResolverCacheCache`缓存处理，也是为了性能\n\n```java\n/**\n * HandlerMethodArgumentResolver 的仓库\n * \n * Resolves method parameters by delegating to a list of registered {@link HandlerMethodArgumentResolver}s.\n * Previously resolved method parameters are cached for faster lookups.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 3.1\n */\npublic class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final List<HandlerMethodArgumentResolver> argumentResolvers =\n\t\t\tnew LinkedList<HandlerMethodArgumentResolver>();\n\n\tprivate final Map<MethodParameter, HandlerMethodArgumentResolver> argumentResolverCache =\n\t\t\tnew ConcurrentHashMap<MethodParameter, HandlerMethodArgumentResolver>(256);\n\n\n\t/**\n\t * Add the given {@link HandlerMethodArgumentResolver}.\n\t */\n\tpublic HandlerMethodArgumentResolverComposite addResolver(HandlerMethodArgumentResolver resolver) {\n\t\tthis.argumentResolvers.add(resolver);\n\t\treturn this;\n\t}\n```\n\n* 通过调试可以看到有下面这些`argumentResolvers`，看类名称是不是很熟悉，就是我们平常使用的`@RequestBody` `@RequestParam` 是一一对应的，还是专人做专事，可以得出不同的参数是有不同的参数解析组件来专门处理的\n\n![](/images/server/spring/spring-mvc/argumentResolvers.jpg)\n\n* 下面来看主要`XXXArgumentResolver`的作用\n\n```java\n1. SessionAttributeMethodArgumentResolver\n    针对 被 @SessionAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_SESSION)    \n2. RequestParamMethodArgumentResolver\n    针对被 @RequestParam 注解修饰, 但类型不是 Map, 或类型是 Map, 并且 @RequestParam 中指定 name, 一般通过 MultipartHttpServletRequest | HttpServletRequest 获取数据\n3. RequestHeaderMethodArgumentResolver\n    针对 参数被 RequestHeader 注解, 并且 参数不是 Map 类型, 数据通过 HttpServletRequest.getHeaderValues(name) 获取\n4. RequestAttributeMethodArgumentResolver\n    针对 被 @RequestAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_REQUEST)\n5. PathVariableMethodArgumentResolver\n    解决被注解 @PathVariable 注释的参数 <- 这个注解对应的是 uri 中的数据, 在解析 URI 中已经进行解析好了 <- 在 RequestMappingInfoHandlerMapping.handleMatch -> getPathMatcher().extractUriTemplateVariables\n6. MatrixVariableMethodArgumentResolver\n    针对被 @MatrixVariable 注解修饰的参数起作用,  从 HttpServletRequest 中获取去除 ; 的 URI Template Variables 获取数据\n7. ExpressionValueMethodArgumentResolver\n    针对被 @Value 修饰, 返回 ExpressionValueNamedValueInfo\n8. ServletCookieValueMethodArgumentResolver\n    针对被 @CookieValue 修饰, 通过 HttpServletRequest.getCookies 获取对应数据\n```\n\n* 然后进入`HandlerMethodArgumentResolverComposite`类的`args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);` 方法，可以看到逻辑十分简单，就是遍历`this.argumentResolvers` 然后做了个缓存处理，得到`HandlerMethodArgumentResolver`之后就是调用`resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);`方法了，该方法是参数解析的主体方法\n\n```java\n\t/**\n\t * 迭代注册过的 HandlerMethodArgumentResolver, 然后找到对应的ArgumentResolver\n\t * Iterate over registered {@link HandlerMethodArgumentResolver}s and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodArgumentResolver} is found.\n\t */\n\t@Override\n\tpublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {\n\n\t\tHandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);\n\t\tif (resolver == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown parameter type [\" + parameter.getParameterType().getName() + \"]\");\n\t\t}\n\t\treturn resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);\n\t}\n\n\t/**\n\t * 先从缓存里取，没有的再遍历，注意这里是先来先得的\n\t * Find a registered {@link HandlerMethodArgumentResolver} that supports the given method parameter.\n\t */\n\tprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n\t\tHandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\n\t\tif (result == null) {\n\t\t\tfor (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Testing if argument resolver [\" + methodArgumentResolver + \"] supports [\" +\n\t\t\t\t\t\t\tparameter.getGenericParameterType() + \"]\");\n\t\t\t\t}\n\t\t\t\tif (methodArgumentResolver.supportsParameter(parameter)) {\n\t\t\t\t\tresult = methodArgumentResolver;\n\t\t\t\t\tthis.argumentResolverCache.put(parameter, result);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n```\n\n* 再来回顾`HandlerMethodArgumentResolver`接口，该接口就两个方法\n\n```java\n/**\n * 方法参数解析器\n *\n * Strategy interface for resolving method parameters into argument values in\n * the context of a given request.\n *\n * @author Arjen Poutsma\n * @since 3.1\n * @see HandlerMethodReturnValueHandler\n */\npublic interface HandlerMethodArgumentResolver {\n\n\t/**\n\t * 是否支持\n\t *\n\t * Whether the given {@linkplain MethodParameter method parameter} is\n\t * supported by this resolver.\n\t * @param parameter the method parameter to check\n\t * @return {@code true} if this resolver supports the supplied parameter;\n\t * {@code false} otherwise\n\t */\n\tboolean supportsParameter(MethodParameter parameter);\n\n\t/**\n\t * 根据request解析方法参数值\n\t *\n\t * Resolves a method parameter into an argument value from a given request.\n\t * A {@link ModelAndViewContainer} provides access to the model for the\n\t * request. A {@link WebDataBinderFactory} provides a way to create\n\t * a {@link WebDataBinder} instance when needed for data binding and\n\t * type conversion purposes.\n\t * @param parameter the method parameter to resolve. This parameter must\n\t * have previously been passed to {@link #supportsParameter} which must\n\t * have returned {@code true}.\n\t * @param mavContainer the ModelAndViewContainer for the current request\n\t * @param webRequest the current request\n\t * @param binderFactory a factory for creating {@link WebDataBinder} instances\n\t * @return the resolved argument value, or {@code null}\n\t * @throws Exception in case of errors with the preparation of argument values\n\t */\n\tObject resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;\n\n}\n```\n* `HandlerMethodArgumentResolver`的 `resolveArgument` 的解析将在之后的章节介绍\n\n### 2.2.2 方法执行\n\n* 回到`InvocableHandlerMethod`类的`invokeForRequest` 方法，上一小节介绍了方法参数绑定的主体逻辑(`Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);`)，这一小节介绍`Object returnValue = doInvoke(args);`，该行代码是方法执行的主体方法\n\n```java\n\tpublic Object invokeForRequest(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\t// 1、这里得到了方法参数值\n\t\tObject[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n\t\t\t\t\t\"' with arguments \" + Arrays.toString(args));\n\t\t}\n\t\t// 2、传入方法参数值并执行方法\n\t\tObject returnValue = doInvoke(args);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n\t\t\t\t\t\"] returned [\" + returnValue + \"]\");\n\t\t}\n\t\t// 3、返回结果\n\t\treturn returnValue;\n\t}\n```\n\n* 进入`Object returnValue = doInvoke(args);` 方法，可以看到调用了`getBridgedMethod().invoke(getBean(), args);` 来执行方法，`getBridgedMethod()` 得到的是`private final Method bridgedMethod`，百度了一下这个桥接方法的用途是为了和jdk1.5之前的字节码兼容. 因为范型是在jdk1.5之后才引入的. 在jdk1.5之前例如集合的操作都是没有范型支持的, 所以生成的字节码中参数都是用Object接收的, 所以也可以往集合中放入任意类型的对象, 集合类型的校验也被拖到运行期.\n\n```java\n\t/**\n\t * Invoke the handler method with the given argument values.\n\t */\n\tprotected Object doInvoke(Object... args) throws Exception {\n\t\t// 强制将他变为可调用 即使是private方法\n\t\tReflectionUtils.makeAccessible(getBridgedMethod());\n\t\ttry {\n\t\t\treturn getBridgedMethod().invoke(getBean(), args);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\tString text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\tthrow new IllegalStateException(getInvocationErrorMessage(text, args), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Unwrap for HandlerExceptionResolvers ...\n\t\t\tThrowable targetException = ex.getTargetException();\n\t\t\tif (targetException instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException) targetException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Error) {\n\t\t\t\tthrow (Error) targetException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Exception) {\n\t\t\t\tthrow (Exception) targetException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString text = getInvocationErrorMessage(\"Failed to invoke handler method\", args);\n\t\t\t\tthrow new IllegalStateException(text, targetException);\n\t\t\t}\n\t\t}\n\t}\n```\n* 在此方法执行完成\n\n### 2.2.3 返回结果处理\n\n* 方法执行完成之后就对返回结果的处理了，回到`ServletInvocableHandlerMethod`类，现在方法体已经执行了，就是对结果对象的处理了\n\n```java\n\t/**\n\t * Invoke the method and handle the return value through one of the\n\t * configured {@link HandlerMethodReturnValueHandler}s.\n\t * @param webRequest the current request\n\t * @param mavContainer the ModelAndViewContainer for this request\n\t * @param providedArgs \"given\" arguments matched by type (not resolved)\n\t */\n\tpublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n\t\t\tObject... providedArgs) throws Exception {\n\n\t\tObject returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n\t\tsetResponseStatus(webRequest);\n\n\t\tif (returnValue == null) {\n\t\t\tif (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n\t\t\t\tmavContainer.setRequestHandled(true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse if (StringUtils.hasText(getResponseStatusReason())) {\n\t\t\tmavContainer.setRequestHandled(true);\n\t\t\treturn;\n\t\t}\n\n\t\tmavContainer.setRequestHandled(false);\n\t\ttry {\n\t\t\tthis.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(getReturnValueHandlingErrorMessage(\"Error handling return value\", returnValue), ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n```\n\n* 查看上面的代码可以看到`this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);` 这行代码作用是对结果对象的处理，查看`returnValueHandlers` 对象（`private HandlerMethodReturnValueHandlerComposite returnValueHandlers;`）可以看到和我们之前的参数绑定的处理是相似的，`HandlerMethodReturnValueHandlerComposite`存放了各种结果处理组件\n\n> HandlerMethodReturnValueHandlerComposite.java\n\n```java\n\n/**\n * Handles method return values by delegating to a list of registered {@link HandlerMethodReturnValueHandler}s.\n * Previously resolved return types are cached for faster lookups.\n *\n * @author Rossen Stoyanchev\n * @since 3.1\n */\npublic class HandlerMethodReturnValueHandlerComposite implements AsyncHandlerMethodReturnValueHandler {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\t// 结果处理组件\n\tprivate final List<HandlerMethodReturnValueHandler> returnValueHandlers =\n\t\tnew ArrayList<HandlerMethodReturnValueHandler>();\n```\n\n> HandlerMethodReturnValueHandler.java\n\n```java\n/**\n * 结果对象处理\n *\n * Strategy interface to handle the value returned from the invocation of a\n * handler method .\n *\n * @author Arjen Poutsma\n * @since 3.1\n * @see HandlerMethodArgumentResolver\n */\npublic interface HandlerMethodReturnValueHandler {\n\n\t/**\n\t * 是否支持\n\t * \n\t * Whether the given {@linkplain MethodParameter method return type} is\n\t * supported by this handler.\n\t * @param returnType the method return type to check\n\t * @return {@code true} if this handler supports the supplied return type;\n\t * {@code false} otherwise\n\t */\n\tboolean supportsReturnType(MethodParameter returnType);\n\n\t/**\n\t * 处理结果集\n\t * \n\t * Handle the given return value by adding attributes to the model and\n\t * setting a view or setting the\n\t * {@link ModelAndViewContainer#setRequestHandled} flag to {@code true}\n\t * to indicate the response has been handled directly.\n\t * @param returnValue the value returned from the handler method\n\t * @param returnType the type of the return value. This type must have\n\t * previously been passed to {@link #supportsReturnType} which must\n\t * have returned {@code true}.\n\t * @param mavContainer the ModelAndViewContainer for the current request\n\t * @param webRequest the current request\n\t * @throws Exception if the return value handling results in an error\n\t */\n\tvoid handleReturnValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;\n\n}\n\n```\n\n* 进入`handleReturnValue`方法，可以看到和之前方法参数绑定处理是一样的套路的\n\n```java\n\t/**\n\t * 迭代注册过的 HandlerMethodReturnValueHandler, 然后找到对应的ReturnValueHandler\n\t * Iterate over registered {@link HandlerMethodReturnValueHandler}s and invoke the one that supports it.\n\t * @throws IllegalStateException if no suitable {@link HandlerMethodReturnValueHandler} is found.\n\t */\n\t@Override\n\tpublic void handleReturnValue(Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {\n\n\t\tHandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);\n\t\tif (handler == null) {\n\t\t\tthrow new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName());\n\t\t}\n\t\thandler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);\n\t}\n\t\n    private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) {\n        boolean isAsyncValue = isAsyncReturnValue(value, returnType);\n        for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {\n            if (isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {\n                continue;\n            }\n            if (handler.supportsReturnType(returnType)) {\n                return handler;\n            }\n        }\n        return null;\n    }\n```\n\n* 如下图可以看到有如下`this.returnValueHandlers`\n\n![](/images/server/spring/spring-mvc/HandlerComposite.jpg)\n\n## 3.1 总结\n* `RequestMappingHandlerAdapter` 的功能主要是\n    * 1、方法参数绑定\n    * 2、方法执行，\n    * 3、返回结果处理` \n* `HandlerMethodArgumentResolver` 的方法参数绑定处理是针对于不同的方法参数有专门的`ArgumentResolver` 专人做专事，专业\n* `HandlerMethodReturnValueHandler` 的返回结果处理也是和参数处理那样是针对于不同的返回对象有专门的`ReturnValueHandler`\n\n## 4.1 参考\n\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\n","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(七)处理适配器HanlderAdapter","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(七)处理适配器HanlderAdapter/","content":"## 1.1 前言\n* 前几章介绍了`HandlerMapping`处理流程， `HandlerMapping`负责根据`request`请求找到对应的`Handler`处理器及`Interceptor`拦截器，得到处理器`Handler`之后，`Spring MVC` 又根据该`Handler` 找出对应的 `HandlerAdapter`，这一章节来介绍`HandlerAdapter`，`HandlerAdapter`是具体使用`Handler` 来干活的\n\n* 下面还是方法体`doDispatch(HttpServletRequest request, HttpServletResponse response)` 的处理代码，可以看到得到`Handler`处理器之后就是遍历所有的 `HandlerAdapter`，找到可以处理该 `Handler` 的 `HandlerAdapter`，找到之后就是`mv = ha.handle(processedRequest, response, mappedHandler.getHandler());` 调用真正的处理方法了\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n    // 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            // 检查是否是文件上传请求 Multipart，有则将请求转换为 Multipart 请求\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            // Determine handler for the current request.\n            // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null || mappedHandler.getHandler() == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n            \n            // Determine handler adapter for the current request.\n            // 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n            \n            // Process last-modified header, if supported by the handler.\n            // 处理 last-modified 请求头\n            String method = request.getMethod();\n            boolean isGet = \"GET\".equals(method);\n            if (isGet || \"HEAD\".equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n                }\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n                    return;\n                }\n            }\n            // 执行相应拦截器Interceptor的preHandle\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // Actually invoke the handler.\n            // 执行实际的处理程序，执行Controller里的方法\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n## 2.1 处理适配器HanlderAdapter解析\n\n### 2.1.1 HanlderAdapter 解析\n* 先看`HanlderAdapter` 这个接口有哪些方法\n\n```java\n/**\n * Handler 处理适配器, 适配不同的 Handler\n *\n * MVC framework SPI, allowing parameterization of the core MVC workflow.\n *\n * <p>Interface that must be implemented for each handler type to handle a request.\n * This interface is used to allow the {@link DispatcherServlet} to be indefinitely\n * extensible. The {@code DispatcherServlet} accesses all installed handlers through\n * this interface, meaning that it does not contain code specific to any handler type.\n *\n * <p>Note that a handler can be of type {@code Object}. This is to enable\n * handlers from other frameworks to be integrated with this framework without\n * custom coding, as well as to allow for annotation-driven handler objects that\n * do not obey any specific Java interface.\n *\n * <p>This interface is not intended for application developers. It is available\n * to handlers who want to develop their own web workflow.\n *\n * <p>Note: {@code HandlerAdapter} implementors may implement the {@link\n * org.springframework.core.Ordered} interface to be able to specify a sorting\n * order (and thus a priority) for getting applied by the {@code DispatcherServlet}.\n * Non-Ordered instances get treated as lowest priority.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @see org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\n * @see org.springframework.web.servlet.handler.SimpleServletHandlerAdapter\n */\npublic interface HandlerAdapter {\n\n\t/**\n\t * 检测 HandlerAdapter 是否支持这个 handler\n\t *\n\t * Given a handler instance, return whether or not this {@code HandlerAdapter}\n\t * can support it. Typical HandlerAdapters will base the decision on the handler\n\t * type. HandlerAdapters will usually only support one handler type each.\n\t * <p>A typical implementation:\n\t * <p>{@code\n\t * return (handler instanceof MyHandler);\n\t * }\n\t * @param handler handler object to check\n\t * @return whether or not this object can use the given handler\n\t */\n\tboolean supports(Object handler);\n\n\t/**\n\t * 处理 HttpServletRequest 的入口方法\n\t *\n\t * Use the given handler to handle this request.\n\t * The workflow that is required may vary widely.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handler handler to use. This object must have previously been passed\n\t * to the {@code supports} method of this interface, which must have\n\t * returned {@code true}.\n\t * @throws Exception in case of errors\n\t * @return ModelAndView object with the name of the view and the required\n\t * model data, or {@code null} if the request has been handled directly\n\t */\n\tModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;\n\n\t/**\n\t *  获取Http 请求中的lastModifiedTime\n\t *\n\t * Same contract as for HttpServlet's {@code getLastModified} method.\n\t * Can simply return -1 if there's no support in the handler class.\n\t * @param request current HTTP request\n\t * @param handler handler to use\n\t * @return the lastModified value for the given handler\n\t * @see javax.servlet.http.HttpServlet#getLastModified\n\t * @see org.springframework.web.servlet.mvc.LastModified#getLastModified\n\t */\n\tlong getLastModified(HttpServletRequest request, Object handler);\n\n}\n\n```\n\n* 下图是`HanlderAdapter`涉及子类的继承关系，看方法名是不是很熟悉，没错和前几章的`HandlerMapping`是差不多是一一对应的\n\n![image](/images/server/spring/spring-mvc/HandlerAdapter.png)\n\n\n* 查看这些类可以看到除了`RequestMappingHandlerAdapter` 的实现比较复杂之外，其他的`HandlerAdapter`都是调用`Handler`里固定的方法，比如下图的`SimpleControllerHandlerAdapter`\n```java\npublic class SimpleControllerHandlerAdapter implements HandlerAdapter {\n\n\t@Override\n\tpublic boolean supports(Object handler) {\n\t\treturn (handler instanceof Controller);\n\t}\n\n\t@Override\n\tpublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn ((Controller) handler).handleRequest(request, response);\n\t}\n\n\t@Override\n\tpublic long getLastModified(HttpServletRequest request, Object handler) {\n\t\tif (handler instanceof LastModified) {\n\t\t\treturn ((LastModified) handler).getLastModified(request);\n\t\t}\n\t\treturn -1L;\n\t}\n\n}\n```\n\n* 查看`AbstractHandlerMethodAdapter`可以看到内容也很少，`HandlerAdapter` 接口的实现都转发到自己的抽象方法里去了\n\n```java\n/**\n * Abstract base class for {@link HandlerAdapter} implementations that support\n * handlers of type {@link HandlerMethod}.\n *\n * @author Arjen Poutsma\n * @since 3.1\n */\npublic abstract class AbstractHandlerMethodAdapter extends WebContentGenerator implements HandlerAdapter, Ordered {\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE;\n\n\n\tpublic AbstractHandlerMethodAdapter() {\n\t\t// no restriction of HTTP methods by default\n\t\tsuper(false);\n\t}\n\n\n\t/**\n\t * Specify the order value for this HandlerAdapter bean.\n\t * <p>Default value is {@code Integer.MAX_VALUE}, meaning that it's non-ordered.\n\t * @see org.springframework.core.Ordered#getOrder()\n\t */\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn this.order;\n\t}\n\n\n\t/**\n\t * 先判断是否是HandlerMethod，然后转向抽象方法supportsInternal\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t * @param handler the handler instance to check\n\t * @return whether or not this adapter can adapt the given handler\n\t */\n\t@Override\n\tpublic final boolean supports(Object handler) {\n\t\treturn (handler instanceof HandlerMethod && supportsInternal((HandlerMethod) handler));\n\t}\n\n\t/**\n\t * Given a handler method, return whether or not this adapter can support it.\n\t * @param handlerMethod the handler method to check\n\t * @return whether or not this adapter can adapt the given method\n\t */\n\tprotected abstract boolean supportsInternal(HandlerMethod handlerMethod);\n\n\t/**\n\t * 转向抽象方法 handleInternal()\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */\n\t@Override\n\tpublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\treturn handleInternal(request, response, (HandlerMethod) handler);\n\t}\n\n\t/**\n\t * Use the given handler method to handle the request.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @param handlerMethod handler method to use. This object must have previously been passed to the\n\t * {@link #supportsInternal(HandlerMethod)} this interface, which must have returned {@code true}.\n\t * @return ModelAndView object with the name of the view and the required model data,\n\t * or {@code null} if the request has been handled directly\n\t * @throws Exception in case of errors\n\t */\n\tprotected abstract ModelAndView handleInternal(HttpServletRequest request,\n\t\t\tHttpServletResponse response, HandlerMethod handlerMethod) throws Exception;\n\n\t/**\n\t * 转向抽象方法 getLastModifiedInternal()\n\t * This implementation expects the handler to be an {@link HandlerMethod}.\n\t */\n\t@Override\n\tpublic final long getLastModified(HttpServletRequest request, Object handler) {\n\t\treturn getLastModifiedInternal(request, (HandlerMethod) handler);\n\t}\n\n\t/**\n\t * Same contract as for {@link javax.servlet.http.HttpServlet#getLastModified(HttpServletRequest)}.\n\t * @param request current HTTP request\n\t * @param handlerMethod handler method to use\n\t * @return the lastModified value for the given handler\n\t */\n\tprotected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);\n\n}\n```\n### 2.1.2 各个 `HandlerAdapter`作用 \n#### AnnotationMethodHandlerAdapter\n`AnnotationMethodHandlerAdapter`主要是适配注解类处理器，注解类处理器就是我们经常使用的`@Controller`的这类处理器，不过该类已经被`@Deprecated` 标记了（@deprecated as of Spring 3.2, in favor of`） \n\n```java\n@Override\npublic final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return handleInternal(request, response, (HandlerMethod) handler);\n}\n```\n\n####  HttpRequestHandlerAdapter\n`HttpRequestHandlerAdapter` 主要是适配静态资源处理器，静态资源处理器就是实现了`HttpRequestHandler`接口的处理器，这类处理器的作用是处理通过`SpringMVC`来访问的静态资源的请求。\n\n```java\n@Override\npublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    ((HttpRequestHandler) handler).handleRequest(request, response);\n    return null;\n}\n```        \n\n#### SimpleControllerHandlerAdapter\n`SimpleControllerHandlerAdapter` 是`Controller`处理适配器，适配实现了`Controller`接口或`Controller`接口子类的处理器，比如我们经常自己写的`Controller`来继承`MultiActionController`\n\n```java\n@Override\npublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller) handler).handleRequest(request, response);\n}\n```\n\n#### SimpleServletHandlerAdapter\n`SimpleServletHandlerAdapter`是`Servlet`处理适配器,适配实现了`Servlet`接口或`Servlet`的子类的处理器，我们不仅可以在web.xml里面配置Servlet，其实也可以用SpringMVC来配置Servlet，不过这个适配器很少用到，而且SpringMVC默认的适配器没有他，默认的是前面的三种。\n\n```java\n@Override\npublic ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet) handler).service(request, response);\n    return null;\n}\n```\n\n\n### 2.1.3 `HandlerAdapter` 注册过程\n* `HandlerAdapter` 注册过程 和 `HandlerMapping` 的注册过程是一样的，回到`DispatcherServlet` 类中`onRefresh` 方法\n```java\n\t/**\n\t * Initialize the strategy objects that this servlet uses.\n\t * <p>May be overridden in subclasses in order to initialize further strategy objects.\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\t// 上传组件组件初始化\n\t\tinitMultipartResolver(context);\n\t\tinitLocaleResolver(context);\n\t\tinitThemeResolver(context);\n\t\t// 请求映射处理组件初始化\n\t\tinitHandlerMappings(context);\n\t\t// 处理适配器组建初始化\n\t\tinitHandlerAdapters(context);\n\t\t// 异常处理组件初始化\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\t// 视图处理组件初始化\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}\n```\n* 进入`initHandlerAdapters(context);` 从下面代码也可以看到也是通过扫描`HandlerAdapter`类 `bean`的形式来注册`HandlerAdapter`\n```java\n\t/**\n\t * Initialize the HandlerAdapters used by this class.\n\t * <p>If no HandlerAdapter beans are defined in the BeanFactory for this namespace,\n\t * we default to SimpleControllerHandlerAdapter.\n\t */\n\tprivate void initHandlerAdapters(ApplicationContext context) {\n\t\tthis.handlerAdapters = null;\n\n\t\tif (this.detectAllHandlerAdapters) {\n\t\t\t// 加载所有实现了HandlerAdapter接口的bean\n\t\t\t// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.\n\t\t\tMap<String, HandlerAdapter> matchingBeans =\n\t\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n\t\t\tif (!matchingBeans.isEmpty()) {\n\t\t\t\tthis.handlerAdapters = new ArrayList<HandlerAdapter>(matchingBeans.values());\n\t\t\t\t// We keep HandlerAdapters in sorted order.\n\t\t\t\tAnnotationAwareOrderComparator.sort(this.handlerAdapters);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tHandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);\n\t\t\t\tthis.handlerAdapters = Collections.singletonList(ha);\n\t\t\t}\n\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t// Ignore, we'll add a default HandlerAdapter later.\n\t\t\t}\n\t\t}\n\n\t\t// Ensure we have at least some HandlerAdapters, by registering\n\t\t// default HandlerAdapters if no other adapters are found.\n\t\tif (this.handlerAdapters == null) {\n\t\t\tthis.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No HandlerAdapters found in servlet '\" + getServletName() + \"': using default\");\n\t\t\t}\n\t\t}\n\t}\n```\n\n## 3.1 适配器设计模式\n\n* `HanlderAdapter`看后缀名就可以理解它使用了适配器模式\n\n* `Spring MVC`的`handler`有多种形式，由于实现方式不一样， `Handler` 有可能是一个 `HandlerMethod`（封装了 `Controller` 中的方法）对象，也有可能是一个 `Controller` 对象、 `HttpRequestHandler` 对象或 `Servlet` 对象，而这个 `Handler` 具体是什么对象，调用方式就不确定了。\n\n* 如果正常编写调用，就需要使用多个`if else`判断`instance of`，再添加实现方式，就需要修改源码，不符合对扩展开放，对修改关闭原则， 所以针对这种情况设计了`HanlderAdapter`，如果是添加了新的`Handler`只要添加一个新的`HanlderAdapter`就可以完成扩展\n\n## 4.1 总结\n* `HanlderAdapter` 从字面上的意思就是处理适配器，他的作用就是根据用户的请求调用具体的方法，根据`HandlerMapping`传过来`Hanler`与注册好的`HandlerAdapter`一一匹配，如果找到了其中一种`HandlerAdapter`是支持传过来的`controller`类型，那么该`HandlerAdapter`会调用自己的`handle`方法\n* 不同的`HanlderAdapter`可以适应不同的request需求\n\n## 5.1 参考\n\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\nhttps://www.jianshu.com/p/3d6df6b725e4\n\nhttps://blog.csdn.net/weixin_38399962/article/details/85288660","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程/","content":"## 1.1 前言\n* 上一章节介绍了 `RequestMappingHandlerMapping` 这个 `HandlerMapping` 的加载过程，这一章节来介绍`RequestMappingHandlerMapping`实现流程\n\n## 2.1 找到与请求对应的 Handler 解析\n\n* 还是回到这个方法`doDispatch(HttpServletRequest request, HttpServletResponse response)` ，下面的代码是发挥`RequestMappingHandlerMapping`作用的地方\n\n```java\nHandlerExecutionChain mappedHandler = null;\n...\n\n// Determine handler for the current request.\n// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中\nmappedHandler = getHandler(processedRequest);\nif (mappedHandler == null || mappedHandler.getHandler() == null) {\n    noHandlerFound(processedRequest, response);\n    return;\n}\n```\n\n* 进入 `getHandler`方法，这里会遍历到我们的`RequestMappingHandlerMapping` 这个`HandlerMapping`，通过`HandlerExecutionChain handler = hm.getHandler(request);` 得到`HandlerExecutionChain`\n\n```java\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    // 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping\n    for (HandlerMapping hm : this.handlerMappings) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\n                    \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\");\n        }\n        // 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain\n        HandlerExecutionChain handler = hm.getHandler(request);\n        if (handler != null) {\n            // 注意这里是找到第一个就直接返回\n            return handler;\n        }\n    }\n    return null;\n}\n```\n\n* 进入`hm.getHandler(request);` 会跳到我们的`AbstractHandlerMapping` 类中，`RequestMappingHandlerMapping` 继承该类，由下面代码可以看到这里这里获取了 `handler` 及 `Interceptor` 并封装为`HandlerExecutionChain` 返回调用者\n \n```java\n/**\n * Look up a handler for the given request, falling back to the default\n * handler if no specific one is found.\n * @param request current HTTP request\n * @return the corresponding handler instance, or the default handler\n * @see #getHandlerInternal\n */\n@Override\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    // 在这里获取 处理器handler，模板方法实现， RequestMappingHandlerMapping 跳到 AbstractHandlerMethodMapping\n    Object handler = getHandlerInternal(request);\n    if (handler == null) {\n        handler = getDefaultHandler();\n    }\n    if (handler == null) {\n        return null;\n    }\n    // Bean name or resolved handler?\n    if (handler instanceof String) {\n        String handlerName = (String) handler;\n        handler = getApplicationContext().getBean(handlerName);\n    }\n    // 获取 拦截器Interceptor\n    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);\n    if (CorsUtils.isCorsRequest(request)) {\n        CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);\n        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);\n        CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);\n        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);\n    }\n    return executionChain;\n}\n```\n\n* 关注`Object handler = getHandlerInternal(request);` 这里是获取`handler`的地方，这时又会跳到`AbstractHandlerMethodMapping` 类中，这样跳来跳去可以看到封装的特性及使用模板方法提高了扩展性\n\n```java\n/**\n * Look up a handler method for the given request.\n */\n@Override\nprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {\n    // 获取请求url路径 localhost:8080/pub/account/list >>> /pub/account/list\n    String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Looking up handler method for path \" + lookupPath);\n    }\n    // mappingRegistry添加读锁，其他线程只能读不能写\n    this.mappingRegistry.acquireReadLock();\n    try {\n        // 根据request获取对应的HandlerMethod\n        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);\n        if (logger.isDebugEnabled()) {\n            if (handlerMethod != null) {\n                logger.debug(\"Returning handler method [\" + handlerMethod + \"]\");\n            }\n            else {\n                logger.debug(\"Did not find handler method for [\" + lookupPath + \"]\");\n            }\n        }\n        return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);\n    }\n    finally {\n        this.mappingRegistry.releaseReadLock();\n    }\n}\n```\n\n* 关注 `HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);` 这行代码，进入该方法，可以看到这个方法的作用是得到`HandlerMethod`\n\n```java\n/**\n * 查找当前request请求 最为匹配的处理方法HandlerMethod，如果有多个匹配结果，则选择最佳匹配结果\n * Look up the best-matching handler method for the current request.\n * If multiple matches are found, the best match is selected.\n * @param lookupPath mapping lookup path within the current servlet mapping\n * @param request the current request\n * @return the best-matching handler method, or {@code null} if no match\n * @see #handleMatch(Object, String, HttpServletRequest)\n * @see #handleNoMatch(Set, String, HttpServletRequest)\n */\nprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {\n    List<Match> matches = new ArrayList<Match>();\n    // 根据URL来获取,springMVC会在初始化的时候建立URL和相应RequestMappingInfo的映射。如果不是restful接口，这里就可以直接获取到了， lookupPath: /pub/account/list\n    List<T> directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath);\n    if (directPathMatches != null) {\n        // 匹配校验\n        addMatchingMappings(directPathMatches, matches, request);\n    }\n    if (matches.isEmpty()) {\n        // 全盘扫描\n        // No choice but to go through all mappings...\n        addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request);\n    }\n    // 得到匹配结果\n    if (!matches.isEmpty()) {\n        Comparator<Match> comparator = new MatchComparator(getMappingComparator(request));\n        Collections.sort(matches, comparator);\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Found \" + matches.size() + \" matching mapping(s) for [\" +\n                    lookupPath + \"] : \" + matches);\n        }\n        Match bestMatch = matches.get(0);\n        if (matches.size() > 1) {\n            if (CorsUtils.isPreFlightRequest(request)) {\n                return PREFLIGHT_AMBIGUOUS_MATCH;\n            }\n            Match secondBestMatch = matches.get(1);\n            // 如果最佳匹配 第二佳匹配都是同一个则报错\n            if (comparator.compare(bestMatch, secondBestMatch) == 0) {\n                Method m1 = bestMatch.handlerMethod.getMethod();\n                Method m2 = secondBestMatch.handlerMethod.getMethod();\n                throw new IllegalStateException(\"Ambiguous handler methods mapped for HTTP path '\" +\n                        request.getRequestURL() + \"': {\" + m1 + \", \" + m2 + \"}\");\n            }\n        }\n        // 设置HttpServletRequest值\n        handleMatch(bestMatch.mapping, lookupPath, request);\n        return bestMatch.handlerMethod;\n    }\n    else {\n        // 没有找到匹配，返回null\n        return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request);\n    }\n}\n```\n\n* 查看这行代码可以看到是通过url来获取`this.mappingRegistry.getMappingsByUrl(lookupPath);`，进入该方法，可以看到`this.urlLookup`是`MappingRegistry`类中的一个`Map`,直接通过 `url`为`key`得到值\n\n```java\nclass MappingRegistry {\n\n    private final Map<T, MappingRegistration<T>> registry = new HashMap<T, MappingRegistration<T>>();\n\n    private final Map<T, HandlerMethod> mappingLookup = new LinkedHashMap<T, HandlerMethod>();\n\n    private final MultiValueMap<String, T> urlLookup = new LinkedMultiValueMap<String, T>();\n\n    private final Map<String, List<HandlerMethod>> nameLookup =\n            new ConcurrentHashMap<String, List<HandlerMethod>>();\n\n    private final Map<HandlerMethod, CorsConfiguration> corsLookup =\n            new ConcurrentHashMap<HandlerMethod, CorsConfiguration>();\n\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    \n    ...\n    \n\n    */\n    public List<T> getMappingsByUrl(String urlPath) {\n        //  MultiValueMap<String, T> urlLookup 就是个map\n        return this.urlLookup.get(urlPath);\n    }\n```\n\n> 下图是this.urlLookup.get(urlPath) 的到的结果，返回的是个list\n\n![image](/images/server/spring/spring-mvc/getMappingsByUrl.jpg)\n\n* 返回到`lookupHandlerMethod(String lookupPath, HttpServletRequest request)` 方法，这里使用了`Match`做了匹配处理，得到最佳`Match bestMatch` 对象，最后返回`HandlerMethod`，在此终于得到了`HandlerMethod`\n\n* 得到`HandlerMethod`对象之后，返回到`getHandler(HttpServletRequest request)`方法中，下面主要逻辑是整合了`HandlerMethod`及`HandlerInterceptor`并存放在`HandlerExecutionChain`对象\n\n```java\n/**\n * Look up a handler for the given request, falling back to the default\n * handler if no specific one is found.\n * @param request current HTTP request\n * @return the corresponding handler instance, or the default handler\n * @see #getHandlerInternal\n */\n@Override\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    // 在这里获取 处理器handler，模板方法实现， RequestMappingHandlerMapping 跳到 AbstractHandlerMethodMapping\n    Object handler = getHandlerInternal(request);\n    if (handler == null) {\n        handler = getDefaultHandler();\n    }\n    if (handler == null) {\n        return null;\n    }\n    // Bean name or resolved handler?\n    if (handler instanceof String) {\n        String handlerName = (String) handler;\n        handler = getApplicationContext().getBean(handlerName);\n    }\n    // 获取 拦截器Interceptor\n    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);\n    if (CorsUtils.isCorsRequest(request)) {\n        CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request);\n        CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);\n        CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig);\n        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);\n    }\n    return executionChain;\n}\n```\n \n## 3.1 总结\n* `RequestMappingHandlerMapping` 的主要功能就是通过 `reqeust` 获取 `HandlerExecutionChain` 的 `HandlerMethod`、`Interceptor`。\n\n* 下图是`RequestMappingHandlerMapping`工作流程图，可以看到`RequestMappingHandlerMapping` 一个类的实现分了4层，`HandlerMapping` 接口定义顶级方法，两个抽象类又分两次封装，由上而下，逐渐细分功能\n\n![image](/images/server/spring/spring-mvc/RequestMappingInfoHandlerMapping.png)\n\n## 4.1 参考\n\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程/","content":"## 1.1 前言\n\n* 上一章节介绍了请求映射处理组件`HandlerMapping`的主体处理流程，根据`request url` 获取对应的处理器`Handler`，这一章节来详细介绍我们平常最多使用的`RequestMappingHandlerMapping`的加载，这个`HandlerMapping` 是怎样加载基于`@Controller,@RequestMapping` 实现的`Controller`\n\n## 2.1 解析\n\n* 接下来我们关注`RequestMappingHandlerMapping`这个`HandlerMapping`，因为这个是我们开发过程中最为常用的`HandlerMapping`，那么它是怎样实现`HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;` 这个方法，先看一下`RequestMappingHandlerMapping`的继承关系\n\n![image](/images/server/spring/spring-mvc/RequestMappingHandlerMapping.png)\n\n### 2.1.1 `RequestMappingHandlerMapping` 加载过程\n\n* 由上图可以看到`RequestMappingHandlerMapping` 的父类`AbstractHandlerMethodMapping` 实现了`InitializingBean` 接口，`InitializingBean`接口为`bean`提供了初始化方法的方式，它只包括`afterPropertiesSet`方法，凡是继承该接口的类， 在初始化`bean`的时候都会执行该方法。\n\n```java\npublic interface InitializingBean {\n\n\t/**\n\t * Invoked by a BeanFactory after it has set all bean properties supplied\n\t * (and satisfied BeanFactoryAware and ApplicationContextAware).\n\t * <p>This method allows the bean instance to perform initialization only\n\t * possible when all bean properties have been set and to throw an\n\t * exception in the event of misconfiguration.\n\t * @throws Exception in the event of misconfiguration (such\n\t * as failure to set an essential property) or if initialization fails.\n\t */\n\tvoid afterPropertiesSet() throws Exception;\n\n}\n```\n\n* 下面是`Spring Bean`的生命周期图\n\n![](/images/server/spring/analysis/doCreateBean.jpg)\n\n* 查看`AbstractHandlerMethodMapping`类 `afterPropertiesSet()`的实现\n\n```java\n/**\n * Detects handler methods at initialization.\n */\n@Override\npublic void afterPropertiesSet() {\n    initHandlerMethods();\n}\n```\n\n* 又抽象了一个方法，通过方法名可以得到它的用途是初始化`HandlerMethods`，进入`initHandlerMethods();` 方法，这个方法是扫描`ApplicationContext` 所有的`bean`，如果发现了该`bean`所在的类有`@Controller`注解及`@RequestMapping`注解的话，则检查这个类的所有方法，如果是标注了`@RequestMapping`注解的方法则会注册为`HandlerMethod`\n\n```java\n/**\n * Scan beans in the ApplicationContext, detect and register handler methods.\n * @see #isHandler(Class)\n * @see #getMappingForMethod(Method, Class)\n * @see #handlerMethodsInitialized(Map)\n */\nprotected void initHandlerMethods() {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Looking for request mappings in application context: \" + getApplicationContext());\n    }\n    // 首先拿到容器的所有的beanName数组\n    String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?\n            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :\n            getApplicationContext().getBeanNamesForType(Object.class));\n\n    for (String beanName : beanNames) {\n        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n            // 得到bean类型\n            Class<?> beanType = null;\n            try {\n                beanType = getApplicationContext().getType(beanName);\n            }\n            catch (Throwable ex) {\n                // An unresolvable bean type, probably from a lazy bean - let's ignore it.\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Could not resolve target class for bean with name '\" + beanName + \"'\", ex);\n                }\n            }\n            // 检查bean所在的类是否有Controller注解及RequestMapping注解\n            if (beanType != null && isHandler(beanType)) {\n                // 负责将Handler保存到Map里\n                detectHandlerMethods(beanName);\n            }\n        }\n    }\n    // 对Handler进行一些初始化，是一个模板方法\n    handlerMethodsInitialized(getHandlerMethods());\n}\n```\n\n> String[] beanNames 示例\n\n![iamge](/images/server/spring/spring-mvc/beanNames.jpg)\n\n* 进入`isHandler(beanType)`方法，，此方法由`RequestMappingHandlerMapping`实现， 此方法检查`bean`所在的类是否有`@Controller`注解及`@RequestMapping`注解，可以看到此方法的实现是在`RequestMappingHandlerMapping`里，是不是看到了我们熟悉的两个注解\n```java\n/**\n * 检查bean所在的类是否有Controller注解及RequestMapping注解\n * {@inheritDoc}\n * Expects a handler to have a type-level @{@link Controller} annotation.\n */\n@Override\nprotected boolean isHandler(Class<?> beanType) {\n    return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||\n            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));\n}\n```\n\n* 如果该`bean`有 `Controller`注解及`RequestMapping`注解，则执行`detectHandlerMethods(beanName);`方法，下面举个例子，我们有一个`UserController`里面有五个方法，下面来看是怎么处理这个类的\n\n```java\n@RestController\n@RequestMapping(\"/pub/account\")\npublic class UserController {\n\n    @Autowired\n    private UserService userService;\n\n    @GetMapping(\"/list\")\n    public List<User> findAll() {\n        return userService.findAll();\n    }\n\n    @GetMapping(\"/view\")\n    public User view() {\n        return userService.findById(1);\n    }\n\n    @GetMapping(\"/{id}\")\n    public User view(@PathVariable(\"id\") Integer id) {\n        return userService.findById(id);\n    }\n\n    @PostMapping(\"/\")\n    public void updateUser(@RequestBody User user) {\n        User user1 = userService.findById(user.getId());\n        user1.setUsername(\"update\");\n        userService.saveSelective(user1);\n    }\n\n    @DeleteMapping(\"/{id}\")\n    public void deleteUser(@PathVariable(\"id\") Integer id) {\n        userService.logicDeleteOne(id);\n    }\n}\n```\n\n* 进入`detectHandlerMethods(beanName);`方法，可以看到`Map<Method, T> methods = MethodIntrospector.selectMethods` 获取到了我们五个方法，`Map<Method, T> methods` 以`Method`为key，`RequestMappingInfo`为value\n\n![image](/images/server/spring/spring-mvc/detectHandlerMethods.jpg)\n\n```java\n/**\n * Look for handler methods in a handler.\n * @param handler the bean name of a handler or a handler instance\n */\nprotected void detectHandlerMethods(final Object handler) {\n    // 获取Handler的类型\n    Class<?> handlerType = (handler instanceof String ?\n            getApplicationContext().getType((String) handler) : handler.getClass());\n    final Class<?> userType = ClassUtils.getUserClass(handlerType);\n\n    // 这里获取 RequestMapping方法，会过滤掉普通方法\n    Map<Method, T> methods = MethodIntrospector.selectMethods(userType,\n            new MethodIntrospector.MetadataLookup<T>() {\n                @Override\n                public T inspect(Method method) {\n                    try {\n                        return getMappingForMethod(method, userType);\n                    }\n                    catch (Throwable ex) {\n                        throw new IllegalStateException(\"Invalid mapping on handler class [\" +\n                                userType.getName() + \"]: \" + method, ex);\n                    }\n                }\n            });\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(methods.size() + \" request handler methods found on \" + userType + \": \" + methods);\n    }\n    for (Map.Entry<Method, T> entry : methods.entrySet()) {\n        Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);\n        T mapping = entry.getValue();\n        // 注册 mappingRegistry\n        registerHandlerMethod(handler, invocableMethod, mapping);\n    }\n}\n```\n\n* 进入`getMappingForMethod(method, userType)` ，此方法在`RequestMappingHandlerMapping`实现，这里解析分两步解析，一个是方法`method`解析，另一个是方法所在类`handlerType`的解析，然后拼接成一个`RequestMappingInfo`，可以看到也是对`RequestMapping`注解的解析\n\n```java\n/**\n * 没有使用 {@code @RequestMapping} 注解会返回null\n * Uses method and type-level @{@link RequestMapping} annotations to create\n * the RequestMappingInfo.\n * @return the created RequestMappingInfo, or {@code null} if the method\n * does not have a {@code @RequestMapping} annotation.\n * @see #getCustomMethodCondition(Method)\n * @see #getCustomTypeCondition(Class)\n */\n@Override\nprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n    // 解析method的@RequestMapping\n    RequestMappingInfo info = createRequestMappingInfo(method);\n    if (info != null) {\n        // 解析Class的@RequestMapping\n        RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n        if (typeInfo != null) {\n            // 合并两个RequestMappingInfo 比如url拼接\n            info = typeInfo.combine(info);\n        }\n    }\n    // 不是RequestMapping方法返回null\n    return info;\n}\n\n\nprivate RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {\n        // 拿到注解\n        RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);\n        RequestCondition<?> condition = (element instanceof Class ?\n                getCustomTypeCondition((Class<?>) element) : getCustomMethodCondition((Method) element));\n        return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);\n}\n\nprotected RequestMappingInfo createRequestMappingInfo(\n        RequestMapping requestMapping, RequestCondition<?> customCondition) {\n    // 用@RequestMapping的属性生成RequestMappingInfo\n    return RequestMappingInfo\n            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n            .methods(requestMapping.method())\n            .params(requestMapping.params())\n            .headers(requestMapping.headers())\n            .consumes(requestMapping.consumes())\n            .produces(requestMapping.produces())\n            .mappingName(requestMapping.name())\n            .customCondition(customCondition)\n            .options(this.config)\n            .build();\n}\n```\n \n* RequestMappingInfo.java 对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是`@RequestMapping`的一个对应类。\n\n```java\npublic final class RequestMappingInfo implements RequestCondition<RequestMappingInfo> {\n\n\tprivate final String name;\n\n\tprivate final PatternsRequestCondition patternsCondition;\n\n\tprivate final RequestMethodsRequestCondition methodsCondition;\n\n\tprivate final ParamsRequestCondition paramsCondition;\n\n\tprivate final HeadersRequestCondition headersCondition;\n\n\tprivate final ConsumesRequestCondition consumesCondition;\n\n\tprivate final ProducesRequestCondition producesCondition;\n\n\tprivate final RequestConditionHolder customConditionHolder;\n\t\n\t...\n```\n\n* 返回到`detectHandlerMethods`方法\n\n```java\nprotected void detectHandlerMethods(final Object handler) {\n    // 获取Handler的类型\n    Class<?> handlerType = (handler instanceof String ?\n            getApplicationContext().getType((String) handler) : handler.getClass());\n    final Class<?> userType = ClassUtils.getUserClass(handlerType);\n\n    // 这里获取 RequestMapping方法，会过滤掉普通方法\n    Map<Method, T> methods = MethodIntrospector.selectMethods(userType,\n            new MethodIntrospector.MetadataLookup<T>() {\n                @Override\n                public T inspect(Method method) {\n                    try {\n                        return getMappingForMethod(method, userType);\n                    }\n                    catch (Throwable ex) {\n                        throw new IllegalStateException(\"Invalid mapping on handler class [\" +\n                                userType.getName() + \"]: \" + method, ex);\n                    }\n                }\n            });\n    if (logger.isDebugEnabled()) {\n        logger.debug(methods.size() + \" request handler methods found on \" + userType + \": \" + methods);\n    }\n    for (Map.Entry<Method, T> entry : methods.entrySet()) {\n        Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);\n        T mapping = entry.getValue();\n        // 注册 mappingRegistry\n        registerHandlerMethod(handler, invocableMethod, mapping);\n    }\n}\n```\n\n* 得到`Map<Method, T> methods`之后，就是把这些信息保存起来，`registerHandlerMethod(handler, invocableMethod, mapping);` 这行代码就是做的这个功能\n\n```java\nprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n    this.mappingRegistry.register(mapping, handler, method);\n}\n\t\npublic void register(T mapping, Object handler, Method method) {\n    // 加锁\n    this.readWriteLock.writeLock().lock();\n    try {\n        // 创建HandlerMethod\n        HandlerMethod handlerMethod = createHandlerMethod(handler, method);\n        assertUniqueMethodMapping(handlerMethod, mapping);\n\n        if (logger.isInfoEnabled()) {\n            logger.info(\"Mapped \\\"\" + mapping + \"\\\" onto \" + handlerMethod);\n        }\n        this.mappingLookup.put(mapping, handlerMethod);\n\n        List<String> directUrls = getDirectUrls(mapping);\n        for (String url : directUrls) {\n            this.urlLookup.add(url, mapping);\n        }\n\n        String name = null;\n        if (getNamingStrategy() != null) {\n            name = getNamingStrategy().getName(handlerMethod, mapping);\n            addMappingName(name, handlerMethod);\n        }\n\n        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);\n        if (corsConfig != null) {\n            this.corsLookup.put(handlerMethod, corsConfig);\n        }\n        /**\n         * private final Map<T, MappingRegistration<T>> registry = new HashMap<T, MappingRegistration<T>>();\n         * key: RequestMappingInfo\n         */\n        this.registry.put(mapping, new MappingRegistration<T>(mapping, handlerMethod, directUrls, name));\n    }\n    finally {\n        this.readWriteLock.writeLock().unlock();\n    }\n}\n```\n\n* 查看`private final Map<T, MappingRegistration<T>> registry` 对象，见下图`key`值是`RequestMappingInfo` `value`是`MappingRegistration`\n\n![image](/images/server/spring/spring-mvc/registry.jpg)\n\n> MappingRegistration.java\n\n```java\nprivate static class MappingRegistration<T> {\n\n    private final T mapping;\n\n    private final HandlerMethod handlerMethod;\n\n    private final List<String> directUrls;\n\n    private final String mappingName;\n    \n    ...\n```\n\n## 3.1 总结\n\n* `Spring Mvc`提供了各种各样的抽象，你能感受到面向对象的魅力。\n\n    * `RequestMappingInfo` 这个类是对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是`@RequestMapping`的一个对应类。\n\n    * `HandlerMethod`这个类封装了处理器实例`（Controller Bean）`和 处理方法实例`（Method）`以及方法参数数组`（MethodParameter[]）`\n\n    * `MethodParameter`  这个类从`2.0`就有了，它封装了方法某个参数的相关信息及行为，如该参数的索引，该参数所属方法实例或构造器实例，该参数的类型等。\n\n    * `HandlerMapping` 该接口的实现类用来定义请求和处理器之前的映射关系，其中只定义了一个方法`getHandler`。\n\n    * `AbstractHandlerMethodMapping` 这是`HandlerMapping`的一个基本实现类，该类定义了请求与`HandlerMethod`实例的映射关系。\n\n    * `RequestMappingInfoHandlerMapping`这个是`AbstractHandlerMethodMapping`的实现类，他维护了一个`RequestMappingInfo`和`HandlerMethod`的Map属性。\n\n    * `RequestMappingHandlerMapping` 这个是`RequestMappingInfoHandlerMapping`的子类，它将`@RequestMapping`注解转化为`RequestMappingInfo`实例，并为父类使用。也就是我们处理@RequestMapping的终点。\n\n    * `InitializingBean` 这个接口定义了其实现`Bean`在容器完成属性设置后可以执行自定义初始化操作，我们的`AbstractHandlerMethodMapping`便实现了这个接口，并且定义了一组自定义操作，就是用来检测处理我们的`@RequestMapping`注解。\n\n* `RequestMappingHandlerMapping` 这个类的初始化过程主要是构建`private final MappingRegistry mappingRegistry`的过程，用于找出被`@RequestMapping`注解修饰的方法，并构造成`HanderMethod`对象，然后就是放到`MappingRegistry mappingRegistry`对象中，用于根据`request`找到对应的处理方法并调用\n\n## 4.1 参考\n\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\nhttps://www.cnblogs.com/taotingkai/p/8438360.html","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(四)请求映射处理组件HandlerMapping","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping/","content":"## 1.1 前言\n* 上一章节介绍了`Spring Mvc`执行一个普通请求的整体流程，这一章节介绍其请求映射处理组件`HandlerMapping` 的作用\n\n* `HandlerMapping`负责根据`request`请求找到对应的`Handler`处理器及`Interceptor`拦截器,并将它们封装在`HandlerExecutionChain`对象内，返回给中央调度器\n\n\n## 2.1 请求映射处理组件`HandlerMapping` 解析\n\n### 2.1.1 `HandlerMapping` 解析\n* 先来回顾核心方法体`doDispatch(HttpServletRequest request, HttpServletResponse response)`，查看`HandlerMapping` 对应的处理逻辑\n\n```java\n\tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\t\t// 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry {\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry {\n\t\t\t\t// 检查是否有 Multipart，有则将请求转换为 Multipart 请求\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// Determine handler for the current request.\n\t\t\t\t// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null || mappedHandler.getHandler() == null) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Determine handler adapter for the current request.\n\t\t\t\t// 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\t\t// 处理 last-modified 请求头\n\t\t\t\tString method = request.getMethod();\n\t\t\t\tboolean isGet = \"GET\".equals(method);\n\t\t\t\tif (isGet || \"HEAD\".equals(method)) {\n\t\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n\t\t\t\t\t}\n\t\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Actually invoke the handler.\n\t\t\t\t// 执行实际的处理程序\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\t// 遍历拦截器，执行它们的 postHandle() 方法\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n\t\t\t}\n\t\t    // 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew NestedServletException(\"Handler processing failed\", err));\n\t\t}\n\t\tfinally {\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t// Instead of postHandle and afterCompletion\n\t\t\t\t// 遍历拦截器，执行它们的 afterCompletion() 方法\n\t\t\t\tif (mappedHandler != null) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Clean up any resources used by a multipart request.\n\t\t\t\tif (multipartRequestParsed) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n\n\n\n* 下面是请求映射处理组件`HandlerMapping` 主要的处理代码\n```java\n    HandlerExecutionChain mappedHandler = null;\n    ...\n    \n    // Determine handler for the current request.\n    // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中\n    mappedHandler = getHandler(processedRequest);\n    if (mappedHandler == null || mappedHandler.getHandler() == null) {\n        noHandlerFound(processedRequest, response);\n        return;\n    }\n```\n\n* 继续在`doDispatch`方法中`mappedHandler = getHandler(processedRequest);` 这行代码打好断点，进入该方法\n\n```java\n    /** List of HandlerMappings used by this servlet */\n    private List<HandlerMapping> handlerMappings;\n    \n\t/**\n\t * Return the HandlerExecutionChain for this request.\n\t * <p>Tries all handler mappings in order.\n\t * @param request current HTTP request\n\t * @return the HandlerExecutionChain, or {@code null} if no handler could be found\n\t */\n\tprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n\t\t// 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping\n\t\tfor (HandlerMapping hm : this.handlerMappings) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\n\t\t\t\t\t\t\"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t\t// 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain\n\t\t\tHandlerExecutionChain handler = hm.getHandler(request);\n\t\t\tif (handler != null) {\n\t\t\t\t// 注意这里是找到第一个就直接返回\n\t\t\t\treturn handler;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n```\n\n* 可以看到是遍历了`this.handlerMappings`这个对象，这个对象是个`list`， 在调试过程中，我们可以看到，默认加载的是如下图所示的的`HandlerMapping`，\n\n![](/images/server/spring/spring-mvc/HandlerMapping1.jpg)\n\n* `this.handlerMappings`这个对象是怎么初始化的呢\n    * 回顾第二章节的`DispatcherServlet`的`onRefresh(wac);`方法\n    ```java\n    protected void onRefresh(ApplicationContext context) {\n        // initStrategies方法内部会初始化各个策略接口的实现类。\n        initStrategies(context);\n    }\n    protected void initStrategies(ApplicationContext context) {\n        // 上传组件组件初始化\n        initMultipartResolver(context);\n        initLocaleResolver(context);\n        initThemeResolver(context);\n        // 请求映射处理组件初始化\n        initHandlerMappings(context);\n        // 处理适配器组建初始化\n        initHandlerAdapters(context);\n        // 异常处理组件初始化\n        initHandlerExceptionResolvers(context);\n        initRequestToViewNameTranslator(context);\n        // 视图处理组件初始化\n        initViewResolvers(context);\n        initFlashMapManager(context);\n    }\n    ```\n    * 进入`initHandlerMappings(context);` 方法\n    ```java\n        private void initHandlerMappings(ApplicationContext context) {\n            this.handlerMappings = null;\n    \n            if (this.detectAllHandlerMappings) {\n                // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.\n                // 在ApplicationContext bean中找到所有HandlerMappings， beansOfTypeIncludingAncestors 返回给定类型或子类型的所有bean\n                Map<String, HandlerMapping> matchingBeans =\n                        BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n                if (!matchingBeans.isEmpty()) {\n                    this.handlerMappings = new ArrayList<HandlerMapping>(matchingBeans.values());\n                    // We keep HandlerMappings in sorted order.\n                    AnnotationAwareOrderComparator.sort(this.handlerMappings);\n                }\n            }\n            else {\n                try {\n                    HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);\n                    this.handlerMappings = Collections.singletonList(hm);\n                }\n                catch (NoSuchBeanDefinitionException ex) {\n                    // Ignore, we'll add a default HandlerMapping later.\n                }\n            }\n    \n            // Ensure we have at least one HandlerMapping, by registering\n            // a default HandlerMapping if no other mappings are found.\n            if (this.handlerMappings == null) {\n                // 在这里将设置\n                this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\");\n                }\n            }\n        }\n    ```\n    * 关注`this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);` 这行代码，可以看到`this.handlerMappings` 在这里赋值，继续进入该方法\n    ```java\n    protected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {\n        String key = strategyInterface.getName();\n        String value = defaultStrategies.getProperty(key);\n        if (value != null) {\n            String[] classNames = StringUtils.commaDelimitedListToStringArray(value);\n            List<T> strategies = new ArrayList<T>(classNames.length);\n            for (String className : classNames) {\n                try {\n                    Class<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());\n                    Object strategy = createDefaultStrategy(context, clazz);\n                    strategies.add((T) strategy);\n                }\n                catch (ClassNotFoundException ex) {\n                    throw new BeanInitializationException(\n                            \"Could not find DispatcherServlet's default strategy class [\" + className +\n                                    \"] for interface [\" + key + \"]\", ex);\n                }\n                catch (LinkageError err) {\n                    throw new BeanInitializationException(\n                            \"Error loading DispatcherServlet's default strategy class [\" + className +\n                                    \"] for interface [\" + key + \"]: problem with class file or dependent class\", err);\n                }\n            }\n            return strategies;\n           }\n           else {\n               return new LinkedList<T>();\n           }\n       }\n       ```\n    * 从可以看到`String value = defaultStrategies.getProperty(key);` 这里使用了我们的配置对象`private static final Properties defaultStrategies;`\n         * `defaultStrategies` 是哪里初始化的呢？可以看到是在`static`代码块中读取一个配置文件并把它注册为`Properties defaultStrategies`对象\n         ```java\n            /**\n             * Name of the class path resource (relative to the DispatcherServlet class)\n             * that defines DispatcherServlet's default strategy names.\n             */\n            private static final String DEFAULT_STRATEGIES_PATH = \"DispatcherServlet.properties\";\n            \n            ...\n            \n             static {\n                 // Load default strategy implementations from properties file.\n                 // This is currently strictly internal and not meant to be customized\n                 // by application developers.\n                 try {\n                   \t // DEFAULT_STRATEGIES_PATH: DispatcherServlet.properties\n                     ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);\n                     defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n                 }\n                 catch (IOException ex) {\n                     throw new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage());\n                 }\n             }\n            \n         ```\n         * 这里是读取了`DEFAULT_STRATEGIES_PATH`变量，查看变量可以发现是`DispatcherServlet.properties`，所以查看`DispatcherServlet.properties`文件，该文件在`Spring web mvc` 包下\n         ```properties\n         # Default implementation classes for DispatcherServlet's strategy interfaces.\n         # Used as fallback when no matching beans are found in the DispatcherServlet context.\n         # Not meant to be customized by application developers.\n         \n         org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver\n         \n         org.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver\n         \n         org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n            org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n         \n         org.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\n            org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\n            org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\n         \n         org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\\n            org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\\n            org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver\n         \n         org.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\n         \n         org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\n         \n         org.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager\n         ```\n    * 上面配置的了`org.springframework.web.servlet.HandlerMapping`默认有`BeanNameUrlHandlerMapping`及`DefaultAnnotationHandlerMapping`，所以之后执行`createDefaultStrategy` 方法就是根据`Class`对象来创建`bean`\n    ```java\n        protected Object createDefaultStrategy(ApplicationContext context, Class<?> clazz) {\n            return context.getAutowireCapableBeanFactory().createBean(clazz);\n        }\n    ```\n\n* 下面来介绍三种常用的`HandlerMapping`的作用 \n    * `RequestMappingHandlerMapping`是三个中最常用的`handlerMapping`，使用注解方式最为方便快捷，`SpringMvc`项目开发都是采用这种形式，配合`@RequestMapping()`相关注释就可以完成开发\n        ```java\n            <!-- 注册HandlerMapper、HandlerAdapter两个映射类 -->\n            <mvc:annotation-driven />\n             \n            <!-- 访问静态资源 -->\n            <mvc:default-servlet-handler />\n             \n            <!-- 配置扫描的包 -->\n            <context:component-scan base-package=\"com.songsy.*\" />\n   \n            @RestController\n            @RequestMapping(\"/hello\")\n            public class HelloController {\n                protected final Log logger = LogFactory.getLog(this.getClass());\n             \n                @RequestMapping(\"/index\")\n                public String index(){\n                    return \"test\";\n                }\n            }\n        ```\n    * `SimpleUrlHandlerMapping`\n   \n        `SimpleUrlHandlerMapping`的`Controller`处理类需要实现`Controller`接口，并注册成`Bean`就可以完成配置，处理逻辑写在`handleRequest`方法体内\n        ```java\n            <bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n                <property name=\"mappings\">\n                    <props>\n                        <prop key=\"/simpleUrlHandlerMapping.do\">welcomeController</prop>\n                    </props>\n                 </property>\n            </bean>\n\n            /**\n             * @author Rob Harrop\n             */\n            public class WelcomeController implements Controller {\n            \n                @Override\n                public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {\n                    return new ModelAndView(\"welcomeView\");\n                }\n            \n            }\n\n        ```\n    * `BeanNameUrlHandlerMapping`需要配置 `<bean id=\"/index\" class=\"com.alipay.web.TestController\" />`，注意在`bean`的`id`中要加上斜杆，`Controller`方面的测试代码跟前面的`SimpleUrlHandlerMapping`一样，实现`Controller`，重写`handlerRequest()`方法即可。\n\n* 下一章节来跟进`RequestMappingHandlerMapping`这个`HandlerMapping` 的具体实现\n\n## 3.1 总结\n* `HandlerMapping`我们知道他的作用是根据`request`找到对应的`Handler`，`Handler`具体表现形式可以为类，也可以为方法，上面的三种常用的`HandlerMapping`有其介绍，我们平常使用`@RequestMapping`注解来标识一个方法，这个注解的作用就是将这个方法注册为`Handler`\n* 为什么需要要多种`HandlerMapping`呢，当然是为了其可扩展性，实现`HandlerMapping`接口就可以实现自定义`Handler`的获取，从而实现定制化\n* `Spring Mvc` 大量使用了`模版方法模式`，父类定义流程，子类实现，而这些口子都是所谓的模板方法，可以自由指定，从而保证了灵活性，良好的抽象设计，是整个框架变得非常灵活\n* `Spring Mvc` 核心类中所有的变量声明，几乎都以接口的形式给出，并没有绑定在具体的实现类上\n\n## 4.1 参考\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\nhttps://www.jianshu.com/p/e4f1c9326223\n\nhttps://blog.csdn.net/gaoshan12345678910/article/details/81778587\n\nhttps://blog.csdn.net/lang_programmer/article/details/71598042\n\n","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(三)核心分发器DispatcherServlet处理流程","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程/","content":"## 1.1 前言\n上一章节介绍了`DispatcherServlet`的初始化过程，这一章节介绍核心分发器`DispatcherServlet`是怎样处理请求的\n\n## 2.1 DispatcherServlet 处理请求过程\n\n![](/images/server/spring/spring-mvc/spring-mvc-handle.png)\n\n* 既然`DispatcherServlet`本身是`Servlet`，我们就要专注于它的`service、doGet、doPost`等相关方法，在`FrameworkServlet`里可以看到`service、doGet、doPost`这些方法的重载实现，可以看到都是流转到`processRequest(request, response);`这个方法中\n```java\n\t/**\n\t * Override the parent class implementation in order to intercept PATCH requests.\n\t */\n\t@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tHttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n\t\tif (HttpMethod.PATCH == httpMethod || httpMethod == null) {\n\t\t\tprocessRequest(request, response);\n\t\t}\n\t\telse {\n\t\t\tsuper.service(request, response);\n\t\t}\n\t}\n\n\t/**\n\t * Delegate GET requests to processRequest/doService.\n\t * <p>Will also be invoked by HttpServlet's default implementation of {@code doHead},\n\t * with a {@code NoBodyResponse} that just captures the content length.\n\t * @see #doService\n\t * @see #doHead\n\t */\n\t@Override\n\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}\n\n\t/**\n\t * Delegate POST requests to {@link #processRequest}.\n\t * @see #doService\n\t */\n\t@Override\n\tprotected final void doPost(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}\n\n\t/**\n\t * Delegate PUT requests to {@link #processRequest}.\n\t * @see #doService\n\t */\n\t@Override\n\tprotected final void doPut(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}\n\n\t/**\n\t * Delegate DELETE requests to {@link #processRequest}.\n\t * @see #doService\n\t */\n\t@Override\n\tprotected final void doDelete(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tprocessRequest(request, response);\n\t}\n```\n* 根据`service`方法，我们一步步找到一个方法链`service –> processRequest –> doService –> doDispatch`，我们最终将目光定位在`doDispatch`，因为从它的方法体就可以看出它是整个`SpringMVC`的核心方法。\n```java\n\t/**\n\t * Process the actual dispatching to the handler.\n\t * <p>The handler will be obtained by applying the servlet's HandlerMappings in order.\n\t * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters\n\t * to find the first that supports the handler class.\n\t * <p>All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers\n\t * themselves to decide which methods are acceptable.\n\t * @param request current HTTP request\n\t * @param response current HTTP response\n\t * @throws Exception in case of any kind of processing failure\n\t */\n\tprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tHttpServletRequest processedRequest = request;\n\t\tHandlerExecutionChain mappedHandler = null;\n\t\tboolean multipartRequestParsed = false;\n\t\t// 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联\n\t\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\t\ttry {\n\t\t\tModelAndView mv = null;\n\t\t\tException dispatchException = null;\n\n\t\t\ttry {\n\t\t\t\t// 检查是否有 Multipart，有则将请求转换为 Multipart 请求\n\t\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t\t// Determine handler for the current request.\n\t\t\t\t// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中\n\t\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\t\tif (mappedHandler == null || mappedHandler.getHandler() == null) {\n\t\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Determine handler adapter for the current request.\n\t\t\t\t// 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter\n\t\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\t\t// 处理 last-modified 请求头\n\t\t\t\tString method = request.getMethod();\n\t\t\t\tboolean isGet = \"GET\".equals(method);\n\t\t\t\tif (isGet || \"HEAD\".equals(method)) {\n\t\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n\t\t\t\t\t}\n\t\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Actually invoke the handler.\n\t\t\t\t// 执行实际的处理程序\n\t\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t\t// 遍历拦截器，执行它们的 postHandle() 方法\n\t\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tdispatchException = ex;\n\t\t\t}\n\t\t\tcatch (Throwable err) {\n\t\t\t\t// As of 4.3, we're processing Errors thrown from handler methods as well,\n\t\t\t\t// making them available for @ExceptionHandler methods and other scenarios.\n\t\t\t\tdispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n\t\t\t}\n\t\t    // 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染\n\t\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\t\tnew NestedServletException(\"Handler processing failed\", err));\n\t\t}\n\t\tfinally {\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t// Instead of postHandle and afterCompletion\n\t\t\t\t// 遍历拦截器，执行它们的 afterCompletion() 方法\n\t\t\t\tif (mappedHandler != null) {\n\t\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Clean up any resources used by a multipart request.\n\t\t\t\tif (multipartRequestParsed) {\n\t\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n* 说它是核心一点也不为过，从上述代码的中文注释可以看出，它包含了解析请求，执行相关拦截器，执行`handle`方法，这行代码是真正执行我们`controller`的方法`mv = ha.handle(processedRequest, response, mappedHandler.getHandler());`，那`SpringMvc`是怎样找到我们的方法的呢，下面的章节将介绍\n\n## 3.1 总结\n* `Spring Mvc` 的处理方式是先在顶层设计好整体结构，然后将具体的处理交给不同的组件具体去实现\n* `DispatcherServlet`中的`doDispatch`方法完成了具体的请求处理，下面是主要流程\n    *  遍历所有的 `HandlerMapping` 找到与请求对应的 `Handler`，并将其与一堆拦截器封装到 `HandlerExecutionChain` 对象中\n    *  遍历所有的 `HandlerAdapter`，找到可以处理该 `Handler` 的 `HandlerAdapter`\n    *  执行相应拦截器`Interceptor`的`preHandle`方法\n    *  `HandlerAdapter` 执行`Hander`，由`Hander` 执行实际的处理程序，执行Controller里的方法\n    *  调用`processDispatchResult`处理结果\n    *  执行相应拦截器`Interceptor`的`postHandle`方法\n* 本章只是介绍下`Spring MVC`的主要流程，下面的章节将详细介绍这些流程，下面是流程图\n\n![](/images/server/spring/spring-mvc/dispatcherServlet1.png) \n\n    \n## 4.1 参考\n\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\nhttp://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html\n\nhttps://blog.csdn.net/lang_programmer/article/details/71598042\n\n","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(二)核心分发器DispatcherServlet初始化","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化/","content":"## 1.1 前言\n\n我们都知道`DispatcherServlet`是前端控制器，是整个`Spring Mvc`的入口，但是这个前端控制器里面又有很多箱子，每一个箱子都有其独有的功能，当我们翻开一个箱子之后看看里面有什么的时候，又会发现箱子里面装着又一个箱子，所以我们需要一个个的探究这些箱子。\n\n## 2.1 DispatcherServlet 初始化过程\n### 2.1.1 配置 DispatcherServlet\n\n* 首先，`Tomcat`每次启动时都会加载并解析`/WEB-INF/web.xml`文件，所以可以先从`web.xml`找突破口，主要代码如下\n\n```xml\n\n<!-- 初始化参数 需要告诉Spring配置文件的位置 -->\n<init-param >\n  <param-name >contextConfigLocation</param-name>\n  <param-value >classpath:/applicationContext.xml</param-value>\n</init-param>\n<listener>\n  <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  \n</listener>\n\n<servlet >\n  <servlet-name >spring-mvc</servlet-name>\n  <!-- servlet类 -->\n  <servlet-class >org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  <!-- 初始化参数 -->\n  <init-param >\n    <param-name >contextConfigLocation</param-name>\n    <param-value >classpath:/spring-mvc.xml</param-value>\n  </init-param>\n  <!-- 启动时加载 -->\n  <load-on-startup >1</load-on-startup>\n</servlet>\n<servlet-mapping >\n  <servlet-name >spring-mvc</servlet-name>\n  <url-pattern >/</url-pattern>\n</servlet-mapping>\n```\n\n#### 2.1.1.1 ContextLoaderListener\n\n* 先来看下面的配置文件，这里配置了`Spring`的配置文件路径及一个监听类`ContextLoaderListener`\n\n```xml\n    <context-param>\n      <param-name>contextConfigLocation</param-name>  \n      <param-value >classpath:/applicationContext.xml</param-value>\n    </context-param>\n    <listener>\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  \n    </listener>\n```\n\n* 我们知道在是使用`Spring`的时候通常是使用`ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");`的方式来获取`Spring`容器的，现在我们是要将`Spring容器`与`Web`环境联系起来，所以需要通过这个类`ContextLoaderListener`将两者联系起来，那么它是怎么实现联系的呢？\n\n* 查看`ContextLoaderListener`类，可以看到它实现了`ServletContextListener`这个接口，这个是属于`Servlet`的类，如果实现了`ServletContextListener`这个接口，在`web.xml`配置这个监听器，启动容器时，就会默认执行它实现的方法`contextInitialized()`及`contextDestroyed()`\n\n```java\n// org.springframework.web.context.ContextLoaderListener\npublic class ContextLoaderListener extends ContextLoader implements ServletContextListener {\n\n\tpublic ContextLoaderListener() {}\n\n\tpublic ContextLoaderListener(WebApplicationContext context) {\n\t\tsuper(context);\n\t}\n\n\t/**\n\t * ServletContext启动之后会调用此方法\n\t *\n\t * Initialize the root web application context.\n\t */\n\t@Override\n\tpublic void contextInitialized(ServletContextEvent event) {\n\t\tinitWebApplicationContext(event.getServletContext());\n\t}\n\n\n\t/**\n\t * ServletContext关闭之后会调用此方法\n\t * \n\t * Close the root web application context.\n\t */\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent event) {\n\t\tcloseWebApplicationContext(event.getServletContext());\n\t\tContextCleanupListener.cleanupAttributes(event.getServletContext());\n\t}\n\n}\n\n// javax.servlet.ServletContextListener\npublic interface ServletContextListener extends EventListener {\n\n    public void contextInitialized(ServletContextEvent sce);\n\n    public void contextDestroyed(ServletContextEvent sce);\n}\n```\n\n* `ContextLoaderListener`类继承关系\n\n![](/images/server/spring/analysis/mvc/ContextLoaderListener.png)\n\n\n* 1、`ServletContext`启动之后会调用此方法`contextInitialized(ServletContextEvent event)`\n    * 进入此方法\n    ```java\n\tpublic WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n\t\t// web.xml中存在多次ContextLoader定义抛异常\n\t\tif (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cannot initialize context because there is already a root application context present - \" +\n\t\t\t\t\t\"check whether you have multiple ContextLoader* definitions in your web.xml!\");\n\t\t}\n\n\t\tLog logger = LogFactory.getLog(ContextLoader.class);\n\t\tservletContext.log(\"Initializing Spring root WebApplicationContext\");\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Root WebApplicationContext: initialization started\");\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\ttry {\n\t\t\t// Store context in local instance variable, to guarantee that\n\t\t\t// it is available on ServletContext shutdown.\n\t\t\tif (this.context == null) {\n\t\t\t\t// 创建WebApplicationContext\n\t\t\t\tthis.context = createWebApplicationContext(servletContext);\n\t\t\t}\n\t\t\tif (this.context instanceof ConfigurableWebApplicationContext) {\n\t\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n\t\t\t\tif (!cwac.isActive()) {\n\t\t\t\t\t// The context has not yet been refreshed -> provide services such as\n\t\t\t\t\t// setting the parent context, setting the application context id, etc\n\t\t\t\t\tif (cwac.getParent() == null) {\n\t\t\t\t\t\t// The context instance was injected without an explicit parent ->\n\t\t\t\t\t\t// determine parent for root web application context, if any.\n\t\t\t\t\t\tApplicationContext parent = loadParentContext(servletContext);\n\t\t\t\t\t\tcwac.setParent(parent);\n\t\t\t\t\t}\n\t\t\t\t\t// 构造Spring容器\n\t\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac, servletContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 将WebApplicationContext记录在servletContext中\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n\n\t\t\tClassLoader ccl = Thread.currentThread().getContextClassLoader();\n\t\t\tif (ccl == ContextLoader.class.getClassLoader()) {\n\t\t\t\tcurrentContext = this.context;\n\t\t\t}\n\t\t\telse if (ccl != null) {\n\t\t\t\t// 映射当前的类加载器与创建的实例到全局变量中currentContextPerThread\n\t\t\t\tcurrentContextPerThread.put(ccl, this.context);\n\t\t\t}\n\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Published root WebApplicationContext as ServletContext attribute with name [\" +\n\t\t\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + \"]\");\n\t\t\t}\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\t\tlogger.info(\"Root WebApplicationContext: initialization completed in \" + elapsedTime + \" ms\");\n\t\t\t}\n\n\t\t\treturn this.context;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tlogger.error(\"Context initialization failed\", ex);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Error err) {\n\t\t\tlogger.error(\"Context initialization failed\", err);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);\n\t\t\tthrow err;\n\t\t}\n\t}\n    ```\n    * 可以看到上面主要逻辑分为以下几个步骤\n        * 1、创建`WebApplicationContext`对象\n            * 代码\n            ```java\n            protected WebApplicationContext createWebApplicationContext(ServletContext sc) {\n                Class<?> contextClass = determineContextClass(sc);\n                if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n                    throw new ApplicationContextException(\"Custom context class [\" + contextClass.getName() +\n                            \"] is not of type [\" + ConfigurableWebApplicationContext.class.getName() + \"]\");\n                }\n                return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n            }\n            ```\n        * 2、构造`Spring`容器，这个很重要\n            * 进入`configureAndRefreshWebApplicationContext(cwac, servletContext);`，可以看到主要逻辑是读取了我们上面配置的`contextConfigLocation`配置路径，然后执行了`wac.refresh();`方法，这个方法是构造`Spring`容器的核心方法\n            ```java\n            protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n                if (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n                    // The application context id is still set to its original default value\n                    // -> assign a more useful id based on available information\n                    String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n                    if (idParam != null) {\n                        wac.setId(idParam);\n                    }\n                    else {\n                        // Generate default id...\n                        wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n                                ObjectUtils.getDisplayString(sc.getContextPath()));\n                    }\n                }\n                // 在Spring也存一份ServletContext\n                wac.setServletContext(sc);\n                /**\n                 * 读取contextConfigLocation配置路径\n                 * <context-param>\n                        <param-name>contextConfigLocation</param-name>\n                        <param-value >classpath:/applicationContext.xml</param-value>\n                 </context-param>\n                 */\n                String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n                if (configLocationParam != null) {\n                    wac.setConfigLocation(configLocationParam);\n                }\n        \n                // The wac environment's #initPropertySources will be called in any case when the context\n                // is refreshed; do it eagerly here to ensure servlet property sources are in place for\n                // use in any post-processing or initialization that occurs below prior to #refresh\n                ConfigurableEnvironment env = wac.getEnvironment();\n                if (env instanceof ConfigurableWebEnvironment) {\n                    ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);\n                }\n        \n                customizeContext(sc, wac);\n                // 核心 refresh()方法\n                wac.refresh();\n            }\n            ```\n        * 3、构建完成之后将此对象放在`servletContext`中，这样就可以在`Web`服务中使用`Spring`容器了，开发者能够在客户端请求提供服务之前向`ServletContext`中添加任意的对象，`ServletContext`在`web`容器运行期间都是可见的\n            * 代码\n            ```java\n            servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n            ```\n        * 4、映射当前的类加载器与创建的实例到全局变量中`currentContextPerThread`中\n            * 代码\n                ```java\n                /**\n                 * Map from (thread context) ClassLoader to corresponding 'current' WebApplicationContext.\n                 */\n                private static final Map<ClassLoader, WebApplicationContext> currentContextPerThread =\n                        new ConcurrentHashMap<ClassLoader, WebApplicationContext>(1);\n            \n                /**\n                 * The 'current' WebApplicationContext, if the ContextLoader class is\n                 * deployed in the web app ClassLoader itself.\n                 */\n                private static volatile WebApplicationContext currentContext;\n    \n                ...\n      \n                ClassLoader ccl = Thread.currentThread().getContextClassLoader();\n                if (ccl == ContextLoader.class.getClassLoader()) {\n                    currentContext = this.context;\n                }\n                else if (ccl != null) {\n                    // 映射当前的类加载器与创建的实例到全局变量中currentContextPerThread\n                    currentContextPerThread.put(ccl, this.context);\n                } \n                ```\n* 2、`ServletContext`关闭之后会调用此方法`contextDestroyed(ServletContextEvent event)`\n    * 这里的逻辑主要是销毁`Spring`容器及清理`Web`容器\n    ```java\n\t@Override\n\tpublic void contextDestroyed(ServletContextEvent event) {\n\t\tcloseWebApplicationContext(event.getServletContext());\n\t\tContextCleanupListener.cleanupAttributes(event.getServletContext());\n\t}\n    public void closeWebApplicationContext(ServletContext servletContext) {\n        servletContext.log(\"Closing Spring root WebApplicationContext\");\n        try {\n            if (this.context instanceof ConfigurableWebApplicationContext) {\n                ((ConfigurableWebApplicationContext) this.context).close();\n            }\n        }\n        finally {\n            ClassLoader ccl = Thread.currentThread().getContextClassLoader();\n            if (ccl == ContextLoader.class.getClassLoader()) {\n                currentContext = null;\n            }\n            else if (ccl != null) {\n                currentContextPerThread.remove(ccl);\n            }\n            servletContext.removeAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n            if (this.parentContextRef != null) {\n                this.parentContextRef.release();\n            }\n        }\n    }\n    ```\n    \n#### 2.1.1.2 DispatcherServlet\n\n* 上面通过`ContextLoaderListener`已经将`Spring`容器构建起来了并与`Web`容器联系起来了，但`Spring MVC`的核心逻辑是在`DispatcherServlet`中进行的，这就是下面`web.xml`配置的\n\n```xml\n<servlet >\n  <servlet-name >spring-mvc</servlet-name>\n  <!-- servlet类 -->\n  <servlet-class >org.springframework.web.servlet.DispatcherServlet</servlet-class>\n  <!-- 初始化参数 -->\n  <init-param >\n    <param-name >contextConfigLocation</param-name>\n    <param-value >classpath:/spring-mvc.xml</param-value>\n  </init-param>\n  <!-- 启动时加载 -->\n  <load-on-startup >1</load-on-startup>\n</servlet>\n<servlet-mapping >\n  <servlet-name >spring-mvc</servlet-name>\n  <url-pattern >/</url-pattern>\n</servlet-mapping>\n```\n\n* 可以看到 `DispatcherServlet` 本身就是个`Servlet`，`servlet`的生命周期是由`servlet`容器来控制的，可分为以下几个阶段：\n    * 1、初始化阶段: 先加载`servlet`类并构建，然后执行其`init()`方法进行初始化，这个步骤只会执行一次\n    * 2、运行阶段：当`servlet`容器收到一个请求时，会创建`servletRequest`和`servletResponse`对象，并其将作为参数调用`service()`方法，执行业务逻辑\n    * 3、销毁阶段：销毁当然是销毁`servlet`，释放`servlet`所占用的资源，比如关闭数据库连接，关闭文件输入输出类等等\n* 上面回顾了一些`servlet`的一些知识，那么`DispatcherServlet`也是围绕这几个阶段来处理请求的，下面看看`DispatcherServlet`做了什么呢，我们先看下`DispatcherServlet`的继承关系，重点关注`HttpServletBean` 和`FrameworkServlet` 这两个类\n\n```java\nGenericServlet (javax.servlet)\n    HttpServlet (javax.servlet.http)\n        HttpServletBean (org.springframework.web.servlet)\n            FrameworkServlet (org.springframework.web.servlet)\n                DispatcherServlet (org.springframework.web.servlet)\n```\n\n![](/images/server/spring/spring-mvc/DispatcherServlet.png)\n\n* 通过上图可以看到 `DispatcherServlet` 实现了`Spring` 的`ApplicationContextAware`、`EnvironmentCapable`、 `EnvironmentAware`这些`Spring`中的接口，`XXXAware`在`Spring`中表示对`XXX`可以感知，通俗点可以说在某个类中想使用`Spring`的一些东西，就可以实现`XXXAware`接口告诉`Spring`我要这个东西，比如`ApplicationContextAware`，该接口只有一个方法就是`setApplicationContext(ApplicationContext applicationContext)`, 通过该方法可以得到`ApplicationContext`，`Spring`容器会检测容器中的所有`Bean`，如果发现某个`Bean`实现了`ApplicationContextAware`接口，Spring容器会在创建该`Bean`之后，自动调用该`Bean`的`setApplicationContextAware()`方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将`Spring`传入的参数（容器本身）赋给该类对象的`applicationContext`实例变量，因此接下来可以通过该`applicationContext`实例变量来访问容器本身。实现`XXXCapable`接口表示可以得到某种能力，实现`EnvironmentCapable`接口说明可以得到`Environment`的能力，也就是可以提供`Environment`\n    * `ApplicationContextAware`\n        * 代码\n        ```java\n            @Override\n            public void setApplicationContext(ApplicationContext applicationContext) {\n                if (this.webApplicationContext == null && applicationContext instanceof WebApplicationContext) {\n                    this.webApplicationContext = (WebApplicationContext) applicationContext;\n                    this.webApplicationContextInjected = true;\n                }\n            }\n        ```\n    * `EnvironmentCapable`\n        * 代码\n        ```java\n        @Override\n            public ConfigurableEnvironment getEnvironment() {\n                if (this.environment == null) {\n                    this.environment = createEnvironment();\n                }\n                return this.environment;\n            }\n        ```\n##### 2.1.1.2.1 父类HttpServletBean\n\n* `HttpServletBean` 覆写了`GenericServlet` 的`init`方法，此方法是第一次访问该`DispatcherServlet`的时候就会执行，对初始化过程做了一些处理，`HttpServletBean` 这个类的作用主要做一些初始化的工作，将`web.xml`中配置的参数设置到`ServletConfig`中。比如`servlet`标签的子标签`init-param`标签中配置的参数`(classpath:/spring-mvc.xml)`，第二个就是调用`FrameworkServlet`子类方法构建及发布`WebApplicationContext`\n\n```java\n@Override\npublic final void init() throws ServletException {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Initializing servlet '\" + getServletName() + \"'\");\n    }\n\n    // 构造过程中会使用ServletConfig对象找出web.xml配置文件中的配置参数 比如web.xml配置的<init-param >\n    // 并设置到ServletConfig\n    // Set bean properties from init parameters.\n    PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n    if (!pvs.isEmpty()) {\n        try {\n            // 使用BeanWrapper构造DispatcherServlet BeanWrapper是Spring提供用来操作JavaBean属性的工具，使用它可以直接修改一个对象的属性\n            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n            ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n            bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n            // 模板方法\n            initBeanWrapper(bw);\n            // 设置DispatcherServlet属性\n            bw.setPropertyValues(pvs, true);\n        }\n        catch (BeansException ex) {\n            if (logger.isErrorEnabled()) {\n                logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex);\n            }\n            throw ex;\n        }\n    }\n    // 触发子类{@link FrameworkServlet#initServletBean() } 用构建及发布WebApplicationContext\n    initServletBean();\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\");\n    }\n}\n```\n\n##### 2.1.1.2.2 父类FrameworkServlet\n\n* 关注`initServletBean()`方法，该方法的实现在`FrameworkServlet` 类里，这个类的作用是将`Servlet`与`Spring`容器上下文关联。其实也就是初始化`FrameworkServlet`的属性`webApplicationContext`\n\n```java\n\t/**\n\t * Overridden method of {@link HttpServletBean}, invoked after any bean properties\n\t * have been set. Creates this servlet's WebApplicationContext.\n\t */\n\t@Override\n\tprotected final void initServletBean() throws ServletException {\n\t\tgetServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\");\n\t\tif (this.logger.isInfoEnabled()) {\n\t\t\tthis.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\");\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\ttry {\n\t\t\t// 初始化 WebApplicationContext (即SpringMVC的IOC容器)\n\t\t\tthis.webApplicationContext = initWebApplicationContext();\n\t\t\tinitFrameworkServlet();\n\t\t}\n\t\tcatch (ServletException ex) {\n\t\t\tthis.logger.error(\"Context initialization failed\", ex);\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tthis.logger.error(\"Context initialization failed\", ex);\n\t\t\tthrow ex;\n\t\t}\n\n\t\tif (this.logger.isInfoEnabled()) {\n\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\tthis.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" +\n\t\t\t\t\telapsedTime + \" ms\");\n\t\t}\n\t}\n```\n\n* 进入`this.webApplicationContext = initWebApplicationContext();`方法，这个方法的作用是先得到根上下文`rootContext` 然后创建`webApplicationContext`并设置根上下文（将 `Spring` 的容器设为 `SpringMVC` 容器的父容器），这里的容器涉及到两个，一个是`Spring`父容器，另一个是`SpringMVC` 容器，所以需要把这两个容器合并，最后就是发布这个整合版的 `WebApplicationContext` 容器到 `ServletContext` 中\n\n```java\n\t/**\n\t * Initialize and publish the WebApplicationContext for this servlet.\n\t * <p>Delegates to {@link #createWebApplicationContext} for actual creation\n\t * of the context. Can be overridden in subclasses.\n\t * @return the WebApplicationContext instance\n\t * @see #FrameworkServlet(WebApplicationContext)\n\t * @see #setContextClass\n\t * @see #setContextConfigLocation\n\t */\n\tprotected WebApplicationContext initWebApplicationContext() {\n\t    // 获取ContextLoaderListener 初始化并注册在 ServletContext 中的Spring 的容器容器，这里是父容器\n\t\tWebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());\n\t\tWebApplicationContext wac = null;\n\n\t\tif (this.webApplicationContext != null) {\n\t\t\t// A context instance was injected at construction time -> use it\n\t\t\twac = this.webApplicationContext;\n\t\t\tif (wac instanceof ConfigurableWebApplicationContext) {\n\t\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n\t\t\t\tif (!cwac.isActive()) {\n\t\t\t\t\t// The context has not yet been refreshed -> provide services such as\n\t\t\t\t\t// setting the parent context, setting the application context id, etc\n\t\t\t\t\tif (cwac.getParent() == null) {\n\t\t\t\t\t\t// The context instance was injected without an explicit parent -> set\n\t\t\t\t\t\t// the root application context (if any; may be null) as the parent\n\t\t\t\t\t\t// 将 Spring 的容器设为 SpringMVC 容器的父容器\n\t\t\t\t\t\tcwac.setParent(rootContext);\n\t\t\t\t\t}\n\t\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (wac == null) {\n\t\t\t// No context instance was injected at construction time -> see if one\n\t\t\t// has been registered in the servlet context. If one exists, it is assumed\n\t\t\t// that the parent context (if any) has already been set and that the\n\t\t\t// user has performed any initialization such as setting the context id\n\t\t\t// 如果 WebApplicationContext 为空，则进行查找，能找到说明上下文已经在别处初始化。\n\t\t\twac = findWebApplicationContext();\n\t\t}\n\t\tif (wac == null) {\n\t\t\t// No context instance is defined for this servlet -> create a local one\n\t\t\t// 如果 WebApplicationContext 仍为空，则以 Spring 的容器为父上下文建立一个新的，并设置根上下文为父上下文\n\t\t\twac = createWebApplicationContext(rootContext);\n\t\t}\n\t\tif (!this.refreshEventReceived) {\n\t\t\t// Either the context is not a ConfigurableApplicationContext with refresh\n\t\t\t// support or the context injected at construction time had already been\n\t\t\t// refreshed -> trigger initial onRefresh manually here.\n\t\t\t// 模版方法，由 DispatcherServlet 实现\n\t\t\tonRefresh(wac);\n\t\t}\n\t\tif (this.publishContext) {\n\t\t\t// Publish the context as a servlet context attribute.\n\t\t\t// 发布这个 WebApplicationContext 容器到 ServletContext 中\n\t\t\tString attrName = getServletContextAttributeName();\n\t\t\tgetServletContext().setAttribute(attrName, wac);\n\t\t\tif (this.logger.isDebugEnabled()) {\n\t\t\t\tthis.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() +\n\t\t\t\t\t\t\"' as ServletContext attribute with name [\" + attrName + \"]\");\n\t\t\t}\n\t\t}\n\t\treturn wac;\n\t}\n```\n\n* `Spring`父容器\n    * 回顾上面的配置文件的配置，这里就是指定了`Spring`父容器的配置\n    ```xml\n    <init-param >\n      <param-name >contextConfigLocation</param-name>\n      <param-value >classpath:/applicationContext.xml</param-value>\n    </init-param>\n    ```\n    * 父容器的构建关注`WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());`方法，这里是就是获取我们上面在`ContextLoaderListener` 初始化并注册在 `ServletContext` 的`WebApplicationContext`\n        * 进入此方法，可以看到是直接从`ServletContext`中获取`sc.getAttribute(attrName);`\n        ```java\n         public static WebApplicationContext getWebApplicationContext(ServletContext sc) {\n            return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n        }\n        public static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) {\n            Assert.notNull(sc, \"ServletContext must not be null\");\n            // 从ServletContext中获取\n            Object attr = sc.getAttribute(attrName);\n            if (attr == null) {\n                return null;\n            }\n            if (attr instanceof RuntimeException) {\n                throw (RuntimeException) attr;\n            }\n            if (attr instanceof Error) {\n                throw (Error) attr;\n            }\n            if (attr instanceof Exception) {\n                throw new IllegalStateException((Exception) attr);\n            }\n            if (!(attr instanceof WebApplicationContext)) {\n                throw new IllegalStateException(\"Context attribute is not of type WebApplicationContext: \" + attr);\n            }\n            return (WebApplicationContext) attr;\n        }\n        ```\n        * 这里的`WebApplicationContext`的值是什么时候弄进去的呢，回顾一下`ContextLoaderListener`的`initWebApplicationContext()`方法，下面第三步`servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);`就把`WebApplicationContext`赋值到了`ServletContext`中\n        ```java\n        public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n        \n          ...  \n        \n          try {\n                // Store context in local instance variable, to guarantee that\n                // it is available on ServletContext shutdown.\n                if (this.context == null) {\n                    // 1、创建WebApplicationContext\n                    this.context = createWebApplicationContext(servletContext);\n                }\n                if (this.context instanceof ConfigurableWebApplicationContext) {\n                    ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n                    if (!cwac.isActive()) {\n                        // The context has not yet been refreshed -> provide services such as\n                        // setting the parent context, setting the application context id, etc\n                        if (cwac.getParent() == null) {\n                            // The context instance was injected without an explicit parent ->\n                            // determine parent for root web application context, if any.\n                            ApplicationContext parent = loadParentContext(servletContext);\n                            cwac.setParent(parent);\n                        }\n                        // 2、构造Spring容器\n                        configureAndRefreshWebApplicationContext(cwac, servletContext);\n                    }\n                }\n                // 3、将WebApplicationContext记录在servletContext中\n                servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n        \n        ...\n        ```\n* `SpringMVC` 容器\n    * 回顾上面的配置文件的配置，这里就是指定了`SpringMVC`父容器的配置\n    ```xml\n    <init-param >\n      <param-name >contextConfigLocation</param-name>\n      <param-value >classpath:/spring-mvc.xml</param-value>\n    </init-param>\n    ```\n    * `SpringMVC` 容器的构建关注`wac = createWebApplicationContext(rootContext);`方法，这里是以 `Spring`父容器为基础构建一个新的`SpringMVC` 容器\n    ```java\n  \tprotected WebApplicationContext createWebApplicationContext(WebApplicationContext parent) {\n  \t\treturn createWebApplicationContext((ApplicationContext) parent);\n  \t}  \n\tprotected WebApplicationContext createWebApplicationContext(ApplicationContext parent) {\n\t\tClass<?> contextClass = getContextClass();\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(\"Servlet with name '\" + getServletName() +\n\t\t\t\t\t\"' will try to create custom WebApplicationContext context of class '\" +\n\t\t\t\t\tcontextClass.getName() + \"'\" + \", using parent context [\" + parent + \"]\");\n\t\t}\n\t\tif (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\"Fatal initialization error in servlet with name '\" + getServletName() +\n\t\t\t\t\t\"': custom WebApplicationContext class [\" + contextClass.getName() +\n\t\t\t\t\t\"] is not of type ConfigurableWebApplicationContext\");\n\t\t}\n\t\tConfigurableWebApplicationContext wac =\n\t\t\t\t(ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n\n\t\twac.setEnvironment(getEnvironment());\n\t\twac.setParent(parent);\n\t\t/**\n\t\t * \t  这里配置了ConfigLocation\n\t\t * \t\n\t\t *    <init-param >\n\t\t *       <param-name >contextConfigLocation</param-name>\n\t\t *       <param-value >classpath:/spring-mvc.xml</param-value>\n\t\t *     </init-param>\n\t\t */\n\t\twac.setConfigLocation(getContextConfigLocation());\n\n\t\tconfigureAndRefreshWebApplicationContext(wac);\n\n\t\treturn wac;\n\t}\n    ```\n    \n* 上面已经得到了`SpringMVC` 的容器，继续走下面的逻辑\n\n```java\nif (!this.refreshEventReceived) {\n    // Either the context is not a ConfigurableApplicationContext with refresh\n    // support or the context injected at construction time had already been\n    // refreshed -> trigger initial onRefresh manually here.\n    // 刷新Spring MVC，模版方法，由 DispatcherServlet 实现\n    onRefresh(wac);\n}\n```\n\n* 进入`onRefresh(wac);` 由 `DispatcherServlet` 实现，这里的操作就是`Spring Mvc`自身的初始化过程\n\n```java\n\t/**\n\t * This implementation calls {@link #initStrategies}.\n\t */\n\t@Override\n\tprotected void onRefresh(ApplicationContext context) {\n     \t\t// initStrategies方法内部会初始化各个策略接口的实现类。\n     \t\tinitStrategies(context);\n     \t}\n\n\t/**\n\t * Initialize the strategy objects that this servlet uses.\n\t * <p>May be overridden in subclasses in order to initialize further strategy objects.\n\t */\n\tprotected void initStrategies(ApplicationContext context) {\n\t\t// 上传组件初始化，注册后每个请求会检查是否包含multipart\n\t\tinitMultipartResolver(context);\n\t\t// 国际化组件初始化\n\t\tinitLocaleResolver(context);\n\t\t// 主题解析器初始化\n\t\tinitThemeResolver(context);\n\t\t// 核心：请求映射处理组件初始化\n\t\tinitHandlerMappings(context);\n\t\t// 处理适配器组建初始化\n\t\tinitHandlerAdapters(context);\n\t\t// 异常处理组件初始化\n\t\tinitHandlerExceptionResolvers(context);\n\t\tinitRequestToViewNameTranslator(context);\n\t\t// 视图处理组件初始化\n\t\tinitViewResolvers(context);\n\t\tinitFlashMapManager(context);\n\t}\n```\n\n* 到这里`SpringMVC` 的容器已经初始完成了，那么就需要发布这个容器了，可以看到还是设置到`ServletContext`中，这样的话就可以在整个`Web`环境中使用该容器了\n\n```java\nif (this.publishContext) {\n    // Publish the context as a servlet context attribute.\n    // 发布这个 WebApplicationContext 容器到 ServletContext 中\n    String attrName = getServletContextAttributeName();\n    getServletContext().setAttribute(attrName, wac);\n    if (this.logger.isDebugEnabled()) {\n        this.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() +\n                \"' as ServletContext attribute with name [\" + attrName + \"]\");\n    }\n}\n```\n\n\n### 2.1.1 DispatcherServlet 默认加载bean\n\n* `DispatcherServlet` 初始化的时候会默认加载一些组件，代码如下，可以看到是在`static`代码块中读取一个配置文件并把它注册为`Properties defaultStrategies`对象\n```java\n\t/**\n\t * Name of the class path resource (relative to the DispatcherServlet class)\n\t * that defines DispatcherServlet's default strategy names.\n\t */\n\tprivate static final String DEFAULT_STRATEGIES_PATH = \"DispatcherServlet.properties\";\n\t\n\t...\n\t\n    static {\n        // Load default strategy implementations from properties file.\n        // This is currently strictly internal and not meant to be customized\n        // by application developers.\n        try {\n            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        }\n        catch (IOException ex) {\n            throw new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage());\n        }\n    }\n\t\n```\n\n* 查看`DispatcherServlet.properties`文件，该文件在`Spring web mvc` 包下\n```properties\n# Default implementation classes for DispatcherServlet's strategy interfaces.\n# Used as fallback when no matching beans are found in the DispatcherServlet context.\n# Not meant to be customized by application developers.\n\norg.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver\n\norg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolver\n\norg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping\n\norg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\n\norg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\\n\torg.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver\n\norg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator\n\norg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver\n\norg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager\n```\n\n* 从如上配置可以看出`DispatcherServlet` 配置的是一些类的全限定名，那它是在哪里调用的呢，还是回到之前的`onRefresh(wac);` 的`initStrategies(ApplicationContext context)`方法\n\n\n\n### 2.1.2 <mvc:annotation-driven/> 自定义标签解析\n\n* 如果需要使用`Spring`则需要添加上面的标签用于开启`Spring MVC`的功能，可以知道这个标签是属于`Spring`的自定义标签，所以找到对应的命名空间处理器`NamespaceHandler`\n\n* 可以定位到`MvcNamespaceHandler`\n\n```java\npublic class MvcNamespaceHandler extends NamespaceHandlerSupport {\n\n\t@Override\n\tpublic void init() {\n\t\tregisterBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"default-servlet-handler\", new DefaultServletHandlerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"interceptors\", new InterceptorsBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"resources\", new ResourcesBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"view-controller\", new ViewControllerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"redirect-view-controller\", new ViewControllerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"status-controller\", new ViewControllerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"view-resolvers\", new ViewResolversBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"tiles-configurer\", new TilesConfigurerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"freemarker-configurer\", new FreeMarkerConfigurerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"velocity-configurer\", new VelocityConfigurerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"groovy-configurer\", new GroovyMarkupConfigurerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"script-template-configurer\", new ScriptTemplateConfigurerBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"cors\", new CorsBeanDefinitionParser());\n\t}\n\n}\n```\n\n* 关注`registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser());` 进入到`AnnotationDrivenBeanDefinitionParser`的`parse`方法，可以看到主要逻辑就是构造各种`BeanDefinition`并注册到容器中，可以发现有我们最常用`RequestMappingHandlerMapping`、`RequestMappingHandlerAdapter`、`DefaultHandlerExceptionResolver`等等，这些`bean`是`Spring MVC`的重要组成部分，具体功能在以后的章节将会介绍\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    Object source = parserContext.extractSource(element);\n    XmlReaderContext readerContext = parserContext.getReaderContext();\n\n    CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);\n    parserContext.pushContainingComponent(compDefinition);\n\n    RuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);\n\n    // 注册 RequestMappingHandlerMapping\n    RootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);\n    handlerMappingDef.setSource(source);\n    handlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    handlerMappingDef.getPropertyValues().add(\"order\", 0);\n    handlerMappingDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\n    if (element.hasAttribute(\"enable-matrix-variables\")) {\n        Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(\"enable-matrix-variables\"));\n        handlerMappingDef.getPropertyValues().add(\"removeSemicolonContent\", !enableMatrixVariables);\n    }\n    else if (element.hasAttribute(\"enableMatrixVariables\")) {\n        Boolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(\"enableMatrixVariables\"));\n        handlerMappingDef.getPropertyValues().add(\"removeSemicolonContent\", !enableMatrixVariables);\n    }\n\n    configurePathMatchingProperties(handlerMappingDef, element, parserContext);\n    readerContext.getRegistry().registerBeanDefinition(HANDLER_MAPPING_BEAN_NAME , handlerMappingDef);\n\n    RuntimeBeanReference corsConfigurationsRef = MvcNamespaceUtils.registerCorsConfigurations(null, parserContext, source);\n    handlerMappingDef.getPropertyValues().add(\"corsConfigurations\", corsConfigurationsRef);\n\n    RuntimeBeanReference conversionService = getConversionService(element, source, parserContext);\n    RuntimeBeanReference validator = getValidator(element, source, parserContext);\n    RuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element);\n\n    // 注册 ConfigurableWebBindingInitializer\n    RootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);\n    bindingDef.setSource(source);\n    bindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    bindingDef.getPropertyValues().add(\"conversionService\", conversionService);\n    bindingDef.getPropertyValues().add(\"validator\", validator);\n    bindingDef.getPropertyValues().add(\"messageCodesResolver\", messageCodesResolver);\n\n    ManagedList<?> messageConverters = getMessageConverters(element, source, parserContext);\n    ManagedList<?> argumentResolvers = getArgumentResolvers(element, parserContext);\n    ManagedList<?> returnValueHandlers = getReturnValueHandlers(element, parserContext);\n    String asyncTimeout = getAsyncTimeout(element);\n    RuntimeBeanReference asyncExecutor = getAsyncExecutor(element);\n    ManagedList<?> callableInterceptors = getCallableInterceptors(element, source, parserContext);\n    ManagedList<?> deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);\n\n    // 注册 RequestMappingHandlerAdapter\n    RootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);\n    handlerAdapterDef.setSource(source);\n    handlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    handlerAdapterDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n    handlerAdapterDef.getPropertyValues().add(\"webBindingInitializer\", bindingDef);\n    handlerAdapterDef.getPropertyValues().add(\"messageConverters\", messageConverters);\n    addRequestBodyAdvice(handlerAdapterDef);\n    addResponseBodyAdvice(handlerAdapterDef);\n\n    if (element.hasAttribute(\"ignore-default-model-on-redirect\")) {\n        Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(\"ignore-default-model-on-redirect\"));\n        handlerAdapterDef.getPropertyValues().add(\"ignoreDefaultModelOnRedirect\", ignoreDefaultModel);\n    }\n    else if (element.hasAttribute(\"ignoreDefaultModelOnRedirect\")) {\n        // \"ignoreDefaultModelOnRedirect\" spelling is deprecated\n        Boolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(\"ignoreDefaultModelOnRedirect\"));\n        handlerAdapterDef.getPropertyValues().add(\"ignoreDefaultModelOnRedirect\", ignoreDefaultModel);\n    }\n\n    if (argumentResolvers != null) {\n        handlerAdapterDef.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n    }\n    if (returnValueHandlers != null) {\n        handlerAdapterDef.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n    }\n    if (asyncTimeout != null) {\n        handlerAdapterDef.getPropertyValues().add(\"asyncRequestTimeout\", asyncTimeout);\n    }\n    if (asyncExecutor != null) {\n        handlerAdapterDef.getPropertyValues().add(\"taskExecutor\", asyncExecutor);\n    }\n\n    handlerAdapterDef.getPropertyValues().add(\"callableInterceptors\", callableInterceptors);\n    handlerAdapterDef.getPropertyValues().add(\"deferredResultInterceptors\", deferredResultInterceptors);\n    readerContext.getRegistry().registerBeanDefinition(HANDLER_ADAPTER_BEAN_NAME , handlerAdapterDef);\n\n    String uriCompContribName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;\n    // 注册 CompositeUriComponentsContributorFactoryBean\n    RootBeanDefinition uriCompContribDef = new RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);\n    uriCompContribDef.setSource(source);\n    uriCompContribDef.getPropertyValues().addPropertyValue(\"handlerAdapter\", handlerAdapterDef);\n    uriCompContribDef.getPropertyValues().addPropertyValue(\"conversionService\", conversionService);\n    readerContext.getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);\n\n    // 注册 ConversionServiceExposingInterceptor\n    RootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);\n    csInterceptorDef.setSource(source);\n    csInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);\n\n    // 注册 MappedInterceptor\n    RootBeanDefinition mappedCsInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);\n    mappedCsInterceptorDef.setSource(source);\n    mappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);\n    mappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);\n    String mappedInterceptorName = readerContext.registerWithGeneratedName(mappedCsInterceptorDef);\n\n    // 注册 ExceptionHandlerExceptionResolver\n    RootBeanDefinition exceptionHandlerExceptionResolver = new RootBeanDefinition(ExceptionHandlerExceptionResolver.class);\n    exceptionHandlerExceptionResolver.setSource(source);\n    exceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    exceptionHandlerExceptionResolver.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n    exceptionHandlerExceptionResolver.getPropertyValues().add(\"messageConverters\", messageConverters);\n    exceptionHandlerExceptionResolver.getPropertyValues().add(\"order\", 0);\n    addResponseBodyAdvice(exceptionHandlerExceptionResolver);\n\n    if (argumentResolvers != null) {\n        exceptionHandlerExceptionResolver.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n    }\n    if (returnValueHandlers != null) {\n        exceptionHandlerExceptionResolver.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n    }\n\n    String methodExceptionResolverName = readerContext.registerWithGeneratedName(exceptionHandlerExceptionResolver);\n\n    // 注册 ResponseStatusExceptionResolver\n    RootBeanDefinition responseStatusExceptionResolver = new RootBeanDefinition(ResponseStatusExceptionResolver.class);\n    responseStatusExceptionResolver.setSource(source);\n    responseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    responseStatusExceptionResolver.getPropertyValues().add(\"order\", 1);\n    String responseStatusExceptionResolverName =\n            readerContext.registerWithGeneratedName(responseStatusExceptionResolver);\n\n    // 注册 DefaultHandlerExceptionResolver\n    RootBeanDefinition defaultExceptionResolver = new RootBeanDefinition(DefaultHandlerExceptionResolver.class);\n    defaultExceptionResolver.setSource(source);\n    defaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    defaultExceptionResolver.getPropertyValues().add(\"order\", 2);\n    String defaultExceptionResolverName =\n            readerContext.registerWithGeneratedName(defaultExceptionResolver);\n\n    parserContext.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME));\n    parserContext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, HANDLER_ADAPTER_BEAN_NAME));\n    parserContext.registerComponent(new BeanComponentDefinition(uriCompContribDef, uriCompContribName));\n    parserContext.registerComponent(new BeanComponentDefinition(exceptionHandlerExceptionResolver, methodExceptionResolverName));\n    parserContext.registerComponent(new BeanComponentDefinition(responseStatusExceptionResolver, responseStatusExceptionResolverName));\n    parserContext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExceptionResolverName));\n    parserContext.registerComponent(new BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));\n\n    // Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n    MvcNamespaceUtils.registerDefaultComponents(parserContext, source);\n\n    parserContext.popAndRegisterContainingComponent();\n\n    return null;\n}\n```\n\n\n## 3.1 总结\n* `HttpServletBean` 继承了`HttpServlet`，所以主要逻辑还是执行其`init()`进行`Servlet`的初始化任务，主要有下面逻辑\n    * 1、解析参数配置：将`web.xml`中配置的参数设置到`ServletConfig`中。比如`servlet`标签的子标签`init-param`标签中配置的参数。\n    * 2、触发子类`{@link FrameworkServlet#initServletBean() }`方法 用与构建及发布`WebApplicationContext`\n\n* `FrameworkServlet` 将`Servlet`与`Spring`容器上下文关联。其实也就是初始化`FrameworkServlet`的属性`webApplicationContext`，这个属性代表`SpringMVC`容器，它有个父类上下文，既`web.xml`中配置`的ContextLoaderListener`监听器初始化的容器上下文。\n\n* `DispatcherServlet` 初始化各个功能的实现类。比如文件上传处理、异常处理、视图处理、请求映射处理等。\n\n* `DispatcherServlet`会自动注册一些特殊的`Bean`，无需我们注册，如果我们注册了，默认的将不会注册。 因此`BeanNameUrlHandlerMapping、SimpleControllerHandlerAdapter`是不需要注册的，`DispatcherServlet`默认会注册这两个`Bean`。\n\n## 4.1 参考\n官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n\nhttp://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html\n\nhttps://blog.csdn.net/lang_programmer/article/details/71598042\n\n","tags":["spring"],"categories":["服务器"]},{"title":"Spring Mvc源码(一)Spring Mvc介绍","url":"/2019/08/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(一)Spring Mvc介绍/","content":"\n### 1.1 什么是Spring Mvc\n* 在JavaEE体系结构中一个应用可以划分为四个层次，从上到下分别是应用层、Web层、业务层、持久层，现在的项目大都是按照这种结构来开发，我们这一系列介绍的是Web层的处理框架`Spring Mvc`\n\n* `Spring Web Mvc`是一种基于Java的轻量级Web框架，使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。\n\n### 2.1 为什么要使用Spring Mvc\n#### 2.1.1 没有使用Spring Mvc会怎么样\n在Web开发模式中，主要有两个开发模式，称为模式一（Mode I）和模式二（Mode II）. 模式二是因为受不了模式一的缺点而进化出来的，而Spring Mvc则是模式二的进化版本，下面是两种模式的介绍：\n* 模式一（Mode I）指的就是在开发中将显示层、控制层、数据层的操作统一交给JSP或者JavaBean来进行处理！\n    * 优点\n        * 开发速度贼快，适合炒鸡简单的应用 \n    * 缺点\n        * 程序的可读性差、复用性低、代码复杂！什么jsp代码、html代码都往上面写，这肯定很难阅读，很难重用！\n        * 要求开发者不仅要掌握 Java ，还要有高超的前端水平\n        * 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试\n        \n![](/images/server/spring/spring-mvc/model1.png)\n\n* 模式二（Mode II）中所有的开发都是以Servlet为主体展开的，由Servlet接收所有的客户端请求，然后根据请求调用相对应的JavaBean，并所有的显示结果交给JSP完成！，也就是俗称的MVC设计模式\n    * 优点\n        * 相比模式一，耦合度降低了，添加了Servlet来协调视图处理及业务数据处理\n    * 缺点\n        * 需要定义大量的Servlet来处理应用\n        \n    * MVC设计模式\n        * 模型层（Mode）：模型是什么呢？ 模型就是数据，就是 dao,bean\n        * 显示层（View）：视图是什么呢？ 就是网页, JSP，用来展示模型中的数据\n        * 控制层（Controller）：控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色，在Spring MVC中`DispatcherServlet`就是这个特殊的控制器\n \n* 很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合，\n\n![](/images/server/spring/spring-mvc/model2.png)\n\n* 模式二（Mode II）就很完美吗，不不不，还可以进行优化，所以有了Web Mvc框架\n\n    * 常见的Web Mvc框架有`Sturts`及主角`Spring Mvc`\n\n![](/images/server/spring/spring-mvc/model3.png)\n#### 2.1.2 对比其他WEB框架有那些优势\n* 使用简单，对于开发人员来说实现一个功能肯定是实现越简单越好，Spring Mvc配合一系列注解即可完成Web应用的开发，尤其是在SpringBoot上的体现越明显\n* 性能上Spring会稍微比Struts快。Spring mvc是基于方法的设计，而Sturts是基于类，每次发一次请求都会实例一个action，每个action都会被注入属性，而Spring基于方法，粒度更细，但要小心把握像在Servlet控制数据一样。\n* 易于和Spring容器集成，毕竟是自己家里人\n\n### 3.1 使用Spring Mvc\n\n\n### 4.1 总结\n* 框架本身就是为了找到一个平衡，用哪个合适，就用哪个\n\n### 5.1 参考\n* 官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\n* https://www.cnblogs.com/wmyskxz/p/8848461.html\n\n","tags":["spring"],"categories":["服务器"]},{"title":"Spring系列(七四)Spring事务之Mybatis集成事务管理","url":"/2019/08/02/backend/framework/spring/analysis/Spring系列(七四)Spring事务之Mybatis集成事务管理/","content":"## 前言\n\n* 使用 `MyBatis-Spring` 的主要原因是它允许 `MyBatis` 参与到 `Spring` 的事务管理中。而 不是给 `MyBatis` 创建一个新的特定的事务管理器,`MyBatis-Spring` 利用了存在于 Spring 中的 `DataSourceTransactionManager`。\n\n### 如何集成 `Spring`的事务管理\n \n* 配置 `DataSourceTransactionManager` Bean\n\n```xml\n    <!-- 数据库连接池 -->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\n          init-method=\"init\" destroy-method=\"close\">\n\n        <!-- 基本属性 url、IUser、password -->\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;characterEncoding=UTF-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n\n        <!-- 配置初始化大小、最小、最大 -->\n        <property name=\"initialSize\" value=\"1\"/>\n        <property name=\"minIdle\" value=\"1\"/>\n        <property name=\"maxActive\" value=\"20\"/>\n\n        <!-- 配置获取连接等待超时的时间 -->\n        <property name=\"maxWait\" value=\"60000\"/>\n\n        <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->\n        <property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/>\n\n        <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->\n        <property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/>\n\n        <!--\n            用来检测连接是否有效的sql，要求是一个查询语句。\n            如果validationQuery为null，testOnBorrow、testOnReturn、\n            testWhileIdle都不会其作用\n        -->\n        <property name=\"validationQuery\" value=\"SELECT 1 FROM DUAL\"/>\n        <property name=\"testWhileIdle\" value=\"true\"/>\n        <property name=\"testOnBorrow\" value=\"false\"/>\n        <property name=\"testOnReturn\" value=\"false\"/>\n\n        <!--\n            打开PSCache，并且指定每个连接上PSCache的大小\n            如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false\n        -->\n        <property name=\"poolPreparedStatements\" value=\"true\"/>\n        <property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\"/>\n\n        <!-- 配置监控统计拦截的filters，去掉后监控界面sql无法统计 -->\n        <property name=\"filters\" value=\"stat,wall,log4j\"/>\n\n        <!--\n            如果配置了proxyFilters，此配置可以不配置\n            druid.stat.mergeSql=true 合并执行的相同sql，避免因为参数不同而统计多条sql语句\n            druid.stat.slowSqlMillis=10000 用来配置SQL慢的标准，执行时间超过slowSqlMillis的就是慢\n\n        <property name=\"connectionProperties\" value=\"druid.stat.mergeSql=true;druid.stat.slowSqlMillis=10000\" />\n         -->\n\n        <!-- 监控统计拦截的filters -->\n        <!-- 并在filters属性中配置了log4j -->\n        <!--<property name=\"proxyFilters\">-->\n        <!--<list>-->\n        <!--<ref bean=\"stat-filter\" />-->\n        <!--<ref bean=\"log-filter\" />-->\n        <!--</list>-->\n        <!--</property>-->\n\n        <!-- 连接属性 -->\n        <property name=\"connectionProperties\">\n            <value>clientEncoding=UTF-8</value>\n        </property>\n    </bean>\n\n    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\" />\n        <constructor-arg index=\"1\" value=\"BATCH\" />\n    </bean>\n\n    <!-- 配置SqlSessionFactory对象 -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"typeAliasesPackage\" value=\"org.springframework.iframe.entity\"/>\n        <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\n    </bean>\n\n    <!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"org.springframework.iframe.mapper\"></property>\n    </bean>\n\n\n    <!-- (事务管理)transaction manager, use JtaTransactionManager for global tx -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n\n    <tx:annotation-driven proxy-target-class=\"false\" transaction-manager=\"transactionManager\" />\n```\n\n* 要注意, 为事务管理器指定的 `DataSource` 必须和用来创建 `SqlSessionFactoryBean` 的 是同一个数据源,否则事务管理器就无法工作了。\n\n* 一旦 `Spring` 的 `DataSourceTransactionManager` 配置好了,你可以在 `Spring` 中你可以使用`@Transactional` 注解来完成事物操作。在事务处理期间,一个单独的 `SqlSession` 对象（线程级别）将会被创建 和使用。当事务完成时,这个 `SqlSession` 会以合适的方式提交或回滚。相反如果没有开启事物那么`SqlSession` 对象就是方法级别的了，每次调用`Mapper`里的方法都会返回一个新的`SqlSession` 来处理，下面来看其内部是怎么实现的\n\n### 事务实现解析\n\n* 与`Spring`集成以后，`Spring`提供了一个全局唯一的`SqlSessionTemplate` 来完成`DefailtSqlSession`的功能\n\n* 进入`SqlSessionTemplate` 可以看到里面有个`SqlSession` 属性，看属性名可以看出这里又用了动态代理，为什么又要代理呢？下面来看看\n\n```java\n  // SqlSession代理\n  private final SqlSession sqlSessionProxy;\n```\n\n* 观察其构造方法，这里形成`SqlSession`代理类，再来看动态代理类`SqlSessionInterceptor`做了什么\n\n```java\n public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,\n      PersistenceExceptionTranslator exceptionTranslator) {\n\n    notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\");\n    notNull(executorType, \"Property 'executorType' is required\");\n\n    this.sqlSessionFactory = sqlSessionFactory;\n    this.executorType = executorType;\n    this.exceptionTranslator = exceptionTranslator;\n    // 形成SqlSession代理类\n    this.sqlSessionProxy = (SqlSession) newProxyInstance(\n        SqlSessionFactory.class.getClassLoader(),\n        new Class[] { SqlSession.class },\n        new SqlSessionInterceptor());\n  }\n```\n\n* 进入`SqlSessionInterceptor`类，这个`SqlSession`代理类的出现是为了让`Spring` 来管理`SqlSession` 的，从而实现事务管理\n\n\n```java\n  /**\n   * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession\n   * Proxy needed to route MyBatis method calls to the proper SqlSession got\n   * from Spring's Transaction Manager\n   * It also unwraps exceptions thrown by {@code Method#invoke(Object, Object...)} to\n   * pass a {@code PersistenceException} to the {@code PersistenceExceptionTranslator}.\n   */\n  private class SqlSessionInterceptor implements InvocationHandler {\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      // 获取SqlSession(这个SqlSession才是真正使用的，它不是线程安全的)\n      SqlSession sqlSession = getSqlSession(\n          SqlSessionTemplate.this.sqlSessionFactory,\n          SqlSessionTemplate.this.executorType,\n          SqlSessionTemplate.this.exceptionTranslator);\n      try {\n        // 调用真实SqlSession的方法\n        Object result = method.invoke(sqlSession, args);\n        // 判断一下当前的sqlSession是否被Spring托管\n        if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {\n          // force commit even on non-dirty sessions because some databases require\n          // a commit/rollback before calling close()\n          // 没有使用事务\n          sqlSession.commit(true);\n        }\n        return result;\n      } catch (Throwable t) {\n        Throwable unwrapped = unwrapThrowable(t);\n        if (SqlSessionTemplate.this.exceptionTranslator != null && unwrapped instanceof PersistenceException) {\n          // release the connection to avoid a deadlock if the translator is no loaded. See issue #22\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n          sqlSession = null;\n          Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);\n          if (translated != null) {\n            unwrapped = translated;\n          }\n        }\n        throw unwrapped;\n      } finally {\n        if (sqlSession != null) {\n          // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n        }\n      }\n    }\n  }\n```\n\n* 进入`getSqlSession()`方法，这里是获取`SqlSession` 的方法\n\n```java\n  public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) {\n\n    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);\n    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);\n\n    // 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder\n    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);\n\n    SqlSession session = sessionHolder(executorType, holder);\n    if (session != null) {\n      return session;\n    }\n    // 如果找不到，则根据执行类型构造一个新的sqlSession\n    LOGGER.debug(() -> \"Creating a new SqlSession\");\n    session = sessionFactory.openSession(executorType);\n\n    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);\n\n    return session;\n  }\n```\n\n* 关注`TransactionSynchronizationManager` 内部成员，这里使用`TreadLocal`记录事务的一些属性，用于应用扩展同步器的使用，在事务的开启，挂起，提交等各个点上回调应用的逻辑\n\n```java\n    // 应用代码随事务的声明周期绑定的对象\n\tprivate static final ThreadLocal<Map<Object, Object>> resources =\n\t\t\tnew NamedThreadLocal<>(\"Transactional resources\");\n\n    // synchronizations-使用的同步器，用于应用扩展\n\tprivate static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =\n\t\t\tnew NamedThreadLocal<>(\"Transaction synchronizations\");\n    \n\t// 事务的名称\n\tprivate static final ThreadLocal<String> currentTransactionName =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction name\");\n    \n\t// 事务是否是只读\n\tprivate static final ThreadLocal<Boolean> currentTransactionReadOnly =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction read-only status\");\n    \n\t// 事务的隔离界别\n\tprivate static final ThreadLocal<Integer> currentTransactionIsolationLevel =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction isolation level\");\n    \n\t// 事务是否开启\n\tprivate static final ThreadLocal<Boolean> actualTransactionActive =\n\t\t\tnew NamedThreadLocal<>(\"Actual transaction active\");\n\n```\n\n* 回到`SqlSessionInterceptor` 类`invoke`方法，这里有个if判断` if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {` 来判断是否开启了`Spring`事务，如果该`Session`未被`Spring`托管则自动`commit`\n\n```java\n  public static boolean isSqlSessionTransactional(SqlSession session, SqlSessionFactory sessionFactory) {\n    notNull(session, NO_SQL_SESSION_SPECIFIED);\n    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);\n\n    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);\n\n    return (holder != null) && (holder.getSqlSession() == session);\n  }\n```\n\n* 关注`invoke`方法的`finally`块的 `closeSqlSession()方法`，如果是开启了事务则没有执行`session.close();`\n\n```java\n    finally {\n        if (sqlSession != null) {\n          // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n        }\n      }\n```\n\n```java\n  public static void closeSqlSession(SqlSession session, SqlSessionFactory sessionFactory) {\n    notNull(session, NO_SQL_SESSION_SPECIFIED);\n    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);\n\n    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);\n    if ((holder != null) && (holder.getSqlSession() == session)) {\n      LOGGER.debug(() -> \"Releasing transactional SqlSession [\" + session + \"]\");\n      // 如果是开启了事务 SqlSession是没有被close的，所以方法体内使用的是一个SqlSession，当然一级缓存是生效的\n      holder.released();\n    } else {\n      LOGGER.debug(() -> \"Closing non transactional SqlSession [\" + session + \"]\");\n      session.close();\n    }\n  }\n```\n\n## 总结\n* 通过上述代码可以得出如果开启了事务，同一事务中同一个`sqlSessionFactory`创建的唯一`sqlSession`，一个事务中使用的是同一个`sqlSession`，为什么要用同一个`sqlSession`呢，是为了使用同一个`connection (JDBC)`\n* 如果没有开启事务，调用一次`mapper`里的方法将会新建一个`sqlSession`来执行方法\n\n## 参考\n* http://www.mybatis.org/spring/zh/factorybean.html\n* https://www.cnblogs.com/daxin/p/3544188.html","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(七三)Spring事务之PlatformTransactionManager","url":"/2019/08/02/backend/framework/spring/analysis/Spring系列(七三)Spring事务之PlatformTransactionManager/","content":"## 前言\n\n* `Spring` 事务的管理，是通过 `org.springframework.transaction.PlatformTransactionManager` 进行管理\n\n```java\n// PlatformTransactionManager.java\n\npublic interface PlatformTransactionManager {\n\n    // 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 \n    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;\n\n    // 根据情况，提交事务\n    void commit(TransactionStatus status) throws TransactionException;\n    \n    // 根据情况，回滚事务\n    void rollback(TransactionStatus status) throws TransactionException;\n    \n}\n```\n\n* `PlatformTransactionManager` 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。\n    * `#getTransaction(TransactionDefinition definition)`\n        * 根据事务定义 `TransactionDefinition` ，获得 `TransactionStatus `\n        * 为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建\n        * 什么返回的是 `TransactionStatus` 对象？在 `TransactionStatus` 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等\n    * `#commit(TransactionStatus status)`\n        * 根据 `TransactionStatus` 情况，提交事务\n        * 为什么根据 `TransactionStatus` 情况，进行提交？例如说，带`@Transactional` 注解的的 `A` 方法，会调用 `@Transactional` 注解的的 `B` 方法。\n            * 在 `B` 方法结束调用后，会执行 `PlatformTransactionManager#commit(TransactionStatus status)` 方法，此处事务是不能、也不会提交的。\n            * 而是在 `A` 方法结束调用后，执行 `PlatformTransactionManager#commit(TransactionStatus status)` 方法，提交事务。\n    * `#rollback(TransactionStatus status)`\n        * 根据 `TransactionStatus` 情况，回滚事务\n        * 为什么根据 `TransactionStatus` 情况，进行回滚？原因同 `#commit(TransactionStatus status)` 方法。\n \n### 子类\n\n* 先来一张`PlatformTransactionManager`接口的子类图\n\n![](/images/server/spring/analysis/tx/transaction4.png)\n\n* `PlatformTransactionManager` 有抽象子类 `org.springframework.transaction.support.AbstractPlatformTransactionManager` ，基于 模板方法模式实现事务整体逻辑的骨架，而抽象 `#doCommit(DefaultTransactionStatus status)、#doRollback(DefaultTransactionStatus status)` 等等方法，交由子类类来实现。\n\n* 不同的数据持久层框架，会有其对应的 `PlatformTransactionManager` 实现类\n    * `HibernateTransactionManager`\n        * 和`Hibernate5` 的事务管理做集成\n    * `DataSourceTransactionManager`\n        * 和 `JDBC` 的事务管理做集成。所以，它也适用于 `MyBatis、Spring JDBC` 等等。\n        * 最常使用的\n    * `JpaTransactionManager ` \n        * 和 `JPA` 的事务管理做集成\n\n### 其他支持类\n\n##### TransactionDefinition\n\n* `@Transactional` 注解的属性，会解析成 `org.springframework.transaction.TransactionDefinition` 对象，即事务定义\n\n```java\npublic interface TransactionDefinition {\n\n\tint getPropagationBehavior(); // 事务的传播行为\n\tint getIsolationLevel(); // 事务的隔离级别\n\tint getTimeout(); // 事务的超时时间\n\tboolean isReadOnly(); // 事务是否只读\n\t@Nullable\n\tString getName(); // 事务的名字\n\n}\n```\n\n* `TransactionDefinition`继承关系图\n\n![](/images/server/spring/analysis/tx/TransactionDefinition.png)\n\n* `@Transactional` 注解的 `rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName` 属性貌似没体现出来？它们提现在 `TransactionDefinition` 的实现类 `RuleBasedTransactionAttribute`中。\n\n##### TransactionStatus\n\n* `TransactionStatus` 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息\n\n```java\n// TransactionStatus.java\n\npublic interface TransactionStatus extends SavepointManager, Flushable {\n\n    /**\n     * 是否是新创建的事务\n     */\n    boolean isNewTransaction();\n\n    /**\n     * 是否有 Savepoint\n     *\n     * 在 {@link TransactionDefinition#PROPAGATION_NESTED} 传播级别使用。\n     */\n    boolean hasSavepoint();\n\n    /**\n     * 设置为只回滚\n     */\n    void setRollbackOnly();\n    /**\n     * 是否为只回滚\n     */\n    boolean isRollbackOnly();\n\n    /**\n     * 执行 flush 操作\n     */\n    @Override\n    void flush();\n\n    /**\n     * 是否事务已经完成\n     */\n    boolean isCompleted();\n\n}\n```\n\n* `TransactionStatus`继承关系图\n\n![](/images/server/spring/analysis/tx/TransactionStatus.png)\n\n* 为什么没有事务对象呢？在 `TransactionStatus` 的实现类 `DefaultTransactionStatus` 中，有个 `Object transaction` 属性，表示事务对象。\n* `#isNewTransaction()` 方法，表示是否是新创建的事务。有什么用呢？\n    * 我们对 `#commit(TransactionStatus status)` 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，才能且应该真正的提交事务。\n* 子类\n    * `org.springframework.transaction.interceptor.TransactionAttribute `\n        * 支持定义返回异常回滚的事务定义接口\n    * `org.springframework.transaction.interceptor.RuleBasedTransactionAttribute`\n        * 基于 `{@link RollbackRuleAttribute}` 的事务定义实现类\n        * 每个 `@Transactional` 注解的方法及每个`<tx:method />``XML`的配置 都会被解析成此对象\n\n## 总结\n* 使用 `Spring` 事务有什么优点？\n    * 通过 `PlatformTransactionManager` ，为不同的数据层持久框架提供统一的 `API` ，无需关心到底是原生 `JDBC、Spring JDBC、JPA、Hibernate` 还是 `MyBatis` 。\n\n\n## 参考\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(七二)Spring事务之具体执行过程","url":"/2019/08/02/backend/framework/spring/analysis/Spring系列(七二)Spring事务之具体执行过程/","content":"## 前言\n* 我们知道在`JDBC`中处理事务，都是通过`Connection`完成的，同一事务中所有的操作，都在使用同一个`Connection`对象，`Connection`的三个方法与事务有关，万变不离其宗，`Spring`的事务也是基于`JDBC`来实现的，那么`Spring`是怎么来写这些代码的呢，这就是本章要介绍的内容。\n\n```java\ntry {\n    // 设置是否为自动提交事务，如果true（默认值为true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，\n    // 如果设置为false，那么相当于开启了事务了；con.setAutoCommit(false) 表示开启事务。\n    con.setAutoCommit(false);\n    ......\n    // 提交事务     \n    con.commit(); \n} catch（） {\n    // 回滚事务\n    con.rollback();\n}\n```\n\n* 上一章节介绍了`<tx:annotation-driven>`标签是开启事务的开关，配置了这个就可以使用注解`@Transactional`来开启事务了，下面通过一个例子看看`Spring`事务的执行过程\n\n* 下面的`updateUserByRuntimeException()`方法添加了`@Transactional`注解，这个方法先是插入一条记录，然后再更新另一条记录，如果没有开启事务的话，会执行第一条`sql`语句，第二条`sql`语句不会执行\n\n```java\n    // org.springframework.iframe.service.impl.UserServiceImpl\n\n    @Transactional\n    public void updateUserByRuntimeException (IUser iUser) throws NullPointerException{\n        log.info(\"开启事务\");\n        if (userMapper.insertSelective(iUser) == 1) {\n            throw new NullPointerException(\"运行时异常\");\n        }\n        IUser iUser2 = userMapper.selectByPrimaryKey(1);\n        iUser2.setAge(iUser2.getAge() + 1);\n        userMapper.updateByPrimaryKeySelective(iUser2);\n    }\n```\n\n* 测试类及配置文件\n\n```java\n// org.springframework.iframe.test.transaction.TransactionTests\n\n@Slf4j\npublic class TransactionTests {\n\n    private final ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/applicationContext.xml\");\n\n    /**\n     * 运行时异常事务处理\n     * 事务会回滚\n     */\n    @Test\n    public void runtimeExceptionTransactionTest() throws Exception {\n        UserService userService = xmlApplicationContext.getBean(UserService.class);\n        IUser iUser = new IUser();\n        iUser.setUsername(\"运行时异常 事务会回滚\");\n        iUser.setAge(1);\n        userService.updateUserByRuntimeException(iUser);\n    }\n```\n\n```xml\n// beans/applicationContext.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                              http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\">\n\n    <!-- ComponentScanBeanDefinitionParser-->\n    <context:component-scan base-package = \"org.springframework.iframe.*\"/>\n\n    <aop:aspectj-autoproxy/>\n\n    <import resource=\"applicationContext-dao.xml\"/>\n\n</beans>\n```\n\n```xml\n// beans/applicationContext-dao.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:p=\"http://www.springframework.org/schema/p\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"\n          http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n          http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n          http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\">\n    <!-- 数据库连接池 -->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\n          init-method=\"init\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;characterEncoding=UTF-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"root\"/>\n        <property name=\"initialSize\" value=\"1\"/>\n        <property name=\"minIdle\" value=\"1\"/>\n        <property name=\"maxActive\" value=\"20\"/>\n        <property name=\"maxWait\" value=\"60000\"/>\n        <property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/>\n        <property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/>\n        <property name=\"validationQuery\" value=\"SELECT 1 FROM DUAL\"/>\n        <property name=\"testWhileIdle\" value=\"true\"/>\n        <property name=\"testOnBorrow\" value=\"false\"/>\n        <property name=\"testOnReturn\" value=\"false\"/>\n        <property name=\"poolPreparedStatements\" value=\"true\"/>\n        <property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\"/>\n        <property name=\"filters\" value=\"stat,wall,log4j\"/>\n        <property name=\"connectionProperties\">\n            <value>clientEncoding=UTF-8</value>\n        </property>\n    </bean>\n\n    <bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\" />\n        <constructor-arg index=\"1\" value=\"BATCH\" />\n    </bean>\n\n    <!-- 配置SqlSessionFactory对象 -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"typeAliasesPackage\" value=\"org.springframework.iframe.entity\"/>\n        <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\n    </bean>\n\n    <!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"org.springframework.iframe.mapper\"></property>\n    </bean>\n\n    <!-- (事务管理)transaction manager, use JtaTransactionManager for global tx -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n\n    <tx:annotation-driven proxy-target-class=\"false\" transaction-manager=\"transactionManager\" />\n</beans>\n```\n\n## 调试\n\n* 现在来执行测试类，执行`UserService userService = xmlApplicationContext.getBean(UserService.class);`见下图可以看到`userService`是`JdkDynamicAopProxy`对象，由此可以得到`Spring`事务是通过`AOP`来实现的，由`AOP`来完成事务方法的织入及执行\n\n![](/images/server/spring/analysis/tx/transaction1.png)\n\n* 进入`userService.updateUserByRuntimeException(iUser);`方法，会跳到`JdkDynamicAopProxy`类的`invoke()`方法，这些逻辑和我们之前介绍`AOP`章节的内容是一致的\n\n```java\n/**\n * Implementation of {@code InvocationHandler.invoke}.\n * <p>Callers will see exactly the exception thrown by the target,\n * unless a hook method throws an exception.\n */\n@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    MethodInvocation invocation;\n    Object oldProxy = null;\n    boolean setProxyContext = false;\n\n    TargetSource targetSource = this.advised.targetSource;\n    Class<?> targetClass = null;\n    Object target = null;\n\n    try {\n        // 如果被代理的目标对象要执行的方法是equal则执行JdkDynamicAopProxy（即代理对象的equal）方法\n        if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n            // The target does not implement the equals(Object) method itself.\n            return equals(args[0]);\n        }\n        // 如果被代理的目标对象要执行的方法是hashCode则执行JdkDynamicAopProxy（即代理对象的hashCode）方法\n        else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n            // The target does not implement the hashCode() method itself.\n            return hashCode();\n        }\n        else if (method.getDeclaringClass() == DecoratingProxy.class) {\n            // There is only getDecoratedClass() declared -> dispatch to proxy config.\n            return AopProxyUtils.ultimateTargetClass(this.advised);\n        }\n        else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&\n                method.getDeclaringClass().isAssignableFrom(Advised.class)) {\n            // Service invocations on ProxyConfig with the proxy config...\n            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n        }\n\n        Object retVal;\n        // 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理\n        if (this.advised.exposeProxy) {\n            // Make invocation available if necessary.\n            oldProxy = AopContext.setCurrentProxy(proxy);\n            setProxyContext = true;\n        }\n\n        // May be null. Get as late as possible to minimize the time we \"own\" the target,\n        // in case it comes from a pool.\n        target = targetSource.getTarget();\n        if (target != null) {\n            targetClass = target.getClass();\n        }\n\n        // Get the interception chain for this method.\n        // 获取当前方法的拦截器链\n        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n        // Check whether we have any advice. If we don't, we can fallback on direct\n        // reflective invocation of the target, and avoid creating a MethodInvocation.\n        if (chain.isEmpty()) {\n            // We can skip creating a MethodInvocation: just invoke the target directly\n            // Note that the final invoker must be an InvokerInterceptor so we know it does\n            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n            // 如果没有发现任何拦截器那么直接调用切点方法\n            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n        }\n        else {\n            // We need to create a method invocation...\n            // 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器\n            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n            // Proceed to the joinpoint through the interceptor chain.\n            // 执行拦截器链\n            retVal = invocation.proceed();\n        }\n\n        // Massage return value if necessary.\n        Class<?> returnType = method.getReturnType();\n        if (retVal != null && retVal == target &&\n                returnType != Object.class && returnType.isInstance(proxy) &&\n                !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n            // Special case: it returned \"this\" and the return type of the method\n            // is type-compatible. Note that we can't help if the target sets\n            // a reference to itself in another returned object.\n            retVal = proxy;\n        }\n        // 返回结果\n        else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n            throw new AopInvocationException(\n                    \"Null return value from advice does not match primitive return type for: \" + method);\n        }\n        return retVal;\n    }\n    finally {\n        if (target != null && !targetSource.isStatic()) {\n            // Must have come from TargetSource.\n            targetSource.releaseTarget(target);\n        }\n        if (setProxyContext) {\n            // Restore old proxy.\n            AopContext.setCurrentProxy(oldProxy);\n        }\n    }\n}\n```\n\n* 上面要注意的是`List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);`，获取当前方法的拦截器链，由下图可以看到这里得到的是`TransactionInterceptor`事务拦截器，是不是有些眉目了\n\n![](/images/server/spring/analysis/tx/transaction2.png)\n\n* 得到拦截器之后就是执行`invocation.proceed();`方法了\n\n```java\n@Override\npublic Object proceed() throws Throwable {\n    //\tWe start with an index of -1 and increment early.\n    // 执行完所有增强后执行切点方法，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法\n    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n        return invokeJoinpoint();\n    }\n    // 获取下一个要执行的拦截器 沿着拦截器链执行\n    Object interceptorOrInterceptionAdvice =\n            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n        // Evaluate dynamic method matcher here: static part will already have\n        // been evaluated and found to match.\n        // 对方法进行动态匹配，切点的匹配就在这里进行\n        InterceptorAndDynamicMethodMatcher dm =\n                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n            return dm.interceptor.invoke(this);\n        }\n        else {\n            // Dynamic matching failed.\n            // Skip this interceptor and invoke the next in the chain.\n            // 不匹配则跳过这个拦截器调用下一个\n            return proceed();\n        }\n    }\n    else {\n        // It's an interceptor, so we just invoke it: The pointcut will have\n        // been evaluated statically before this object was constructed.\n        //  这是一个拦截器，直接调用它，将this作为参数传递以保证当前实例中调用链的执行\n        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n    }\n}\n```\n\n* 进入`((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this)`方法执行拦截器的方法\n\n```java\n// org.springframework.transaction.interceptor.TransactionInterceptor#invoke\n\n@Override\npublic Object invoke(final MethodInvocation invocation) throws Throwable {\n    // Work out the target class: may be {@code null}.\n    // The TransactionAttributeSource should be passed the target class\n    // as well as the method, which may be from an interface.\n    Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);\n\n    // Adapt to TransactionAspectSupport's invokeWithinTransaction...\n    return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {\n        @Override\n        public Object proceedWithInvocation() throws Throwable {\n            return invocation.proceed();\n        }\n    });\n}\n```\n\n* 执行`invokeWithinTransaction()`进入到`TransactionInterceptor`的父类中`TransactionAspectSupport`，下面的方法可以说是`Spring`事务的核心代码了\n\n```java\n// org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction\n\n/**\n * General delegate for around-advice-based subclasses, delegating to several other template\n * methods on this class. Able to handle {@link CallbackPreferringPlatformTransactionManager}\n * as well as regular {@link PlatformTransactionManager} implementations.\n * @param method the Method being invoked\n * @param targetClass the target class that we're invoking the method on\n * @param invocation the callback to use for proceeding with the target invocation\n * @return the return value of the method, if any\n * @throws Throwable propagated from the target invocation\n */\nprotected Object invokeWithinTransaction(Method method, Class<?> targetClass, final InvocationCallback invocation)\n        throws Throwable {\n\n    // If the transaction attribute is null, the method is non-transactional.\n    // 获取对应的事务属性\n    final TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);\n    // 获取beanFactory中的transactionManager\n    final PlatformTransactionManager tm = determineTransactionManager(txAttr);\n    // 构造方法唯一标识(service.UserServiceImpl.save)\n    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);\n\n    // 声明式事务处理\n    if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {\n        // Standard transaction demarcation with getTransaction and commit/rollback calls.\n        // 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作\n        TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\n        Object retVal = null;\n        try {\n            // This is an around advice: Invoke the next interceptor in the chain.\n            // This will normally result in a target object being invoked.\n            // 方法调用\n            retVal = invocation.proceedWithInvocation();\n        }\n        catch (Throwable ex) {\n            // target invocation exception\n            // 回滚事务 注意：只对RuntimeException回滚\n            completeTransactionAfterThrowing(txInfo, ex);\n            throw ex;\n        }\n        finally {\n            // 清除信息\n            cleanupTransactionInfo(txInfo);\n        }\n        // 提交事务\n        commitTransactionAfterReturning(txInfo);\n        return retVal;\n    }\n\n    else {\n        // 编程式事务处理\n        // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.\n        try {\n            Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr,\n                    new TransactionCallback<Object>() {\n                        @Override\n                        public Object doInTransaction(TransactionStatus status) {\n                            TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\n                            try {\n                                return invocation.proceedWithInvocation();\n                            }\n                            catch (Throwable ex) {\n                                if (txAttr.rollbackOn(ex)) {\n                                    // A RuntimeException: will lead to a rollback.\n                                    if (ex instanceof RuntimeException) {\n                                        throw (RuntimeException) ex;\n                                    }\n                                    else {\n                                        throw new ThrowableHolderException(ex);\n                                    }\n                                }\n                                else {\n                                    // A normal return value: will lead to a commit.\n                                    return new ThrowableHolder(ex);\n                                }\n                            }\n                            finally {\n                                cleanupTransactionInfo(txInfo);\n                            }\n                        }\n                    });\n\n            // Check result: It might indicate a Throwable to rethrow.\n            if (result instanceof ThrowableHolder) {\n                throw ((ThrowableHolder) result).getThrowable();\n            }\n            else {\n                return result;\n            }\n        }\n        catch (ThrowableHolderException ex) {\n            throw ex.getCause();\n        }\n    }\n}\n```\n\n* 上面的逻辑分为声明式事务处理及编程式事务处理，我们这里关注声明式事务处理，由上面可以看到主要逻辑分为下面几点，是不是有些上面`JDBC`事务代码的影子了\n    * 1、创建事务\n    * 2、方法调用\n    * 3、如有异常回滚事务\n    * 4、提交事务\n\n#### 1、创建事务\n\n* `TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);`这行代码是创建事务的逻辑，可以看到是封装了一个`TransactionInfo`对象，现在先进入`createTransactionIfNecessary()`方法\n\n```java\n// org.springframework.transaction.interceptor.TransactionAspectSupport#createTransactionIfNecessary\n\nprotected TransactionInfo createTransactionIfNecessary(\n        PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) {\n\n    // If no name specified, apply method identification as transaction name.\n    // 如果没有名称指定则使用方法唯一标识，并使用DelegatingTransactionAttribute封装txAttr\n    if (txAttr != null && txAttr.getName() == null) {\n        txAttr = new DelegatingTransactionAttribute(txAttr) {\n            @Override\n            public String getName() {\n                return joinpointIdentification;\n            }\n        };\n    }\n\n    TransactionStatus status = null;\n    if (txAttr != null) {\n        if (tm != null) {\n            // 核心 获取TransactionStatus 这里有建立事务连接\n            status = tm.getTransaction(txAttr);\n        }\n        else {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Skipping transactional joinpoint [\" + joinpointIdentification +\n                        \"] because no transaction manager has been configured\");\n            }\n        }\n    }\n    // 根据指定的属性与status准备一个TransactionInfo\n    return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);\n}\n```\n\n* 关注`status = tm.getTransaction(txAttr);`方法，这里是建立事务连接关键\n\n\n```java\n// org.springframework.transaction.support.AbstractPlatformTransactionManager#getTransaction\n\n@Override\npublic final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {\n    Object transaction = doGetTransaction();\n\n    // Cache debug flag to avoid repeated checks.\n    boolean debugEnabled = logger.isDebugEnabled();\n\n    if (definition == null) {\n        // Use defaults if no transaction definition given.\n        definition = new DefaultTransactionDefinition();\n    }\n\n    // 判断当前线程是否存在事务，判断依据为当前线程记录的连接不为空且连接中(connectionHolder)中的transactionActive属性不为空\n    if (isExistingTransaction(transaction)) {\n        // Existing transaction found -> check propagation behavior to find out how to behave.\n        // 当前线程已经存在事务\n        return handleExistingTransaction(definition, transaction, debugEnabled);\n    }\n\n    // Check definition settings for new transaction.\n    // 事务超时设置验证\n    if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {\n        throw new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout());\n    }\n\n    // No existing transaction found -> check propagation behavior to find out how to proceed.\n    // 如果当前线程不存在事务，propagationBehavior声明为PROPAGATION_MANDATORY 抛异常\n    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {\n        throw new IllegalTransactionStateException(\n                \"No existing transaction found for transaction marked with propagation 'mandatory'\");\n    }\n    else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||\n            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||\n            definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n        // 需要新建事务\n        SuspendedResourcesHolder suspendedResources = suspend(null);\n        if (debugEnabled) {\n            logger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition);\n        }\n        try {\n            boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n            DefaultTransactionStatus status = newTransactionStatus(\n                    definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);\n            /**\n             * 构建transaction ，包括设置ConnectionHolder、隔离级别、timout\n             */\n            doBegin(transaction, definition);\n            // 新同步事务的设置，针对与当前线程的设置，将事务信息记录在当前线程中\n            prepareSynchronization(status, definition);\n            return status;\n        }\n        catch (RuntimeException ex) {\n            resume(null, suspendedResources);\n            throw ex;\n        }\n        catch (Error err) {\n            resume(null, suspendedResources);\n            throw err;\n        }\n    }\n    else {\n        // Create \"empty\" transaction: no actual transaction, but potentially synchronization.\n        if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {\n            logger.warn(\"Custom isolation level specified but no actual transaction initiated; \" +\n                    \"isolation level will effectively be ignored: \" + definition);\n        }\n        boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n        return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);\n    }\n}\n```\n\n* 进入`doBegin(transaction, definition);`方法，可以看到`Connection newCon = this.dataSource.getConnection();`这里获取了`JDBC`的`Connection`，然后就是通过`con.setAutoCommit(false);`来开启事务了，获取数据库连接之后就是通过`TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());`来将连接绑定到当前线程中（使用`ThreadLocal`来实现）\n\n```java\n/**\n * 构建transaction，包括设置ConnectionHolder、隔离级别、timeout\n * 如果是新连接，绑定到当前线程，这个函数已经开始尝试了对数据库连接的获取\n *\n * This implementation sets the isolation level but ignores the timeout.\n */\n@Override\nprotected void doBegin(Object transaction, TransactionDefinition definition) {\n    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\n    Connection con = null;\n\n    try {\n        // 尝试获取连接，当然并不是每次都获取新的连接，如果当前线程中ConnectionHolder已经存在，则不需要再次获取\n        if (txObject.getConnectionHolder() == null ||\n                txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\n            Connection newCon = this.dataSource.getConnection();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\n            }\n            txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\n        }\n\n        txObject.getConnectionHolder().setSynchronizedWithTransaction(true);\n        con = txObject.getConnectionHolder().getConnection();\n\n        // 设置隔离级别\n        Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\n        txObject.setPreviousIsolationLevel(previousIsolationLevel);\n\n        // Switch to manual commit if necessary. This is very expensive in some JDBC drivers,\n        // so we don't want to do it unnecessarily (for example if we've explicitly\n        // configured the connection pool to set it already).\n        // 更改Connection自动提交设置，由Spring控制提交\n        if (con.getAutoCommit()) {\n            txObject.setMustRestoreAutoCommit(true);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\n            }\n            con.setAutoCommit(false);\n        }\n\n        prepareTransactionalConnection(con, definition);\n        // 设置判断当前线程是否存在事务的依据\n        txObject.getConnectionHolder().setTransactionActive(true);\n\n        // 设置过期时间\n        int timeout = determineTimeout(definition);\n        if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\n            txObject.getConnectionHolder().setTimeoutInSeconds(timeout);\n        }\n\n        // Bind the connection holder to the thread.\n        if (txObject.isNewConnectionHolder()) {\n            // 将当前获取到的连接绑定到当前线程\n            TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());\n        }\n    }\n\n    catch (Throwable ex) {\n        if (txObject.isNewConnectionHolder()) {\n            DataSourceUtils.releaseConnection(con, this.dataSource);\n            txObject.setConnectionHolder(null, false);\n        }\n        throw new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\n    }\n}\n```\n\n#### 2、方法调用\n\n```java\n// 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作\nTransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\nObject retVal = null;\ntry {\n    // This is an around advice: Invoke the next interceptor in the chain.\n    // This will normally result in a target object being invoked.\n    // 方法调用\n    retVal = invocation.proceedWithInvocation();\n}\ncatch (Throwable ex) {\n    // target invocation exception\n    // 回滚事务 注意：只对RuntimeException回滚\n    completeTransactionAfterThrowing(txInfo, ex);\n    throw ex;\n}\nfinally {\n    // 清除信息\n    cleanupTransactionInfo(txInfo);\n}\n// 提交事务\ncommitTransactionAfterReturning(txInfo);\n```\n\n* 上面获取了`TransactionInfo`之后就是来执行方法了，进入`invocation.proceedWithInvocation();`，可以看到又回到了上面的`org.springframework.transaction.interceptor.TransactionAspectSupport#invokeWithinTransaction`的方法中，这里执行的是`invocation.proceed();`方法\n\n```java\n@Override\npublic Object invoke(final MethodInvocation invocation) throws Throwable {\n    // Work out the target class: may be {@code null}.\n    // The TransactionAttributeSource should be passed the target class\n    // as well as the method, which may be from an interface.\n    Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);\n\n    // Adapt to TransactionAspectSupport's invokeWithinTransaction...\n    return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() {\n        @Override\n        public Object proceedWithInvocation() throws Throwable {\n            return invocation.proceed();\n        }\n    });\n}\n```\n\n* 进入`invocation.proceed();`方法，又回到了`ReflectiveMethodInvocation#proceed`方法，只不过现在是执行的`invokeJoinpoint();`方法\n\n```java\n// org.springframework.aop.framework.ReflectiveMethodInvocation#proceed\n\npublic Object proceed() throws Throwable {\n    //\tWe start with an index of -1 and increment early.\n    // 执行完所有增强后执行切点方法，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法\n    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n        return invokeJoinpoint();\n    }\n    // 获取下一个要执行的拦截器 沿着拦截器链执行\n    Object interceptorOrInterceptionAdvice =\n            this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n        // Evaluate dynamic method matcher here: static part will already have\n        // been evaluated and found to match.\n        // 对方法进行动态匹配，切点的匹配就在这里进行\n        InterceptorAndDynamicMethodMatcher dm =\n                (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n        if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n            return dm.interceptor.invoke(this);\n        }\n        else {\n            // Dynamic matching failed.\n            // Skip this interceptor and invoke the next in the chain.\n            // 不匹配则跳过这个拦截器调用下一个\n            return proceed();\n        }\n    }\n    else {\n        // It's an interceptor, so we just invoke it: The pointcut will have\n        // been evaluated statically before this object was constructed.\n        //  这是一个拦截器，直接调用它，将this作为参数传递以保证当前实例中调用链的执行\n        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n    }\n```\n\n* 进入`invokeJoinpoint();`方法，下面的使用了反射(`method.invoke(target, args);`)执行了我们的`org.springframework.iframe.service.impl.UserServiceImpl#updateUserByRuntimeException`方法\n\n```java\nprotected Object invokeJoinpoint() throws Throwable {\n    return AopUtils.invokeJoinpointUsingReflection(this.target, this.method, this.arguments);\n}\n\npublic static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args)\n        throws Throwable {\n\n    // 使用反射执行方法\n    try {\n        ReflectionUtils.makeAccessible(method);\n        return method.invoke(target, args);\n    }\n    catch (InvocationTargetException ex) {\n        // Invoked method threw a checked exception.\n        // We must rethrow it. The client won't see the interceptor.\n        throw ex.getTargetException();\n    }\n    catch (IllegalArgumentException ex) {\n        throw new AopInvocationException(\"AOP configuration seems to be invalid: tried calling method [\" +\n                method + \"] on target [\" + target + \"]\", ex);\n    }\n    catch (IllegalAccessException ex) {\n        throw new AopInvocationException(\"Could not access method [\" + method + \"]\", ex);\n    }\n}\n```\n\n* 进入`org.springframework.iframe.service.impl.UserServiceImpl#updateUserByRuntimeException`方法，这里插入一条记录之后就抛出一个异常，之后的逻辑就是下面的了\n\n```java\n@Override\n@Transactional\npublic void updateUserByRuntimeException (IUser iUser) throws NullPointerException{\n    log.info(\"开启事务\");\n    if (userMapper.insertSelective(iUser) == 1) {\n        throw new NullPointerException(\"运行时异常\");\n    }\n    IUser iUser2 = userMapper.selectByPrimaryKey(1);\n    iUser2.setAge(iUser2.getAge() + 1);\n    userMapper.updateByPrimaryKeySelective(iUser2);\n}\n```\n\n#### 3、如有异常回滚事务\n\n* 上面的`throw new NullPointerException(\"运行时异常\");`抛出了一个空指针异常，所以被我们下面的逻辑给`catch`到了\n\n```java\n// 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作\nTransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\nObject retVal = null;\ntry {\n    // This is an around advice: Invoke the next interceptor in the chain.\n    // This will normally result in a target object being invoked.\n    // 方法调用\n    retVal = invocation.proceedWithInvocation();\n}\ncatch (Throwable ex) {\n    // target invocation exception\n    // 回滚事务 注意：只对RuntimeException回滚\n    completeTransactionAfterThrowing(txInfo, ex);\n    throw ex;\n}\nfinally {\n    // 清除信息\n    cleanupTransactionInfo(txInfo);\n}\n// 提交事务\ncommitTransactionAfterReturning(txInfo);\nreturn retVal;\n```\n\n* 关注`completeTransactionAfterThrowing(txInfo, ex);`方法\n\n```java\n// org.springframework.transaction.interceptor.TransactionAspectSupport#completeTransactionAfterThrowing\n\n/**\n * Handle a throwable, completing the transaction.\n * We may commit or roll back, depending on the configuration.\n * @param txInfo information about the current transaction\n * @param ex throwable encountered\n */\nprotected void completeTransactionAfterThrowing(TransactionInfo txInfo, Throwable ex) {\n    // 当抛出异常时首先判断当前是否存在事务，这是基础依据\n    if (txInfo != null && txInfo.hasTransaction()) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() +\n                    \"] after exception: \" + ex);\n        }\n        // 这里判断是否回滚默认的依据是抛出的异常是否是 (ex instanceof RuntimeException || ex instanceof Error)，我们熟悉的Exception默认是不处理的\n        if (txInfo.transactionAttribute.rollbackOn(ex)) {\n            try {\n                // 核心 根据TransactionStatus信息进行回滚处理\n                txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());\n            }\n            catch (TransactionSystemException ex2) {\n                logger.error(\"Application exception overridden by rollback exception\", ex);\n                ex2.initApplicationException(ex);\n                throw ex2;\n            }\n            catch (RuntimeException ex2) {\n                logger.error(\"Application exception overridden by rollback exception\", ex);\n                throw ex2;\n            }\n            catch (Error err) {\n                logger.error(\"Application exception overridden by rollback error\", ex);\n                throw err;\n            }\n        }\n        else {\n            // 如果不满足回滚条件即使抛出异常也同样会提交\n            // We don't roll back on this exception.\n            // Will still roll back if TransactionStatus.isRollbackOnly() is true.\n            try {\n                txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n            }\n            catch (TransactionSystemException ex2) {\n                logger.error(\"Application exception overridden by commit exception\", ex);\n                ex2.initApplicationException(ex);\n                throw ex2;\n            }\n            catch (RuntimeException ex2) {\n                logger.error(\"Application exception overridden by commit exception\", ex);\n                throw ex2;\n            }\n            catch (Error err) {\n                logger.error(\"Application exception overridden by commit error\", ex);\n                throw err;\n            }\n        }\n    }\n}\n```\n\n* 下面先判断当前是否存在事务，可以看到`Spring`的严谨，然后就是判断抛出的异常是否是`RuntimeException及Error`，之后就是`rollback`\n    * 判断抛出的异常是否是`RuntimeException及Error`\n        * 进入`txInfo.transactionAttribute.rollbackOn(ex)`方法一直进入直到看到下面的代码，可以看到这里的异常判断只处理了`RuntimeException及Error`异常，另一个编译型异常`Exception`是不处理的，这个在开发过程中需要特别注意\n        ```java\n        ...      \n  \n        public boolean rollbackOn(Throwable ex) {\n            return (ex instanceof RuntimeException || ex instanceof Error);\n        }\n        ```\n    * `rollback`\n        * 进入`txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());`方法之后一直进入直到进入下面的代码，可以看到这里使用`txObject.getConnectionHolder().getConnection();`获取了我们之前新建的`Connection`，得到之后就是执行`con.rollback();`方法了\n        ```java\n        // org.springframework.jdbc.datasource.DataSourceTransactionManager#doRollback\n  \n        @Override\n        protected void doRollback(DefaultTransactionStatus status) {\n            DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n            Connection con = txObject.getConnectionHolder().getConnection();\n            if (status.isDebug()) {\n                logger.debug(\"Rolling back JDBC transaction on Connection [\" + con + \"]\");\n            }\n            try {\n                con.rollback();\n            }\n            catch (SQLException ex) {\n                throw new TransactionSystemException(\"Could not roll back JDBC transaction\", ex);\n            }\n        }\n        ```\n#### 4、提交事务\n\n* 上面可以知道如果有异常的话是执行`completeTransactionAfterThrowing(txInfo, ex);`方法进行事务回滚，然后抛异常之后的逻辑都不执行\n\n```java\n// 创建事物 创建TransactionInfo 完成了目标方法运行前的事务准备工作\nTransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);\nObject retVal = null;\ntry {\n    // This is an around advice: Invoke the next interceptor in the chain.\n    // This will normally result in a target object being invoked.\n    // 方法调用\n    retVal = invocation.proceedWithInvocation();\n}\ncatch (Throwable ex) {\n    // target invocation exception\n    // 回滚事务 注意：只对RuntimeException回滚\n    completeTransactionAfterThrowing(txInfo, ex);\n    throw ex;\n}\nfinally {\n    // 清除信息\n    cleanupTransactionInfo(txInfo);\n}\n// 提交事务\ncommitTransactionAfterReturning(txInfo);\nreturn retVal;\n```\n\n* 如果没有异常的话会执行`commitTransactionAfterReturning(txInfo);`方法\n\n```java\nprotected void commitTransactionAfterReturning(TransactionInfo txInfo) {\n    if (txInfo != null && txInfo.hasTransaction()) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"Completing transaction for [\" + txInfo.getJoinpointIdentification() + \"]\");\n        }\n        txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());\n    }\n}\n\n// 进入 org.springframework.transaction.support.AbstractPlatformTransactionManager#commit\n\n@Override\npublic final void commit(TransactionStatus status) throws TransactionException {\n    if (status.isCompleted()) {\n        throw new IllegalTransactionStateException(\n                \"Transaction is already completed - do not call commit or rollback more than once per transaction\");\n    }\n\n    DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;\n    if (defStatus.isLocalRollbackOnly()) {\n        if (defStatus.isDebug()) {\n            logger.debug(\"Transactional code has requested rollback\");\n        }\n        processRollback(defStatus);\n        return;\n    }\n    if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {\n        if (defStatus.isDebug()) {\n            logger.debug(\"Global transaction is marked as rollback-only but transactional code requested commit\");\n        }\n        processRollback(defStatus);\n        // Throw UnexpectedRollbackException only at outermost transaction boundary\n        // or if explicitly asked to.\n        if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {\n            throw new UnexpectedRollbackException(\n                    \"Transaction rolled back because it has been marked as rollback-only\");\n        }\n        return;\n    }\n    // 事务提交\n    processCommit(defStatus);\n}\n\nprivate void processCommit(DefaultTransactionStatus status) throws TransactionException {\n    try {\n        boolean beforeCompletionInvoked = false;\n        try {\n            // 预留口子方法执行额外逻辑\n            prepareForCommit(status);\n            triggerBeforeCommit(status);\n            triggerBeforeCompletion(status);\n            \n            beforeCompletionInvoked = true;\n            boolean globalRollbackOnly = false;\n            if (status.isNewTransaction() || isFailEarlyOnGlobalRollbackOnly()) {\n                globalRollbackOnly = status.isGlobalRollbackOnly();\n            }\n            if (status.hasSavepoint()) {\n                if (status.isDebug()) {\n                    logger.debug(\"Releasing transaction savepoint\");\n                }\n                // 如果存在保存点则清除保存点信息\n                status.releaseHeldSavepoint();\n            }\n            else if (status.isNewTransaction()) {\n                if (status.isDebug()) {\n                    logger.debug(\"Initiating transaction commit\");\n                }\n                // 如果时独立事务直接提交\n                doCommit(status);\n            }\n            // Throw UnexpectedRollbackException if we have a global rollback-only\n            // marker but still didn't get a corresponding exception from commit.\n            if (globalRollbackOnly) {\n                throw new UnexpectedRollbackException(\n                        \"Transaction silently rolled back because it has been marked as rollback-only\");\n            }\n        }\n        catch (UnexpectedRollbackException ex) {\n            // can only be caused by doCommit\n            triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);\n            throw ex;\n        }\n        catch (TransactionException ex) {\n            // can only be caused by doCommit\n            if (isRollbackOnCommitFailure()) {\n                doRollbackOnCommitException(status, ex);\n            }\n            else {\n                triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);\n            }\n            throw ex;\n        }\n        catch (RuntimeException ex) {\n            if (!beforeCompletionInvoked) {\n                triggerBeforeCompletion(status);\n            }\n            doRollbackOnCommitException(status, ex);\n            throw ex;\n        }\n        catch (Error err) {\n            if (!beforeCompletionInvoked) {\n                triggerBeforeCompletion(status);\n            }\n            // 提交过程中出现异常则回滚\n            doRollbackOnCommitException(status, err);\n            throw err;\n        }\n\n        // Trigger afterCommit callbacks, with an exception thrown there\n        // propagated to callers but the transaction still considered as committed.\n        try {\n            triggerAfterCommit(status);\n        }\n        finally {\n            triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);\n        }\n\n    }\n    finally {\n        cleanupAfterCompletion(status);\n    }\n}\n```\n\n* 关注核心方法`doCommit(status);`这里是提交事务的关键，当然如果提交事务的时候发生了异常也会执行回滚操作，由下图可以看到`Spring`由那些类实现了此方法\n\n![](/images/server/spring/analysis/tx/transaction3.png)\n\n* 我们这里进入的是`org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit`方法，终于看到我们熟悉的`con.commit();`方法\n\n```java\n// org.springframework.jdbc.datasource.DataSourceTransactionManager#doCommit\n\n@Override\nprotected void doCommit(DefaultTransactionStatus status) {\n    DataSourceTransactionObject txObject = (DataSourceTransactionObject) status.getTransaction();\n    Connection con = txObject.getConnectionHolder().getConnection();\n    if (status.isDebug()) {\n        logger.debug(\"Committing JDBC transaction on Connection [\" + con + \"]\");\n    }\n    try {\n        // 提交事务\n        con.commit();\n    }\n    catch (SQLException ex) {\n        throw new TransactionSystemException(\"Could not commit JDBC transaction\", ex);\n    }\n}\n```\n\n* 在此`Spring`事务的执行完成!!!\n\n### 其他\n\n* 为什么在 `Spring` 事务中不能切换数据源？\n    * 在 Spring 的事务管理中所使用的数据库连接会和当前线程所绑定，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。\n* \n\n* 什么是事务的传播级别？分成哪些传播级别？\n    * 事务的传播行为，指的是当前带有事务配置的方法，需要怎么处理事务。\n        * 例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。\n        * 有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，而是 Spring 自身所定义的。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。\n    * 在`TransactionDefinition` 接口中，定义了三类七种传播级别。代码如下\n        * `TransactionDefinition.java`\n        ```java\n        // TransactionDefinition.java\n        \n        // ========== 支持当前事务的情况 ========== \n        \n        /**\n         * 如果当前存在事务，则使用该事务。\n         * 如果当前没有事务，则创建一个新的事务。\n         */\n        int PROPAGATION_REQUIRED = 0;\n        /**\n         * 如果当前存在事务，则使用该事务。\n         * 如果当前没有事务，则以非事务的方式继续运行。\n         */\n        int PROPAGATION_SUPPORTS = 1;\n        /**\n         * 如果当前存在事务，则使用该事务。\n         * 如果当前没有事务，则抛出异常。\n         */\n        int PROPAGATION_MANDATORY = 2;\n        \n        // ========== 不支持当前事务的情况 ========== \n        \n        /**\n         * 创建一个新的事务。\n         * 如果当前存在事务，则把当前事务挂起。\n         */\n        int PROPAGATION_REQUIRES_NEW = 3;\n        /**\n         * 以非事务方式运行。\n         * 如果当前存在事务，则把当前事务挂起。\n         */\n        int PROPAGATION_NOT_SUPPORTED = 4;\n        /**\n         * 以非事务方式运行。\n         * 如果当前存在事务，则抛出异常。\n         */\n        int PROPAGATION_NEVER = 5;\n        \n        // ========== 其他情况 ========== \n        \n        /**\n         * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。\n         * 如果当前没有事务，则等价于 {@link TransactionDefinition#PROPAGATION_REQUIRED}\n         */\n        int PROPAGATION_NESTED = 6;\n        ```\n        * 分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 `PROPAGATION_REQUIRED` 传播级别。\n## 总结\n* 事务说白了就是“绑架”一个数据库连接，更改数据库的自动提交功能，使用手动提交机制。`Spring`把这一系列操作属性及数据库连接放到了`ThreadLocal`中，而`ThreadLocal`的`key`为“当前线程的值”，可以说一个线程一个连接一个事务`\n* 声明式事务管理建立在`AOP`之上的，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务\n* 默认情况下`Spring`中的事务处理只对`RuntimeException`运行时异常进行回滚，对`Exception`编译性异常不会进行回滚\n* 通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(七一)Spring事务之解析事务自定义标签","url":"/2019/08/02/backend/framework/spring/analysis/Spring系列(七一)Spring事务之解析事务自定义标签/","content":"## 前言\n\n* `Spring`事务让我们从复杂的事务处理中得到解脱，使我们再不需要去处理获得连接、关闭连接、事务提交和回滚等操作，`Spring`事务分为声明式事务和编程式事务，其中编程式事务因为对代码入侵较大所以不被推荐使用，我们平常最常使用的是声明式事务也就是通过`@Transactional`注解的形式开启事务\n    * 编程式事务\n        * 示例代码\n        ```java\n        @Autowired\n        private TransactionTemplate transactionTemplate;\n        \n        @Autowired\n        private PlatformTransactionManager transactionManager;\n        \n        //开启事务保存数据\n        boolean result = transactionTemplate.execute(new TransactionCallback<Boolean>() {\n            @Override\n            public Boolean doInTransaction(TransactionStatus status) {\n                try {\n                    // TODO something\n                } catch (Exception e) {\n                    //TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); //手动开启事务回滚\n                    status.setRollbackOnly();\n                    logger.error(e.getMessage(), e);\n                    return false;\n                }\n                return true;\n            }\n        });\n        ```\n    * 声明式事务\n        * `xml`配置\n        ```xml\n        <!-- (事务管理)transaction manager, use JtaTransactionManager for global tx -->\n        <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n            <property name=\"dataSource\" ref=\"dataSource\"/>\n        </bean>\n    \n        <tx:annotation-driven proxy-target-class=\"false\" transaction-manager=\"transactionManager\" />\n        ```\n        * `<tx:annotation-driven>`标签是开启声明式事务的开关，配置了这个就可以使用注解`@Transactional`来开启事务了\n        ```java\n        // org.springframework.iframe.service.impl.UserServiceImpl#updateUserByRuntimeException      \n  \n        @Transactional\n        public void updateUserByRuntimeException (IUser iUser) throws NullPointerException{\n            log.info(\"开启事务\");\n            if (userMapper.insertSelective(iUser) == 1) {\n                throw new NullPointerException(\"运行时异常\");\n            }\n            IUser iUser2 = userMapper.selectByPrimaryKey(1);\n            iUser2.setAge(iUser2.getAge() + 1);\n            userMapper.updateByPrimaryKeySelective(iUser2);\n        }\n        ```\n        * 也可以用xml的方式配置那些方法需要加事务\n            * `xml`配置\n             ```xml \n            <!-- 配置事务通知属性 -->\n            <tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n                <!-- 定义事务传播属性 -->\n                <tx:attributes>\n                    <tx:method name=\"insert*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"edit*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"save*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"add*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"new*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"set*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"remove*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"change*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"check*\" propagation=\"REQUIRED\"/>\n                    <tx:method name=\"get*\" propagation=\"REQUIRED\" read-only=\"true\"/>\n                    <tx:method name=\"find*\" propagation=\"REQUIRED\" read-only=\"true\"/>\n                    <tx:method name=\"load*\" propagation=\"REQUIRED\" read-only=\"true\"/>\n                    <tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"true\"/>\n                </tx:attributes>\n            </tx:advice>\n        \n            <!-- 配置事务切面 -->\n            <aop:config>\n                <aop:pointcut id=\"serviceOperation\"\n                              expression=\"execution(* org.springframework.iframe.service.*.*(..))\"/>\n                <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"serviceOperation\"/>\n            </aop:config>\n             ```\n            * 从上面可以看到编程式事务需要配置哪些方法需要事务控制，比如`<tx:method name=\"insert*\" propagation=\"REQUIRED\"/>`配置的就是`insert`开头的方法会有事务控制，然后`aop:config`配置了事务切面，上面的配置是`org.springframework.iframe.service`包下方法名符合`insert*、update*`规则的方法会有事务控制\n            \n## 解析\n\n### 声明式事务原理解析\n\n* 由上面介绍可以看到开启声明式事务的关键是`<tx:annotation-driven>`标签，由前些章节知识积累可以发现这个标签也是自定义标签，所以需要找到对应的`NamespaceHandler`\n    * 先查看`NamespaceHandler`的实现类\n    ![](/images/server/spring/analysis/tx/NamespaceHandler.png)\n    * 根据名称可以定位到`TxNamespaceHandler`，下面代码可以看到<tx:advice/>标签的解析是给通过`TxAdviceBeanDefinitionParser`类进行解析，<tx:annotation-driven/>标签的解析是通过`AnnotationDrivenBeanDefinitionParser`类进行解析\n    ```java\n    public class TxNamespaceHandler extends NamespaceHandlerSupport {  \n        static final String TRANSACTION_MANAGER_ATTRIBUTE = \"transaction-manager\";  \n        static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = \"transactionManager\";  \n        static String getTransactionManagerName(Element element) {\n            return (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?\n                    element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);\n        }\n        @Override\n        public void init() {\n            // 对<tx:advice/>标签的解析\n            registerBeanDefinitionParser(\"advice\", new TxAdviceBeanDefinitionParser());\n            // 对<tx:annotation-driven/>标签的解析\n            registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser());\n            registerBeanDefinitionParser(\"jta-transaction-manager\", new JtaTransactionManagerBeanDefinitionParser());\n        } \n    }\n    ```\n#### AnnotationDrivenBeanDefinitionParser\n\n* 进入`parse()`方法开始解析\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    registerTransactionalEventListenerFactory(parserContext);\n    String mode = element.getAttribute(\"mode\");\n    if (\"aspectj\".equals(mode)) {\n        // mode=\"aspectj\"\n        registerTransactionAspect(element, parserContext);\n    }\n    else {\n        // mode=\"proxy\"\n        // 提供对aspectj方式进行事务切入的支持\n        AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);\n    }\n    return null;\n}\n```\n\n* 我们这里是进入`AopAutoProxyConfigurer.configueAutoProxyCreator(element, parserContext);`方法，可以看到下面逻辑主要是注册了一些`bean`，这些`bean`支撑了整个事务功能，后面会详细说明\n    * `InfrastructureAdvisorAutoProxyCreator`\n    * `AnnotationTransactionAttributeSource`\n    * `TransactionInterceptor`\n    * `BeanFactoryTransactionAttributeSourceAdvisor`\n\n* 进入`AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);`方法\n\n```java\n/**\n * Inner class to just introduce an AOP framework dependency when actually in proxy mode.\n */\nprivate static class AopAutoProxyConfigurer {\n\n    public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {\n        // 注册 InfrastructureAdvisorAutoProxyCreator bean 这个类继承了 BeanPostProcessor，这里实现了AOP代理对象的创建\n        AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);\n\n        String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;\n        if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {\n            Object eleSource = parserContext.extractSource(element);\n\n            // 创建 AnnotationTransactionAttributeSource definition.\n            RootBeanDefinition sourceDef = new RootBeanDefinition(\n                    \"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource\");\n            sourceDef.setSource(eleSource);\n            sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n            // 注册TransactionAttributeSource bean，并使用Spring中的定义规则生成beanname\n            String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);\n\n            // 创建 TransactionInterceptor definition.\n            RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);\n            interceptorDef.setSource(eleSource);\n            interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\n            // <tx:annotation-driven/>标签在不指定transaction-manager属性的时候，会默认寻找id固定名为transactionManager的bean作为事务管理器\n            registerTransactionManager(element, interceptorDef);\n            interceptorDef.getPropertyValues().add(\"transactionAttributeSource\", new RuntimeBeanReference(sourceName));\n            // 注册TransactionInterceptor bean，\n            String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);\n\n            // 创建 BeanFactoryTransactionAttributeSourceAdvisor definition.\n            RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);\n            advisorDef.setSource(eleSource);\n            advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n            // 将sourceName的bean注入advisorDef的transactionAttributeSource属性中\n            // 并将前两个BeanDefinition添加到第三个BeanDefinition的属性当中\n            advisorDef.getPropertyValues().add(\"transactionAttributeSource\", new RuntimeBeanReference(sourceName));\n            advisorDef.getPropertyValues().add(\"adviceBeanName\", interceptorName);\n            if (element.hasAttribute(\"order\")) {\n                advisorDef.getPropertyValues().add(\"order\", element.getAttribute(\"order\"));\n            }\n            // 注册BeanFactoryTransactionAttributeSourceAdvisor bean\n            parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);\n\n            // 创建CompositeComponentDefinition\n            CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), eleSource);\n            compositeDef.addNestedComponent(new BeanComponentDefinition(sourceDef, sourceName));\n            compositeDef.addNestedComponent(new BeanComponentDefinition(interceptorDef, interceptorName));\n            compositeDef.addNestedComponent(new BeanComponentDefinition(advisorDef, txAdvisorBeanName));\n            parserContext.registerComponent(compositeDef);\n        }\n    }\n}\n\n```\n\n* `AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);`，这里注册了 `InfrastructureAdvisorAutoProxyCreator` `bean` 这个类继承了 `BeanPostProcessor`，这里实现了`AOP`代理对象的创建\n\n![](/images/server/spring/analysis/tx/InfrastructureAdvisorAutoProxyCreator.png)\n\n* 所以关注`InfrastructureAdvisorAutoProxyCreator`的`postProcessAfterInitialization()`方法，进入其父类`AbstractAutoProxyCreator`中，这行代码是不是很熟悉没错就是创建`AOP`动态代理对象的方法\n\n```java\n// org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization\n\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    if (bean != null) {\n        // 根据给定的bean的class和name构建出个key，格式: beanClassName_beanName\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            // 如果它适合被代理，则需要封装指定的bean\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    // 如果已经处理过\n    if (beanName != null && this.targetSourcedBeans.contains(beanName)) {\n        return bean;\n    }\n    // 无需增强\n    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n        return bean;\n    }\n    // 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理\n    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        return bean;\n    }\n\n    // Create proxy if we have advice.\n    // 如果存在增强方法则创建代理\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    // 如果获取到了增强则需要针对增强创建代理\n    if (specificInterceptors != DO_NOT_PROXY) {\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        // 创建代理 1、获取增强方法或者增强器 2、根据获取的增强进行代理\n        Object proxy = createProxy(\n                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        return proxy;\n    }\n\n    this.advisedBeans.put(cacheKey, Boolean.FALSE);\n    return bean;\n}\n```\n\n* 关注` Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);`这里是检查是否存在增强方法，如果有的话则创建代理，这里的内容`AOP`章节已经介绍了些\n\n```java\n@Override\nprotected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, TargetSource targetSource) {\n    // 获取所有的增强以及寻找所有增强中适用于bean的增强并应用\n    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n    if (advisors.isEmpty()) {\n        return DO_NOT_PROXY;\n    }\n    return advisors.toArray();\n}\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    // 获取所有增强器\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    // 从所有增强器中找出适合的增强器\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n\n* 可以看到先是获取了所有的增强器，然后在所有增强器中找出适合的增强器并返回\n    * 获取所有增强器\n        * 进入`findCandidateAdvisors();`方法之后直接跳到`findAdvisorBeans()`方法，关注`advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false);`方法这里获取所有对应`Advisor.class`的类\n        * 回顾之前的`AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);`方法是注册了`BeanFactoryTransactionAttributeSourceAdvisor`，看名称可以知道是继承了`Advisor`接口，所以这里获取增强器也会把这个类添加进来\n        ```java\n        public List<Advisor> findAdvisorBeans() {\n            // Determine list of advisor bean names, if not cached already.\n            String[] advisorNames = null;\n            synchronized (this) {\n                advisorNames = this.cachedAdvisorBeanNames;\n                if (advisorNames == null) {\n                    // Do not initialize FactoryBeans here: We need to leave all regular beans\n                    // uninitialized to let the auto-proxy creator apply to them!\n                    // 获取所有的beanName\n                    advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Advisor.class, true, false);\n                    this.cachedAdvisorBeanNames = advisorNames;\n                }\n            }\n            if (advisorNames.length == 0) {\n                return new LinkedList<Advisor>();\n            }\n    \n            List<Advisor> advisors = new LinkedList<Advisor>();\n            // 循环所有的beanname找出对应的增强方法\n            for (String name : advisorNames) {\n                if (isEligibleBean(name)) {\n                    if (this.beanFactory.isCurrentlyInCreation(name)) {\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"Skipping currently created advisor '\" + name + \"'\");\n                        }\n                    }\n                    else {\n                        try {\n                            advisors.add(this.beanFactory.getBean(name, Advisor.class));\n                        }\n                        catch (BeanCreationException ex) {\n                            Throwable rootCause = ex.getMostSpecificCause();\n                            if (rootCause instanceof BeanCurrentlyInCreationException) {\n                                BeanCreationException bce = (BeanCreationException) rootCause;\n                                if (this.beanFactory.isCurrentlyInCreation(bce.getBeanName())) {\n                                    if (logger.isDebugEnabled()) {\n                                        logger.debug(\"Skipping advisor '\" + name +\n                                                \"' with dependency on currently created bean: \" + ex.getMessage());\n                                    }\n                                    // Ignore: indicates a reference back to the bean we're trying to advise.\n                                    // We want to find advisors other than the currently created bean itself.\n                                    continue;\n                                }\n                            }\n                            throw ex;\n                        }\n                    }\n                }\n            }\n            return advisors;\n        }\n        ```\n    * 从所有增强器中找出适合的增强器\n        * 上面已经获取了所有增强器，接下来就是匹配符合条件的增强器了，下面关注最后一个`canApply()`方法可以看到`if (advisor instanceof PointcutAdvisor)`判断\n        ```java\n        protected List<Advisor> findAdvisorsThatCanApply(\n                List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {\n    \n            ProxyCreationContext.setCurrentProxiedBeanName(beanName);\n            try {\n                // 过滤已经得到的advisors\n                return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\n            }\n            finally {\n                ProxyCreationContext.setCurrentProxiedBeanName(null);\n            }\n        }\n  \n        public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n            if (candidateAdvisors.isEmpty()) {\n                return candidateAdvisors;\n            }\n            List<Advisor> eligibleAdvisors = new LinkedList<Advisor>();\n            // 首先处理引介增强\n            for (Advisor candidate : candidateAdvisors) {\n                // canApply真正的匹配\n                if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n                    eligibleAdvisors.add(candidate);\n                }\n            }\n            boolean hasIntroductions = !eligibleAdvisors.isEmpty();\n            for (Advisor candidate : candidateAdvisors) {\n                if (candidate instanceof IntroductionAdvisor) {\n                    // 引介增强已经处理\n                    // already processed\n                    continue;\n                }\n                // 对于普通bean的处理\n                if (canApply(candidate, clazz, hasIntroductions)) {\n                    eligibleAdvisors.add(candidate);\n                }\n            }\n            return eligibleAdvisors;\n        }\n  \n        public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n            if (advisor instanceof IntroductionAdvisor) {\n                return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n            }\n            else if (advisor instanceof PointcutAdvisor) {\n                PointcutAdvisor pca = (PointcutAdvisor) advisor;\n                return canApply(pca.getPointcut(), targetClass, hasIntroductions);\n            }\n            else {\n                // It doesn't have a pointcut so we assume it applies.\n                return true;\n            }\n        }\n        ```\n        * 当前我们分析`UserService`是否适用于此增强方法，那么当前的`advisor`就是之前自定义标签解析的`BeanFactoryTransactionAttributeSourceAdvisor`，这个类间接实现了`PointcutAdvisor`，然后调用` canApply(pca.getPointcut(), targetClass, hasIntroductions)`方法，所以现在就将`AOP`和`TX`联系起来了\n        * 进入`canApply(pca.getPointcut(), targetClass, hasIntroductions)`方法，这里`pca.getPointcut()`返回的是`TransactionAttributeSourcePointcut`，这也是上面解析自定义标签时注入进入的\n        ```java\n        public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n            Assert.notNull(pc, \"Pointcut must not be null\");\n            if (!pc.getClassFilter().matches(targetClass)) {\n                return false;\n            }\n            // TransactionAttributeSourcePointcut里的MethodMatcher\n            MethodMatcher methodMatcher = pc.getMethodMatcher();\n            if (methodMatcher == MethodMatcher.TRUE) {\n                // No need to iterate the methods if we're matching any method anyway...\n                return true;\n            }\n    \n            IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n            if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n                introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n            }\n    \n            Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n            classes.add(targetClass);\n            for (Class<?> clazz : classes) {\n                Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n                // 获取对应类的所有接口并连同类本身一起遍历，在遍历过程中又对类中的方法再次遍历，一但匹配成功便认为这个类使用于当前增强器\n                for (Method method : methods) {\n                    if ((introductionAwareMethodMatcher != null &&\n                            introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||\n                            methodMatcher.matches(method, targetClass)) {\n                        return true;\n                    }\n                }\n            }\n    \n            return false;\n        }\n        ```\n        * 可以看到先是获取`TransactionAttributeSourcePointcut`里的`MethodMatcher`，然后就是获取对应类的所有接口并连同类本身一起遍历，在遍历过程中又对类中的方法再次遍历，一但匹配成功便认为这个类使用于当前增强器，所以关注`TransactionAttributeSourcePointcut`里的`MethodMatcher`里的`matches(method, targetClass)`方法\n        ```java\n        @Override\n        public boolean matches(Method method, Class<?> targetClass) {\n            if (TransactionalProxy.class.isAssignableFrom(targetClass)) {\n                return false;\n            }\n            // 自定义标签解析时注入，这里tas是AnnotationTransactionAttributeSource\n            TransactionAttributeSource tas = getTransactionAttributeSource();\n            return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);\n        }\n        ```\n        * 进入`tas.getTransactionAttribute()`方法，这里跳到`org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource#getTransactionAttribute`，这里是判断我们的业务方法或者类上是否有`@Transactional`注解并且做了一下缓存处理\n        ```java\n        /**\n         * 判断我们的业务方法或者类上是否有@Transactional注解\n         *\n         * Determine the transaction attribute for this method invocation.\n         * <p>Defaults to the class's transaction attribute if no method attribute is found.\n         * @param method the method for the current invocation (never {@code null})\n         * @param targetClass the target class for this invocation (may be {@code null})\n         * @return TransactionAttribute for this method, or {@code null} if the method\n         * is not transactional\n         */\n        @Override\n        public TransactionAttribute getTransactionAttribute(Method method, Class<?> targetClass) {\n            if (method.getDeclaringClass() == Object.class) {\n                return null;\n            }\n    \n            // First, see if we have a cached value.\n            Object cacheKey = getCacheKey(method, targetClass);\n            Object cached = this.attributeCache.get(cacheKey);\n            if (cached != null) {\n                // Value will either be canonical value indicating there is no transaction attribute,\n                // or an actual transaction attribute.\n                if (cached == NULL_TRANSACTION_ATTRIBUTE) {\n                    return null;\n                }\n                else {\n                    return (TransactionAttribute) cached;\n                }\n            }\n            else {\n                // We need to work it out.\n                // 获取事物属性\n                TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);\n                // Put it in the cache.\n                if (txAttr == null) {\n                    this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);\n                }\n                else {\n                    String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);\n                    if (txAttr instanceof DefaultTransactionAttribute) {\n                        ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Adding transactional method '\" + methodIdentification + \"' with attribute: \" + txAttr);\n                    }\n                    // 存入缓存\n                    this.attributeCache.put(cacheKey, txAttr);\n                }\n                return txAttr;\n            }\n        }\n        ```\n        * 关注`computeTransactionAttribute(method, targetClass);`，可以看到如果方法中存在事务属性，则使用方法上的事务属性，否则使用方法所在类上的事务属性，如果还是没找到就搜寻接口中的方法的事务属性，再没有就找接口类上的事务属性\n        ```java\n        protected TransactionAttribute computeTransactionAttribute(Method method, Class<?> targetClass) {\n            // Don't allow no-public methods as required.\n            if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {\n                return null;\n            }\n    \n            // Ignore CGLIB subclasses - introspect the actual user class.\n            Class<?> userClass = ClassUtils.getUserClass(targetClass);\n            // The method may be on an interface, but we need attributes from the target class.\n            // If the target class is null, the method will be unchanged.\n            Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass);\n            // If we are dealing with method with generic parameters, find the original method.\n            specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\n    \n            // First try is the method in the target class.\n            // 查看方法中是否存在事务声明\n            TransactionAttribute txAttr = findTransactionAttribute(specificMethod);\n            if (txAttr != null) {\n                return txAttr;\n            }\n    \n            // Second try is the transaction attribute on the target class.\n            // 查看方法所在类中是否有事务声明\n            txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());\n            if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n                return txAttr;\n            }\n    \n            if (specificMethod != method) {\n                // Fallback is to look at the original method.\n                // 查看接口方法中是否有事务声明\n                txAttr = findTransactionAttribute(method);\n                if (txAttr != null) {\n                    return txAttr;\n                }\n                // Last fallback is the class of the original method.\n                // 查看接口类中是否有事务声明\n                txAttr = findTransactionAttribute(method.getDeclaringClass());\n                if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {\n                    return txAttr;\n                }\n            }\n    \n            return null;\n        }\n        ```\n        * 具体查找逻辑在`findTransactionAttribute()`方法上\n        ```java\n        @Override\n        protected TransactionAttribute findTransactionAttribute(Method method) {\n            return determineTransactionAttribute(method);\n        }      \n        protected TransactionAttribute determineTransactionAttribute(AnnotatedElement ae) {\n            if (ae.getAnnotations().length > 0) {\n                for (TransactionAnnotationParser annotationParser : this.annotationParsers) {\n                    TransactionAttribute attr = annotationParser.parseTransactionAnnotation(ae);\n                    if (attr != null) {\n                        return attr;\n                    }\n                }\n            }\n            return null;\n        }\n        ```\n        * 然后就是跳到`org.springframework.transaction.annotation.SpringTransactionAnnotationParser#parseTransactionAnnotation(java.lang.reflect.AnnotatedElement)`方法上，这里的方法就是解析 `{@link Transactional}` 注解，并封装成`TransactionAttribute`\n        ```java\n        @Override\n        public TransactionAttribute parseTransactionAnnotation(AnnotatedElement ae) {\n            AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ae, Transactional.class);\n            if (attributes != null) {\n                return parseTransactionAnnotation(attributes);\n            }\n            else {\n                return null;\n            }\n        }\n        /**\n         * 解析 {@link Transactional} 注解\n         *\n         * @param attributes\n         * @return\n         */\n        protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {\n            RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();\n            Propagation propagation = attributes.getEnum(\"propagation\");\n            rbta.setPropagationBehavior(propagation.value());\n            Isolation isolation = attributes.getEnum(\"isolation\");\n            rbta.setIsolationLevel(isolation.value());\n            rbta.setTimeout(attributes.getNumber(\"timeout\").intValue());\n            rbta.setReadOnly(attributes.getBoolean(\"readOnly\"));\n            rbta.setQualifier(attributes.getString(\"value\"));\n            ArrayList<RollbackRuleAttribute> rollBackRules = new ArrayList<RollbackRuleAttribute>();\n            Class<?>[] rbf = attributes.getClassArray(\"rollbackFor\");\n            for (Class<?> rbRule : rbf) {\n                RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);\n                rollBackRules.add(rule);\n            }\n            String[] rbfc = attributes.getStringArray(\"rollbackForClassName\");\n            for (String rbRule : rbfc) {\n                RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);\n                rollBackRules.add(rule);\n            }\n            Class<?>[] nrbf = attributes.getClassArray(\"noRollbackFor\");\n            for (Class<?> rbRule : nrbf) {\n                NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);\n                rollBackRules.add(rule);\n            }\n            String[] nrbfc = attributes.getStringArray(\"noRollbackForClassName\");\n            for (String rbRule : nrbfc) {\n                NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);\n                rollBackRules.add(rule);\n            }\n            rbta.getRollbackRules().addAll(rollBackRules);\n            return rbta;\n        }\n       ```\n* 回到`AbstractAutoProxyCreator#postProcessAfterInitialization`方法，这里是创建`AOP`代理对象的逻辑\n\n```java\n// org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#postProcessAfterInitialization\n\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    if (bean != null) {\n        // 根据给定的bean的class和name构建出个key，格式: beanClassName_beanName\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            // 如果它适合被代理，则需要封装指定的bean\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    // 如果已经处理过\n    if (beanName != null && this.targetSourcedBeans.contains(beanName)) {\n        return bean;\n    }\n    // 无需增强\n    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n        return bean;\n    }\n    // 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理\n    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        return bean;\n    }\n\n    // Create proxy if we have advice.\n    // 如果存在增强方法则创建代理\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    // 如果获取到了增强则需要针对增强创建代理\n    if (specificInterceptors != DO_NOT_PROXY) {\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        // 创建代理 1、获取增强方法或者增强器 2、根据获取的增强进行代理\n        Object proxy = createProxy(\n                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        return proxy;\n    }\n\n    this.advisedBeans.put(cacheKey, Boolean.FALSE);\n    return bean;\n}\n```\n\n* 现在来看看`UserService`的获取到的增强器，可以看到是获取到了`BeanFactoryTransactionAttributeSourceAdvisor`，这里是根据该`Advisor`来创建代理对象，到这里`Spring`事务自定义标签的解析过程已经介绍完了，可以总结为下面几个步骤：\n    * 1、解析事务自定义标签`<tx:annotation-driven>`，注册`InfrastructureAdvisorAutoProxyCreator`及`BeanFactoryTransactionAttributeSourceAdvisor`等`bean`\n    * 2、`InfrastructureAdvisorAutoProxyCreator`实现了`BeanPostProcessor`，所以可以遍历所有的`bean`用于创建代理对象\n    * 3、那些类需要创建事务代理对象，则由`BeanFactoryTransactionAttributeSourceAdvisor`提供实现\n    \n![](/images/server/spring/analysis/tx/transaction5.png)\n\n### 编程式事务原理解析\n\n* 可以看到编程式事务是通过`TransactionTemplate`及`PlatformTransactionManager`硬编码的形式来实现的，实际使用起来比声明式事务麻烦，而且侵入性强，因为这个很少使用所以不解析\n\n\n## 总结\n* `<tx:annotation-driven>`标签是开启事务的开关，配置了这个就可以使用注解`@Transactional`来开启事务了，解析该标签的过程就是注册`bean`的过程\n    * 注册`BeanFactoryTransactionAttributeSourceAdvisor`是整个事务功能的基础，这个类是判断这个`bean`是否需要适用事务增强，如果需要的话就创建`AOP`代理对象\n    * 在解析事务自定义标签时`Spring`将`TransactionInterceptor`类注入到了`BeanFactoryTransactionAttributeSourceAdvisor`，所以在调用事务增强器增强的代理类时会首先执行`TransactionInterceptor`进行增强，同时其`invoke`方法完成了整个事务的逻辑\n* `Spring`事务的初始化过程的大概逻辑是检查所有的`bean`是否需要创建`AOP`代理，判断逻辑是判断所在类及所在类的方法是否有`@Transactional`注解，如果有的话就创建代理，创建代理之后就是执行代理方法了，下章介绍\n## 参考\n* 《Spring 源码深度解析》","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(七十)Spring事务之基础概念","url":"/2019/08/02/backend/framework/spring/analysis/Spring系列(七十)Spring事务之基础概念/","content":"## 前言\n\n#### 什么是事务？\n\n* 事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。\n\n#### 事务的特性ACID\n\n##### 1、原子性 Atomicity\n\n* 一个事务`（transaction）`中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复`（Rollback）`到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\n\n##### 2、一致性 Consistency\n\n* 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器)、级联回滚等。\n\n##### 3、隔离性 Isolation \n\n* 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 \n\n##### 4、持久性 Durability \n\n* 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n#### 事务的隔离性\n\n* MySQL数据库针对这四种特性，为我们提供的四种隔离级别，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。\n\n## 参考\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(五四)AOP源码解析之代理对象方法执行","url":"/2019/08/01/backend/framework/spring/analysis/Spring系列(五四)AOP源码解析之代理对象方法执行/","content":"## 前言\n\n* 上一章节介绍了`AOP`代理对象的创建，那么实际方法的运行是通过代理对象来操作的，本章节将介绍代理对象方法的执行过程\n\n* `AopProxy`它有两个子类，所以不同代理对象方法执行过程是不一样的\n    * `JdkDynamicAopProxy `是基于 `JDK` 的 `AOP` 代理实现类\n    * `ObjenesisCglibAopProxy `是基于 `CGLIB` 的 `AOP` 的代理实现类\n\n## 解析\n\n#### 1、JdkDynamicAopProxy\n\n* 我们知道`JDK`的动态代理是通过`Proxy`,`InvocationHandler`来实现的，所以抓住这两个点来分析这个`JdkDynamicAopProxy`\n\n* 先看一下`JdkDynamicAopProxy`这个类的继承关系，可以看到这个类实现了`InvocationHandler`接口，所以关注里面的`invoke`方法，同时还继承了`AopProxy`接口，这个接口的作用是返回对应的代理对象\n\n![](/images/server/spring/analysis/aop/JdkDynamicAopProxy.png)\n\n* 下面是`JdkDynamicAopProxy`的主体代码\n\n```java\nfinal class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {\n\n\tprivate static final long serialVersionUID = 5531744639992436476L;\n\n\tprivate static final Log logger = LogFactory.getLog(JdkDynamicAopProxy.class);\n\n\t/** Config used to configure this proxy */\n\tprivate final AdvisedSupport advised;\n\n\t/**\n\t * Is the {@link #equals} method defined on the proxied interfaces?\n\t */\n\tprivate boolean equalsDefined;\n\n\t/**\n\t * Is the {@link #hashCode} method defined on the proxied interfaces?\n\t */\n\tprivate boolean hashCodeDefined;\n\n\n\t/**\n\t * Construct a new JdkDynamicAopProxy for the given AOP configuration.\n\t * @param config the AOP configuration as AdvisedSupport object\n\t * @throws AopConfigException if the config is invalid. We try to throw an informative\n\t * exception in this case, rather than let a mysterious failure happen later.\n\t */\n\tpublic JdkDynamicAopProxy(AdvisedSupport config) throws AopConfigException {\n\t\tAssert.notNull(config, \"AdvisedSupport must not be null\");\n\t\tif (config.getAdvisors().length == 0 && config.getTargetSource() == AdvisedSupport.EMPTY_TARGET_SOURCE) {\n\t\t\tthrow new AopConfigException(\"No advisors and no TargetSource specified\");\n\t\t}\n\t\tthis.advised = config;\n\t}\n\n\n\t@Override\n\tpublic Object getProxy() {\n\t\treturn getProxy(ClassUtils.getDefaultClassLoader());\n\t}\n\n\t@Override\n\tpublic Object getProxy(ClassLoader classLoader) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Creating JDK dynamic proxy: target source is \" + this.advised.getTargetSource());\n\t\t}\n\t\tClass<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n\t\tfindDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n\t\treturn Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n\t}\n\n\t/**\n\t * Finds any {@link #equals} or {@link #hashCode} method that may be defined\n\t * on the supplied set of interfaces.\n\t * @param proxiedInterfaces the interfaces to introspect\n\t */\n\tprivate void findDefinedEqualsAndHashCodeMethods(Class<?>[] proxiedInterfaces) {\n\t\tfor (Class<?> proxiedInterface : proxiedInterfaces) {\n\t\t\tMethod[] methods = proxiedInterface.getDeclaredMethods();\n\t\t\tfor (Method method : methods) {\n\t\t\t\tif (AopUtils.isEqualsMethod(method)) {\n\t\t\t\t\tthis.equalsDefined = true;\n\t\t\t\t}\n\t\t\t\tif (AopUtils.isHashCodeMethod(method)) {\n\t\t\t\t\tthis.hashCodeDefined = true;\n\t\t\t\t}\n\t\t\t\tif (this.equalsDefined && this.hashCodeDefined) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Implementation of {@code InvocationHandler.invoke}.\n\t * <p>Callers will see exactly the exception thrown by the target,\n\t * unless a hook method throws an exception.\n\t */\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\tMethodInvocation invocation;\n\t\tObject oldProxy = null;\n\t\tboolean setProxyContext = false;\n\n\t\tTargetSource targetSource = this.advised.targetSource;\n\t\tClass<?> targetClass = null;\n\t\tObject target = null;\n\n\t\ttry {\n\t\t\t// 如果被代理的目标对象要执行的方法是equal则执行JdkDynamicAopProxy（即代理对象的equal）方法\n\t\t\tif (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n\t\t\t\t// The target does not implement the equals(Object) method itself.\n\t\t\t\treturn equals(args[0]);\n\t\t\t}\n\t\t\t// 如果被代理的目标对象要执行的方法是hashCode则执行JdkDynamicAopProxy（即代理对象的hashCode）方法\n\t\t\telse if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n\t\t\t\t// The target does not implement the hashCode() method itself.\n\t\t\t\treturn hashCode();\n\t\t\t}\n\t\t\telse if (method.getDeclaringClass() == DecoratingProxy.class) {\n\t\t\t\t// There is only getDecoratedClass() declared -> dispatch to proxy config.\n\t\t\t\treturn AopProxyUtils.ultimateTargetClass(this.advised);\n\t\t\t}\n\t\t\telse if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&\n\t\t\t\t\tmethod.getDeclaringClass().isAssignableFrom(Advised.class)) {\n\t\t\t\t// Service invocations on ProxyConfig with the proxy config...\n\t\t\t\treturn AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n\t\t\t}\n\n\t\t\tObject retVal;\n\t\t\t// 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理\n\t\t\tif (this.advised.exposeProxy) {\n\t\t\t\t// Make invocation available if necessary.\n\t\t\t\toldProxy = AopContext.setCurrentProxy(proxy);\n\t\t\t\tsetProxyContext = true;\n\t\t\t}\n\n\t\t\t// May be null. Get as late as possible to minimize the time we \"own\" the target,\n\t\t\t// in case it comes from a pool.\n\t\t\ttarget = targetSource.getTarget();\n\t\t\tif (target != null) {\n\t\t\t\ttargetClass = target.getClass();\n\t\t\t}\n\n\t\t\t// Get the interception chain for this method.\n\t\t\t// 获取当前方法的拦截器链\n\t\t\tList<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n\n\t\t\t// Check whether we have any advice. If we don't, we can fallback on direct\n\t\t\t// reflective invocation of the target, and avoid creating a MethodInvocation.\n\t\t\tif (chain.isEmpty()) {\n\t\t\t\t// We can skip creating a MethodInvocation: just invoke the target directly\n\t\t\t\t// Note that the final invoker must be an InvokerInterceptor so we know it does\n\t\t\t\t// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n\t\t\t\tObject[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n\t\t\t\t// 如果没有发现任何拦截器那么直接调用切点方法\n\t\t\t\tretVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We need to create a method invocation...\n\t\t\t\t// 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器\n\t\t\t\tinvocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n\t\t\t\t// Proceed to the joinpoint through the interceptor chain.\n\t\t\t\t// 执行拦截器链\n\t\t\t\tretVal = invocation.proceed();\n\t\t\t}\n\n\t\t\t// Massage return value if necessary.\n\t\t\tClass<?> returnType = method.getReturnType();\n\t\t\tif (retVal != null && retVal == target &&\n\t\t\t\t\treturnType != Object.class && returnType.isInstance(proxy) &&\n\t\t\t\t\t!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n\t\t\t\t// Special case: it returned \"this\" and the return type of the method\n\t\t\t\t// is type-compatible. Note that we can't help if the target sets\n\t\t\t\t// a reference to itself in another returned object.\n\t\t\t\tretVal = proxy;\n\t\t\t}\n\t\t\t// 返回结果\n\t\t\telse if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n\t\t\t\tthrow new AopInvocationException(\n\t\t\t\t\t\t\"Null return value from advice does not match primitive return type for: \" + method);\n\t\t\t}\n\t\t\treturn retVal;\n\t\t}\n\t\tfinally {\n\t\t\tif (target != null && !targetSource.isStatic()) {\n\t\t\t\t// Must have come from TargetSource.\n\t\t\t\ttargetSource.releaseTarget(target);\n\t\t\t}\n\t\t\tif (setProxyContext) {\n\t\t\t\t// Restore old proxy.\n\t\t\t\tAopContext.setCurrentProxy(oldProxy);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t...\n```\n\n* 关注`invoke`方法，根据上面代码可以看到如果执行的是`equals`或者`hashCode`方法则执行`JdkDynamicAopProxy`里面对应的内部方法，然后就是获取当前获取当前方法的拦截器链，对于没有拦截器的方法直接调用原有方法，有拦截器的方法会构造`ReflectiveMethodInvocation`，并沿着拦截器链进行调用。整个调用链的入口在其`proceed`方法中\n    * 1、获取当前方法的拦截器链\n        * `this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);`方法，这个方法做了一下缓存处理，因为那些方法需要执行代理都是之前写好固定的\n        ```java\n        public List<Object> getInterceptorsAndDynamicInterceptionAdvice(Method method, Class<?> targetClass) {\n            // 从缓存中寻找该方法的拦截链是否已经获取过（可能被代理对象的某个方法被调用过多次，\n            // 调用第一次就会获取一次，后面多次调用时，则需从缓存中直接获取，无需多次获取，\n            // 这样就会提高性能），如果已经获取过，直接返回\n            MethodCacheKey cacheKey = new MethodCacheKey(method);\n            List<Object> cached = this.methodCache.get(cacheKey);\n            if (cached == null) {\n                cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n                        this, method, targetClass);\n                this.methodCache.put(cacheKey, cached);\n            }\n            return cached;\n        }\n        ```\n        * 继续跟进`this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);`方法，可以看到这边就是一个拦截器的过滤，可以看到主体逻辑是循环`Advisor`通过切点匹配`MethodMatchers.matches(mm, method, actualClass, hasIntroductions)`\n        ```java\n        /**\n         * 其实这边就是一个拦截器的过滤，我们在生产环境中，我们一般会用正则表达来定义切点（expression），\n         * 因为并不是每个方法都需要切，会影响性能，所以matches这个方法很重要\n         *\n         * @param config the AOP configuration in the form of an Advised object\n         * @param method the proxied method\n         * @param targetClass the target class (may be {@code null} to indicate a proxy without\n         * target object, in which case the method's declaring class is the next best option)\n         * @return\n         */\n        @Override\n        public List<Object> getInterceptorsAndDynamicInterceptionAdvice(\n                Advised config, Method method, Class<?> targetClass) {\n    \n            // This is somewhat tricky... We have to process introductions first,\n            // but we need to preserve order in the ultimate list.\n            // 先定义了一个拦截链的List大小最大为我们传入advisor的个数\n            List<Object> interceptorList = new ArrayList<Object>(config.getAdvisors().length);\n            Class<?> actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());\n            boolean hasIntroductions = hasMatchingIntroductions(config, actualClass);\n            AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();\n    \n            for (Advisor advisor : config.getAdvisors()) {\n                if (advisor instanceof PointcutAdvisor) {\n                    // Add it conditionally.\n                    PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;\n                    if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {\n                        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);\n                        MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();\n                        if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {\n                            if (mm.isRuntime()) {\n                                // Creating a new object instance in the getInterceptors() method\n                                // isn't a problem as we normally cache created chains.\n                                for (MethodInterceptor interceptor : interceptors) {\n                                    interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));\n                                }\n                            }\n                            else {\n                                interceptorList.addAll(Arrays.asList(interceptors));\n                            }\n                        }\n                    }\n                }\n                else if (advisor instanceof IntroductionAdvisor) {\n                    IntroductionAdvisor ia = (IntroductionAdvisor) advisor;\n                    if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {\n                        Interceptor[] interceptors = registry.getInterceptors(advisor);\n                        interceptorList.addAll(Arrays.asList(interceptors));\n                    }\n                }\n                else {\n                    Interceptor[] interceptors = registry.getInterceptors(advisor);\n                    interceptorList.addAll(Arrays.asList(interceptors));\n                }\n            }\n    \n            return interceptorList;\n        }\n        ```\n    * 2、对于没有拦截器的方法直接调用原有方法\n        * 如果上面获取的`chain`是`isEmpty()`，下面就是直接调用`method.invoke(target, args);`方法\n        ```java\n        if (chain.isEmpty()) {\n            // We can skip creating a MethodInvocation: just invoke the target directly\n            // Note that the final invoker must be an InvokerInterceptor so we know it does\n            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n            // 如果没有发现任何拦截器那么直接调用切点方法\n            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n        }\n  \n        public static Object invokeJoinpointUsingReflection(Object target, Method method, Object[] args) throws Throwable {\n            // 使用反射执行方法\n            try {\n                ReflectionUtils.makeAccessible(method);\n                return method.invoke(target, args);\n            }\n            catch (InvocationTargetException ex) {\n                // Invoked method threw a checked exception.\n                // We must rethrow it. The client won't see the interceptor.\n                throw ex.getTargetException();\n            }\n            catch (IllegalArgumentException ex) {\n                throw new AopInvocationException(\"AOP configuration seems to be invalid: tried calling method [\" +\n                        method + \"] on target [\" + target + \"]\", ex);\n            }\n            catch (IllegalAccessException ex) {\n                throw new AopInvocationException(\"Could not access method [\" + method + \"]\", ex);\n            }\n        }\n        ```\n        * \n    * 3、有拦截器的方法会构造`ReflectiveMethodInvocation`执行`proceed()`方法\n        * 如果上面获取的`chain`是`isNotEmpty()`，就需要执行相应拦截器的方法了，可以看到是封装了一个`ReflectiveMethodInvocation`对象，然后执行其`proceed()`方法\n        ```java\n        else {\n            // We need to create a method invocation...\n            // 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器\n            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n            // Proceed to the joinpoint through the interceptor chain.\n            // 执行拦截器链\n            retVal = invocation.proceed();\n        }\n        ```\n        * 进入`invocation.proceed();`方法，可以看到这里使用了一个拦截器链的操作，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法\n        ```java\n        @Override\n        public Object proceed() throws Throwable {\n            //\tWe start with an index of -1 and increment early.\n            // 执行完所有增强后执行切点方法，从索引为-1的拦截器开始，并递增，如果拦截器迭代调用完成，则调用目标方法\n            if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {\n                return invokeJoinpoint();\n            }\n            // 获取下一个要执行的拦截器 沿着拦截器链执行\n            Object interceptorOrInterceptionAdvice =\n                    this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);\n            if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {\n                // Evaluate dynamic method matcher here: static part will already have\n                // been evaluated and found to match.\n                // 对方法进行动态匹配，切点的匹配就在这里进行\n                InterceptorAndDynamicMethodMatcher dm =\n                        (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;\n                if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {\n                    return dm.interceptor.invoke(this);\n                }\n                else {\n                    // Dynamic matching failed.\n                    // Skip this interceptor and invoke the next in the chain.\n                    // 不匹配则跳过这个拦截器调用下一个\n                    return proceed();\n                }\n            }\n            else {\n                // It's an interceptor, so we just invoke it: The pointcut will have\n                // been evaluated statically before this object was constructed.\n                //  这是一个拦截器，直接调用它，将this作为参数传递以保证当前实例中调用链的执行\n                return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);\n            }\n        }\n        ```\n\n\n#### 2、ObjenesisCglibAopProxy\n \n* 先看一下`ObjenesisCglibAopProxy`这个类的继承关系\n\n![](/images/server/spring/analysis/aop/ObjenesisCglibAopProxy.png)\n\n* `Cglib`调用方法的核心逻辑在`DynamicAdvisedInterceptor`的`intercept`方法中，和`jdk`方式实现代理的`invoke`方法大同小异\n\n```java\nprivate static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable {\n\n    private final AdvisedSupport advised;\n\n    public DynamicAdvisedInterceptor(AdvisedSupport advised) {\n        this.advised = advised;\n    }\n\n    @Override\n    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        Object oldProxy = null;\n        boolean setProxyContext = false;\n        Class<?> targetClass = null;\n        Object target = null;\n        try {\n            if (this.advised.exposeProxy) {\n                // Make invocation available if necessary.\n                oldProxy = AopContext.setCurrentProxy(proxy);\n                setProxyContext = true;\n            }\n            // May be null. Get as late as possible to minimize the time we\n            // \"own\" the target, in case it comes from a pool...\n            target = getTarget();\n            if (target != null) {\n                targetClass = target.getClass();\n            }\n            // 获取拦截器链\n            List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n            Object retVal;\n            // Check whether we only have one InvokerInterceptor: that is,\n            // no real advice, but just reflective invocation of the target.\n            if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {\n                // We can skip creating a MethodInvocation: just invoke the target directly.\n                // Note that the final invoker must be an InvokerInterceptor, so we know\n                // it does nothing but a reflective operation on the target, and no hot\n                // swapping or fancy proxying.\n                // 拦截器链为空直接激活原方法\n                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n                retVal = methodProxy.invoke(target, argsToUse);\n            }\n            else {\n                // We need to create a method invocation...\n                // 进入链\n                retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\n            }\n            retVal = processReturnType(proxy, target, method, retVal);\n            return retVal;\n        }\n        finally {\n            if (target != null) {\n                releaseTarget(target);\n            }\n            if (setProxyContext) {\n                // Restore old proxy.\n                AopContext.setCurrentProxy(oldProxy);\n            }\n        }\n    }\n```\n\n* 关注`retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();`这行代码，这里构造了`CglibMethodInvocation`查看这个类，然后执行`proceed()`方法，可以发现这个类继承了`ReflectiveMethodInvocation`这个类，所以这里的`proceed()`方法和我们上面`jdk`动态代理执行的`proceed()`方法是一样的\n\n## 总结\n\n\n\n## 参考\n* 《Spring 源码深度解析》\n","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(五三)AOP源码解析之创建AOP代理","url":"/2019/08/01/backend/framework/spring/analysis/Spring系列(五三)AOP源码解析之创建AOP代理/","content":"## 前言\n* 上一章节介绍了`<aop:aspectj-autoproxy/>`的解析过程，最终结果是得到`AnnotationAwareAspectJAutoProxyCreator` 这个`bean`，这个类用于创建`AOP`的代理类，那么这个类到底做了什么工作来完成`AOP`的功能的呢？\n\n* 先看一下`AnnotationAwareAspectJAutoProxyCreator` 的类继承关系\n\n![](/images/server/spring/analysis/aop/AnnotationAwareAspectJAutoProxyCreator.png)\n\n```java\nAspectJAwareAdvisorAutoProxyCreator (org.springframework.aop.aspectj.autoproxy)\n    AbstractAdvisorAutoProxyCreator (org.springframework.aop.framework.autoproxy)\n        AbstractAutoProxyCreator (org.springframework.aop.framework.autoproxy)\n            ProxyProcessorSupport (org.springframework.aop.framework)\n                ProxyConfig (org.springframework.aop.framework)\n                    Object (java.lang)\n                    Serializable (java.io)\n                Ordered (org.springframework.core)\n                BeanClassLoaderAware (org.springframework.beans.factory)\n                    Aware (org.springframework.beans.factory)\n                AopInfrastructureBean (org.springframework.aop.framework)\n            SmartInstantiationAwareBeanPostProcessor (org.springframework.beans.factory.config)\n                InstantiationAwareBeanPostProcessor (org.springframework.beans.factory.config)\n                    BeanPostProcessor (org.springframework.beans.factory.config)\n            BeanFactoryAware (org.springframework.beans.factory)\n                Aware (org.springframework.beans.factory)\n```\n\n## 解析\n\n* 由`AnnotationAwareAspectJAutoProxyCreator`的继承关系图可以注意到此类实现了 `BeanPostProcessor`接口，这个接口前面经常看见，实现了这个接口是可以在`bean`初始化之前和初始化之后添加一些逻辑，到这里，我们大概可以猜出代理类是怎样和目标对象联系在一起的，实现偷天换日\n    * 先回顾下`doCreateBean`方法\n    ```java\n    // AbstractAutowireCapableBeanFactory\n    protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n                throws BeanCreationException {\n    \n        // Instantiate the bean.\n        BeanWrapper instanceWrapper = null;\n        if (mbd.isSingleton()) {\n            instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n        }\n        if (instanceWrapper == null) {\n            // 1. 创建实例\n            instanceWrapper = createBeanInstance(beanName, mbd, args);\n        }\n        ...\n    \n        // Initialize the bean instance.\n        Object exposedObject = bean;\n        try {\n            // 2. 装载属性\n            populateBean(beanName, mbd, instanceWrapper);\n            if (exposedObject != null) {\n                // 3. 初始化\n                exposedObject = initializeBean(beanName, exposedObject, mbd);\n            }\n        }\n        ...\n    }\n    ```\n    * 在上面第 3 步 `initializeBean(...) `初始化方法中会调用 `BeanPostProcessor` 中的方法，如下：\n    ```java\n    protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n       ...\n       Object wrappedBean = bean;\n       if (mbd == null || !mbd.isSynthetic()) {\n          // 1. 执行每一个 BeanPostProcessor 的 postProcessBeforeInitialization 方法\n          wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n       }\n    \n       try {\n          // 激活用户自定义的init方法 1、InitializingBean接口afterPropertiesSet方法 2、bean 定义的init-method=\"\"方法\n          invokeInitMethods(beanName, wrappedBean, mbd);\n       }\n       ...\n       if (mbd == null || !mbd.isSynthetic()) {\n          // 我们关注的重点是这里！！！\n          // 2. 执行每一个 BeanPostProcessor 的 postProcessAfterInitialization 方法\n          wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n       }\n       return wrappedBean;\n    }\n    ```\n    \n* 由上面的代码可以看到`Spring AOP` 会在 `IOC` 容器创建 `bean` 实例的最后对 `bean` 进行处理，其实就是在这一步进行代理增强。 我们来看一下它是怎么实现  `BeanPostProcessor`接口的，具体实现在父类`AbstractAutoProxyCreator#postProcessAfterInitialization`中，下面的代码可以看到先是判断这个`bean`是否需要被代理，如果要的话就是返回对应的代理类了，具体逻辑在`wrapIfNecessary(bean, beanName, cacheKey);`方法中\n\n```java\n/**\n * Create a proxy with the configured interceptors if the bean is\n * identified as one to proxy by the subclass.\n * @see #getAdvicesAndAdvisorsForBean\n */\n@Override\npublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n    if (bean != null) {\n        // 根据给定的bean的class和name构建出个key，格式: beanClassName_beanName\n        Object cacheKey = getCacheKey(bean.getClass(), beanName);\n        if (!this.earlyProxyReferences.contains(cacheKey)) {\n            // 如果它适合被代理，则需要封装指定的bean\n            return wrapIfNecessary(bean, beanName, cacheKey);\n        }\n    }\n    return bean;\n}\n\n/**\n * Wrap the given bean if necessary, i.e. if it is eligible for being proxied.\n * @param bean the raw bean instance\n * @param beanName the name of the bean\n * @param cacheKey the cache key for metadata access\n * @return a proxy wrapping the bean, or the raw bean instance as-is\n */\nprotected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {\n    // 如果已经处理过\n    if (beanName != null && this.targetSourcedBeans.contains(beanName)) {\n        return bean;\n    }\n    // 无需增强\n    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {\n        return bean;\n    }\n    // 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理\n    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {\n        this.advisedBeans.put(cacheKey, Boolean.FALSE);\n        return bean;\n    }\n\n    // Create proxy if we have advice.\n    // 核心方法 如果存在增强方法则创建代理\n    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);\n    // 如果获取到了增强则需要针对增强创建代理\n    if (specificInterceptors != DO_NOT_PROXY) {\n        this.advisedBeans.put(cacheKey, Boolean.TRUE);\n        // 创建代理 1、获取增强方法或者增强器 2、根据获取的增强进行代理\n        Object proxy = createProxy(\n                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));\n        this.proxyTypes.put(cacheKey, proxy.getClass());\n        return proxy;\n    }\n\n    this.advisedBeans.put(cacheKey, Boolean.FALSE);\n    return bean;\n}\n```\n\n* 从上面的代码可以看到代理创建的雏形，主要步骤分为两步\n    * 1、获取增强方法或者增强器\n    * 2、根据获取的增强进行代理\n\n### 1、获取增强方法或者增强器\n\n* 先来看获取增强方法的实现逻辑`getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);`\n\n```java\n@Override\nprotected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, TargetSource targetSource) {\n    // 获取所有的增强以及寻找所有增强中适用于bean的增强并应用\n    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);\n    if (advisors.isEmpty()) {\n        return DO_NOT_PROXY;\n    }\n    return advisors.toArray();\n}\nprotected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n    // 获取所有增强器\n    List<Advisor> candidateAdvisors = findCandidateAdvisors();\n    // 从所有增强器中找出适合的增强器\n    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n    extendAdvisors(eligibleAdvisors);\n    if (!eligibleAdvisors.isEmpty()) {\n        eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n    }\n    return eligibleAdvisors;\n}\n```\n\n* 可以看到先是获取了所有的增强器，然后在所有增强器中找出适合的增强器并返回\n    * 获取所有增强器\n        * 当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持，在这里调用父类方法加载配置文件中的AOP声明，然后再`add`使用注解配置的`Advisor` \n        ```java\n        @Override\n        protected List<Advisor> findCandidateAdvisors() {\n            // Add all the Spring advisors found according to superclass rules.\n            // 当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持\n            // 在这里调用父类方法加载配置文件中的AOP声明\n            List<Advisor> advisors = super.findCandidateAdvisors();\n            // Build Advisors for all AspectJ aspects in the bean factory.\n      \t\t// 获取注解配置的Advisor\n            advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());\n            return advisors;\n        }\n        ```\n        * `this.aspectJAdvisorsBuilder.buildAspectJAdvisors()`方法是获取注解配置的`Advisor`\n        ```java\n        public List<Advisor> buildAspectJAdvisors() {\n            List<String> aspectNames = this.aspectBeanNames;\n    \n            if (aspectNames == null) {\n                synchronized (this) {\n                    aspectNames = this.aspectBeanNames;\n                    if (aspectNames == null) {\n                        List<Advisor> advisors = new LinkedList<Advisor>();\n                        aspectNames = new LinkedList<String>();\n                        // 获取所有的beanName\n                        String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(\n                                this.beanFactory, Object.class, true, false);\n                        // 循环所有的beanName找出对应的增强方法\n                        for (String beanName : beanNames) {\n                            // 不合法的bean则略过\n                            if (!isEligibleBean(beanName)) {\n                                continue;\n                            }\n                            // We must be careful not to instantiate beans eagerly as in this case they\n                            // would be cached by the Spring conainer but would not have been weaved.\n                            // 获取对应的bean的类型\n                            Class<?> beanType = this.beanFactory.getType(beanName);\n                            if (beanType == null) {\n                                continue;\n                            }\n                            // 如果存在Aspect注解\n                            if (this.advisorFactory.isAspect(beanType)) {\n                                aspectNames.add(beanName);\n                                AspectMetadata amd = new AspectMetadata(beanType, beanName);\n                                if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {\n                                    MetadataAwareAspectInstanceFactory factory =\n                                            new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);\n                                    // TODO 核心 解析标记AspectJ注解中的增强方法 委托 advisorFactory.getAdvisors\n                                    List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);\n                                    if (this.beanFactory.isSingleton(beanName)) {\n                                        this.advisorsCache.put(beanName, classAdvisors);\n                                    }\n                                    else {\n                                        this.aspectFactoryCache.put(beanName, factory);\n                                    }\n                                    advisors.addAll(classAdvisors);\n                                }\n                                else {\n                                    // Per target or per this.\n                                    if (this.beanFactory.isSingleton(beanName)) {\n                                        throw new IllegalArgumentException(\"Bean with name '\" + beanName +\n                                                \"' is a singleton, but aspect instantiation model is not singleton\");\n                                    }\n                                    MetadataAwareAspectInstanceFactory factory =\n                                            new PrototypeAspectInstanceFactory(this.beanFactory, beanName);\n                                    this.aspectFactoryCache.put(beanName, factory);\n                                    advisors.addAll(this.advisorFactory.getAdvisors(factory));\n                                }\n                            }\n                        }\n                        this.aspectBeanNames = aspectNames;\n                        return advisors;\n                    }\n                }\n            }\n    \n            if (aspectNames.isEmpty()) {\n                return Collections.emptyList();\n            }\n            // 记录在缓存中\n            List<Advisor> advisors = new LinkedList<Advisor>();\n            for (String aspectName : aspectNames) {\n                List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);\n                if (cachedAdvisors != null) {\n                    advisors.addAll(cachedAdvisors);\n                }\n                else {\n                    MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);\n                    advisors.addAll(this.advisorFactory.getAdvisors(factory));\n                }\n            }\n            return advisors;\n        }\n        ```\n        * 上面的逻辑可以看到先是获取所有的`beanName`然后遍历，找出声明`AspectJ`注解的类，并将结果加入到缓存中\n        * `this.advisorFactory.getAdvisors(factory);`是最为重要及最为复杂的\n        ```java\n        @Override\n        public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {\n            // 获取标记为AspectJ的类\n            Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();\n            // 获取标记为AspectJ的name\n            String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();\n            // 验证\n            validate(aspectClass);\n    \n            // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator\n            // so that it will only instantiate once.\n            MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =\n                    new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);\n    \n            List<Advisor> advisors = new LinkedList<Advisor>();\n            for (Method method : getAdvisorMethods(aspectClass)) {\n                // TODO 普通增强器的获取\n                Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);\n                if (advisor != null) {\n                    advisors.add(advisor);\n                }\n            }\n    \n            // If it's a per target aspect, emit the dummy instantiating aspect.\n            // 如果寻找的增强器不为空而且又配置了延迟初始化那么需要在首位加入同步实例化增强器\n            if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {\n                Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);\n                advisors.add(0, instantiationAdvisor);\n            }\n    \n            // Find introduction fields.\n            // 获取DeclaredField注解\n            for (Field field : aspectClass.getDeclaredFields()) {\n                Advisor advisor = getDeclareParentsAdvisor(field);\n                if (advisor != null) {\n                    advisors.add(advisor);\n                }\n            }\n    \n            return advisors;\n        }\n        ```\n        * 关注`for (Method method : getAdvisorMethods(aspectClass))`方法，循环切点方法，然后调用`Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);`获取增强\n        ```java\n        @Override\n        public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,\n                int declarationOrderInAspect, String aspectName) {\n    \n            validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());\n    \n            // 切点信息的获取\n            AspectJExpressionPointcut expressionPointcut = getPointcut(\n                    candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());\n            if (expressionPointcut == null) {\n                return null;\n            }\n            // 根据切点信息生成增强器\n            return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,\n                    this, aspectInstanceFactory, declarationOrderInAspect, aspectName);\n        }\n  \n        private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {\n            // 获取方法上的注解\n            AspectJAnnotation<?> aspectJAnnotation =\n                    AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);\n            if (aspectJAnnotation == null) {\n                return null;\n            }\n            // 使用AspectJExpressionPointcut实例封装获取的信息\n            AspectJExpressionPointcut ajexp =\n                    new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);\n            ajexp.setExpression(aspectJAnnotation.getPointcutExpression());\n            ajexp.setBeanFactory(this.beanFactory);\n            // 提取到的注解中表达式如 @Pointcut(\"execution(* *.*test*(..))\")中的execution(* *.*test*(..)\n            return ajexp;\n        }\n  \n        protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {\n            // 看到了熟悉的注解类\n            Class<?>[] classesToLookFor = new Class<?>[] {\n                    Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};\n            for (Class<?> c : classesToLookFor) {\n                AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c);\n                if (foundAnnotation != null) {\n                    return foundAnnotation;\n                }\n            }\n            return null;\n        }\n        ```\n        * 这里找出了两个`List<Advisor> candidateAdvisors`，可以看到第二个是`serviceAspectj`\n        ![](/images/server/spring/analysis/aop/allAdvisor.png)\n    * 找出适合的增强器\n        * 上面是获取了所有的增强器，但是对应所有增强器来将并不一定都适用于当前的`Bean`,还要挑取出合适的增强器，也就是满足我们配置的通配符的增强器\n        ```java\n        protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {\n            // 获取所有增强器\n            List<Advisor> candidateAdvisors = findCandidateAdvisors();\n            // 从所有增强器中找出适合的增强器\n            List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);\n            extendAdvisors(eligibleAdvisors);\n            if (!eligibleAdvisors.isEmpty()) {\n                eligibleAdvisors = sortAdvisors(eligibleAdvisors);\n            }\n            return eligibleAdvisors;\n        }\n        ```\n        * 执行`List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);`方法从所有增强器中找出适合的增强器\n        ```java\n        protected List<Advisor> findAdvisorsThatCanApply(\n                List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {\n    \n            ProxyCreationContext.setCurrentProxiedBeanName(beanName);\n            try {\n                // 过滤已经得到的advisors\n                return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);\n            }\n            finally {\n                ProxyCreationContext.setCurrentProxiedBeanName(null);\n            }\n        }\n  \n        public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {\n            if (candidateAdvisors.isEmpty()) {\n                return candidateAdvisors;\n            }\n            List<Advisor> eligibleAdvisors = new LinkedList<Advisor>();\n            // 首先处理引介增强\n            for (Advisor candidate : candidateAdvisors) {\n                // canApply真正的匹配\n                if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {\n                    eligibleAdvisors.add(candidate);\n                }\n            }\n            boolean hasIntroductions = !eligibleAdvisors.isEmpty();\n            for (Advisor candidate : candidateAdvisors) {\n                if (candidate instanceof IntroductionAdvisor) {\n                    // 引介增强已经处理\n                    // already processed\n                    continue;\n                }\n                // 对于普通bean的处理\n                if (canApply(candidate, clazz, hasIntroductions)) {\n                    eligibleAdvisors.add(candidate);\n                }\n            }\n            return eligibleAdvisors;\n        }\n        ```\n        * 真正的匹配在`canApply()`方法，可以看到使用了`MethodMatcher`接口的`boolean matches(Method method, Class<?> targetClass, boolean hasIntroductions);`方法进行匹配\n        ```java\n        public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {\n            if (advisor instanceof IntroductionAdvisor) {\n                return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);\n            }\n            else if (advisor instanceof PointcutAdvisor) {\n                PointcutAdvisor pca = (PointcutAdvisor) advisor;\n                return canApply(pca.getPointcut(), targetClass, hasIntroductions);\n            }\n            else {\n                // It doesn't have a pointcut so we assume it applies.\n                return true;\n            }\n        }\n        public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {\n            Assert.notNull(pc, \"Pointcut must not be null\");\n            if (!pc.getClassFilter().matches(targetClass)) {\n                return false;\n            }\n      \n            MethodMatcher methodMatcher = pc.getMethodMatcher();\n            if (methodMatcher == MethodMatcher.TRUE) {\n                // No need to iterate the methods if we're matching any method anyway...\n                return true;\n            }\n      \n            IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;\n            if (methodMatcher instanceof IntroductionAwareMethodMatcher) {\n                introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;\n            }\n      \n            Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));\n            classes.add(targetClass);\n            for (Class<?> clazz : classes) {\n                Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);\n                for (Method method : methods) {\n                    if ((introductionAwareMethodMatcher != null &&\n                            introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||\n                            methodMatcher.matches(method, targetClass)) {\n                        return true;\n                    }\n                }\n            }\n      \n            return false;\n        }\n        ```\n### 2、根据获取的增强创建代理\n\n* 获取了所有对应`bean`的增强器后，便可以进行代理的创建了，对于代理类的创建及处理，`Spring`委托给了`ProxyFactory`（创建 `Proxy` 的工厂类）去处理，下面的函数主要是对`ProxyFactory`的初始化操作，进而对真正的创建代理做准备\n\n```java\nprotected Object createProxy(\n        Class<?> beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {\n\n    if (this.beanFactory instanceof ConfigurableListableBeanFactory) {\n        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);\n    }\n    // 对于代理类的创建及处理，Spring委托给了ProxyFactory去处理\n    ProxyFactory proxyFactory = new ProxyFactory();\n    // 获取当前类中相关属性\n    proxyFactory.copyFrom(this);\n    // 决定对于给定的bean是否应该使用targetClass而不是她的接口代理。检查ProxyTargetClass设置\n    if (!proxyFactory.isProxyTargetClass()) {\n        if (shouldProxyTargetClass(beanClass, beanName)) {\n            proxyFactory.setProxyTargetClass(true);\n        }\n        else {\n            evaluateProxyInterfaces(beanClass, proxyFactory);\n        }\n    }\n    // 将拦截器封装为增强器\n    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);\n    for (Advisor advisor : advisors) {\n        // 加入增强器\n        proxyFactory.addAdvisor(advisor);\n    }\n    // 设置要代理的类\n    proxyFactory.setTargetSource(targetSource);\n    // 定制dialing\n    customizeProxyFactory(proxyFactory);\n    // 用来控制代理工厂被配置之后是否还允许修改通知 缺省值为false（即在代理被配置之后不允许修改代理的配置）\n    proxyFactory.setFrozen(this.freezeProxy);\n    if (advisorsPreFiltered()) {\n        proxyFactory.setPreFiltered(true);\n    }\n    // 创建代理\n    return proxyFactory.getProxy(getProxyClassLoader());\n}\n```\n\n* 继续进入`proxyFactory.getProxy(getProxyClassLoader())`方法\n\n```java\npublic Object getProxy(ClassLoader classLoader) {\n    return createAopProxy().getProxy(classLoader);\n}\n```\n\n* 可以看到先是调用`createAopProxy()`创建`AopProxy`，由下图可以看到一个是`cglib`的代理，一个是`jdk`的代理\n![](/images/server/spring/analysis/aop/AopProxy.png)\n    * `AopProxy` 用于生成代理对象的委托类，就俩方法获取代理对象`Proxy`\n    ```java\n    public interface AopProxy {\n        Object getProxy();\n    \n        Object getProxy(ClassLoader classLoader);\n    }\n    ```\n    * 进入`createAopProxy()`方法，这里根据逻辑判断返回`ObjenesisCglibAopProxy`或者`JdkDynamicAopProxy`，如果目标对象实现了接口，默认情况下采用`jdk`的动态代理，也可以强制使用`cglib`实现`aop`(设置方式 `<aop:aspectj-autoproxy proxy-target-class=\"true\"/>`)\n    ```java\n\tprotected final synchronized AopProxy createAopProxy() {\n\t\tif (!this.active) {\n\t\t\tactivate();\n\t\t}\n\t\t// 创建代理\n\t\treturn getAopProxyFactory().createAopProxy(this);\n\t}\n\t\n    /**\n     * 如果目标对象实现了接口，默认情况下采用jdk的动态代理，也可以强制使用cglib实现aop\n     * 如果目标对象没有实现了接口，必须采用cglib\n     * @param config the AOP configuration in the form of an\n     * AdvisedSupport object\n     * @return\n     * @throws AopConfigException\n     */\n    @Override\n    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n        /**\n         * optimize        \t\t\t\t\t：用来控制通过cglib创建的代理是否使用激进的优化策略，仅对cglib有效，一般不推荐用户使用这个设置\n         * proxyTargetClass\t\t\t\t\t：为true时，目标类本身被代理而不是目标类的接口，那么cglib代理将被创建，设置方式 <aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n         * hasNoUserSuppliedProxyInterfaces: 是否存在代理接口\n         *\n         */\n        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {\n            Class<?> targetClass = config.getTargetClass();\n            if (targetClass == null) {\n                throw new AopConfigException(\"TargetSource cannot determine target class: \" +\n                        \"Either an interface or a target is required for proxy creation.\");\n            }\n            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {\n                return new JdkDynamicAopProxy(config);\n            }\n            return new ObjenesisCglibAopProxy(config);\n        }\n        else {\n            return new JdkDynamicAopProxy(config);\n        }\n    }\n    ```\n\n* 调用`createAopProxy()`的到`AopProxy`之后就是调用`AopProxy`的`getProxy(ClassLoader classLoader)` 获取代理对象了，`AopProxy`它有两个子类`JdkDynamicAopProxy `基于 `JDK` 的 `AOP` 代理实现类，`ObjenesisCglibAopProxy `基于 `CGLIB` 的 `AOP` 的代理实现类。\n    * `JdkDynamicAopProxy`\n        * 下面看到了我们熟悉的`Proxy.newProxyInstance`方法\n        ```java\n        @Override\n        public Object getProxy(ClassLoader classLoader) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Creating JDK dynamic proxy: target source is \" + this.advised.getTargetSource());\n            }\n            Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);\n            findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);\n            return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);\n        }\n        ```\n        * 可以看到`JdkDynamicAopProxy`实现了`InvocationHandler`接口，那么我们可以推断这一定有一个`invoke`函数\n        ```java\n        final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable {\n        ```\n        * `JdkDynamicAopProxy`的`invoke`函数最重要的工作就是创建了一个拦截器链，并实现了拦截器链的逐一调用\n        ```java\n        /**\n         * Implementation of {@code InvocationHandler.invoke}.\n         * <p>Callers will see exactly the exception thrown by the target,\n         * unless a hook method throws an exception.\n         */\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            MethodInvocation invocation;\n            Object oldProxy = null;\n            boolean setProxyContext = false;\n    \n            TargetSource targetSource = this.advised.targetSource;\n            Class<?> targetClass = null;\n            Object target = null;\n    \n            try {\n                // 如果被代理的目标对象要执行的方法是equal则执行JdkDynamicAopProxy（即代理对象的equal）方法\n                if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {\n                    // The target does not implement the equals(Object) method itself.\n                    return equals(args[0]);\n                }\n                // 如果被代理的目标对象要执行的方法是hashCode则执行JdkDynamicAopProxy（即代理对象的hashCode）方法\n                else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {\n                    // The target does not implement the hashCode() method itself.\n                    return hashCode();\n                }\n                else if (method.getDeclaringClass() == DecoratingProxy.class) {\n                    // There is only getDecoratedClass() declared -> dispatch to proxy config.\n                    return AopProxyUtils.ultimateTargetClass(this.advised);\n                }\n                else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&\n                        method.getDeclaringClass().isAssignableFrom(Advised.class)) {\n                    // Service invocations on ProxyConfig with the proxy config...\n                    return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);\n                }\n    \n                Object retVal;\n                // 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理\n                if (this.advised.exposeProxy) {\n                    // Make invocation available if necessary.\n                    oldProxy = AopContext.setCurrentProxy(proxy);\n                    setProxyContext = true;\n                }\n    \n                // May be null. Get as late as possible to minimize the time we \"own\" the target,\n                // in case it comes from a pool.\n                target = targetSource.getTarget();\n                if (target != null) {\n                    targetClass = target.getClass();\n                }\n    \n                // Get the interception chain for this method.\n                // 获取当前方法的拦截器链\n                List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n    \n                // Check whether we have any advice. If we don't, we can fallback on direct\n                // reflective invocation of the target, and avoid creating a MethodInvocation.\n                if (chain.isEmpty()) {\n                    // We can skip creating a MethodInvocation: just invoke the target directly\n                    // Note that the final invoker must be an InvokerInterceptor so we know it does\n                    // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.\n                    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n                    // 如果没有发现任何拦截器那么直接调用切点方法\n                    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);\n                }\n                else {\n                    // We need to create a method invocation...\n                    // 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器\n                    invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);\n                    // Proceed to the joinpoint through the interceptor chain.\n                    // 执行拦截器链\n                    retVal = invocation.proceed();\n                }\n    \n                // Massage return value if necessary.\n                Class<?> returnType = method.getReturnType();\n                if (retVal != null && retVal == target &&\n                        returnType != Object.class && returnType.isInstance(proxy) &&\n                        !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {\n                    // Special case: it returned \"this\" and the return type of the method\n                    // is type-compatible. Note that we can't help if the target sets\n                    // a reference to itself in another returned object.\n                    retVal = proxy;\n                }\n                // 返回结果\n                else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {\n                    throw new AopInvocationException(\n                            \"Null return value from advice does not match primitive return type for: \" + method);\n                }\n                return retVal;\n            }\n            finally {\n                if (target != null && !targetSource.isStatic()) {\n                    // Must have come from TargetSource.\n                    targetSource.releaseTarget(target);\n                }\n                if (setProxyContext) {\n                    // Restore old proxy.\n                    AopContext.setCurrentProxy(oldProxy);\n                }\n            }\n        }\n        ```\n    * `ObjenesisCglibAopProxy`\n        * `Cglib`获取代理类\n        ```java\n        @Override\n        public Object getProxy(ClassLoader classLoader) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Creating CGLIB proxy: target source is \" + this.advised.getTargetSource());\n            }\n    \n            try {\n                Class<?> rootClass = this.advised.getTargetClass();\n                Assert.state(rootClass != null, \"Target class must be available for creating a CGLIB proxy\");\n    \n                Class<?> proxySuperClass = rootClass;\n                if (ClassUtils.isCglibProxyClass(rootClass)) {\n                    proxySuperClass = rootClass.getSuperclass();\n                    Class<?>[] additionalInterfaces = rootClass.getInterfaces();\n                    for (Class<?> additionalInterface : additionalInterfaces) {\n                        this.advised.addInterface(additionalInterface);\n                    }\n                }\n    \n                // Validate the class, writing log messages as necessary.\n                validateClassIfNecessary(proxySuperClass, classLoader);\n    \n                // Configure CGLIB Enhancer...\n                Enhancer enhancer = createEnhancer();\n                if (classLoader != null) {\n                    enhancer.setClassLoader(classLoader);\n                    if (classLoader instanceof SmartClassLoader &&\n                            ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {\n                        enhancer.setUseCache(false);\n                    }\n                }\n                enhancer.setSuperclass(proxySuperClass);\n                enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));\n                enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);\n                enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));\n    \n                Callback[] callbacks = getCallbacks(rootClass);\n                Class<?>[] types = new Class<?>[callbacks.length];\n                for (int x = 0; x < types.length; x++) {\n                    types[x] = callbacks[x].getClass();\n                }\n                // fixedInterceptorMap only populated at this point, after getCallbacks call above\n                enhancer.setCallbackFilter(new ProxyCallbackFilter(\n                        this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));\n                enhancer.setCallbackTypes(types);\n    \n                // Generate the proxy class and create a proxy instance.\n                return createProxyClassAndInstance(enhancer, callbacks);\n            }\n            catch (CodeGenerationException ex) {\n                throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" +\n                        this.advised.getTargetClass() + \"]: \" +\n                        \"Common causes of this problem include using a final class or a non-visible class\",\n                        ex);\n            }\n            catch (IllegalArgumentException ex) {\n                throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" +\n                        this.advised.getTargetClass() + \"]: \" +\n                        \"Common causes of this problem include using a final class or a non-visible class\",\n                        ex);\n            }\n            catch (Throwable ex) {\n                // TargetSource.getTarget() failed\n                throw new AopConfigException(\"Unexpected AOP exception\", ex);\n            }\n        }\n        ```\n        * `Cglib`是一个强大的高性能代码生成包，底层通过使用一个小而快的字节码处理框架`ASM`，来转化字节码并生成新类\n        * `Cglib`调用方法的核心逻辑在`DynamicAdvisedInterceptor`的`intercept`方法中，和`jdk`方式实现代理的`invoke`方法大同小异\n        ```java\n        /**\n         * 核心逻辑\n         * General purpose AOP callback. Used when the target is dynamic or when the\n         * proxy is not frozen.\n         */\n        private static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable {\n    \n            private final AdvisedSupport advised;\n    \n            public DynamicAdvisedInterceptor(AdvisedSupport advised) {\n                this.advised = advised;\n            }\n    \n            @Override\n            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n                Object oldProxy = null;\n                boolean setProxyContext = false;\n                Class<?> targetClass = null;\n                Object target = null;\n                try {\n                    if (this.advised.exposeProxy) {\n                        // Make invocation available if necessary.\n                        oldProxy = AopContext.setCurrentProxy(proxy);\n                        setProxyContext = true;\n                    }\n                    // May be null. Get as late as possible to minimize the time we\n                    // \"own\" the target, in case it comes from a pool...\n                    target = getTarget();\n                    if (target != null) {\n                        targetClass = target.getClass();\n                    }\n                    // 获取拦截器链\n                    List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);\n                    Object retVal;\n                    // Check whether we only have one InvokerInterceptor: that is,\n                    // no real advice, but just reflective invocation of the target.\n                    if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {\n                        // We can skip creating a MethodInvocation: just invoke the target directly.\n                        // Note that the final invoker must be an InvokerInterceptor, so we know\n                        // it does nothing but a reflective operation on the target, and no hot\n                        // swapping or fancy proxying.\n                        // 拦截器链为空直接激活原方法\n                        Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);\n                        retVal = methodProxy.invoke(target, argsToUse);\n                    }\n                    else {\n                        // We need to create a method invocation...\n                        // 进入链\n                        retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\n                    }\n                    retVal = processReturnType(proxy, target, method, retVal);\n                    return retVal;\n                }\n                finally {\n                    if (target != null) {\n                        releaseTarget(target);\n                    }\n                    if (setProxyContext) {\n                        // Restore old proxy.\n                        AopContext.setCurrentProxy(oldProxy);\n                    }\n                }\n            }\n        ```\n\n\n![](/images/server/spring/analysis/aop/jdkcglib.png)\n\n\n## 总结\n\n* 由`AnnotationAwareAspectJAutoProxyCreator`的继承关系图可以注意到此类实现了 `BeanPostProcessor`接口，`BeanPostProcessor`接口是`IOC`与`AOP`连接的桥梁\n* 在研究源码之前可以尝试着自己想象一下解析思路，看看自己的思路和`Spring`是否有差别\n* 在 `Spring` 的容器中，我们面向的对象是一个个的 `bean` 实例，当我们需要`bean`的时候通过`IOC` 容器的 `getBean(…)` 方法从容器中获取 `bean` 实例，只不过大部分的场景下，我们都用了依赖注入，所以很少手动调用 `getBean(...)` 方法。借助`IOC`的话实现`AOP`就很简单了，只要在`getBean(...)`返回新的代理类就可以了\n* `Spring`使用`JDK`动态代理和`CGLib`动态代理技术在运行期织入增强，要使用`JDK`动态代理，目标类必须实现接口，而`CGLib`不对目标类作任何限制，他是通过动态生成目标类子类的方式提供代理\n* `JDK`在创建代理对象时的性能高于`CGLib`，但生成的代理对象的运行性能却比`CGLib`的低，如果无需频繁的创建代理对象比较适合采用`CGLib`动态代理技术，反之比较适合`JDK`动态代理技术\n\n\n\n## 参考\n* 《Spring 源码深度解析》\n* https://www.javadoop.com/post/spring-aop-source","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(五二)AOP源码解析之解析AOP自定义标签","url":"/2019/08/01/backend/framework/spring/analysis/Spring系列(五二)AOP源码解析之解析AOP自定义标签/","content":"## 前言\n\n### 简单示例\n\n* 创建切面类`ServiceAspectj`，这个方法用于定义切面，功能是打印方法的执行前的输入参数及输出结果\n\n```java\n@Slf4j\n@Aspect\n@Component\npublic class ServiceAspectj {\n\n    @Pointcut(value = \"execution(* org.springframework.iframe.service..*(..))\")\n    public void pointcut() {\n\n    }\n\n    @Around(\"pointcut()\")\n    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {\n        String className = pjp.getSignature().getDeclaringType().getSimpleName();\n        String methodName = pjp.getSignature().getName();\n\n        log.info(\"=> [request method: {}#{}]\",className, methodName);\n        log.info(\"=> [request body: {}]\", JSONObject.toJSONString(pjp.getArgs()));\n\n        Object result = pjp.proceed();\n\n        log.info(\"=< [response method: {}#{}]\",className, methodName);\n        log.info(\"=< [response result: {} ]\", JSONObject.toJSONString(result));\n        return result;\n    }\n\n}\n```\n\n* 需要切的方法\n\n```java\npublic interface UserService {\n\n    User findUserByName(String userName);\n\n}\n\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    User user;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Override\n    public User findUserByName(String userName) {\n        User user = new User(userName,18);\n        //Role role = roleService.findRoleByUserName(userName);\n        user.setRole(new Role());\n        return user;\n    }\n\n}\n```\n\n* `Spring` 配置文件 `beans/bean.xml` 添加`<aop:aspectj-autoproxy/>`配置，开启AOP开关\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                              http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\">\n\n\n    <bean class=\"org.springframework.iframe.entity.User\">\n        <property name=\"userName\" value=\"shop\"/>\n    </bean>\n\n    <!-- ComponentScanBeanDefinitionParser-->\n    <context:component-scan base-package = \"org.springframework.iframe.*\"/>\n\n    <aop:aspectj-autoproxy/>\n\n</beans>\n```\n\n* 测试类及测试结果\n\n```java\n@Test\npublic void test1 () {\n    ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\");\n    UserService userService = xmlApplicationContext.getBean(UserService.class);\n    User user1 = userService.findUserByName(\"sd\");\n    log.info(\"user1:{}\", user1);\n}\n```\n\n```xml\n11:12:06,216 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - => [request method: UserService#findUserByName]\n11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - => [request body: [\"sd\"]]\n11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =< [response method: UserService#findUserByName]\n11:12:06,372 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =< [response result: {\"age\":18,\"role\":{},\"userName\":\"sd\"} ]\n```\n\n* 从上面的例子可以看到已经实现了这个功能，那么是怎么设计呢？\n    * 首先我们知道`AOP`是实现横切逻辑的增强，比如在方法执行前额外做一些事，方法执行后额外做一些事\n    * 那我们是不是需要在一个地方定义好什么人在什么时候做什么事情，`ServiceAspectj`切面类就是做这个事\n        * 什么人：`execution(* org.springframework.iframe.service..*(..))` 这里定义了这个包下的所有方法，这些方法就是这些人\n        * 什么时候：` @Around`注解是环绕的意思，也就是做完正常工作之前和之后做一些额外的事情\n        * 做什么事情：`Object doAround(ProceedingJoinPoint pjp) `这个方法就是定义了具体做什么事（打印报告）\n    * 上面只是些做了些规划书，还没真正起作用，那么这就需要包工头根据规划书来统一规划了，那些人需要做这些事，那些人不需要做这些事\n    * 确认了那些人需要做这些事之后就是通知这些人需要多做一些事了，那么这些人就会执行打印报告的操作\n\n* 那么`Spring`究竟是如何实现`AOP`的呢，以后的几个章节将介绍着一块\n\n## 解析\n\n* `beans/bean.xml` 配置开启`AOP`开关\n\n```xml\n// 默认标签\n<bean class=\"org.springframework.iframe.entity.User\">\n    <property name=\"userName\" value=\"shop\"/>\n</bean>\n\n// 自定义标签\n<!-- ComponentScanBeanDefinitionParser-->\n<context:component-scan base-package = \"org.springframework.iframe.*\"/>\n\n// 自定义标签\n<aop:aspectj-autoproxy/>\n```\n\n* 关注上面配置文件 `beans/bean.xml` 中的 `<aop:aspectj-autoproxy/>`配置，之前的`Spring系列(五)Document读取器BeanDefinitionDocumentReader`章节就介绍了`Spring`的配置文件分为默认标签的解析及自定义标签的解析，我们现在这个`<aop:aspectj-autoproxy/>`配置和之前扫包的`<context:component-scan`配置都属于自定义标签\n    * 回顾\n    ```java\n    /**\n     * Parse the elements at the root level in the document:\n     * \"import\", \"alias\", \"bean\".\n     * @param root the DOM root element of the document\n     */\n    protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n        // 如果是默认命名空间 xmlns=\"http://www.springframework.org/schema/beans\"\n        if (delegate.isDefaultNamespace(root)) {\n            NodeList nl = root.getChildNodes();\n            for (int i = 0; i < nl.getLength(); i++) {\n                Node node = nl.item(i);\n                if (node instanceof Element) {\n                    Element ele = (Element) node;\n                    // 默认标签解析 如<bean class=\"\"/>\n                    if (delegate.isDefaultNamespace(ele)) {\n                        parseDefaultElement(ele, delegate);\n                    }\n                    else { // 自定义标签解析 如：<context:component-scan base-package = \"*\"/>\n                        delegate.parseCustomElement(ele);\n                    }\n                }\n            }\n        }\n        else {// 自定义标签解析\n            delegate.parseCustomElement(root);\n        }\n    }\n    ```\n    * 进入自定义标签解析方法`delegate.parseCustomElement(root);`\n    ```java\n\tpublic BeanDefinition parseCustomElement(Element ele) {\n\t\treturn parseCustomElement(ele, null);\n\t}\n\n\tpublic BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {\n\t\t// 获取xml配置文件中的命名空间http://www.springframework.org/schema/aop\n\t\tString namespaceUri = getNamespaceURI(ele);\n\t\t// 根据命名空间找到命名空间处理类AopNamespaceHandler\n\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\tif (handler == null) {\n\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t\t// 解析命名空间支持的标签\n\t\treturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n\t}\n    ```\n    * 这里有个`NamespaceHandler`这个接口是命名空间处理器，它可以根据需求自己来处理我们设置的标签元素。 主要功能是 通过`Element`标签找到对于的`BeanDefinitionParser`，找到之后然后调用`BeanDefinitionParser`接口的`parse`方法来解析\n        * `NamespaceHandler`接口 ![](/images/server/spring/analysis/NamespaceHandler.png)\n            * 命名空间处理器，我们就可以根据需求自己来处理我们设置的标签元素。\n            * 可能需要配置如`<aop:config />`这样的标签, 在配置这个标签之前，通常我们需要在`xml`中引入这个aop所在的命名空间，`xmlns:aop=\"http://www.springframework.org/schema/aop`\n            * 只有通过配置`aop`的命名空间才会找到`AOP`标签的处理器`org.springframework.aop.config.AopNamespaceHandler`，在`AOP`的`jar`中的`spring.handlers`配置文件中配置了命名空间和命名空间处理器之间的关系。\n            ```xml\n            http\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler\n            ```\n    * 比如我们这里是`<aop:aspectj-autoproxy/>`标签，所以得到的命名空间处理类是`AopNamespaceHandler`，那么是怎么得到的呢，关注`this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);`可以看到传入了一个`namespaceUri`\n        * 这里是进入到`DefaultNamespaceHandlerResolver#resolve`方法，可以看到先是调用了`getHandlerMappings()` 方法读取`spring.handlers`配置的命名空间的对应关系，保存到了`Map<String, Object> handlerMappings`中，然后就是调用`NamespaceHandler`接口的`init()`方法注册解析类\n        ```java\n        /**\n         * 注册handlerMappings\n         * \n         * Locate the {@link NamespaceHandler} for the supplied namespace URI\n         * from the configured mappings.\n         * @param namespaceUri the relevant namespace URI\n         * @return the located {@link NamespaceHandler}, or {@code null} if none found\n         */\n        @Override\n        public NamespaceHandler resolve(String namespaceUri) {\n            Map<String, Object> handlerMappings = getHandlerMappings();\n            Object handlerOrClassName = handlerMappings.get(namespaceUri);\n            if (handlerOrClassName == null) {\n                return null;\n            }\n            else if (handlerOrClassName instanceof NamespaceHandler) {\n                return (NamespaceHandler) handlerOrClassName;\n            }\n            else {\n                String className = (String) handlerOrClassName;\n                try {\n                    Class<?> handlerClass = ClassUtils.forName(className, this.classLoader);\n                    if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {\n                        throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri +\n                                \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\");\n                    }\n                    // init方法\n                    NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);\n                    namespaceHandler.init();\n                    handlerMappings.put(namespaceUri, namespaceHandler);\n                    return namespaceHandler;\n                }\n                catch (ClassNotFoundException ex) {\n                    throw new FatalBeanException(\"NamespaceHandler class [\" + className + \"] for namespace [\" +\n                            namespaceUri + \"] not found\", ex);\n                }\n                catch (LinkageError err) {\n                    throw new FatalBeanException(\"Invalid NamespaceHandler class [\" + className + \"] for namespace [\" +\n                            namespaceUri + \"]: problem with handler class file or dependent class\", err);\n                }\n            }\n        }\n        /**\n         * Load the specified NamespaceHandler mappings lazily.\n         */\n        private Map<String, Object> getHandlerMappings() {\n            if (this.handlerMappings == null) {\n                synchronized (this) {\n                    if (this.handlerMappings == null) {\n                        try {\n                            // 在 META-INF/spring.handlers配置文件中有配置对应关系\n                            Properties mappings = PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);\n                            if (logger.isDebugEnabled()) {\n                                logger.debug(\"Loaded NamespaceHandler mappings: \" + mappings);\n                            }\n                            Map<String, Object> handlerMappings = new ConcurrentHashMap<String, Object>(mappings.size());\n                            CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);\n                            // 赋值到 Map<String, Object> handlerMappings中\n                            this.handlerMappings = handlerMappings;\n                        }\n                        catch (IOException ex) {\n                            throw new IllegalStateException(\n                                    \"Unable to load NamespaceHandler mappings from location [\" + this.handlerMappingsLocation + \"]\", ex);\n                        }\n                    }\n                }\n            }\n            return this.handlerMappings;\n        }\n        ```\n        * 关注`namespaceHandler.init();`上下几行代码，这里有执行`init()`方法，下面的逻辑会调用，这个方法是注册标签与相应解析类对应关系的方法\n    * AopNamespaceHandler.java\n    ```java\n    public class AopNamespaceHandler extends NamespaceHandlerSupport {\n    \n        /**\n         * Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the\n         * '{@code config}', '{@code spring-configured}', '{@code aspectj-autoproxy}'\n         * and '{@code scoped-proxy}' tags.\n         */\n        @Override\n        public void init() {\n            // In 2.0 XSD as well as in 2.1 XSD.\n            registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser());\n            registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser());\n            registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator());\n    \n            // Only in 2.0 XSD: moved to context namespace as of 2.1\n            registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n        }\n    }\n    ```\n    * 关注`registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser());`这行代码这里注册了标签命名与对应解析类的对应关系，并存放在`Map<String, BeanDefinitionParser> parsers` 对象中，所以现在\n    ```java\n  \tprivate final Map<String, BeanDefinitionParser> parsers = new HashMap<String, BeanDefinitionParser>();  \n  \n    protected final void registerBeanDefinitionParser(String elementName, BeanDefinitionParser parser) {\n        this.parsers.put(elementName, parser);\n    }\n    ```\n\n### 解析配置文件\n\n* 上面的步骤已经得到了`AopNamespaceHandler`，然后就是进入`handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));` 方法开始解析，可以看到逻辑很简单，就是在`Map<String, BeanDefinitionParser> parsers`中`get`相应的解析类并调用其`parse`方法\n\n```java\n/**\n * 先找到对应的BeanDefinitionParser 然后执行parse(element, parserContext)方法\n * Parses the supplied {@link Element} by delegating to the {@link BeanDefinitionParser} that is\n * registered for that {@link Element}.\n */\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    return findParserForElement(element, parserContext).parse(element, parserContext);\n}\n\n/**\n * 根据标签名得到相应的解析类，NamespaceHandler这里起到了一个中介的作用\n * {@link parsers} Map<String, BeanDefinitionParser> 存放着所有的解析类，这个\n *\n * Locates the {@link BeanDefinitionParser} from the register implementations using\n * the local name of the supplied {@link Element}.\n */\nprivate BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) {\n    String localName = parserContext.getDelegate().getLocalName(element);\n    BeanDefinitionParser parser = this.parsers.get(localName);\n    if (parser == null) {\n        parserContext.getReaderContext().fatal(\n                \"Cannot locate BeanDefinitionParser for element [\" + localName + \"]\", element);\n    }\n    return parser;\n}\n```\n\n* 我们这里`<aop:aspectj-autoproxy/>`标签得到的是`AspectJAutoProxyBeanDefinitionParser`解析类\n\n#### AspectJAutoProxyBeanDefinitionParser\n\n```java\nclass AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser {\n\n\t@Override\n\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\t// 注册 AnnotationAwareAspectJAutoProxyCreator AOP的实现基本上是靠这个类来完成的\n\t\tAopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);\n\t\t// 对于注解中子类的处理\n\t\textendBeanDefinition(element, parserContext);\n\t\treturn null;\n\t}\n\n\tprivate void extendBeanDefinition(Element element, ParserContext parserContext) {\n\t\tBeanDefinition beanDef =\n\t\t\t\tparserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);\n\t\tif (element.hasChildNodes()) {\n\t\t\taddIncludePatterns(element, parserContext, beanDef);\n\t\t}\n\t}\n\n\tprivate void addIncludePatterns(Element element, ParserContext parserContext, BeanDefinition beanDef) {\n\t\tManagedList<TypedStringValue> includePatterns = new ManagedList<TypedStringValue>();\n\t\tNodeList childNodes = element.getChildNodes();\n\t\tfor (int i = 0; i < childNodes.getLength(); i++) {\n\t\t\tNode node = childNodes.item(i);\n\t\t\tif (node instanceof Element) {\n\t\t\t\tElement includeElement = (Element) node;\n\t\t\t\tTypedStringValue valueHolder = new TypedStringValue(includeElement.getAttribute(\"name\"));\n\t\t\t\tvalueHolder.setSource(parserContext.extractSource(includeElement));\n\t\t\t\tincludePatterns.add(valueHolder);\n\t\t\t}\n\t\t}\n\t\tif (!includePatterns.isEmpty()) {\n\t\t\tincludePatterns.setSource(parserContext.extractSource(element));\n\t\t\tbeanDef.getPropertyValues().add(\"includePatterns\", includePatterns);\n\t\t}\n\t}\n\n}\n```\n\n* 关注`parse`方法，可以看到主要逻辑是注册了`AnnotationAwareAspectJAutoProxyCreator`这个`bean`\n\n```java\n@Override\npublic BeanDefinition parse(Element element, ParserContext parserContext) {\n    // 注册 AnnotationAwareAspectJAutoProxyCreator 对应AOP的实现基本上是靠这个类来完成的\n    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);\n    // 对于注解中子类的处理\n    extendBeanDefinition(element, parserContext);\n    return null;\n}\n```\n\n* `AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);`方法这里是注册了`AnnotationAwareAspectJAutoProxyCreator`这个`bean`，`RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);`这里就把`AnnotationAwareAspectJAutoProxyCreator.class`给`BeanDefinition`绑定在一起了，`registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);`方法是将`BeanDefinition`注册到`BeanFactory`中了\n\n```java\npublic static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(\n        ParserContext parserContext, Element sourceElement) {\n    // 关键逻辑 注册或升级AutoProxyCreator定义为beanName为org.springframework.aop.config.internalAutoProxyCreator\n    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(\n            parserContext.getRegistry(), parserContext.extractSource(sourceElement));\n    // 对于proxy-target-class(强制使用CGLIB)以及expose-proxy属性的处理\n    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);\n    // 注册组件并通知，便于监听器做进一步处理\n    registerComponentIfNecessary(beanDefinition, parserContext);\n}\n\n\n// AopConfigUtils#registerAspectJAnnotationAutoProxyCreatorIfNecessary(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)\n\npublic static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {\n    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);\n}\n\nprivate static BeanDefinition registerOrEscalateApcAsRequired(Class<?> cls, BeanDefinitionRegistry registry, Object source) {\n    Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n    // 如果已经存在了自动代理创建器且存在的自动代理创建器与现在的不一致那么需要根据优先级来判断到底需要使用哪个\n    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {\n        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);\n        if (!cls.getName().equals(apcDefinition.getBeanClassName())) {\n            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());\n            int requiredPriority = findPriorityForClass(cls);\n            if (currentPriority < requiredPriority) {\n                // 改变bean最重要的就是改变bean所对应的className属性\n                apcDefinition.setBeanClassName(cls.getName());\n            }\n        }\n        // 如果已经存在自动代理创建器并且与将要创建的一致，那么无需再次创建\n        return null;\n    }\n    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);\n    beanDefinition.setSource(source);\n    beanDefinition.getPropertyValues().add(\"order\", Ordered.HIGHEST_PRECEDENCE);\n    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);\n    return beanDefinition;\n}\n```\n\n* 处理`proxy-target-class`属性\n\n```java\nprivate static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) {\n    if (sourceElement != null) {\n        // 对proxy-target-class属性的处理 JDK动态代理或者CGLIB\n        boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));\n        if (proxyTargetClass) {\n            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);\n        }\n        // 对expose-proxy属性的处理\n        boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));\n        if (exposeProxy) {\n            // 强制使用的过程其实也是一个属性设置的过程\n            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);\n        }\n    }\n}\n```\n\n#### ConfigBeanDefinitionParser\n\n* `ConfigBeanDefinitionParser`用于解析`<aop:config>`标签，这种方法是`Spring`之前版本定义增强切面的方法，不过现在都是使用`@AspectJ`注解的形式来定义了，所以暂不细究\n\n```xml\n<aop:config proxy-target-class=\"true\">\n    <!--使用<aop:aspect>元素标签定义切面, 其内部可以定义多个增强-->\n    <aop:aspect ref=\"adviceMethods\">\n        <aop:after method=\"afterExecution\" pointcut=\"execution(* com.aop.learn.service.*.*(..))\"/>\n    </aop:aspect>\n</aop:config>\n\n<!--adviceMethods bean, 该bean是增强方法所在的类-->\n<bean id=\"adviceMethods\" class=\"com.aop.learn.advice.UserAdvice\"/>\n<bean id=\"userService\" class=\"com.aop.learn.service.impl.UserServiceImpl\"/>\n```\n\n* `ConfigBeanDefinitionParser` 类成员及`parse`方法\n\n```java\nclass ConfigBeanDefinitionParser implements BeanDefinitionParser {\n\n\tprivate static final String ASPECT = \"aspect\";\n\tprivate static final String EXPRESSION = \"expression\";\n\tprivate static final String ID = \"id\";\n\tprivate static final String POINTCUT = \"pointcut\";\n\tprivate static final String ADVICE_BEAN_NAME = \"adviceBeanName\";\n\tprivate static final String ADVISOR = \"advisor\";\n\tprivate static final String ADVICE_REF = \"advice-ref\";\n\tprivate static final String POINTCUT_REF = \"pointcut-ref\";\n\tprivate static final String REF = \"ref\";\n\tprivate static final String BEFORE = \"before\";\n\tprivate static final String DECLARE_PARENTS = \"declare-parents\";\n\tprivate static final String TYPE_PATTERN = \"types-matching\";\n\tprivate static final String DEFAULT_IMPL = \"default-impl\";\n\tprivate static final String DELEGATE_REF = \"delegate-ref\";\n\tprivate static final String IMPLEMENT_INTERFACE = \"implement-interface\";\n\tprivate static final String AFTER = \"after\";\n\tprivate static final String AFTER_RETURNING_ELEMENT = \"after-returning\";\n\tprivate static final String AFTER_THROWING_ELEMENT = \"after-throwing\";\n\tprivate static final String AROUND = \"around\";\n\tprivate static final String RETURNING = \"returning\";\n\tprivate static final String RETURNING_PROPERTY = \"returningName\";\n\tprivate static final String THROWING = \"throwing\";\n\tprivate static final String THROWING_PROPERTY = \"throwingName\";\n\tprivate static final String ARG_NAMES = \"arg-names\";\n\tprivate static final String ARG_NAMES_PROPERTY = \"argumentNames\";\n\tprivate static final String ASPECT_NAME_PROPERTY = \"aspectName\";\n\tprivate static final String DECLARATION_ORDER_PROPERTY = \"declarationOrder\";\n\tprivate static final String ORDER_PROPERTY = \"order\";\n\tprivate static final int METHOD_INDEX = 0;\n\tprivate static final int POINTCUT_INDEX = 1;\n\tprivate static final int ASPECT_INSTANCE_FACTORY_INDEX = 2;\n\n\tprivate ParseState parseState = new ParseState();\n\n\n\t@Override\n\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tCompositeComponentDefinition compositeDef =\n\t\t\t\tnew CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element));\n\t\tparserContext.pushContainingComponent(compositeDef);\n\n\t\tconfigureAutoProxyCreator(parserContext, element);\n\n\t\tList<Element> childElts = DomUtils.getChildElements(element);\n\t\tfor (Element elt: childElts) {\n\t\t\tString localName = parserContext.getDelegate().getLocalName(elt);\n\t\t\tif (POINTCUT.equals(localName)) {\n\t\t\t\tparsePointcut(elt, parserContext);\n\t\t\t}\n\t\t\telse if (ADVISOR.equals(localName)) {\n\t\t\t\tparseAdvisor(elt, parserContext);\n\t\t\t}\n\t\t\telse if (ASPECT.equals(localName)) {\n\t\t\t\tparseAspect(elt, parserContext);\n\t\t\t}\n\t\t}\n\n\t\tparserContext.popAndRegisterContainingComponent();\n\t\treturn null;\n\t}\n```\n\n## 总结\n\n* 在`Spring`中如果是用`xml`的方式配置`Spring`如果需要使用`AOP`功能，就需要在配置文件中添加`<aop:aspectj-autoproxy/>`属性，这个是打开`AOP`功能的开关，这是标签是自定义标签所以具体的解析工作是给`AspectJAutoProxyBeanDefinitionParser`来完成的，那么`Spring`是怎么知道这个`<aop:aspectj-autoproxy/>`由这个类来解析的呢，`NamespaceHandler`这个接口设计就发挥作用了，`aop`对应的命名空间处理器是`AopNamespaceHandler`（对应关系在`aop`的炸包里的`META-INF/spring.handlers`里设置），`AopNamespaceHandler`里面有配置（init方法）`aspectj-autoproxy`标签对应的解析类是`AspectJAutoProxyBeanDefinitionParser`\n* `<aop:aspectj-autoproxy/>` 的最终结果是注册`AnnotationAwareAspectJAutoProxyCreator` 这个`bean`，这个类用于创建`AOP`的代理类\n\n\n\n## 参考\n* 《Spring 源码深度解析》","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(五一)AOP切点表达式函数","url":"/2019/08/01/backend/framework/spring/analysis/Spring系列(五一)AOP切点表达式函数/","content":"## 概述\n* Spring支持9个@ApsectJ切点表达式函数，它们用不同的方式描述目标类的连接点，根据描述对象的不同，可以将它们大致分为4种类型： \n    * 方法切点函数：通过描述目标类方法信息定义连接点； \n    * 方法入参切点函数：通过描述目标类方法入参的信息定义连接点； \n    * 目标类切点函数：通过描述目标类类型信息定义连接点； \n    * 代理类切点函数：通过描述目标类的代理类的信息定义连接点； \n* 这4种类型的切点函数，通过下面的表格进行说明： \n<escape> \n<table>    \n  <tr>\n    <th>类别</th>\n    <th>函数</th>\n    <th>入参</th>\n    <th>说明</th>\n  </tr> \n  \n  <tr>\n    <td rowspan=\"2\">方法切点函数</td>\n    <td>execution()</td>\n    <td>方法匹配模式串</td>\n    <td>表示满足某一匹配模式的所有目标类方法连接点。如execution(* greetTo(..))表示所有目标类中的greetTo()方法。</td>\n  </tr> \n   \n  <tr>\n    <td>@annotation()</td>\n    <td>方法注解类名</td>\n    <td>表示标注了特定注解的目标方法连接点。如@annotation(com.baobaotao.anno.NeedTest)表示任何标注了@NeedTest注解的目标类方法。</td>\n  </tr>\n  \n  <tr>\n    <td rowspan=\"2\">方法入参切点函数</td>\n    <td>args()</td>\n    <td>类名</td>\n    <td>通过判别目标类方法运行时入参对象的类型定义指定连接点。如args(com.baobaotao.Waiter)表示所有有且仅有一个按类型匹配于Waiter的入参的方法。</td>\n  </tr> \n   \n  <tr>\n    <td>@args()</td>\n    <td>类型注解类名</td>\n    <td>通过判别目标方法的运行时入参对象的类是否标注特定注解来指定连接点。如@args(com.baobaotao.Monitorable)表示任何这样的一个目标方法：它有一个入参且入参对象的类标注@Monitorable注解。</td>\n  </tr>\n  \n  <tr>\n    <td rowspan=\"4\">目标类切点函数</td>\n    <td>within()</td>\n    <td>类名匹配串</td>\n    <td>  表示特定域下的所有连接点。如within(com.baobaotao.service.*)表示com.baobaotao.service包中的所有连接点，也即包中所有类的所有方法，而within(com.baobaotao.service.*Service)表示在com.baobaotao.service包中，所有以Service结尾的类的所有连接点。</td>\n  </tr> \n   \n  <tr>\n    <td>target()</td>\n    <td>类名</td>\n    <td>假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过target(com.baobaotao.Waiter)定义的切点，Waiter、以及Waiter实现类NaiveWaiter中所有连接点都匹配该切点。</td>\n  </tr>\n  \n  <tr>\n    <td>@within()</td>\n    <td>类型注解类名</td>\n    <td>假如目标类按类型匹配于某个类A，且类A标注了特定注解，则目标类的所有连接点匹配这个切点。如@within(com.baobaotao.Monitorable)定义的切点，假如Waiter类标注了@Monitorable注解，则Waiter以及Waiter实现类NaiveWaiter类的所有连接点都匹配。</td>\n  </tr>\n  \n  <tr>\n    <td>@target()</td>\n    <td>类型注解类名</td>\n    <td>  目标类标注了特定注解，则目标类所有连接点匹配该切点。如@target(com.baobaotao.Monitorable)，假如NaiveWaiter标注了@Monitorable，则NaiveWaiter所有连接点匹配切点。</td>\n  </tr>\n  \n  <tr>\n    <td>代理类切点函数</td>\n    <td>this()</td>\n    <td>类名</td>\n    <td>代理类按类型匹配于指定类，则被代理的目标类所有连接点匹配切点。限制连接点匹配 AOP 代理的 Bean 引用为指定类型的类</td>\n  </tr>\n    \n</table>\n</escape>\n\n### 详解\n\n### execution()\n> execution() 是最常见的切点函数,语法形式为\n\n```java\nexcution(<修饰符模式> ? <返回类型模式> <方法名模式>(<参数模式>) <异常模式>?) \n```\n\n### 切点复合运算\n* &&  与运算符\n   * & 是特殊运算符，在xml可以使用 &amp;&amp;\n   * Spring 提供一个等效的运算符`and`\n* || 或运算符\n   * Spring 提供一个等效的运算符`or`\n* ! 非运算符\n   * Spring 提供一个等效的运算符`not`\n\n示例代码：\n```java\n@Before(\"!target(com.baobaotao.NaiveWaiter) \"+\n\t\t\"&& execution(* serveTo(..)))\")\npublic void notServeInNaiveWaiter() {\n\tSystem.out.println(\"--notServeInNaiveWaiter() executed!--\");\n}\n\n@After(\"within(com.baobaotao.*) \"\n\t\t+ \" && execution(* greetTo(..)))\")\npublic void greeToFun() {\n\tSystem.out.println(\"--greeToFun() executed!--\");\n}\n\n@AfterReturning(\"target(com.baobaotao.Waiter) || \"+\n\t\t        \" target(com.baobaotao.Seller)\")\npublic void waiterOrSeller(){\n\tSystem.out.println(\"--waiterOrSeller() executed!--\");\n}\n```\n\n### 命名切点\n* 运用命名切点，可以实现切点表达式的复用\n```java\npublic class TestNamePointcut {\n    // 只能在本切面类中使用\n    @Pointcut(\"within(com.smart.*)\")\n    private void inPackage(){}\n    \n    // 在切面类、子切面类中使用\n    @Pointcut(\"execution(* greetTo(..)))\")\n    protected void greetTo(){}\n    \n    // 公共使用\n    @Pointcut(\"inPackage() and greetTo()\")\n    public void inPkgGreetTo(){}\n}\n```\n\n### 访问连接点信息\n#### JoinPoint\n* java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表；\n* Signature getSignature() ：获取连接点的方法签名对象；\n* java.lang.Object getTarget() ：获取连接点所在的目标对象；\n* java.lang.Object getThis() ：获取代理对象本身；\n\n#### ProceedingJoinPoint （ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：）\n* java.lang.Object proceed() throws java.lang.Throwable：通过反射执行目标对象的连接点处的方法；\n\n* java.lang.Object proceed(java.lang.Object[] args) throws java.lang.Throwable：通过反射执行目标对象连接点处的方法，不过使用新的入参替换原来的入参。\n\n## 切点表达式例子\n\n```java\npublic class ExecutionAspect {\n\n    /**\n     * 匹配所有目标类的public方法\n     */\n    @Before(\"execution(public * *(..))\")\n\n    /**\n     * 匹配所有以To为后缀的方法\n     */\n    @Before(\"execution(* *To(..))\")\n\n    /**\n     * 匹配Waiter接口中的所有方法\n     */\n    @Before(\"execution(* com.aop.learn.service.Writer.*(..))\")\n \n    /**\n     * 匹配Waiter接口中及其实现类的方法\n     */\n    @Before(\"execution(* com.aop.learn.service.Writer+.*(..))\")\n  \n    /**\n     * 匹配 com.aop.learn.service 包下所有类的所有方法\n     */\n    @Before(\"execution(* com.aop.learn.service.*(..))\")\n \n    /**\n     * 匹配 com.aop.learn.service 包,子孙包下所有类的所有方法\n     */\n    @Before(\"execution(* com.aop.learn.service..*(..))\")\n  \n    /**\n     * 匹配 包名前缀为com的任何包下类名后缀为ive的方法,方法必须以Smart为前缀\n     */\n    @Before(\"execution(* com..*.*ive.Smart*(..))\")\n\n    /**\n     * 匹配 save(String name,int age) 函数\n     */\n    @Before(\"execution(* save(String,int))\")\n \n    /**\n     * 匹配 save(String name,*) 函数 第二个参数为任意类型\n     */\n    @Before(\"execution(* save(String,*))\")\n   \n    /**\n     * 匹配 save(String name,..) 函数 除第一个参数固定外,接受后面有任意个入参且入参类型不限\n     */\n    @Before(\"execution(* save(String,..))\")\n   \n    /**\n     * 匹配 save(String+) 函数  String+ 表示入参类型是String的子类\n     */\n    @Before(\"execution(* save(String+))\")\n   \n    /**\n     * 最详细的切入点表达式  具体到包、类名、方法名、方法返回值、参数个数及类型类型\n     */\n    @Before(\"execution(public void com.bwlu.aop.MathCalculator.add(int, int))\")\n      \n    /**\n     * 最模糊的切入点表达式\n     */\n    @Before(\"execution (* *.*(..))\")\n    \n    /**\n     * MathCalculator中的任意方法,任意参数列表\n     */\n    @Before(\"execution(public void com.bwlu.aop.MathCalculator.*(..))\")\n    \n    /**\n     * MathCalculator中的任意方法,任意参数列表，任意返回值\n     */\n    @Before(\"execution(public * com.bwlu.aop.MathCalculator.*(..))\")\n    \n    /** \n     * MathCalculator中的任意方法,任意参数列表，任意返回值，任意访问修饰符\n     */\n    @Before(\"execution( * com.bwlu.aop.MathCalculator.*(..))\")\n```\n\n\n\n```java\n    /**\n     * 匹配Controller\n     * @within :使用 “@within(注解类型)” 匹配所以持有指定注解类型内的方法;注解类型也必须是全限定类型名;\n     */\n    @Pointcut(\"@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)\")\n    public void excudeService() {\n    }\n```\n\n## 参考\n* 《精通Spring+4.x++企业应用开发实战》\n* https://blog.csdn.net/yangshangwei/article/details/77943720","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(五十)面向切面编程AOP","url":"/2019/08/01/backend/framework/spring/analysis/Spring系列(五十)面向切面编程AOP/","content":"## 概念 \n\n### 什么是AOP\n \n* 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。\n\n### 为什么要用Aop\n* 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n\n* 在不改变原有方法的基础添加一些功能 , 比如:\n    * 日志记录\n    * 性能统计\n    * 安全控制\n    * 事务处理\n    * 异常处理等等\n\n<!--more-->\n\n### Aop 术语\n> 连接点(JoinPoint)\n\n 程序执行到某个特定位置，如类开始初始化前，类初始化后，某个方法调用前/后，方法抛出异常后，一些具有边界性质的特定点就是连接点， Spring 仅支持方法级的连接点(方法执行前，方法完成后，抛出异常后)\n\n> 切点(Pointcut)\n\n 从连接点的基础上引出的概念，是指特定的连接点，一个类有好多方法,每个方法又有多个连接点，则需要切点来限定一个小范围的连接点，在Spring中是使用类和方法作为连接点的查询条件\n \n> 通知、增强处理(Advice)\n\n 就是指你所需要添加的功能及这个功能什么时候(通知)实现 , 比如一个业务方法需要实现日志功能 , 那么就需要专门在一个地方定义好需要做什么，然后定义什么时候执行(方法执行前？，方法完成后？，抛出异常？。。。)\n  \n   Spring 切面可应用的 5 种通知类型：\n   1. Before——在方法调用之前调用通知\n   2. After——在方法完成之后调用通知，无论方法执行成功与否\n   3. After-returning——在方法执行成功之后调用通知\n   4. After-throwing——在方法抛出异常后进行通知\n   5. Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为\n\n> 引入(introduction)\n \n  特殊的增强，为类添加一些属性和方法，这样即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类\n\n> 切面(Aspect)\n\n 切面由切点和增强组成 , 及包括横切逻辑的定义，也包括切点的定义, \n\n> 目标对象(Target)\n\n 增强逻辑的织入目标类 , 如果没有Aop,那么目标对象就要自己实现(日志记录，性能统计，安全控制，事务处理，异常处理)这些功能，那么一个方法就会变成很杂乱\n \n> 织入(Weaing)\n\n 将增强添加到目标对象的具体连接点上, Spring使用动态代理织入\n \n\n Aop有三种织入方式\n 1. 编译期织入\n 2. 类装载期织入\n 3. 动态代理织入: 在运行期间为目标类添加增强生成子类的方式\n\n### Aop 实现\n\n* `JDK`动态代理\n\n* `CGLib`动态代理\n\n#### 代理知识总结\n* `Spring`使用`JDK`动态代理和`CGLib`动态代理技术在运行期织入增强，要使用`JDK`动态代理，目标类必须实现接口，而`CGLib`不对目标类作任何限制，他是通过动态生成目标类子类的方式提供代理\n* `JDK`在创建代理对象时的性能高于`CGLib`，但生成的代理对象的运行性能却比`CGLib`的低，如果无需频繁的创建代理对象比较适合采用`CGLib`动态代理技术，反之比较适合`JDK`动态代理技术\n\n\n### AOP示例\n\n* 创建切面类`ServiceAspectj`，这个方法用于定义切面，功能是打印方法的执行前的输入参数及输出结果\n\n```java\n@Slf4j\n@Aspect\n@Component\npublic class ServiceAspectj {\n\n    @Pointcut(value = \"execution(* org.springframework.iframe.service..*(..))\")\n    public void pointcut() {\n\n    }\n\n    @Around(\"pointcut()\")\n    public Object doAround(ProceedingJoinPoint pjp) throws Throwable {\n        String className = pjp.getSignature().getDeclaringType().getSimpleName();\n        String methodName = pjp.getSignature().getName();\n\n        log.info(\"=> [request method: {}#{}]\",className, methodName);\n        log.info(\"=> [request body: {}]\", JSONObject.toJSONString(pjp.getArgs()));\n\n        Object result = pjp.proceed();\n\n        log.info(\"=< [response method: {}#{}]\",className, methodName);\n        log.info(\"=< [response result: {} ]\", JSONObject.toJSONString(result));\n        return result;\n    }\n\n}\n```\n\n* 需要切的方法\n\n```java\npublic interface UserService {\n\n    User findUserByName(String userName);\n\n}\n\n\n@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    User user;\n\n    @Autowired\n    private RoleService roleService;\n\n    @Override\n    public User findUserByName(String userName) {\n        User user = new User(userName,18);\n        //Role role = roleService.findRoleByUserName(userName);\n        user.setRole(new Role());\n        return user;\n    }\n\n}\n```\n\n* `Spring` 配置文件 `beans/bean.xml` 添加`<aop:aspectj-autoproxy/>`配置，开启AOP开关\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n                              http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\">\n\n\n    <bean class=\"org.springframework.iframe.entity.User\">\n        <property name=\"userName\" value=\"shop\"/>\n    </bean>\n\n    <!-- ComponentScanBeanDefinitionParser-->\n    <context:component-scan base-package = \"org.springframework.iframe.*\"/>\n\n    <aop:aspectj-autoproxy/>\n\n</beans>\n```\n\n* 测试类及测试结果\n\n```java\n@Test\npublic void test1 () {\n    ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\");\n    UserService userService = xmlApplicationContext.getBean(UserService.class);\n    User user1 = userService.findUserByName(\"sd\");\n    log.info(\"user1:{}\", user1);\n}\n```\n\n```xml\n11:12:06,216 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - => [request method: UserService#findUserByName]\n11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - => [request body: [\"sd\"]]\n11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =< [response method: UserService#findUserByName]\n11:12:06,372 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =< [response result: {\"age\":18,\"role\":{},\"userName\":\"sd\"} ]\n```\n\n## 总结\n* AOP的工作重心就是将增强应用与目标对象的连接点上，这里包括两部分内容：\n    * 如何通过切点和增强定位到连接点上\n    * 如何在增强中编写切面的逻辑\n\n## 参考\n* 《精通Spring+4.x++企业应用开发实战》","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(三十)ApplicationContext分析","url":"/2019/07/02/backend/framework/spring/analysis/Spring系列(三一)ApplicationContext分析/","content":"## 前言\n* `BeanFactory` 是容器的顶级抽象，它并不适用于我们生产环境，在生产环境我们通常会选择 `ApplicationContext` ，相对于大多数人而言，它才是正规军，相比于 `BeanFactory` 这个杂牌军而言，它由如下几个区别：\n    * 继承 `MessageSource`，提供国际化的标准访问策略。\n    * 继承 `ApplicationEventPublisher` ，提供强大的事件机制。\n    * 扩展 `ResourceLoader`，可以用来加载多个 `Resource`，可以灵活访问不同的资源。\n    * 对 `Web` 应用的支持。\n    \n### ApplicationContext 接口\n\n* 接口代码\n\n```java\npublic interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,\n\t\tMessageSource, ApplicationEventPublisher, ResourcePatternResolver {\n\n\tString getId();\n\n\tString getApplicationName();\n\n\tString getDisplayName();\n\n\tlong getStartupDate();\n\n\tApplicationContext getParent();\n\n\tAutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;\n}\n```\n\n* 类继承关系\n    * `BeanFactory`\n        * `Spring` 管理 `Bean` 的顶层接口，我们可以认为他是一个简易版的 `Spring` 容器。`ApplicationContext` 继承 `BeanFactory` 的两个子类：`HierarchicalBeanFactory` 和 `ListableBeanFactory`。\n    * `HierarchicalBeanFactory` 是一个具有层级关系的 `BeanFactory`，拥有属性 `parentBeanFactory` 。\n    * `ListableBeanFactory` 实现了枚举方法可以列举出当前 `BeanFactory` 中所有的 `bean` 对象而不必根据 `name` 一个一个的获取。\n    *  `ApplicationEventPublisher`\n        * 用于封装事件发布功能的接口，向事件监听器（`Listener`）发送事件消息。\n    * `ResourceLoader`\n        * Spring 加载资源的顶层接口，用于从一个源加载资源文件。`ApplicationContext` 继承 `ResourceLoader` 的子类 `ResourcePatternResolver`，该接口是将 `location` 解析为 `Resource` 对象的策略接口。\n    * `MessageSource`\n        * 解析 `message` 的策略接口，用不支撑国际化等功能。\n    * `EnvironmentCapable`\n        * 用于获取 `Environment` 的接口。\n\n![](/images/server/spring/analysis/ApplicationContext.png)\n\n\n* 接口方法(包括父类方法)\n\n![](/images/server/spring/analysis/ApplicationContextMethod.jpg)\n\n### ApplicationContext 常用子类\n\n\n##### 1、 WebApplicationContext\n\n* 该接口只有一个 `#getServletContext()` 方法，用于给 `Servlet` 提供上下文信息。\n\n```java\n// WebApplicationContext.java\n\npublic interface WebApplicationContext extends ApplicationContext {\n\n    ServletContext getServletContext();\n    \n}\n```\n\n##### 2、 ClassPathXmlApplicationContext\n\n* `ClassPathXmlApplicationContext` 是我们在学习 `Spring` 过程中用的非常多的一个类\n\n![](/images/server/spring/analysis/ClassPathXmlApplicationContext.png)\n\n* `ClassPathXmlApplicationContext` 设计的顶级接口\n    * `BeanFactory`\n        * Spring 容器 Bean 的管理\n    * `MessageSource`\n        * 管理 message ，实现国际化等功能\n    * `ApplicationEventPublisher`\n        * 事件发布,用于封装事件发布功能的接口，向事件监听器（Listener）发送事件消息。\n    * `ResourcePatternResolver`\n        * 资源加载\n    * `EnvironmentCapable`\n        * 系统 Environment（profile + Properties） 相关\n    * `Lifecycle`\n        * 管理生命周期\n    * `Closable`\n        * 关闭，释放资源,用于关闭 ApplicationContext 销毁所有 Bean \n    * `InitializingBean`\n        * 自定义初始化\n    * `BeanNameAware`\n        * 设置 beanName 的 Aware 接口\n\n##### 3、ConfigurableApplicationContext \n* 接口 `ConfigurableApplicationContext` 对 `ApplicationContext` 接口再次进行扩展，提供了生命周期的管理功能。\n\n## 总结\n* `Spring` 真的是一个非常优秀的框架，具有良好的结构设计和接口抽象，它的每一个接口职能单一，且都是具体功能到各个模块的高度抽象，且几乎每套接口都提供了一个默认的实现`（defaultXXX）`。\n\n* 抽象类 `ApplicationContext` 对整套接口提供了大部分的默认实现，将其中“不易变动”的部分进行了封装，通过“组合”的方式将“容易变动”的功能委托给其他类来实现，同时利用模板方法模式将一些方法的实现开放出去由子类实现，从而实现“对扩展开放，对修改封闭”的设计原则。\n\n## 参考\n\n* 芋道源码 http://www.iocoder.cn\n","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(三十)IOC容器技术内幕","url":"/2019/07/02/backend/framework/spring/analysis/Spring系列(三十)IOC容器技术内幕/","content":"## 前言\n### IOC是什么\n* `Ioc—Inversion of Control`，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：\n    * 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；`谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。`\n    * 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；`而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。`\n* 用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来：\n\n![](/images/server/spring/analysis/ioc1.jpg)\n\n* 当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:\n\n![](/images/server/spring/analysis/ioc2.jpg)\n\n### IOC和DI\n* `Dependency Injection` 即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。\n\n* 那么IOC和DI这两者又是什么关系呢？　IOC就是一种软件设计思想，DI是这种软件设计思想的一个实现。而Spring中的核心机制就是DI。\n\n### IOC注入形式\n* 构造函数注入\n    * 通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 \n* setter 方法注入\n    * 当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中\n* 接口注入\n    * 接口方式注入需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。\n    \n> Spring支持前两种依赖注入方式\n\n## Spring 容器\n> 该图为 ClassPathXmlApplicationContext 的类继承体系结构，虽然只有一部分，但是它基本上包含了 IoC 体系中大部分的核心类和接口。\n\n![](/images/server/spring/analysis/ioc.png)\n\n* 如果将Spring容器比作一辆车，那么可以将`BeanFactory`看成汽车的发动机，而`ApplicationContext`则是一辆完整的汽车，它不但包括发动机，还包括离合器、变速器及底盘、车身、电气设备等其他组件。在`ApplicationContext`内，各个组件按部就班、有条不絮地完成汽车的各项功能。\n\n### 内部工作机制\n\n#### Spring 容器启动逻辑\n\n* Spring的`AbstractApplicationContext`是`ApplicationContext`的抽象实现类，该抽象类的`refresh()`方法定义了Spring容器在加载配置文件后的各项处理过程，这些处理过程清新地刻画了Spring容器启动时所执行地各项操作：\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        prepareRefresh();\n\n        // Tell the subclass to refresh the internal bean factory.\n        // 初始化BeanFactory\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n        // Prepare the bean factory for use in this context.\n        prepareBeanFactory(beanFactory);\n\n        try {\n            // Allows post-processing of the bean factory in context subclasses.\n            postProcessBeanFactory(beanFactory);\n\n            // Invoke factory processors registered as beans in the context.\n            // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，\n            // 并调用其postProcessBeanFactory接口方法\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            // Register bean processors that intercept bean creation.\n            // 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean，\n            // 并将它们注册到容器Bean后处理器的注册表中\n            registerBeanPostProcessors(beanFactory);\n\n            // Initialize message source for this context.\n            // 初始化消息源 初始化容器的国际化消息资源\n            initMessageSource();\n\n            // Initialize event multicaster for this context.\n            // 初始化应用上下文事件广播器\n            initApplicationEventMulticaster();\n\n            // Initialize other special beans in specific context subclasses.\n            // 初始化其他特殊的bean，由具体子类实现，这是个钩子方法\n            onRefresh();\n\n            // Check for listener beans and register them.\n            // 注册事件监听器\n            registerListeners();\n\n            // Instantiate all remaining (non-lazy-init) singletons.\n            // 初始化所有单实例的Bean，使用懒加载模式的bean除外，初始化Bean后将它们放到Spring容器的缓冲池中\n            finishBeanFactoryInitialization(beanFactory);\n\n            // Last step: publish corresponding event.\n            // 完成刷新并发布容器刷新事件\n            finishRefresh();\n        }\n\n        catch (BeansException ex) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception encountered during context initialization - \" +\n                        \"cancelling refresh attempt: \" + ex);\n            }\n\n            // Destroy already created singletons to avoid dangling resources.\n            destroyBeans();\n\n            // Reset 'active' flag.\n            cancelRefresh(ex);\n\n            // Propagate exception to caller.\n            throw ex;\n        }\n\n        finally {\n            // Reset common introspection caches in Spring's core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n```\n\n#### 处理流程图\n* Spring容器从加载配置文件到创建一个完整Bean的作业流程及参与的角色\n\n![](/images/server/spring/analysis/ioc4.png)\n\n* 由上图可以得到Spring容器的构造逻辑，如下：\n    * 1、ResourceLoader从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件资源；\n    * 2、BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个<bean>解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中；\n    * 3、容器扫描BeanDefintionRegistry中的BeanDefintion，使用Java反射机制自动识别出Bean工厂后处理器(实现BeanFactoryPostProcessor接口的Bean)，然后调用这些Bean工厂后处理对BeanDefinitionRegistry中的BeanDefinition进行加工处理。主要完成一下两项工作:\n        * 1). 对使用占位符的< bean >元素标签进行解析，得到最终的配置值。这意味着对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象；\n        * 2). 对BeanDefinitionRegistry中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean(实现java.beans.PropertyEditor接口的Bean)，并自动将它们注册到Spring容器的属性器注册表中(PropertyEditorRegistry)。\n    * 4、Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，并调用InstantiationStarategy着手进行Bean实例化的工作；\n    * 5、在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装。BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefintion及容器中的属性编辑器，完成Bean属性注入工作；\n    * 6、利用容器中的Bean后处理器(实现BeanPostProcessor接口的Bean)对己经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean；\n#### 总结\n\n* Spring容器堪称一部设计精密的机器，其内部拥有众多的组件和装置。Spring的高明之处在于，它使用众多接口描绘除了所有的装置的协作蓝图，构建好Spring的骨架，继而通过继承体系层层推演、不断丰富，最终让Spring成为有血有肉的完整的框架。所有在查看Spring框架的源码时，有两条清晰可见的脉络：\n    * 接口层描述了容器的重要组件及组件间的协作关系\n    * 继承体系逐步实现组件的各项功能。\n* 接口层清晰地勾勒出Spring框架地高层功能，框架脉络呼之欲出。有了接口层抽象地描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同的实现，可以说Spring完善的接口层使框架的扩展性得到了很好的保证\n* 纵向继承体系的逐步发展，分步骤地实现框架地功能，这种实现方案保证了框架功能不会堆积在某些类身上，从而造成过重地代码逻辑负载，框架的复杂度被完美地分解开了。\n* Spring可以就像一个餐馆，为顾客提供各种各样的美味佳肴，那么它是怎样做出美味的饭菜呢？\n    * Spring的设计者就是餐馆的老板，统筹规划餐馆的运作\n    * 原始食材：`xml配置的bean` ，高级一点的原始食材`注解配置的bean`，加工后的食材：`Resource` `BeanDefinition` `PropertyEditor`\n    * 采购员：`ResourceLoader`，择菜员：`BeanDefinitionReader`，仓库：`BeanDefintionRegistry` ,厨师就是将准备好的食材烹饪为菜肴\n### 其他\n\n#### 在Spring也可以注入List/Map\n* 之前一直使用xml的方式进行Spring配置，对于内部元素为String的List和Map属性的注入一般为如下方式：\n```java\n<bean id = \"testBean\" class = \"com.a.b.c.TestBean\">\n    <property name = \"fieldMap\">\n        <map>\n            <entry key = \"field1\" value = \"value1\"></entry>\n            <entry key = \"field2\" value = \"value2\"></entry>\n            <entry key = \"field3\" value = \"value3\"></entry>\n        </map>\n    </property>\n    <property name = \"fieldList\">\n        <list>\n            <value>1</value>\n            <value>2</value>\n        </list>\n    </property>\n</bean>\n```\n* 如果内部元素为Bean，则将value替换为value-ref或元素即可。\n\n* 当然，我们也可以使用Spring提供的schema扩展util来实现List和Map的声明、注入：\n```java\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:util=\"http://www.springframework.org/schema/util\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n    http://www.springframework.org/schema/util\n    http://www.springframework.org/schema/util/spring-util-2.5.xsd\">\n    <util:list list-class=\"java.util.ArrayList\">\n        <value>1</value>\n        <value>2</value>\n        <value>3</value>\n    </util:list>\n    <util:map map-class=\"java.util.HashMap\">\n        <entry key=\"Key1\" value=\"1\" />\n        <entry key=\"Key2\" value=\"2\" />\n        <entry key=\"Key3\" value=\"3\" />\n    </util:map>\n</beans>\n```\n\n* 目前多用注解的方式来注入String类型的List和Map：\n\n> properties.yml\n```java\ntest.map = {key1:'value1',key2:'value2',key3:'value3'}\ntest.list = value1,value2,value3\n```\n\n> 在目标Bean中使用@Value注解进行注入：\n```java\n@Value(\"#{'${test.list}'.split(',')}\")\nprivate List<String> testList;\n@Value(\"#{${test.map}}\")\nprivate Map<String,String> testMap;\n``` \n\n\n\n\n## 总结\n\n## 参考\n* 《精通Spring+4.x++企业应用开发实战》\n* https://jinnianshilongnian.iteye.com/blog/1413846\n* http://www.cnblogs.com/xdp-gacl/p/4249939.html\n* https://blog.csdn.net/li_xiao_dai/article/details/80667246\n* https://www.cnblogs.com/xiao2/p/7706902.html\n* http://svip.iocoder.cn/Spring/IoC-intro/","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(二四)Spring生命周期之Lifecycle","url":"/2019/07/01/backend/framework/spring/analysis/Spring系列(二四)Spring生命周期之Lifecycle/","content":"## 前言\n\n* 先看一张图，有了这张图在回顾之前的章节知识就会变了很清晰了\n\n![](/images/server/spring/analysis/lifecycle.webp.jpg)\n\n## 解析\n\n### \n\n* `Lifecycle`接口，`LifeCycle`定义`Spring`容器对象的生命周期，任何`Spring`管理对象都可以实现该接口。然后，当`ApplicationContext`本身接收启动和停止信号(例如在运行时停止/重启场景)时，`Spring`容器将在容器上下文中找出所有实现了`LifeCycle`及其子类接口的类，并一一调用它们实现的类。`Spring`是通过委托给生命周期处理器`LifecycleProcessor`来实现这一点的。\n\n```java\n/**\n * A common interface defining methods for start/stop lifecycle control.\n * The typical use case for this is to control asynchronous processing.\n * <b>NOTE: This interface does not imply specific auto-startup semantics.\n * Consider implementing {@link SmartLifecycle} for that purpose.</b>\n *\n * <p>Can be implemented by both components (typically a Spring bean defined in a\n * Spring context) and containers  (typically a Spring {@link ApplicationContext}\n * itself). Containers will propagate start/stop signals to all components that\n * apply within each container, e.g. for a stop/restart scenario at runtime.\n *\n * <p>Can be used for direct invocations or for management operations via JMX.\n * In the latter case, the {@link org.springframework.jmx.export.MBeanExporter}\n * will typically be defined with an\n * {@link org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler},\n * restricting the visibility of activity-controlled components to the Lifecycle\n * interface.\n *\n * <p>Note that the Lifecycle interface is only supported on <b>top-level singleton\n * beans</b>. On any other component, the Lifecycle interface will remain undetected\n * and hence ignored. Also, note that the extended {@link SmartLifecycle} interface\n * provides integration with the application context's startup and shutdown phases.\n *\n * @author Juergen Hoeller\n * @since 2.0\n * @see SmartLifecycle\n * @see ConfigurableApplicationContext\n * @see org.springframework.jms.listener.AbstractMessageListenerContainer\n * @see org.springframework.scheduling.quartz.SchedulerFactoryBean\n */\npublic interface Lifecycle {\n\n\t/**\n\t * Start this component.\n\t * <p>Should not throw an exception if the component is already running.\n\t * <p>In the case of a container, this will propagate the start signal to all\n\t * components that apply.\n\t * @see SmartLifecycle#isAutoStartup()\n\t */\n\tvoid start();\n\n\t/**\n\t * Stop this component, typically in a synchronous fashion, such that the component is\n\t * fully stopped upon return of this method. Consider implementing {@link SmartLifecycle}\n\t * and its {@code stop(Runnable)} variant when asynchronous stop behavior is necessary.\n\t * <p>Note that this stop notification is not guaranteed to come before destruction: On\n\t * regular shutdown, {@code Lifecycle} beans will first receive a stop notification before\n\t * the general destruction callbacks are being propagated; however, on hot refresh during a\n\t * context's lifetime or on aborted refresh attempts, only destroy methods will be called.\n\t * <p>Should not throw an exception if the component isn't started yet.\n\t * <p>In the case of a container, this will propagate the stop signal to all components\n\t * that apply.\n\t * @see SmartLifecycle#stop(Runnable)\n\t * @see org.springframework.beans.factory.DisposableBean#destroy()\n\t */\n\tvoid stop();\n\n\t/**\n\t * Check whether this component is currently running.\n\t * <p>In the case of a container, this will return {@code true} only if <i>all</i>\n\t * components that apply are currently running.\n\t * @return whether the component is currently running\n\t */\n\tboolean isRunning();\n\n}\n```\n\n\n* Lifecycle 生命周期的不足\n\n* 常规的LifeCycle接口只是在容器上下文显式的调用start()/stop()方法时，才会去回调LifeCycle的实现类的start stop方法逻辑。并不意味着在上下文刷新时自动启动。\n\n##### SmartLifecycle 自动的生命周期扩展\n\n* 那么,如果Spring容器上下文没有显式的调用start和destory(或者close,stop)等方法时，我们也需要做到生命周期回调，怎么做?\n\n* 于是SmartLifecycle可以做到这一点,它继承自Lifecycle接口，新增了如下几个方法:\n\n```java\npublic interface SmartLifecycle extends Lifecycle, Phased {\n\n    /**\n      * 如果该`Lifecycle`类所在的上下文在调用`refresh`时,希望能够自己自动进行回调，则返回`true`* ,\n      * false的值表明组件打算通过显式的start()调用来启动，类似于普通的Lifecycle实现。\n     */\n    boolean isAutoStartup();\n\n    /**\n     * Indicates that a Lifecycle component must stop if it is currently running.\n     * <p>The provided callback is used by the {@link LifecycleProcessor} to support\n     * an ordered, and potentially concurrent, shutdown of all components having a\n     * common shutdown order value. The callback <b>must</b> be executed after\n     * the {@code SmartLifecycle} component does indeed stop.\n     * <p>The {@link LifecycleProcessor} will call <i>only</i> this variant of the\n     * {@code stop} method; i.e. {@link Lifecycle#stop()} will not be called for\n     * {@code SmartLifecycle} implementations unless explicitly delegated to within\n     * the implementation of this method.\n     * @see #stop()\n     * @see #getPhase()\n     */\n    void stop(Runnable callback);\n\n}\n```\n\n\n* 容器中实现了`Lifecycle`的多个类如果希望有顺序的进行回调时，那么启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在依赖关系，那么依赖方将在依赖后开始，在依赖前停止。然而，有时直接依赖关系是未知的。您可能只知道某个类型的对象应该在另一个类型的对象之前开始。在这些情况下，`SmartLifecycle`接口定义了另一个选项，即在其超接口上定义的`getPhase()`方法。\n\n\n## 总结\n\n* `Lifecycle`接口是为启动或停止生命周期,控制定义方法的通用接口。\n\n## 参考\n* https://www.jianshu.com/p/43b65ed2e166\n","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(二三)PropertySource及Environment及Profile接口分析","url":"/2019/07/01/backend/framework/spring/analysis/Spring系列(二三)PropertySource及Environment及Profile接口分析/","content":"## 前言\n* `spring.profiles.active` 和 `@Profile` 这两个我相信各位都熟悉吧，主要功能是可以实现不同环境下（开发、测试、生产）参数配置的切换。\n\n## 解析\n* `Spring` 环境 & 属性由四个部分组成：`PropertySource、PropertyResolver、Profile` 和 `Environment`。\n\n### PropertySource\n* 属性源，`key-value` 属性对抽象，用于配置数据。\n\n### PropertyResolver\n* 属性解析器，用于解析任何基础源的属性的接口\n\n### Profile\n* 剖面，只有激活的剖面的组件/配置才会注册到 `Spring` 容器，类似于 `Spring Boot` 中的 `profile` 。\n\n### Environment\n\n* `Environment` 对象的作用，是确定哪些配置文件（如果有）当前处于活动状态，以及默认情况下哪些配置文件（如果有）应处于活动状态。properties 在几乎所有应用程序中都发挥着重要作用，并且有多种来源：属性文件，JVM 系统属性，系统环境变量，JNDI，servlet 上下文参数，ad-hoc 属性对象，映射等。同时它继承 PropertyResolver 接口，所以与属性相关的 Environment 对象其主要是为用户提供方便的服务接口，用于配置属性源和从中属性源中解析属性。\n\n```java\n// Environment.java\n\npublic interface Environment extends PropertyResolver {\n    \n    // 返回此环境下激活的配置文件集\n    String[] getActiveProfiles();\n\n    // 如果未设置激活配置文件，则返回默认的激活的配置文件集\n    String[] getDefaultProfiles();\n\n    boolean acceptsProfiles(String... profiles);\n}\n```\n\n## 总结\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(二二)BeanFactoryPostProcessor接口分析","url":"/2019/07/01/backend/framework/spring/analysis/Spring系列(二二)BeanFactoryPostProcessor接口分析/","content":"## 前言\n\n* 前面我们知道`BeanPostProcessor`是`Spring` 的一个工厂钩子，使用户可以对实例化后的`Bean`初始化之际对 `Bean` 进行增强处理（前、后置处理），同样在 `Spring` 容器启动阶段，`Spring` 也提供了一种容器扩展机制：`BeanFactoryPostProcessor`，该机制作用于容器启动阶段，允许我们在容器实例化 `Bean` 之前对注册到该容器的 `BeanDefinition` 做出修改。\n\n* `BeanFactoryPostProcessor` 的机制，就相当于给了我们在 `Bean` 实例化之前最后一次修改 `BeanDefinition` 的机会，我们可以利用这个机会对 `BeanDefinition` 来进行一些额外的操作，比如更改某些 `bean` 的一些属性，给某些 `Bean` 增加一些其他的信息等等操作。\n\n## 解析\n\n### BeanFactoryPostProcessor 接口定义\n\n* `org.springframework.beans.factory.config.BeanFactoryPostProcessor` 接口，定义如下：\n\n```java\npublic interface BeanFactoryPostProcessor {\n\n\tvoid postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;\n\n}\n```\n\n* 这个方法工作于 `BeanDefinition` 加载完成之后，`Bean `实例化之前，其主要作用是对加载 `BeanDefinition` 进行修改\n\n* 有一点需要需要注意的是在 `#postProcessBeanFactory(...)` 方法中千万不能进行 `Bean` 的实例化工作，因为这样会导致 `Bean` 过早实例化，会产生严重后果\n\n* 我们始终需要注意的是 `BeanFactoryPostProcessor` 是与 `BeanDefinition` 打交道的，如果想要与 `Bean` 打交道，请使用 `BeanPostProcessor` 。\n\n* 与 `BeanPostProcessor` 一样，`BeanFactoryPostProcessor` 同样支持排序，一个容器可以同时拥有多个 `BeanFactoryPostProcessor` ，这个时候如果我们比较在乎他们的顺序的话，可以实现 `Ordered` 接口。\n\n### BeanFactoryPostProcessor 在哪里调用\n\n* 回到`org.springframework.context.support.AbstractApplicationContext#refresh`方法，关注`invokeBeanFactoryPostProcessors(beanFactory);`方法，见名知其意执行`BeanFactoryPostProcessor`方法\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        // 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证\n        prepareRefresh();\n\n        // Tell the subclass to refresh the internal bean factory.\n        // 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n        // Prepare the bean factory for use in this context.\n        // 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开\n        // 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持\n        prepareBeanFactory(beanFactory);\n\n        try {\n            // Allows post-processing of the bean factory in context subclasses.\n            // 子类覆盖方法做额外的处理\n            postProcessBeanFactory(beanFactory);\n\n\n            // Invoke factory processors registered as beans in the context.\n            // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，\n            // 并调用其postProcessBeanFactory接口方法\n            invokeBeanFactoryPostProcessors(beanFactory);\n            \n            ...\n```\n\n* 进入`invokeBeanFactoryPostProcessors(beanFactory);`方法，这里出现了一个新的委托类`PostProcessorRegistrationDelegate` ，委托执行`post processors`任务的工具类\n\n```java\n/**\n * 实例化BeanFactoryPostProcessor实例及执行其接口方法\n *\n * Instantiate and invoke all registered BeanFactoryPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before singleton instantiation.\n */\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n\n    // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n    // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n    if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n    }\n}\n```\n\n* 进入`PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())`方法\n\n```java\n/**\n * Invoke the given BeanFactoryPostProcessor beans.\n */\nprivate static void invokeBeanFactoryPostProcessors(\n        Collection<? extends BeanFactoryPostProcessor> postProcessors, ConfigurableListableBeanFactory beanFactory) {\n\n    for (BeanFactoryPostProcessor postProcessor : postProcessors) {\n        postProcessor.postProcessBeanFactory(beanFactory);\n    }\n}\n```\n\n\n### BeanFactoryPostProcessor 子类\n\n##### PropertyPlaceholderConfigurer \n* 允许我们在 `XML` 配置文件中使用占位符并将这些占位符所代表的资源单独配置到简单的 `properties` 文件中来加载\n\n\n## 总结\n\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn\n* https://blog.csdn.net/andy_zhang2007/article/details/78530137","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(二一)BeanPostProcessor接口分析","url":"/2019/07/01/backend/framework/spring/analysis/Spring系列(二一)BeanPostProcessor接口分析/","content":"## 前言\n\n* `BeanPostProcessor`接口\n\n```java\npublic interface BeanPostProcessor {\n\n\tObject postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n\tObject postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n}\n```\n\n* `BeanPostProcessor` 可以理解为是 `Spring` 的一个工厂钩子（其实 `Spring` 提供一系列的钩子，如 `Aware 、InitializingBean、DisposableBean）`，它是 `Spring` 提供的对象实例化阶段强有力的扩展点，允许 `Spring` 在实例化 `bean` 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如 `AOP`）。\n\n* `#postProcessBeforeInitialization(Object bean, String beanName)` 和 `#postProcessAfterInitialization(Object bean, String beanName)` 两个方法，都接收一个 `Object` 类型的 `bean` ，一个 `String` 类型的 `beanName` ，其中` bean` 是已经实例化了的 `instanceBean` ，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 `bean` 的前后置处理器，他们应用 `#invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) `方法的前后。如下图:\n\n![](/images/server/spring/analysis/201808231001.png)\n\n## 解析 \n\n\n### BeanPostProcessor接口方法调用\n\n* 接口的两个方法是哪里调用了呢，又回到回到`doCreateBean(...)` 方法，这个方法主要用于完成 `bean` 的创建和初始化工作，我们可以将其分为一下几个过程\n    * `createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)` 方法，实例化 `bean` 。\n    * `populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)` 方法，进行属性填充。\n    * `initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)` 方法，初始化 `Bean` 。\n\n* 还是关注`initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)` 方法，从下面的代码关注重点1及重点2两行，可以看到中间就夹了个`invokeInitMethods(beanName, wrappedBean, mbd);`方法，这个方法用于初始化`bean`，也就是用于激活用户自定义的初始化方法\n    * 进入`invokeInitMethods(beanName, wrappedBean, mbd);`方法，可以看到下面是检测当前 `bean` 对象是否实现了 `InitializingBean`接口。如果是，则会调用其 `#afterPropertiesSet()` 方法，进一步调整 `bean` 实例对象的状态。\n    ```java\n\tprotected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)\n\t\t\tthrows Throwable {\n\t\t// 检测当前 bean 对象是否实现了 InitializingBean 接口。如果是，则会调用其 #afterPropertiesSet() 方法，进一步调整 bean 实例对象的状态。\n\t\tboolean isInitializingBean = (bean instanceof InitializingBean);\n\t\tif (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\");\n\t\t\t}\n\t\t\tif (System.getSecurityManager() != null) {\n\t\t\t\ttry {\n\t\t\t\t\t// 调用afterPropertiesSet方法\n\t\t\t\t\tAccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object run() throws Exception {\n\t\t\t\t\t\t\t((InitializingBean) bean).afterPropertiesSet();\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, getAccessControlContext());\n\t\t\t\t}\n\t\t\t\tcatch (PrivilegedActionException pae) {\n\t\t\t\t\tthrow pae.getException();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// 属性初始化的处理\n\t\t\t\t((InitializingBean) bean).afterPropertiesSet();\n\t\t\t}\n\t\t}\n\n\t\tif (mbd != null) {\n\t\t\tString initMethodName = mbd.getInitMethodName();\n\t\t\tif (initMethodName != null && !(isInitializingBean && \"afterPropertiesSet\".equals(initMethodName)) &&\n\t\t\t\t\t!mbd.isExternallyManagedInitMethod(initMethodName)) {\n\t\t\t\t// 调用自定义初始化方法\n\t\t\t\tinvokeCustomInitMethod(beanName, bean, mbd);\n\t\t\t}\n\t\t}\n\t}\n    ```\n    * 然后，再检查是否也指定了 `init-method`，如果指定了则通过反射机制调用指定的 `init-method` 方法。\n        * 但是如果真的让我们的业务对象来实现这个`InitializingBean`接口就显得不是那么的友好了，`Spring` 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 `Spring` 容器具有侵入性了。所以 Spring 还提供了另外一种实现的方式：`init-method` 方法\n        * 使用``init-method``完全可以达到和 `InitializingBean` 一样的效果，而且在代码中我们没有看到丝毫 `Spring` 侵入的现象。所以通过 `init-method` 我们可以使用业务对象中定义的任何方法来实现 `bean` 实例对象的初始化定制化，而不再受制于 `InitializingBean的 #afterPropertiesSet()` 方法。同时我们可以使用 `<beans>` 标签的 `default-init-method` 属性来统一指定初始化方法，这样就省了需要在每个 `<bean>` 标签中都设置 `init-method` 这样的繁琐工作了\n\n```java\n\tprotected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n\t\tif (System.getSecurityManager() != null) {\n\t\t\tAccessController.doPrivileged(new PrivilegedAction<Object>() {\n\t\t\t\t@Override\n\t\t\t\tpublic Object run() {\n\t\t\t\t\tinvokeAwareMethods(beanName, bean);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}, getAccessControlContext());\n\t\t}\n\t\telse {\n\t\t\t// 对特殊的bean处理 Aware、BeanClassLoaderAware、BeanFactoryAware\n\t\t\tinvokeAwareMethods(beanName, bean);\n\t\t}\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\t// 重点1：BeanPostProcessor前置处理\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\t//  激活用户自定义的init方法 1、InitializingBean接口afterPropertiesSet方法 2、bean 定义的init-method=\"\"方法\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null),\n\t\t\t\t\tbeanName, \"Invocation of init method failed\", ex);\n\t\t}\n\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\t// 重点2：BeanPostProcessor后置处理\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\t\treturn wrappedBean;\n\t}\n```\n\n* 重点1：BeanPostProcessor前置处理 `wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);`\n\n```java\n@Override\npublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n        throws BeansException {\n\n    Object result = existingBean;\n    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n        result = beanProcessor.postProcessBeforeInitialization(result, beanName);\n        if (result == null) {\n            return result;\n        }\n    }\n    return result;\n}\n```\n\n* 重点2：BeanPostProcessor后置处理 `wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);`\n\n```java\n@Override\npublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n        throws BeansException {\n\n    Object result = existingBean;\n    // 实现 BeanPostProcessor 接口用户可以根据自己的业务需求进行响应的处理\n    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n        result = beanProcessor.postProcessAfterInitialization(result, beanName);\n        if (result == null) {\n            return result;\n        }\n    }\n    return result;\n}\n```\n\n### BeanPostProcessor自动检测并注册\n\n* `#getBeanPostProcessors()` 方法，返回的是 `BeanPostProcessor` 集合，该集合里面存放就是我们自定义的 `BeanPostProcessor`\n\n* 如果该集合中存在元素则调用相应的方法，否则就直接返回 `bean` 了。这也是为什么使用 `BeanFactory` 容器是无法输出自定义 `BeanPostProcessor` 里面的内容，因为在 `BeanFactory#getBean(...)` 方法的过程中根本就没有将我们自定义的 `BeanPostProcessor` 注入进来，所以要想 `BeanFactory` 容器 的 `BeanPostProcessor` 生效我们必须手动调用 `#addBeanPostProcessor(BeanPostProcessor, beanPostProcessor)` 方法，将定义的 `BeanPostProcessor` 注册到相应的 `BeanFactory` 中。但是 `ApplicationContext` 不需要手动，因为 `ApplicationContext` 会自动检测并完成注册。 \n\n* `ApplicationContext` 实现自动注册的原因，在于我们构造一个 `ApplicationContext` 实例对象的时候会调用 `#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory)` 方法，将检测到的 `BeanPostProcessor` 注入到 `ApplicationContext` 容器中，同时应用到该容器创建的 `bean` 中。代码如下：\n\n```java\n\t@Override\n\tpublic void refresh() throws BeansException, IllegalStateException {\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\t// Prepare this context for refreshing.\n\t\t\t// 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证\n\t\t\tprepareRefresh();\n\n\t\t\t// Tell the subclass to refresh the internal bean factory.\n\t\t\t// 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t\t\t// Prepare the bean factory for use in this context.\n\t\t\t// 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开\n\t\t\t// 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持\n\t\t\tprepareBeanFactory(beanFactory);\n\n\t\t\ttry {\n\t\t\t\t// Allows post-processing of the bean factory in context subclasses.\n\t\t\t\t// 子类覆盖方法做额外的处理\n\t\t\t\tpostProcessBeanFactory(beanFactory);\n\n\n\t\t\t\t// Invoke factory processors registered as beans in the context.\n\t\t\t\t// 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，\n\t\t\t\t// 并调用其postProcessBeanFactory接口方法\n\t\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t\t\t// Register bean processors that intercept bean creation.\n\t\t\t\t// 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean，\n\t\t\t\t// 并将它们注册到容器Bean后处理器的注册表中，这里只是注册，真正的调用在getBean时候\n\t\t\t\tregisterBeanPostProcessors(beanFactory);\n\t\t\t\t\n\t\t\t\t...\n```\n\n* 进入`registerBeanPostProcessors(beanFactory);`方法\n\n```java\n/**\n * 实例化并调用已经注入的 BeanPostProcessor 必须在应用中 bean 实例化之前调用\n * Instantiate and invoke all registered BeanPostProcessor beans,\n * respecting explicit order if given.\n * <p>Must be called before any instantiation of application beans.\n */\nprotected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n}\n\npublic static void registerBeanPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n    // 获取所有的 BeanPostProcessor 的 beanName\n    // 这些 beanName 都已经全部加载到容器中去，但是没有实例化\n    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n    // Register BeanPostProcessorChecker that logs an info message when\n    // a bean is created during BeanPostProcessor instantiation, i.e. when\n    // a bean is not eligible for getting processed by all BeanPostProcessors.\n    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n    // Separate between BeanPostProcessors that implement PriorityOrdered,\n    // Ordered, and the rest.\n    List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n    List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();\n    List<String> orderedPostProcessorNames = new ArrayList<String>();\n    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();\n    for (String ppName : postProcessorNames) {\n        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n            priorityOrderedPostProcessors.add(pp);\n            if (pp instanceof MergedBeanDefinitionPostProcessor) {\n                internalPostProcessors.add(pp);\n            }\n        }\n        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n            orderedPostProcessorNames.add(ppName);\n        }\n        else {\n            nonOrderedPostProcessorNames.add(ppName);\n        }\n    }\n\n    // First, register the BeanPostProcessors that implement PriorityOrdered.\n    // 第一步，注册所有实现了 PriorityOrdered 的 BeanPostProcessor\n    // 先排序\n    sortPostProcessors(beanFactory, priorityOrderedPostProcessors);\n    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n    // Next, register the BeanPostProcessors that implement Ordered.\n    // 第二步，注册所有实现了 Ordered 的 BeanPostProcessor\n    List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();\n    for (String ppName : orderedPostProcessorNames) {\n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n        orderedPostProcessors.add(pp);\n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n            internalPostProcessors.add(pp);\n        }\n    }\n    sortPostProcessors(beanFactory, orderedPostProcessors);\n    // 后注册\n    registerBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n    // Now, register all regular BeanPostProcessors.\n    // 第三步注册所有无序的 BeanPostProcessor\n    List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();\n    for (String ppName : nonOrderedPostProcessorNames) {\n        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n        nonOrderedPostProcessors.add(pp);\n        if (pp instanceof MergedBeanDefinitionPostProcessor) {\n            internalPostProcessors.add(pp);\n        }\n    }\n    // 注册，无需排序\n    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n    // Finally, re-register all internal BeanPostProcessors.\n    // 最后，注册所有的 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor\n    sortPostProcessors(beanFactory, internalPostProcessors);\n    registerBeanPostProcessors(beanFactory, internalPostProcessors);\n\n    // Re-register post-processor for detecting inner beans as ApplicationListeners,\n    // moving it to the end of the processor chain (for picking up proxies etc).\n    // 加入ApplicationListenerDetector（探测器）\n    // 重新注册 BeanPostProcessor 以检测内部 bean，因为 ApplicationListeners 将其移动到处理器链的末尾\n    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n}\n```\n\n* 注册代码如下，可以看到是存放在`AbstractBeanFactory`类的`private final List<BeanPostProcessor> beanPostProcessors`属性中\n\n```java\n/**\n * Register the given BeanPostProcessor beans.\n */\nprivate static void registerBeanPostProcessors(\n        ConfigurableListableBeanFactory beanFactory, List<BeanPostProcessor> postProcessors) {\n\n    for (BeanPostProcessor postProcessor : postProcessors) {\n        beanFactory.addBeanPostProcessor(postProcessor);\n    }\n}\n\n@Override\npublic void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {\n    Assert.notNull(beanPostProcessor, \"BeanPostProcessor must not be null\");\n    this.beanPostProcessors.remove(beanPostProcessor);\n    this.beanPostProcessors.add(beanPostProcessor);\n    if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n        this.hasInstantiationAwareBeanPostProcessors = true;\n    }\n    if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {\n        this.hasDestructionAwareBeanPostProcessors = true;\n    }\n}\n```\n\n\n## 总结\n* `Spring`对对象的可扩展性主要就是依靠`BeanPostProcessor`来完成的，使用`BeanPostProcessor`可以对实例化后的`bean`为所欲为，添加自己的逻辑，不过一般项目开发中很少用到这个类\n* `BeanFactory` 和 `ApplicationContext` 对 `BeanPostProcessor` 的处理不同，`ApplicationContext` 会自动检测所有实现了 `BeanPostProcessor` 接口的 bean，并完成注册，但是使用 `BeanFactory` 容器时则需要手动调用 `AbstractBeanFactory#addBeanPostProcessor(BeanPostProcessor beanPostProcessor)` 方法来完成注册\n\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(二十)Aware接口分析","url":"/2019/07/01/backend/framework/spring/analysis/Spring系列(二十)Aware接口分析/","content":"## 前言\n* 平常开发中会经常用到下面这个工具类，用于获取对应的`ApplicationContext`容器，然后再根据`ApplicationContext`获取对应的`Bean`，那么`ApplicationContext applicationContext`是怎么被注入进去的呢？\n\n```java\n@Component\npublic class SpringContextUtils implements ApplicationContextAware, DisposableBean{\n\n    private static ApplicationContext applicationContext;\n\n    public static ApplicationContext getApplicationContext() {\n        return applicationContext;\n    }\n\n    public static <T> T getBean(Class<T> requiredType) {\n        return applicationContext.getBean(requiredType);\n    }\n\n    public static Object getBean(String beanName) {\n        return applicationContext.getBean(beanName);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        SpringContextUtils.applicationContext = applicationContext;\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        applicationContext=null;\n    }\n}\n\n```\n\n* 观察上面的代码可以发现此类是被 `@Component`修饰的`Bean`，此外该类还实现了`ApplicationContextAware`接口，此接口就一个方法，这个方法的作用是获取`ApplicationContext`容器，下面我们来看看`Spring`是怎样实现此功能的\n\n```java\npublic interface ApplicationContextAware extends Aware {\n    \n\tvoid setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n\n}\n```\n\n## 解析\n\n### Aware接口\n\n* `org.springframework.beans.factory.Aware` 接口，定义如下：\n\n```java\n/**\n *\n * 标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。\n *\n * Marker superinterface indicating that a bean is eligible to be\n * notified by the Spring container of a particular framework object\n * through a callback-style method. Actual method signature is\n * determined by individual subinterfaces, but should typically\n * consist of just one void-returning method that accepts a single\n * argument.\n *\n * <p>Note that merely implementing {@link Aware} provides no default\n * functionality. Rather, processing must be done explicitly, for example\n * in a {@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor}.\n * Refer to {@link org.springframework.context.support.ApplicationContextAwareProcessor}\n * and {@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory}\n * for examples of processing {@code *Aware} interface callbacks.\n *\n * @author Chris Beams\n * @since 3.1\n */\npublic interface Aware {\n\n}\n```\n\n* `Aware` 接口为 `Spring` 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 `bean` 是具有被 `Spring` 容器通知的能力，通知的方式是采用回调的方式。\n\n* `Aware` 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接收单参数的 `set` 方法，该 `set` 方法的命名方式为 `set` + 去掉接口名中的 `Aware` 后缀，即 `XxxAware` 接口，则方法定义为 `setXxx()`，例如 `BeanNameAware（setBeanName），ApplicationContextAware（setApplicationContext）`。\n\n### Aware接口是如何发挥作用\n\n `Aware` 的子接口需要提供一个 `setXxx` 方法，我们知道 `set` 是设置属性值的方法，即 `Aware` 类接口的 `setXxx` 方法其实就是设置 `xxx` 属性值的。 `Aware` 的含义是感知的、感应的，那么在 Spring 容器中是如何实现感知并设置属性值得呢？我们可以从初始化 `bean` 中的激活 `Aware` 的方法 `#invokeAwareMethods(final String beanName, final Object bean)` 中看到一点点，代码如下：\n\n* 回顾`doCreateBean(...)` 方法，这个方法主要用于完成 `bean` 的创建和初始化工作，我们可以将其分为一下几个过程\n    * `createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)` 方法，实例化 `bean` 。\n    * `populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)` 方法，进行属性填充。\n    * `initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)` 方法，初始化 `Bean` 。\n* `Aware`接口是怎样发挥作用的呢，进入`initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)` 方法，关注`invokeAwareMethods(beanName, bean);`方法，见名知其意\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {\n    if (System.getSecurityManager() != null) {\n        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                invokeAwareMethods(beanName, bean);\n                return null;\n            }\n        }, getAccessControlContext());\n    }\n    else {\n        // 对特殊的bean处理 Aware、BeanClassLoaderAware、BeanFactoryAware\n        invokeAwareMethods(beanName, bean);\n    }\n    Object wrappedBean = bean;\n    if (mbd == null || !mbd.isSynthetic()) {\n        // 应用后处理器\n        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n    }\n```\n\n* 进入`invokeAwareMethods(beanName, bean);` 可以看到实现逻辑十分简单，首先判断该`bean`是否实现了`Aware`，然后就是根据不同的`Aware`子类调用不同的方法\n\n```java\n/**\n * 实现了这些Aware接口的bean被初始化之后，可以取得一些相对应的资源\n * @param beanName\n * @param bean\n */\nprivate void invokeAwareMethods(final String beanName, final Object bean) {\n    // 下面都是直接调用接口方法\n    if (bean instanceof Aware) {\n        if (bean instanceof BeanNameAware) {\n            ((BeanNameAware) bean).setBeanName(beanName);\n        }\n        if (bean instanceof BeanClassLoaderAware) {\n            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());\n        }\n        if (bean instanceof BeanFactoryAware) {\n            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n        }\n    }\n}\n```\n\n* 上面的只有三种`Aware`并没有我们的`ApplicationContextAware`，关注`wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);`方法，从这里可以找到答案，下面代码又出现了熟悉的`BeanPostProcessor`，调用了`bean`初始化之前的钩子方法\n\n```java\n@Override\npublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n        throws BeansException {\n\n    Object result = existingBean;\n    for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n        result = beanProcessor.postProcessBeforeInitialization(result, beanName);\n        if (result == null) {\n            return result;\n        }\n    }\n    return result;\n}\n```\n\n* 进入`org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization`方法，可以看到主要是调用了`invokeAwareInterfaces(bean);`方法\n\n```java\n@Override\npublic Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {\n    AccessControlContext acc = null;\n\n    if (System.getSecurityManager() != null &&\n            (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||\n                    bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||\n                    bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {\n        acc = this.applicationContext.getBeanFactory().getAccessControlContext();\n    }\n\n    if (acc != null) {\n        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n            @Override\n            public Object run() {\n                invokeAwareInterfaces(bean);\n                return null;\n            }\n        }, acc);\n    }\n    else {\n        invokeAwareInterfaces(bean);\n    }\n\n    return bean;\n}\n\n```\n\n* 进入`invokeAwareInterfaces(bean);`方法，这里就看到了`Spring`对其进行了设置值` ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);`\n\n```java\nprivate void invokeAwareInterfaces(Object bean) {\n    if (bean instanceof Aware) {\n        if (bean instanceof EnvironmentAware) {\n            ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n        }\n        if (bean instanceof EmbeddedValueResolverAware) {\n            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);\n        }\n        if (bean instanceof ResourceLoaderAware) {\n            ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);\n        }\n        if (bean instanceof ApplicationEventPublisherAware) {\n            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);\n        }\n        if (bean instanceof MessageSourceAware) {\n            ((MessageSourceAware) bean).setMessageSource(this.applicationContext);\n        }\n        if (bean instanceof ApplicationContextAware) {\n            ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n        }\n    }\n}\n```\n\n### Aware主要子类\n* ApplicationContextAware: 加载ApplicationContext\n* LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ\n* BeanClassLoaderAware：加载Spring Bean的类加载器\n* BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI\n* ResourceLoaderAware：底层访问资源的加载器\n* BeanFactoryAware：声明BeanFactory\n* PortletConfigAware：PortletConfig\n* PortletContextAware：PortletContext\n* ServletConfigAware：ServletConfig\n* ServletContextAware：ServletContext\n* MessageSourceAware：国际化\n* ApplicationEventPublisherAware：应用事件\n* NotificationPublisherAware：JMX通知\n* BeanNameAware：声明Spring Bean的名字\n\n## 总结\n* `Aware` 真正的含义是感知，其实是 `Spring` 容器在初始化主动检测当前 `bean` 是否实现了 `Aware` 接口，如果实现了则回调其 `set` 方法将相应的参数设置给该 `bean` ，这个时候该 `bea`n 就从 `Spring` 容器中取得相应的资源。\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(十一)加载Bean之AutowiredAnnotationBeanPostProcessor@Autowired注解原理","url":"/2019/06/19/backend/framework/spring/analysis/Spring系列(十一)加载Bean之AutowiredAnnotationBeanPostProcessor@Autowired注解原理/","content":"## 前言\n\n* `@Autowired`是一个用来执行依赖注入的注解。每当一个`Spring`管理的`bean`发现有这个注解时候，它会直接注入相应的另一个`Spring`管理的`bean`。那么具体的解析是怎么实现的呢，`AutowiredAnnotationBeanPostProcessor`这个类就是做这个事情的\n\n* 类继承关系\n\n![](/images/server/spring/analysis/AutowiredAnnotationBeanPostProcessor.png)\n\n* 类成员\n\n```java\npublic class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter\n\t\timplements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware {\n\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final Set<Class<? extends Annotation>> autowiredAnnotationTypes =\n\t\t\tnew LinkedHashSet<Class<? extends Annotation>>();\n\n\tprivate String requiredParameterName = \"required\";\n\n\tprivate boolean requiredParameterValue = true;\n\n\tprivate int order = Ordered.LOWEST_PRECEDENCE - 2;\n\n\tprivate ConfigurableListableBeanFactory beanFactory;\n\n\tprivate final Set<String> lookupMethodsChecked =\n\t\t\tCollections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(256));\n\n\tprivate final Map<Class<?>, Constructor<?>[]> candidateConstructorsCache =\n\t\t\tnew ConcurrentHashMap<Class<?>, Constructor<?>[]>(256);\n\n\tprivate final Map<String, InjectionMetadata> injectionMetadataCache =\n\t\t\tnew ConcurrentHashMap<String, InjectionMetadata>(256);\n\n\n\t/**\n\t * 构造函数中定义要处理的注解\n\t *\n\t * Create a new AutowiredAnnotationBeanPostProcessor\n\t * for Spring's standard {@link Autowired} annotation.\n\t * <p>Also supports JSR-330's {@link javax.inject.Inject} annotation, if available.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic AutowiredAnnotationBeanPostProcessor() {\n\t\tthis.autowiredAnnotationTypes.add(Autowired.class);\n\t\tthis.autowiredAnnotationTypes.add(Value.class);\n\t\ttry {\n\t\t\tthis.autowiredAnnotationTypes.add((Class<? extends Annotation>)\n\t\t\t\t\tClassUtils.forName(\"javax.inject.Inject\", AutowiredAnnotationBeanPostProcessor.class.getClassLoader()));\n\t\t\tlogger.info(\"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-330 API not available - simply skip.\n\t\t}\n\t}\n```\n\n\n## 解析\n\n### 解析类是怎么注册的\n\n* 第五章有介绍`ComponentScanBeanDefinitionParser`是`<context:component-scan base-package = \"org.springiframe.*\"/>`这个标签的实现类，我们的`AutowiredAnnotationBeanPostProcessor`这个类就是在这里注册的，进入`registerComponents(parserContext.getReaderContext(), beanDefinitions, element);`方法，关注`AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)`方法\n\n```java\n/**\n * Register all relevant annotation post processors in the given registry.\n * @param registry the registry to operate on\n * @param source the configuration source element (already extracted)\n * that this registration was triggered from. May be {@code null}.\n * @return a Set of BeanDefinitionHolders, containing all bean definitions\n * that have actually been registered by this call\n */\npublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n        BeanDefinitionRegistry registry, Object source) {\n\n    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n    if (beanFactory != null) {\n        if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n        }\n        if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n            beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n        }\n    }\n\n    Set<BeanDefinitionHolder> beanDefs = new LinkedHashSet<BeanDefinitionHolder>(4);\n\n    // 注册@Configuration`解析类\n    if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // 注册`@Autowired/@Value`解析类\n    if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // 注册`@Required`解析类\n    if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n    // 注册@PostConstruct @PreDestroy @Resource 及JSR-250支持注解解析类\n    if (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n    // 注册JPA注解解析类\n    if (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition();\n        try {\n            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n                    AnnotationConfigUtils.class.getClassLoader()));\n        }\n        catch (ClassNotFoundException ex) {\n            throw new IllegalStateException(\n                    \"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n        }\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n    }\n\n    if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n    }\n    if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n        RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n        def.setSource(source);\n        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n    }\n\n    return beanDefs;\n}\n```\n\n### 解析类是在哪里调用的\n\n* 上一章节介绍了`populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)`方法，这个方法是进行属性填充，这里是完成依赖注入的关键\n\n```java\n...\n\n// 后处理器已经初始化\nboolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n// 需要依赖检查\nboolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\nif (hasInstAwareBpps || needsDepCheck) {\n    PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n    if (hasInstAwareBpps) {\n        // PropertyValue值设置后，Spring会调用getBeanPostProcessor方法遍历Bean工厂中注册的所有BeanPostProcessor\n        // 其中就包括AutowiredAnnotationBeanPostProcessor @Autowired注解就是在这里完成的注入\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                // 对所有需要依赖检查的属性进行后处理\n                pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                if (pvs == null) {\n                    return;\n                }\n            }\n        }\n    }\n    if (needsDepCheck) {\n        // 依赖检查。对应depends-on属性，3.0已废弃\n        checkDependencies(beanName, mbd, filteredPds, pvs);\n    }\n}\n\n...\n```\n\n* 可以看到上面是循环`BeanPostProcessor`，然后判断是否是`InstantiationAwareBeanPostProcessor`实例，如果是的话就执行`postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)`方法，这里是调用了我们上面注册的`AutowiredAnnotationBeanPostProcessor`并对其接口方法进行了实现\n    * 先看`InstantiationAwareBeanPostProcessor`接口，这个接口主要作用在于目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置\n    ```java\n    public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {  \n        /**\n         * 是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。\n         * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。\n         * 如果该方法的返回值代替原本该生成的目标对象，\n         */\n        Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException;\n    \n        /**\n         * 在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置都是null\n         */\n        boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;\n    \n        /**\n         * 对属性值进行修改(这个时候属性值还未被设置，但是我们可以修改原本该设置进去的属性值)。\n         */\n        PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException;\n    }\n    ```\n\n### 解析类实现依赖注入\n\n* 进入`postProcessPropertyValues`方法，可以看到先获取了`InjectionMetadata`对象，`InjectionMetadata`对象是注入元数据,包含了目标`Bean`的`Class`对象,和注入元素(`InjectionElement`)集合，先是获取这个`bean`哪些属性及方法需要依赖注入，然后封装成`InjectionMetadata`对象，最后执行了其对象的`metadata.inject(bean, beanName, pvs);`方法完成依赖注入\n    * `postProcessPropertyValues`方法\n    ```java\n    @Override\n    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {\n    \n        // 调用下面的方法获取InjectionMetadata对象（其实InjectionElement集合）\n        InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n        try {\n            // 调用注入方法\n            metadata.inject(bean, beanName, pvs);\n        }\n        catch (BeanCreationException ex) {\n            throw ex;\n        }\n        catch (Throwable ex) {\n            throw new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n        }\n        return pvs;\n    }\n    ```\n    * `InjectionMetadata`类 \n    ```java\n    public class InjectionMetadata {\n    \n        private static final Log logger = LogFactory.getLog(InjectionMetadata.class);\n    \n        private final Class<?> targetClass;\n    \n        private final Collection<InjectedElement> injectedElements;\n    \n        private volatile Set<InjectedElement> checkedElements;\n    \n    \n        public InjectionMetadata(Class<?> targetClass, Collection<InjectedElement> elements) {\n            this.targetClass = targetClass;\n            this.injectedElements = elements;\n        }\n    \n        ...\n    \n        public void inject(Object target, String beanName, PropertyValues pvs) throws Throwable {\n            Collection<InjectedElement> elementsToIterate =\n                    (this.checkedElements != null ? this.checkedElements : this.injectedElements);\n            if (!elementsToIterate.isEmpty()) {\n                boolean debug = logger.isDebugEnabled();\n                for (InjectedElement element : elementsToIterate) {\n                    if (debug) {\n                        logger.debug(\"Processing injected element of bean '\" + beanName + \"': \" + element);\n                    }\n                    // 依次循环注入\n                    element.inject(target, beanName, pvs);\n                }\n            }\n        }\n        \n        public static abstract class InjectedElement {\n    \n            protected final Member member;\n    \n            protected final boolean isField;\n    \n            protected final PropertyDescriptor pd;\n    \n            protected volatile Boolean skip;\n            \n        ...\n    ```\n#### 1、获取这个`bean`哪些属性及方法需要依赖注入\n* 进入`InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);`方法，因为需要注入的属性基本上都是不变的，所以`Spring`在这里做了一下缓存\n\n```java\n/**\n * 获取注入元数据信息，这里做了一下缓存\n *\n * @param beanName\n * @param clazz\n * @param pvs\n * @return\n */\nprivate InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, PropertyValues pvs) {\n    // Fall back to class name as cache key, for backwards compatibility with custom callers.\n    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());\n    // Quick check on the concurrent map first, with minimal locking. 先找缓存\n    InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);\n    if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n        synchronized (this.injectionMetadataCache) {\n            metadata = this.injectionMetadataCache.get(cacheKey);\n            if (InjectionMetadata.needsRefresh(metadata, clazz)) {\n                if (metadata != null) {\n                    metadata.clear(pvs);\n                }\n                try {\n                    // 缓存没有，调用buildAutowiringMetadata方法构建\n                    metadata = buildAutowiringMetadata(clazz);\n                    this.injectionMetadataCache.put(cacheKey, metadata);\n                }\n                catch (NoClassDefFoundError err) {\n                    throw new IllegalStateException(\"Failed to introspect bean class [\" + clazz.getName() +\n                            \"] for autowiring metadata: could not find class that it depends on\", err);\n                }\n            }\n        }\n    }\n    return metadata;\n}\n```\n\n* 如果缓存没有则调用`buildAutowiringMetadata(clazz)`方法进行构建，这个方法是找到哪些属性需要被自动装配，也就是查找被`@Autowired、@Value、@Inject`注解标记的元素，并封装为`InjectionMetadata`，可以看到是循环了这个类的`Field`及`Method`\n\n```java\n/**\n * 找到哪些属性需要被自动装配，也就是查找被@Autowired、@Value、@Inject注解标记的元素，封装为InjectionMetadata\n * @param clazz\n * @return\n */\npublic InjectionMetadata buildAutowiringMetadata(final Class<?> clazz) {\n    // 存放哪些属性需要被自动装配\n    LinkedList<InjectionMetadata.InjectedElement> elements = new LinkedList<InjectionMetadata.InjectedElement>();\n    Class<?> targetClass = clazz;\n\n    do {\n        // 这里是循环，因为要考虑到父类的字段及方法\n        final LinkedList<InjectionMetadata.InjectedElement> currElements = new LinkedList<InjectionMetadata.InjectedElement>();\n        ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() {\n            @Override\n            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {\n                // 遍历每一个field，找到被@Autowired、@Value、@Inject标识的字段\n                AnnotationAttributes ann = findAutowiredAnnotation(field);\n                if (ann != null) {\n                    if (Modifier.isStatic(field.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"Autowired annotation is not supported on static fields: \" + field);\n                        }\n                        return;\n                    }\n                    boolean required = determineRequiredStatus(ann);\n                    // 创建AutowiredFieldElement\n                    currElements.add(new AutowiredFieldElement(field, required));\n                }\n            }\n        });\n\n        ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() {\n            @Override\n            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\n                // 遍历所有的方法\n                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);\n                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {\n                    return;\n                }\n                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);\n                if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {\n                    if (Modifier.isStatic(method.getModifiers())) {\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"Autowired annotation is not supported on static methods: \" + method);\n                        }\n                        return;\n                    }\n                    if (method.getParameterTypes().length == 0) {\n                        if (logger.isWarnEnabled()) {\n                            logger.warn(\"Autowired annotation should only be used on methods with parameters: \" +\n                                    method);\n                        }\n                    }\n                    boolean required = determineRequiredStatus(ann);\n                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);\n                    // 创建AutowiredFieldElement\n                    currElements.add(new AutowiredMethodElement(method, required, pd));\n                }\n            }\n        });\n\n        elements.addAll(0, currElements);\n        targetClass = targetClass.getSuperclass();\n    }\n    while (targetClass != null && targetClass != Object.class);\n    // 将InjectedElement集合添加到新建的InjectionMetadata\n    return new InjectionMetadata(clazz, elements);\n}\n```\n\n* 关注`AnnotationAttributes ann = findAutowiredAnnotation(field\\bridgedMethod);`方法，可以看到这里是对`this.autowiredAnnotationTypes`进行遍历匹配，如果符合就返回\n\n```java\nprivate AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) {\n    if (ao.getAnnotations().length > 0) {\n        for (Class<? extends Annotation> type : this.autowiredAnnotationTypes) {\n            AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type);\n            if (attributes != null) {\n                return attributes;\n            }\n        }\n    }\n    return null;\n}\n```\n\n* `this.autowiredAnnotationTypes` 属性就是构造函数构建的存放`Set<Class<? extends Annotation>> autowiredAnnotationTypes`集合 ，默认有`@Autowired、@Value、@Inject`注解的\n\n![](/images/server/spring/analysis/aabpp.jpg)\n\n\n#### 2、执行依赖注入\n\n* 上面的步骤以及获取了这个类哪些属性需要注入，现在就是需要完成依赖注入的操作\n\n```java\n@Override\npublic PropertyValues postProcessPropertyValues(\n        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {\n\n    // 调用下面的方法获取InjectionMetadata对象（其实InjectionElement集合）\n    InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);\n    try {\n        // 调用注入方法\n        metadata.inject(bean, beanName, pvs);\n    }\n    catch (BeanCreationException ex) {\n        throw ex;\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex);\n    }\n    return pvs;\n}\n\npublic void inject(Object target, String beanName, PropertyValues pvs) throws Throwable {\n    Collection<InjectedElement> elementsToIterate =\n            (this.checkedElements != null ? this.checkedElements : this.injectedElements);\n    if (!elementsToIterate.isEmpty()) {\n        boolean debug = logger.isDebugEnabled();\n        for (InjectedElement element : elementsToIterate) {\n            if (debug) {\n                logger.debug(\"Processing injected element of bean '\" + beanName + \"': \" + element);\n            }\n            // 依次循环注入\n            element.inject(target, beanName, pvs);\n        }\n    }\n}\n```\n\n* 关注`element.inject(target, beanName, pvs)`方法，可以看到是循环`Collection<InjectedElement> injectedElements`依次对属性进行注入，见下图可以看到`Field`及`Method`有不同的注入实现类\n![](/images/server/spring/analysis/injectedElement.jpg)\n\n* 注入实现\n    * `AutowiredFieldElement#inject()` 可以看到 `ReflectionUtils.makeAccessible(field); field.set(bean, value);` 这里完成了注入操作\n    ```java\n\t\t@Override\n\t\tprotected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n\t\t\tField field = (Field) this.member;\n\t\t\tObject value;\n\t\t\tif (this.cached) {\n\t\t\t\tvalue = resolvedCachedArgument(beanName, this.cachedFieldValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDependencyDescriptor desc = new DependencyDescriptor(field, this.required);\n\t\t\t\tdesc.setContainingClass(bean.getClass());\n\t\t\t\tSet<String> autowiredBeanNames = new LinkedHashSet<String>(1);\n\t\t\t\tTypeConverter typeConverter = beanFactory.getTypeConverter();\n\t\t\t\ttry {\n\t\t\t\t\t// 这里是重中之重，获取真正的属性值。\n\t\t\t\t\tvalue = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);\n\t\t\t\t}\n\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\tthrow new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);\n\t\t\t\t}\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (!this.cached) {\n\t\t\t\t\t\tif (value != null || this.required) {\n\t\t\t\t\t\t\tthis.cachedFieldValue = desc;\n\t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeanNames);\n\t\t\t\t\t\t\tif (autowiredBeanNames.size() == 1) {\n\t\t\t\t\t\t\t\tString autowiredBeanName = autowiredBeanNames.iterator().next();\n\t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\t\t\t\t\tif (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {\n\t\t\t\t\t\t\t\t\t\tthis.cachedFieldValue = new ShortcutDependencyDescriptor(\n\t\t\t\t\t\t\t\t\t\t\t\tdesc, autowiredBeanName, field.getType());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.cachedFieldValue = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.cached = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (value != null) {\n\t\t\t\t// 最终赋值结束。\n\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\tfield.set(bean, value);\n\t\t\t}\n\t\t}\n\t}\n    ```\n    * `AutowiredMethodElement#inject()`可以看到`ReflectionUtils.makeAccessible(method); method.invoke(bean, arguments);`这里完成了注入操作\n    ```java\n\tprotected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable {\n\t\t\tif (checkPropertySkipping(pvs)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tMethod method = (Method) this.member;\n\t\t\tObject[] arguments;\n\t\t\tif (this.cached) {\n\t\t\t\t// Shortcut for avoiding synchronization...\n\t\t\t\targuments = resolveCachedArguments(beanName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tClass<?>[] paramTypes = method.getParameterTypes();\n\t\t\t\targuments = new Object[paramTypes.length];\n\t\t\t\tDependencyDescriptor[] descriptors = new DependencyDescriptor[paramTypes.length];\n\t\t\t\tSet<String> autowiredBeans = new LinkedHashSet<String>(paramTypes.length);\n\t\t\t\tTypeConverter typeConverter = beanFactory.getTypeConverter();\n\t\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\t\tMethodParameter methodParam = new MethodParameter(method, i);\n\t\t\t\t\tDependencyDescriptor currDesc = new DependencyDescriptor(methodParam, this.required);\n\t\t\t\t\tcurrDesc.setContainingClass(bean.getClass());\n\t\t\t\t\tdescriptors[i] = currDesc;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter);\n\t\t\t\t\t\tif (arg == null && !this.required) {\n\t\t\t\t\t\t\targuments = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targuments[i] = arg;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\tthrow new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(methodParam), ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsynchronized (this) {\n\t\t\t\t\tif (!this.cached) {\n\t\t\t\t\t\tif (arguments != null) {\n\t\t\t\t\t\t\tthis.cachedMethodArguments = new Object[paramTypes.length];\n\t\t\t\t\t\t\tfor (int i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\t\t\tthis.cachedMethodArguments[i] = descriptors[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tregisterDependentBeans(beanName, autowiredBeans);\n\t\t\t\t\t\t\tif (autowiredBeans.size() == paramTypes.length) {\n\t\t\t\t\t\t\t\tIterator<String> it = autowiredBeans.iterator();\n\t\t\t\t\t\t\t\tfor (int i = 0; i < paramTypes.length; i++) {\n\t\t\t\t\t\t\t\t\tString autowiredBeanName = it.next();\n\t\t\t\t\t\t\t\t\tif (beanFactory.containsBean(autowiredBeanName)) {\n\t\t\t\t\t\t\t\t\t\tif (beanFactory.isTypeMatch(autowiredBeanName, paramTypes[i])) {\n\t\t\t\t\t\t\t\t\t\t\tthis.cachedMethodArguments[i] = new ShortcutDependencyDescriptor(\n\t\t\t\t\t\t\t\t\t\t\t\t\tdescriptors[i], autowiredBeanName, paramTypes[i]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis.cachedMethodArguments = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.cached = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (arguments != null) {\n\t\t\t\ttry {\n\t\t\t\t\t// 完成注入\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tmethod.invoke(bean, arguments);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex){\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    ``` \n    * `InjectedElement#inject()`可以看到`ReflectionUtils.makeAccessible(method); field.set(target, getResourceToInject(target, requestingBeanName));`这里完成了注入操作\n    ```java\n    protected void inject(Object target, String requestingBeanName, PropertyValues pvs) throws Throwable {\n        if (this.isField) {\n            Field field = (Field) this.member;\n            ReflectionUtils.makeAccessible(field);\n            field.set(target, getResourceToInject(target, requestingBeanName));\n        }\n        else {\n            if (checkPropertySkipping(pvs)) {\n                return;\n            }\n            try {\n                Method method = (Method) this.member;\n                ReflectionUtils.makeAccessible(method);\n                method.invoke(target, getResourceToInject(target, requestingBeanName));\n            }\n            catch (InvocationTargetException ex) {\n                throw ex.getTargetException();\n            }\n        }\n    }\n    ```\n## 总结\n\n* `@Autowired`和`@Resource`这两个注解是我们开发过程中经常使用的注解\n    * `@Autowired`默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许`null`值，可以设置它的`required`属性为`false`，例如：`@Autowired(required=false)` ，如果我们想使用名称装配可以结合`@Qualifier`注解进行使用\n    * `@Resource`，默认安装名称进行装配，名称可以通过`name`属性进行指定，如果没有指定`name`属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的`bean`时才按照类型进行装配。但是需要注意的是，如果`name`属性一旦指定，就只会按照名称进行装配。\n* `@Autowired、@Value、@Inject` 注解的实现大体逻辑是先获取哪些需要注入的属性，然后调用反射进行赋值\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(十)加载Bean之AbstractBeanFactory类createBean方法","url":"/2019/06/18/backend/framework/spring/analysis/Spring系列(十)加载Bean之AbstractBeanFactory类createBean方法/","content":"## 前言\n\n* 上一章节介绍了不同作用域下获取`Bean`的主体逻辑，这些作用域都调用了`createBean(String beanName, RootBeanDefinition mbd, Object[] args)`方法，这个是`AbstractBeanFactory`内定义的方法，默认实现是`AbstractAutowireCapableBeanFactory`，这个方法是创建`bean`实例的核心方法\n\n```java\n/**\n * 创建bean实例的核心方法，填充bean实例\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating instance of bean '\" + beanName + \"'\");\n    }\n    RootBeanDefinition mbdToUse = mbd;\n\n    // Make sure bean class is actually resolved at this point, and\n    // clone the bean definition in case of a dynamically resolved Class\n    // which cannot be stored in the shared merged bean definition.\n    // 锁定class，根据设置的class属性或者根据className来解析Class\n    Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n    if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n        mbdToUse = new RootBeanDefinition(mbd);\n        mbdToUse.setBeanClass(resolvedClass);\n    }\n\n    // Prepare method overrides.\n    // 对override属性进行标记及验证\n    try {\n        mbdToUse.prepareMethodOverrides();\n    }\n    catch (BeanDefinitionValidationException ex) {\n        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n                beanName, \"Validation of method overrides failed\", ex);\n    }\n\n    try {\n        // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n        // 给BeanPostProcessors一个机会来返回代理来替代真正的实例\n        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n        // 当经过前置处理后的返回结果如果不为空，那么会直接略过后续bean的创建二直接返回结果。这一特性虽然很容易被忽略，但是\n        // 却起着至关重要的作用，我们熟知的AOP功能就是基于这里的判断的\n        if (bean != null) {\n            return bean;\n        }\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n                \"BeanPostProcessor before instantiation of bean failed\", ex);\n    }\n    // 核心方法创建bean\n    Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\");\n    }\n    return beanInstance;\n}\n```\n\n* 上面有两个比较重要的方法，下面将详细介绍\n    * `Object bean = resolveBeforeInstantiation(beanName, mbdToUse);`\n    * `Object beanInstance = doCreateBean(beanName, mbdToUse, args);`\n\n## 解析\n\n### 方法一 resolveBeforeInstantiation(...) 解析\n\n* 查看注释可以得到这个方法是给给`BeanPostProcessors`一个机会来返回代理来替代真正的实例，注意这里`bean`还没有实例化还停留在`BeanDefinition`阶段\n\n```java\ntry {\n    // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n    // 给BeanPostProcessors一个机会来返回代理来替代真正的实例\n    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n    // 当经过前置处理后的返回结果如果不为空，那么会直接略过后续bean的创建二直接返回结果。这一特性虽然很容易被忽略，但是\n    // 却起着至关重要的作用\n    // 注意这里`bean`还没有实例化还停留在`BeanDefinition`阶段\n    if (bean != null) {\n        return bean;\n    }\n}\n```\n\n* 进入`Object bean = resolveBeforeInstantiation(beanName, mbdToUse);`方法，下面代码可以看到主要逻辑就是循环执行`InstantiationAwareBeanPostProcessor`接口的`postProcessBeforeInstantiation()`方法，因为上一层方法会直接`return`，如果能得到结果然后执行`BeanPostProcessor`实例化后的后处理器应用方法\n\n```java\n/**\n * 在bean实例化之前偷天换日\n * @see InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation\n *\n * Apply before-instantiation post-processors, resolving whether there is a\n * before-instantiation shortcut for the specified bean.\n * @param beanName the name of the bean\n * @param mbd the bean definition for the bean\n * @return the shortcut-determined bean instance, or {@code null} if none\n */\nprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n    Object bean = null;\n    // 如果尚未被解析\n    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n        // Make sure bean class is actually resolved at this point.\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n            Class<?> targetType = determineTargetType(beanName, mbd);\n            if (targetType != null) {\n                // 实例化前的后处理器应用 调用postProcessBeforeInstantiation，给一个子类一个修改BeanDefinition的机会\n                // 当经过这个方法后，bean可能已经不是我们认为的bean了，而是或许成为了一个经过处理的代理bean，可能是通过cglib生成的\n                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n                if (bean != null) {\n                    // 实例化后的后处理器应用 方法二 调用postProcessAfterInitialization\n                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n                }\n            }\n        }\n        mbd.beforeInstantiationResolved = (bean != null);\n    }\n    return bean;\n}\n\nprotected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n    for (BeanPostProcessor bp : getBeanPostProcessors()) {\n        if (bp instanceof InstantiationAwareBeanPostProcessor) {\n            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);\n            if (result != null) {\n                return result;\n            }\n        }\n    }\n    return null;\n}\n```\n\n* `InstantiationAwareBeanPostProcessor`接口也是继承`BeanPostProcessor`，说明他也是`Bean`的生命周期的一个钩子，`BeanPostProcessor`接口定义的方法都是实例化后的执行的方法，`InstantiationAwareBeanPostProcessor`接口在它的基础上添加了对象未实例化之前调用方法，该方法的返回值类型是`Object`，我们可以返回任何类型的值。由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例。如果该方法的返回值代替原本该生成的目标对象\n\n```java\n/**\n *\n * 主要作用在于目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置\n *\n * Subinterface of {@link BeanPostProcessor} that adds a before-instantiation callback,\n * and a callback after instantiation but before explicit properties are set or\n * autowiring occurs.\n *\n * <p>Typically used to suppress default instantiation for specific target beans,\n * for example to create proxies with special TargetSources (pooling targets,\n * lazily initializing targets, etc), or to implement additional injection strategies\n * such as field injection.\n *\n * <p><b>NOTE:</b> This interface is a special purpose interface, mainly for\n * internal use within the framework. It is recommended to implement the plain\n * {@link BeanPostProcessor} interface as far as possible, or to derive from\n * {@link InstantiationAwareBeanPostProcessorAdapter} in order to be shielded\n * from extensions to this interface.\n *\n * @author Juergen Hoeller\n * @author Rod Johnson\n * @since 1.2\n * @see org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator#setCustomTargetSourceCreators\n * @see org.springframework.aop.framework.autoproxy.target.LazyInitTargetSourceCreator\n */\npublic interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {\n\n\t/**\n\t * 是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。\n\t * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如AOP代理对象)。\n\t * 如果该方法的返回值代替原本该生成的目标对象，\n\t *\n\t * Apply this BeanPostProcessor <i>before the target bean gets instantiated</i>.\n\t * The returned bean object may be a proxy to use instead of the target bean,\n\t * effectively suppressing default instantiation of the target bean.\n\t * <p>If a non-null object is returned by this method, the bean creation process\n\t * will be short-circuited. The only further processing applied is the\n\t * {@link #postProcessAfterInitialization} callback from the configured\n\t * {@link BeanPostProcessor BeanPostProcessors}.\n\t * <p>This callback will only be applied to bean definitions with a bean class.\n\t * In particular, it will not be applied to beans with a \"factory-method\".\n\t * <p>Post-processors may implement the extended\n\t * {@link SmartInstantiationAwareBeanPostProcessor} interface in order\n\t * to predict the type of the bean object that they are going to return here.\n\t * @param beanClass the class of the bean to be instantiated\n\t * @param beanName the name of the bean\n\t * @return the bean object to expose instead of a default instance of the target bean,\n\t * or {@code null} to proceed with default instantiation\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.factory.support.AbstractBeanDefinition#hasBeanClass\n\t * @see org.springframework.beans.factory.support.AbstractBeanDefinition#getFactoryMethodName\n\t */\n\tObject postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException;\n\n\t/**\n\t * 在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置都是null\n\t *\n\t *\n\t * Perform operations after the bean has been instantiated, via a constructor or factory method,\n\t * but before Spring property population (from explicit properties or autowiring) occurs.\n\t * <p>This is the ideal callback for performing custom field injection on the given bean\n\t * instance, right before Spring's autowiring kicks in.\n\t * @param bean the bean instance created, with properties not having been set yet\n\t * @param beanName the name of the bean\n\t * @return {@code true} if properties should be set on the bean; {@code false}\n\t * if property population should be skipped. Normal implementations should return {@code true}.\n\t * Returning {@code false} will also prevent any subsequent InstantiationAwareBeanPostProcessor\n\t * instances being invoked on this bean instance.\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t */\n\tboolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;\n\n\t/**\n\t * 对属性值进行修改(这个时候属性值还未被设置，但是我们可以修改原本该设置进去的属性值)。\n\t * 如果 {@link #postProcessAfterInstantiation(java.lang.Object, java.lang.String)}方法返回false，该方法可能不会被调用。可以在该方法内对属性值进行修改\n\t *\n\t * Post-process the given property values before the factory applies them\n\t * to the given bean. Allows for checking whether all dependencies have been\n\t * satisfied, for example based on a \"Required\" annotation on bean property setters.\n\t * <p>Also allows for replacing the property values to apply, typically through\n\t * creating a new MutablePropertyValues instance based on the original PropertyValues,\n\t * adding or removing specific values.\n\t * @param pvs the property values that the factory is about to apply (never {@code null})\n\t * @param pds the relevant property descriptors for the target bean (with ignored\n\t * dependency types - which the factory handles specifically - already filtered out)\n\t * @param bean the bean instance created, but whose properties have not yet been set\n\t * @param beanName the name of the bean\n\t * @return the actual property values to apply to the given bean\n\t * (can be the passed-in PropertyValues instance), or {@code null}\n\t * to skip property population\n\t * @throws org.springframework.beans.BeansException in case of errors\n\t * @see org.springframework.beans.MutablePropertyValues\n\t */\n\tPropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException;\n\n}\n```\n\n### 方法二 doCreateBean(...) 解析\n\n* `Object beanInstance = doCreateBean(beanName, mbdToUse, args);` 这个方法是核心方法，又是个`do`开头的方法\n    * 该方法接受三个方法参数\n        * `bean` 的名字\n        * 已经合并了父类属性的（如果有的话）`BeanDefinition` 对象。\n        * 用于构造函数或者工厂方法创建 `Bean` 实例对象的参数。\n\n```java\n/**\n * Actually create the specified bean. Pre-creation processing has already happened\n * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.\n * <p>Differentiates between default bean instantiation, use of a\n * factory method, and autowiring a constructor.\n * @param beanName the name of the bean\n * @param mbd the merged bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return a new instance of the bean\n * @throws BeanCreationException if the bean could not be created\n * @see #instantiateBean\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n */\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)\n        throws BeanCreationException {\n\n    // Instantiate the bean.\n    // BeanWrapper 是对 Bean 的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装 bean 的属性描述器\n    BeanWrapper instanceWrapper = null;\n    // 单例模型，则从未完成的 FactoryBean 缓存中删除\n    if (mbd.isSingleton()) {\n        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n        // 根据指定的bean使用对应的策略创新新的实例，如：工厂方法、构造函数自动注入、简单初始化\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    // 包装的实例对象\n    final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);\n    // 包装的实例对象的类型\n    Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);\n    mbd.resolvedTargetType = beanType;\n\n    // Allow post-processors to modify the merged bean definition.\n    synchronized (mbd.postProcessingLock) {\n        // 判断是否有后置处理，如果有后置处理，则允许后置处理修改 BeanDefinition\n        if (!mbd.postProcessed) {\n            try {\n                // 应用MergedBeanDefinitionPostProcessors\n                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n            }\n            catch (Throwable ex) {\n                throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                        \"Post-processing of merged bean definition failed\", ex);\n            }\n            mbd.postProcessed = true;\n        }\n    }\n\n    // Eagerly cache singletons to be able to resolve circular references\n    // even when triggered by lifecycle interfaces like BeanFactoryAware.\n    /**\n     * 是否需要提早曝光：单例&允许循环依赖&当前bean正在创建中，检测循环依赖\n     *\n     * Spring处理循环依赖的解决方法：\n     * 在B中创建依赖A时是通过ObjectFactory提供的实例化方法来中断A中的属性填充，使B中持有的A仅仅是刚初始化并\n     * 没有填充任何属性的A，而这正初始化A的步骤还是在最开始创建A的时候进行的，但是因为A与B中A所表示的属性地址\n     * 是一样的，所以在A中创建好的属性填充可以通过B中的A获取，这样就解决了循环依赖的问题\n     */\n    boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n            isSingletonCurrentlyInCreation(beanName));\n    if (earlySingletonExposure) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Eagerly caching bean '\" + beanName +\n                    \"' to allow for resolving potential circular references\");\n        }\n        // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂\n        addSingletonFactory(beanName, new ObjectFactory<Object>() {\n            @Override\n            public Object getObject() throws BeansException {\n                // 对bean再一次依赖引用，主要应用于SmartInstantiationAware BeanPostProcessor\n                // 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有直接返回bean，不做任何处理\n                return getEarlyBeanReference(beanName, mbd, bean);\n            }\n        });\n\n    }\n\n    // Initialize the bean instance.\n    Object exposedObject = bean;\n    try {\n        // 对bean进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始依赖bean\n        populateBean(beanName, mbd, instanceWrapper);\n        if (exposedObject != null) {\n            // 调用初始化方法 比如init-method\n            exposedObject = initializeBean(beanName, exposedObject, mbd);\n        }\n    }\n    catch (Throwable ex) {\n        if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n            throw (BeanCreationException) ex;\n        }\n        else {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n        }\n    }\n    // 循环依赖处理\n    if (earlySingletonExposure) {\n        Object earlySingletonReference = getSingleton(beanName, false);\n        // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空\n        if (earlySingletonReference != null) {\n            // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强\n            if (exposedObject == bean) {\n                exposedObject = earlySingletonReference;\n            }\n            // 处理依赖\n            else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n                String[] dependentBeans = getDependentBeans(beanName);\n                Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);\n                for (String dependentBean : dependentBeans) {\n                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n                        actualDependentBeans.add(dependentBean);\n                    }\n                }\n                if (!actualDependentBeans.isEmpty()) {\n                    throw new BeanCurrentlyInCreationException(beanName,\n                            \"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n                            \"] in its raw version as part of a circular reference, but has eventually been \" +\n                            \"wrapped. This means that said other beans do not use the final version of the \" +\n                            \"bean. This is often the result of over-eager type matching - consider using \" +\n                            \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n                }\n            }\n        }\n    }\n\n    // Register bean as disposable.\n    try {\n        // 根据scope注册bean\n        registerDisposableBeanIfNecessary(beanName, bean, mbd);\n    }\n    catch (BeanDefinitionValidationException ex) {\n        throw new BeanCreationException(\n                mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n    }\n\n    return exposedObject;\n}\n```\n\n* 这个方法主要用于完成 `bean` 的创建和初始化工作，我们可以将其分为一下几个过程：\n    * `createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)` 方法，实例化 `bean` 。\n    * `populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)` 方法，进行属性填充。\n    * `initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)` 方法，初始化 `Bean` 。\n\n#### 1、 createBeanInstance(...) 实例化 bean\n\n```java\n/**\n * Create a new instance for the specified bean, using an appropriate instantiation strategy:\n * factory method, constructor autowiring, or simple instantiation.\n * @param beanName the name of the bean\n * @param mbd the bean definition for the bean\n * @param args explicit arguments to use for constructor or factory method invocation\n * @return BeanWrapper for the new instance\n * @see #instantiateUsingFactoryMethod\n * @see #autowireConstructor\n * @see #instantiateBean\n */\nprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {\n    // Make sure bean class is actually resolved at this point.\n    // 解析 bean ，将 bean 类名解析为 class 引用。\n    Class<?> beanClass = resolveBeanClass(mbd, beanName);\n\n    if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {\n        throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName());\n    }\n\n    // 如果工厂方法不为空则使用工厂方法初始化策略\n    if (mbd.getFactoryMethodName() != null)  {\n        return instantiateUsingFactoryMethod(beanName, mbd, args);\n    }\n\n    // Shortcut when re-creating the same bean...\n    boolean resolved = false;\n    boolean autowireNecessary = false;\n    if (args == null) {\n        synchronized (mbd.constructorArgumentLock) {\n            // 一个类有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先更具参数锁定构造函数或对应的工厂方法\n            if (mbd.resolvedConstructorOrFactoryMethod != null) {\n                resolved = true;\n                autowireNecessary = mbd.constructorArgumentsResolved;\n            }\n        }\n    }\n    // 如果已经解析过则使用解析好的构造函数方法不需要再次锁定\n    if (resolved) {\n        if (autowireNecessary) {\n            // 构造函数自动注入\n            return autowireConstructor(beanName, mbd, null, null);\n        }\n        else {\n            // 使用默认构造函数构造\n            return instantiateBean(beanName, mbd);\n        }\n    }\n\n    // Need to determine the constructor...\n    // 需根据参数解析构造函数\n    Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\n    if (ctors != null ||\n            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||\n            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {\n        // 构造函数自动注入\n        return autowireConstructor(beanName, mbd, ctors, args);\n    }\n\n    // No special handling: simply use no-arg constructor.\n    // 使用默认构造函数构造\n    return instantiateBean(beanName, mbd);\n}\n```\n\n* `createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)` 方法，用于实例化 `Bean` 对象。它会根据不同情况，选择不同的实例化策略来完成 `Bean` 的初始化，主要包括\n    * 1.1 工厂方法初始化：`instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs)` 方法。\n        * 如果存在工厂方法，则调用此工厂方法完成 `bean` 的初始化工作\n    * 1.2 构造函数自动注入初始化：`autowireConstructor(final String beanName, final RootBeanDefinition mbd, Constructor<?>[] chosenCtors, final Object[] explicitArgs)` 方法。\n        * 这个初始化方法，我们可以简单理解为是带有参数的构造方法，来初始化 `bean` 对象。\n        * 主要是因为构造函数和构造参数的不确定性，`Spring` 需要花大量的精力来确定构造函数和构造参数，所以比较复杂\n    * 1.3 默认构造函数初始化：`instantiateBean(final String beanName, final RootBeanDefinition mbd)` 方法。\n        * 它没有参数，所以不需要确认经过复杂的过来来确定构造器、构造参数\n        * 进入`getInstantiationStrategy().instantiate(mbd, beanName, parent);` 方法，从下面的代码可以得到默认构造函数的初始化比上面的情况更为简单，如果没有什么特殊的直接反射得到`ctor.newInstance(args)`实例\n        ```java\n        @Override\n        public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {\n            // Don't override the class with CGLIB if no overrides.\n            // 用户没有使用replace或者lookup的配置方法，那么直接使用反射的方式创建实例\n            if (bd.getMethodOverrides().isEmpty()) {\n                Constructor<?> constructorToUse;\n                synchronized (bd.constructorArgumentLock) {\n                    constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;\n                    if (constructorToUse == null) {\n                        final Class<?> clazz = bd.getBeanClass();\n                        if (clazz.isInterface()) {\n                            throw new BeanInstantiationException(clazz, \"Specified class is an interface\");\n                        }\n                        try {\n                            if (System.getSecurityManager() != null) {\n                                constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<Constructor<?>>() {\n                                    @Override\n                                    public Constructor<?> run() throws Exception {\n                                        return clazz.getDeclaredConstructor((Class[]) null);\n                                    }\n                                });\n                            }\n                            else {\n                                constructorToUse =\tclazz.getDeclaredConstructor((Class[]) null);\n                            }\n                            bd.resolvedConstructorOrFactoryMethod = constructorToUse;\n                        }\n                        catch (Throwable ex) {\n                            throw new BeanInstantiationException(clazz, \"No default constructor found\", ex);\n                        }\n                    }\n                }\n                // 实例化实体类\n                return BeanUtils.instantiateClass(constructorToUse);\n            }\n            else {\n                // 需要将replace或者lookup这两个配置的功能（动态代理）切入进去\n                // Must generate CGLIB subclass.\n                return instantiateWithMethodInjection(bd, beanName, owner);\n            }\n        }\n  \n        public static <T> T instantiateClass(Constructor<T> ctor, Object... args) throws BeanInstantiationException {\n            Assert.notNull(ctor, \"Constructor must not be null\");\n            try {\n                // 反射构造实例\n                ReflectionUtils.makeAccessible(ctor);\n                return ctor.newInstance(args);\n            }\n            catch (InstantiationException ex) {\n                throw new BeanInstantiationException(ctor, \"Is it an abstract class?\", ex);\n            }\n            catch (IllegalAccessException ex) {\n                throw new BeanInstantiationException(ctor, \"Is the constructor accessible?\", ex);\n            }\n            catch (IllegalArgumentException ex) {\n                throw new BeanInstantiationException(ctor, \"Illegal arguments for constructor\", ex);\n            }\n            catch (InvocationTargetException ex) {\n                throw new BeanInstantiationException(ctor, \"Constructor threw exception\", ex.getTargetException());\n            }\n        }\n        ```\n\n#### 2、 populateBean(...) 进行属性填充，完成依赖注入\n\n```java\n/**\n * Populate the bean instance in the given BeanWrapper with the property values\n * from the bean definition.\n * @param beanName the name of the bean\n * @param mbd the bean definition for the bean\n * @param bw BeanWrapper with bean instance\n */\nprotected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {\n    PropertyValues pvs = mbd.getPropertyValues();\n\n    if (bw == null) {\n        if (!pvs.isEmpty()) {\n            throw new BeanCreationException(\n                    mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\");\n        }\n        else {\n            // Skip property population phase for null instance.\n            // 没有可填充的属性\n            return;\n        }\n    }\n\n    // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the\n    // state of the bean before properties are set. This can be used, for example,\n    // to support styles of field injection.\n    boolean continueWithPropertyPopulation = true;\n    /**\n     * 给InstantiationAwareBeanPostProcessors最后一次机会在属性设置前来改变bean\n     * 如：可以用来支持属性注入的类型\n     */\n    if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                // 返回值是否继续填充bean\n                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                    continueWithPropertyPopulation = false;\n                    break;\n                }\n            }\n        }\n    }\n    // 终止后续的执行\n    if (!continueWithPropertyPopulation) {\n        return;\n    }\n\n    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||\n            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n        // 存入PropertyValues中\n        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);\n\n        // Add property values based on autowire by name if applicable.\n        // 根据名称自动注入\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {\n            autowireByName(beanName, mbd, bw, newPvs);\n        }\n\n        // Add property values based on autowire by type if applicable.\n        // 根据类型自动注入\n        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {\n            autowireByType(beanName, mbd, bw, newPvs);\n        }\n\n        pvs = newPvs;\n    }\n    // 后处理器已经初始化\n    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n    // 需要依赖检查\n    boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n    if (hasInstAwareBpps || needsDepCheck) {\n        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n        if (hasInstAwareBpps) {\n            // PropertyValue值设置后，Spring会调用getBeanPostProcessor方法遍历Bean工厂中注册的所有BeanPostProcessor\n            // 其中就包括AutowiredAnnotationBeanPostProcessor @Autowired注解就是在这里完成的注入\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    // 对所有需要依赖检查的属性进行后处理\n                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n                    if (pvs == null) {\n                        return;\n                    }\n                }\n            }\n        }\n        if (needsDepCheck) {\n            // 依赖检查。对应depends-on属性，3.0已废弃\n            checkDependencies(beanName, mbd, filteredPds, pvs);\n        }\n    }\n    // 将属性应用到bean中 之前的操作是获取所有注入属性，但是获取到的属性是以PropertyValues形式存在的，并没有\n    // 应用到已经实例化的bean中，下面的方法就是做这个操作的\n    applyPropertyValues(beanName, mbd, bw, pvs);\n}\n```\n\n* `populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)` 方法，进行属性填充，这里是完成依赖注入的关键，根据上面的代码可以划分\n    * 1、获取`PropertyValues pvs = mbd.getPropertyValues();` 已定义`bean`的属性值\n        * 比如之前配置的，下面就是`userName`属性\n        ```java\n         <bean class=\"org.springiframe.entity.User\">\n            <property name=\"userName\" value=\"shop\"/>\n         </bean>\n        ```\n        * 由下图可以看到已经获取了`PropertyValues pvs `属性值，\n         ![](/images/server/spring/analysis/pb1.png)\n    * 2、给`InstantiationAwareBeanPostProcessors`最后一次机会在属性设置前来改变`bean`\n        * 看代码可以看到是循环`BeanPostProcessor`，然后调用`postProcessAfterInstantiation(Object bean, String beanName)`方法\n        ```java\n        if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    // 返回值是否继续填充bean\n                    if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {\n                        continueWithPropertyPopulation = false;\n                        break;\n                    }\n                }\n            }\n        }\n        // 终止后续的执行\n        if (!continueWithPropertyPopulation) {\n            return;\n        }\n        ```\n        * 可以通过`postProcessAfterInstantiation(Object bean, String beanName)`的返回值来控制 `Spring` 是否继续进行属性填充。\n    * 3、判断自动注入的模式\n        * 根据名称自动注入`autowireByName(beanName, mbd, bw, newPvs)`\n            * TODO\n        * 根据类型自动注入`autowireByType(beanName, mbd, bw, newPvs);`\n            * TODO\n    * 4、依赖检查及依赖注入\n        *  `@Autowired`注解就是在这里完成的注入，遍历`InstantiationAwareBeanPostProcessor`执行`postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) `方法\n        ```java\n\t\t// 后处理器已经初始化\n\t\tboolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();\n\t\t// 需要依赖检查\n\t\tboolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);\n\n\t\tif (hasInstAwareBpps || needsDepCheck) {\n\t\t\tPropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);\n\t\t\tif (hasInstAwareBpps) {\n\t\t\t\t// PropertyValue值设置后，Spring会调用getBeanPostProcessor方法遍历Bean工厂中注册的所有BeanPostProcessor\n\t\t\t\t// 其中就包括AutowiredAnnotationBeanPostProcessor @Autowired注解就是在这里完成的注入\n\t\t\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\t\t\tif (bp instanceof InstantiationAwareBeanPostProcessor) {\n\t\t\t\t\t\tInstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n\t\t\t\t\t\t// 对所有需要依赖检查的属性进行后处理\n\t\t\t\t\t\tpvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);\n\t\t\t\t\t\tif (pvs == null) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (needsDepCheck) {\n\t\t\t\t// 依赖检查。对应depends-on属性，3.0已废弃\n\t\t\t\tcheckDependencies(beanName, mbd, filteredPds, pvs);\n\t\t\t}\n\t\t}\n        ```\n        * 关注`postProcessPropertyValues`方法，这里是调用的`InstantiationAwareBeanPostProcessor`接口的方法，这个方法完成了依赖属性的注入，这个接口又是继承`BeanPostProcessor`，详细说明将在下一章介绍\n\n#### 3、 initializeBean(...) 初始化 bean\n\n```java\nprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {\n    if (pvs == null || pvs.isEmpty()) {\n        return;\n    }\n\n    MutablePropertyValues mpvs = null;\n    List<PropertyValue> original;\n\n    if (System.getSecurityManager() != null) {\n        if (bw instanceof BeanWrapperImpl) {\n            ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());\n        }\n    }\n\n    if (pvs instanceof MutablePropertyValues) {\n        mpvs = (MutablePropertyValues) pvs;\n        // 如果mpvs中的值已经被转化为对应的类型那么可以直接设置到beanwapper中\n        if (mpvs.isConverted()) {\n            // Shortcut: use the pre-converted values as-is.\n            try {\n                bw.setPropertyValues(mpvs);\n                return;\n            }\n            catch (BeansException ex) {\n                throw new BeanCreationException(\n                        mbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n            }\n        }\n        original = mpvs.getPropertyValueList();\n    }\n    else {\n        // 如果pvs并不是使用MutablePropertyValues封装的类型，那么直接使用原始的属性获取方法\n        original = Arrays.asList(pvs.getPropertyValues());\n    }\n\n    TypeConverter converter = getCustomTypeConverter();\n    if (converter == null) {\n        converter = bw;\n    }\n    // 获取对应的解析器\n    BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);\n\n    // Create a deep copy, resolving any references for values.\n    List<PropertyValue> deepCopy = new ArrayList<PropertyValue>(original.size());\n    boolean resolveNecessary = false;\n    // 遍历属性，将属性转化为对应lei的对应属性的类型\n    for (PropertyValue pv : original) {\n        if (pv.isConverted()) {\n            deepCopy.add(pv);\n        }\n        else {\n            String propertyName = pv.getName();\n            Object originalValue = pv.getValue();\n            // 调用\n            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);\n            Object convertedValue = resolvedValue;\n            boolean convertible = bw.isWritableProperty(propertyName) &&\n                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);\n            if (convertible) {\n                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);\n            }\n            // Possibly store converted value in merged bean definition,\n            // in order to avoid re-conversion for every created bean instance.\n            if (resolvedValue == originalValue) {\n                if (convertible) {\n                    pv.setConvertedValue(convertedValue);\n                }\n                deepCopy.add(pv);\n            }\n            else if (convertible && originalValue instanceof TypedStringValue &&\n                    !((TypedStringValue) originalValue).isDynamic() &&\n                    !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {\n                pv.setConvertedValue(convertedValue);\n                deepCopy.add(pv);\n            }\n            else {\n                resolveNecessary = true;\n                deepCopy.add(new PropertyValue(pv, convertedValue));\n            }\n        }\n    }\n    if (mpvs != null && !resolveNecessary) {\n        mpvs.setConverted();\n    }\n\n    // Set our (possibly massaged) deep copy.\n    try {\n        bw.setPropertyValues(new MutablePropertyValues(deepCopy));\n    }\n    catch (BeansException ex) {\n        throw new BeanCreationException(\n                mbd.getResourceDescription(), beanName, \"Error setting property values\", ex);\n    }\n}\n```\n\n* 将属性应用到已经实例化的`bean`中`applyPropertyValues(beanName, mbd, bw, pvs);`，上面只是完成了所有注入属性的获取，将获取的属性封装在 `PropertyValues` 的实例对象 `pvs` 中，并没有应用到已经实例化的 `bean` 中\n\n### Spring Bean 在容器的生命周期是什么样的？\n\n![](/images/server/spring/analysis/bean/beanlife.png)\n\n* 实例化 `Bean` 对象\n    * `Spring` 容器根据配置中的 `Bean Definition`(定义)中实例化 `Bean` 对象。`Bean Definition` 可以通过 `XML`，`Java` 注解或 `Java Config` 代码提供。\n* 进行属性填充\n    * `Spring` 使用依赖注入填充所有属性，如 `Bean` 中所定义的配置。\n* 调用钩子接口函数`Aware`、`BeanPostProcessor`、`InitializingBean` \n* 使用 `Bean` 对象\n* 销毁 `Bean` 对象\n    * 如果 `Bean` 实现 `DisposableBean` 接口，当 `spring` 容器关闭时，会调用 `#destroy()` 方法。\n    * 如果为 `Bean` 指定了 `destroy` 方法（例如 `<bean />` 的 `destroy-method` 属性），那么将调用该方法。\n\n## 总结\n* `Object beanInstance = createBean(beanName, mbdToUse, args);` 这个方法是核心方法，所有的`bean`实例的创建，都会委托给该方法实现。\n* `doCreateBean(...)` 方法，主要用于完成 `bean` 的创建和初始化工作，我们可以将其分为一下几个过程：\n    * `createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args)` 方法，实例化 `bean` 。\n    * `populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)` 方法，进行属性填充。\n    * `initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)` 方法，初始化 `Bean` 。\n\n![](/images/server/spring/analysis/doCreateBean.jpg)\n\n* `getBean` 的全流程\n\n![](/images/server/spring/analysis/getBean.jpg)\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(九)加载Bean之不同作用域下获取Bean","url":"/2019/06/17/backend/framework/spring/analysis/Spring系列(九)加载Bean之不同作用域下获取Bean/","content":"## 前言\n\n* 上一章节介绍了从单例缓存中获取单例 `Bean`，这一章节来介绍不从缓存中获取单例`Bean`的过程，也就是下面的`else`分支的代码语句，什么时候会走到`else`呢，一种情况是该 `Bean` 的 `scope` 不是 `singleton`，另一种情况是该 `Bean` 的 `scope` 是 `singleton` 但是没有初始化完成。\n\n```java\nObject sharedInstance = getSingleton(beanName);\n// 从缓存中获取 Bean 后，若其不为 null 且 args 为空\nif (sharedInstance != null && args == null) {\n    \n    ... 第八章已介绍\n    \n}\nelse { // 在缓存中没有\n\n    // 只有单例情况下才会尝试解决循依赖（如果存在A中有B属性，B中有A属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次创建A，造成循环依赖）\n    // 在原型模式下如果存在循环依赖则会抛出异常。\n    // Fail if we're already creating this bean instance:\n    // We're assumably within a circular reference.\n    if (isPrototypeCurrentlyInCreation(beanName)) {\n        throw new BeanCurrentlyInCreationException(beanName);\n    }\n\n    // Check if bean definition exists in this factory.\n    // 判断工厂中是否含有此Bean的定义，如果没有找到则父类容器里找\n    BeanFactory parentBeanFactory = getParentBeanFactory();\n    // 如果beanDefinitionMap中也就是在所有已经加载的类中不包括beanName，则尝试从parentBeanFactory中检测\n    if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n        // Not found -> check parent. 如果没有，查询父工厂\n        String nameToLookup = originalBeanName(name);\n        // 递归到BeanFactory中寻找 递归调用getBean方法\n        if (args != null) {\n            // Delegation to parent with explicit args.  执行带有args参数的getbean方法\n            return (T) parentBeanFactory.getBean(nameToLookup, args);\n        }\n        else {\n            // No args -> delegate to standard getBean method. 如果没有参数，执行标准的getbean方法\n            return parentBeanFactory.getBean(nameToLookup, requiredType);\n        }\n    }\n    // 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n    if (!typeCheckOnly) {\n        markBeanAsCreated(beanName);\n    }\n\n    try {\n        // 将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition，\n        // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n        // 检查给定的合并的 BeanDefinition\n        checkMergedBeanDefinition(mbd, beanName, args);\n\n        // 处理所依赖的 bean\n        // Guarantee initialization of beans that the current bean depends on.\n        String[] dependsOn = mbd.getDependsOn();\n        // 若存在依赖则需要递归实例化依赖的bean，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖\n        if (dependsOn != null) {\n            for (String dep : dependsOn) {\n                if (isDependent(beanName, dep)) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                            \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n                }\n                // 缓存依赖调用\n                registerDependentBean(dep, beanName);\n                /**\n                 * 递归处理依赖 Bean\n                 * 每个 Bean 都不是单独工作的，它会依赖其他 Bean，其他 Bean 也会依赖它。\n                 * 对于依赖的 Bean ，它会优先加载，所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。\n                 */\n                getBean(dep);\n            }\n        }\n        // Create bean instance. 重头戏\n        // 单例模式的实例化bean\n        if (mbd.isSingleton()) {\n            // 获取实例了\n            sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n                @Override\n                public Object getObject() throws BeansException {\n                    try {\n                        // 在getSingleton()方法会调用\n                        return createBean(beanName, mbd, args);\n                    }\n                    catch (BeansException ex) {\n                        // Explicitly remove instance from singleton cache: It might have been put there\n                        // eagerly by the creation process, to allow for circular reference resolution.\n                        // Also remove any beans that received a temporary reference to the bean.\n                        // 显式从单例缓存中删除 Bean 实例，因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                        destroySingleton(beanName);\n                        throw ex;\n                    }\n                }\n            });\n            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n        }\n        // 原型模式的实例化bean\n        else if (mbd.isPrototype()) {\n            // It's a prototype -> create a new instance.\n            Object prototypeInstance = null;\n            try {\n                beforePrototypeCreation(beanName);\n                prototypeInstance = createBean(beanName, mbd, args);\n            }\n            finally {\n                afterPrototypeCreation(beanName);\n            }\n            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n        }\n\n        else {\n            // 指定的scope上实例化bean\n            String scopeName = mbd.getScope();\n            final Scope scope = this.scopes.get(scopeName);\n            if (scope == null) {\n                throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n            }\n            try {\n                Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n                    @Override\n                    public Object getObject() throws BeansException {\n                        beforePrototypeCreation(beanName);\n                        try {\n                            return createBean(beanName, mbd, args);\n                        }\n                        finally {\n                            afterPrototypeCreation(beanName);\n                        }\n                    }\n                });\n                bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n            }\n            catch (IllegalStateException ex) {\n                throw new BeanCreationException(beanName,\n                        \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                        \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                        ex);\n            }\n        }\n    }\n    catch (BeansException ex) {\n        cleanupAfterBeanCreationFailure(beanName);\n        throw ex;\n    }\n}\n```\n* 上面的代码可以分为如下部分：\n    * 1、原型模式下循环依赖检查，如果是则抛`BeanCurrentlyInCreationException`异常\n        * 在前面就提过，`Spring` 只解决单例模式下的循环依赖，对于原型模式的循环依赖则抛异常，单例模式下`Spring`是通过`cache`的形式提早曝光创建的对象来处理循环依赖的，但原型模式下的`bean`都是新建的，所以无法`cache`\n        * 检测逻辑和单例模式一样，一个“集合”存放着正在创建的 `Bean` ，从该集合中进行判断即可，只不过单例模式下的“集合”为 `Set` ，而原型模式的则是 `ThreadLocal`\n        * 代码\n            ```java\n            /** Names of beans that are currently in creation */\n            private final ThreadLocal<Object> prototypesCurrentlyInCreation = new NamedThreadLocal<Object>(\"Prototype beans currently in creation\");\n        \n            if (isPrototypeCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(beanName);\n            }\n        \n            protected boolean isPrototypeCurrentlyInCreation(String beanName) {\n                Object curVal = this.prototypesCurrentlyInCreation.get();\n                return (curVal != null &&\n                        (curVal.equals(beanName) || (curVal instanceof Set && ((Set<?>) curVal).contains(beanName))));\n            }\n            ```\n    * 2、判断工厂中是否含有此`Bean`的定义，如果没有找到则父类容器里找\n        * 递归到`BeanFactory`中寻找 递归调用`getBean`方法\n        * 代码\n        ```java\n        // Check if bean definition exists in this factory.\n        // 判断工厂中是否含有此Bean的定义，如果没有找到则父类容器里找\n        BeanFactory parentBeanFactory = getParentBeanFactory();\n        // 如果beanDefinitionMap中也就是在所有已经加载的类中不包括beanName，则尝试从parentBeanFactory中检测\n        if (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n            // Not found -> check parent. 如果没有，查询父工厂\n            String nameToLookup = originalBeanName(name);\n            // 递归到BeanFactory中寻找 递归调用getBean方法\n            if (args != null) {\n                // Delegation to parent with explicit args.  执行带有args参数的getbean方法\n                return (T) parentBeanFactory.getBean(nameToLookup, args);\n            }\n            else {\n                // No args -> delegate to standard getBean method. 如果没有参数，执行标准的getbean方法\n                return parentBeanFactory.getBean(nameToLookup, requiredType);\n            }\n        }\n        ```\n    * 3、获取`RootBeanDefinition`，若获取的 `BeanDefinition` 为子 `BeanDefinition`，则需要合并父类的相关属性\n        * 合并得到`RootBeanDefinition`\n        * 代码\n        ```java\n        // 将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition，\n        // 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n        final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n        // 检查给定的合并的 BeanDefinition\n        checkMergedBeanDefinition(mbd, beanName, args);\n        ```\n    * 4、处理依赖，设及到`depends-on`属性\n        * 适用于表面上看起来两个`bean`之间没有使用属性之类的强连接的`bean`，但是两个`bean`又确实存在前后依赖关系的情况，使用了`depends-on`的时候，依赖他人的`bean`是先于被依赖`bean`销毁的\n        * 代码\n        ```java\n        // 处理所依赖的 bean\n        // Guarantee initialization of beans that the current bean depends on.\n        String[] dependsOn = mbd.getDependsOn();\n        // 若存在依赖则需要递归实例化依赖的bean，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖\n        if (dependsOn != null) {\n            for (String dep : dependsOn) {\n                if (isDependent(beanName, dep)) {\n                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,\n                            \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n                }\n                // 缓存依赖调用\n                registerDependentBean(dep, beanName);\n                /**\n                 * 递归处理依赖 Bean\n                 * 每个 Bean 都不是单独工作的，它会依赖其他 Bean，其他 Bean 也会依赖它。\n                 * 对于依赖的 Bean ，它会优先加载，所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。\n                 */\n                getBean(dep);\n            }\n        }\n        ```\n    * 5、单例模式的实例化`bean`\n    * 6、原型模式的实例化`bean`\n    * 7、指定的`scope`上实例化`bean`\n## 解析\n\n### 1、单例模式的实例化bean\n* 单例模式的实例化`bean`的动作是在`getSingleton(String beanName, ObjectFactory<?> singletonFactory)`方法实现的，可以看到两个参数，一个`beanName`，第二个`ObjectFactory`的对象，可以看到是直接`new`了一个`ObjectFactory`，并重写了` getObject()`方法，转而调用`createBean(beanName, mbd, args);`方法\n\n```java\n// Create bean instance. 重头戏\n// 单例模式的实例化bean\nif (mbd.isSingleton()) {\n    // 获取实例了\n    sharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n        @Override\n        public Object getObject() throws BeansException {\n            try {\n                // 在getSingleton()方法会调用\n                return createBean(beanName, mbd, args);\n            }\n            catch (BeansException ex) {\n                // Explicitly remove instance from singleton cache: It might have been put there\n                // eagerly by the creation process, to allow for circular reference resolution.\n                // Also remove any beans that received a temporary reference to the bean.\n                // 显式从单例缓存中删除 Bean 实例，因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n                destroySingleton(beanName);\n                throw ex;\n            }\n        }\n    });\n    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n}\n```\n\n* 先进入`getSingleton(String beanName, ObjectFactory<?> singletonFactory)`方法，可以看到先是从`private final Map<String, Object> singletonObjects`对象中获取`bean`，如果没有获取到就是通过`singletonFactory.getObject();` 来获取`bean`\n\n```java\n/**\n * Return the (raw) singleton object registered under the given name,\n * creating and registering a new one if none registered yet.\n * @param beanName the name of the bean\n * @param singletonFactory the ObjectFactory to lazily create the singleton\n * with, if necessary\n * @return the registered singleton object\n */\npublic Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n    Assert.notNull(beanName, \"'beanName' must not be null\");\n    // 全局变量需要同步\n    synchronized (this.singletonObjects) {\n        // 首先检查对应的bean是否已经加载过，因为singleton模式其实就是复用以创建的bean。所以这一步是必须的\n        Object singletonObject = this.singletonObjects.get(beanName);\n        // 如果未空才可以进行singleton的bean的初始化\n        if (singletonObject == null) {\n            if (this.singletonsCurrentlyInDestruction) {\n                throw new BeanCreationNotAllowedException(beanName,\n                        \"Singleton bean creation not allowed while singletons of this factory are in destruction \" +\n                        \"(Do not request a bean from a BeanFactory in a destroy method implementation!)\");\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\");\n            }\n            // 记录加载状态，将当前正要创建的bean记录在缓存中，这样便可以对循环依赖进行检测\n            beforeSingletonCreation(beanName);\n            boolean newSingleton = false;\n            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);\n            if (recordSuppressedExceptions) {\n                this.suppressedExceptions = new LinkedHashSet<Exception>();\n            }\n            try {\n                // 真正获取单例 bean 的方法\n                singletonObject = singletonFactory.getObject();\n                newSingleton = true;\n            }\n            catch (IllegalStateException ex) {\n                // Has the singleton object implicitly appeared in the meantime ->\n                // if yes, proceed with it since the exception indicates that state.\n                singletonObject = this.singletonObjects.get(beanName);\n                if (singletonObject == null) {\n                    throw ex;\n                }\n            }\n            catch (BeanCreationException ex) {\n                if (recordSuppressedExceptions) {\n                    for (Exception suppressedException : this.suppressedExceptions) {\n                        ex.addRelatedCause(suppressedException);\n                    }\n                }\n                throw ex;\n            }\n            finally {\n                if (recordSuppressedExceptions) {\n                    this.suppressedExceptions = null;\n                }\n                // 当bean加载结束后需要移除缓存中对该bean的正在加载状态的记录\n                afterSingletonCreation(beanName);\n            }\n            if (newSingleton) {\n                // 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态\n                addSingleton(beanName, singletonObject);\n            }\n        }\n        return (singletonObject != NULL_OBJECT ? singletonObject : null);\n    }\n}\n```\n\n* `beforeSingletonCreation(beanName);` 记录正在创建的`bean`，使用了一个存放`beanName`的 `Set`集合，这样便可以对循环依赖进行检测\n\n```java\n/**\n * Names of beans that are currently in creation\n *\n * 记录bean的加载状态\t，在bean开始创建前会将beanName记录在属性中，创建结束会将该beanName从该属性中移除\n */\nprivate final Set<String> singletonsCurrentlyInCreation =\n        Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(16));\n\n// 记录加载状态，将当前正要创建的bean记录在缓存中，这样便可以对循环依赖进行检测\nbeforeSingletonCreation(beanName);\n\nprotected void beforeSingletonCreation(String beanName) {\n    // 记录bean的加载状态\n    if (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.add(beanName)) {\n        throw new BeanCurrentlyInCreationException(beanName);\n    }\n}\n```\n\n* `singletonObject = singletonFactory.getObject();`是真正获取单例 `bean` 的方法，这个方法在外面`AbstractAutowireCapableBeanFactory`的`createBean(beanName, mbd, args);`实现，代码如下可以看到主要是有两个主体方法:1、`Object bean = resolveBeforeInstantiation(beanName, mbdToUse);` 、2、`Object beanInstance = doCreateBean(beanName, mbdToUse, args);`\n\n```java\n/**\n * 创建bean实例的核心方法，填充bean实例\n * Central method of this class: creates a bean instance,\n * populates the bean instance, applies post-processors, etc.\n * @see #doCreateBean\n */\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException {\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Creating instance of bean '\" + beanName + \"'\");\n    }\n    RootBeanDefinition mbdToUse = mbd;\n\n    // Make sure bean class is actually resolved at this point, and\n    // clone the bean definition in case of a dynamically resolved Class\n    // which cannot be stored in the shared merged bean definition.\n    // 锁定class，根据设置的class属性或者根据className来解析Class\n    Class<?> resolvedClass = resolveBeanClass(mbd, beanName);\n    if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n        mbdToUse = new RootBeanDefinition(mbd);\n        mbdToUse.setBeanClass(resolvedClass);\n    }\n\n    // Prepare method overrides.\n    // 对override属性进行标记及验证\n    try {\n        mbdToUse.prepareMethodOverrides();\n    }\n    catch (BeanDefinitionValidationException ex) {\n        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n                beanName, \"Validation of method overrides failed\", ex);\n    }\n\n    try {\n        // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n        // 给BeanPostProcessors一个机会来返回代理来替代真正的实例\n        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);\n        // 当经过前置处理后的返回结果如果不为空，那么会直接略过后续bean的创建二直接返回结果。这一特性虽然很容易被忽略，但是\n        // 却起着至关重要的作用，我们熟知的AOP功能就是基于这里的判断的\n        if (bean != null) {\n            return bean;\n        }\n    }\n    catch (Throwable ex) {\n        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n                \"BeanPostProcessor before instantiation of bean failed\", ex);\n    }\n    // 创建bean\n    Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\");\n    }\n    return beanInstance;\n}\n```\n* 下面来讲解着两个方法\n    * `Object bean = resolveBeforeInstantiation(beanName, mbdToUse);` \n        * 这个方法是给`BeanPostProcessor`一个机会来返回代理来替代真正的实例，这个方法却起着至关重要的作用，我们熟知的`AOP`功能就是基于这里的判断的，如果不为空直接返回对应的代理类，`BeanPostProcessors` 接口之前也接触过一些，这个接口是定义`bean`初始化之和初始化之后分别调用的的方法\n        * 进入方法，可以看到主要功能是遍历`List<BeanPostProcessor> beanPostProcessors`，先执行`bean`初始化之前接口方法`postProcessBeforeInstantiation`，后执行`bean`初始化之后接口方法`postProcessAfterInitialization`\n        ```java\n        protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {\n            Object bean = null;\n            // 如果尚未被解析\n            if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {\n                // Make sure bean class is actually resolved at this point.\n                if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n                    Class<?> targetType = determineTargetType(beanName, mbd);\n                    if (targetType != null) {\n                        // 实例化前的后处理器应用 调用postProcessBeforeInstantiation，给一个子类一个修改BeanDefinition的机会\n                        // 当经过这个方法后，bean可能已经不是我们认为的bean了，而是或许成为了一个经过处理的代理bean，可能是通过cglib生成的\n                        bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n                        if (bean != null) {\n                            // 实例化后的后处理器应用 方法二 调用postProcessAfterInitialization\n                            bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);\n                        }\n                    }\n                }\n                mbd.beforeInstantiationResolved = (bean != null);\n            }\n            return bean;\n        }\n  \n        protected Object applyBeanPostProcessorsBeforeInstantiation(Class<?> beanClass, String beanName) {\n            for (BeanPostProcessor bp : getBeanPostProcessors()) {\n                if (bp instanceof InstantiationAwareBeanPostProcessor) {\n                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;\n                    Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);\n                    if (result != null) {\n                        return result;\n                    }\n                }\n            }\n            return null;\n        }\n  \n        public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n                throws BeansException {\n      \n            Object result = existingBean;\n            // 实现 BeanPostProcessor 接口用户可以根据自己的业务需求进行响应的处理\n            for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n                result = beanProcessor.postProcessAfterInitialization(result, beanName);\n                if (result == null) {\n                    return result;\n                }\n            }\n            return result;\n        }\n        ```\n    * `Object beanInstance = doCreateBean(beanName, mbdToUse, args);`\n        * 这个方法是创建`bean`的主体方法，篇幅较多所以放到下一章节\n\n* 得到 `Object singletonObject` 之后\n    * 1、先是移除缓存中对该bean的正在加载状态的记录，与上面的`beforeSingletonCreation(beanName)`相对应\n    ```java\n\tprotected void afterSingletonCreation(String beanName) {\n\t\t// 移除bean的加载状态\n\t\tif (!this.inCreationCheckExclusions.contains(beanName) && !this.singletonsCurrentlyInCreation.remove(beanName)) {\n\t\t\tthrow new IllegalStateException(\"Singleton '\" + beanName + \"' isn't currently in creation\");\n\t\t}\n\t}\n    ```\n    * 2、存放到缓存中，可以看到将结果`put`到`Map<String, Object> singletonObjects`对象中并记录注册过的单例`bean name` 放到`Set<String> registeredSingletons`集合中，然后移除`Map<String, ObjectFactory<?>> singletonFactories`及`Map<String, Object> earlySingletonObjects`缓存，最终结果:`Map<String, Object> singletonObjects` \n    ```java\n\tif (newSingleton) {\n        // 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态\n        addSingleton(beanName, singletonObject);\n    }\n  \n    /**\n     * 将给定的singleton对象添加到此工厂的singleton缓存中。\n     *\n     * Add the given singleton object to the singleton cache of this factory.\n     * <p>To be called for eager registration of singletons.\n     * @param beanName the name of the bean\n     * @param singletonObject the singleton object\n     */\n    protected void addSingleton(String beanName, Object singletonObject) {\n        synchronized (this.singletonObjects) {\n            this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));\n            this.singletonFactories.remove(beanName);\n            this.earlySingletonObjects.remove(beanName);\n            this.registeredSingletons.add(beanName);\n        }\n    }\n    ```\n\n### 2、原型模式的实例化bean\n\n* 上代码\n\n```java\n// 原型模式的实例化bean\nelse if (mbd.isPrototype()) {\n    // It's a prototype -> create a new instance.\n    Object prototypeInstance = null;\n    try {\n        // 记录加载原型模式 bean 之前的加载状态前置处理\n        beforePrototypeCreation(beanName);\n        // 直接调用createBean(beanName, mbd, args)创建新bean\n        prototypeInstance = createBean(beanName, mbd, args);\n    }\n    finally {\n        // 删除原型模式 bean 之前的加载状态，后置处理\n        afterPrototypeCreation(beanName);\n    }\n    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n}\n```\n* 原型模式下的初始化过程比较简单，与单例模式下的主要区别就是没有在缓存中获取，而是直接调用`createBean(beanName, mbd, args)`创建新`bean`，并在创建前记录原型模式下正在创建 `bean`，使用`ThreadLocal<Object> prototypesCurrentlyInCreation`进行存放，创建完成之后就销毁，这个变量在`isPrototypeCurrentlyInCreation(beanName)`方法中使用，检查是否是原型模式下存在循环依赖情况 \n\n### 3、指定的scope上实例化bean\n       \n* 上代码\n\n```java\nelse {\n    // 指定的scope上实例化bean\n    String scopeName = mbd.getScope();\n    final Scope scope = this.scopes.get(scopeName);\n    if (scope == null) {\n        throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n    }\n    try {\n        Object scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n            @Override\n            public Object getObject() throws BeansException {\n                beforePrototypeCreation(beanName);\n                try {\n                    return createBean(beanName, mbd, args);\n                }\n                finally {\n                    afterPrototypeCreation(beanName);\n                }\n            }\n        });\n        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n    }\n    catch (IllegalStateException ex) {\n        throw new BeanCreationException(beanName,\n                \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n                \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n                ex);\n    }\n}\n```\n\n* 核心流程和原型模式一样，只不过获取 `bean` 实例是由 `Scope#get(String name, ObjectFactory<?> objectFactory)` 方法来实现。\n    * 指定的`scope`上实例化`bean`，分为`request`（HTTP请求）、`session`（会话）、`global-session`（全局会话）\n        * `org.springframework.web.context.request.RequestScope`\n            * 代码\n            ```java\n            public class RequestScope extends AbstractRequestAttributesScope {\n            \n                @Override\n                protected int getScope() {\n                    return RequestAttributes.SCOPE_REQUEST;\n                }\n            \n                @Override\n                public String getConversationId() {\n                    return null;\n                }\n            \n            }\n            ```\n        * `org.springframework.web.context.request.SessionScope`\n            * 代码\n            ```java\n            public class SessionScope extends AbstractRequestAttributesScope {\n            \n            \tprivate final int scope;\n       \n            \tpublic SessionScope() {\n            \t\tthis.scope = RequestAttributes.SCOPE_SESSION;\n            \t}\n \n            \tpublic SessionScope(boolean globalSession) {\n            \t\tthis.scope = (globalSession ? RequestAttributes.SCOPE_GLOBAL_SESSION : RequestAttributes.SCOPE_SESSION);\n            \t}\n            \n            \n            \t@Override\n            \tprotected int getScope() {\n            \t\treturn this.scope;\n            \t}\n            \n            \t@Override\n            \tpublic String getConversationId() {\n            \t\treturn RequestContextHolder.currentRequestAttributes().getSessionId();\n            \t}\n            \n            \t@Override\n            \tpublic Object get(String name, ObjectFactory<?> objectFactory) {\n            \t\tObject mutex = RequestContextHolder.currentRequestAttributes().getSessionMutex();\n            \t\tsynchronized (mutex) {\n            \t\t\treturn super.get(name, objectFactory);\n            \t\t}\n            \t}\n            \n            \t@Override\n            \tpublic Object remove(String name) {\n            \t\tObject mutex = RequestContextHolder.currentRequestAttributes().getSessionMutex();\n            \t\tsynchronized (mutex) {\n            \t\t\treturn super.remove(name);\n            \t\t}\n            \t}\n            \n            }\n            ```\n        * `AbstractRequestAttributesScope`是上面两个类的抽象实现类，可以看到里面的操作是通过`RequestContextHolder.currentRequestAttributes();`来获取当前线程属性集合，之后的操作就是对属性进行`get set`了，并通过子类实现`getScope()`方法来区分不同的`scope`\n        ```java\n        public abstract class AbstractRequestAttributesScope implements Scope {\n        \n            @Override\n            public Object get(String name, ObjectFactory<?> objectFactory) {\n                // 获取当前线程属性集合\n                RequestAttributes attributes = RequestContextHolder.currentRequestAttributes();\n                Object scopedObject = attributes.getAttribute(name, getScope());\n                if (scopedObject == null) {\n                    // 存放到RequestAttributes中\n                    scopedObject = objectFactory.getObject();\n                    attributes.setAttribute(name, scopedObject, getScope());\n                    // Retrieve object again, registering it for implicit session attribute updates.\n                    // As a bonus, we also allow for potential decoration at the getAttribute level.\n                    Object retrievedObject = attributes.getAttribute(name, getScope());\n                    if (retrievedObject != null) {\n                        // Only proceed with retrieved object if still present (the expected case).\n                        // If it disappeared concurrently, we return our locally created instance.\n                        scopedObject = retrievedObject;\n                    }\n                }\n                // 获取到直接返回\n                return scopedObject;\n            }\n        \n            @Override\n            public Object remove(String name) {\n                // 获取当前线程属性集合\n                RequestAttributes attributes = RequestContextHolder.currentRequestAttributes();\n                Object scopedObject = attributes.getAttribute(name, getScope());\n                if (scopedObject != null) {\n                    // 从RequestAttributes中移除\n                    attributes.removeAttribute(name, getScope());\n                    return scopedObject;\n                }\n                else {\n                    return null;\n                }\n            }\n        \n            @Override\n            public void registerDestructionCallback(String name, Runnable callback) {\n                RequestAttributes attributes = RequestContextHolder.currentRequestAttributes();\n                attributes.registerDestructionCallback(name, callback, getScope());\n            }\n        \n            @Override\n            public Object resolveContextualObject(String key) {\n                RequestAttributes attributes = RequestContextHolder.currentRequestAttributes();\n                return attributes.resolveReference(key);\n            }\n\n            protected abstract int getScope(); \n        }\n        ```\n## 总结\n* 单例模式的`bean`是通过一个`HashMap`缓存来实现的，原型模式下的`bean`都是每次新建调用的，指定scope模式下的`bean`是调用`Scope`接口的`get`方法来获取的\n* 如果存在循环依赖的情况，单例模式下`Spring`是通过`cache`的形式提早曝光创建的对象来处理循环依赖的，但原型模式下的`bean`都是新建的，所以无法`cache`\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(八)加载Bean之单例缓存中获取单例 Bean","url":"/2019/06/12/backend/framework/spring/analysis/Spring系列(八)加载Bean之单例缓存中获取单例 Bean/","content":"## 前言\n\n* 平常开发中我们知道`Spring`的`Bean`默认是单例模式，也就是说此`Bean`只会创建一次，然后每次调用都是获取的同一个`Bean`，那么`Spring`是怎么实现的呢？\n\n## 解析\n\n* 回到上一章节的的`doGetBean()`方法，关注`Object sharedInstance = getSingleton(beanName);` 方法，`sharedInstance` 见名知意(共享实例)，这个方法是从缓存中获取 `Bean`\n\n```java\n/**\n * 检查缓存中或者实例工厂中是否有对应的实例，为什么首先会使用这段代码呢\n *\n * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖\n * Spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactory提早曝光也就是\n * 将ObjectFactory加入缓存中，一旦下个bean创建的时候需要依赖上一个bean，则直接使用ObjectFactory\n */\n// Eagerly check singleton cache for manually registered singletons.\nObject sharedInstance = getSingleton(beanName);\n// 从缓存中获取 Bean 后，若其不为 null 且 args 为空\nif (sharedInstance != null && args == null) {\n    if (logger.isDebugEnabled()) {\n        if (isSingletonCurrentlyInCreation(beanName)) {\n            logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n                    \"' that is not fully initialized yet - a consequence of a circular reference\");\n        }\n        else {\n            logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n        }\n    }\n    /**\n     * 为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 Bean ，并不一定使我们最终想要的 Bean\n     * 返回对应的实例，有时候存在诸如BeanFactory的情况并不是直接返回实例本身而是返回指定方法返回的实例 比如工厂bean中定义的factory-method方法中返回的bean\n     */\n    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n}\n```\n\n* 进入`getSingleton(beanName)`方法，总体逻辑，就是根据 `beanNam` 依次检测这三个 `Map`，若为空，从下一个，否则返回，`singletonObjects` -> `earlySingletonObjects` -> `singletonFactories`\n\n```java\n/**\n * Cache of singleton objects: bean name --> bean instance\n * 存放的是单例 bean 的映射 一级缓存\n * */\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(256);\n\n/**\n * Cache of singleton factories: bean name --> ObjectFactory\n * 存放的是 ObjectFactory 三级缓存\n * */\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<String, ObjectFactory<?>>(16);\n\n/** Cache of early singleton objects: bean name --> bean instance\n * 提前暴光的单例对象的Cache 二级缓存\n *\n * 1、它与 {@link #singletonFactories} 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整。\n * 2、从 {@link #getSingleton(String)} 方法中，我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了。\n * 所以当在 bean 的创建过程中，就可以通过 getBean() 方法获取。\n * 3、这个 Map 也是【循环依赖】的关键所在。\n * */\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<String, Object>(16);\n\n/**\n * 根据 beanName 依次检测这三个 Map，若为空，检测下一个，否则返回\n * {@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects}\n * {@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#earlySingletonObjects}\n * {@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonFactories}\n *\n * Return the (raw) singleton object registered under the given name.\n * <p>Checks already instantiated singletons and also allows for an early\n * reference to a currently created singleton (resolving a circular reference).\n * @param beanName the name of the bean to look for\n * @param allowEarlyReference whether early references should be created or not\n * @return the registered singleton object, or {@code null} if none found\n */\nprotected Object getSingleton(String beanName, boolean allowEarlyReference) {\n    // 从单例缓冲中加载 bean\n    Object singletonObject = this.singletonObjects.get(beanName);\n    /**\n     * 缓存中的 bean 为空，且bean正在创建中\n     * 1、isSingletonCurrentlyInCreation 判断该 beanName 对应的 Bean 是否在创建过程中\n     *    查看private final Set<String> {@link singletonsCurrentlyInCreation) 是否有，该set记录了正在创建bean的beanName\n     */\n    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {\n        synchronized (this.singletonObjects) {\n            // 从 earlySingletonObjects 获取\n            singletonObject = this.earlySingletonObjects.get(beanName);\n            // earlySingletonObjects 中没有，且允许提前创建\n            if (singletonObject == null && allowEarlyReference) {\n                // 从 singletonFactories 中获取对应的 ObjectFactory\n                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);\n                if (singletonFactory != null) {\n                    singletonObject = singletonFactory.getObject();\n                    this.earlySingletonObjects.put(beanName, singletonObject);\n                    this.singletonFactories.remove(beanName);\n                }\n            }\n        }\n    }\n    return (singletonObject != NULL_OBJECT ? singletonObject : null);\n}\n\n```\n\n* 执行完`getSingleton`方法之后就是判断如果从缓存里获取到了`singletonObjects`且没有传入参数，那么就执行`getObjectForBeanInstance(sharedInstance, name, beanName, null);`方法了，该方法的定义为获取给定 `Bean` 实例的对象，该对象要么是 `Bean` 实例本身，要么就是 `FactoryBean` 创建的 `Bean` 对象。从下面的方法可以看到首先判断该实例是否实现了`FactoryBean`接口，如果不是那么直接返回该实例，下面的方法就是获取实现了`FactoryBean`接口的`Bean`实例了\n\n```java\n/**\n * 该方法的定义为获取给定 Bean 实例的对象，该对象要么是 bean 实例本身，要么就是 FactoryBean 创建的 Bean 对象。\n *\n * Get the object for the given bean instance, either the bean\n * instance itself or its created object in case of a FactoryBean.\n * @param beanInstance the shared bean instance\n * @param name name that may include factory dereference prefix\n * @param beanName the canonical bean name\n * @param mbd the merged bean definition\n * @return the object to expose for the bean\n */\nprotected Object getObjectForBeanInstance(\n        Object beanInstance, String name, String beanName, RootBeanDefinition mbd) {\n\n    // 校验 beanInstance 的正确性 如果指定的name是工厂相关(以&为前缀)且beanInstance又不是FactoryBean类型则验证不通过\n    // Don't let calling code try to dereference the factory if the bean isn't a factory.\n    if (BeanFactoryUtils.isFactoryDereference(name) && !(beanInstance instanceof FactoryBean)) {\n        throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());\n    }\n    // 如果 beanInstance 不为 FactoryBean 类型或者 name 也不是与工厂相关的，则直接返回 beanInstance 这个 Bean 对象\n    // 如果是 FactoryBean，我们则创建该 Bean\n    // Now we have the bean instance, which may be a normal bean or a FactoryBean.\n    // If it's a FactoryBean, we use it to create a bean instance, unless the\n    // caller actually wants a reference to the factory.\n    if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {\n        return beanInstance;\n    }\n\n    // 加载FactoryBean\n    Object object = null;\n    if (mbd == null) {\n        // 尝试从缓存中加载bean\n        object = getCachedObjectForFactoryBean(beanName);\n    }\n    // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean 。从而，使用 FactoryBean 获得 Bean 对象\n    if (object == null) {\n        // Return bean instance from factory.\n        // 到这里已经明确知道beanInstance一定是FactoryBean类型\n        FactoryBean<?> factory = (FactoryBean<?>) beanInstance;\n        // Caches object obtained from FactoryBean if it is a singleton. containsBeanDefinition 检测 beanDefinitionMap 中也就是在所有已经加载的类中\n        if (mbd == null && containsBeanDefinition(beanName)) {\n            mbd = getMergedLocalBeanDefinition(beanName);\n        }\n        // 是否是用户定义的，而不是应用程序本身定义的\n        boolean synthetic = (mbd != null && mbd.isSynthetic());\n        // 核心代码，使用 FactoryBean 获得 Bean 对象\n        object = getObjectFromFactoryBean(factory, beanName, !synthetic);\n    }\n    return object;\n}\n```\n\n* 使用 `FactoryBean` 获得 `Bean` 对象之前先来说明下`FactoryBean`一些概念\n    * `FactoryBean` 解析\n        * 从下面代码可以看到这个接口只有三个方法，重点是`getObject()`方法\n        ```java\n        public interface FactoryBean<T> {\n \n            T getObject() throws Exception;\n\n            Class<?> getObjectType();\n        \n            boolean isSingleton();\n        }\n        ```\n        *  一般情况下，`Spring`通过反射机制利用`<bean>`的`class`属性指定实现类实例化`Bean`，在某些情况下，实例化`Bean`过程比较复杂，如果按照传统的方式，则需要在`<bean>`中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。`Spring`为此提供了一个`org.springframework.bean.factory.FactoryBean`的工厂类接口，用户可以通过实现该接口定制实例化`Bean`的逻辑。`FactoryBean`接口对于`Spring`框架来说占用重要的地位，`Spring`自身就提供了70多个`FactoryBean`的实现。\n        * `FactoryBean`是一个接口，当在`IOC`容器中的`Bean`实现了`FactoryBean`后，通过`getBean(String BeanName)`获取到的`Bean`对象并不是`FactoryBean`的实现类对象，而是这个实现类中的`getObject()`方法返回的对象。要想获取`FactoryBean`的实现类，就要`getBean(&BeanName)`，在`BeanName`之前加上`&`。\n\n* 由上面可以知道要获取 `FactoryBean` 实例直接调用`getObject()`方法就是了，继续跟进方法`object = getObjectFromFactoryBean(factory, beanName, !synthetic);`，此方法可以看到这里又做了个`Map<String, Object> factoryBeanObjectCache`缓存的处理，如果有就直接`get`，如果没有就`new`然后`put`\n\n```java\n/**\n * Obtain an object to expose from the given FactoryBean.\n * @param factory the FactoryBean instance\n * @param beanName the name of the bean\n * @param shouldPostProcess whether the bean is subject to post-processing\n * @return the object obtained from the FactoryBean\n * @throws BeanCreationException if FactoryBean object creation failed\n * @see org.springframework.beans.factory.FactoryBean#getObject()\n */\nprotected Object getObjectFromFactoryBean(FactoryBean<?> factory, String beanName, boolean shouldPostProcess) {\n    // 如果是单例模式且缓存中存在\n    if (factory.isSingleton() && containsSingleton(beanName)) {\n        // 同步锁，锁住的对象都是 this.singletonObjects，主要是因为在单例模式中必须要保证全局唯一\n        synchronized (getSingletonMutex()) {\n            // 从缓存中获取指定的 factoryBean\n            Object object = this.factoryBeanObjectCache.get(beanName);\n            if (object == null) {\n                // 继续跟进，为空，则从 FactoryBean 中获取对象\n                object = doGetObjectFromFactoryBean(factory, beanName);\n                // Only post-process and store if not put there already during getObject() call above\n                // (e.g. because of circular reference processing triggered by custom getBean calls)\n                Object alreadyThere = this.factoryBeanObjectCache.get(beanName);\n                if (alreadyThere != null) {\n                    object = alreadyThere;\n                }\n                else {\n                    if (object != null && shouldPostProcess) {\n                        try {\n                            // 对从 FactoryBean 获取的对象进行后处理后处理器\n                            object = postProcessObjectFromFactoryBean(object, beanName);\n                        }\n                        catch (Throwable ex) {\n                            throw new BeanCreationException(beanName,\n                                    \"Post-processing of FactoryBean's singleton object failed\", ex);\n                        }\n                    }\n                    // 添加到 factoryBeanObjectCache 中，进行缓存\n                    this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT));\n                }\n            }\n            return (object != NULL_OBJECT ? object : null);\n        }\n    }\n    else {\n        // 为空，则从 FactoryBean 中获取对象\n        Object object = doGetObjectFromFactoryBean(factory, beanName);\n        // 需要后续处理\n        if (object != null && shouldPostProcess) {\n            try {\n                // 对从 FactoryBean 获取的对象进行后处理后处理器\n                object = postProcessObjectFromFactoryBean(object, beanName);\n            }\n            catch (Throwable ex) {\n                throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex);\n            }\n        }\n        return object;\n    }\n}\n```\n\n* `getObjectFromFactoryBean(factory, beanName, !synthetic)` 功能点分析\n    * `object = doGetObjectFromFactoryBean(factory, beanName);` 从 `FactoryBean` 中获取对象\n        * 看代码，这里是直接调用了`object = factory.getObject();`方法，是不是很简单\n        ```java\n        /**\n         * 如果Bean实现了FactoryBean后，通过getBean(String BeanName)\n         * 获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。\n         *\n         * Obtain an object to expose from the given FactoryBean.\n         * @param factory the FactoryBean instance\n         * @param beanName the name of the bean\n         * @return the object obtained from the FactoryBean\n         * @throws BeanCreationException if FactoryBean object creation failed\n         * @see org.springframework.beans.factory.FactoryBean#getObject()\n         */\n        private Object doGetObjectFromFactoryBean(final FactoryBean<?> factory, final String beanName)\n                throws BeanCreationException {\n    \n            Object object;\n            try {\n                // 需要权限验证\n                if (System.getSecurityManager() != null) {\n                    AccessControlContext acc = getAccessControlContext();\n                    try {\n                        object = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\n                            @Override\n                            public Object run() throws Exception {\n                                    return factory.getObject();\n                                }\n                            }, acc);\n                    }\n                    catch (PrivilegedActionException pae) {\n                        throw pae.getException();\n                    }\n                }\n                else {\n                    // 直接调用getObject方法\n                    object = factory.getObject();\n                }\n            }\n            catch (FactoryBeanNotInitializedException ex) {\n                throw new BeanCurrentlyInCreationException(beanName, ex.toString());\n            }\n            catch (Throwable ex) {\n                throw new BeanCreationException(beanName, \"FactoryBean threw exception on object creation\", ex);\n            }\n    \n            // Do not accept a null value for a FactoryBean that's not fully\n            // initialized yet: Many FactoryBeans just return null then.\n            if (object == null && isSingletonCurrentlyInCreation(beanName)) {\n                throw new BeanCurrentlyInCreationException(\n                        beanName, \"FactoryBean which is currently in creation returned null from getObject\");\n            }\n            return object;\n        }\n        ```\n    * `object = postProcessObjectFromFactoryBean(object, beanName);`对从 FactoryBean 获取的对象进行后处理后处理器\n        * 看代码，直接调用`BeanPostProcessor`的`postProcessAfterInitialization`方法，执行`bean`初始化后的方法逻辑\n        ```java\n        @Override\n        public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n                throws BeansException {\n    \n            Object result = existingBean;\n            // 实现 BeanPostProcessor 接口用户可以根据自己的业务需求进行响应的处理\n            for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {\n                result = beanProcessor.postProcessAfterInitialization(result, beanName);\n                if (result == null) {\n                    return result;\n                }\n            }\n            return result;\n        }\n        ```\n    * 我们可以利用这个特性将`bean`实现`BeanPostProcessor`接口，实际开发过程中大可以利用这个方法设计自己的业务逻辑。\n    * \n    ```java\n    /**\n     * 定义bean初始化之和初始化之后分别调用的的方法\n     *\n     * BeanFactory钩子，允许对新建的bean进行自定义修改，eg：检查是否有标记接口或者需要代理bean如果有的话做对应的操作\n     */\n    public interface BeanPostProcessor {\n\n        Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;\n\n        Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;\n    }\n    ```\n        \n* 至此，从缓存中获取 `Bean`对象过程已经分析完毕了。\n\n## 总结\n* `Spring`的单例`bean`是使用`HashMap`来实现的，用户可以通过实现`FactoryBean`接口定制实例化`Bean`的逻辑，又体现了`Spring`的灵活性\n* 用户可以实现`BeanPostProcessor`接口进行业务定制化\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(七)加载Bean之doGetBean方法","url":"/2019/06/12/backend/framework/spring/analysis/Spring系列(七)加载Bean之doGetBean方法/","content":"## 前言\n* 经过容器初始化阶段后，应用程序中定义的 `bean` 信息（`BeanDefinition` ）已经全部加载到系统中了，当我们显示或者隐式地调用 `BeanFactory#getBean(...)` 方法时，则会触发加载 `Bean` 阶段。\n\n* 在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 Bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。\n\n* 下面的章节将会介绍加载`Bean`的过程，仓库里有货了就应该让它发挥作用\n\n## 解析\n\n* 调用 `BeanFactory#getBean(...)` 方法\n\n```java\n// AbstractBeanFactory.java\n\n@Override\npublic Object getBean(String name) throws BeansException {\n\treturn doGetBean(name, null, null, false);\n}\n```\n\n* 内部调用 `doGetBean(String name, final Class<T> requiredType, Object[] args, boolean typeCheckOnly)` 下面是代码主体\n\n```java\n\t/**\n\t * doGetBean统一入口\n\t *\n\t * Return an instance, which may be shared or independent, of the specified bean.\n\t * @param name the name of the bean to retrieve\t\t\t\t\t\t\t\t\t\t\t\t要获取 Bean 的名字\n\t * @param requiredType the required type of the bean to retrieve \t\t\t\t\t\t\t要获取 bean 的类型\n\t * @param args arguments to use when creating a bean instance using explicit arguments \t\t创建 Bean 时传递的参数。这个参数仅限于创建 Bean 时使用。\n\t * (only applied when creating a new instance as opposed to retrieving an existing one)\n\t * @param typeCheckOnly whether the instance is obtained for a type check, \t\t\t\t\t是否为类型检查。\n\t * not for actual use\n\t * @return an instance of the bean\n\t * @throws BeansException if the bean could not be created\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected <T> T doGetBean(\n\t\t\tfinal String name, final Class<T> requiredType, final Object[] args, boolean typeCheckOnly)\n\t\t\tthrows BeansException {\n\t\t/**\n\t\t * 提取对应的beanName， 这里传递的是 name 方法，不一定就是 beanName，可能是 aliasName\n\t\t * 也有可能是 FactoryBean FactoryBean会带上&符号，\n\t\t */\n\t\tfinal String beanName = transformedBeanName(name);\n\t\tObject bean;\n\t\t/**\n\t\t * 检查缓存中或者实例工厂中是否有对应的实例，为什么首先会使用这段代码呢\n\t\t *\n\t\t * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖\n\t\t * Spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactory提早曝光也就是\n\t\t * 将ObjectFactory加入缓存中，一旦下个bean创建的时候需要依赖上一个bean，则直接使用ObjectFactory\n\t\t */\n\t\t// Eagerly check singleton cache for manually registered singletons.\n\t\tObject sharedInstance = getSingleton(beanName);\n\t\t// 从缓存中获取 Bean 后，若其不为 null 且 args 为空\n\t\tif (sharedInstance != null && args == null) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\tlogger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n\t\t\t\t\t\t\t\"' that is not fully initialized yet - a consequence of a circular reference\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\t * 为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 Bean ，并不一定使我们最终想要的 Bean\n\t\t\t * 返回对应的实例，有时候存在诸如BeanFactory的情况并不是直接返回实例本身而是返回指定方法返回的实例 比如工厂bean中定义的factory-method方法中返回的bean\n\t\t\t */\n\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t\t}\n\t\telse { // 在缓存中没有\n\t\t\n\t\t\t// 只有单例情况下才会尝试解决循依赖（如果存在A中有B属性，B中有A属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次创建A，造成循环依赖）\n\t\t\t// 在原型模式下如果存在循环依赖则会抛出异常。\n\t\t\t// Fail if we're already creating this bean instance:\n\t\t\t// We're assumably within a circular reference.\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\n\t\t\t// Check if bean definition exists in this factory.\n\t\t\t// 判断工厂中是否含有此Bean的定义，如果没有找到则父类容器里找\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\t// 如果beanDefinitionMap中也就是在所有已经加载的类中不包括beanName，则尝试从parentBeanFactory中检测\n\t\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t\t// Not found -> check parent. 如果没有，查询父工厂\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\t// 递归到BeanFactory中寻找 递归调用getBean方法\n\t\t\t\tif (args != null) {\n\t\t\t\t\t// Delegation to parent with explicit args.  执行带有args参数的getbean方法\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// No args -> delegate to standard getBean method. 如果没有参数，执行标准的getbean方法\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 如果不是仅仅做类型检查则是创建bean，这里要进行记录\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t// 将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition，\n\t\t\t\t// 如果指定BeanName是子Bean的话同时会合并父类的相关属性\n\t\t\t\tfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\t// 检查给定的合并的 BeanDefinition\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t// 处理所依赖的 bean\n\t\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\t// 若存在依赖则需要递归实例化依赖的bean，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// 缓存依赖调用\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * 递归处理依赖 Bean\n\t\t\t\t\t\t * 每个 Bean 都不是单独工作的，它会依赖其他 Bean，其他 Bean 也会依赖它。\n\t\t\t\t\t\t * 对于依赖的 Bean ，它会优先加载，所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Create bean instance. 重头戏\n\t\t\t\t// 单例模式的实例化bean\n\t\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t\t// 获取实例了\n\t\t\t\t\tsharedInstance = getSingleton(beanName, new ObjectFactory<Object>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Object getObject() throws BeansException {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t// 创建bean\n\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\t\t\t// 显式从单例缓存中删除 Bean 实例，因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它\n\t\t\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\t\t\t\t// 原型模式的实例化bean\n\t\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t\t// It's a prototype -> create a new instance.\n\t\t\t\t\tObject prototypeInstance = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tbean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\t// 指定的scope上实例化bean\n\t\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\t\tfinal Scope scope = this.scopes.get(scopeName);\n\t\t\t\t\tif (scope == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject scopedInstance = scope.get(beanName, new ObjectFactory<Object>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic Object getObject() throws BeansException {\n\t\t\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n\t\t\t\t\t\t\t\t\"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n\t\t\t\t\t\t\t\tex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * 检查需要的类型是否符合bean的实际类型 Check if required type matches the type of the actual bean instance.\n\t\t * 当然就一般而言，我们是不需要进行类型转换的，也就是 requiredType 为空（比如 #getBean(String name) 方法）。\n\t\t * 但有，可能会存在这种情况，比如我们返回的 Bean 类型为 String ，我们在使用的时候需要将其转换为 Integer，\n\t\t * 那么这个时候 requiredType 就有用武之地了。当然我们一般是不需要这样做的。\n\t\t */\n\t\tif (requiredType != null && bean != null && !requiredType.isAssignableFrom(bean.getClass())) {\n\t\t\ttry {\n\t\t\t\t// 执行转换\n\t\t\t\treturn getTypeConverter().convertIfNecessary(bean, requiredType);\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" +\n\t\t\t\t\t\t\tClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n\t\t\t\t}\n\t\t\t\t// 转换失败，抛出 BeanNotOfRequiredTypeException 异常\n\t\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t\t}\n\t\t}\n\t\treturn (T) bean;\n\t}\n```\n\n* \n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(六)装载BeanDefinition总结","url":"/2019/06/11/backend/framework/spring/analysis/Spring系列(六)装载BeanDefinition总结/","content":"## 前言\n* 调试代码\n\n```java\npublic class ClassPathXmlApplicationContextTest {\n    @Test\n    public void classPathXmlApplicationContext () {\n        ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\");\n        User user = xmlApplicationContext.getBean(User.class);\n    }\n}\n```\n\n* 前面的第二节到第五节分析了 `IoC BeanDefinition` 装载的整个过程，这篇就这些内容做一个总结将其连贯起来。`IoC` 容器的初始化过程分为三步骤`Resource` 定位、`BeanDefinition` 的装载，`BeanDefinition`解析及注册。\n\n### Resource 定位\n* 我们一般用外部资源来描述 `Bean` 对象，所以在初始化 `IoC` 容器的第一步就是需要定位这个外部资源。\n* 上面的调试代码`new ClassPathXmlApplicationContext(\"beans/bean.xml\");`中我们传入了配置文件的一个路径，然后`Spring`就是通过这个路径使用`ResourceLoader`来找到对应的`Resource`\n\n```xml\npublic int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {\n    ResourceLoader resourceLoader = getResourceLoader();\n    if (resourceLoader == null) {\n        throw new BeanDefinitionStoreException(\n                \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n    }\n\n    if (resourceLoader instanceof ResourcePatternResolver) {\n        // Resource pattern matching available.\n        try {\n            // 通过`ResourceLoader`来用这个路径找到对应的`Resource`\n            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n```\n        \n### BeanDefinition 的装载\n\n* 上一步已经得到了`Resource`了，现在就是装载，这个过程使用`XmlBeanDefinitionReader`来完成解析，可以看到`InputStream inputStream = encodedResource.getResource().getInputStream();` 通过`Resource`对象直接获取到了`InputStream`\n\n```java\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n    Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n    if (logger.isInfoEnabled()) {\n        logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource());\n    }\n    // 通过属性来记录已经加载的资源\n    Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();\n    if (currentResources == null) {\n        currentResources = new HashSet<EncodedResource>(4);\n        this.resourcesCurrentlyBeingLoaded.set(currentResources);\n    }\n    if (!currentResources.add(encodedResource)) {\n        throw new BeanDefinitionStoreException(\n                \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n    }\n    try {\n        // 获取输入流\n        InputStream inputStream = encodedResource.getResource().getInputStream();\n        try {\n            // 构造 InputSource ，此类不是Spring的类\n            InputSource inputSource = new InputSource(inputStream);\n            if (encodedResource.getEncoding() != null) {\n                inputSource.setEncoding(encodedResource.getEncoding());\n            }\n            // 逻辑核心部分\n            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n```\n\n* 得到`InputStream`之后就是解析了，就是这个方法`doLoadBeanDefinitions(inputSource, encodedResource.getResource());`来获取到`Document doc`对象，这个是要下一步需要\n\n###  BeanDefinition 解析及注册。\n\n#### 解析\n* 上一步已经得到了`Document doc`，现在就是需要将它解析得到`BeanDefinition`，这个工作由 `BeanDefinitionDocumentReader`来实现\n\n#### 注册\n\n* 在 `IoC` 容器内部维护着一个 `BeanDefinition Map` 的数据结构，这里的`IoC` 容器是`DefaultListableBeanFactory`，在配置文件中每一个`bean`都对应着一个 `BeanDefinition` 对象，注册工作就是将`BeanDefinition` `put`到容器的`map`中，这个过程是通过 `BeanDefinitionRegistry` 接口来实现的。,`DefaultListableBeanFactory`实现了这个接口\n\n```java\n// DefaultListableBeanFactory.java\n@Override\npublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n        throws BeanDefinitionStoreException {\n    // ...省略校验相关的代码\n    // 从缓存中获取指定 beanName 的 BeanDefinition\n    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);\n    // 如果已经存在\n    if (existingDefinition != null) {\n        // 如果存在但是不允许覆盖，抛出异常\n        if (!isAllowBeanDefinitionOverriding()) {\n             throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);\n        } else {\n           // ...省略 logger 打印日志相关的代码\n        }\n        // 【重点】允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。\n        this.beanDefinitionMap.put(beanName, beanDefinition);\n    // 如果未存在\n    } else {\n        // ... 省略非核心的代码\n        // 【重点】添加到 BeanDefinition 到 beanDefinitionMap 中。\n        this.beanDefinitionMap.put(beanName, beanDefinition);\n    }\n    // 重新设置 beanName 对应的缓存\n    if (existingDefinition != null || containsSingleton(beanName)) {\n        resetBeanDefinition(beanName);\n    }\n}\n```\n* 在 `IoC` 容器内部其实是将解析得到的 `BeanDefinition` 注入到一个` HashMap` 容器中，`IoC` 容器就是通过这个 `HashMap` 来维护这些 `BeanDefinition` 的。\n\n\n\n## 总结\n* 在这里需要注意的一点是这个过程并没有完成依赖注入`Bean `创建），`Bean` 创建是发生在应用第一次调用 `#getBean(...)` 方法，向容器索要 `Bean` 时。当然我们可以通过设置预处理，即对某个 `Bean` 设置 `lazyinit = false` 属性，那么这个 `Bean` 的依赖注入就会在容器初始化的时候完成。\n* 整体时序图如下: 红框部分，就是 BeanDefinition 的解析过程\n![](/images/server/spring/analysis/spring-201807201001.png)\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(五)Document读取器BeanDefinitionDocumentReader","url":"/2019/06/09/backend/framework/spring/analysis/Spring系列(五)Document读取器BeanDefinitionDocumentReader/","content":"## 前言\n* 回顾上一章节的内容，在`XmlBeanDefinitionReader`中已经获取了`Document doc`，那么需要将`Document doc`对象解析成`BeanDefinition`，这里`Document`读取器`BeanDefinitionDocumentReader`就开始上场表演了\n\n```java\n/**\n * Register the bean definitions contained in the given DOM document.\n * Called by {@code loadBeanDefinitions}.\n * <p>Creates a new instance of the parser class and invokes\n * {@code registerBeanDefinitions} on it.\n * @param doc the DOM document\n * @param resource the resource descriptor (for context information)\n * @return the number of bean definitions found\n * @throws BeanDefinitionStoreException in case of parsing errors\n * @see #loadBeanDefinitions\n * @see #setDocumentReaderClass\n * @see BeanDefinitionDocumentReader#registerBeanDefinitions\n */\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n    /**\n     * 使用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader，在实例化BeanDefinitionDocumentReader的时候会将\n     *\n     * @see DefaultBeanDefinitionDocumentReader\n     *\n     */\n    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n    // 记录统计前的BeanDefinition的加载个数\n    int countBefore = getRegistry().getBeanDefinitionCount();\n    // 加载并注册bean\n    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n    return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n```\n \n* `BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();`这里获取的是`DefaultBeanDefinitionDocumentReader`类，此类是`BeanDefinitionDocumentReader`接口的唯一实现类\n    * `createReaderContext(resource)` 方法将我们的上一章节`XmlBeanDefinitionReader`对象放在了一个新的对象`XmlReaderContext`中，注意下面的`this`指针\n        ```java\n        /**\n         * Create the {@link XmlReaderContext} to pass over to the document reader.\n         */\n        public XmlReaderContext createReaderContext(Resource resource) {\n            return new XmlReaderContext(resource, this.problemReporter, this.eventListener,\n                    this.sourceExtractor, this, getNamespaceHandlerResolver());\n        }\n        ```\n    * `BeanDefinitionDocumentReader`定义了读取` Document` 并注册为BeanDefinition功能，里面只有一个方法`void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)`\n    * ![](/images/server/spring/analysis/DefaultBeanDefinitionDocumentReader.png)\n    * `DefaultBeanDefinitionDocumentReader` 属性：可以看到我们熟悉的`xml`配置标签名\n    ```java\n    public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader {\n    \n        public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT;\n    \n        public static final String NESTED_BEANS_ELEMENT = \"beans\";\n    \n        public static final String ALIAS_ELEMENT = \"alias\";\n    \n        public static final String NAME_ATTRIBUTE = \"name\";\n    \n        public static final String ALIAS_ATTRIBUTE = \"alias\";\n    \n        public static final String IMPORT_ELEMENT = \"import\";\n    \n        public static final String RESOURCE_ATTRIBUTE = \"resource\";\n    \n        public static final String PROFILE_ATTRIBUTE = \"profile\";\n    \n    \n        protected final Log logger = LogFactory.getLog(getClass());\n    \n        private XmlReaderContext readerContext;\n    \n        private BeanDefinitionParserDelegate delegate;\n    ```\n    * 上面可以看到里面有个`BeanDefinitionParserDelegate`类，这个类是`BeanDefinition`解析方法，里面是解析`Element`的各种方法，从成员变量中可以看到`xml`标签名及属性名\n    ```java\n    public class BeanDefinitionParserDelegate {\n    \n        public static final String BEANS_NAMESPACE_URI = \"http://www.springframework.org/schema/beans\";\n    \n        public static final String MULTI_VALUE_ATTRIBUTE_DELIMITERS = \",; \";\n    \n        /**\n         * Value of a T/F attribute that represents true.\n         * Anything else represents false. Case seNsItive.\n         */\n        public static final String TRUE_VALUE = \"true\";\n    \n        public static final String FALSE_VALUE = \"false\";\n    \n        public static final String DEFAULT_VALUE = \"default\";\n    \n        public static final String DESCRIPTION_ELEMENT = \"description\";\n    \n        public static final String AUTOWIRE_NO_VALUE = \"no\";\n    \n        public static final String AUTOWIRE_BY_NAME_VALUE = \"byName\";\n    \n        public static final String AUTOWIRE_BY_TYPE_VALUE = \"byType\";\n    \n        public static final String AUTOWIRE_CONSTRUCTOR_VALUE = \"constructor\";\n    \n        public static final String AUTOWIRE_AUTODETECT_VALUE = \"autodetect\";\n    \n        public static final String DEPENDENCY_CHECK_ALL_ATTRIBUTE_VALUE = \"all\";\n    \n        public static final String DEPENDENCY_CHECK_SIMPLE_ATTRIBUTE_VALUE = \"simple\";\n    \n        public static final String DEPENDENCY_CHECK_OBJECTS_ATTRIBUTE_VALUE = \"objects\";\n    \n        public static final String NAME_ATTRIBUTE = \"name\";\n    \n        public static final String BEAN_ELEMENT = \"bean\";\n    \n        public static final String META_ELEMENT = \"meta\";\n    \n        public static final String ID_ATTRIBUTE = \"id\";\n    \n        public static final String PARENT_ATTRIBUTE = \"parent\";\n    \n        public static final String CLASS_ATTRIBUTE = \"class\";\n    \n        public static final String ABSTRACT_ATTRIBUTE = \"abstract\";\n    \n        public static final String SCOPE_ATTRIBUTE = \"scope\";\n    \n        private static final String SINGLETON_ATTRIBUTE = \"singleton\";\n    \n        public static final String LAZY_INIT_ATTRIBUTE = \"lazy-init\";\n    \n        public static final String AUTOWIRE_ATTRIBUTE = \"autowire\";\n    \n        public static final String AUTOWIRE_CANDIDATE_ATTRIBUTE = \"autowire-candidate\";\n    \n        public static final String PRIMARY_ATTRIBUTE = \"primary\";\n    \n        public static final String DEPENDENCY_CHECK_ATTRIBUTE = \"dependency-check\";\n    \n        public static final String DEPENDS_ON_ATTRIBUTE = \"depends-on\";\n    \n        public static final String INIT_METHOD_ATTRIBUTE = \"init-method\";\n    \n        public static final String DESTROY_METHOD_ATTRIBUTE = \"destroy-method\";\n    \n        public static final String FACTORY_METHOD_ATTRIBUTE = \"factory-method\";\n    \n        public static final String FACTORY_BEAN_ATTRIBUTE = \"factory-bean\";\n    \n        public static final String CONSTRUCTOR_ARG_ELEMENT = \"constructor-arg\";\n    \n        public static final String INDEX_ATTRIBUTE = \"index\";\n    \n        public static final String TYPE_ATTRIBUTE = \"type\";\n    \n        public static final String VALUE_TYPE_ATTRIBUTE = \"value-type\";\n    \n        public static final String KEY_TYPE_ATTRIBUTE = \"key-type\";\n    \n        public static final String PROPERTY_ELEMENT = \"property\";\n    \n        public static final String REF_ATTRIBUTE = \"ref\";\n    \n        public static final String VALUE_ATTRIBUTE = \"value\";\n    \n        public static final String LOOKUP_METHOD_ELEMENT = \"lookup-method\";\n    \n        public static final String REPLACED_METHOD_ELEMENT = \"replaced-method\";\n    \n        public static final String REPLACER_ATTRIBUTE = \"replacer\";\n    \n        public static final String ARG_TYPE_ELEMENT = \"arg-type\";\n    \n        public static final String ARG_TYPE_MATCH_ATTRIBUTE = \"match\";\n    \n        public static final String REF_ELEMENT = \"ref\";\n    \n        public static final String IDREF_ELEMENT = \"idref\";\n    \n        public static final String BEAN_REF_ATTRIBUTE = \"bean\";\n    \n        public static final String LOCAL_REF_ATTRIBUTE = \"local\";\n    \n        public static final String PARENT_REF_ATTRIBUTE = \"parent\";\n    \n        public static final String VALUE_ELEMENT = \"value\";\n    \n        public static final String NULL_ELEMENT = \"null\";\n    \n        public static final String ARRAY_ELEMENT = \"array\";\n    \n        public static final String LIST_ELEMENT = \"list\";\n    \n        public static final String SET_ELEMENT = \"set\";\n    \n        public static final String MAP_ELEMENT = \"map\";\n    \n        public static final String ENTRY_ELEMENT = \"entry\";\n    \n        public static final String KEY_ELEMENT = \"key\";\n    \n        public static final String KEY_ATTRIBUTE = \"key\";\n    \n        public static final String KEY_REF_ATTRIBUTE = \"key-ref\";\n    \n        public static final String VALUE_REF_ATTRIBUTE = \"value-ref\";\n    \n        public static final String PROPS_ELEMENT = \"props\";\n    \n        public static final String PROP_ELEMENT = \"prop\";\n    \n        public static final String MERGE_ATTRIBUTE = \"merge\";\n    \n        public static final String QUALIFIER_ELEMENT = \"qualifier\";\n    \n        public static final String QUALIFIER_ATTRIBUTE_ELEMENT = \"attribute\";\n    \n        public static final String DEFAULT_LAZY_INIT_ATTRIBUTE = \"default-lazy-init\";\n    \n        public static final String DEFAULT_MERGE_ATTRIBUTE = \"default-merge\";\n    \n        public static final String DEFAULT_AUTOWIRE_ATTRIBUTE = \"default-autowire\";\n    \n        public static final String DEFAULT_DEPENDENCY_CHECK_ATTRIBUTE = \"default-dependency-check\";\n    \n        public static final String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = \"default-autowire-candidates\";\n    \n        public static final String DEFAULT_INIT_METHOD_ATTRIBUTE = \"default-init-method\";\n    \n        public static final String DEFAULT_DESTROY_METHOD_ATTRIBUTE = \"default-destroy-method\";\n    \n    \n        protected final Log logger = LogFactory.getLog(getClass());\n    \n        private final XmlReaderContext readerContext;\n    \n        private final DocumentDefaultsDefinition defaults = new DocumentDefaultsDefinition();\n    \n        private final ParseState parseState = new ParseState();\n    \n        /**\n         * Stores all used bean names so we can enforce uniqueness on a per\n         * beans-element basis. Duplicate bean ids/names may not exist within the\n         * same level of beans element nesting, but may be duplicated across levels.\n         */\n        private final Set<String> usedNames = new HashSet<String>();\n\n    ```\n* 跟进`documentReader.registerBeanDefinitions(doc, createReaderContext(resource));`方法，可以看到将`XmlReaderContext readerContext`对象放到了`DefaultBeanDefinitionDocumentReader`的 `private XmlReaderContext readerContext;`成员对象中，这个是`BeanDefinitionDocumentReader`与`XmlBeanDefinitionReader`进行互通的纽带\n```java\n/**\n * This implementation parses bean definitions according to the \"spring-beans\" XSD\n * (or DTD, historically).\n * <p>Opens a DOM Document; then initializes the default settings\n * specified at the {@code <beans/>} level; then parses the contained bean definitions.\n */\n@Override\npublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {\n    this.readerContext = readerContext;\n    logger.debug(\"Loading bean definitions\");\n    Element root = doc.getDocumentElement();\n    // 核心逻辑，真正的开始解析了\n    doRegisterBeanDefinitions(root);\n}\n/**\n * Register each bean definition within the given root {@code <beans/>} element.\n */\nprotected void doRegisterBeanDefinitions(Element root) {\n    // Any nested <beans> elements will cause recursion in this method. In\n    // order to propagate and preserve <beans> default-* attributes correctly,\n    // keep track of the current (parent) delegate, which may be null. Create\n    // the new (child) delegate with a reference to the parent for fallback purposes,\n    // then ultimately reset this.delegate back to its original (parent) reference.\n    // this behavior emulates a stack of delegates without actually necessitating one.\n    BeanDefinitionParserDelegate parent = this.delegate;\n    this.delegate = createDelegate(getReaderContext(), root, parent);\n\n    if (this.delegate.isDefaultNamespace(root)) {\n        // 检查是否定义了profile属性，如果定义了需要到环境变量中找，利用这个特性我们可以在配置文件中部署不同的环境\n        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);\n        if (StringUtils.hasText(profileSpec)) {\n            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(\n                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec +\n                            \"] not matching: \" + getReaderContext().getResource());\n                }\n                return;\n            }\n        }\n    }\n    // 解析前处理，留给子类实现\n    preProcessXml(root);\n    // 解析并注册BeBeanDefinitions\n    parseBeanDefinitions(root, this.delegate);\n    // 解析后处理，留给子类实现\n    postProcessXml(root);\n\n    this.delegate = parent;\n}\n```\n* 进入`parseBeanDefinitions(root, this.delegate);`方法，这里分为默认标签解析及自定义标签解析\n```java\n/**\n * Parse the elements at the root level in the document:\n * \"import\", \"alias\", \"bean\".\n * @param root the DOM root element of the document\n */\nprotected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {\n    // 如果是默认命名空间 xmlns=\"http://www.springframework.org/schema/beans\"\n    if (delegate.isDefaultNamespace(root)) {\n        NodeList nl = root.getChildNodes();\n        for (int i = 0; i < nl.getLength(); i++) {\n            Node node = nl.item(i);\n            if (node instanceof Element) {\n                Element ele = (Element) node;\n                // 默认标签解析 如<bean class=\"\"/>\n                if (delegate.isDefaultNamespace(ele)) {\n                    parseDefaultElement(ele, delegate);\n                }\n                else { // 自定义标签解析 如：<context:component-scan base-package = \"*\"/>\n                    delegate.parseCustomElement(ele);\n                }\n            }\n        }\n    }\n    else {// 自定义标签解析\n        delegate.parseCustomElement(root);\n    }\n}\n```\n* `delegate.isDefaultNamespace(root)` 方法用于区分是使用默认标签解析还是自定义标签解析，由下面代码可以看到是获取了`Node`标签的命名间`URI`然后再与`\"http://www.springframework.org/schema/beans\"`字符串进行比较，可以看到如果相等的话就是默认标签了\n    * `isDefaultNamespace(root)`方法\n    ```java\n    public static final String BEANS_NAMESPACE_URI = \"http://www.springframework.org/schema/beans\";\n    \n    public boolean isDefaultNamespace(Node node) {\n        return isDefaultNamespace(getNamespaceURI(node));\n    }\n    public boolean isDefaultNamespace(String namespaceUri) {\n        return (!StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri));\n    }\n    ```\n    * 访问 http://www.springframework.org/schema/beans 得到的是beans的XSD定义文件  \n    ```xml\n    Index of /schema/beans\n    Icon  Name                    Last modified      Size  Description\n    [PARENTDIR] Parent Directory                             -   \n    [TXT] spring-beans-2.0.xsd    2019-05-09 08:43   38K  \n    [TXT] spring-beans-2.5.xsd    2019-05-09 08:43   41K  \n    [TXT] spring-beans-3.0.xsd    2019-05-09 08:43   41K  \n    [TXT] spring-beans-3.1.xsd    2019-05-09 08:43   42K  \n    [TXT] spring-beans-3.2.xsd    2019-05-09 08:43   43K  \n    [TXT] spring-beans-4.0.xsd    2019-05-09 08:43   42K  \n    [TXT] spring-beans-4.1.xsd    2019-05-09 08:43   43K  \n    [TXT] spring-beans-4.2.xsd    2019-05-09 08:43   43K  \n    [TXT] spring-beans-4.3.xsd    2019-05-09 08:43   43K  \n    [TXT] spring-beans.xsd        2019-05-09 08:43   43K  \n    ```\n    \n* 默认标签解析`parseDefaultElement(ele, delegate)`\n    * 可以看到这些是Spring默认的一些标签\n    ```java\n    /**\n     * 默认标签解析\n     *\n     * @param ele\n     * @param delegate\n     */\n    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {\n        // 解析import\n        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {\n            importBeanDefinitionResource(ele);\n        }\n        // 解析alias\n        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {\n            processAliasRegistration(ele);\n        }\n        // 解析bean 最为复杂最为重要\n        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {\n            processBeanDefinition(ele, delegate);\n        }\n        // 解析beans\n        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {\n            // recurse\n            doRegisterBeanDefinitions(ele);\n        }\n    }\n    ```\n    * 进入`processBeanDefinition(ele, delegate);`我们这里查看`bean标签`是怎么解析的，毕竟是`Spring`的主力军，可以看到下面的方法先是获取了`BeanDefinitionHolder`，这个是`BeanDefinition`的一个容器，在`BeanDefinition`内容的基础上添加了`beanName`及`aliases`属性，然后标签的解析工作是由`BeanDefinitionParserDelegate`类的`registerBeanDefinition`方法来执行的，这个类在上面的内容中简单提过一次，`BeanDefinitionParserDelegate`类提供了解析`spring`配置文件功能，对于默认空间下的元素在该类内部实现，如果是其它命名空间下的元素可以通过绑定`NamespaceHandler`的方式来实现,针对每个命名空间下的元素提供不同`BeanDefinitionParser`来实现.\n    ```java\n\t/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t */\n\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\t/**\n\t\t * 委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析\n\t\t *\n\t\t * bdHolder 实例已经包含我们配置文件中配置的各个属性了，例如class、name、id、alias\n\t\t */\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\t\tif (bdHolder != null) {\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t/**\n\t\t\t\t * 对解析后的bdHolder进行注册\n\t\t\t\t * Register the final decorated instance.\n\t\t\t\t */\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}\n\t\n\t/**\n     *\n     * BeanDefinitionHolder 实例已经包含我们配置文件中配置的各个属性了，\n     * 有beanDefinition及beanName和aliases,为注册做准备\n     *\n     * Holder for a BeanDefinition with name and aliases.\n     * Can be registered as a placeholder for an inner bean.\n     *\n     * <p>Can also be used for programmatic registration of inner bean\n     * definitions. If you don't care about BeanNameAware and the like,\n     * registering RootBeanDefinition or ChildBeanDefinition is good enough.\n     *\n     * @author Juergen Hoeller\n     * @since 1.0.2\n     * @see org.springframework.beans.factory.BeanNameAware\n     * @see org.springframework.beans.factory.support.RootBeanDefinition\n     * @see org.springframework.beans.factory.support.ChildBeanDefinition\n     */\n    public class BeanDefinitionHolder implements BeanMetadataElement {\n    \n    \tprivate final BeanDefinition beanDefinition;\n    \n    \tprivate final String beanName;\n    \n    \tprivate final String[] aliases;\n    ```\n    * 进入`delegate.parseBeanDefinitionElement(ele)`，可以看到一些基础代码`String id = ele.getAttribute(ID_ATTRIBUTE);` 获取id呀，获取name属性呀\n    ```java\n\t/**\n\t * Parses the supplied {@code <bean>} element. May return {@code null}\n\t * if there were errors during parse. Errors are reported to the\n\t * {@link org.springframework.beans.factory.parsing.ProblemReporter}.\n\t */\n\tpublic BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {\n\t\t// 获取id属性\n\t\tString id = ele.getAttribute(ID_ATTRIBUTE);\n\t\t// 获取name属性\n\t\tString nameAttr = ele.getAttribute(NAME_ATTRIBUTE);\n\n\t\t// 分割name属性 这里是实现了多个name配置的解析，可以是`,; `作为分割\n\t\tList<String> aliases = new ArrayList<String>();\n\t\tif (StringUtils.hasLength(nameAttr)) {\n\t\t\tString[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);\n\t\t\taliases.addAll(Arrays.asList(nameArr));\n\t\t}\n\n\t\tString beanName = id;\n\t\tif (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {\n\t\t\tbeanName = aliases.remove(0);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"No XML 'id' specified - using '\" + beanName +\n\t\t\t\t\t\t\"' as bean name and \" + aliases + \" as aliases\");\n\t\t\t}\n\t\t}\n\n\t\tif (containingBean == null) {\n\t\t\tcheckNameUniqueness(beanName, aliases, ele);\n\t\t}\n\n\t\tAbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);\n\t\tif (beanDefinition != null) {\n\t\t\tif (!StringUtils.hasText(beanName)) {\n\t\t\t\ttry {\n\t\t\t\t\t// 如果不存在beanName那么根据Spring中提供的命名规则为当前的bean生成对应的beanName\n\t\t\t\t\tif (containingBean != null) {\n\t\t\t\t\t\tbeanName = BeanDefinitionReaderUtils.generateBeanName(\n\t\t\t\t\t\t\t\tbeanDefinition, this.readerContext.getRegistry(), true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbeanName = this.readerContext.generateBeanName(beanDefinition);\n\t\t\t\t\t\t// Register an alias for the plain bean class name, if still possible,\n\t\t\t\t\t\t// if the generator returned the class name plus a suffix.\n\t\t\t\t\t\t// This is expected for Spring 1.2/2.0 backwards compatibility.\n\t\t\t\t\t\tString beanClassName = beanDefinition.getBeanClassName();\n\t\t\t\t\t\tif (beanClassName != null &&\n\t\t\t\t\t\t\t\tbeanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&\n\t\t\t\t\t\t\t\t!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {\n\t\t\t\t\t\t\taliases.add(beanClassName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Neither XML 'id' nor 'name' specified - \" +\n\t\t\t\t\t\t\t\t\"using generated bean name [\" + beanName + \"]\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\terror(ex.getMessage(), ele);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tString[] aliasesArray = StringUtils.toStringArray(aliases);\n\t\t\treturn new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);\n\t\t}\n\n\t\treturn null;\n\t}\n    ```\n    * `parseBeanDefinitionElement(ele, beanName, containingBean)` 这个方法构造了`BeanDefinition`，在这里是`AbstractBeanDefinition`对象，通过下面的代码可以很清晰的与`<bean>`标签的一些属性对应在一起，这些`xml`标签在`Spring`中就是转化成`BeanDefinition`\n    ```java\n\t/**\n\t * Parse the bean definition itself, without regard to name or aliases. May return\n\t * {@code null} if problems occurred during the parsing of the bean definition.\n\t */\n\tpublic AbstractBeanDefinition parseBeanDefinitionElement(\n\t\t\tElement ele, String beanName, BeanDefinition containingBean) {\n\n\t\tthis.parseState.push(new BeanEntry(beanName));\n\n\t\tString className = null;\n\t\t// 获取class属性\n\t\tif (ele.hasAttribute(CLASS_ATTRIBUTE)) {\n\t\t\tclassName = ele.getAttribute(CLASS_ATTRIBUTE).trim();\n\t\t}\n\n\t\ttry {\n\t\t\tString parent = null;\n\t\t\tif (ele.hasAttribute(PARENT_ATTRIBUTE)) {\n\t\t\t\tparent = ele.getAttribute(PARENT_ATTRIBUTE);\n\t\t\t}\n\t\t\t// 创建用于承载属性的AbstractBeanDefinition类型的GenericBeanDefinition\n\t\t\tAbstractBeanDefinition bd = createBeanDefinition(className, parent);\n\n\t\t\t// 硬编码解析默认bean的各种属性\n\t\t\tparseBeanDefinitionAttributes(ele, beanName, containingBean, bd);\n\t\t\t// 提取description\n\t\t\tbd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));\n\n\t\t\t// 解析元数据\n\t\t\tparseMetaElements(ele, bd);\n\t\t\t// 解析lookup-method\n\t\t\tparseLookupOverrideSubElements(ele, bd.getMethodOverrides());\n\t\t\t// 解析replaced-method\n\t\t\tparseReplacedMethodSubElements(ele, bd.getMethodOverrides());\n\n\t\t\t// 解析构造函数参数\n\t\t\tparseConstructorArgElements(ele, bd);\n\t\t\t// 解析property子元素\n\t\t\tparsePropertyElements(ele, bd);\n\t\t\t// 解析qualifier子元素\n\t\t\tparseQualifierElements(ele, bd);\n\n\t\t\tbd.setResource(this.readerContext.getResource());\n\t\t\tbd.setSource(extractSource(ele));\n\n\t\t\treturn bd;\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\terror(\"Bean class [\" + className + \"] not found\", ele, ex);\n\t\t}\n\t\tcatch (NoClassDefFoundError err) {\n\t\t\terror(\"Class that bean class [\" + className + \"] depends on not found\", ele, err);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\terror(\"Unexpected failure during bean definition parsing\", ele, ex);\n\t\t}\n\t\tfinally {\n\t\t\tthis.parseState.pop();\n\t\t}\n\n\t\treturn null;\n\t}\n    ```\n    * 回到`protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)`方法，在这里我们已经得到了`BeanDefinitionHolder`，下面就是需要将解析后的结果注册存放起来了，下面的`BeanDefinitionReaderUtils.registerBeanDefinition`方法就是做的这个任务\n    ```java\n\t/**\n\t * Process the given bean element, parsing the bean definition\n\t * and registering it with the registry.\n\t */\n\tprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {\n\t\t/**\n\t\t * 委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析\n\t\t *\n\t\t * bdHolder 实例已经包含我们配置文件中配置的各个属性了，例如class、name、id、alias\n\t\t */\n\t\tBeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);\n\t\tif (bdHolder != null) {\n\t\t\tbdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);\n\t\t\ttry {\n\t\t\t\t/**\n\t\t\t\t * 对解析后的bdHolder进行注册\n\t\t\t\t * Register the final decorated instance.\n\t\t\t\t */\n\t\t\t\tBeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());\n\t\t\t}\n\t\t\tcatch (BeanDefinitionStoreException ex) {\n\t\t\t\tgetReaderContext().error(\"Failed to register bean definition with name '\" +\n\t\t\t\t\t\tbdHolder.getBeanName() + \"'\", ele, ex);\n\t\t\t}\n\t\t\t// Send registration event.\n\t\t\tgetReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));\n\t\t}\n\t}\n    ```  \n    * 进入`BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());`方法，关注`getReaderContext().getRegistry()`方法，由上面可以知道`XmlReaderContext`存放着`XmlBeanDefinitionReader`，而`XmlBeanDefinitionReader`存放着`private final BeanDefinitionRegistry registry;`我们的`beanFactory`\n    private XmlReaderContext readerContext;\n    \n    ```java\n\t/**\n\t * Return the descriptor for the XML resource that this parser works on.\n\t */\n\tprotected final XmlReaderContext getReaderContext() {\n\t\treturn this.readerContext;\n\t}\n    ```\n    * 下面的代码可以看到第二参数是看到传入了`BeanDefinitionRegistry`对象，下面的方法就是根据`BeanDefinitionHolder`信息调用`BeanDefinitionRegistry`类的方法注册`BeanDefinition`及`Aliases`\n    ```java\n\t/**\n\t * Register the given bean definition with the given bean factory.\n\t * @param definitionHolder the bean definition including name and aliases\n\t * @param registry the bean factory to register with\n\t * @throws BeanDefinitionStoreException if registration failed\n\t */\n\tpublic static void registerBeanDefinition(\n\t\t\tBeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\t// Register bean definition under primary name. 使用beanName做唯一标识注册\n\t\tString beanName = definitionHolder.getBeanName();\n        // 核心代码\n\t\tregistry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n\t\t// Register aliases for bean name, if any. 注册所有的别名\n\t\tString[] aliases = definitionHolder.getAliases();\n\t\tif (aliases != null) {\n\t\t\tfor (String alias : aliases) {\n\t\t\t\tregistry.registerAlias(beanName, alias);\n\t\t\t}\n\t\t}\n\t}\n    ```\n    * 进入核心方法`registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());`，关注`this.beanDefinitionMap.put(beanName, beanDefinition);` 可以看到将我们得到的`beanDefinition`存放到了一个`private final Map<String, BeanDefinition> beanDefinitionMap`中，到这一个`<bean>`标签已经是解析完成了\n    \n    ```java\n\t@Override\n\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\t// 校验 beanName 与 beanDefinition 非空\n\t\tAssert.hasText(beanName, \"Bean name must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\n\t\t// 校验 BeanDefinition 这是注册前的最后一次校验了，主要是对 AbstractBeanDefinition 的 methodOverrides 属性进行校验。\n\t\tif (beanDefinition instanceof AbstractBeanDefinition) {\n\t\t\ttry {\n\t\t\t\t((AbstractBeanDefinition) beanDefinition).validate();\n\t\t\t}\n\t\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Validation of bean definition failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tBeanDefinition oldBeanDefinition;\n\t\t// 从缓存中获取指定 beanName 的 BeanDefinition\n\t\toldBeanDefinition = this.beanDefinitionMap.get(beanName);\n\t\t// 如果已经存在\n\t\tif (oldBeanDefinition != null) {\n\t\t\t// 如果存在但是不允许覆盖，抛出异常\n\t\t\tif (!isAllowBeanDefinitionOverriding()) {\n\t\t\t\tthrow new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,\n\t\t\t\t\t\t\"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName +\n\t\t\t\t\t\t\"': There is already [\" + oldBeanDefinition + \"] bound.\");\n\t\t\t}\n\t\t\t// 覆盖 beanDefinition 大于 被覆盖的 beanDefinition 的 ROLE ，打印 info 日志\n\t\t\telse if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {\n\t\t\t\t// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE\n\t\t\t\tif (this.logger.isWarnEnabled()) {\n\t\t\t\t\tthis.logger.warn(\"Overriding user-defined bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a framework-generated bean definition: replacing [\" +\n\t\t\t\t\t\t\toldBeanDefinition + \"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不相同，打印 debug 日志\n\t\t\telse if (!beanDefinition.equals(oldBeanDefinition)) {\n\t\t\t\tif (this.logger.isInfoEnabled()) {\n\t\t\t\t\tthis.logger.info(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with a different definition: replacing [\" + oldBeanDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 其它，打印 debug 日志\n\t\t\telse {\n\t\t\t\tif (this.logger.isDebugEnabled()) {\n\t\t\t\t\tthis.logger.debug(\"Overriding bean definition for bean '\" + beanName +\n\t\t\t\t\t\t\t\"' with an equivalent definition: replacing [\" + oldBeanDefinition +\n\t\t\t\t\t\t\t\"] with [\" + beanDefinition + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。\n\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t}\n\t\telse { // 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制\n\t\t\tif (hasBeanCreationStarted()) {\n\t\t\t\t// Cannot modify startup-time collection elements anymore (for stable iteration)\n\t\t\t\t// beanDefinitionMap 为全局变量，避免并发情况\n\t\t\t\tsynchronized (this.beanDefinitionMap) {\n\t\t\t\t\t// 添加到 BeanDefinition 到 beanDefinitionMap 中。\n\t\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t\tList<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);\n\t\t\t\t\tupdatedDefinitions.addAll(this.beanDefinitionNames);\n\t\t\t\t\tupdatedDefinitions.add(beanName);\n\t\t\t\t\t// 添加 beanName 到 beanDefinitionNames 中\n\t\t\t\t\tthis.beanDefinitionNames = updatedDefinitions;\n\t\t\t\t\t// 从 manualSingletonNames 移除 beanName\n\t\t\t\t\tif (this.manualSingletonNames.contains(beanName)) {\n\t\t\t\t\t\tSet<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);\n\t\t\t\t\t\tupdatedSingletons.remove(beanName);\n\t\t\t\t\t\tthis.manualSingletonNames = updatedSingletons;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Still in startup registration phase\n\t\t\t\t// 添加到 BeanDefinition 到 beanDefinitionMap 中。\n\t\t\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t\t\t\t// 添加 beanName 到 beanDefinitionNames 中\n\t\t\t\tthis.beanDefinitionNames.add(beanName);\n\t\t\t\t// 从 manualSingletonNames 移除 beanName\n\t\t\t\tthis.manualSingletonNames.remove(beanName);\n\t\t\t}\n\t\t\tthis.frozenBeanDefinitionNames = null;\n\t\t}\n\t\t// 重新设置 beanName 对应的缓存\n\t\tif (oldBeanDefinition != null || containsSingleton(beanName)) {\n\t\t\tresetBeanDefinition(beanName);\n\t\t}\n\t}\n    ```\n    \n* 自定义标签解析`delegate.parseCustomElement(ele)`\n    * 与默认标签解析的操作不同，它是通过调用`BeanDefinitionParser`接口的`parse`方法来解析\n    ```java\n\tpublic BeanDefinition parseCustomElement(Element ele) {\n\t\treturn parseCustomElement(ele, null);\n\t}\n\n\tpublic BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {\n\t\t// 获取xml配置文件中的命名空间http://www.springframework.org/schema/context\n\t\tString namespaceUri = getNamespaceURI(ele);\n\t\t// 根据命名空间找到命名空间处理类 比如ContextNamespaceHandler AopNamespaceHandler\n\t\tNamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);\n\t\tif (handler == null) {\n\t\t\terror(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele);\n\t\t\treturn null;\n\t\t}\n\t\t// 解析命名空间支持的标签\n\t\treturn handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));\n\t}\n    ```\n    * 这里有个`NamespaceHandler`这个接口主要功能是通过`Element`标签找到对于的`BeanDefinitionParser`，找到之后然后调用`BeanDefinitionParser`接口的`parse`方法来解析\n        * `NamespaceHandler`接口 ![](/images/server/spring/analysis/NamespaceHandler.png)\n            * 命名空间处理器，我们就可以根据需求自己来处理我们设置的标签元素。\n            * 可能需要配置如`<aop:config />`这样的标签, 在配置这个标签之前，通常我们需要在`xml`中引入这个aop所在的命名空间，`xmlns:aop=\"http://www.springframework.org/schema/aop`\n            * 只有通过配置`aop`的命名空间才会找到`AOP`标签的处理器`{@link org.springframework.aop.config.AopNamespaceHandler}`，在`AOP`的`jar`中的`spring.handlers`配置文件中配置了命名空间和命名空间处理器之间的关系。\n    * 比如我们这里是`<context:component-scan/>`标签，所以得到的命名空间处理类是`ContextNamespaceHandler`\n    ```xml\n    public class ContextNamespaceHandler extends NamespaceHandlerSupport {\n    \n        @Override\n        public void init() {\n            registerBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser());\n            registerBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser());\n            registerBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser());\n            registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser());\n            registerBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser());\n            registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n            registerBeanDefinitionParser(\"mbean-export\", new MBeanExportBeanDefinitionParser());\n            registerBeanDefinitionParser(\"mbean-server\", new MBeanServerBeanDefinitionParser());\n        }\n    \n    }\n    ```\n    * 关注`registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser());`这行代码这里注册了标签命名与对应解析类的对应关系，找到`ContextNamespaceHandler`之后就是调用对应解析类的对应方法了，调用`ComponentScanBeanDefinitionParser`的`parse`方法，此类实现了`BeanDefinitionParser`\n    ```java\n    /**\n     * Parser for the {@code <context:component-scan/>} element.\n     *\n     * @author Mark Fisher\n     * @author Ramnivas Laddad\n     * @author Juergen Hoeller\n     * @since 2.5\n     */\n    public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser {\n    \n        private static final String BASE_PACKAGE_ATTRIBUTE = \"base-package\";\n    \n        private static final String RESOURCE_PATTERN_ATTRIBUTE = \"resource-pattern\";\n    \n        private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\";\n    \n        private static final String ANNOTATION_CONFIG_ATTRIBUTE = \"annotation-config\";\n    \n        private static final String NAME_GENERATOR_ATTRIBUTE = \"name-generator\";\n    \n        private static final String SCOPE_RESOLVER_ATTRIBUTE = \"scope-resolver\";\n    \n        private static final String SCOPED_PROXY_ATTRIBUTE = \"scoped-proxy\";\n    \n        private static final String EXCLUDE_FILTER_ELEMENT = \"exclude-filter\";\n    \n        private static final String INCLUDE_FILTER_ELEMENT = \"include-filter\";\n    \n        private static final String FILTER_TYPE_ATTRIBUTE = \"type\";\n    \n        private static final String FILTER_EXPRESSION_ATTRIBUTE = \"expression\";\n    \n    \n        @Override\n        public BeanDefinition parse(Element element, ParserContext parserContext) {\n            String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);\n            basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);\n            // 解析base-package属性值，扫描的包可以,;分隔\n            String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,\n                    ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n    \n            // Actually scan for bean definitions and register them.\n            // 构建类路径的BeanDefinition扫描器\n            ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);\n\t\t    // 在指定的基础包中执行扫描 base-package = \"org.springiframe.*\" 找出该包下所有的bean注册为beanDefinition\n            Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);\n            // 注册组件\n            registerComponents(parserContext.getReaderContext(), beanDefinitions, element);\n    \n            return null;\n        }\n    ```\n    * 进入`configureScanner(parserContext, element);`方法，这里是构建了`ClassPathBeanDefinitionScanner`对象，并解析标签元素\n    ```java\n\tprotected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) {\n\t\t// 默认使用spring自带的注解过滤\n\t\tboolean useDefaultFilters = true;\n\t\t// 解析`use-default-filters`，类型为boolean\n\t\tif (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) {\n\t\t\tuseDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));\n\t\t}\n\n\t\t// Delegate bean definition registration to scanner class.\n\t\t// 此处如果`use-default-filters`为true，则添加`@Component`、`@Service`、`@Controller`、`@Repository`、`@ManagedBean`、`@Named`添加到includeFilters的集合过滤\n\t\tClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters);\n\t\tscanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());\n\t\tscanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());\n\n\t\t// 设置`resource-pattern`属性，扫描资源的模式匹配，支持正则表达式\n\t\tif (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) {\n\t\t\tscanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));\n\t\t}\n\n\t\ttry {\n\t\t\t// 解析name-generator属性 beanName生成器\n\t\t\tparseBeanNameGenerator(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tparserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t}\n\n\t\ttry {\n\t\t\t// 解析scope-resolver属性和scoped-proxy属性，但两者只可存在其一 后者值为targetClass：cglib代理、interfaces：JDK代理、no：不使用代理\n\t\t\tparseScope(element, scanner);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tparserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause());\n\t\t}\n\t\t// 解析子节点`context:include-filter`、`context:exclude-filter`主要用于对扫描class类的过滤\n\t\tparseTypeFilters(element, scanner, parserContext);\n\n\t\treturn scanner;\n\t}\n    ```\n    * 进入`createScanner(parserContext.getReaderContext(), useDefaultFilters);` 方法里面的`registerDefaultFilters();`方法，可以看到默认是注册了`@Component`,`@ManagedBean`,`@Named`过滤器到`this.includeFilters`中\n    ```java\n\tprotected void registerDefaultFilters() {\n\t\tthis.includeFilters.add(new AnnotationTypeFilter(Component.class));\n\t\tClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();\n\t\ttry {\n\t\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"javax.annotation.ManagedBean\", cl)), false));\n\t\t\tlogger.debug(\"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.\n\t\t}\n\t\ttry {\n\t\t\tthis.includeFilters.add(new AnnotationTypeFilter(\n\t\t\t\t\t((Class<? extends Annotation>) ClassUtils.forName(\"javax.inject.Named\", cl)), false));\n\t\t\tlogger.debug(\"JSR-330 'javax.inject.Named' annotation found and supported for component scanning\");\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t// JSR-330 API not available - simply skip.\n\t\t}\n\t}\n    ```\n    * 从上面可以看到Spring支持如下三种注解\n        * Spring自带的@Component注解及扩展@Repository、@Service、@Controller\n        * JSR-250 1.1版本中中定义的@ManagedBean注解，是Java EE 6标准规范之一，不包括在JDK中，需要在应用服务器环境使用（如Jboss）\n        * JSR-330的@Named注解\n    * 回到`Set<BeanDefinitionHolder> beanDefinitions = scanner.doScan(basePackages);`方法，这个方法就是在指定的基础包中执行扫描基础包下的所有符合条件的class\n    ```java\n\t/**\n\t * 在指定的基础包中执行扫描基础包下的所有符合条件的class\n\t *\n\t * Perform a scan within the specified base packages,\n\t * returning the registered bean definitions.\n\t * <p>This method does <i>not</i> register an annotation config processor\n\t * but rather leaves this up to the caller.\n\t * @param basePackages the packages to check for annotated classes\n\t * @return set of beans registered if any for tooling registration purposes (never {@code null})\n\t */\n\tprotected Set<BeanDefinitionHolder> doScan(String... basePackages) {\n\t\t// base-package属性必须要有\n\t\tAssert.notEmpty(basePackages, \"At least one base package must be specified\");\n\t\tSet<BeanDefinitionHolder> beanDefinitions = new LinkedHashSet<BeanDefinitionHolder>();\n\t\t// 对每个基础包都进行扫描寻找并且对基础包下的所有符合条件的class注册为BeanDefinition\n\t\tfor (String basePackage : basePackages) {\n\t\t\t// 核心方法 并对得到的candidates集合进行过滤，此处便用到include-filters和exclude-filters\n\t\t\tSet<BeanDefinition> candidates = findCandidateComponents(basePackage);\n\t\t\tfor (BeanDefinition candidate : candidates) {\n\t\t\t\tScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);\n\t\t\t\tcandidate.setScope(scopeMetadata.getScopeName());\n\t\t\t\tString beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);\n\t\t\t\tif (candidate instanceof AbstractBeanDefinition) {\n\t\t\t\t\t// 设置lazy-init/autowire-code默认属性，从spring配置的<beans>节点属性读取\n\t\t\t\t\tpostProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);\n\t\t\t\t}\n\t\t\t\tif (candidate instanceof AnnotatedBeanDefinition) {\n\t\t\t\t\t// 读取bean上的注解，比如`@Lazy`、`@Dependson`的值设置相应的属性\n\t\t\t\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);\n\t\t\t\t}\n\t\t\t\t// 查看是否已注册\n\t\t\t\tif (checkCandidate(beanName, candidate)) {\n\t\t\t\t\tBeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);\n\t\t\t\t\t// 默认采取cglib来做代理\n\t\t\t\t\tdefinitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);\n\t\t\t\t\tbeanDefinitions.add(definitionHolder);\n\t\t\t\t\t// 注册bean信息到工厂中\n\t\t\t\t\tregisterBeanDefinition(definitionHolder, this.registry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn beanDefinitions;\n\t}\n    ```\n    * `findCandidateComponents(String basePackage)`方法可以看到是遍历了class文件，一个个找符合条件的class并构造成`BeanDefinition`对象\n    ```java\n\t/**\n\t * Scan the class path for candidate components.\n\t * @param basePackage the package to check for annotated classes\n\t * @return a corresponding Set of autodetected bean definitions\n\t */\n\tpublic Set<BeanDefinition> findCandidateComponents(String basePackage) {\n\t\tSet<BeanDefinition> candidates = new LinkedHashSet<BeanDefinition>();\n\t\ttry {\n\t\t\tString packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +\n\t\t\t\t\tresolveBasePackage(basePackage) + '/' + this.resourcePattern;\n\t\t\tResource[] resources = this.resourcePatternResolver.getResources(packageSearchPath);\n\t\t\tboolean traceEnabled = logger.isTraceEnabled();\n\t\t\tboolean debugEnabled = logger.isDebugEnabled();\n\t\t\t// 遍历class文件\n\t\t\tfor (Resource resource : resources) {\n\t\t\t\tif (traceEnabled) {\n\t\t\t\t\tlogger.trace(\"Scanning \" + resource);\n\t\t\t\t}\n\t\t\t\tif (resource.isReadable()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tMetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource);\n\t\t\t\t\t\t// 这里进行匹配\n\t\t\t\t\t\tif (isCandidateComponent(metadataReader)) {\n\t\t\t\t\t\t\tScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader);\n\t\t\t\t\t\t\tsbd.setResource(resource);\n\t\t\t\t\t\t\tsbd.setSource(resource);\n\t\t\t\t\t\t\tif (isCandidateComponent(sbd)) {\n\t\t\t\t\t\t\t\tif (debugEnabled) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Identified candidate component class: \" + resource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcandidates.add(sbd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (debugEnabled) {\n\t\t\t\t\t\t\t\t\tlogger.debug(\"Ignored because not a concrete top-level class: \" + resource);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (traceEnabled) {\n\t\t\t\t\t\t\t\tlogger.trace(\"Ignored because not matching any filter: \" + resource);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\t\tthrow new BeanDefinitionStoreException(\n\t\t\t\t\t\t\t\t\"Failed to read candidate component class: \" + resource, ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (traceEnabled) {\n\t\t\t\t\t\tlogger.trace(\"Ignored because not readable: \" + resource);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex);\n\t\t}\n\t\treturn candidates;\n\t}\n    ```\n    * `isCandidateComponent(MetadataReader metadataReader)` 方法就是进行匹配的主体方法，上面默认注册的`this.includeFilters`就派上作用了\n    ```java\n\t/**\n\t * Determine whether the given class does not match any exclude filter\n\t * and does match at least one include filter.\n\t * @param metadataReader the ASM ClassReader for the class\n\t * @return whether the class qualifies as a candidate component\n\t */\n\tprotected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException {\n\t\tfor (TypeFilter tf : this.excludeFilters) {\n\t\t\t// 排除过滤器\n\t\t\tif (tf.match(metadataReader, this.metadataReaderFactory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (TypeFilter tf : this.includeFilters) {\n\t\t\t// 筛选过滤器\n\t\t\tif (tf.match(metadataReader, this.metadataReaderFactory)) {\n\t\t\t\treturn isConditionMatch(metadataReader);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n    ```\n    * 获得`BeanDefinition`之后就是通过`registerBeanDefinition(definitionHolder, this.registry);`注册，和之前默认标签的`BeanDefinition`的注册调用的是同一个方法\n    ```java\n\t/**\n\t * Register the given bean definition with the given bean factory.\n\t * @param definitionHolder the bean definition including name and aliases\n\t * @param registry the bean factory to register with\n\t * @throws BeanDefinitionStoreException if registration failed\n\t */\n\tpublic static void registerBeanDefinition(\n\t\t\tBeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\t// Register bean definition under primary name. 使用beanName做唯一标识注册\n\t\tString beanName = definitionHolder.getBeanName();\n\t\t// 核心代码\n\t\tregistry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());\n\n\t\t// Register aliases for bean name, if any. 注册所有的别名\n\t\tString[] aliases = definitionHolder.getAliases();\n\t\tif (aliases != null) {\n\t\t\tfor (String alias : aliases) {\n\t\t\t\tregistry.registerAlias(beanName, alias);\n\t\t\t}\n\t\t}\n\t}\t\t\t\n    ```\n    * 回到`registerComponents(parserContext.getReaderContext(), beanDefinitions, element);`，此处的目的主要是注册多个`BeanPostProcessor`接口实现类，供后续`Spring`调用统一接口进行解析\n    ```java\n\tprotected void registerComponents(XmlReaderContext readerContext, Set<BeanDefinitionHolder> beanDefinitions, Element element) {\n\n\t\tObject source = readerContext.extractSource(element);\n\t\t// 包装为CompositeComponentDefinition对象，内置多ComponentDefinition对象\n\t\tCompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source);\n\n\t\t// 将已注册的所有beanDefinitionHolder对象放到上述对象中\n\t\tfor (BeanDefinitionHolder beanDefHolder : beanDefinitions) {\n\t\t\tcompositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder));\n\t\t}\n\n\t\t// Register annotation config processors, if necessary.\n\t\tboolean annotationConfig = true;\n\t\t// 获取annotation-config的属性值，默认为true\n\t\tif (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) {\n\t\t\tannotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));\n\t\t}\n\t\tif (annotationConfig) {\n\t\t\t// 注册多个BeanPostProcessor接口，具体什么可自行查看，返回的是包含BeanPostProcessor接口的beanDefinitionHolder对象集合\n\t\t\t// 我们的@Autowired注解解析类AutowiredAnnotationBeanPostProcessor就是在这里默认导入的\n\t\t\tSet<BeanDefinitionHolder> processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);\n\t\t\t// 继续装入CompositeComponentDefinition对象\n\t\t\tfor (BeanDefinitionHolder processorDefinition : processorDefinitions) {\n\t\t\t\tcompositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition));\n\t\t\t}\n\t\t}\n\n\t\treaderContext.fireComponentRegistered(compositeDef);\n\t}\n    ```\n    * 关注`registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)`方法，可以看到默认注册了一些我们常用注解的解析器\n        * `ConfigurationClassPostProcessor`解析`@Configuration`注解类\n        * `AutowiredAnnotationBeanPostProcessor`解析`@Autowired/@Value`注解\n        * `RequiredAnnotationBeanPostProcessor`解析`@Required`注解\n        * `CommonAnnotationBeanPostProcessor`解析`@PostConstruct @PreDestroy @Resource`注解\n        * `PersistenceAnnotationBeanPostProcessor`解析`JPA`注解，持久层\n    ```java\n\t/**\n\t * Register all relevant annotation post processors in the given registry.\n\t * @param registry the registry to operate on\n\t * @param source the configuration source element (already extracted)\n\t * that this registration was triggered from. May be {@code null}.\n\t * @return a Set of BeanDefinitionHolders, containing all bean definitions\n\t * that have actually been registered by this call\n\t */\n\tpublic static Set<BeanDefinitionHolder> registerAnnotationConfigProcessors(\n\t\t\tBeanDefinitionRegistry registry, Object source) {\n\n\t\tDefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);\n\t\tif (beanFactory != null) {\n\t\t\tif (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) {\n\t\t\t\tbeanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);\n\t\t\t}\n\t\t\tif (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) {\n\t\t\t\tbeanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());\n\t\t\t}\n\t\t}\n\n\t\tSet<BeanDefinitionHolder> beanDefs = new LinkedHashSet<BeanDefinitionHolder>(4);\n\n\t\t// 注册@Configuration`解析类\n\t\tif (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// 注册`@Autowired/@Value`解析类\n\t\tif (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// 注册`@Required`解析类\n\t\tif (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.\n\t\t// 注册@PostConstruct @PreDestroy @Resource 及JSR-250支持注解解析类\n\t\tif (jsr250Present && !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\t// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.\n\t\t// 注册JPA注解解析类\n\t\tif (jpaPresent && !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition();\n\t\t\ttry {\n\t\t\t\tdef.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,\n\t\t\t\t\t\tAnnotationConfigUtils.class.getClassLoader()));\n\t\t\t}\n\t\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);\n\t\t\t}\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));\n\t\t}\n\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));\n\t\t}\n\t\tif (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) {\n\t\t\tRootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class);\n\t\t\tdef.setSource(source);\n\t\t\tbeanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));\n\t\t}\n\n\t\treturn beanDefs;\n\t}\n    ```\n## 总结\n* 回顾上一章节中`XmlBeanDefinitionReader`的总体功能是 `XML Resource => XML Document => Bean Definition` 的转化过程。由`Resource`得到`Document`对象，再由`Document`对象得到`BeanDefinition`对象，本章的`BeanDefinitionDocumentReader`对象就是替`XmlBeanDefinitionReader`完成`XML Document => Bean Definition`的功能\n* `XML Document`标签的解析分为默认标签的解析及自定义标签解析，默认标签的解析主要是通过`BeanDefinitionParserDelegate`类来实现，默认标签的解析比较固定所以直接是一个解析类就能完成，而自定义标签的实现是通过绑定`NamespaceHandler`的方式来实现,针对每个命名空间下的元素提供不同`BeanDefinitionParser`来实现，可以看到`Spring`考虑的十分全面\n* `ComponentScanBeanDefinitionParser`这个类是`<context:component-scan base-package = \"org.springiframe.*\"/>`这个标签的实现类，用于解析该包下所有的`bean`注册为`beanDefinition`\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(四)BeanDefinition读取器XmlBeanDefinitionReader","url":"/2019/06/09/backend/framework/spring/analysis/Spring系列(四)BeanDefinition读取器XmlBeanDefinitionReader/","content":"## 前言\n* 上一章节介绍了Resource的获取，这一章节来介绍BeanDefinitionReader功能， 它的作用是读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个<bean>解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中；\n\n* 下图是Spring容器从加载配置文件到创建一个完整Bean的作业流程及参与的角色\n\n![](/images/server/spring/analysis/ioc4.png)\n\n* BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition 。\n    * 在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构\n    * 在配置文件中每一个 <bean> 都对应着一个 BeanDefinition 对象。\n* 向 IoC 容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IoC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。\n    * 在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），Bean 创建是发生在应用第一次调用 #getBean(...) 方法，向容器索要 Bean 时。\n    * 当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit = false 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。\n    \n## 解析\n\n![](/images/server/spring/analysis/XmlBeanDefinitionReader.png)\n\n* `XmlBeanDefinitionReader`的继承结构比较简单，上面就一个顶级接口及一个默认抽象实现类，还有个获取`Environment`的接口\n\n* `BeanDefinitionReader` 顶级接口，关注`loadBeanDefinitions`方法，这些是定义解析`BeanDefinitions`的方法，可以看到支持`Resource`资源类型的解析，还支持`location`指定文件路径资源的解析\n\n```java\n/**\n * 主要定义了资源文件读取并转换为BeanDefinition的各个功能\n *\n * Simple interface for bean definition readers.\n * Specifies load methods with Resource and String location parameters.\n *\n * <p>Concrete bean definition readers can of course add additional\n * load and register methods for bean definitions, specific to\n * their bean definition format.\n *\n * <p>Note that a bean definition reader does not have to implement\n * this interface. It only serves as suggestion for bean definition\n * readers that want to follow standard naming conventions.\n *\n * @author Juergen Hoeller\n * @since 1.1\n * @see org.springframework.core.io.Resource\n */\npublic interface BeanDefinitionReader {\n\n\t/**\n\t * Return the bean factory to register the bean definitions with.\n\t * <p>The factory is exposed through the BeanDefinitionRegistry interface,\n\t * encapsulating the methods that are relevant for bean definition handling.\n\t */\n\tBeanDefinitionRegistry getRegistry();\n\n\t/**\n\t * Return the resource loader to use for resource locations.\n\t * Can be checked for the <b>ResourcePatternResolver</b> interface and cast\n\t * accordingly, for loading multiple resources for a given resource pattern.\n\t * <p>Null suggests that absolute resource loading is not available\n\t * for this bean definition reader.\n\t * <p>This is mainly meant to be used for importing further resources\n\t * from within a bean definition resource, for example via the \"import\"\n\t * tag in XML bean definitions. It is recommended, however, to apply\n\t * such imports relative to the defining resource; only explicit full\n\t * resource locations will trigger absolute resource loading.\n\t * <p>There is also a {@code loadBeanDefinitions(String)} method available,\n\t * for loading bean definitions from a resource location (or location pattern).\n\t * This is a convenience to avoid explicit ResourceLoader handling.\n\t * @see #loadBeanDefinitions(String)\n\t * @see org.springframework.core.io.support.ResourcePatternResolver\n\t */\n\tResourceLoader getResourceLoader();\n\n\t/**\n\t * Return the class loader to use for bean classes.\n\t * <p>{@code null} suggests to not load bean classes eagerly\n\t * but rather to just register bean definitions with class names,\n\t * with the corresponding Classes to be resolved later (or never).\n\t */\n\tClassLoader getBeanClassLoader();\n\n\t/**\n\t * Return the BeanNameGenerator to use for anonymous beans\n\t * (without explicit bean name specified).\n\t */\n\tBeanNameGenerator getBeanNameGenerator();\n\n\n\t/**\n\t * Load bean definitions from the specified resource.\n\t * @param resource the resource descriptor\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */\n\tint loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException;\n\n\t/**\n\t * Load bean definitions from the specified resources.\n\t * @param resources the resource descriptors\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */\n\tint loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException;\n\n\t/**\n\t * Load bean definitions from the specified resource location.\n\t * <p>The location can also be a location pattern, provided that the\n\t * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n\t * @param location the resource location, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t * @see #getResourceLoader()\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n\t * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n\t */\n\tint loadBeanDefinitions(String location) throws BeanDefinitionStoreException;\n\n\t/**\n\t * Load bean definitions from the specified resource locations.\n\t * @param locations the resource locations, to be loaded with the ResourceLoader\n\t * (or ResourcePatternResolver) of this bean definition reader\n\t * @return the number of bean definitions found\n\t * @throws BeanDefinitionStoreException in case of loading or parsing errors\n\t */\n\tint loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;\n\n}\n```\n\n* `AbstractBeanDefinitionReader` 抽象类是`BeanDefinitionReader`接口的默认抽象实现，关注`private final BeanDefinitionRegistry registry;`属性，上一章节介绍的`DefaultListableBeanFactory`类型的`beanFactory`就是存放在这，之后解析后的`BeanDefinition`也是存放在这\n\n```java\n/**\n * BeanDefinitionReader的抽象实现\n * 对 EnvironmentCapable、BeanDefinitionReader定义的功能进行实现\n *\n * Abstract base class for bean definition readers which implement\n * the {@link BeanDefinitionReader} interface.\n *\n * <p>Provides common properties like the bean factory to work on\n * and the class loader to use for loading bean classes.\n *\n * @author Juergen Hoeller\n * @author Chris Beams\n * @since 11.12.2003\n * @see BeanDefinitionReaderUtils\n */\npublic abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader {\n\n\t/** Logger available to subclasses */\n\tprotected final Log logger = LogFactory.getLog(getClass());\n\n\tprivate final BeanDefinitionRegistry registry;\n\n\tprivate ResourceLoader resourceLoader;\n\n\tprivate ClassLoader beanClassLoader;\n\n\tprivate Environment environment;\n\n\tprivate BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();\n\n\n\t/**\n\t * Create a new AbstractBeanDefinitionReader for the given bean factory.\n\t * <p>If the passed-in bean factory does not only implement the BeanDefinitionRegistry\n\t * interface but also the ResourceLoader interface, it will be used as default\n\t * ResourceLoader as well. This will usually be the case for\n\t * {@link org.springframework.context.ApplicationContext} implementations.\n\t * <p>If given a plain BeanDefinitionRegistry, the default ResourceLoader will be a\n\t * {@link org.springframework.core.io.support.PathMatchingResourcePatternResolver}.\n\t * <p>If the passed-in bean factory also implements {@link EnvironmentCapable} its\n\t * environment will be used by this reader.  Otherwise, the reader will initialize and\n\t * use a {@link StandardEnvironment}. All ApplicationContext implementations are\n\t * EnvironmentCapable, while normal BeanFactory implementations are not.\n\t * @param registry the BeanFactory to load bean definitions into,\n\t * in the form of a BeanDefinitionRegistry\n\t * @see #setResourceLoader\n\t * @see #setEnvironment\n\t */\n\tprotected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) {\n\t\tAssert.notNull(registry, \"BeanDefinitionRegistry must not be null\");\n\t\tthis.registry = registry;\n\n\t\t// Determine ResourceLoader to use.\n\t\tif (this.registry instanceof ResourceLoader) {\n\t\t\tthis.resourceLoader = (ResourceLoader) this.registry;\n\t\t}\n\t\telse {\n\t\t\tthis.resourceLoader = new PathMatchingResourcePatternResolver();\n\t\t}\n\n\t\t// Inherit Environment if possible\n\t\tif (this.registry instanceof EnvironmentCapable) {\n\t\t\tthis.environment = ((EnvironmentCapable) this.registry).getEnvironment();\n\t\t}\n\t\telse {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\t}\n```\n\n* `XmlBeanDefinitionReader.java` 可以看到就一个构造方法`public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) ` 我们之前构造的`DefaultListableBeanFactory`是实现了`BeanDefinitionRegistry`这个接口的，这个接口定义了对 `BeanDefinition` 的各种增删改查方法\n\n```java\n/**\n * 用于XML bean定义的Bean定义读取器。\n *\n * Bean definition reader for XML bean definitions.\n * Delegates the actual XML document reading to an implementation\n * of the {@link BeanDefinitionDocumentReader} interface.\n *\n * <p>Typically applied to a\n * {@link org.springframework.beans.factory.support.DefaultListableBeanFactory}\n * or a {@link org.springframework.context.support.GenericApplicationContext}.\n *\n * <p>This class loads a DOM document and applies the BeanDefinitionDocumentReader to it.\n * The document reader will register each bean definition with the given bean factory,\n * talking to the latter's implementation of the\n * {@link org.springframework.beans.factory.support.BeanDefinitionRegistry} interface.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Chris Beams\n * @since 26.11.2003\n * @see #setDocumentReaderClass\n * @see BeanDefinitionDocumentReader\n * @see DefaultBeanDefinitionDocumentReader\n * @see BeanDefinitionRegistry\n * @see org.springframework.beans.factory.support.DefaultListableBeanFactory\n * @see org.springframework.context.support.GenericApplicationContext\n */\npublic class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader {\n\n\t/**\n\t * Indicates that the validation should be disabled.\n\t */\n\tpublic static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;\n\n\t/**\n\t * Indicates that the validation mode should be detected automatically.\n\t */\n\tpublic static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;\n\n\t/**\n\t * Indicates that DTD validation should be used.\n\t */\n\tpublic static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;\n\n\t/**\n\t * Indicates that XSD validation should be used.\n\t */\n\tpublic static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;\n\n\n\t/** Constants instance for this class */\n\tprivate static final Constants constants = new Constants(XmlBeanDefinitionReader.class);\n\n\tprivate int validationMode = VALIDATION_AUTO;\n\n\tprivate boolean namespaceAware = false;\n\n\tprivate Class<?> documentReaderClass = DefaultBeanDefinitionDocumentReader.class;\n\n\tprivate ProblemReporter problemReporter = new FailFastProblemReporter();\n\n\tprivate ReaderEventListener eventListener = new EmptyReaderEventListener();\n\n\tprivate SourceExtractor sourceExtractor = new NullSourceExtractor();\n\n\tprivate NamespaceHandlerResolver namespaceHandlerResolver;\n\n\tprivate DocumentLoader documentLoader = new DefaultDocumentLoader();\n\n\t/**\n\t * 解析XML,SAX首先会读取xml文档上的声明，根据声明去寻找相应的DTD定义，以便对文档进行一个验证，\n\t * 默认的寻找规则即通过网络，通过网络的话有可能出现网络中断或不可用的情况，所以提供该接口来实\n\t * 现寻找DTD声明的过程，可以把这个文件放到项目中，这样就可以避免网络出错而导致无法启动项目的情况\n\t */\n\tprivate EntityResolver entityResolver;\n\n\tprivate ErrorHandler errorHandler = new SimpleSaxErrorHandler(logger);\n\n\tprivate final XmlValidationModeDetector validationModeDetector = new XmlValidationModeDetector();\n\n\tprivate final ThreadLocal<Set<EncodedResource>> resourcesCurrentlyBeingLoaded =\n\t\t\tnew NamedThreadLocal<Set<EncodedResource>>(\"XML bean definition resources currently being loaded\");\n\n\n\t/**\n\t * Create new XmlBeanDefinitionReader for the given bean factory.\n\t * @param registry the BeanFactory to load bean definitions into,\n\t * in the form of a BeanDefinitionRegistry\n\t */\n\tpublic XmlBeanDefinitionReader(BeanDefinitionRegistry registry) {\n\t\tsuper(registry);\n\t}\n```\n\n## 代码跟进\n\n* 上一章节介绍了 `Resource[] resources` 的获取，得到resources之后就是调用`loadBeanDefinitions(resources);`方法了\n \n```java\n/**\n * Load bean definitions from the specified resource location.\n * <p>The location can also be a location pattern, provided that the\n * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n * @param location the resource location, to be loaded with the ResourceLoader\n * (or ResourcePatternResolver) of this bean definition reader\n * @param actualResources a Set to be filled with the actual Resource objects\n * that have been resolved during the loading process. May be {@code null}\n * to indicate that the caller is not interested in those Resource objects.\n * @return the number of bean definitions found\n * @throws BeanDefinitionStoreException in case of loading or parsing errors\n * @see #getResourceLoader()\n * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n */\npublic int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {\n    ResourceLoader resourceLoader = getResourceLoader();\n    if (resourceLoader == null) {\n        throw new BeanDefinitionStoreException(\n                \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n    }\n\n    if (resourceLoader instanceof ResourcePatternResolver) {\n        // Resource pattern matching available.\n        try {\n            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n            // 解析BeanDefinition\n            int loadCount = loadBeanDefinitions(resources);\n            if (actualResources != null) {\n                for (Resource resource : resources) {\n                    actualResources.add(resource);\n                }\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\");\n            }\n            return loadCount;\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n                    \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n        }\n    }\n    else {\n        // Can only load single resources by absolute URL.\n        Resource resource = resourceLoader.getResource(location);\n        int loadCount = loadBeanDefinitions(resource);\n        if (actualResources != null) {\n            actualResources.add(resource);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\");\n        }\n        return loadCount;\n    }\n}\n```\n\n* `loadBeanDefinitions(Resource resource)`是`XmlBeanDefinitionReader`类的方法\n\n```java\n/**\n * Load bean definitions from the specified XML file.\n * @param resource the resource descriptor for the XML file\n * @return the number of bean definitions found\n * @throws BeanDefinitionStoreException in case of loading or parsing errors\n */\n@Override\npublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {\n    // 对参数使用EncodedResource类进行封装，对资源文件的编码进行处理，考虑到Resource可能存在编码要求的情况\n    return loadBeanDefinitions(new EncodedResource(resource));\n}\n```\n\n* 再跟进`loadBeanDefinitions(new EncodedResource(resource));`，可以看到我们熟悉的代码`InputStream inputStream = encodedResource.getResource().getInputStream();`\n\n```java\n/**\n * Load bean definitions from the specified XML file.\n * @param encodedResource the resource descriptor for the XML file,\n * allowing to specify an encoding to use for parsing the file\n * @return the number of bean definitions found\n * @throws BeanDefinitionStoreException in case of loading or parsing errors\n */\npublic int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {\n    Assert.notNull(encodedResource, \"EncodedResource must not be null\");\n    if (logger.isInfoEnabled()) {\n        logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource());\n    }\n    // 通过属性来记录已经加载的资源\n    Set<EncodedResource> currentResources = this.resourcesCurrentlyBeingLoaded.get();\n    if (currentResources == null) {\n        currentResources = new HashSet<EncodedResource>(4);\n        this.resourcesCurrentlyBeingLoaded.set(currentResources);\n    }\n    if (!currentResources.add(encodedResource)) {\n        throw new BeanDefinitionStoreException(\n                \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\");\n    }\n    try {\n        // 获取输入流\n        InputStream inputStream = encodedResource.getResource().getInputStream();\n        try {\n            // 构造 InputSource ，此类不是Spring的类\n            InputSource inputSource = new InputSource(inputStream);\n            if (encodedResource.getEncoding() != null) {\n                inputSource.setEncoding(encodedResource.getEncoding());\n            }\n            // 逻辑核心部分\n            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());\n        }\n        finally {\n            inputStream.close();\n        }\n    }\n    catch (IOException ex) {\n        throw new BeanDefinitionStoreException(\n                \"IOException parsing XML document from \" + encodedResource.getResource(), ex);\n    }\n    finally {\n        currentResources.remove(encodedResource);\n        if (currentResources.isEmpty()) {\n            this.resourcesCurrentlyBeingLoaded.remove();\n        }\n    }\n}\n```\n\n* 进入核心代码`doLoadBeanDefinitions(inputSource, encodedResource.getResource());`，下面的方法得到了`Document doc `\n\n```java\n/**\n * Actually load bean definitions from the specified XML file.\n * @param inputSource the SAX InputSource to read from\n * @param resource the resource descriptor for the XML file\n * @return the number of bean definitions found\n * @throws BeanDefinitionStoreException in case of loading or parsing errors\n * @see #doLoadDocument\n * @see #registerBeanDefinitions\n */\nprotected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)\n        throws BeanDefinitionStoreException {\n    try {\n        // 加载XML文件得到Document\n        Document doc = doLoadDocument(inputSource, resource);\n        // 根据得到的Document注册Bean信息\n        return registerBeanDefinitions(doc, resource);\n    }\n    catch (BeanDefinitionStoreException ex) {\n        throw ex;\n    }\n    catch (SAXParseException ex) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                \"Line \" + ex.getLineNumber() + \" in XML document from \" + resource + \" is invalid\", ex);\n    }\n    catch (SAXException ex) {\n        throw new XmlBeanDefinitionStoreException(resource.getDescription(),\n                \"XML document from \" + resource + \" is invalid\", ex);\n    }\n    catch (ParserConfigurationException ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                \"Parser configuration exception parsing XML from \" + resource, ex);\n    }\n    catch (IOException ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                \"IOException parsing XML document from \" + resource, ex);\n    }\n    catch (Throwable ex) {\n        throw new BeanDefinitionStoreException(resource.getDescription(),\n                \"Unexpected exception parsing XML document from \" + resource, ex);\n    }\n}\n```\n\n* 进入`doLoadDocument(inputSource, resource);`方法，此方法完成了 `XML Resource => XML Document` 的转化过程\n\n```java\n/**\n * Actually load the specified document using the configured DocumentLoader.\n * @param inputSource the SAX InputSource to read from\n * @param resource the resource descriptor for the XML file\n * @return the DOM Document\n * @throws Exception when thrown from the DocumentLoader\n * @see #setDocumentLoader\n * @see DocumentLoader#loadDocument\n */\nprotected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {\n    /**\n     * 委托了DocumentLoader来加载Document，具体实现:\n     * @see DefaultDocumentLoader#loadDocument(org.xml.sax.InputSource, org.xml.sax.EntityResolver, org.xml.sax.ErrorHandler, int, boolean)\n     *\n     * getValidationModeForResource方法来获取对应资源的验证模式\n     */\n    return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,\n            getValidationModeForResource(resource), isNamespaceAware());\n}\n```\n\n* `getEntityResolver()` 方法，返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。\n    * 何为EntityResolver？官网这样解释：如果 SAX 应用程序需要实现自定义处理外部实体，则必须实现此接口并使用 setEntityResolver 方法向SAX 驱动器注册一个实例。也就是说，对于解析一个XML，SAX 首先读取该 XML 文档上的声明，根据声明去寻找相应的 DTD 定义，以便对文档进行一个验证。默认的寻找规则，即通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行认证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。\n    * EntityResolver 的作用是项目本身就可以提供一个如何寻找 DTD 声明的方法，即由程序来实现寻找 DTD 声明的过程，比如我们将 DTD 文件放到项目中某处，在实现时直接将此文档读取并返回给 SAX 即可。这样就避免了通过网络来寻找相应的声明。\n\n* `getValidationModeForResource(resource)`方法是来获取对应XML资源的验证模式，我们知道`XML`使用了`DTD` 与 `XSD`验证模式保证了 `XML` 文件的正确性\n    * `DTD` 与 `XSD` 的区别\n        * `DTD` (Document Type Definition)即文档类型\n            * 一个DTD文档包含：（1）元素的定义规则；（2）元素间关系的定义规则；（3）元素可使用的属性，可使用的实体或符号规则\n            * .dtd文件，DTD基本语法：`<!ELEMENT NAME CONTENT>`\n            ```xml\n            <!ELEMENT 班级 (学生+)>\n            <!ELEMENT 学生 (名字,年龄,介绍)>\n            <!ELEMENT 名字 (#PCDATA)>\n            <!ELEMENT 年龄 (#PCDATA)>\n            \n            <!ELEMENT 介绍 (#PCDATA)>\n            ```\n            * 使用DTD验证模式需要在XML文件的头部声明\n            ```xml\n            <?xml version=\"1.0\" encoding=\"utf-8\"?>\n            <!-- 引入dtd文件，约束这个xml -->\n            <!DOCTYPE 班级 SYSTEM \"myclass.dtd\">\n            <班级>\n                <学生>\n                    <名字>周小星</名字>\n                    <年龄>23</年龄>\n                    <介绍>学习刻苦</介绍>\n                </学生>\n            </班级>\n            ```\n        * `XSD` (XML Schema)描述了XML文档的结构，可以用一个指定的XML Schema来验证某个XML\n            * XML Schema的优点:\n                * 1) XML Schema基于XML,没有专门的语法 \n                * 2) XML Schema可以象其他XML文件一样解析和处理 \n                * 3) XML Schema比DTD提供了更丰富的数据类型.\n                * 4) XML Schema提供可扩充的数据模型。 \n                * 5) XML Schema支持综合命名空间 \n                * 6) XML Schema支持属性组\n            * XSD定义\n            ```xml\n            <?xml version=\"1.0\"?>\n             \n            <xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"//在schema中用到的数据类型和元素来自此命名空间，并且来自此命名空间的元素以xs开头\n            targetNamespace=\"http://www.w3school.com.cn\"//此shema定义的元素（note等）来自此命名空间\n            xmlns=\"http://www.w3school.com.cn\"//默认的命名空间\n            elementFormDefault=\"qualified\">\n                <xs:element name=\"note\">\n                   <xs:complexType>\n                  <xs:sequence>\n                <xs:element name=\"to\" type=\"xs:string\"/>\n                <xs:element name=\"from\" type=\"xs:string\"/>\n                <xs:element name=\"heading\" type=\"xs:string\"/>\n                <xs:element name=\"body\" type=\"xs:string\"/>\n                  </xs:sequence>\n                </xs:complexType>\n                </xs:element>\n            </xs:schema>\n            ```\n            * XSD使用\n            ```xml\n            <?xml version=\"1.0\"?>\n            \n            <note xmlns=\"http://www.w3school.com.cn\" //默认命名空间\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" //可用的XML SCHEMAL实例命名空间 --->可以使用schemaLocation\n            xsi:schemaLocation=\"http://www.w3school.com.cn note.xsd\"> //schemaLacation两个属性：需要使用的命名空间 ；供命名空间使用的 XML schema 的位置\n            \n            <to>George</to>\n            <from>John</from>\n            <heading>Reminder</heading>\n            <body>Don't forget the meeting!</body>\n            </note>\n            ```\n            * \n       \n* `registerBeanDefinitions(doc, resource);`这行代码完成`XML Document => Bean Definition `的转化过程，这里涉及到另一个类`BeanDefinitionDocumentReader`，所以放到下一个章节介绍\n\n```java\n/**\n * Register the bean definitions contained in the given DOM document.\n * Called by {@code loadBeanDefinitions}.\n * <p>Creates a new instance of the parser class and invokes\n * {@code registerBeanDefinitions} on it.\n * @param doc the DOM document\n * @param resource the resource descriptor (for context information)\n * @return the number of bean definitions found\n * @throws BeanDefinitionStoreException in case of parsing errors\n * @see #loadBeanDefinitions\n * @see #setDocumentReaderClass\n * @see BeanDefinitionDocumentReader#registerBeanDefinitions\n */\npublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {\n    /**\n     * 使用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader，在实例化BeanDefinitionDocumentReader的时候会将\n     *\n     * @see DefaultBeanDefinitionDocumentReader\n     *\n     */\n    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();\n    // 记录统计前的BeanDefinition的加载个数\n    int countBefore = getRegistry().getBeanDefinitionCount();\n    // 加载并注册bean\n    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));\n    return getRegistry().getBeanDefinitionCount() - countBefore;\n}\n``` \n\n## 总结\n* `XmlBeanDefinitionReader`的总体功能是 `XML Resource => XML Document => Bean Definition` 的转化过程。由Resource得到Document对象，再由Document对象得到BeanDefinition对象\n\n## 参考\n* https://blog.csdn.net/qq_17037733/article/details/80503560\n* 《Spring 源码深度解析》 \n","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(三)Bean标签BeanDefinition","url":"/2019/06/08/backend/framework/spring/analysis/Spring系列(三)Bean标签BeanDefinition/","content":"## 前言\n* 解析 `bean` 标签的过程其实就是构造一个 `BeanDefinition` 对象的过程，<bean> 元素标签拥有的配置属性，BeanDefinition 均提供了相应的属性，与之一一对应。所以，我们有必要对 BeanDefinition 先有一个整体的认识。\n\n* `BeanDefinition` 的继承关系图\n\n![](/images/server/spring/analysis/bn2.png)\n\n* `BeanDefinition`\n```java\n/**\n * 配置文件<bean>元素标签在容器中的内部表示形式\n *\n * A BeanDefinition describes a bean instance, which has property values,\n * constructor argument values, and further information supplied by\n * concrete implementations.\n *\n * <p>This is just a minimal interface: The main intention is to allow a\n * {@link BeanFactoryPostProcessor} such as {@link PropertyPlaceholderConfigurer}\n * to introspect and modify property values and other bean metadata.\n *\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @since 19.03.2004\n * @see ConfigurableListableBeanFactory#getBeanDefinition\n * @see org.springframework.beans.factory.support.RootBeanDefinition\n * @see org.springframework.beans.factory.support.ChildBeanDefinition\n */\npublic interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {\n\n\t/**\n\t * Scope identifier for the standard singleton scope: \"singleton\".\n\t * <p>Note that extended bean factories might support further scopes.\n\t * @see #setScope\n\t */\n\tString SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;\n\n\t/**\n\t * Scope identifier for the standard prototype scope: \"prototype\".\n\t * <p>Note that extended bean factories might support further scopes.\n\t * @see #setScope\n\t */\n\tString SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;\n\n\n\t/**\n\t * Role hint indicating that a {@code BeanDefinition} is a major part\n\t * of the application. Typically corresponds to a user-defined bean.\n\t */\n\tint ROLE_APPLICATION = 0;\n\n\t/**\n\t * Role hint indicating that a {@code BeanDefinition} is a supporting\n\t * part of some larger configuration, typically an outer\n\t * {@link org.springframework.beans.factory.parsing.ComponentDefinition}.\n\t * {@code SUPPORT} beans are considered important enough to be aware\n\t * of when looking more closely at a particular\n\t * {@link org.springframework.beans.factory.parsing.ComponentDefinition},\n\t * but not when looking at the overall configuration of an application.\n\t */\n\tint ROLE_SUPPORT = 1;\n\n\t/**\n\t * Role hint indicating that a {@code BeanDefinition} is providing an\n\t * entirely background role and has no relevance to the end-user. This hint is\n\t * used when registering beans that are completely part of the internal workings\n\t * of a {@link org.springframework.beans.factory.parsing.ComponentDefinition}.\n\t */\n\tint ROLE_INFRASTRUCTURE = 2;\n\n\n\t// Modifiable attributes\n\n\t/**\n\t * Set the name of the parent definition of this bean definition, if any.\n\t */\n\tvoid setParentName(String parentName);\n\n\t/**\n\t * Return the name of the parent definition of this bean definition, if any.\n\t */\n\tString getParentName();\n\n\t/**\n\t * Specify the bean class name of this bean definition.\n\t * <p>The class name can be modified during bean factory post-processing,\n\t * typically replacing the original class name with a parsed variant of it.\n\t * @see #setParentName\n\t * @see #setFactoryBeanName\n\t * @see #setFactoryMethodName\n\t */\n\tvoid setBeanClassName(String beanClassName);\n\n\t/**\n\t * Return the current bean class name of this bean definition.\n\t * <p>Note that this does not have to be the actual class name used at runtime, in\n\t * case of a child definition overriding/inheriting the class name from its parent.\n\t * Also, this may just be the class that a factory method is called on, or it may\n\t * even be empty in case of a factory bean reference that a method is called on.\n\t * Hence, do <i>not</i> consider this to be the definitive bean type at runtime but\n\t * rather only use it for parsing purposes at the individual bean definition level.\n\t * @see #getParentName()\n\t * @see #getFactoryBeanName()\n\t * @see #getFactoryMethodName()\n\t */\n\tString getBeanClassName();\n\n\t/**\n\t * Override the target scope of this bean, specifying a new scope name.\n\t * @see #SCOPE_SINGLETON\n\t * @see #SCOPE_PROTOTYPE\n\t */\n\tvoid setScope(String scope);\n\n\t/**\n\t * Return the name of the current target scope for this bean,\n\t * or {@code null} if not known yet.\n\t */\n\tString getScope();\n\n\t/**\n\t * Set whether this bean should be lazily initialized.\n\t * <p>If {@code false}, the bean will get instantiated on startup by bean\n\t * factories that perform eager initialization of singletons.\n\t */\n\tvoid setLazyInit(boolean lazyInit);\n\n\t/**\n\t * Return whether this bean should be lazily initialized, i.e. not\n\t * eagerly instantiated on startup. Only applicable to a singleton bean.\n\t */\n\tboolean isLazyInit();\n\n\t/**\n\t * Set the names of the beans that this bean depends on being initialized.\n\t * The bean factory will guarantee that these beans get initialized first.\n\t */\n\tvoid setDependsOn(String... dependsOn);\n\n\t/**\n\t * Return the bean names that this bean depends on.\n\t */\n\tString[] getDependsOn();\n\n\t/**\n\t * Set whether this bean is a candidate for getting autowired into some other bean.\n\t * <p>Note that this flag is designed to only affect type-based autowiring.\n\t * It does not affect explicit references by name, which will get resolved even\n\t * if the specified bean is not marked as an autowire candidate. As a consequence,\n\t * autowiring by name will nevertheless inject a bean if the name matches.\n\t */\n\tvoid setAutowireCandidate(boolean autowireCandidate);\n\n\t/**\n\t * Return whether this bean is a candidate for getting autowired into some other bean.\n\t */\n\tboolean isAutowireCandidate();\n\n\t/**\n\t * Set whether this bean is a primary autowire candidate.\n\t * <p>If this value is {@code true} for exactly one bean among multiple\n\t * matching candidates, it will serve as a tie-breaker.\n\t */\n\tvoid setPrimary(boolean primary);\n\n\t/**\n\t * Return whether this bean is a primary autowire candidate.\n\t */\n\tboolean isPrimary();\n\n\t/**\n\t * Specify the factory bean to use, if any.\n\t * This the name of the bean to call the specified factory method on.\n\t * @see #setFactoryMethodName\n\t */\n\tvoid setFactoryBeanName(String factoryBeanName);\n\n\t/**\n\t * Return the factory bean name, if any.\n\t */\n\tString getFactoryBeanName();\n\n\t/**\n\t * Specify a factory method, if any. This method will be invoked with\n\t * constructor arguments, or with no arguments if none are specified.\n\t * The method will be invoked on the specified factory bean, if any,\n\t * or otherwise as a static method on the local bean class.\n\t * @see #setFactoryBeanName\n\t * @see #setBeanClassName\n\t */\n\tvoid setFactoryMethodName(String factoryMethodName);\n\n\t/**\n\t * Return a factory method, if any.\n\t */\n\tString getFactoryMethodName();\n\n\t/**\n\t * Return the constructor argument values for this bean.\n\t * <p>The returned instance can be modified during bean factory post-processing.\n\t * @return the ConstructorArgumentValues object (never {@code null})\n\t */\n\tConstructorArgumentValues getConstructorArgumentValues();\n\n\t/**\n\t * Return the property values to be applied to a new instance of the bean.\n\t * <p>The returned instance can be modified during bean factory post-processing.\n\t * @return the MutablePropertyValues object (never {@code null})\n\t */\n\tMutablePropertyValues getPropertyValues();\n\n\n\t// Read-only attributes\n\n\t/**\n\t * Return whether this a <b>Singleton</b>, with a single, shared instance\n\t * returned on all calls.\n\t * @see #SCOPE_SINGLETON\n\t */\n\tboolean isSingleton();\n\n\t/**\n\t * Return whether this a <b>Prototype</b>, with an independent instance\n\t * returned for each call.\n\t * @see #SCOPE_PROTOTYPE\n\t */\n\tboolean isPrototype();\n\n\t/**\n\t * Return whether this bean is \"abstract\", that is, not meant to be instantiated.\n\t */\n\tboolean isAbstract();\n\n\t/**\n\t * Get the role hint for this {@code BeanDefinition}. The role hint\n\t * provides the frameworks as well as tools with an indication of\n\t * the role and importance of a particular {@code BeanDefinition}.\n\t * @see #ROLE_APPLICATION\n\t * @see #ROLE_SUPPORT\n\t * @see #ROLE_INFRASTRUCTURE\n\t */\n\tint getRole();\n\n\t/**\n\t * Return a human-readable description of this bean definition.\n\t */\n\tString getDescription();\n\n\t/**\n\t * Return a description of the resource that this bean definition\n\t * came from (for the purpose of showing context in case of errors).\n\t */\n\tString getResourceDescription();\n\n\t/**\n\t * Return the originating BeanDefinition, or {@code null} if none.\n\t * Allows for retrieving the decorated bean definition, if any.\n\t * <p>Note that this method returns the immediate originator. Iterate through the\n\t * originator chain to find the original BeanDefinition as defined by the user.\n\t */\n\tBeanDefinition getOriginatingBeanDefinition();\n\n}\n\n```\n\n### BeanDefinition 的父类\n\n* `BeanDefinition` 继承 `AttributeAccessor` 和 `BeanMetadataElement` 接口。两个接口定义如下：\n    * `AttributeAccessor ` \n        * 定义了与其它对象的（元数据）进行连接和访问的约定，即对属性的修改，包括获取、设置、删除。\n        * 代码如下：\n        ```java\n        public interface AttributeAccessor {\n        \n            void setAttribute(String name, @Nullable Object value);\n        \n            @Nullable\n            Object getAttribute(String name);\n        \n            @Nullable\n            Object removeAttribute(String name);\n        \n            boolean hasAttribute(String name);\n        \n            String[] attributeNames();\n        \n        }\n        ```\n    * `BeanMetadataElement ` Bean 元对象持有的配置元素可以通过 #getSource() 方法来获取。\n        *\n        * 代码如下：\n        ```java\n        public interface BeanMetadataElement {\n        \n            @Nullable\n            Object getSource();\n        \n        }\n        ```\n### BeanDefinition 的子类\n    \n![](/images/server/spring/analysis/bn1.png)\n\n* 常用的三个实现类有：\n\n```java\norg.springframework.beans.factory.support.ChildBeanDefinition\norg.springframework.beans.factory.support.RootBeanDefinition\norg.springframework.beans.factory.support.GenericBeanDefinition\n```\n\n* `ChildBeanDefinition、RootBeanDefinition、GenericBeanDefinition` 三者都继承 `AbstractBeanDefinition` 抽象类，即 `AbstractBeanDefinition` 对三个子类的共同的类信息进行抽象。\n\n* `AbstractBeanDefinition` 是`BeanDefinition`的抽象基类\n\n```java\n/**\n * BeanDefinition的抽象基类\n *\n * Base class for concrete, full-fledged {@link BeanDefinition} classes,\n * factoring out common properties of {@link GenericBeanDefinition},\n * {@link RootBeanDefinition}, and {@link ChildBeanDefinition}.\n *\n * <p>The autowire constants match the ones defined in the\n * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory}\n * interface.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Rob Harrop\n * @author Mark Fisher\n * @see GenericBeanDefinition\n * @see RootBeanDefinition\n * @see ChildBeanDefinition\n */\n@SuppressWarnings(\"serial\")\npublic abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor\n\t\timplements BeanDefinition, Cloneable {\n\n\t/**\n\t * Constant for the default scope name: {@code \"\"}, equivalent to singleton\n\t * status unless overridden from a parent bean definition (if applicable).\n\t */\n\tpublic static final String SCOPE_DEFAULT = \"\";\n\n\t/**\n\t * Constant that indicates no autowiring at all.\n\t * @see #setAutowireMode\n\t */\n\tpublic static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;\n\n\t/**\n\t * Constant that indicates autowiring bean properties by name.\n\t * @see #setAutowireMode\n\t */\n\tpublic static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;\n\n\t/**\n\t * Constant that indicates autowiring bean properties by type.\n\t * @see #setAutowireMode\n\t */\n\tpublic static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;\n\n\t/**\n\t * Constant that indicates autowiring a constructor.\n\t * @see #setAutowireMode\n\t */\n\tpublic static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;\n\n\t/**\n\t * Constant that indicates determining an appropriate autowire strategy\n\t * through introspection of the bean class.\n\t * @see #setAutowireMode\n\t * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies,\n\t * use annotation-based autowiring for clearer demarcation of autowiring needs.\n\t */\n\t@Deprecated\n\tpublic static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;\n\n\t/**\n\t * Constant that indicates no dependency check at all.\n\t * @see #setDependencyCheck\n\t */\n\tpublic static final int DEPENDENCY_CHECK_NONE = 0;\n\n\t/**\n\t * Constant that indicates dependency checking for object references.\n\t * @see #setDependencyCheck\n\t */\n\tpublic static final int DEPENDENCY_CHECK_OBJECTS = 1;\n\n\t/**\n\t * Constant that indicates dependency checking for \"simple\" properties.\n\t * @see #setDependencyCheck\n\t * @see org.springframework.beans.BeanUtils#isSimpleProperty\n\t */\n\tpublic static final int DEPENDENCY_CHECK_SIMPLE = 2;\n\n\t/**\n\t * Constant that indicates dependency checking for all properties\n\t * (object references as well as \"simple\" properties).\n\t * @see #setDependencyCheck\n\t */\n\tpublic static final int DEPENDENCY_CHECK_ALL = 3;\n\n\t/**\n\t * Constant that indicates the container should attempt to infer the\n\t * {@link #setDestroyMethodName destroy method name} for a bean as opposed to\n\t * explicit specification of a method name. The value {@value} is specifically\n\t * designed to include characters otherwise illegal in a method name, ensuring\n\t * no possibility of collisions with legitimately named methods having the same\n\t * name.\n\t * <p>Currently, the method names detected during destroy method inference\n\t * are \"close\" and \"shutdown\", if present on the specific bean class.\n\t */\n\tpublic static final String INFER_METHOD = \"(inferred)\";\n\n\n\tprivate volatile Object beanClass;\n\n\t/**\n\t * bean属性scope\n\t */\n\tprivate String scope = SCOPE_DEFAULT;\n\t/**\n\t * 是否是抽奖\n\t */\n\tprivate boolean abstractFlag = false;\n\t/**\n\t * 是否延迟加载\n\t */\n\tprivate boolean lazyInit = false;\n\t/**\n\t * 自动注入模式，对应bean属性autowire\n\t */\n\tprivate int autowireMode = AUTOWIRE_NO;\n\t/**\n\t * 依赖检查\n\t */\n\tprivate int dependencyCheck = DEPENDENCY_CHECK_NONE;\n\t/**\n\t * 用来表示一个bean的实例化依靠另一个bean先实例化，对应bean属性depend-on\n\t */\n\tprivate String[] dependsOn;\n\n\tprivate boolean autowireCandidate = true;\n\t/**\n\t * 首选bean\n\t */\n\tprivate boolean primary = false;\n\n\tprivate final Map<String, AutowireCandidateQualifier> qualifiers =\n\t\t\tnew LinkedHashMap<String, AutowireCandidateQualifier>(0);\n\n\tprivate boolean nonPublicAccessAllowed = true;\n\n\tprivate boolean lenientConstructorResolution = true;\n\n\tprivate String factoryBeanName;\n\n\tprivate String factoryMethodName;\n\n\tprivate ConstructorArgumentValues constructorArgumentValues;\n\n\tprivate MutablePropertyValues propertyValues;\n\n\tprivate MethodOverrides methodOverrides = new MethodOverrides();\n\n\tprivate String initMethodName;\n\n\tprivate String destroyMethodName;\n\n\tprivate boolean enforceInitMethod = true;\n\n\tprivate boolean enforceDestroyMethod = true;\n\n\tprivate boolean synthetic = false;\n\n\tprivate int role = BeanDefinition.ROLE_APPLICATION;\n\n\tprivate String description;\n\n\tprivate Resource resource;\n\n\n\t/**\n\t * Create a new AbstractBeanDefinition with default settings.\n\t */\n\tprotected AbstractBeanDefinition() {\n\t\tthis(null, null);\n\t}\n\n\t/**\n\t * Create a new AbstractBeanDefinition with the given\n\t * constructor argument values and property values.\n\t */\n\tprotected AbstractBeanDefinition(ConstructorArgumentValues cargs, MutablePropertyValues pvs) {\n\t\tsetConstructorArgumentValues(cargs);\n\t\tsetPropertyValues(pvs);\n\t}\n\n\t/**\n\t * Create a new AbstractBeanDefinition as a deep copy of the given\n\t * bean definition.\n\t * @param original the original bean definition to copy from\n\t */\n\tprotected AbstractBeanDefinition(BeanDefinition original) {\n\t\tsetParentName(original.getParentName());\n\t\tsetBeanClassName(original.getBeanClassName());\n\t\tsetScope(original.getScope());\n\t\tsetAbstract(original.isAbstract());\n\t\tsetLazyInit(original.isLazyInit());\n\t\tsetFactoryBeanName(original.getFactoryBeanName());\n\t\tsetFactoryMethodName(original.getFactoryMethodName());\n\t\tsetConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues()));\n\t\tsetPropertyValues(new MutablePropertyValues(original.getPropertyValues()));\n\t\tsetRole(original.getRole());\n\t\tsetSource(original.getSource());\n\t\tcopyAttributesFrom(original);\n\n\t\tif (original instanceof AbstractBeanDefinition) {\n\t\t\tAbstractBeanDefinition originalAbd = (AbstractBeanDefinition) original;\n\t\t\tif (originalAbd.hasBeanClass()) {\n\t\t\t\tsetBeanClass(originalAbd.getBeanClass());\n\t\t\t}\n\t\t\tsetAutowireMode(originalAbd.getAutowireMode());\n\t\t\tsetDependencyCheck(originalAbd.getDependencyCheck());\n\t\t\tsetDependsOn(originalAbd.getDependsOn());\n\t\t\tsetAutowireCandidate(originalAbd.isAutowireCandidate());\n\t\t\tsetPrimary(originalAbd.isPrimary());\n\t\t\tcopyQualifiersFrom(originalAbd);\n\t\t\tsetNonPublicAccessAllowed(originalAbd.isNonPublicAccessAllowed());\n\t\t\tsetLenientConstructorResolution(originalAbd.isLenientConstructorResolution());\n\t\t\tsetMethodOverrides(new MethodOverrides(originalAbd.getMethodOverrides()));\n\t\t\tsetInitMethodName(originalAbd.getInitMethodName());\n\t\t\tsetEnforceInitMethod(originalAbd.isEnforceInitMethod());\n\t\t\tsetDestroyMethodName(originalAbd.getDestroyMethodName());\n\t\t\tsetEnforceDestroyMethod(originalAbd.isEnforceDestroyMethod());\n\t\t\tsetSynthetic(originalAbd.isSynthetic());\n\t\t\tsetResource(originalAbd.getResource());\n\t\t}\n\t\telse {\n\t\t\tsetResourceDescription(original.getResourceDescription());\n\t\t}\n\t}\n```\n\n* 如果配置文件中定义了父bean 和 子bean ，则父bean用 `RootBeanDefinition` 表示，子bean用 `ChildBeanDefinition` 表示，而没有父bean的就使用`RootBeanDefinition` 表示。\n\n* GenericBeanDefinition 为一站式服务类。\n\n### BeanDefinition 注册表：BeanDefinitionRegistry\n\n* 将`Bean` 的资源文件解析成 `BeanDefinition` 后需要将其注入容器中，这个过程由 `BeanDefinitionRegistry` 来完成。\n\n* `BeanDefinitionRegistry` 接口\n\n```java\n/**\n * 定义了对 BeanDefinition 的各种增删改查操作\n * Spring bean配置信息的内存数据库，以map的形式保存\n * \n */\npublic interface BeanDefinitionRegistry extends AliasRegistry {\n    \n\tvoid registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException;\n\n\tvoid removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;\n\n\tBeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException;\n\n\tboolean containsBeanDefinition(String beanName);\n\n\tString[] getBeanDefinitionNames();\n\n\tint getBeanDefinitionCount();\n\n\tboolean isBeanNameInUse(String beanName);\n\n}\n```\n\n* 下图是 `BeanDefinitionRegistry` 类结构图 \n\n![](/images/server/spring/analysis/dbr.jpg)\n\n#### 子类 SimpleBeanDefinitionRegistry\n\n* `SimpleBeanDefinitionRegistry`\n\n```java\n/**\n * 对BeanDefinitionRegistry的基本实现，提供了beanDefinitionMap Map作为BeanDefinition的容器\n * 下面的方法就是对map的增删改查\n *\n * Simple implementation of the {@link BeanDefinitionRegistry} interface.\n * Provides registry capabilities only, with no factory capabilities built in.\n * Can for example be used for testing bean definition readers.\n *\n * @author Juergen Hoeller\n * @since 2.5.2\n */\npublic class SimpleBeanDefinitionRegistry extends SimpleAliasRegistry implements BeanDefinitionRegistry {\n\n\t/** Map of bean definition objects, keyed by bean name */\n\tprivate final Map<String, BeanDefinition> beanDefinitionMap = new ConcurrentHashMap<String, BeanDefinition>(64);\n\n\n\t@Override\n\tpublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)\n\t\t\tthrows BeanDefinitionStoreException {\n\n\t\tAssert.hasText(beanName, \"'beanName' must not be empty\");\n\t\tAssert.notNull(beanDefinition, \"BeanDefinition must not be null\");\n\t\tthis.beanDefinitionMap.put(beanName, beanDefinition);\n\t}\n\n\t@Override\n\tpublic void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tif (this.beanDefinitionMap.remove(beanName) == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n\t\t}\n\t}\n\n\t@Override\n\tpublic BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException {\n\t\tBeanDefinition bd = this.beanDefinitionMap.get(beanName);\n\t\tif (bd == null) {\n\t\t\tthrow new NoSuchBeanDefinitionException(beanName);\n\t\t}\n\t\treturn bd;\n\t}\n\n\t@Override\n\tpublic boolean containsBeanDefinition(String beanName) {\n\t\treturn this.beanDefinitionMap.containsKey(beanName);\n\t}\n\n\t@Override\n\tpublic String[] getBeanDefinitionNames() {\n\t\treturn StringUtils.toStringArray(this.beanDefinitionMap.keySet());\n\t}\n\n\t@Override\n\tpublic int getBeanDefinitionCount() {\n\t\treturn this.beanDefinitionMap.size();\n\t}\n\n\t@Override\n\tpublic boolean isBeanNameInUse(String beanName) {\n\t\treturn isAlias(beanName) || containsBeanDefinition(beanName);\n\t}\n\n}\n\n```\n\n## 总结\n* 类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等，其实就是将Bean的定义信息存储到这个`BeanDefinition`相应的属性中，后面对Bean的操作就直接对BeanDefinition进行\n* 拿到这个`BeanDefinition`后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。\n* 下面的章节将介绍`BeanDefinition`的构建\n\n## 参考\n* 《Spring 源码深度解析》\n* 芋道源码 http://www.iocoder.cn","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(二)装载配置文件Resource","url":"/2019/05/12/backend/framework/spring/analysis/Spring系列(二)装载配置文件Resource/","content":"## 前言\n\n> 测试类\n\n```java\npublic class ClassPathXmlApplicationContextTest {\n\n    @Test\n    public void classPathXmlApplicationContext () {\n        ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\");\n        User user = xmlApplicationContext.getBean(User.class);\n    }\n}\n```\n\n* 关注`ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\");` 这行代码可以看到是传入了一个文件的相对路径地址，我们可以猜到里面的逻辑是读取配置文件`beans/bean.xml`，解析并构造成需要的对象\n\n* 那么`Spring`是怎样加载配置文件的呢，本章内容就是介绍`Spring`的资源加载设计及实现的一些知识，然后再通过断点调试来跟进上面这行代码是怎么实现资源加载的\n\n* 在学`Java SE`的时候，我们学习了一个标准类 `java.net.URL`，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator）\n    * 我们知道它的实现基本只限于网络形式发布的资源的查找和定位\n    * 然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等,而且它可以存在于任何场所，比如网络、文件系统、应用程序中\n    * 所以 java.net.URL 的局限性迫使 Spring 必须实现自己的资源加载策略\n\n### Jdk没有轮子那么Spring自己造\n\n* Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。\n\n#### 资源的定义Resource\n\n* Spring 定义了一个 org.springframework.core.io.Resource 接口，Resource 接口是为了统一各种类型不同的资源而定义的，Spring 提供了若干 Resource 接口的实现类，\n\n* 由子类 AbstractResource 提供统一的默认实现，这些实现类可以轻松地加载不同类型的底层资源，并提供了获取文件名、URL 地址以及资源内容的操作方法\n\n\n```java\npublic interface Resource extends InputStreamSource {\n\n\t/**\n\t * 资源是否存在\n\t */\n\tboolean exists();\n\n\t/**\n\t * 资源是否可读\n\t */\n\tdefault boolean isReadable() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * 资源所代表的句柄是否被一个 stream 打开了\n\t */\n\tdefault boolean isOpen() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * 是否为 File\n\t */\n\tdefault boolean isFile() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * 返回资源的 URL 的句柄\n\t */\n\tURL getURL() throws IOException;\n\n\t/**\n\t * 返回资源的 URI 的句柄\n\t */\n\tURI getURI() throws IOException;\n\n\t/**\n\t * 返回资源的 File 的句柄\n\t */\n\tFile getFile() throws IOException;\n\n\t/**\n\t * 返回 ReadableByteChannel\n\t */\n\tdefault ReadableByteChannel readableChannel() throws IOException {\n\t\treturn java.nio.channels.Channels.newChannel(getInputStream());\n\t}\n\n\t/**\n\t * 资源内容的长度\n\t */\n\tlong contentLength() throws IOException;\n\n\t/**\n\t * 资源最后的修改时间\n\t */\n\tlong lastModified() throws IOException;\n\n\t/**\n\t * 根据资源的相对路径创建新资源\n\t */\n\tResource createRelative(String relativePath) throws IOException;\n\n\t/**\n\t * 资源的文件名\n\t */\n\t@Nullable\n\tString getFilename();\n\n\t/**\n\t * 资源的描述\n\t */\n\tString getDescription();\n\n}\n```\n\n* `Resource` 根据资源的不同类型提供不同子类的具体实现，如下:\n\n![](/images/server/spring/analysis/resource1.jpg)\n\n* 抽象基类 `AbstractResource` 这个类是`Resource` 接口的默认抽象实现，如果我们想自定义`Resource`，继承该接口重写对应的方法就可以很方便自定义\n\n```java\n/**\n * Convenience base class for {@link Resource} implementations,\n * pre-implementing typical behavior.\n *\n * <p>The \"exists\" method will check whether a File or InputStream can\n * be opened; \"isOpen\" will always return false; \"getURL\" and \"getFile\"\n * throw an exception; and \"toString\" will return the description.\n *\n * @author Juergen Hoeller\n * @since 28.12.2003\n */\npublic abstract class AbstractResource implements Resource {\n\n\t/**\n\t * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流\n\t *\n\t * This implementation checks whether a File can be opened,\n\t * falling back to whether an InputStream can be opened.\n\t * This will cover both directories and content resources.\n\t */\n\t@Override\n\tpublic boolean exists() {\n\t\t// Try file existence: can we find the file in the file system? 基于 File 进行判断\n\t\ttry {\n\t\t\treturn getFile().exists();\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\t// Fall back to stream existence: can we open the stream?  基于 InputStream 进行判断\n\t\t\ttry {\n\t\t\t\tInputStream is = getInputStream();\n\t\t\t\tis.close();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Throwable isEx) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 直接返回true，表示可读\n\t * This implementation always returns {@code true}.\n\t */\n\t@Override\n\tpublic boolean isReadable() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * 直接返回 false，表示未被打开\n\t * This implementation always returns {@code false}.\n\t */\n\t@Override\n\tpublic boolean isOpen() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * 抛出 FileNotFoundException 异常，交给子类实现\n\t *\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to a URL.\n\t */\n\t@Override\n\tpublic URL getURL() throws IOException {\n\t\tthrow new FileNotFoundException(getDescription() + \" cannot be resolved to URL\");\n\t}\n\n\t/**\n\t * 基于 getURL() 返回的 URL 构建 URI\n\t *\n\t * This implementation builds a URI based on the URL returned\n\t * by {@link #getURL()}.\n\t */\n\t@Override\n\tpublic URI getURI() throws IOException {\n\t\tURL url = getURL();\n\t\ttry {\n\t\t\treturn ResourceUtils.toURI(url);\n\t\t}\n\t\tcatch (URISyntaxException ex) {\n\t\t\tthrow new NestedIOException(\"Invalid URI [\" + url + \"]\", ex);\n\t\t}\n\t}\n\n\t/**\n\t * 直接返回false，表示不为 File\n\t *\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that the resource cannot be resolved to an absolute file path.\n\t */\n\t@Override\n\tpublic File getFile() throws IOException {\n\t\tthrow new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\");\n\t}\n\n\t/**\n\t * 获取资源的长度\n\t *\n\t * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断\n\t *\n\t * This implementation reads the entire InputStream to calculate the\n\t * content length. Subclasses will almost always be able to provide\n\t * a more optimal version of this, e.g. checking a File length.\n\t * @see #getInputStream()\n\t */\n\t@Override\n\tpublic long contentLength() throws IOException {\n\t\tInputStream is = getInputStream();\n\t\tAssert.state(is != null, \"Resource InputStream must not be null\");\n\t\ttry {\n\t\t\tlong size = 0;\n\t\t\tbyte[] buf = new byte[255];\n\t\t\tint read;\n\t\t\twhile ((read = is.read(buf)) != -1) {\n\t\t\t\tsize += read;\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tis.close();\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 返回资源最后的修改时间\n\t *\n\t * This implementation checks the timestamp of the underlying File,\n\t * if available.\n\t * @see #getFileForLastModifiedCheck()\n\t */\n\t@Override\n\tpublic long lastModified() throws IOException {\n\t\tlong lastModified = getFileForLastModifiedCheck().lastModified();\n\t\tif (lastModified == 0L) {\n\t\t\tthrow new FileNotFoundException(getDescription() +\n\t\t\t\t\t\" cannot be resolved in the file system for resolving its last-modified timestamp\");\n\t\t}\n\t\treturn lastModified;\n\t}\n\n\t/**\n\t * Determine the File to use for timestamp checking.\n\t * <p>The default implementation delegates to {@link #getFile()}.\n\t * @return the File to use for timestamp checking (never {@code null})\n\t * @throws FileNotFoundException if the resource cannot be resolved as\n\t * an absolute file path, i.e. is not available in a file system\n\t * @throws IOException in case of general resolution/reading failures\n\t */\n\tprotected File getFileForLastModifiedCheck() throws IOException {\n\t\treturn getFile();\n\t}\n\n\t/**\n\t * 抛出 FileNotFoundException 异常，交给子类实现\n\t *\n\t * This implementation throws a FileNotFoundException, assuming\n\t * that relative resources cannot be created for this resource.\n\t */\n\t@Override\n\tpublic Resource createRelative(String relativePath) throws IOException {\n\t\tthrow new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription());\n\t}\n\n\t/**\n\t *  获取资源名称，默认返回 null ，交给子类实现\n\t *\n\t * This implementation always returns {@code null},\n\t * assuming that this resource type does not have a filename.\n\t */\n\t@Override\n\tpublic String getFilename() {\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * This implementation returns the description of this resource.\n\t * @see #getDescription()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn getDescription();\n\t}\n\n\t/**\n\t * This implementation compares description strings.\n\t * @see #getDescription()\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\treturn (obj == this ||\n\t\t\t(obj instanceof Resource && ((Resource) obj).getDescription().equals(getDescription())));\n\t}\n\n\t/**\n\t * This implementation returns the description's hash code.\n\t * @see #getDescription()\n\t */\n\t@Override\n\tpublic int hashCode() {\n\t\treturn getDescription().hashCode();\n\t}\n\n```\n\n* 子类解析\n    * 通过 `FileSystemResource` 以文件系统绝对路径的方式进行访问，对 `java.io.File` 类型资源的封装，只要是跟 `File` 打交道的，基本上与 `FileSystemResource` 也可以打交道；\n        * 成员变量及构造方法\n        ```java\n        public class FileSystemResource extends AbstractResource implements WritableResource {\n        \n            private final File file;\n        \n            private final String path;\n        \n            public FileSystemResource(File file) {\n                Assert.notNull(file, \"File must not be null\");\n                this.file = file;\n                this.path = StringUtils.cleanPath(file.getPath());\n            }\n            public FileSystemResource(String path) {\n                Assert.notNull(path, \"Path must not be null\");\n                this.file = new File(path);\n                this.path = StringUtils.cleanPath(path);\n            }\n        ```\n    * 通过 `ByteArrayResource` 对字节数组提供的数据的封装。如果通过 `InputStream` 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 `ByteArrayInputStream`。\n        * 成员变量及构造方法\n        ```java\n        public class ByteArrayResource extends AbstractResource {\n        \n            private final byte[] byteArray;\n        \n            private final String description;\n    \n            public ByteArrayResource(byte[] byteArray) {\n                this(byteArray, \"resource loaded from byte array\");\n            }\n\n            public ByteArrayResource(byte[] byteArray, String description) {\n                if (byteArray == null) {\n                    throw new IllegalArgumentException(\"Byte array must not be null\");\n                }\n                this.byteArray = byteArray;\n                this.description = (description != null ? description : \"\");\n            }\n        ```\n    * 通过 UrlResource 对 java.net.URL类型资源的封装。内部委派 URL 进行具体的资源操作。\n        * 成员变量及构造方法\n        ```java\n        public class UrlResource extends AbstractFileResolvingResource {\n        \n            private final URI uri;\n    \n            private final URL url;\n      \n            private final URL cleanedUrl;\n     \n            public UrlResource(URI uri) throws MalformedURLException {\n                Assert.notNull(uri, \"URI must not be null\");\n                this.uri = uri;\n                this.url = uri.toURL();\n                this.cleanedUrl = getCleanedUrl(this.url, uri.toString());\n            }\n   \n            public UrlResource(URL url) {\n                Assert.notNull(url, \"URL must not be null\");\n                this.url = url;\n                this.cleanedUrl = getCleanedUrl(this.url, url.toString());\n                this.uri = null;\n            }\n        \n            public UrlResource(String path) throws MalformedURLException {\n                Assert.notNull(path, \"Path must not be null\");\n                this.uri = null;\n                this.url = new URL(path);\n                this.cleanedUrl = getCleanedUrl(this.url, path);\n            }\n     \n            public UrlResource(String protocol, String location) throws MalformedURLException  {\n                this(protocol, location, null);\n            }\n    \n            public UrlResource(String protocol, String location, String fragment) throws MalformedURLException  {\n                try {\n                    this.uri = new URI(protocol, location, fragment);\n                    this.url = this.uri.toURL();\n                    this.cleanedUrl = getCleanedUrl(this.url, this.uri.toString());\n                }\n                catch (URISyntaxException ex) {\n                    MalformedURLException exToThrow = new MalformedURLException(ex.getMessage());\n                    exToThrow.initCause(ex);\n                    throw exToThrow;\n                }\n            }\n        ```\n    * 通过 `ClassPathResource` 以类路径的方式进行访问,`class path` 类型资源的实现。使用给定的 `ClassLoader` 或者给定的 `Class` 来加载资源。\n        * 成员变量及构造方法\n        ```java\n        public class ClassPathResource extends AbstractFileResolvingResource {\n        \n            private final String path;\n        \n            private ClassLoader classLoader;\n        \n            private Class<?> clazz;\n \n            public ClassPathResource(String path) {\n                this(path, (ClassLoader) null);\n            }\n  \n            public ClassPathResource(String path, ClassLoader classLoader) {\n                Assert.notNull(path, \"Path must not be null\");\n                String pathToUse = StringUtils.cleanPath(path);\n                if (pathToUse.startsWith(\"/\")) {\n                    pathToUse = pathToUse.substring(1);\n                }\n                this.path = pathToUse;\n                this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n            }\n    \n            public ClassPathResource(String path, Class<?> clazz) {\n                Assert.notNull(path, \"Path must not be null\");\n                this.path = StringUtils.cleanPath(path);\n                this.clazz = clazz;\n            }\n    \n            protected ClassPathResource(String path, ClassLoader classLoader, Class<?> clazz) {\n                this.path = StringUtils.cleanPath(path);\n                this.classLoader = classLoader;\n                this.clazz = clazz;\n            }\n        ```\n    * 通过 `InputStreamResource` 将给定的 `InputStream` 作为一种资源的 `Resource` 的实现类。\n        * 成员变量及构造方法\n        ```java\n        public class InputStreamResource extends AbstractResource {\n        \n            private final InputStream inputStream;\n        \n            private final String description;\n        \n            private boolean read = false;\n \n            public InputStreamResource(InputStream inputStream) {\n                this(inputStream, \"resource loaded through InputStream\");\n            }\n    \n            public InputStreamResource(InputStream inputStream, String description) {\n                if (inputStream == null) {\n                    throw new IllegalArgumentException(\"InputStream must not be null\");\n                }\n                this.inputStream = inputStream;\n                this.description = (description != null ? description : \"\");\n            }\n        ```\n    * 通过 `ServletContextResource` 以相对于 Web 应用根目录的方式进行访问。\n        * 成员变量及构造方法\n        ```java\n        public class ServletContextResource extends AbstractFileResolvingResource implements ContextResource {\n        \n            private final ServletContext servletContext;\n        \n            private final String path;\n    \n            public ServletContextResource(ServletContext servletContext, String path) {\n                // check ServletContext\n                Assert.notNull(servletContext, \"Cannot resolve ServletContextResource without ServletContext\");\n                this.servletContext = servletContext;\n        \n                // check path\n                Assert.notNull(path, \"Path is required\");\n                String pathToUse = StringUtils.cleanPath(path);\n                if (!pathToUse.startsWith(\"/\")) {\n                    pathToUse = \"/\" + pathToUse;\n                }\n                this.path = pathToUse;\n            }\n        ```\n        \n* 示例代码\n\n```java\n@Test\npublic void createFileSystemResourceByFile() throws Exception {\n    File file = new File(\"D://1.txt\");\n    FileSystemResource fileSystemResource = new FileSystemResource(file);\n}\n@Test\npublic void createFileSystemResourceByPath() throws Exception {\n    FileSystemResource fileSystemResource = new FileSystemResource(\"D://1.txt\");\n\n}\n@Test\npublic void createClassPathResourceByFile() throws Exception {\n    ClassPathResource classPathResource = new ClassPathResource(\"beans/bean.xml\");\n}\n```\n\n\n#### 统一资源定位 ResourceLoader\n* 一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。\n\n* org.springframework.core.io.ResourceLoader 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器 ,主要应用于根据给定的资源文件地址，返回对应的 Resource\n\n```java\n/**\n * 定义资源加载器，主要应用于根据给定的资源文件地址返回对应的 Resource\n *\n * Strategy interface for loading resources (e.. class path or file system\n * resources). An {@link org.springframework.context.ApplicationContext}\n * is required to provide this functionality, plus extended\n * {@link org.springframework.core.io.support.ResourcePatternResolver} support.\n *\n * <p>{@link DefaultResourceLoader} is a standalone implementation that is\n * usable outside an ApplicationContext, also used by {@link ResourceEditor}.\n *\n * <p>Bean properties of type Resource and Resource array can be populated\n * from Strings when running in an ApplicationContext, using the particular\n * context's resource loading strategy.\n *\n * @author Juergen Hoeller\n * @since 10.03.2004\n * @see Resource\n * @see org.springframework.core.io.support.ResourcePatternResolver\n * @see org.springframework.context.ApplicationContext\n * @see org.springframework.context.ResourceLoaderAware\n */\npublic interface ResourceLoader {\n\n\t/** Pseudo URL prefix for loading from the class path: \"classpath:\" */\n\tString CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;\n\n\n\t/**\n\t * 据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 Resource#exist() 方法来判断。\n\t * 该方法支持以下模式的资源加载：\n\t *\t\tURL位置资源，如 \"file:C:/test.dat\"\n\t *\t\tClassPath位置资源，如 \"classpath:test.dat\".\n\t *\t\t相对路径资源，如 \"WEB-INF/test.dat\"\n\t * Return a Resource handle for the specified resource location.\n\t * <p>The handle should always be a reusable resource descriptor,\n\t * allowing for multiple {@link Resource#getInputStream()} calls.\n\t * <p><ul>\n\t * <li>Must support fully qualified URLs, e.g. \"file:C:/test.dat\".\n\t * <li>Must support classpath pseudo-URLs, e.g. \"classpath:test.dat\".\n\t * <li>Should support relative file paths, e.g. \"WEB-INF/test.dat\".\n\t * (This will be implementation-specific, typically provided by an\n\t * ApplicationContext implementation.)\n\t * </ul>\n\t * <p>Note that a Resource handle does not imply an existing resource;\n\t * you need to invoke {@link Resource#exists} to check for existence.\n\t * @param location the resource location\n\t * @return a corresponding Resource handle (never {@code null})\n\t * @see #CLASSPATH_URL_PREFIX\n\t * @see Resource#exists()\n\t * @see Resource#getInputStream()\n\t */\n\tResource getResource(String location);\n\n\t/**\n\t * 返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。\n\t *\n\t * Expose the ClassLoader used by this ResourceLoader.\n\t * <p>Clients which need to access the ClassLoader directly can do so\n\t * in a uniform manner with the ResourceLoader, rather than relying\n\t * on the thread context ClassLoader.\n\t * @return the ClassLoader (only {@code null} if even the system\n\t * ClassLoader isn't accessible)\n\t * @see org.springframework.util.ClassUtils#getDefaultClassLoader()\n\t */\n\tClassLoader getClassLoader();\n\n}\n\n```\n\n> ResourceLoader.java 类继承结构\n\n![](/images/server/spring/analysis/rl1.png)\n\n* 子类结构\n    *  DefaultResourceLoader\n        * 与 AbstractResource 相似，org.springframework.core.io.DefaultResourceLoader 是 ResourceLoader 的默认实现。\n        * `getResource 方法` ResourceLoader 中最核心的方法为 #getResource(String location) ，它根据提供的 location 返回相应的 Resource 。而 DefaultResourceLoader 对该方法提供了核心实现（因为，它的两个子类都没有提供覆盖该方法，所以可以断定 ResourceLoader 的资源加载策略就封装在 DefaultResourceLoader 中)，\n        ```java\n        /**\n         * 可以看到Resource的加载获取是有顺序的，谁先获得就先返回\n         * \t1、首先，通过 ProtocolResolver 来加载资源，为什么要这个呢，它允许用户自定义资源加载协议，\n         * \t   而不需要继承 ResourceLoader 的子类。ProtocolResolver 接口，仅有一个方法resolve，实现该方法\n         * \t   就可以自己实现资源加载，\n         * \t2、以 / 开头，返回 ClassPathContextResource 类型的资源\n         * \t3、以 classpath: 开头，返回 ClassPathResource 类型的资源\n         * \t4、加载URL资源文件\n         * \t5、上一步没有找到，抛异常 ，就是返回 ClassPathContextResource 类型的资源\n         * @param location the resource location\n         * @return\n         */\n        @Override\n        public Resource getResource(String location) {\n            Assert.notNull(location, \"Location must not be null\");\n            /**\n             * 首先，通过 ProtocolResolver 来加载资源，\n             * @see #protocolResolvers\n             * 调用方法 {@link DefaultResourceLoader#addProtocolResolver(ProtocolResolver)} 即可添加\n             */\n            for (ProtocolResolver protocolResolver : this.protocolResolvers) {\n                Resource resource = protocolResolver.resolve(location, this);\n                if (resource != null) {\n                    return resource;\n                }\n            }\n            // 其次，以 / 开头，返回 ClassPathContextResource 类型的资源\n            if (location.startsWith(\"/\")) {\n                return getResourceByPath(location);\n            } // 再次，以 classpath: 开头，返回 ClassPathResource 类型的资源\n            else if (location.startsWith(CLASSPATH_URL_PREFIX)) {\n                return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());\n            }\n            else {\n                // 然后，根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源\n                try {\n                    // Try to parse the location as a URL...\n                    URL url = new URL(location);\n                    return new UrlResource(url);\n                }\n                catch (MalformedURLException ex) {\n                    // No URL -> resolve as resource path. 最后，返回 ClassPathContextResource 类型的资源\n                    return getResourceByPath(location);\n                }\n            }\n        }\n       ```\n    * FileSystemResourceLoader\n        * 它继承 DefaultResourceLoader ，且覆写了 #getResourceByPath(String) 方法，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型\n    * ClassRelativeResourceLoader\n        * ClassRelativeResourceLoader 扩展的功能是，可以根据给定的class 所在包或者所在包的子包下加载资源。\n        * 是 DefaultResourceLoader 的另一个子类的实现。和 FileSystemResourceLoader 类似，在实现代码的结构上类似，也是覆写 #getResourceByPath(String path) 方法，并返回其对应的 ClassRelativeContextResource 的资源类型。\n    * ResourcePatternResolver\n        * ResourceLoader 的 Resource getResource(String location) 方法，每次只能根据 location 返回一个 Resource 。当需要加载多个资源时，我们除了多次调用 #getResource(String location) 方法外，别无他法\n        * ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下：\n        ```java\n        public interface ResourcePatternResolver extends ResourceLoader {\n        \n            String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n        \n            Resource[] getResources(String locationPattern) throws IOException;\n        }\n        ``` \n        * ResourcePatternResolver 在 ResourceLoader 的基础上增加了 #getResources(String locationPattern) 方法，以支持根据路径匹配模式返回多个 Resource 实例。\n        * 同时，也新增了一种新的协议前缀 \"classpath*:\"，该协议前缀由其子类负责实现。\n    * PathMatchingResourcePatternResolver\n        * 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 \"classpath*:\" 前缀外，还支持 Ant 风格的路径匹配模式（类似于 \"**/*.xml\"）。\n        * getResource() 该方法，直接委托给相应的 ResourceLoader 来实现。所以，如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，如果未指定 ResourceLoader 参数的情况下，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。\n        ```java\n        @Override\n        public Resource getResource(String location) {\n            return getResourceLoader().getResource(location);\n        }\n        \n        public ResourceLoader getResourceLoader() {\n            return this.resourceLoader;\n        }\n        ```\n        * getResources() 方法，返回的资源是多个\n            * 非 \"classpath*:\" 开头，且路径不包含通配符，直接委托给相应的 ResourceLoader 来实现，只能加载找到的第一个文件\n            * 其他情况，调用 #findAllClassPathResources(...)、或 #findPathMatchingResources(...) 方法，返回多个 Resource\n            * 使用classpath*:与classpath:加载资源的结果是不一样的，如果有通配符的话更复杂\n\n        ```java\n        /**\n         * Spring可以通过指定classpath*:与classpath:前缀加路径的方式从classpath加载文件,\n         * 如bean的定义文件.classpath*:的出现是为了从多个jar文件中加载相同的文件，.classpath:只能加载找到的第一个文件.\n         * @param locationPattern the location pattern to resolve\n         * @return\n         * @throws IOException\n         */\n        @Override\n        public Resource[] getResources(String locationPattern) throws IOException {\n            Assert.notNull(locationPattern, \"Location pattern must not be null\");\n            // 以 \"classpath*:\" 开头\n            if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {\n                // 路径包含通配符\n                // a class path resource (multiple resources for same name possible)\n                if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {\n                    // a class path resource pattern\n                    return findPathMatchingResources(locationPattern);\n                }\n                else {\n                    // 路径不包含通配符，该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。\n                    // all class path resources with the given name\n                    return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));\n                }\n            } // 不以 \"classpath*:\" 开头\n            else {\n                // Generally only look for a pattern after a prefix here,\n                // and on Tomcat only after the \"*/\" separator for its \"war:\" protocol.\n                int prefixEnd = (locationPattern.startsWith(\"war:\") ? locationPattern.indexOf(\"*/\") + 1 :\n                        locationPattern.indexOf(\":\") + 1);\n                if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {\n                    // a file pattern\n                    return findPathMatchingResources(locationPattern);\n                }\n                else {\n                    // a single resource with the given name\n                    return new Resource[] {getResourceLoader().getResource(locationPattern)};\n                }\n            }\n        }\n        ```\n        * 方法讲解\n            * findPathMatchingResources 方法\n                * 当 locationPattern 中包含了通配符，则调用该方法进行资源加载\n                ```java\n                /**\n                 * 确定目录，获取该目录下得所有资源。在所获得的所有资源后，进行迭代匹配获取我们想要的资源。\n                 *\n                 * Find all resources that match the given location pattern via the\n                 * Ant-style PathMatcher. Supports resources in jar files and zip files\n                 * and in the file system.\n                 * @param locationPattern the location pattern to match\n                 * @return the result as Resource array\n                 * @throws IOException in case of I/O errors\n                 * @see #doFindPathMatchingJarResources\n                 * @see #doFindPathMatchingFileResources\n                 * @see org.springframework.util.PathMatcher\n                 */\n                protected Resource[] findPathMatchingResources(String locationPattern) throws IOException {\n                    // 确定根路径、子路径\n                    String rootDirPath = determineRootDir(locationPattern);\n                    String subPattern = locationPattern.substring(rootDirPath.length());\n                    // 获取根据路径下的资源\n                    Resource[] rootDirResources = getResources(rootDirPath);\n                    // 遍历，迭代\n                    Set<Resource> result = new LinkedHashSet<Resource>(16);\n                    for (Resource rootDirResource : rootDirResources) {\n                        rootDirResource = resolveRootDirResource(rootDirResource);\n                        URL rootDirURL = rootDirResource.getURL();\n                        // bundle 资源类型\n                        if (equinoxResolveMethod != null) {\n                            if (rootDirURL.getProtocol().startsWith(\"bundle\")) {\n                                rootDirURL = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirURL);\n                                rootDirResource = new UrlResource(rootDirURL);\n                            }\n                        }\n                        // vfs 资源类型\n                        if (rootDirURL.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {\n                            result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirURL, subPattern, getPathMatcher()));\n                        }\n                        // jar 资源类型\n                        else if (ResourceUtils.isJarURL(rootDirURL) || isJarResource(rootDirResource)) {\n                            result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirURL, subPattern));\n                        }\n                        // 其它资源类型\n                        else {\n                            result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));\n                        }\n                    }\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Resolved location pattern [\" + locationPattern + \"] to resources \" + result);\n                    }\n                    // 转换成 Resource 数组返回\n                    return result.toArray(new Resource[result.size()]);\n                }\n                ```\n            * findAllClassPathResources 方法\n                * 当 locationPattern 以 \"classpath*:\" 开头但是不包含通配符则调用此方法，该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。\n                ```java\n                /**\n                 * Find all class location resources with the given location via the ClassLoader.\n                 * Delegates to {@link #doFindAllClassPathResources(String)}.\n                 * @param location the absolute path within the classpath\n                 * @return the result as Resource array\n                 * @throws IOException in case of I/O errors\n                 * @see java.lang.ClassLoader#getResources\n                 * @see #convertClassLoaderURL\n                 */\n                protected Resource[] findAllClassPathResources(String location) throws IOException {\n                    // 去除首个 /\n                    String path = location;\n                    if (path.startsWith(\"/\")) {\n                        path = path.substring(1);\n                    }\n                    // 真正执行加载所有 classpath 资源\n                    Set<Resource> result = doFindAllClassPathResources(path);\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"Resolved classpath location [\" + location + \"] to resources \" + result);\n                    }\n                    // 转换成 Resource 数组返回\n                    return result.toArray(new Resource[result.size()]);\n                }\n                /**\n                 * Find all class location resources with the given path via the ClassLoader.\n                 * Called by {@link #findAllClassPathResources(String)}.\n                 * @param path the absolute path within the classpath (never a leading slash)\n                 * @return a mutable Set of matching Resource instances\n                 * @since 4.1.1\n                 */\n                protected Set<Resource> doFindAllClassPathResources(String path) throws IOException {\n                    Set<Resource> result = new LinkedHashSet<Resource>(16);\n                    ClassLoader cl = getClassLoader();\n                    // 根据 ClassLoader 加载路径下的所有资源\n                    Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));\n                    while (resourceUrls.hasMoreElements()) {\n                        URL url = resourceUrls.nextElement();\n                        // 将 URL 转换成 UrlResource\n                        result.add(convertClassLoaderURL(url));\n                    }\n                    // <3> 加载路径下得所有 jar 包\n                    if (\"\".equals(path)) {\n                        // The above result is likely to be incomplete, i.e. only containing file system references.\n                        // We need to have pointers to each of the jar files on the classpath as well...\n                        addAllClassLoaderJarRoots(cl, result);\n                    }\n                    return result;\n                }\n                ```\n                * 通过上面的分析，我们知道 #findAllClassPathResources(...) 方法，其实就是利用 ClassLoader 来加载指定路径下的资源，不论它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 /，则会调用 #addAllClassLoaderJarRoots(...) 方法，加载所有的 jar 包。\n                \n            * 处理的流程图: \n            \n             ![](/images/server/spring/analysis/rl2.jpg)\n        \n## 代码跟进 \n* 有了上面的知识储备，我们就知道一些皮毛概念了，下面的内容就是打好断点一步步调试了\n* 关注`ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\");` 这行代码可以看到是传入了一个文件的相对路径地址，我们可以猜到里面的逻辑是读取配置文件`beans/bean.xml`，解析并构造成需要的对象\n* 进入`new ClassPathXmlApplicationContext(\"beans/bean.xml\")`构造方法，可以看到参数是支持数组形式传入的\n\n```java\n/**\n * Create a new ClassPathXmlApplicationContext, loading the definitions\n * from the given XML file and automatically refreshing the context.\n * @param configLocation resource location\n * @throws BeansException if context creation failed\n */\npublic ClassPathXmlApplicationContext(String configLocation) throws BeansException {\n    this(new String[] {configLocation}, true, null);\n}\n\n/**\n * Create a new ClassPathXmlApplicationContext, loading the definitions\n * from the given XML files and automatically refreshing the context.\n * @param configLocations array of resource locations\n * @throws BeansException if context creation failed\n */\npublic ClassPathXmlApplicationContext(String... configLocations) throws BeansException {\n    this(configLocations, true, null);\n}\n/**\n * Create a new ClassPathXmlApplicationContext with the given parent,\n * loading the definitions from the given XML files.\n * @param configLocations array of resource locations\n * @param refresh whether to automatically refresh the context,\n * loading all bean definitions and creating all singletons.\n * Alternatively, call refresh manually after further configuring the context.\n * @param parent the parent context\n * @throws BeansException if context creation failed\n * @see #refresh()\n */\npublic ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)\n        throws BeansException {\n\n    super(parent);\n    // 可以将配置文件路径以数组的方式传入\n    setConfigLocations(configLocations);\n    if (refresh) {\n        // 重点\n        refresh();\n    }\n}\n```\n\n* 进入setConfigLocations方法，可以看到直接解析参数并设置到`private String[] configLocations` 对象中\n\n```java\n/**\n * Set the config locations for this application context.\n * <p>If not set, the implementation may use a default as appropriate.\n */\npublic void setConfigLocations(String... locations) {\n    if (locations != null) {\n        Assert.noNullElements(locations, \"Config locations must not be null\");\n        this.configLocations = new String[locations.length];\n        for (int i = 0; i < locations.length; i++) {\n            // 解析给定的路径\n            this.configLocations[i] = resolvePath(locations[i]).trim();\n        }\n    }\n    else {\n        this.configLocations = null;\n    }\n}\n```\n\n* 进入`refresh()`此方法是容器构建的主体方法，以后的章节也是以这个方法为主线，逐步分析`Spring` 容器构造的过程\n\n```java\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        // Prepare this context for refreshing.\n        // 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证\n        prepareRefresh();\n\n        // Tell the subclass to refresh the internal bean factory.\n        // 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n        // Prepare the bean factory for use in this context.\n        // 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开\n        // 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持\n        prepareBeanFactory(beanFactory);\n\n        try {\n            // Allows post-processing of the bean factory in context subclasses.\n            // 子类覆盖方法做额外的处理\n            postProcessBeanFactory(beanFactory);\n\n            // Invoke factory processors registered as beans in the context.\n            // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean，\n            // 并调用其postProcessBeanFactory接口方法\n            invokeBeanFactoryPostProcessors(beanFactory);\n\n            // Register bean processors that intercept bean creation.\n            // 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean，\n            // 并将它们注册到容器Bean后处理器的注册表中，这里只是注册，真正的调用在getBean时候\n            registerBeanPostProcessors(beanFactory);\n\n            // Initialize message source for this context.\n            // 初始化消息源 初始化容器的国际化消息资源\n            initMessageSource();\n\n            // Initialize event multicaster for this context.\n            // 初始化应用上下文事件广播器\n            initApplicationEventMulticaster();\n\n            // Initialize other special beans in specific context subclasses.\n            // 初始化其他特殊的bean，由具体子类实现，这是个钩子方法\n            onRefresh();\n\n            // Check for listener beans and register them.\n            // 注册事件监听器\n            registerListeners();\n\n            // Instantiate all remaining (non-lazy-init) singletons.\n            // 重点：初始化所有单实例的Bean，使用懒加载模式的bean除外，初始化Bean后将它们放到Spring容器的缓冲池中\n            finishBeanFactoryInitialization(beanFactory);\n\n            // Last step: publish corresponding event.\n            // 完成刷新并发布容器刷新事件\n            finishRefresh();\n        }\n\n        catch (BeansException ex) {\n            if (logger.isWarnEnabled()) {\n                logger.warn(\"Exception encountered during context initialization - \" +\n                        \"cancelling refresh attempt: \" + ex);\n            }\n\n            // Destroy already created singletons to avoid dangling resources.\n            destroyBeans();\n\n            // Reset 'active' flag.\n            cancelRefresh(ex);\n\n            // Propagate exception to caller.\n            throw ex;\n        }\n\n        finally {\n            // Reset common introspection caches in Spring's core, since we\n            // might not ever need metadata for singleton beans anymore...\n            resetCommonCaches();\n        }\n    }\n}\n```\n\n* 在这里我们关心的是配置文件的装载，所以进入`ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();` ，此方法的功能是构造`BeanFactory`\n\n```java\n/**\n * Tell the subclass to refresh the internal bean factory.\n * @return the fresh BeanFactory instance\n * @see #refreshBeanFactory()\n * @see #getBeanFactory()\n */\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n    // 刷新BeanFactory 子类实现，创建DefaultListableBeanFactory\n    refreshBeanFactory();\n    // 将配置文件的信息装入容器Bean定义注册表(BeanDefinitionRegistry)中，Bean未初始化 子类实现\n    ConfigurableListableBeanFactory beanFactory = getBeanFactory();\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n    }\n    return beanFactory;\n}\n```\n\n* 关注`refreshBeanFactory();`方法 ，下面是构造了一个`DefaultListableBeanFactory`一个默认的`BeanFactory`然后就是一些赋值操作\n\n```java\n/**\n * This implementation performs an actual refresh of this context's underlying\n * bean factory, shutting down the previous bean factory (if any) and\n * initializing a fresh bean factory for the next phase of the context's lifecycle.\n */\n@Override\nprotected final void refreshBeanFactory() throws BeansException {\n    if (hasBeanFactory()) {\n        destroyBeans();\n        closeBeanFactory();\n    }\n    try {\n        // 创建DefaultListableBeanFactory\n        DefaultListableBeanFactory beanFactory = createBeanFactory();\n        // 为了序列化指定id，如果需要的话，让这个BeanFactory从id反序列化到BeanFactory对象\n        beanFactory.setSerializationId(getId());\n        // 定制beanFactory：设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖\n        customizeBeanFactory(beanFactory);\n        // 核心方法 初始化DodumentReader，并进行XML文件读取及解析\n        loadBeanDefinitions(beanFactory);\n        synchronized (this.beanFactoryMonitor) {\n            this.beanFactory = beanFactory;\n        }\n    }\n    catch (IOException ex) {\n        throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex);\n    }\n}\n```\n\n* 进入核心方法`loadBeanDefinitions(beanFactory);` 这里传入了构造的`DefaultListableBeanFactory`，通过下面的代码可以看到是用`beanFactory`构建了一个`XmlBeanDefinitionReader`，这里的`befaultListableBeanFactory`会存放在`XmlBeanDefinitionReader`的`private final BeanDefinitionRegistry registry;`属性中，我们的`<bean>`信息解析后会存放在这，`XmlBeanDefinitionReader`就是做这个功能 ，这个类将会在下一章节中介绍\n\n```java\n\t/**\n\t * Loads the bean definitions via an XmlBeanDefinitionReader.\n\t * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader\n\t * @see #initBeanDefinitionReader\n\t * @see #loadBeanDefinitions\n\t */\n\t@Override\n\tprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {\n\t\t// Create a new XmlBeanDefinitionReader for the given BeanFactory.\n\t\t// 为指定beanFactory创建XmlBeanDefinitionReader\n\t\tXmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);\n\n\t\t// Configure the bean definition reader with this context's\n\t\t// resource loading environment.\n\t\t// 对beanDefinitionReader进行环境变量的设置\n\t\tbeanDefinitionReader.setEnvironment(this.getEnvironment());\n\t\tbeanDefinitionReader.setResourceLoader(this);\n\t\tbeanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));\n\n\t\t// Allow a subclass to provide custom initialization of the reader,\n\t\t// then proceed with actually loading the bean definitions.\n\t\t// 对BeanDefinitionReader进行初始设置，可以被子类覆盖，这里只是设置了一个validationMode值\n\t\tinitBeanDefinitionReader(beanDefinitionReader);\n\t\t// 配置文件的读取\n\t\tloadBeanDefinitions(beanDefinitionReader);\n\t}\n```\n\n\n* 我们进入`loadBeanDefinitions(beanDefinitionReader);`方法，这里是对配置文件的读取，下面的代码看到了我们之前传入的`String[] configLocations`，得到之后然后使用`XmlBeanDefinitionReader`解析\n \n```java\n/**\n * Load the bean definitions with the given XmlBeanDefinitionReader.\n * <p>The lifecycle of the bean factory is handled by the {@link #refreshBeanFactory}\n * method; hence this method is just supposed to load and/or register bean definitions.\n * @param reader the XmlBeanDefinitionReader to use\n * @throws BeansException in case of bean registration errors\n * @throws IOException if the required XML document isn't found\n * @see #refreshBeanFactory\n * @see #getConfigLocations\n * @see #getResources\n * @see #getResourcePatternResolver\n */\nprotected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {\n    Resource[] configResources = getConfigResources();\n    if (configResources != null) {\n        reader.loadBeanDefinitions(configResources);\n    }\n    String[] configLocations = getConfigLocations();\n    if (configLocations != null) {\n        reader.loadBeanDefinitions(configLocations);\n    }\n}\n```\n\n* 继续跟进到了`loadBeanDefinitions(location, null)`方法，是不是看到了我们的 `Resource[] resources` 及 `ResourceLoader`，看到这里下面的逻辑就是通过`ResourceLoader`的`getResources`方法来获取`Resource[]`了\n \n```java\n/**\n * Load bean definitions from the specified resource location.\n * <p>The location can also be a location pattern, provided that the\n * ResourceLoader of this bean definition reader is a ResourcePatternResolver.\n * @param location the resource location, to be loaded with the ResourceLoader\n * (or ResourcePatternResolver) of this bean definition reader\n * @param actualResources a Set to be filled with the actual Resource objects\n * that have been resolved during the loading process. May be {@code null}\n * to indicate that the caller is not interested in those Resource objects.\n * @return the number of bean definitions found\n * @throws BeanDefinitionStoreException in case of loading or parsing errors\n * @see #getResourceLoader()\n * @see #loadBeanDefinitions(org.springframework.core.io.Resource)\n * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])\n */\npublic int loadBeanDefinitions(String location, Set<Resource> actualResources) throws BeanDefinitionStoreException {\n    ResourceLoader resourceLoader = getResourceLoader();\n    if (resourceLoader == null) {\n        throw new BeanDefinitionStoreException(\n                \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\");\n    }\n\n    if (resourceLoader instanceof ResourcePatternResolver) {\n        // Resource pattern matching available.\n        try {\n            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);\n            // 解析BeanDefinition\n            int loadCount = loadBeanDefinitions(resources);\n            if (actualResources != null) {\n                for (Resource resource : resources) {\n                    actualResources.add(resource);\n                }\n            }\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\");\n            }\n            return loadCount;\n        }\n        catch (IOException ex) {\n            throw new BeanDefinitionStoreException(\n                    \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex);\n        }\n    }\n    else {\n        // Can only load single resources by absolute URL.\n        Resource resource = resourceLoader.getResource(location);\n        int loadCount = loadBeanDefinitions(resource);\n        if (actualResources != null) {\n            actualResources.add(resource);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\");\n        }\n        return loadCount;\n    }\n}\n```\n\n* 跟进`ResourceLoader resourceLoader = getResourceLoader();`，因为`ClassPathXmlApplicationContext`实现了`ResourceLoader`接口，我们看下`ClassPathXmlApplicationContext`是怎么实现`ResourceLoader`接口的，下面重写`getResources`代码可以看到委托了`ResourcePatternResolver`类来操作的\n    * getResources() 方法\n    ```java\n    /** ResourcePatternResolver used by this context */\n    private ResourcePatternResolver resourcePatternResolver;\n    \n    @Override\n    public Resource[] getResources(String locationPattern) throws IOException {\n        return this.resourcePatternResolver.getResources(locationPattern);\n    }\n    ```\n    * ResourcePatternResolver 是个接口，也是继承自ResourceLoader接口\n    ```java\n    public interface ResourcePatternResolver extends ResourceLoader {\n    \n    \t/**\n    \t * Pseudo URL prefix for all matching resources from the class path: \"classpath*:\"\n    \t * This differs from ResourceLoader's classpath URL prefix in that it\n    \t * retrieves all matching resources for a given name (e.g. \"/beans.xml\"),\n    \t * for example in the root of all deployed JAR files.\n    \t * @see org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX\n    \t */\n    \tString CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n    \n    \t/**\n    \t * Resolve the given location pattern into Resource objects.\n    \t * <p>Overlapping resource entries that point to the same physical\n    \t * resource should be avoided, as far as possible. The result should\n    \t * have set semantics.\n    \t * @param locationPattern the location pattern to resolve\n    \t * @return the corresponding Resource objects\n    \t * @throws IOException in case of I/O errors\n    \t */\n    \tResource[] getResources(String locationPattern) throws IOException;\n    \n    }\n    ```\n    * 那ResourcePatternResolver是怎么获得呢，查看`resourcePatternResolver`引用，可以看到在默认构造函数赋值，下面的代码可以看到直接构造了`PathMatchingResourcePatternResolver`，没错此类就是我们上面的已经讲解过的\n    ```java\n    /**\n     * Create a new AbstractApplicationContext with no parent.\n     */\n    public AbstractApplicationContext() {\n        this.resourcePatternResolver = getResourcePatternResolver();\n    }\n  \n  \tprotected ResourcePatternResolver getResourcePatternResolver() {\n  \t\treturn new PathMatchingResourcePatternResolver(this);\n  \t}\n    ```\n* 到了这里我们的`beans/bean.xml`配置文件已经通过`ResourceLoader`获取到了`Resource`，得到`Resource`之后就是需要解析了，这个之后的章节会介绍\n\n## 总结\n* Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。\n* Resource接口使资源的定义更广泛，网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等,而且它可以存在于任何场所，比如网络、文件系统、应用程序中，我们可以选择不同Resource实现类或者自定义Resource从而定义不同的资源\n\n## 参考\n* 《Spring 源码深度解析》 \n","tags":["Spring"],"categories":["server"]},{"title":"Spring系列(一)为什么要学习Spring","url":"/2019/05/11/backend/framework/spring/analysis/Spring系列(一)为什么要学习Spring/","content":"Spring 的宗旨：简化开发\n\n![](/images/server/spring/analysis/spring.jpg)\n\n## 前言\n* 作为一名从事`JavaWeb`开发方向的程序猿，`Spring`在项目开发中的地位是十分重要的（个人感觉地位仅次于`jdk`），现在基本上的项目都有使用它，之前的日常开发中对`Spring`的掌握程度也只是在使用层面上，对其实现的底层不是很清楚，所以特地开此系列博文来记录自己学习`Spring`的一些笔记及总结\n* 好记性不如烂笔头，`Java`开发设及的技术太多太杂，有些知识点没有总结记录过了许久又会忘记，所以论笔记的重要性\n\n\n## 为什么要阅读源码\n\n* 站在巨人的肩膀上看世界，看看大佬们是怎么写代码的，一些写代码的模式或者技巧是否可以运用到实际项目中\n* 许多东西不能只停留在使用层面，更要知其所以然，提高自己知识的深度\n* 可以融会贯通，看得越多，知识的互通性的愈发明显，比如一些设计思想，设计模式这些在其他框架也是大量的运用\n* 面试官会问呀\n\n## 下载并导入源码\n* 源码地址 `https://github.com/spring-projects/spring-framework` 选择合适的版本\n\n* 配置`gradle`环境\n\n* 详情可见源码父目录下的`import-into-idea.md`说明文档来将源码导入到`IDEA`环境中，执行`import-into-eclipse.bat`脚本将源码可导入至`eclipse`环境中\n\n* 导入到`IDEA`环境中操作步骤\n    * 进入 `spring-framework` 文件夹下，打开`cmd`，输入 `gradlew :spring-oxm:compileTestJava` ，`spring-oxm` 应该预编译，因为它使用重新打包的依赖项，被其他包依赖\n    \n    * 排除 `spring-aspects` 模块 `1、Exclude(Go to File->Project Structure->Modules)` 2、右键`unmark as sources root`让`idea`不认为此目录是源代码文件夹，不然此模块不然在本地编译不过\n    \n    * 执行`gradlew.bat`\n\n## 问题记录\n* 执行`gradle`命令报错\n    * 尝试更换版本，多下几个版本的`gradle`\n\n* 执行`gradle`命令报`错误: 找不到或无法加载主类 org.gradle.wrapper.GradleWrapperMain`\n    * 检查源码目录下是否有 `gradle/wrapper/gradle-wrapper.jar`，如果没有从其他项目中copy一份\n   \n* 执行`gradle`命令报`taskdef class jdiff.JDiffAntTask cannot be found`\n    * 注释该文件的下面代码\n    ```xml\n    ant.taskdef(\n            name: \"jdiff\",\n            classname: \"jdiff.JDiffAntTask\",\n            classpath: \"${jdiffHome}/antjdiff.jar\")\n    ```\n    \n* 有些类`GroovyBeanDefinitionReader` ``GroovyBeanDefinitionReader``编译报错说是找不到\n    * 找到对应`GroovyBeanDefinitionReader`的模块是`spring-beans-groovy` \n    * 然后在找到`build.gradle`文件将`compile(project(\":spring-beans-groovy\"))`依赖添加到对于报错的模块中\n        ```java\n        project(\"spring-context\") {\n            description = \"Spring Context\"\n        \n            apply plugin: \"groovy\"\n        \n            dependencies {\n                compile(project(\":spring-aop\"))\n                compile(project(\":spring-beans\"))\n                compile(project(\":spring-beans-groovy\"))\n        ```\n* 下面的代码是已经可以在`idea`编译使用的源码文件 `https://github.com/songshuiyang/spring-framework-4.3.10.RELEAS`E ，`clone`一下按照上面的步骤说明即可在本地调试源码\n\n* 设置测试类不编译，修改文件`build.gradle`，不然每次点击方法在哪里调用都会冒出一堆测试类供你选择\n```java\nsourceSets {\n    test {\n        java.srcDirs = ['src/排除test目录']\n    }\n}\n\ntest {\n    systemProperty(\"java.awt.headless\", \"true\")\n    systemProperty(\"testGroups\", project.properties.get(\"testGroups\"))\n    scanForTestClasses = false\n    include([\"**/*Tests.class\", \"**/*Test.class\"])\n    // Since we set scanForTestClasses to false, we need to filter out inner\n    // classes with the \"$\" pattern; otherwise, using -Dtest.single=MyTests to\n    // run MyTests by itself will fail if MyTests contains any inner classes.\n    exclude '*'\n}\n\n```\n\n## 坚持\n* 这个世界上从来没有一蹴而就的成功，只有经过踏实的努力，点滴的积累，这样机会降临在你头上的时候你才有能力去掌握它\n* 下面的章节将会以最基础的`Spring`示例代码来学习`Spring 4.3.10.RELEASE`，下面只有几行代码，但`Spring`却做了很多逻辑，所以以这几行代码为入口，开始吧\n\n> org.springiframe.entity.User.java\n\n```java\npublic class User {\n\n    private String userName;\n\n    private Integer age;\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n}\n```\n\n> beans/bean.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n       \n    <bean class=\"org.springiframe.entity.User\">\n        <property name=\"userName\" value=\"shop\"/>\n    </bean>\n</beans>\n```\n\n> 测试类\n\n```java\npublic class ClassPathXmlApplicationContextTest {\n\n    @Test\n    public void classPathXmlApplicationContext () {\n        ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\");\n        User user = xmlApplicationContext.getBean(User.class);\n    }\n}\n```\n\n* 上面的代码主要是做了几件事\n    * 读取配置文件`beans/bean.xml`\n    * 根据配置文件实例化`org.springiframe.entity.User.java`\n    * 实例化完成之后就可以使用该对象了\n* 这些过程看似很简单，但跟入代码查看可以发现`Spring`还是做了挺多事情的\n\n## 参考\n* http://cmsblogs.com/?cat=206\n* 《Spring 源码深度解析》 \n","tags":["Spring"],"categories":["server"]},{"title":"并发多线程(十三)ConcurrentLinkedQueue并发容器","url":"/2019/05/02/backend/java/concurrent1/并发多线程(十三)ConcurrentLinkedQueue并发容器/","content":"## 概述\n* 要实现一个线程安全的队列有两种方式：阻塞和非阻塞。阻塞队列无非就是锁的应用，而非阻塞则是CAS算法的应用。下面我们就开始一个非阻塞算法的研究：CoucurrentLinkedQueue。\n## 解析\n* ConcurrentLinkedQueue是一个基于链接节点的无边界的线程安全队列，它采用FIFO原则对元素进行排序。采用“wait-free”算法（即CAS算法）来实现的。\n* CoucurrentLinkedQueue的结构由head节点和tail节点组成，每个节点由节点元素item和指向下一个节点的next引用组成，而节点与节点之间的关系就是通过该next关联起来的，从而组成一张链表的队列。节点Node为ConcurrentLinkedQueue的内部类，定义如下\n```java\nprivate static class Node<E> {\n      /** 节点元素域 */\n      volatile E item;\n      volatile Node<E> next;\n\n      //初始化,获得item 和 next 的偏移量,为后期的CAS做准备\n\n      Node(E item) {\n          UNSAFE.putObject(this, itemOffset, item);\n      }\n\n      boolean casItem(E cmp, E val) {\n          return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);\n      }\n\n      void lazySetNext(Node<E> val) {\n          UNSAFE.putOrderedObject(this, nextOffset, val);\n      }\n\n      boolean casNext(Node<E> cmp, Node<E> val) {\n          return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n      }\n\n      // Unsafe mechanics\n\n      private static final sun.misc.Unsafe UNSAFE;\n      /** 偏移量 */\n      private static final long itemOffset;\n      /** 下一个元素的偏移量 */\n\n     private static final long nextOffset;\n\n      static {\n          try {\n              UNSAFE = sun.misc.Unsafe.getUnsafe();\n              Class<?> k = Node.class;\n              itemOffset = UNSAFE.objectFieldOffset\n                      (k.getDeclaredField(\"item\"));\n              nextOffset = UNSAFE.objectFieldOffset\n                      (k.getDeclaredField(\"next\"));\n          } catch (Exception e) {\n              throw new Error(e);\n          }\n      }\n  }\n```\n   \n## 总结\n\n## 参考\n* http://www.iocoder.cn/JUC/sike/ConcurrentLinkedQueue/","tags":["Java"],"categories":["server"]},{"title":"并发多线程(十二)ConcurrentHashMap并发容器","url":"/2019/05/02/backend/java/concurrent1/并发多线程(十二)ConcurrentHashMap并发容器/","content":"## 概述\n* HashMap是我们用得非常频繁的一个集合，但是由于它是非线程安全的，在多线程环境下，put操作是有可能产生死循环的，导致CPU利用率接近100%。为了解决该问题，提供了Hashtable和Collections.synchronizedMap(hashMap)两种解决方案，但是这两种方案都是对读写加锁，独占式，一个线程在读时其他线程必须等待，吞吐量较低，性能较为低下。故而Doug Lea大神给我们提供了高性能的线程安全HashMap：ConcurrentHashMap。\n\n## 解析\n\n### ConcurrentHashMap的实现\n* ConcurrentHashMap作为Concurrent一族，其有着高效地并发操作，相比Hashtable的笨重，ConcurrentHashMap则更胜一筹了。\n* 在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。\n* 我们先用一个示意图来描述下其结构：\n\n![](/images/server/java/Concurrent/concurrentHashMap1.png)\n\n* 结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。\n### 初始化\n```java\n// 这构造函数里，什么都不干\npublic ConcurrentHashMap() {\n}\npublic ConcurrentHashMap(int initialCapacity) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n    this.sizeCtl = cap;\n}\n```\n* put 过程分析\n```java\npublic V put(K key, V value) {\n    return putVal(key, value, false);\n}\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    // key、value均不能为null\n    if (key == null || value == null) throw new NullPointerException();\n    // 得到 hash 值\n    int hash = spread(key.hashCode());\n    // 用于记录相应链表的长度\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        // 如果数组\"空\"，进行数组初始化\n        if (tab == null || (n = tab.length) == 0)\n            // 初始化数组，后面会详细介绍\n            tab = initTable();\n \n        // 找该 hash 值对应的数组下标，得到第一个节点 f\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            // 如果数组该位置为空，\n            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了\n            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了\n            if (casTabAt(tab, i, null,\n                         new Node<K,V>(hash, key, value, null)))\n                break;                   // no lock when adding to empty bin\n        }\n        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容\n        else if ((fh = f.hash) == MOVED)\n            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了\n            tab = helpTransfer(tab, f);\n \n        else { // 到这里就是说，f 是该位置的头结点，而且不为空\n \n            V oldVal = null;\n            // 获取数组该位置的头结点的监视器锁\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    if (fh >= 0) { // 头结点的 hash 值大于 0，说明是链表\n                        // 用于累加，记录链表的长度\n                        binCount = 1;\n                        // 遍历链表\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            // 如果发现了\"相等\"的 key，判断是否要进行值覆盖，然后也就可以 break 了\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            // 到了链表的最末端，将这个新值放到链表的最后面\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key,\n                                                          value, null);\n                                break;\n                            }\n                        }\n                    }\n                    else if (f instanceof TreeBin) { // 红黑树\n                        Node<K,V> p;\n                        binCount = 2;\n                        // 调用红黑树的插值方法插入新节点\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            // binCount != 0 说明上面在做链表操作\n            if (binCount != 0) {\n                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8\n                if (binCount >= TREEIFY_THRESHOLD)\n                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，\n                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树\n                    //    具体源码我们就不看了，扩容部分后面说\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    // \n    addCount(1L, binCount);\n    return null;\n}\n```\n### get 过程分析\n```java\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 判断头结点是否就是我们需要的节点\n        if ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n        // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树\n        else if (eh < 0)\n            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)\n            return (p = e.find(h, key)) != null ? p.val : null;\n \n        // 遍历链表\n        while ((e = e.next) != null) {\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n```\n* get 方法从来都是最简单的，这里也不例外： \n    * 计算 hash 值\n    * 根据 hash 值找到数组对应位置: (n – 1) & h\n    * 根据该位置处结点性质进行相应查找\n   \n## 总结\n\n\n## 其他\n* 何为同步容器？可以简单地理解为通过 synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。\n    * 比如 Vector，Hashtable，以及 Collections#synchronizedSet()，Collections#synchronizedList() 等方法返回的容器。\n    * 可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized 。并发容器，使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性。\n    * 例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁。在这种锁机制下，允许任意数量的读线程并发地访问 map ，并且执行读操作的线程和写操作的线程也可以并发的访问 map ，同时允许一定数量的写操作线程并发地修改 map ，所以它可以在并发环境下实现更高的吞吐量。\n* SynchronizedMap 和 ConcurrentHashMap 有什么区别？\n    * SynchronizedMap\n        * 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。\n    * ConcurrentHashMap\n        * 使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】\n        * 另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。\n## 参考\n* http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/\n* http://svip.iocoder.cn/Java/Concurrent/Interview/\n* http://www.importnew.com/28263.html\n","tags":["Java"],"categories":["server"]},{"title":"并发多线程(十一)CompareAndSwap(CAS)","url":"/2019/05/02/backend/java/concurrent1/并发多线程(十一)CompareAndSwap(CAS)/","content":"## 概述\n* CAS ，Compare And Swap ，即比较并交换。Doug Lea 大神在实现同步组件时，大量使用CAS 技术，鬼斧神工地实现了Java 多线程的并发操作。整个 AQS 同步组件、Atomic 原子类操作等等都是基 CAS 实现的\n\n## CAS分析\n* 在 CAS 中有三个参数：内存值 V、旧的预期值 A、要更新的值 B ，当且仅当内存值 V 的值等于旧的预期值 A 时，才会将内存值V的值修改为 B ，否则就再次尝试。其伪代码如下：\n```java\nif (this.value == A) {\n    this.value = B\n    return true;\n} else {\n\treturn false;\n}\n```\n* 这样说或许有些抽象，我们来看一个例子：\n    * 1.在内存地址V当中，存储着值为10的变量。\n    \n    ![](/images/server/java/Concurrent/cas1.jpg)\n    \n    * 2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。\n    \n    ![](/images/server/java/Concurrent/cas2.jpg)\n    * 3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。\n    \n    ![](/images/server/java/Concurrent/cas3.jpg)\n    * 4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。\n    \n    ![](/images/server/java/Concurrent/cas4.jpg)\n    * 5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。\n    \n    ![](/images/server/java/Concurrent/cas5.jpg)\n    * 6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。\n    \n    ![](/images/server/java/Concurrent/cas6.jpg)\n    * 7.线程1进行SWAP，把地址V的值替换为B，也就是12。\n    \n    ![](/images/server/java/Concurrent/cas7.jpg)\n    *\n\n* 由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。\n\n* J.U.C 下的 Atomic 类，都是通过 CAS 来实现的。下面就以 AtomicInteger 为例，来阐述 CAS 的实现。如下：\n\n* 我们就以 AtomicInteger 的 #addAndGet() 方法来做说明，先看源代码：\n```java\n// AtomicInteger.java\npublic final int addAndGet(int delta) {\n    return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n}\n\n// Unsafe.java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n```\n* 关注 `public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);`\n```java\n                                              对象          对象的地址  预期值    修改值\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n### CPU指令对CAS的支持\n* 或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，\n* 因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。\n\n#### 鲜为人知的指针: Unsafe类\n* Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下：\n* 内存管理，Unsafe类中存在直接操作内存的方法；\n```java\n// 分配内存指定大小的内存\npublic native long allocateMemory(long bytes);\n\n// 根据给定的内存地址address设置重新分配指定大小的内存\npublic native long reallocateMemory(long address, long bytes);\n\n// 用于释放allocateMemory和reallocateMemory申请的内存\npublic native void freeMemory(long address);\n\n// 将指定对象的给定offset偏移量内存块中的所有字节设置为固定值\npublic native void setMemory(Object o, long offset, long bytes, byte value);//设置给定内存地址的值public native void putAddress(long address, long x);\n\n// 获取指定内存地址的值\npublic native long getAddress(long address);\n\n// 设置给定内存地址的long值\npublic native void putLong(long address, long x);\n\n// 获取指定内存地址的long值\npublic native long getLong(long address);\n\n// 设置或获取指定内存的byte值\n// 其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同\npublic native byte getByte(long address);\n\npublic native void putByte(long address, byte x);\n```\n* CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现\n```java\n\n//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，\n//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。\npublic final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  \n \npublic final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);\n \npublic final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);\n```\n\n### CAS缺陷\n* CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面：\n    * 循环时间太长\n        * 如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销。在 J.U.C 中，有些地方就限制了 CAS 自旋的次数，例如： BlockingQueue 的 SynchronousQueue 。     \n    * 只能保证一个共享变量原子操作\n        * 看了 CAS 的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用 CAS 也不错。例如读写锁中 state 的高低位。\n    * ABA 问题\n        * CAS 需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是 A，变成了 B，然后又变成了 A，那么在 CAS 检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于 ABA 问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加 1 ，即 A —> B —> A ，变成1A —> 2B —> 3A 。\n          \n\n## 总结：\n* 从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。\n\n## 参考\n* http://www.iocoder.cn/JUC/sike/CAS/\n* https://blog.csdn.net/mmoren/article/details/79185862 ","tags":["Java"],"categories":["server"]},{"title":"并发多线程(十)Condition","url":"/2019/05/02/backend/java/concurrent1/并发多线程(十)Condition/","content":"## 简介\n> Condition\n\n* 在没有 Lock 之前，我们使用 synchronized 来控制同步，配合 Object 的 #wait()、#notify() 等一系列方法可以实现等待 / 通知模式。在 Java SE 5 后，Java 提供了 Lock 接口，相对于 synchronized 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活。下图是 Condition 与 Object 的监视器方法的对比（摘自《Java并发编程的艺术》）：\n\n![](/images/server/java/Concurrent/condition1.png)\n\n* `java.util.concurrent.locks.Condition` 条件 Condition 接口，定义了一系列的方法，来对阻塞和唤醒线程：\n```java\n// ========== 阻塞 ==========\nvoid await() throws InterruptedException; // 造成当前线程在接到信号或被中断之前一直处于等待状态。\nvoid awaitUninterruptibly(); // 造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。\nlong awaitNanos(long nanosTimeout) throws InterruptedException; // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在`nanosTimeout` 之前唤醒，那么返回值 `= nanosTimeout - 消耗时间` ，如果返回值 `<= 0` ,则可以认定它已经超时了。\nboolean await(long time, TimeUnit unit) throws InterruptedException; // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。\nboolean awaitUntil(Date deadline) throws InterruptedException; // 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回 true ，否则表示到了指定时间，返回返回 false 。\n\n// ========== 唤醒 ==========\nvoid signal(); // 唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。\nvoid signalAll(); // 唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。\n```\n* Condition是个接口，基本的方法就是await()和signal()方法；\n* Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() \n* 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用\n    * Conditon中的await()对应Object的wait()；\n    * Condition中的signal()对应Object的notify()；\n    * Condition中的signalAll()对应Object的notifyAll()。\n* 示例代码\n```java\npublic class ConditionTest {\n    final Lock lock = new ReentrantLock();\n    // 获取的是ConditionObject\n    final Condition condition = lock.newCondition();\n\n    public static void main(String[] args) {\n        ConditionTest conditionTest = new ConditionTest();\n        Consumer consumer = conditionTest.new Consumer();\n        Producer producer = conditionTest.new Producer();\n\n        consumer.start();\n        producer.start();\n\n    }\n\n    class Consumer extends Thread {\n        @Override\n        public void run() {\n            try {\n                lock.lock();\n                System.out.println(\"消费者：我在等一个新信号\" + currentThread().getName());\n                condition.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                System.out.println(\"消费者：拿到一个信号\" + currentThread().getName());\n                lock.unlock();\n            }\n        }\n    }\n    class Producer extends Thread {\n        @Override\n        public void run() {\n            try {\n                lock.lock();\n                System.out.println(\"生产者：我拿到了锁\" + currentThread().getName());\n                condition.signalAll();\n                System.out.println(\"生产者：我发出了一个信号\" + currentThread().getName());\n            } finally {\n\n                lock.unlock();\n            }\n        }\n    }\n}\n```\n* 运行结果\n```java\n\"C:\\Program Files\\Java\\jdk1.7.0_80\\bin\\java\" \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2017.2.1\\lib\\idea_rt.jar=54974:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2017.2.1\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\rt.jar;D:\\workspace-github\\jvm\\target\\production\\jvm\" com.songsy.jdk.concurrent.ConditionTest\n消费者：我在等一个新信号Thread-0\n生产者：我拿到了锁Thread-1\n生产者：我发出了一个信号Thread-1\n消费者：拿到一个信号Thread-0\n\nProcess finished with exit code 0\n```\n* Condition的执行方式，是当在线程Consumer中调用await方法后，线程Consumer将释放锁，并且将自己沉睡，等待唤醒，线程Producer获取到锁后，开始做事，完毕后，调用Condition的signalall方法，唤醒线程Consumer，线程Consumer恢复执行。\n* 以上说明Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备( signal 或者 signalAll方法被带调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁。\n\n> ConditionObject\n\n* 获取一个 Condition 必须要通过 Lock 的 #newCondition() 方法。该方法定义在接口 Lock 下面，返回的结果是绑定到此 Lock 实例的新 Condition 实例。Condition 为一个接口，其下仅有一个实现类 ConditionObject ，由于 Condition 的操作需要获取相关的锁，而 AQS则是同步锁的实现基础，所以 ConditionObject 则定义为 AQS 的内部类。代码如下：\n\n```java\npublic class ConditionObject implements Condition, java.io.Serializable {\n    /**\n    * 我们知道一个Condition可以在多个地方被await()，那么就需要一个FIFO的结构将这些Condition串联起来，\n    * 然后根据需要唤醒一个或者多个（通常是所有）。所以在Condition内部就需要一个FIFO的队列。\n    */\n    /** First node of condition queue. */\n    private transient Node firstWaiter; // 头节点\n    /** Last node of condition queue. */\n    private transient Node lastWaiter; // 尾节点\n    \n    public ConditionObject() {\n    }\n\n    // ... 省略内部代码\n}\n```\n* 从代码中可以看出`ConditionObject` 拥有首节点（firstWaiter），尾节点（lastWaiter）。当前线程调用 #await()方法时，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾部\n* Node 里面包含了当前线程的引用。Node 定义与 AQS 的 CLH 同步队列的节点使用的都是同一个类（AbstractQueuedSynchronized 的 Node 静态内部类）。\n\n## 大体实现流程\n* AQS等待队列与Condition队列是两个相互独立的队列 \n    * await()就是在当前线程持有锁的基础上释放锁资源，并新建Condition节点加入到Condition的队列尾部，阻塞当前线程 \n    * signal()就是将Condition的头节点移动到AQS等待节点尾部，让其等待再次获取锁\n* 以下是AQS队列和Condition队列的出入结点的示意图，可以通过这几张图看出线程结点在两个队列中的出入关系和条件。\n\n![](/images/server/java/Concurrent/condition2.png)\n\n* 一：AQS等待队列有3个Node，Condition队列有1个Node(也有可能1个都没有)，节点1执行Condition.await()\n    * 1.将head后移 \n    * 2.释放节点1的锁并从AQS等待队列中移除 \n    * 3.将节点1加入到Condition的等待队列中 \n    * 4.更新lastWaiter为节点1\n    \n![](/images/server/java/Concurrent/condition3.png)\n\n* 二：节点2执行signal()操作 \n    * 5.将firstWaiter后移 \n    * 6.将节点4移出Condition队列 \n    * 7.将节点4加入到AQS的等待队列中去 \n    * 8.更新AQS的等待队列的tail\n\n![](/images/server/java/Concurrent/condition4.png)\n\n* await\n    * 调用 Condition 的 #await() 方法，会使当前线程进入等待状态，同时会加入到 Condition 等待队列，并且同时释放锁。当从 #await() 方法结束时，当前线程一定是获取了Condition 相关联的锁。\n    \n* signal\n    * 调用 ConditionObject的 #signal() 方法，将会唤醒在等待队列中等待最长时间的节点（条件队列里的首节点），在唤醒节点前，会将节点移到CLH同步队列中。\n\n## 示例\n* 生产者和消费者\n```java\npublic class ConsumerProducer {\n    private int storage;\n    private int putCounter;\n    private int getCounter;\n    private Lock lock = new ReentrantLock();\n    private Condition putCondition = lock.newCondition();\n    private Condition getCondition = lock.newCondition();\n\n    public void put() throws InterruptedException {\n        try {\n            lock.lock();\n            if (storage > 0) {\n                putCondition.await();\n            }\n            storage++;\n            System.out.println(\"put => \" + ++putCounter );\n            getCondition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void get() throws InterruptedException {\n        try {\n            lock.lock();\n            lock.lock();\n            if (storage <= 0) {\n                getCondition.await();\n            }\n            storage--;\n            System.out.println(\"get  => \" + ++getCounter);\n            putCondition.signal();\n        } finally {\n            lock.unlock();\n            lock.unlock();\n        }\n    }\n\n    public class PutThread extends Thread {\n        @Override\n        public void run() {\n            for (int i = 0; i < 100; i++) {\n                try {\n                    put();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n    }\n\n    public class GetThread extends Thread {\n        @Override\n        public void run() {\n            for (int i = 0; i < 100; i++) {\n                try {\n                    get();\n                } catch (InterruptedException e) {\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final ConsumerProducer test = new ConsumerProducer();\n        Thread put = test.new PutThread();\n        Thread get = test.new GetThread();\n        put.start();\n        get.start();\n    }\n}\n\n```\n\n## 总结：\n* 一个线程获取锁后，通过调用 Condition 的 #await() 方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过 #isOnSyncQueue(Node node) 方法，不断自检看节点是否已经在 CLH 同步队列了，如果是则尝试获取锁，否则一直挂起。\n* 当线程调用 #signal() 方法后，程序首先检查当前线程是否获取了锁，然后通过#doSignal(Node first) 方法唤醒CLH同步队列的首节点。被唤醒的线程，将从 #await() 方法中的 while 循环中退出来，然后调用 #acquireQueued(Node node, int arg) 方法竞争同步状态。\n\n## 参考\n* http://www.iocoder.cn/JUC/sike/Condition/\n* https://blog.csdn.net/coslay/article/details/45217069","tags":["Java"],"categories":["server"]},{"title":"并发多线程(九)ReadWriteLock与ReentrantReadWriteLock","url":"/2019/04/29/backend/java/concurrent1/并发多线程(九)ReadWriteLock与ReentrantReadWriteLock/","content":"## 简介\n* 重入锁 ReentrantLock 是排他锁，排他锁在同一时刻仅有一个线程可以进行访问，但是在大多数场景下，大部分时间都是提供读服务，而写服务占有的时间较少。然而，读服务不存在数据竞争问题，如果一个线程在读时禁止其他线程读势必会导致性能降低。所以就提供了读写锁。\n\n* 读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升：\n    * 在同一时间，可以允许多个读线程同时访问。\n    * 是，在写线程访问时，所有读线程和写线程都会被阻塞。\n* 读写锁的主要特性：\n    * 公平性：支持公平性和非公平性。\n    * 重入性：支持重入。读写锁最多支持 65535 个递归写入锁和 65535 个递归读取锁。\n    * 锁降级：遵循获取写锁，再获取读锁，最后释放写锁的次序，如此写锁能够降级成为读锁。\n## 示例\n* ReadWriteLock\n    * ReadWriteLock也是一个接口，在它里面只定义了两个方法：\n        ```java\n        public interface ReadWriteLock {\n            /**\n             * Returns the lock used for reading.\n             *\n             * @return the lock used for reading.\n             */\n            Lock readLock();\n         \n            /**\n             * Returns the lock used for writing.\n             *\n             * @return the lock used for writing.\n             */\n            Lock writeLock();\n        }\n        ```\n    * 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。\n* 4.ReentrantReadWriteLock\n    * ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。\n    * 下面通过几个例子来看一下ReentrantReadWriteLock具体用法。\n    * 假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：\n        ```java\n        public class Test {\n            private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n             \n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n            }  \n             \n            public synchronized void get(Thread thread) {\n                long start = System.currentTimeMillis();\n                while(System.currentTimeMillis() - start <= 1) {\n                    System.out.println(thread.getName()+\"正在进行读操作\");\n                }\n                System.out.println(thread.getName()+\"读操作完毕\");\n            }\n        }\n        ```\n    * 这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。\n        ```java\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0读操作完毕\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1读操作完毕\n        ```\n    * 而改成用读写锁的话：\n        ```java\n        public class Test {\n            private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n             \n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n            }  \n             \n            public void get(Thread thread) {\n                rwl.readLock().lock();\n                try {\n                    long start = System.currentTimeMillis();\n                     \n                    while(System.currentTimeMillis() - start <= 1) {\n                        System.out.println(thread.getName()+\"正在进行读操作\");\n                    }\n                    System.out.println(thread.getName()+\"读操作完毕\");\n                } finally {\n                    rwl.readLock().unlock();\n                }\n            }\n        }\n        ```\n     * 此时打印的结果为：\n         ```java\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0读操作完毕\n        Thread-1读操作完毕\n         ```\n     * 说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。\n\n\n\n## 四.总结\n\n## 参考转载\n* https://www.cnblogs.com/dolphin0520/p/3932921.html","tags":["jvm"],"categories":["服务器"]},{"title":"并发多线程(八)Reentrantlock重入锁","url":"/2019/04/29/backend/java/concurrent1/并发多线程(八)Reentrantlock重入锁/","content":"## 简介\n* ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。它可以等同于 synchronized 的使用，但是 ReentrantLock 提供了比 synchronized 更强大、灵活的锁机制，可以减少死锁发生的概率。\n    * 一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。\n\n\n## 示例\n* ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。\n\n* lock()的错误使用方法\n    * 代码\n        ```java\n        public class Test {\n            private ArrayList<Integer> arrayList = new ArrayList<Integer>();\n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n            }  \n             \n            public void insert(Thread thread) {\n                Lock lock = new ReentrantLock();    //注意这个地方\n                lock.lock();\n                try {\n                    System.out.println(thread.getName()+\"得到了锁\");\n                    for(int i=0;i<5;i++) {\n                        arrayList.add(i);\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }finally {\n                    System.out.println(thread.getName()+\"释放了锁\");\n                    lock.unlock();\n                }\n            }\n        }\n        ```\n    * 各位朋友先想一下这段代码的输出结果是什么？\n        ```java\n        Thread-0得到了锁\n        Thread-1得到了锁\n        Thread-0释放了锁\n        Thread-1释放了锁\n        ```\n    * 也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。\n    * 知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。\n        ```java\n        public class Test {\n            private ArrayList<Integer> arrayList = new ArrayList<Integer>();\n            private Lock lock = new ReentrantLock();    //注意这个地方\n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n            }  \n             \n            public void insert(Thread thread) {\n                lock.lock();\n                try {\n                    System.out.println(thread.getName()+\"得到了锁\");\n                    for(int i=0;i<5;i++) {\n                        arrayList.add(i);\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }finally {\n                    System.out.println(thread.getName()+\"释放了锁\");\n                    lock.unlock();\n                }\n            }\n        }\n        ```\n    * 这样就是正确地使用Lock的方法了。\n* tryLock()的使用方法\n    * 代码\n        ```java\n        public class Test {\n            private ArrayList<Integer> arrayList = new ArrayList<Integer>();\n            private Lock lock = new ReentrantLock();    //注意这个地方\n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n            }  \n             \n            public void insert(Thread thread) {\n                if(lock.tryLock()) {\n                    try {\n                        System.out.println(thread.getName()+\"得到了锁\");\n                        for(int i=0;i<5;i++) {\n                            arrayList.add(i);\n                        }\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                    }finally {\n                        System.out.println(thread.getName()+\"释放了锁\");\n                        lock.unlock();\n                    }\n                } else {\n                    System.out.println(thread.getName()+\"获取锁失败\");\n                }\n            }\n        }\n        ```\n    * 输出结果：\n        ```java\n        Thread-0得到了锁\n        Thread-1获取锁失败\n        Thread-0释放了锁\n        ```\n* lockInterruptibly()响应中断的使用方法：\n    * 代码：\n        ```java\n        public class Test {\n            private Lock lock = new ReentrantLock();   \n            public static void main(String[] args)  {\n                Test test = new Test();\n                MyThread thread1 = new MyThread(test);\n                MyThread thread2 = new MyThread(test);\n                thread1.start();\n                thread2.start();\n                 \n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                thread2.interrupt();\n            }  \n             \n            public void insert(Thread thread) throws InterruptedException{\n                lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出\n                try {  \n                    System.out.println(thread.getName()+\"得到了锁\");\n                    long startTime = System.currentTimeMillis();\n                    for(    ;     ;) {\n                        if(System.currentTimeMillis() - startTime >= Integer.MAX_VALUE)\n                            break;\n                        //插入数据\n                    }\n                }\n                finally {\n                    System.out.println(Thread.currentThread().getName()+\"执行finally\");\n                    lock.unlock();\n                    System.out.println(thread.getName()+\"释放了锁\");\n                }  \n            }\n        }\n         \n        class MyThread extends Thread {\n            private Test test = null;\n            public MyThread(Test test) {\n                this.test = test;\n            }\n            @Override\n            public void run() {\n                 \n                try {\n                    test.insert(Thread.currentThread());\n                } catch (InterruptedException e) {\n                    System.out.println(Thread.currentThread().getName()+\"被中断\");\n                }\n            }\n        }\n        ```\n    * 运行之后，发现thread2能够被正确中断\n        ```java\n        Thread-0得到了锁\n        Thread-1被中断\n        ```\n        \n## 总结\n* 与 synchronized 相比，ReentrantLock提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。\n* ReentrantLock 还提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock 更加适合（以后会阐述Condition）。\n* ReentrantLock 提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而 synchronized 则一旦进入锁请求要么成功要么阻塞，所以相比 synchronized 而言，ReentrantLock会不容易产生死锁些。\n* ReentrantLock 支持更加灵活的同步代码块，但是使用 synchronized 时，只能在同一个 synchronized 块结构中获取和释放。注意，ReentrantLock 的锁释放一定要在 finally 中处理，否则可能会产生严重的后果。\n* ReentrantLock 支持中断处理，且性能较 synchronized 会好些。\n\n## 参考转载\n* http://www.iocoder.cn/JUC/sike/ReentrantLock/","tags":["jvm"],"categories":["服务器"]},{"title":"并发多线程(七)AbstractQueuedSynchronizer","url":"/2019/04/29/backend/java/concurrent1/并发多线程(七)AbstractQueuedSynchronizer/","content":"## 简介\n* `AbstractQueuedSynchronizer`(`AQS` ) 即队列同步器。它是构建锁或者其他同步组件的基础框架（如 `ReentrantLock、ReentrantReadWriteLock、Semaphore` 等），它使用了一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程的派对工作 J.U.C 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 J.U.C 并发包中的核心基础组件。\n\n### 优势\n* AQS 解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO 同步队列。基于 AQS 来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。\n* 在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中，所有基于 AQS 构建的同步器均可以获得这个优势。\n\n### 同步状态\n* AQS 的主要使用方式是继承，子类通过继承同步器，并实现它的抽象方法来管理同步状态。\n\n* AQS 使用一个 int 类型的成员变量 state 来表示同步状态：\n    * 当 state > 0 时，表示已经获取了锁。\n    * 当 state = 0 时，表示释放了锁。\n* 它提供了三个方法，来对同步状态 state 进行操作，并且 AQS 可以确保对 state 的操作是安全的：\n    * getState()\n    * setState(int newState)\n    * compareAndSetState(int expect, int update)\n* \n\n### 同步队列\n* AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作：\n    * 如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程\n    * 当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。\n    \n* 同步器的开始提到了其实现依赖于一个FIFO队列，该队列就是 CLH 同步队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。\n* Node 是 AbstractQueuedSynchronizer 的内部静态类，Node的主要包含以下成员变量：\n\n|   属性名称   |      描述        |\n|:-------|:-------------|\n|   int waitStatus  |     表示节点的状态。其中包含的状态有：<br>1. CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待表示当前的线程被取消；<br>2. SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，将会通知后继节点，使后继节点的线程得以运行；<br>3. CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；<br>4. PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；<br> 5. 值为0，表示当前节点在sync队列中，等待着获取锁。|\n| Node prev| 前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。|\n| Node next| 后继节点。|\n| Node nextWaiter  | 存储condition队列中的后继节点。   |\n| Thread thread | 入队列时的当前线程。 |\n* 入列\n    * 学了数据结构的我们，CLH 队列入列是再简单不过了\n        * tail 指向新节点。\n        * 新节点的 prev 指向当前最后的节点。\n        * 当前最后一个节点的 next 指向当前节点。\n    * 过程图如下：\n    \n     ![](/images/server/java/Concurrent/clh1.png)\n    * 实际上，入队逻辑实现的 #addWaiter(Node) 方法，需要考虑并发的情况。它通过 CAS 的方式，来保证正确的添加 Node 。代码如下：\n    ```java\n    /**\n     * Creates and enqueues node for current thread and given mode.\n     *\n     * mode 方法参数，传递获取同步状态的模式。\n     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared\n     * @return the new node\n     */\n    private Node addWaiter(Node mode) {\n        // 新建节点\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        // 记录原尾节点\n        Node pred = tail;\n        // 快速尝试，添加新节点为尾节点\n        if (pred != null) {\n            // 设置新 Node 节点的尾节点为原尾节点\n            node.prev = pred;\n            // CAS 设置新的尾节点\n            if (compareAndSetTail(pred, node)) {\n                // 成功，原尾节点的下一个节点为新节点\n                pred.next = node;\n                return node;\n            }\n        }\n        // 失败，多次尝试，直到成功\n        enq(node);\n        return node;\n    }\n  \n  \n    /**\n     * Inserts node into queue, initializing if necessary. See picture above.\n     * @param node the node to insert\n     * @return node's predecessor\n     */\n    private Node enq(final Node node) {\n        // 死循环，多次尝试，直到成功添加为止\n        for (;;) {\n            // 记录原尾节点\n            Node t = tail;\n            // 原尾节点不存在，创建首尾节点都为 new Node()\n            if (t == null) { // Must initialize\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else { // 原尾节点存在，添加新节点为尾节点\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n    ```\n* 出队\n    * CLH 同步队列遵循 FIFO，首节点的线程释放同步状态后，将会唤醒它的下一个节点（Node.next）。而后继节点将会在获取同步状态成功时，将自己设置为首节点( head )。\n    * 这个过程非常简单，head 执行该节点并断开原首节点的 next 和当前节点的 prev 即可。注意，在这个过程是不需要使用 CAS 来保证的，因为只有一个线程，能够成功获取到同步状态。\n    * 过程图如下：\n    \n         ![](/images/server/java/Concurrent/clh2.png)\n    * setHead(Node node) 方法，实现上述的出列逻辑。代码如下：\n    ```java\n    private void setHead(Node node) {\n        head = node;\n        node.thread = null;\n        node.prev = null;\n    }\n    ```\n![](/images/server/java/Concurrent/clh.png)\n\n\n### API说明\n* 实现自定义同步器时，需要使用同步器提供的getState()、setState()和compareAndSetState()方法来操纵状态的变迁。\n\n|   方法名称   |      描述        |\n|:-------|:-------------|\n| getState()| 返回同步状态的当前值。|\n| setState(int newState)|设置当前同步状态。 |\n| compareAndSetState(int expect, int update)|使用 CAS 设置当前状态，该方法能够保证状态设置的原子性。 |\n|   protected boolean tryAcquire(int arg)        | 【可重写】排它的获取这个状态。这个方法的实现需要查询当前状态是否允许获取，然后再进行获取（使用compareAndSetState来做）状态。|\n|   protected boolean tryRelease(int arg)        | 【可重写】释放状态。|\n|   protected int tryAcquireShared(int arg)      | 【可重写】共享的模式下获取状态。|\n|   protected boolean tryReleaseShared(int arg)  | 【可重写】共享的模式下释放状态。   |\n|   protected boolean isHeldExclusively()        | 【可重写】在排它模式下，状态是否被占用。 |\n| acquire(int arg)| 独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回；否则，将会进入同步队列等待。该方法将会调用可重写的 #tryAcquire(int arg) 方法；|\n| acquireInterruptibly(int arg)|与 acquire(int arg) 相同，但是该方法响应中断。当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException 异常并返回。 |\n| tryAcquireNanos(int arg, long nanos)|超时获取同步状态。如果当前线程在 nanos 时间内没有获取到同步状态，那么将会返回 false ，已经获取则返回 true 。 |\n| acquireShared(int arg)| 共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态；|\n| acquireSharedInterruptibly(int arg)| 共享式获取同步状态，响应中断。|\n| tryAcquireSharedNanos(int arg, long nanosTimeout)| 共享式获取同步状态，增加超时限制。|\n| release(int arg)|独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。 |\n| releaseShared(int arg)|共享式释放同步状态。 |\n\n### 同步状态的获取与释放\n* AQS 的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态。对于子类而言，它并没有太多的活要做，AQS 已经提供了大量的模板方法来实现同步，主要是分为三类：\n    * 独占式获取和释放同步状态\n    * 共享式获取和释放同步状态\n    * 查询同步队列中的等待线程情况。\n    \n> 独占式: 同一时刻，仅有一个线程持有同步状态。\n* \n![](/images/server/java/Concurrent/clh3.png)\n\n\n> 共享式: 共享式与独占式的最主要区别在于，同一时刻：1、独占式只能有一个线程获取同步状态。2、共享式可以有多个线程获取同步状态。\n\n## 总结：\n* 等待队列是FIFO先进先出。 \n* 加入同步队列后，并不是立即挂起，而是再次进行获取同步状态, 到挂起之前都是在自旋（无限循环尝试），因为同步状态的变化很快，线程上下文的切换比较耗时，所以用短暂的自旋来换取时间开销，当然如果一直自旋，那么开销反而大于了线程切换。所以把自旋时间（次数）控制在一定范围有利于提高性能。\n\n\n## 参考\n* http://www.iocoder.cn/JUC/sike/aqs-0-intro/\n* https://blog.csdn.net/u014634338/article/details/77168608","tags":["Java"],"categories":["server"]},{"title":"并发多线程(六)ThreadLocal","url":"/2019/04/20/backend/java/concurrent1/并发多线程(六)ThreadLocal/","content":"## ThreadLocal 作用\n在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。\n\n如果是你，该如何实现上述功能？常规的思路如下：\n使用一个线程共享的Map<Thread,Object>，Map中的key为线程对象，value即为需要存储的值。那么，我们只需要通过map.get(Thread.currentThread())即可获取本线程中该变量的值。\n\n这种方式确实可以实现我们的需求，但它有何缺点呢？——答案就是：需要同步，效率低！\n\n由于这个map对象需要被所有线程共享，因此需要加锁来保证线程安全性。当然我们可以使用java.util.concurrent.*包下的ConcurrentHashMap提高并发效率，但这种方法只能降低锁的粒度，不能从根本上避免同步锁。而JDK提供的ThreadLocal就能很好地解决这一问题。下面来看看ThreadLocal是如何高效地实现这一需求的。\n\n\n\n## ThreadLocal 是什么\n> ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。\n\n## ThreadLocal 解析\n\n> ThreadLocal的内部结构图\n\n![threadLocal](/images/server/java/三高/threadLocal.jpg)\n\n\n从上面的结构图，我们已经窥见ThreadLocal的核心机制：\n\n每个Thread线程内部都有一个Map。\n\nMap里面存储线程本地对象（key）和线程的变量副本（value）\n\n但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。\n\n所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。\n\nThread线程内部的Map在类中描述如下:\n```java\n    /* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n```\n\n### ThreadLocal类提供如下几个核心方法：\n* get()方法用于获取当前线程的副本变量值。\n* set()方法用于保存当前线程的副本变量值。\n* initialValue()为当前线程初始副本变量值。\n* remove()方法移除当前前程的副本变量值。\n\n\n```java\n    /**\n     * 返回当前线程的副本变量\n     * Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local\n     */\n    public T get() {\n        Thread t = Thread.currentThread();\n        // 返回Thread 对象中的ThreadLocalMap\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        // 如果没有值的话调用默认setInitialValue()方法\n        return setInitialValue();\n    }\n    /**\n     * 存放在Thread的 threadLocals\n     * Get the map associated with a ThreadLocal. Overridden in\n     * InheritableThreadLocal.\n     *\n     * @param  t the current thread\n     * @return the map\n     */\n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n    /**\n     * 设置初始值\n     * Variant of set() to establish initialValue. Used instead\n     * of set() in case user has overridden the set() method.\n     *\n     * @return the initial value\n     */\n    private T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }\n    // map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。\n    protected T initialValue() {\n        return null;\n    }\n    /**\n     * 赋值\n     * Sets the current thread's copy of this thread-local variable\n     * to the specified value.  Most subclasses will have no need to\n     * override this method, relying solely on the {@link #initialValue}\n     * method to set the values of thread-locals.\n     *\n     * @param value the value to be stored in the current thread's copy of\n     *        this thread-local.\n     */\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n    /**\n     * Removes the current thread's value for this thread-local\n     * variable.  If this thread-local variable is subsequently\n     * {@linkplain #get read} by the current thread, its value will be\n     * reinitialized by invoking its {@link #initialValue} method,\n     * unless its value is {@linkplain #set set} by the current thread\n     * in the interim.  This may result in multiple invocations of the\n     * {@code initialValue} method in the current thread.\n     *\n     * @since 1.5\n     */\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n    \n    \n```\n\n### ThreadLocalMap\n* ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现:\n```java\n    static class ThreadLocalMap {\n        /**\n         * 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象   \n         * \n         * The entries in this hash map extend WeakReference, using\n         * its main ref field as the key (which is always a\n         * ThreadLocal object).  Note that null keys (i.e. entry.get()\n         * == null) mean that the key is no longer referenced, so the\n         * entry can be expunged from table.  Such entries are referred to\n         * as \"stale entries\" in the code that follows.\n         */\n        static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                // Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。\n                super(k);\n                value = v;\n            }\n        }\n    }\n```\n## ThreadLocalMap的问题\n\n由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。\n\n### Java的四种引用方式\n* Java的数据类型分为两类：基本数据类型、引用数据类型。\n    * 基本数据类型的值存储在栈内存中\n    * 引用数据类型需要开辟两块存储空间，一块在堆内存中，用于存储该类型的对象；另一块在栈内存中，用于存储堆内存中该对象的引用。\n\n* Java对象的引用类型包括: `强引用，软引用，弱引用，虚引用`\n\n* Java中提供这四种引用类型主要有两个目的：\n    * 第一是可以让程序员通过代码的方式决定某些对象的生命周期，随着 java.lang.ref这个包下的类的引进，程序员拥有了一点点控制你创建的对象何时释放，销毁的权利\n    * 第二是有利于JVM进行垃圾回收\n> 强引用\n* 强引用，就是我们最常见的普通对象引用，我们 new 出来的对象就是强引用，只要尚且存在强引用指向某一个对象，那就能表明该对象还存活，GC 不能去回收这种对象。需要回收强引用指向的对象，可以等待超出引用区域，或者是显式设置对象为 null，就可以通知让 GC 回收，当然实际的回收时间要看 GC 策略。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个对象，new出来的对象都是分配在java堆中的\n        Sample sample = new Sample();   // sample这个引用就是强引用\n        \n        sample = null;                  // 将这个引用指向空指针,\n                                        // 那么上面那个刚new来的对象就没用任何其它有效的引用指向它了\n                                        // 也就说该对象对于垃圾收集器是符合条件的\n                                        // 因此在接下来某个时间点 GC进行收集动作的时候, 该对象将会被销毁，内存被释放\n    }\n}\nclass Sample {\n}\n```\n* 也可以画个简单的图理解一下：\n\n![](/images/server/java/Concurrent/threadlocal.png)\n\n> 软引用\n\n* 当内存资源充足的时候，垃圾回收器不会回收软引用对应的对象的内存空间；但当内存资源紧张时，软引用所对应的对象就会被垃圾回收器回收。\n\n* 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。   SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。\n\n* 也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个对象，new出来的对象都是分配在java堆中的\n        Sample sample = new Sample();   //sample这个引用就是强引用\n        // 创建一个软引用指向这个对象   那么此时就有两个引用指向Sample对象\n        SoftReference<Sample> softRef = new SoftReference<Sample>(sample);\n        \n        // 将强引用指向空指针 那么此时只有一个软引用指向Sample对象\n        // 注意：softRef这个引用也是强引用，它是指向SoftReference这个对象的\n        // 那么这个软引用在哪呢？ 可以跟一下java.lang.Reference的源码 \n        // private T referent; 这个才是软引用， 只被jvm使用\n        sample = null;\n\n        // 可以重新获得Sample对象，并用一个强引用指向它\n        sample = softRef.get();\n    }\n}\nclass Sample {\n}\n```\n\n![](/images/server/java/Concurrent/threadLocal1.png)\n\n* 利用软引用解决OOM问题\n    * 下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。\n    * 示例代码\n    ```java\n    private Map<String, SoftReference<Bitmap>> imageCache = new HashMap<String, SoftReference<Bitmap>>();\n\n    public void addBitmapToCache(String path) {\n        // 强引用的Bitmap对象\n        Bitmap bitmap = BitmapFactory.decodeFile(path);\n \n        // 软引用的Bitmap对象\n        SoftReference<Bitmap> softBitmap = new SoftReference<Bitmap>(bitmap);\n \n        // 添加该对象到Map中使其缓存\n        imageCache.put(path, softBitmap);\n    }\n    public Bitmap getBitmapByPath(String path) {\n        // 从缓存中取软引用的Bitmap对象\n        SoftReference<Bitmap> softBitmap = imageCache.get(path);\n    \n        // 判断是否存在软引用\n        if (softBitmap == null) {\n            return null;\n        }\n        // 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空\n        Bitmap bitmap = softBitmap.get();\n        return bitmap;\n    }\n    ```\n\n> 弱引用\n* 弱引用会被Jvm忽略，也就说在GC进行垃圾收集的时候，如果一个对象只有弱引用指向它，那么和没有引用指向它是一样的效果，jvm都会对它就行果断的销毁，释放内存。\n* 那么，ThreadLocalMap中的key使用弱引用的原因也是如此。当一条线程中的ThreadLocal对象使用完毕，没有强引用指向它的时候，垃圾收集器就会自动回收这个Key，从而达到节约内存的目的。\n```java\nWeakReference<Person> wr = new WeakReference<Person>(new Person()); \n```\n> 虚引用\n```java\n虚引用等于没有引用，无法通过虚引用访问其对应的对象。\n\n虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。\n```\n\n\n\n### 如何避免泄漏\n\n既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。\n\n如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。\n\n## ThreadLocal 应用场景\n> Hibernate的session获取场景：每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。\n                        \n```java\nprivate static final ThreadLocal<Session> threadLocal = new ThreadLocal<Session>();\n\n// 获取Session\npublic static Session getCurrentSession(){\n    Session session =  threadLocal.get();\n    // 判断Session是否为空，如果为空，将创建一个session，并设置到本地线程变量中\n    try {\n        if(session == null && !session.isOpen()){\n            if(sessionFactory == null){\n                // 创建Hibernate的SessionFactory\n                rbuildSessionFactory();\n            }else{\n                session = sessionFactory.openSession();\n            }\n        }\n        threadLocal.set(session);\n    } catch (Exception e) {\n        // TODO: handle exception\n    }\n\n    return session;\n}\n```\n\n## 总结：\n* 每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。\n* ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。\n* 适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。\n\n## 参考\n* https://www.jianshu.com/p/98b68c97df9b\n* https://www.jianshu.com/p/3f3620f9011d\n* https://blog.csdn.net/rodbate/article/details/72857447\n* https://www.cnblogs.com/dolphin0520/p/3784171.html","tags":["Java"],"categories":["server"]},{"title":"并发多线程(五)ThreadPoolExecutor线程池","url":"/2019/04/05/backend/java/concurrent1/并发多线程(五)ThreadPoolExecutor线程池/","content":"## 概述\n* 在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。\n\n* 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的ThreadPoolExecutor类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。\n## Java中的ThreadPoolExecutor类\n\n![](/images/server/java/Concurrent/ThreadPoolExecutor.png)\n\n* `java.uitl.concurrent.ThreadPoolExecutor`类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下`ThreadPoolExecutor`类的具体实现源码。\n```java\npublic class ThreadPoolExecutor extends AbstractExecutorService {\n    .....\n    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,\n            BlockingQueue<Runnable> workQueue);\n \n    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,\n            BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory);\n \n    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,\n            BlockingQueue<Runnable> workQueue,RejectedExecutionHandler handler);\n \n    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,\n        BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);\n    ...\n}\n```\n* 从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。\n\n* 下面解释下一下构造器中各个参数的含义：\n    * corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；\n    * maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；\n    * keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；\n    * unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：\n        ```sql\n        TimeUnit.DAYS;               //天\n        TimeUnit.HOURS;             //小时\n        TimeUnit.MINUTES;           //分钟\n        TimeUnit.SECONDS;           //秒\n        TimeUnit.MILLISECONDS;      //毫秒\n        TimeUnit.MICROSECONDS;      //微妙\n        TimeUnit.NANOSECONDS;       //纳秒\n        ```\n    * workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。\n        ```sql\n        ArrayBlockingQueue;\n        LinkedBlockingQueue;\n        SynchronousQueue;\n        ```\n    * threadFactory：线程工厂，主要用来创建线程；\n    * handler：表示当拒绝处理任务时的策略，有以下四种取值：\n        ```sql\n        ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 \n        ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 \n        ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\n        ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 \n        ```\n* 从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：\n```java\npublic abstract class AbstractExecutorService implements ExecutorService {\n    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) { };\n    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) { };\n    public Future<?> submit(Runnable task) {};\n    public <T> Future<T> submit(Runnable task, T result) { };\n    public <T> Future<T> submit(Callable<T> task) { };\n    private <T> T doInvokeAny(Collection<? extends Callable<T>> tasks,\n                            boolean timed, long nanos)\n        throws InterruptedException, ExecutionException, TimeoutException {\n    };\n    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException {\n    };\n    public <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n                           long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n    };\n    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException {\n    };\n    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n                                         long timeout, TimeUnit unit)\n        throws InterruptedException {\n    };\n}\n```\n* AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。我们接着看ExecutorService接口的实现：\n```java\npublic interface ExecutorService extends Executor {\n \n    void shutdown();\n    boolean isShutdown();\n    boolean isTerminated();\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n    <T> Future<T> submit(Callable<T> task);\n    <T> Future<T> submit(Runnable task, T result);\n    Future<?> submit(Runnable task);\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n                                  long timeout, TimeUnit unit)\n        throws InterruptedException;\n \n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n* 而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现： Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；\n```java\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n* 在ThreadPoolExecutor类中有几个非常重要的方法：\n```java\nexecute()\nsubmit()\nshutdown()\nshutdownNow()\n```\n* 方法讲解\n    * execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。\n    * submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。\n    * shutdown()和shutdownNow()是用来关闭线程池的。\n    * 还有很多其他的方法，比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。\n## 深入剖析线程池实现原理\n\n* 在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：\n```java\n1.线程池状态\n\n2.任务的执行\n\n3.线程池中的线程初始化\n\n4.任务缓存队列及排队策略\n\n5.任务拒绝策略\n\n6.线程池的关闭\n\n7.线程池容量的动态调整\n```\n### 1.线程池状态\n* 在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：\n```java\nvolatile int runState;\nstatic final int RUNNING    = 0;\nstatic final int SHUTDOWN   = 1;\nstatic final int STOP       = 2;\nstatic final int TERMINATED = 3;\n\nrunState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；\n下面的几个static final变量表示runState可能的几个取值。\n当创建线程池后，初始时，线程池处于RUNNING状态；\n如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；\n如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；\n当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。\n```\n### 2.任务的执行\n* 在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：\n```java\nprivate final BlockingQueue<Runnable> workQueue;                // 任务缓存队列，用来存放等待执行的任务\n\nprivate final ReentrantLock mainLock = new ReentrantLock();     // 线程池的主要状态锁，对线程池状态（比如线程池大小runState等）的改变都要使用这个锁\n\nprivate final HashSet<Worker> workers = new HashSet<Worker>();  // 用来存放工作集\n \nprivate volatile long  keepAliveTime;                           // 线程存活时间   \n\nprivate volatile boolean allowCoreThreadTimeOut;                // 是否允许为核心线程设置存活时间\n\nprivate volatile int   corePoolSize;                            // 核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）\n\nprivate volatile int   maximumPoolSize;                         // 线程池最大的线程数\n \nprivate volatile int   poolSize;                                // 线程池中当前的线程数\n \nprivate volatile RejectedExecutionHandler handler;              // 任务拒绝策略\n \nprivate volatile ThreadFactory threadFactory;                   // 线程工厂，用来创建线程\n \nprivate int largestPoolSize;                                    // 用来记录线程池中曾经出现过的最大线程数\n \nprivate long completedTaskCount;                                // 用来记录已经执行完毕的任务个数\n```\n* 每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。\n\n   corePoolSize这个就是线程池的大小。举个简单的例子：\n   \n   -\n\n　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。\n\n　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；\n\n　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；\n\n　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；\n\n　　然后就将任务也分配给这4个临时工人做；\n\n　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。\n\n　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。\n\n　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。\n\n　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。\n\n　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。\n\n　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。\n* 在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可\n```java\n    /**\n     * Executes the given task sometime in the future.  The task\n     * may execute in a new thread or in an existing pooled thread.\n     *\n     * If the task cannot be submitted for execution, either because this\n     * executor has been shutdown or because its capacity has been reached,\n     * the task is handled by the current {@code RejectedExecutionHandler}.\n     *\n     * @param command the task to execute\n     * @throws RejectedExecutionException at discretion of\n     *         {@code RejectedExecutionHandler}, if the task\n     *         cannot be accepted for execution\n     * @throws NullPointerException if {@code command} is null\n     */\n    public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        /*\n         * Proceed in 3 steps:\n         *\n         * 1. If fewer than corePoolSize threads are running, try to\n         * start a new thread with the given command as its first\n         * task.  The call to addWorker atomically checks runState and\n         * workerCount, and so prevents false alarms that would add\n         * threads when it shouldn't, by returning false.\n         *\n         * 2. If a task can be successfully queued, then we still need\n         * to double-check whether we should have added a thread\n         * (because existing ones died since last checking) or that\n         * the pool shut down since entry into this method. So we\n         * recheck state and if necessary roll back the enqueuing if\n         * stopped, or start a new thread if there are none.\n         *\n         * 3. If we cannot queue task, then we try to add a new\n         * thread.  If it fails, we know we are shut down or saturated\n         * and so reject the task.\n         */\n        int c = ctl.get();\n        // 1.如果当前线程数量小于corePoolSize，则创建并启动线程。\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        // 2.步骤1失败，则尝试进入阻塞队列，\n        if (isRunning(c) && workQueue.offer(command)) {\n            // 入队列成功，检查线程池状态，如果状态部署RUNNING而且remove成功，则拒绝任务\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            // 如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        } // 3. 步骤1和2失败，尝试将线程池的数量有corePoolSize扩充至maxPoolSize，如果失败，则拒绝任务\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n```\n\n![](/images/server/java/Concurrent/ThreadPoolExecuter.png)\n\n* 任务提交给线程池之后的处理策略\n    * 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n    * 如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；\n    * 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；\n    * 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。\n\n### 3.线程池中的线程初始化\n\n* 默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：\n    * prestartCoreThread()：初始化一个核心线程；\n    * prestartAllCoreThreads()：初始化所有核心线程\n    \n### 4.任务缓存队列及排队策略\n\n* 在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。workQueue的类型为BlockingQueue<Runnable>，通常可以取下面三种类型：\n    * 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；\n    * 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；\n    * 3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。\n\n### 5.任务拒绝策略\n\n* 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：\n```java\nThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。\nThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\nThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）\nThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务\n```\n\n\n### 6.线程池的关闭\n* ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：\n    * shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务\n    * shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务\n### 7.线程池容量的动态调整\n* ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，\n    * setCorePoolSize：设置核心池大小\n    * setMaximumPoolSize：设置线程池最大能创建的线程数目大小\n* 当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。\n\n## 使用示例\n\n### ThreadPoolExecutor 使用示例\n```java\npublic class ThreadPoolExecutorTest {\n    public static void main(String[] args) {\n        ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,\n                new ArrayBlockingQueue<Runnable>(5));\n\n        for (int i = 0; i < 15; i++) {\n            MyTask myTask = new MyTask(i);\n            executor.execute(myTask);\n            System.out.println(\n                    \"线程池中线程数目：\" + executor.getPoolSize() + \n                    \"，队列中等待执行的任务数目：\" + executor.getQueue().size() + \n                    \"，已执行玩别的任务数目：\" + executor.getCompletedTaskCount());\n        }\n        executor.shutdown();\n    }\n}\n\n\nclass MyTask implements Runnable {\n    private int taskNum;\n\n    public MyTask(int num) {\n        this.taskNum = num;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"正在执行task \" + taskNum);\n        try {\n            Thread.currentThread().sleep(4000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"task \" + taskNum + \"执行完毕\");\n    }\n}\n```\n* 输出结果\n```java\n线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0\n正在执行task 0\n线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0\n线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0\n线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0\n正在执行task 2\n正在执行task 1\n线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0\n线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0\n正在执行task 3\n线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0\n正在执行task 4\n线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0\n线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0\n线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0\n线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0\n正在执行task 10\n线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0\n正在执行task 11\n线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0\n线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0\n正在执行task 12\n正在执行task 13\n线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0\n正在执行task 14\ntask 1执行完毕\ntask 0执行完毕\ntask 4执行完毕\ntask 2执行完毕\n正在执行task 7\ntask 3执行完毕\n正在执行task 6\n正在执行task 5\n正在执行task 8\n正在执行task 9\ntask 12执行完毕\ntask 14执行完毕\ntask 10执行完毕\ntask 11执行完毕\ntask 13执行完毕\ntask 7执行完毕\ntask 5执行完毕\ntask 8执行完毕\ntask 6执行完毕\ntask 9执行完毕\n\nProcess finished with exit code 0\n```\n* 从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。\n\n### Executors提供四种线程池的创建实现\n* 将线程放入线程池的两种方法\n    * 1、ExecutorService 类中的 submit(Runnable task)  submit(Callable<T> task)\n    * 2、Executor 接口中的execute(Runnable command)\n\n#### `newCachedThreadPool` \n* 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池的规模不存在限制。\n* 缓存线程池，缓存的线程默认存活60秒。线程的核心池corePoolSize大小为0，核心池最大为Integer.MAX_VALUE,阻塞队列使用的是SynchronousQueue。是一个直接提交的阻塞队列，    他总会迫使线程池增加新的线程去执行新的任务。在没有任务执行时，当线程的空闲时间超过keepAliveTime（60秒），则工作线程将会终止被回收，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。如果同时又大量任务被提交，而且任务执行的时间不是特别快，那么线程池便会新增出等量的线程池处理任务，这很可能会很快耗尽系统的资源。\n* 构造ThreadPoolExecutor\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n* 示例代码\n```java\npublic class NewCachedThreadPoolTest {\n    public static void main(String[] args) {\n        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();\n        for (int i = 0; i < 10; i++) {\n            final int index = i;\n            try {\n                Thread.sleep(index * 1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            // 1- 在未来某个时间执行给定的命令。\n            // 该命令可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。\n            cachedThreadPool.execute(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(index);\n                }\n            });\n\n            // 2- 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。\n            // 该 Future 的 get 方法在成功完成时将会返回给定的结果\n            cachedThreadPool.submit(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(index);\n                }\n            });\n        }\n        cachedThreadPool.shutdown();\n    }\n}\n```\n\n#### `newFixedThreadPool`\n* 创建一个固定长度线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n* 构造ThreadPoolExecutor\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n#### `newScheduledThreadPool`\n* 创建一个固定长度线程池，支持定时及周期性任务执行。\n* 构造ThreadPoolExecutor\n```java\npublic static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n    return new ScheduledThreadPoolExecutor(corePoolSize);\n}\n\n...\n\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}\n```\n#### `newSingleThreadExecutor`\n* 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n* 构造ThreadPoolExecutor\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n* 从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。\n\n* 虽然jdk提供了以上线程池的创建实现，但在实际项目中不推荐使用，在阿里巴巴编码规范插件中是这么提示的：线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 \n\n* 说明：Executors各个方法的弊端：\n\n  * 1）newCachedThreadPool和newScheduledThreadPool:\n    \n    主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。\n  \n  * 2）newFixedThreadPool和newSingleThreadExecutor:\n      \n    主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。\n    \n* 正确使用例子：\n    \n```java\nPositive example 1：\n  //org.apache.commons.lang3.concurrent.BasicThreadFactory\n  ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1,\n      new BasicThreadFactory.Builder().namingPattern(\"example-schedule-pool-%d\").daemon(true).build());\n     \n      \n          \nPositive example 2：\n  ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()\n      .setNameFormat(\"demo-pool-%d\").build();\n\n  //Common Thread Pool\n  ExecutorService pool = new ThreadPoolExecutor(5, 200,\n      0L, TimeUnit.MILLISECONDS,\n      new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());\n\n  pool.execute(()-> System.out.println(Thread.currentThread().getName()));\n  pool.shutdown();//gracefully shutdown\n     \n      \n          \nPositive example 3：\n  <bean id=\"userThreadPool\"\n      class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\">\n      <property name=\"corePoolSize\" value=\"10\" />\n      <property name=\"maxPoolSize\" value=\"100\" />\n      <property name=\"queueCapacity\" value=\"2000\" />\n\n  <property name=\"threadFactory\" value= threadFactory />\n      <property name=\"rejectedExecutionHandler\">\n          <ref local=\"rejectedExecutionHandler\" />\n      </property>\n  </bean>\n  //in code\n  userThreadPool.execute(thread);\n```\n\n\n## 总结\n* 为什么要用线程池，因为每次new Thread新建对象性能差，使用线程池可以重用存在的线程，减少对象创建、消亡的开销，性能佳。\n* 相比普通线程的执行，使用线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，同时还提供了定时执行、定期执行、单线程、并发数控制等功能。\n\n## 其他\n* Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？一般说来，大家认为线程池的大小经验值应该这样设置：（其中 N 为CPU的个数）\n    * 如果是 CPU 密集型应用，则线程池大小设置为 N+1，因为 CPU 密集型任务使得 CPU 使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。\n    * 如果是 IO 密集型应用，则线程池大小设置为 2N+1，IO密 集型任务 CPU 使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用 CPU 时间。\n    * 如果是混合型应用，那么分别创建线程池，可以将任务分成 IO 密集型和 CPU 密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。\n\n\n## 参考转载\n* https://www.cnblogs.com/dolphin0520/p/3932921.html\n* https://blog.csdn.net/tanghui270270/article/details/80595961\n* https://www.cnblogs.com/superfj/p/7544971.html","tags":["jvm"],"categories":["服务器"]},{"title":"并发多线程(四)Lock同步锁","url":"/2019/04/04/backend/java/concurrent1/并发多线程(四)Lock同步锁/","content":"## 概述\n* 在上上篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。\n\n* 也许有朋友会问，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西\n\n## 一：synchronized的缺陷\n* synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：\n    * 1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；\n    * 2）线程执行发生异常，此时JVM会让线程自动释放锁。\n* 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。\n\n* 再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。\n\n## 二.java.util.concurrent.locks包下常用的类\n\n> 下面我们就来探讨一下java.util.concurrent.locks包中常用的类和接口。\n\n### 1.Lock\n* 首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口：\n```java\npublic interface Lock {\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLock();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlock();\n    Condition newCondition();\n}\n```\n* 下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。\n\n* 在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？\n    * lock()\n        * 首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：\n            ```java\n            Lock lock = ...;\n            lock.lock();\n            try{\n                //处理任务\n            }catch(Exception ex){\n                 \n            }finally{\n                lock.unlock();   //释放锁\n            }\n            ```\n    * tryLock()\n        * tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。\n        * tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。\n        * 所以，一般情况下通过tryLock来获取锁时是这样使用的：\n            ```java\n            Lock lock = ...;\n            if(lock.tryLock()) {\n                 try{\n                     //处理任务\n                 }catch(Exception ex){\n                     \n                 }finally{\n                     lock.unlock();   //释放锁\n                 } \n            }else {\n                //如果不能获取锁，则直接做其他事情\n            }\n            ```\n    * lockInterruptibly()\n        * lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。\n        * 由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。\n        * 因此lockInterruptibly()一般的使用形式如下：\n            ```java\n            public void method() throws InterruptedException {\n                lock.lockInterruptibly();\n                try {  \n                 //.....\n                }\n                finally {\n                    lock.unlock();\n                }  \n            }\n            ```\n        * 注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。\n        * 而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。\n\n### 2.ReentrantLock\n* ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。\n\n* lock()的错误使用方法\n    * 代码\n        ```java\n        public class Test {\n            private ArrayList<Integer> arrayList = new ArrayList<Integer>();\n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n            }  \n             \n            public void insert(Thread thread) {\n                Lock lock = new ReentrantLock();    //注意这个地方\n                lock.lock();\n                try {\n                    System.out.println(thread.getName()+\"得到了锁\");\n                    for(int i=0;i<5;i++) {\n                        arrayList.add(i);\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }finally {\n                    System.out.println(thread.getName()+\"释放了锁\");\n                    lock.unlock();\n                }\n            }\n        }\n        ```\n    * 各位朋友先想一下这段代码的输出结果是什么？\n        ```java\n        Thread-0得到了锁\n        Thread-1得到了锁\n        Thread-0释放了锁\n        Thread-1释放了锁\n        ```\n    * 也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。\n    * 知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。\n        ```java\n        public class Test {\n            private ArrayList<Integer> arrayList = new ArrayList<Integer>();\n            private Lock lock = new ReentrantLock();    //注意这个地方\n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n            }  \n             \n            public void insert(Thread thread) {\n                lock.lock();\n                try {\n                    System.out.println(thread.getName()+\"得到了锁\");\n                    for(int i=0;i<5;i++) {\n                        arrayList.add(i);\n                    }\n                } catch (Exception e) {\n                    // TODO: handle exception\n                }finally {\n                    System.out.println(thread.getName()+\"释放了锁\");\n                    lock.unlock();\n                }\n            }\n        }\n        ```\n    * 这样就是正确地使用Lock的方法了。\n* tryLock()的使用方法\n    * 代码\n        ```java\n        public class Test {\n            private ArrayList<Integer> arrayList = new ArrayList<Integer>();\n            private Lock lock = new ReentrantLock();    //注意这个地方\n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.insert(Thread.currentThread());\n                    };\n                }.start();\n            }  \n             \n            public void insert(Thread thread) {\n                if(lock.tryLock()) {\n                    try {\n                        System.out.println(thread.getName()+\"得到了锁\");\n                        for(int i=0;i<5;i++) {\n                            arrayList.add(i);\n                        }\n                    } catch (Exception e) {\n                        // TODO: handle exception\n                    }finally {\n                        System.out.println(thread.getName()+\"释放了锁\");\n                        lock.unlock();\n                    }\n                } else {\n                    System.out.println(thread.getName()+\"获取锁失败\");\n                }\n            }\n        }\n        ```\n    * 输出结果：\n        ```java\n        Thread-0得到了锁\n        Thread-1获取锁失败\n        Thread-0释放了锁\n        ```\n* lockInterruptibly()响应中断的使用方法：\n    * 代码：\n        ```java\n        public class Test {\n            private Lock lock = new ReentrantLock();   \n            public static void main(String[] args)  {\n                Test test = new Test();\n                MyThread thread1 = new MyThread(test);\n                MyThread thread2 = new MyThread(test);\n                thread1.start();\n                thread2.start();\n                 \n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                thread2.interrupt();\n            }  \n             \n            public void insert(Thread thread) throws InterruptedException{\n                lock.lockInterruptibly();   //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出\n                try {  \n                    System.out.println(thread.getName()+\"得到了锁\");\n                    long startTime = System.currentTimeMillis();\n                    for(    ;     ;) {\n                        if(System.currentTimeMillis() - startTime >= Integer.MAX_VALUE)\n                            break;\n                        //插入数据\n                    }\n                }\n                finally {\n                    System.out.println(Thread.currentThread().getName()+\"执行finally\");\n                    lock.unlock();\n                    System.out.println(thread.getName()+\"释放了锁\");\n                }  \n            }\n        }\n         \n        class MyThread extends Thread {\n            private Test test = null;\n            public MyThread(Test test) {\n                this.test = test;\n            }\n            @Override\n            public void run() {\n                 \n                try {\n                    test.insert(Thread.currentThread());\n                } catch (InterruptedException e) {\n                    System.out.println(Thread.currentThread().getName()+\"被中断\");\n                }\n            }\n        }\n        ```\n    * 运行之后，发现thread2能够被正确中断\n        ```java\n        Thread-0得到了锁\n        Thread-1被中断\n        ```\n* 3.ReadWriteLock\n    * ReadWriteLock也是一个接口，在它里面只定义了两个方法：\n        ```java\n        public interface ReadWriteLock {\n            /**\n             * Returns the lock used for reading.\n             *\n             * @return the lock used for reading.\n             */\n            Lock readLock();\n         \n            /**\n             * Returns the lock used for writing.\n             *\n             * @return the lock used for writing.\n             */\n            Lock writeLock();\n        }\n        ```\n    * 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。\n* 4.ReentrantReadWriteLock\n    * ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。\n    * 下面通过几个例子来看一下ReentrantReadWriteLock具体用法。\n    * 假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果：\n        ```java\n        public class Test {\n            private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n             \n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n            }  \n             \n            public synchronized void get(Thread thread) {\n                long start = System.currentTimeMillis();\n                while(System.currentTimeMillis() - start <= 1) {\n                    System.out.println(thread.getName()+\"正在进行读操作\");\n                }\n                System.out.println(thread.getName()+\"读操作完毕\");\n            }\n        }\n        ```\n    * 这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。\n        ```java\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0读操作完毕\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1读操作完毕\n        ```\n    * 而改成用读写锁的话：\n        ```java\n        public class Test {\n            private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n             \n            public static void main(String[] args)  {\n                final Test test = new Test();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n                new Thread(){\n                    public void run() {\n                        test.get(Thread.currentThread());\n                    };\n                }.start();\n                 \n            }  \n             \n            public void get(Thread thread) {\n                rwl.readLock().lock();\n                try {\n                    long start = System.currentTimeMillis();\n                     \n                    while(System.currentTimeMillis() - start <= 1) {\n                        System.out.println(thread.getName()+\"正在进行读操作\");\n                    }\n                    System.out.println(thread.getName()+\"读操作完毕\");\n                } finally {\n                    rwl.readLock().unlock();\n                }\n            }\n        }\n        ```\n     * 此时打印的结果为：\n         ```java\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0正在进行读操作\n        Thread-1正在进行读操作\n        Thread-0读操作完毕\n        Thread-1读操作完毕\n         ```\n     * 说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。\n\n## 三.锁的相关概念介绍\n\n### 1.可重入锁\n* 如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。\n\n* 看下面这段代码就明白了：\n\n```java\nclass MyClass {\n    public synchronized void method1() {\n        method2();\n    }\n     \n    public synchronized void method2() {\n         \n    }\n}\n```\n* 上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。\n\n* 而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。\n\n### 2.可中断锁\n* 可中断锁：顾名思义，就是可以相应中断的锁。\n* 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。\n* 如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。\n* 在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。\n\n### 3.公平锁\n* 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。\n* 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。\n* 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。\n*而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。\n\n### 4.读写锁\n* 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。\n* ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。\n\n## 四.总结\n* 1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；\n* 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；\n* 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；\n* 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。\n* 5）Lock可以提高多个线程进行读操作的效率。\n* 6）在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。\n\n\n## 参考转载\n* https://www.cnblogs.com/dolphin0520/p/3932921.html","tags":["jvm"],"categories":["服务器"]},{"title":"并发多线程(三)volatile关键字","url":"/2019/04/01/backend/java/concurrent1/并发多线程(三)volatile关键字/","content":"## 剖析volatile关键字\n### 1. volatile关键字的两层语义\n* 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n    * 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n    * 禁止进行指令重排序。\n* 先看一段代码，假如线程1先执行，线程2后执行：\n```java\n//线程1\nboolean stop = false;\nwhile(!stop){\n    doSomething();\n}\n \n//线程2\nstop = true;\n```\n* 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。\n\n* 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。\n  \n* 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。\n  \n* 但是用volatile修饰之后就变得不一样了：\n    * 第一：使用volatile关键字会强制将修改的值立即写入主存；\n    * 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n    * 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n    * 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。\n    * 那么线程1读取到的就是最新的正确的值。\n    \n### 2. volatile保证原子性吗?\n* 从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？\n```java\npublic class Test {\n    public volatile int inc = 0;\n     \n    public void increase() {\n        inc++;\n    }\n     \n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i<10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j<1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n         \n        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n```\n大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。\n\n可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。\n\n这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。\n\n在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：\n\n假如某个时刻变量inc的值为10，\n\n线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；\n\n然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。\n\n然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。\n\n那么两个线程分别进行了一次自增操作后，inc只增加了1。\n\ni++ 的操作实际上分为三个步骤 1、`读 int temp = i;` 2、`改 i = i + 1` 3、`写 i = temp` \n\n解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。\n\n根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。\n\n把上面的代码改成以下任何一种都可以达到效果：\n\n> 采用synchronized：\n\n```java\npublic class Test {\n    public  int inc = 0;\n    \n    public synchronized void increase() {\n        inc++;\n    }\n    \n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i<10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j<1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n        \n        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n```\n> 采用Lock\n```java\npublic class Test {\n    public  int inc = 0;\n    Lock lock = new ReentrantLock();\n    \n    public  void increase() {\n        lock.lock();\n        try {\n            inc++;\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public static void main(String[] args) {\n        final Test test = new Test();\n        for(int i=0;i<10;i++){\n            new Thread(){\n                public void run() {\n                    for(int j=0;j<1000;j++)\n                        test.increase();\n                };\n            }.start();\n        }\n        \n        while(Thread.activeCount()>1)  //保证前面的线程都执行完\n            Thread.yield();\n        System.out.println(test.inc);\n    }\n}\n```\n### 3.volatile能保证有序性吗？\n* 在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。\n\n* volatile关键字禁止指令重排序有两层意思：\n    * 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n    * 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。\n\n* 可能上面说的比较绕，举个简单的例子\n```java\n//x、y为非volatile变量\n//flag为volatile变量\n \nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3\nx = 4;         //语句4\ny = -1;       //语句5\n```\n* 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。\n\n* 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。\n\n* 那么我们回到前面举的一个例子\n```java\n//线程1:\ncontext = loadContext();   //语句1\ninited = true;             //语句2\n \n//线程2:\nwhile(!inited ){\n  sleep()\n}\ndoSomethingwithconfig(context);\n```\n* 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。\n\n* 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。\n\n### 4.volatile的原理和实现机制\n* 前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。\n\n* 下面这段话摘自《深入理解Java虚拟机》：\n    * “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：\n    \n    　　* 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；\n    \n    　　* 2）它会强制将对缓存的修改操作立即写入主存；\n    \n    　　* 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。\n* 为什么代码会重排序？\n    * 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：\n        * 在单线程环境下不能改变程序运行的结果。\n        * 存在数据依赖关系的不允许重排序\n### 5.volatile 使用场景\n* 只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：\n\n　　（1）对变量的写操作不依赖于当前值。\n\n　　（2）该变量没有包含在具有其他变量的不变式中。\n* 状态标志\n* 实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。\n```java\nvolatile boolean shutdownRequested;\n \n...\n \n// 其他线程调用，通知需要结束，并改变状态\npublic void shutdown() { shutdownRequested = true; }\n \npublic void doWork() { \n    while (!shutdownRequested) { \n        // do stuff\n    }\n}\n```\n* 很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用清单 2 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。\n\n* 这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。\n\n## 总结\n\n\n## 其他\n* Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。\n* volatile 和 synchronized 的区别？\n    * volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\n    * volatile 仅能使用在变量级别。synchronized 则可以使用在变量、方法、和类级别的。\n    * volatile 仅能实现变量的修改可见性，不能保证原子性。而synchronized 则可以保证变量的修改可见性和原子性。 \n    * volatile 不会造成线程的阻塞。synchronized 可能会造成线程的阻塞。\n    * volatile 标记的变量不会被编译器优化。synchronized标记的变量可以被编译器优化。\n\n\n## 参考转载\n* https://www.cnblogs.com/dolphin0520/p/3920373.html\n* https://blog.csdn.net/y874961524/article/details/82934831","tags":["jvm"],"categories":["服务器"]},{"title":"并发多线程(二)synchronized关键字","url":"/2019/04/01/backend/java/concurrent1/并发多线程(二)synchronized关键字/","content":"\n![Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/Java%20%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E5%A4%87%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93/%E4%BA%8C%20%20Synchronized%20%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E3%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E3%80%81JDK1.6%20%E4%B9%8B%E5%90%8E%E7%9A%84%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%E4%BB%A5%E5%8F%8A%20%E5%92%8CReenTrantLock%20%E7%9A%84%E5%AF%B9%E6%AF%94.png)\n### 说一说自己对于 synchronized 关键字的了解\n\n* synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\n* 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\n\n###  synchronized关键字最主要的三种使用方式\n\n- **修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁**\n- **修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁** 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，**因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁**。\n- **修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。** 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！\n\n下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。\n\n面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”\n\n**双重校验锁实现对象单例（线程安全）**\n\n```java\npublic class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n\n    private Singleton() {\n    }\n\n    public static Singleton getUniqueInstance() {\n       //先判断对象是否已经实例过，没有实例化过才进入加锁代码\n        if (uniqueInstance == null) {\n            //类对象加锁\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n```\n另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。\n\nuniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\n\n1. 为 uniqueInstance 分配内存空间\n2. 初始化 uniqueInstance\n3. 将 uniqueInstance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\n\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\n\n\n### synchronized 关键字底层原理\n\n**synchronized 关键字底层原理属于 JVM 层面。**\n\n**① synchronized 同步语句块的情况**\n\n```java\npublic class SynchronizedDemo {\n\tpublic void method() {\n\t\tsynchronized (this) {\n\t\t\tSystem.out.println(\"synchronized 代码块\");\n\t\t}\n\t}\n}\n```\n\n通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 `javac SynchronizedDemo.java` 命令生成编译后的 .class 文件，然后执行`javap -c -s -v -l SynchronizedDemo.class`。\n\n![synchronized 关键字原理](https://images.gitbook.cn/abc37c80-d21d-11e8-aab3-09d30029e0d5)\n\n从上面我们可以看出：\n\n**synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。** 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。\n\n![](/images/server/java/Concurrent/duixiangtui.jpg)\n\n对象被创建在堆中。并且对象在内存中的存储布局方式可以分为3块区域：对象头、实例数据、对齐填充。对于对象头来说，主要是包括俩部分信息:\n\n    * 1、自身运行时的数据，比如：如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。（此部分内容被称之为Mark Word） \n    * 2、另一部分是类型指针：JVM通过这个指针来确定这个对象是哪个类的实例。\n\n\n\n**② synchronized 修饰方法的的情况**\n\n```java\npublic class SynchronizedDemo2 {\n\tpublic synchronized void method() {\n\t\tSystem.out.println(\"synchronized 方法\");\n\t}\n}\n\n```\n\n![synchronized 关键字原理](https://images.gitbook.cn/7d407bf0-d21e-11e8-b2d6-1188c7e0dd7e)\n\nsynchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。\n\n\n在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。\n### JDK 1.6锁优化\n\n#### 1、自旋锁\n> 由来\n\n线程的阻塞和唤醒，需要 `CPU 从用户态转为核心态`。频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时，我们发现在许多应用上面，`对象锁的锁状态只会持续很短一段时间`。为了这一段很短的时间，频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。\n\n\n> 定义 \n\n所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。\n\n怎么等待呢？`执行一段无意义的循环即可（自旋）。`\n\n自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。\n\n所以说，自旋等待的时间（自旋的`次数`）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。\n\n自旋锁在 JDK 1.4.2 中引入，默认关闭，但是可以使用` -XX:+UseSpinning` 开开启。\n\n在 JDK1.6 中默认开启。同时自旋的默认次数为 10 次，可以通过参数 `-XX:PreBlockSpin` 来调整。\n\n如果通过参数 `-XX:PreBlockSpin` 来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为 10 ，但是系统很多线程都是等你刚刚退出的时候，就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是 JDK 1.6 引入自适应的自旋锁，让虚拟机会变得越来越聪明。\n\n> 适应自旋锁\n\n* JDK 1.6 引入了更加聪明的自旋锁，即自适应自旋锁。\n    * 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。\n    * 反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。\n* 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。\n\n#### 2、锁消除\n> 由来\n\n为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制。但是，在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。\n\n> 定义\n\n锁消除的依据是逃逸分析的数据支持。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些 JDK 的内置 API 时，如 StringBuffer、Vector、HashTable 等，这个时候会存在隐性的加锁操作。比如 StringBuffer 的 #append(..)方法，Vector 的 add(...) 方法：\n\n```java\npublic void vectorTest(){\n    Vector<String> vector = new Vector<String>();\n    for (int i = 0 ; i < 10 ; i++){\n    \tvector.add(i + \"\");\n    }\n    System.out.println(vector);\n}\n```\n\n在运行这段代码时，JVM 可以明显检测到变量 vector 没有逃逸出方法 #vectorTest() 之外，所以 JVM 可以大胆地将 vector 内部的加锁操作消除。\n\n#### 3、锁粗化\n>由来\n\n我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小：仅在共享数据的实际作用域中才进行同步。这样做的目的，是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。\n\n在大多数的情况下，上述观点是正确的，LZ 也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。\n\n>定义\n\n锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。\n\n如上面实例：vector 每次 add 的时候都需要加锁操作，JVM 检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到 for 循环之外。\n\n#### 4、锁升级\n\n- 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。它们会随着竞争的激烈而逐渐升级。注意，锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。\n\n##### 4.1 重量级锁\n\n重量级锁通过对象内部的监视器（Monitor）实现。\n\n其中，Monitor 的本质是，依赖于底层操作系统的 Mutex Lock 实现。操作系统实现线程之间的切换，需要从用户态到内核态的切换，切换成本非常高。\n\n##### 4.1 轻量级锁\n\n引入轻量级锁的主要目的，是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。\n\n当关闭偏向锁功能或者多个线程竞争偏向锁，导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁其步骤如下：\n\n* 获取锁\n    * 判断当前对象是否处于无锁状态？若是，则 JVM 首先将在当前线程的栈帧中，建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word的 拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）；否则，执行步骤（3）；\n    * JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指正。如果成功，表示竞争到锁，则将锁标志位变成 00（表示此对象处于轻量级锁状态），执行同步操作；如果失败，则执行步骤（3）；\n    * 判断当前对象的 Mark Word 是否指向当前线程的栈帧？如果是，则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则，只能说明该锁对象已经被其他线程抢占了，当前线程便尝试使用自旋来获取锁。若自旋后没有获得锁，此时轻量级锁会升级为重量级锁，锁标志位变成 10，当前线程会被阻塞。\n\n* 释放锁 轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下：\n    * 取出在获取轻量级锁保存在 Displaced Mark Word 中 数据。\n    * 使用 CAS 操作将取出的数据替换当前对象的 Mark Word 中。如果成功，则说明释放锁成功；否则，执行（3）。\n    * 无论（2）是否释放成功，都会唤醒被挂起的线程，重新争夺锁，访问同步代码块。\n    \n* 下图是争夺锁导致的锁膨胀的流程图：其中，绿框的 0 指的是无偏向锁，01 指的是无锁状态。\n\n![](/images/server/java/Concurrent/markword.png)\n\n* 注意事项: 对于轻量级锁，其性能提升的依据是：“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”。如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。\n\n##### 4.1 偏向锁\n##### 4.1 \n\n\n## 参考转载\n* https://github.com/Snailclimb/JavaGuide/edit/master/docs/java/synchronized.md\n* http://www.iocoder.cn/JUC/sike/synchronized/\n","tags":["jvm"],"categories":["服务器"]},{"title":"并发多线程(一)Thread的创建及使用","url":"/2019/04/01/backend/java/concurrent1/并发多线程(一)Thread的创建及使用/","content":"## 1. 线程创建及使用\n\n### 1.1 继承Thread类创建线程类\n* 实现最简单，如果要访问当前线程，则无需使用 `Thread.currentThread()`直接使用`this`即可得到当前线程\n* 不能再继承其他父类，因为线程类已经继承了`Thread`类\n* `Thread`类继承`Runnable`类\n```java\npublic class ThreadTest {\n\n    public static void main(String[] args) {\n        CustomThread customThread = new CustomThread();\n        customThread.start();\n    }\n\n}\nclass CustomThread extends Thread {\n\n    @Override\n    public void run() {\n        System.out.println(\"CustomThread doing\");\n    }\n\n}\n```\n\n### 1.2 实现Runnable类创建线程类\n* 线程类只是实现了`Runnable`类，还可以继承其他类\n* 访问线程需要使用 `Thread.currentThread()`访问当前线程\n```java\npublic class RunnableTest {\n\n    public static void main(String[] args) {\n        // CustomRunnable对象作为Thread构造参数\n        Thread thread = new Thread(new CustomRunnable());\n        thread.start();\n    }\n\n}\nclass CustomRunnable implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(\"CustomRunnable doing\");\n    }\n\n}\n```\n### 1.3 使用Callable和Future创建线程\n* 线程类只是实现了`Runnable`类，还可以继承其他类\n* 访问线程需要使用 `Thread.currentThread()`访问当前线程\n* 可以得到线程方法体的结果，得到`call()`方法返回值\n* 可以得到执行异常\n```java\npublic class CallableTest {\n\n    public static void main(String[] args) {\n        CustomCallable customCallable = new CustomCallable();\n        // 使用Callable方式创建线程，需要FutureTask类的支持，用于接收运算结果，可以使用泛型指定返回值的类型\n        FutureTask<Integer> futureTask = new FutureTask(customCallable);\n        new Thread(futureTask).start();\n        int sum = 0;\n        // 接收运算结果，只有当该线程执行完毕后才会获取到运算结果，等同于闭锁的效果\n        try {\n            sum = futureTask.get();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"sum is \" + sum);\n    }\n\n}\nclass CustomCallable implements Callable {\n\n    @Override\n    public Object call() throws Exception {\n        // 计算1-100的和\n        int sum = 0;\n        for (int i = 1; i <= 100; i++) {\n            sum += i;\n        }\n        return sum;\n    }\n}\n```\n## 2. 线程的生命周期\n\n![](/images/server/java/Concurrent/threadprocess.png)\n\n* 线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、消亡（dead）。\n\n* 当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。\n\n* 线程上下文切换，线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行，上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。\n\n* 虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。\n\n## 3. 控制线程\n\n### 3.1 join线程\n* 让一个线程等待另一个线程完成的方法，当在某个程序执行流中调用其他线程的`join()`方法时，调用线程将被阻塞，直到加入的`join()`线程执行完为止\n\n### 3.2 sleep睡眠线程\n* sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。\n\n### 3.3 yield线程让步\n* 调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。\n\n### 3.4 setPriority() 改变线程优先级\n* 优先级高的线程获得较多的执行机会\n\n## 总结\n* Java 线程是重量级的，每个线程默认使用 1024KB 的内存，所以一个 Java 进程是无法开启大量线程的\n* 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。\n* 从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。\n* 为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？\n    * 一个很明显的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。\n    * 由于 wait，notify 和 notifyAll 方法都是锁级别的操作，所以把它们定义在 Object 类中，因为锁属于对象。\n\n## 参考转载\n* https://www.cnblogs.com/dolphin0520/p/3920357.html\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM堆转储文件分析EclipseMemoryAnalyzer","url":"/2019/03/26/backend/java/jvm1/JVM堆转储文件分析EclipseMemoryAnalyzer/","content":"## 简介\n* Eclipse Memory Analyzer 它是一个功能丰富的 JAVA 堆转储文件分析工具，可以帮助你发现内存漏洞和减少内存消耗\n\n* 简称MAT\n\n## 下载安装\n\n* 下载链接: https://www.eclipse.org/mat/downloads.php\n* 解压后直接打开MemoryAnalyzer.exe\n\n## 使用EclipseMemoryAnalyzer\n\n### 1、获取Heap Dump 堆转储文件\n\n#### 什么是Heap Dump文件\n* Heap Dump 是一个 Java 进程在某个时间点上的内存快照。 Heap Dump 是有着多种格式的。 不过总体上Heap Dump 在触发快照的时候都保存了 java 对象和类的信息。通常在写 Heap Dump 文件前会触发一次 FullGC，所以 Heap Dump 文件中保存的是 FullGC 后留下的对象信息。\n* Memory Analyzer 可以用来处理 HPROF 二进制 Heap Dump 文件、 IBM 系统 dump 文件（经过处理后）、以及来自各个平台上的 IBM portable Heap Dumps (PHD)文件。 \n* 一般在 Heap Dump 文件中可以获取到（ 这仍然取决于 Heap Dump 文件的类型） 如下信息： \n    * 对象信息：类、成员变量、直接量以及引用值； \n    * 类信息： 类加载器、 名称、 超类、 静态成员； \n    * Garbage Collections Roots： JVM 可达的对象； \n    * 线程栈以及本地变量： 获取快照时的线程栈信息， 以及局部变量的详细信息。 \n* MAT根据这个文件可以分析出内存泄露和高内存消耗地点。\n\n#### 获取Heap Dump文件\n* 这可是一个相当便捷的参数了，因为当你需要分析Java内存使用情况时，往往是在OOM(OutOfMemoryError)发生时。那么通过在你的启动脚本中，为Java命令添加以下参数，就可以得到一份内存信息了 `Java –Xmx1024m …. -XX:+HeapDumpOnOutOfMemoryError ……`\n* 使用JDK工具获取，`jmap –dump:format=b,file=heap.bin PID`\n* 使用基本的GUI工具，如jconsol, Eclipse memory analyzer等\n\n### 2、使用EclipseMemoryAnalyzer\n* 得到Heap Dump 堆转储文件之后，就可以使用这个工具直接打开了\n\n#### 2.1 Overview\n\n![](/images/server/java/JVM/mat1.png)\n\n* 在右侧窗口上方的位置可以看到 heapDump 的 size，以及类、对象和类加载器的数量。\n* 右侧窗口中最醒目的饼图直观地显示了 dump 中最大的几个对象。鼠标光标划过饼图中代表某个对象的区块时可以在左侧 Inspector 窗口中看到对象的细节，在区块上点击鼠标左键可以通过菜单项钻取到关于其对应的对象更多的细节。\n* 我们可以看到占用很大一部分内存的有几个深色的饼区，这些就可以当做我们稍后着重看的地方 \n\n#### 2.2 Histogram\n> 列出内存中的对象，对象的个数以及大小。 \n\n![](/images/server/java/JVM/mat2.png)\n\n* Shallow Heap\n    * 对象自身占用的内存大小，不包括它引用的对象\n* Retained Heap\n    * 是该对象自己的shallow size，加上从该对象能直接或间接访问到对象的shallow size之和\n    * 换句话说，Retained size是该对象被GC之后所能回收到内存的总和。 \n    * 并且排除被GC Roots直接或者间接引用的对象\n* Shallow Heap 与 Retained Heap\n    * ![](/images/server/java/JVM/mat7.png)\n    * A对象的 Retained Heap = A对象的 Shallow Heap + C对象的 Shallow Heap 这里不包含 D 对象的 Shallow Heap因为 D对象被Root根对象所引用。\n    * B对象的 Retained Heap = B对象的 Shallow Heap。\n\n* 鼠标右键 \n    * List Object\n        * Incomming Reference（呼入 被谁依赖） 指的是引用当前对象的外部对象，\n        * Outgoing Reference（外向的 依赖谁） 指的是当前对象引用的外部对象\n    * Paths to GC Roots \n        * 从当前对象到GC roots的路径，这个路径解释了为什么当前对象还能存活，对分析内存泄露很有帮助，这个查询只能针对单个对象使用\n    * Merge Shortest Paths to GC roots\n        * 从GC roots到一个或一组对象的公共路径\n        * Merge shortest Paths to GC roots 和Path to GC roots 这两个查询都有很多选项\n             * ![](/images/server/java/JVM/mat12.jpg)\n             * 意思是在查询到GC root的路径时，是包含所有引用，还是排除一些类型的引用（如软引用、弱引用、虚引用）\n             * 从GC角度说，一个对象无法被GC，一定是因为有强引用存在，其它引用类型在GC需要的情况下都是可以被GC掉的，所以可以使用 exclude all phantom/weak/soft etc. references 只查看GC路径上的强引用\n             * 需要注意的是，Paths to GC roots是针对单个对象的，故在Histogram视图无法使用，因为Histogram视图是针对类的，只能使用Merge shortest Paths to GC roots查询\n#### 2.3 Dominator Tree\n> 可以列出那个线程，以及线程下面的那些对象占用的空间。 \n\n![](/images/server/java/JVM/mat3.png)\n\n* Dominator Tree 展示了 Heap Dump 中最大的几个对象。 如果 dominator tree 中对象的父节点被移除的话那么， 那么相应对象及其后代节点也面临被回收的状态。\n \n#### 2.4 Top consumers\n> 通过图形列出最大的object。 \n\n![](/images/server/java/JVM/mat4.png)\n\n\n#### 2.5 Leak Suspects\n> Leak Suspects 是MAT帮我们分析的可能有内存泄露嫌疑的地方，可以体现出哪些对象被保持在内存中，以及为什么它们没有被垃圾回收\n\n![](source/images/server/java/JVM/mat5.png)\n\n![](source/images/server/java/JVM/mat6.png)\n\n#### 2.6 Thread Overview\n> 在分析内存Dump的MAT中还可以看到线程栈信息，这本身就是一个强大的功能，类似于jstack命令的效果\n\n* Thread视图的入口，在工具栏上：\n\n![](/images/server/java/JVM/mat8.jpg)\n\n\n![](/images/server/java/JVM/mat9.jpg)\n\n* 在Thread Overview视图可以看到：线程对象/线程栈信息、线程名、Shallow Heap、Retained Heap、类加载器、是否Daemon线程等信息\n\n* 在分析内存Dump的MAT中还可以看到线程栈信息，这本身就是一个强大的功能，类似于jstack命令的效果\n\n* 而且还能结合内存Dump分析，看到线程栈帧中的本地变量，在左下方的对象属性区域还能看到本地变量的属性，真的很方便\n```java\npublic class TestThreadOverview {\n    private String str1 = \"str1\";\n    private String str2 = \"str2\";\n    public static void main(String[] args) {\n        TestThreadOverview test = new TestThreadOverview();\n        String local_str = \"local_str\";\n        LockSupport.park();\n    }\n}\n```\n* 在上面代码的Heap Dump分析中，可以看到线程调用栈的信息，以及main线程的 本地变量TestThreadOverview 和 字符串local_str 的信息\n\n![](source/images/server/java/JVM/mat10.jpg)\n\n* 上图中第一个框起来的部分是 new TestThreadOverview()对象（代码第6行），TestThreadOverview对象有两个属性str1、str2\n\n* 第二个框起来的部分是main方法中的字符串变量local_str（代码第8行）\n\n* 结合左侧的对象属性区域，可以更方便的看清线程中对象的具体情况\n\n![](source/images/server/java/JVM/mat11.jpg)\n\n## 其他\n* 分析较大的dump文件（根据经验2G以上的dump文件就需要使用以下介绍的方法，不然mat会出现oom）需要调整虚拟机参数找个64位的系统在MemoryAnalyzer.ini设置-Xmx2g\n* MAT提供了一个很贴心的功能，将报告的内容压缩打包到一个zip文件，并放在原始堆转储文件的目录下，一般命名为“xxx_Leak_Suspects.zip”，xxx是dump文件的名字，如果需要和同事一起分析这个内存问题的话，只需要把这个小小的zip包发给他就可以了，不需要把整个堆文件发给他。并且整个报告是一个HTML格式的文件，用浏览器就可以轻松打开  \n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.csdn.net/cc907566076/article/details/79108782\n* https://www.cnblogs.com/ldq2016/p/6632174.html\n* https://www.cnblogs.com/trust-freedom/p/6744948.html","tags":["jvm"],"categories":["服务器"]},{"title":"JVM虚拟机性能监控与故障处理工具","url":"/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/","content":"## JDK的命令行工具\n\n### jcmd 综合工具\n* `jcmd -l`  列出当前运行的所有虚拟机\n```java\n5362 sun.tools.jcmd.JCmd -l\n1236 /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=9080 --debug=5 --handlerCountMax=100 --handlerCountMaxIdle=20\n7167 org.apache.catalina.startup.Bootstrap start\n```\n* `jcmd [pid] VM.uptime`   查看虚拟机启动时间VM.uptime\n* `jcmd [pid] Thread.print`  打印线程栈信息Thread.print\n* `jcmd [pid] GC.class_histogram`  查看系统中类统计信息GC.class_histogram\n* `jcmd [pid] GC.heap_dump [filepath&name]`  导出堆信息GC.heap_dump  这个命令功能和 jmap -dump 功能一样\n* `jcmd [pid] VM.system_properties` 获取系统Properties内容VM.system_properties\n* `jcmd [pid] VM.flags` 获取启动参数VM.flags\n* `jcmd [pid] PerfCounter.print`  获取所有性能相关数据PerfCounter.print\n### jps 虚拟机进程状况工具\n* jps（JVM Process Status Tool）可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。虽然功能比较单一，但它是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier,PID）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。\n* 命令格式，其中[option]、[hostid]参数也可以不写。\n```sql\njps [options] [hostid]\n\noption参数\n    •-l : 输出主类全名或jar路径\n    •-q : 只输出LVMID\n    •-m : 输出JVM启动时传递给main()的参数\n    •-v : 输出JVM启动时显示指定的JVM参数\n```\n* 示例\n```\n$ jps -l\n\n15232 org.gradle.launcher.daemon.bootstrap.GradleDaemon\n3104 sun.tools.jps.Jps\n6784 org.jetbrains.idea.maven.server.RemoteMavenServer\n8916 org.jetbrains.jps.cmdline.Launcher\n15976\n8936 org.jetbrains.jps.cmdline.Launcher\n11580 com.songsy.iframe.Application\n```\n### jinfo 配置信息工具\n* jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令\n\n* 命令格式\n```sql\njinfo [option] [args] LVMID\n\noption参数\n    •-flag : 输出指定args参数的值\n    •-flags : 不需要args参数，输出所有JVM参数的值\n    •-sysprops : 输出系统属性，等同于System.getProperties()\n```\n* 示例\n```java\n$ jinfo -flags 11580\n\nAttaching to process ID 11580, please wait...\nDebugger attached successfully.\nServer compiler detected.\nJVM version is 25.121-b13\nNon-default VM flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=3 -XX:InitialHeapSize=134217728 -XX:+ManagementServer -XX:MaxHeapSize=2118123520 -XX:MaxNewSize=705691648 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44564480 -XX:OldSize=89653248 -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC\nCommand line:  -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:58771,suspend=y,server=n -XX:TieredStopAtLevel=1 -Xverify:none -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=58770 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true -javaagent:C:\\Users\\asua\\.IntelliJIdea2017.2\\system\\groovyHotSwap\\gragent.jar -Dfile.encoding=UTF-8\n\n```\n### jstat：虚拟机统计信息监视工具\n* jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。\n* 命令格式\n```\njstat [option] LVMID [interval] [count]\n\n参数\n    •[option] : 操作参数\n    •LVMID : 本地虚拟机进程ID\n    •[interval] : 连续输出的时间间隔\n    •[count] : 连续输出的次数\n    \n对于命令格式中的VMID与LVMID需要特别说明一下：\n如果是本地虚拟机进程，VMID与LVMID是一致的;\n如果是远程虚拟机进程，那VMID的格式应当是：protocol://lvmid@hostname:port/servername\n参数interval和count代表查询间隔(单位毫秒)和次数，如果省略这两个参数，说明只查询一次。\n假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20\n```\n* 选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考表4-3中的描述。\n\n![](/images/server/java/JVM/jstat.jpg)\n\n* `option`参数详解\n> `jstat -class`监视类装载、卸载数量、总空间以及耗费的时间\n```sql\n$ jstat -class 11580\n\nLoaded  Bytes  Unloaded  Bytes     Time\n  7107 13135.3        0     0.0       6.84\n\n•Loaded : 加载class的数量\n•Bytes : class字节大小\n•Unloaded : 未加载class的数量\n•Bytes : 未加载class的字节大小\n•Time : 加载时间\n```\n> `jstat -compiler`输出JIT编译过的方法数量耗时等\n```sql\n$ jstat -compiler  11580\nCompiled Failed Invalid   Time   FailedType FailedMethod\n    4079      3       0     1.62          1 org/springframework/beans/CachedIntrospectionResults <init>\n\n•Compiled : 编译数量\n•Failed : 编译失败数量\n•Invalid : 无效数量\n•Time : 编译耗时\n•FailedType : 失败类型\n•FailedMethod : 失败方法的全限定名\n```\n> `jstat -gc` 垃圾回收堆的行为统计\n```sql\n$ jstat -gc  11580\n S0C    S1C      S0U    S1U      EC       EU        OC         OU       MC      MU      CCSC    CCSU    YGC     YGCT    FGC    FGCT     GCT\n39424.0 29696.0  0.0    0.0      414208.0 353447.8  118272.0   46473.8  35072.0 34285.7 4608.0  4457.1  9       0.233   2      0.149    0.382\n\n•S0C : survivor0区的总容量\n•S1C : survivor1区的总容量\n•S0U : survivor0区已使用的容量\n•S1C : survivor1区已使用的容量\n•EC : Eden区的总容量\n•EU : Eden区已使用的容量\n•OC : Old区的总容量\n•OU : Old区已使用的容量\n•PC 当前perm的容量 (KB)\n•PU perm的使用 (KB)\n•YGC : 新生代垃圾回收次数\n•YGCT : 新生代垃圾回收时间\n•FGC : 老年代垃圾回收次数\n•FGCT : 老年代垃圾回收时间\n•GCT : 垃圾回收总消耗时间\n```\n> `jstat -gccapacity`同-gc，不过还会输出Java堆各区域使用到的最大、最小空间\n```sql\n$ jstat -gccapacity  11580\n NGCMN    NGCMX     NGC      S0C     S1C       EC          OGCMN      OGCMX       OGC        OC            MCMN      MCMX         MC          CCSMN   CCSMX       CCSC    YGC    FGC\n 43520.0  689152.0  689152.0 39424.0 29696.0   414208.0    87552.0    1379328.0   118272.0   118272.0      0.0       1079296.0    35072.0      0.0    1048576.0   4608.0  9      2\n \n•NGCMN : 新生代占用的最小空间\n•NGCMX : 新生代占用的最大空间\n•OGCMN : 老年代占用的最小空间\n•OGCMX : 老年代占用的最大空间\n•OGC：当前年老代的容量 (KB)\n•OC：当前年老代的空间 (KB)\n•PGCMN : perm占用的最小空间\n•PGCMX : perm占用的最大空间\n```\n> `jstat -gcutil` 同-gc，不过输出的是已使用空间占总空间的百分比\n```sql\n  S0     S1     E      O      M      CCS       YGC     YGCT      FGC    FGCT     GCT\n  0.00   0.00  85.33   39.29  97.76  96.73      9      0.233     2      0.149    0.382\n```\n> `jstat -gccause` 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因\n```sql\n$ jstat -gccause  11580\n  S0     S1    E      O      M      CCS    YGC  YGCT     FGC  FGCT     GCT    LGCC                 GCC\n  0.00   0.00  85.33  39.29  97.76  96.73  9    0.233    2    0.149    0.382  Allocation Failure   No GC\n\n•LGCC：最近垃圾回收的原因\n•GCC：当前垃圾回收的原因\n```\n> `jstat -gcnew` 统计新生代的行为\n```sql\n$ jstat -gcnew  11580\n S0C    S1C      S0U    S1U  TT  MTT  DSS      EC       EU            YGC     YGCT\n39424.0 29696.0  0.0    0.0  2   15   39424.0  414208.0 353447.8      9       0.233\n```\n> `jstat -gcnewcapacity` 新生代与其相应的内存空间的统计\n```sql\n$ jstat -gcnewcapacity  11580\n  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC\n   43520.0   689152.0   689152.0 229376.0  39424.0 229376.0  29696.0   688128.0   414208.0     9     2\n\n•NGC:当前年轻代的容量 (KB)\n•S0CMX:最大的S0空间 (KB)\n•S0C:当前S0空间 (KB)\n•ECMX:最大eden空间 (KB)\n•EC:当前eden空间 (KB)\n```\n\n### jmap：Java内存映像工具\n* jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。\n* 如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如加-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。\n* jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。\n* 命令格式\n```sql\njmap [option] LVMID\n\noption参数\n    •dump : 生成堆转储快照，格式为:-dump:[live, ] format=b,file=<filename>,其中live子参数说明是否只dump出存活的对象。\n    •finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象\n    •heap : 显示Java堆详细信息\n    •histo : 显示堆中对象的统计信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况\n    •permstat : to print permanent generation statistics\n    •F : 当-dump没有响应时，强制生成dump快照\n```\n* 示例\n```sql\n$ jmap -heap 28920\n\nAttaching to process ID 28920, please wait...\n  Debugger attached successfully.\n  Server compiler detected.\n  JVM version is 24.71-b01  \n  using thread-local object allocation.\n  Parallel GC with 4 thread(s)                //GC 方式  \n  Heap Configuration:                         //堆内存初始化配置\n     MinHeapFreeRatio = 0                     //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)\n     MaxHeapFreeRatio = 100                   //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)\n     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小\n     NewSize          = 1310720 (1.25MB)      //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小\n     MaxNewSize       = 17592186044415 MB     //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小\n     OldSize          = 5439488 (5.1875MB)    //对应jvm启动参数-XX:OldSize=<value>:设置JVM堆的‘老生代’的大小\n     NewRatio         = 2                     //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率\n     SurvivorRatio    = 8                     //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 \n     PermSize         = 21757952 (20.75MB)    //对应jvm启动参数-XX:PermSize=<value>:设置JVM堆的‘永生代’的初始大小\n     MaxPermSize      = 85983232 (82.0MB)     //对应jvm启动参数-XX:MaxPermSize=<value>:设置JVM堆的‘永生代’的最大大小\n     G1HeapRegionSize = 0 (0.0MB)  \n  Heap Usage:                                 //堆内存使用情况\n  PS Young Generation\n  Eden Space:                                 //Eden区内存分布\n     capacity = 33030144 (31.5MB)             //Eden区总容量\n     used     = 1524040 (1.4534378051757812MB)//Eden区已使用\n     free     = 31506104 (30.04656219482422MB)//Eden区剩余容量\n     4.614088270399305% used                  //Eden区使用比率\n  From Space:                                 //其中一个Survivor区的内存分布\n     capacity = 5242880 (5.0MB)\n     used     = 0 (0.0MB)\n     free     = 5242880 (5.0MB)\n     0.0% used\n  To Space:                                   //另一个Survivor区的内存分布\n     capacity = 5242880 (5.0MB)\n     used     = 0 (0.0MB)\n     free     = 5242880 (5.0MB)\n     0.0% used\n  PS Old Generation                           //当前的Old区内存分布\n     capacity = 86507520 (82.5MB)\n     used     = 0 (0.0MB)\n     free     = 86507520 (82.5MB)\n     0.0% used\n  PS Perm Generation                          //当前的 “永生代” 内存分布\n     capacity = 22020096 (21.0MB)\n     used     = 2496528 (2.3808746337890625MB)\n     free     = 19523568 (18.619125366210938MB)\n     11.337498256138392% used  \ninterned Strings occupying 43720 bytes.\n```\n> jmap -histo:live 28920 | more 打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）\n```sql\nnum     #instances         #bytes  class name\n----------------------------------------------\n   1:         83613       12012248  <constMethodKlass>\n   2:         23868       11450280  [B\n   3:         83613       10716064  <methodKlass>\n   4:         76287       10412128  [C\n   5:          8227        9021176  <constantPoolKlass>\n   6:          8227        5830256  <instanceKlassKlass>\n   7:          7031        5156480  <constantPoolCacheKlass>\n   8:         73627        1767048  java.lang.String\n   9:          2260        1348848  <methodDataKlass>\n  10:          8856         849296  java.lang.Class\n  \nclass name是对象类型，说明如下：\nB  byte\nC  char\nD  double\nF  float\nI  int\nJ  long\nZ  boolean\n[  数组，如[I表示int[]\n[L+类名 其他对象\n```\n### jhat：虚拟机堆转储快照分析工具\n* jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。\n\n* 不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器。二是用于分析的机器一般也是服务器，由于加载dump快照文件需要比生成dump更大的内存，所以一般在64位JDK、大内存的服务器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。\n\n* 命令格式\n```sql\n    jhat [option] [dumpfile]\n参数\n    •-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.>\n    •-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。>\n    •-port port-number 设置 jhat HTTP server 的端口号. 默认值 7000.> \n    •-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。>\n    •-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.>\n    •-debug int 设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.>\n    •-version 启动后只显示版本信息就退出>\n    •-J< flag > 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.\n```\n* 示例\n```sql\n ~ jhat eclipse.bin \nReading from eclipse.bin...\nDump file created Mon Oct 31 19:32:57 CST 2016\nSnapshot read, resolving...\nResolving 185857 objects...\nChasing references, expect 37 dots.....................................\nEliminating duplicate references.....................................\nSnapshot resolved.\nStarted HTTP server on port 7000\nServer is ready.\n\n屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost:7000/就可以看到分析结果.\n分析结果默认是以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的“Heap Histogram”（与jmap -histo功能一样）与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计.\n```\n### jstack：Java堆栈跟踪工具\n* jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。\n* 命令格式\n```sql\njstack [option] LVMID\n\noption参数\n    •-F : 当正常输出请求不被响应时，强制输出线程堆栈\n    •-l : 除堆栈外，显示关于锁的附加信息\n    •-m : 如果调用到本地方法的话，可以显示C/C++的堆栈\n```\n\n\n\n\n## JDK的可视化工具\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/wade-luffy/p/6017137.html","tags":["jvm"],"categories":["服务器"]},{"title":"JVM内存模型与线程(一)Java内存模型","url":"/2019/03/21/backend/java/jvm1/JVM内存模型与线程(一)Java内存模型/","content":"## 解析\n* 在说Java内存模型之前，我们先说一下Java的内存结构，也就是运行时的数据区域，这一块前面的章节已经介绍过了，很多人容易把内存结构跟内存模型搞混，内存结构就是下图中内存空间这些东西，而Java内存模型，完全是另外的一个东西。\n\n![](/images/server/java/JVM/neicun.jpg)\n\n* Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景下就不许针对不同的平台来编写程序。\n\n### 1. 主内存与工作内存\n* Java内存模型的主要目的是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。注意一下，此处的变量并不包括局部变量与方法参数，因为它们是线程私有的，不会被共享，自然也不会存在竞争，此处的变量应该是实例字段、静态字段和构成数组对象的元素。\n\n* Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量和主内存副本拷贝（注意这里绝不会是整个对象的拷贝，试想一个10M的对象，在每个用到这个对象的工作内存中有一个10M的拷贝，内存还受得了？也就是一些在线程中用到的对象中的字段罢了），线程对变量所有的操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成\n\n### 2. 内存间交互操作\n* 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面体积的每一种操作都是原子的、不可再分的\n    * 1、lock（锁定）：作用于主内存中的变量，它把一个变量标识为一条线程独占的状态\n    * 2、unlock（解锁）：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n    * 3、read（读取）：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用\n    * 4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中\n    * 5、use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，没当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作\n    * 6、assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作\n    * 7、store（存储）：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用\n    * 8、write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中\n* Java内存模型还规定了在执行上述8种基本操作时必须满足以下规则：\n    * 1、不允许read和load、store和write操作之一单独出现\n    * 2、不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了滞后必须把该变化同步回主内存\n    * 3、不允许一个线程无原因地把数据从线程的工作内存同步回主内存中\n    * 4、一个新的变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量\n    * 5、一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁\n    * 6、如果对同一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值\n    * 7、如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定的变量\n    * 8、对一个变量执行unlock操作之前，必须先把此变量同步回主内存中\n\n### 3. 对于volatile型变量的特殊规则\n* 关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。\n\n* 一个变量被定义为volatile后，它将具备两种特性：\n    * 1、保证此变量对所有线程的”可见性”，所谓”可见性”是指当一条线程修改了这个变量的值，新值对于其它线程来说都是可以立即得知的，而普通变量不能做到这一点，普通变量的值在在线程间传递均需要通过主内存来完成，关于volatile关键字的操作请参见volatile关键字使用举例，再强调一遍，volatile只保证了可见性，并不保证基于volatile变量的运算在并罚下是安全的\n      \n    * 2、使用volatile变量的第二个语义是禁止指令重排序优化，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。\n* 总结一下Java内存模型对volatile变量定义的特殊规则：\n    * 1、在工作内存中，每次使用某个变量的时候都必须线从主内存刷新最新的值，用于保证能看见其他线程对该变量所做的修改之后的值\n    * 2、在工作内存中，每次修改完某个变量后都必须立刻同步回主内存中，用于保证其他线程能够看见自己对该变量所做的修改\n    * 3、volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同 \n\n### 4. 原子性、可见性与有序性\n* 1、原子性（Atomicity）\n\n由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store、write，大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大的原子性保证，Java内存模型还提供了lock和unlock，尽管虚拟机没有把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—-synchronized关键字\n\n* 2、可见性（Visibility）\n\n可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile其实已经详细写了这一点，其实synchronized关键字也是可以实现可见性的，synchronized的可见性是由”对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。\n\n* 3、有序性（Ordering）\n\nJava程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无须的。前半句是指”线程内表现为穿行的语义”，后半句是指”指令重排序”和”工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入\n\n\n### 5. 先行发生原则\n\n* 如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将变得很繁琐，但是我们在编写Java代码时并未感觉到这一点，这是因为Java语言中有一个”先行发生（happens-before）”原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则就判断出并发环境下两个操作之间是否可能存在冲突的问题。\n\n* 所谓先行发生原则是指Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，那么操作A产生的影响能够被操作b观察到，”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。Java内存模型下有一些天然的，不需要任何同步协助器就已经存在的先行发生关系：\n    * 1、程序次序规则：在一个线程内，按照控制流顺序，控制流前面的操作先行发生于控制流后面的操作，说”控制流”是因为还要考虑到分支、循环结构\n    * 2、管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作\n    * 3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作\n    * 4、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作\n    * 5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测\n    * 6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n    * 7、对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始\n    * 8、传递新：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A必然先行发生于操作C\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html\n* https://baijiahao.baidu.com/s?id=1595082600371869908&wfr=spider&for=pc\n* http://www.importnew.com/28456.html","tags":["jvm"],"categories":["服务器"]},{"title":"字节码执行(二)基于栈的字节码解释器执行过程","url":"/2019/03/19/backend/java/jvm1/JVM字节码执行(二)基于栈的字节码解释器执行过程/","content":"## 解析\n* 根据一个代码实例来介绍虚拟机中解释器的执行过程\n```java\npublic int calculate(){  \n    int a = 100;  \n    int b = 200;  \n    int c = 300;  \n    return (a + b) * c;  \n}  \n```\n* 由上面的代码可以看出，该方法的逻辑很简单，就是进行简单的四则运算加减乘除，我们编译代码后使用javap -verbose命令查看字节码指令，具体字节码代码如下所示:\n```java\npublic int calculate();  \n  Code:  \n   Stack=2, Locals=4, Args_size=1  \n   0:   bipush  100  \n   2:   istore_1  \n   3:   sipush  200  \n   6:   istore_2  \n   7:   sipush  300  \n   10:  istore_3  \n   11:  iload_1  \n   12:  iload_2  \n   13:  iadd  \n   14:  iload_3  \n   15:  imul  \n   16:  ireturn  \n  LineNumberTable:  \n   line 3: 0  \n   line 4: 3  \n   line 5: 7  \n   line 6: 11  \n  \n}  \n```\n* 根据字节码可以看出，这段代码需要深度为2的操作数栈（Stack=2）和4个Slot的局部变量空间（Locals=4）。下面，使用7张图片来描述上面的字节码代码执行过程中的代码、操作数栈和局部变量表的变化情况。\n\n![](/images/server/java/JVM/zhix1.jpg)\n\n* 上图展示了执行偏移地址为0的指令的情况，bipush指令的作用是将单字节的整型常量值（-128~127）推入操作数栈顶，后跟一个参数，指明推送的常量值，这里是100。\n\n![](/images/server/java/JVM/zhix2.jpg)\n\n* 上图则是执行偏移地址为2的指令，istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量Slot中。后面四条指令（3、6、7、10）都是做同样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。后面四条指令的图就不重复画了。\n\n![](/images/server/java/JVM/zhix3.jpg)\n\n* 上面展示了执行偏移地址为11的指令，iload_1指令的作用是将局部变量第1个Slot中的整型值复制到操作数栈顶。\n\n![](/images/server/java/JVM/zhix4.jpg)\n\n* 上图为执行偏移地址12的指令，iload_2指令的执行过程与iload_1类似，把第2个Slot的整型值入栈。\n\n![](/images/server/java/JVM/zhix5.jpg)\n\n* 上图展示了执行偏移地址为13的指令情况，iadd指令的作用是将操作数栈中前两个栈顶元素出栈，做整型加法，然后把结果重新入栈。在iadd指令执行完毕后，栈中原有的100和200出栈，它们相加后的和300重新入栈。\n\n![](/images/server/java/JVM/zhix6.jpg)\n\n* 上图为执行偏移地址为14的指令的情况，iload_3指令把存放在第3个局部变量Slot中的300入栈到操作数栈中。这时操作数栈为两个整数300,。\n  \n* 下一条偏移地址为15的指令imul是将操作数栈中前两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，这里和iadd指令执行过程完全类似，所以就不重复画图了。\n\n![](/images/server/java/JVM/zhix7.jpg)\n\n* 上图是最后一条指令也就是偏移地址为16的指令的执行过程，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给此方法的调用者。到此为止，该方法执行结束。\n\n* 注：上面的执行过程只是一种概念模型，虚拟机最终会对执行过程做出一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述。不过从这段程序的执行过程也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都是以操作数栈的出栈和入栈为信息交换途径。\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.csdn.net/azhegps/article/details/54092466","tags":["jvm"],"categories":["服务器"]},{"title":"字节码执行(一)运行时栈帧结构","url":"/2019/03/19/backend/java/jvm1/JVM字节码执行(一)运行时栈帧结构/","content":"## 概述\n* 前几章介绍了Class类的文件结构及类的加载，有了原材料及已经运送过来了，那么就要生产产品了，那么字节码的执行就在生产产品\n* 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n* 每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。\n* 一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧的概念结构如下图所示：\n\n![](/images/server/java/JVM/stackFrame.png)\n## 运行时栈帧结构\n\n### 1. 局部变量表\n* 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。\n* 在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。\n* 局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。\n\n\n\n### 2. 操作数栈\n* 操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。\n* 当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。\n* 另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠过程如下图：\n\n\n![](/images/server/java/JVM/stackFrame1.png)\n\n### 3. 动态连接\n* 每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。\n\n### 4. 方法返回地址\n* 当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。\n* 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。\n* 无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。\n* 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。\n\n\n\n### 5. 附加信息\n* 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。\n\n\n## 方法调用\n* 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。\n\n### 解析\n* 如前所述，所有的方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可变的。也就是说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用成为解析。\n\n* JAVA中符号“编译器可知、运行期不可变”的方法包括：静态方法、私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这就决定了他们都不可能通过继承或别的方式重写其版本。因此都适合在类的加载阶段进行解析。\n\n* JAVA虚拟机里面提供了5条方法调用字节码指令。分别如下：\n```java\ninvokestatic:调用静态方法\n\ninvokespecial:调用实例构造器<init>方法、私有方法和父类方法（super(),super.method()）。\n\ninvokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、final方法都是非虚方法)。\n\ninvokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象。\n\ninvokedynamic:现在运行时期动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条指令，分派逻辑都是固化在虚拟机里面的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。\n\n```\n\n* 只要能被invokestatic和invokespecial指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载阶段就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法（还包括使用final修饰的方法，虽然final方法使用invokevirtual指令调用，因为final方法注定不会被重写，也就是无法被覆盖，也就无需对其进行多态选择）。\n\n* 解析调用一定是一个静态的过程，在编译期间就可以完全确定，在类装载的解析阶段就会把涉及的符号引用全部转化为可确定的直接引用，不会延迟到运行期去完成。而分派调用可能是静态的也可能是动态的，根据分派一句的宗量数可分为单分派和多分派。因此分派可分为：静态单分派、静态多分派、动态单分派、动态多分派。\n\n### 问题记录\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.csdn.net/xtayfjpk/article/details/41924283\n* https://www.cnblogs.com/chenyangyao/p/5305352.html","tags":["jvm"],"categories":["服务器"]},{"title":"类加载机制(二)类加载器","url":"/2019/03/18/backend/java/jvm1/JVM类加载机制(二)类加载器/","content":"## 解析\n\n### 1. 类加载器\n* 虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，\n\n* 3种类加载器：\n    * 启动类加载器(Bootstrap ClassLoader)：负责加载JRE的核心类库（JAVA_HOME\\lib）目录中的类包，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。启动类加载器是无法被Java程序直接引用的。\n    * 扩展类加载器(Extension ClassLoader)：负责加载JRE扩展目录 （JAVA_HOME\\lib\\ext） 目录中的类包，或通过java.ext.dirs系统变量指定路径中的类库。开发者可以直接使用扩展类加载器。\n    * 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n![](/images/server/java/JVM/classLoad.jpg)\n    \n* 例子：\n> 寻找类加载器\n```java\npackage com.neo.classloader;\npublic class ClassLoaderTest {\n     public static void main(String[] args) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        System.out.println(loader);\n        System.out.println(loader.getParent());\n        System.out.println(loader.getParent().getParent());\n    }\n}\n```\n> 结果\n```java\nsun.misc.Launcher$AppClassLoader@64fef26a\nsun.misc.Launcher$ExtClassLoader@1ddd40f3\nnull\n```\n* 从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。\n\n* 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。\n\n* 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。\n\n* 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：\n    * 在执行非置信代码之前，自动验证数字签名。\n    * 动态地创建符合用户特定需要的定制化构建类。\n    * 从特定的场所取得java class，例如数据库中和网络中。\n\n### 2. 自定义类加载器\n* 通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可\n\n```java\npackage com.neo.classloader;\n\nimport java.io.*;\n\n\npublic class MyClassLoader extends ClassLoader {\n\n    private String root;\n\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        byte[] classData = loadClassData(name);\n        if (classData == null) {\n            throw new ClassNotFoundException();\n        } else {\n            return defineClass(name, classData, 0, classData.length);\n        }\n    }\n\n    private byte[] loadClassData(String className) {\n        String fileName = root + File.separatorChar\n                + className.replace('.', File.separatorChar) + \".class\";\n        try {\n            InputStream ins = new FileInputStream(fileName);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = 0;\n            while ((length = ins.read(buffer)) != -1) {\n                baos.write(buffer, 0, length);\n            }\n            return baos.toByteArray();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String getRoot() {\n        return root;\n    }\n\n    public void setRoot(String root) {\n        this.root = root;\n    }\n\n    public static void main(String[] args)  {\n\n        MyClassLoader classLoader = new MyClassLoader();\n        classLoader.setRoot(\"E:\\\\temp\");\n\n        Class<?> testClass = null;\n        try {\n            testClass = classLoader.loadClass(\"com.neo.classloader.Test2\");\n            Object object = testClass.newInstance();\n            System.out.println(object.getClass().getClassLoader());\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n\n### 3. 类的加载\n\n* 类加载有三种方式\n    * 命令行启动应用时候由JVM初始化加载\n    * 通过Class.forName()方法动态加载\n    * 通过ClassLoader.loadClass()方法动态加载\n\n* Class.forName()和ClassLoader.loadClass()区别\n    * Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；\n    * ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。\n    * 注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。\n\n### 双亲委派模型\n* 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。\n\n* 双亲委派机制:\n    * 1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。\n    * 2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。\n    * 3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；\n* 双亲委派模型意义：\n    * 系统类防止内存中出现多份同样的字节码 \n    * 保证Java程序安全稳定运行，如果一个人编写了一个恶意的基础类(java.lang.String)并装载到JVM中，将会引起多么可怕的后果，有了这个机制(java.lang.String)永远是由启动类加载器来加载\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* http://www.importnew.com/25295.html\n* https://www.cnblogs.com/ityouknow/p/5603287.html\n","tags":["jvm"],"categories":["服务器"]},{"title":"类加载机制(一)类加载时机及过程","url":"/2019/03/16/backend/java/jvm1/JVM类加载机制(一)类加载时机及过程/","content":"## 什么是类的加载\n* 虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型\n\n* 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口\n\n\n## 类的生命周期\n\n* 如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。下面我们就分别来看一下这五个过程。\n\n![](/images/server/java/JVM/jiazai.png)\n\n### 1. 加载\n* 加载的过程：\n    * 1、通过一个类的全限定名来获取其定义的二进制字节流。\n    * 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n    * 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。\n\n* 加载`.class`文件的方式:\n    * 从本地系统中直接加载\n    * 通过网络下载.class文件\n    * 从zip，jar等归档文件中加载.class文件\n    * 从专有数据库中提取.class文件\n    * 将Java源文件动态编译为.class文件，比如java.lang.reflect.Proxy\n* 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。\n\n* 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是Java堆中，在hotspot中它是存放在方法区中），这样便可以通过该对象访问方法区中的这些数据。\n\n### 2. 验证\n* 验证是为了确保被加载的类的正确性\n\n* 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：\n    * 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。\n    * 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。\n    * 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。\n    * 符号引用验证：确保解析动作能正确执行。\n* 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\n### 3. 准备\n* 准备是为类的静态变量分配内存，并将其初始化为默认值\n\n*   准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意\n    * 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中\n    * 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。\n    * 假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行\n\n![](/images/server/java/JVM/defalutValue.png)\n\n### 4. 解析\n* 解析是把类中的符号引用转换为直接引用\n* 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。\n* 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。\n### 5. 初始化\n* 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。\n\n* 在Java中对类变量进行初始值设定有两种方式：\n    * 声明类变量是指定初始值\n    * 使用静态代码块为类变量指定初始值\n* JVM初始化步骤\n    * 1、假如这个类还没有被加载和连接，则程序先加载并连接该类\n    * 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类\n    * 3、假如类中有初始化语句，则系统依次执行这些初始化语句\n* 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下五种(有且只有)：\n    * 1、Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类\n    * 2、创建类的实例，也就是new的方式或者访问某个类或接口的静态变量，或者对该静态变量赋值，以及调用一个类的静态方法\n    * 3、使用java.lang.reflect包的方法对类进行反射调用的时候（如Class.forName(“com.shengsiyuan.Test”)）\n    * 4、初始化某个类的子类，如果父类没有初始化则其父类也会被初始化\n    * 5、当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。\n* 被动引用\n    * 通过子类引用父类的静态字段，不会导致子类初始化\n    * 通过数组定义来引用类，不会触发此类的初始化\n    * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发\n    \n\n### 6.结束\n* 在如下几种情况下，Java虚拟机将结束生命周期\n    * 执行了System.exit()方法\n    * 程序正常执行结束\n    * 程序在执行过程中遇到了异常或错误而异常终止\n    * 由于操作系统出现错误而导致Java虚拟机进程终止\n## 总结\n* 研究类加载全过程有助于连接JVM运行过程\n* 深入了解java动态性（热部署，动态加载），提高程序的灵活性\n\n    \n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* http://www.importnew.com/25295.html\n* https://www.cnblogs.com/ityouknow/p/5603287.html\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM类文件结构(三)字节码指令","url":"/2019/03/16/backend/java/jvm1/JVM类文件结构(三)字节码指令/","content":"## 解析\n* Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。由于JAVA虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码\n\n* 伪代码执行模型\n\n![](/images/server/java/JVM/zijie.png)\n\n### 加载、存储指令\n```sql\n1）iload、iload<n>、lload、lload<n>、fload、fload<n>、dload、dload<n>、aload、aload<n>：将一个局部变量加载到操作数栈。\n2）istore、istore<n>、lstore、lstore<n>、fstore、fstore<n>、dstore、dstore<n>、astore、astore<n>：将一个数值从操作数栈存储到局部变量表。\n3）bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconstm1、iconst<i>、lconst<l>、fconst<f>、dconst_<d>：将一个常量加载到操作数栈。\n4）wide：扩充局部变量表的访问索引的指令。\n```\n\n* 示例：\n    * 代码\n    ```java\n    public static int methodE(){\n        int e = 100;\n        int c = 300;\n        int d = 300000;\n        e++;\n        ++e;\n        --e;\n        e--;\n        return c + d + e;\n    }\n    ```\n    * 对应的字节码\n    ```java\n    public static int methodE();\n            Signature: ()I\n            flags: ACC_PUBLIC, ACC_STATIC\n            Code:\n            stack=2, locals=3, args_size=0\n            0: bipush        100\n            2: istore_0\n            3: sipush        300\n            6: istore_1\n            7: ldc           #5                  // int 300000\n            9: istore_2\n            10: iinc          0, 1\n            13: iinc          0, 1\n            16: iinc          0, -1\n            19: iinc          0, -1\n            22: iload_1\n            23: iload_2\n            24: iadd\n            25: iload_0\n            26: iadd\n            27: ireturn\n            LineNumberTable:\n            line 40: 0\n            line 41: 3\n            line 42: 7\n            line 43: 10\n            line 44: 13\n            line 45: 16\n            line 46: 19\n            line 47: 22\n    ```\n### 运算指令\n```sql\n1）iadd、ladd、fadd、dadd：加法指令。\n2）isub、lsub、fsub、dsub：减法指令。\n3）imul、lmul、fmul、dmul：乘法指令。\n4）idiv、ldiv、fdiv、ddiv：除法指令。\n5）irem、lrem、frem、drem：求余指令。\n6）ineg、lneg、fneg、dneg：取反指令。\n7）ishl、ishr、iushr、lshl、lshr、lushr：位移指令。\n8）ior、lor：按位或指令。\n9）iand、land：按位与指令。\n10）ixor、lxor：按位异或指令。\n11）iinc：局部变量自增指令。\n12）dcmpg、dcmpl、fcmpg、fcmpl、lcmp：比较指令。\n```\n* 示例参照上例\n\n### 类型转换指令\n```sql\n1）int类型到long、float或者double类型，long类型到float、double类型，float类型到double类型：宽化类型转换（虚拟机直接支持）。\n2）i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f：窄化类型转换（显式指令）。\n```\n* 示例：\n    * 代码\n    ```java\n    public static void methodK(){\n        int i = 97;\n        short i2s = (short) i;\n        char i2c = (char) i;\n        long i2l = i;\n        float i2f = i;\n        double i2d = i;\n        float l2f = i2l;\n        double l2d = i2l;\n    }\n    ```\n    * 对应的字节码\n    ```java\n    public static void methodK();\n    Signature: ()V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=11, args_size=0\n         0: bipush        97\n         2: istore_0\n         3: iload_0\n         4: i2s\n         5: istore_1\n         6: iload_0\n         7: i2c\n         8: istore_2\n         9: iload_0\n        10: i2l\n        11: lstore_3\n        12: iload_0\n        13: i2f\n        14: fstore        5\n        16: iload_0\n        17: i2d\n        18: dstore        6\n        20: lload_3\n        21: l2f\n        22: fstore        8\n        24: lload_3\n        25: l2d\n        26: dstore        9\n        28: return\n      LineNumberTable:\n        line 100: 0\n        line 101: 3\n        line 102: 6\n        line 103: 9\n        line 104: 12\n        line 105: 16\n        line 106: 20\n        line 107: 24\n        line 108: 28\n    ```\n### 对象创建与访问指令\n```sql\n1）new ：创建类实例的指令。\n2）newarray、anewarray、multianewarray：创建数组的指令。\n3）getstatic、putstatic、getfield、putfield：访问类字段（类变量）和实例字段（实例变量）的指令。\n4）baload、caload、saload、iaload、laload、faload、daload、aaload：把一个数组元素加载到操作数栈的指令。\n5）bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore：把一个操作数栈的值存储到数组元素中的指令。\n6）arraylength：取数组长度的指令。\n7）instanceof、checkcast：检查类实例类型的指令。\n```\n* 示例：\n    * 代码\n    ```java\n    public static void methodJ(){\n        new SimpleMethodExecuteProcess();\n    \n        System.out.println(SimpleMethodExecuteProcess.i);\n    }\n    ```\n    * 对应的字节码\n    ```java\n    public static void methodJ();\n    Signature: ()V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=0, args_size=0\n         0: new           #9                  // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess\n         3: dup\n         4: invokespecial #10                 // Method \"<init>\":()V\n         7: pop\n         8: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n        11: getstatic     #11                 // Field i:I\n        14: invokevirtual #12                 // Method java/io/PrintStream.println:(I)V\n        17: return\n      LineNumberTable:\n        line 91: 0\n        line 93: 8\n        line 94: 17\n    ```\n    \n\n### 操作数栈管理指令\n```sql\n1）pop、pop2：将操作数栈的栈顶一个或两个元素出栈。\n2）dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。\n3）swap：将栈最顶端两个数值互换\n```\n* 示例：\n    * 代码\n    ```java\n    public static void main(String[] args) {\n        heavyMethod();\n    }\n    ```\n    * 对应的字节码\n    ```java\n    public static void main(java.lang.String[]);\n            Signature: ([Ljava/lang/String;)V\n            flags: ACC_PUBLIC, ACC_STATIC\n            Code:\n                            stack=1, locals=1, args_size=1\n                            0: invokestatic  #23                 // Method heavyMethod:()I\n                            3: pop\n                            4: return\n            LineNumberTable:\n                            line 115: 0\n                            line 116: 4\n    ```\n### 控制转移指令\n```sql\n1）ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。\n2）tableswitch、lookupswitch：复合条件分支。\n3）goto、goto_w、jsr、jsr_w、ret：无条件分支。\n```\n* 示例：\n    * 代码\n    ```java\n    public static void methodG(){\n        if(i == 0){\n            System.out.println(System.currentTimeMillis());\n        }\n    \n        while(i < 1){\n            System.out.println(System.currentTimeMillis());\n            i++;\n        }\n    }\n    ```\n    * 对应的字节码\n    ```java\n   public static void methodG();\n    Signature: ()V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=3, locals=0, args_size=0\n         0: getstatic     #6                  // Field i:I\n         3: ifne          15\n         6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         9: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J\n        12: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V\n        15: getstatic     #6                  // Field i:I\n        18: iconst_1\n        19: if_icmpge     42\n        22: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n        25: invokestatic  #7                  // Method java/lang/System.currentTimeMillis:()J\n        28: invokevirtual #8                  // Method java/io/PrintStream.println:(J)V\n        31: getstatic     #6                  // Field i:I\n        34: iconst_1\n        35: iadd\n        36: putstatic     #6                  // Field i:I\n        39: goto          15\n        42: return\n      LineNumberTable:\n        line 62: 0\n        line 63: 6\n        line 66: 15\n        line 67: 22\n        line 68: 31\n        line 70: 42\n      StackMapTable: number_of_entries = 2\n           frame_type = 15 /* same */\n           frame_type = 26 /* same */\n    ```\n### 异常处理指令\n```sql\nathrow ：显式抛出异常指令。\n```\n* 示例：\n    * 代码\n    ```java\n    public static void methodH(){\n        try {\n            throw new NullPointerException(\"nothing ...\");\n            // do nothing ...\n        } catch (Throwable t){\n            // do nothing ...\n        }\n    }\n    ```\n    * 对应的字节码\n    ```java\n    public static void methodH();\n    Signature: ()V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=3, locals=1, args_size=0\n         0: new           #9                  // class java/lang/NullPointerException\n         3: dup\n         4: ldc           #10                 // String nothing ...\n         6: invokespecial #11                 // Method java/lang/NullPointerException.\"<init>\":(Ljava/lang/String;)V\n         9: athrow\n        10: astore_0\n        11: return\n      Exception table:\n         from    to  target type\n             0    10    10   Class java/lang/Throwable\n      LineNumberTable:\n        line 77: 0\n        line 79: 10\n        line 82: 11\n      StackMapTable: number_of_entries = 1\n           frame_type = 74 /* same_locals_1_stack_item */\n          stack = [ class java/lang/Throwable ]\n    ```\n* 同步指令\n```sql\nmonitorenter、monitorexit：支持synchronized语句块语义的指令。\n```\n\n* 示例：\n    * 代码\n    ```java\n    public void methodI(){\n        synchronized (Integer.class){\n            // do nothing ...\n        }\n    }\n    ```\n    * 对应的字节码\n    ```java\n    public void methodI();\n    Signature: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: ldc_w         #13                 // class java/lang/Integer\n         3: dup\n         4: astore_1\n         5: monitorenter\n         6: aload_1\n         7: monitorexit\n         8: goto          16\n        11: astore_2\n        12: aload_1\n        13: monitorexit\n        14: aload_2\n        15: athrow\n        16: return\n      Exception table:\n         from    to  target type\n             6     8    11   any\n            11    14    11   any\n      LineNumberTable:\n        line 88: 0\n        line 90: 6\n        line 91: 16\n      StackMapTable: number_of_entries = 2\n           frame_type = 255 /* full_frame */\n          offset_delta = 11\n          locals = [ class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess, class java/lang/Object ]\n          stack = [ class java/lang/Throwable ]\n           frame_type = 250 /* chop */\n          offset_delta = 4\n    ```\n\n* synchronized 修饰方法的语义解析：可以直接从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法，不需要解析出monitorenter、monitorexit同步指令。\n```java\npublic static synchronized void methodL(){\n    int i = 97;\n}\n\n    public static synchronized void methodL();\n        Signature: ()V\n        flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED\n        Code:\n            stack=1, locals=1, args_size=0\n                 0: bipush        97\n                 2: istore_0\n                 3: return\n            LineNumberTable:\n                line 120: 0\n                line 121: 3\n```\n* 方法调用和返回指令\n```sql\n1）invokestatic：调用静态方法。\n2）invokespecial：调用实例构造器<init>方法、私有方法和父类方法。\n3）invokevirtual：调用所有的虚方法。非虚方法以外的都是虚方法，非虚方法包括使用invokestatic、invokespecial调用的方法和被final修饰的方法。\n4）invokeinterface：调用接口方法，运行时再确定一个实现此接口的对象。\n5）invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。\nireturn（返回值是boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn：方法返回指令。\n```\n\n* 示例：\n    * 代码\n    ```java\n    public static int heavyMethod(){\n        int a = 200;\n        int b = 100;\n        int c = methodC(methodA(methodA(a, b), b), methodB(a, b));\n        methodD();\n        methodE();\n        methodF();\n        methodG();\n        methodH();\n        new SimpleMethodExecuteProcess().methodI();\n        methodJ();\n        methodK();\n        methodL();\n        return c;\n    }\n    ```\n    * 对应的字节码\n    ```java\n    public static int heavyMethod();\n    Signature: ()I\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=3, locals=3, args_size=0\n         0: sipush        200\n         3: istore_0\n         4: bipush        100\n         6: istore_1\n         7: iload_0\n         8: iload_1\n         9: invokestatic  #17                 // Method methodA:(II)I\n        12: iload_1\n        13: invokestatic  #17                 // Method methodA:(II)I\n        16: iload_0\n        17: iload_1\n        18: invokestatic  #18                 // Method methodB:(II)I\n        21: invokestatic  #19                 // Method methodC:(II)I\n        24: istore_2\n        25: invokestatic  #20                 // Method methodD:()V\n        28: invokestatic  #21                 // Method methodE:()I\n        31: pop\n        32: invokestatic  #22                 // Method methodF:()D\n        35: pop2\n        36: invokestatic  #23                 // Method methodG:()V\n        39: invokestatic  #24                 // Method methodH:()V\n        42: new           #14                 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess\n        45: dup\n        46: invokespecial #15                 // Method \"<init>\":()V\n        49: invokevirtual #25                 // Method methodI:()V\n        52: invokestatic  #26                 // Method methodJ:()V\n        55: invokestatic  #27                 // Method methodK:()V\n        58: invokestatic  #28                 // Method methodL:()V\n        61: iload_2\n        62: ireturn\n      LineNumberTable:\n        line 128: 0\n        line 129: 4\n        line 130: 7\n        line 131: 25\n        line 132: 28\n        line 133: 32\n        line 134: 36\n        line 135: 39\n        line 136: 42\n        line 137: 52\n        line 138: 55\n        line 139: 58\n        line 140: 61\n    ```\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.51cto.com/damon188/2131035\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM类文件结构(二)Code属性","url":"/2019/03/16/backend/java/jvm1/JVM类文件结构(二)Code属性/","content":"## 解析\n* Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据\n\n* Java虚拟机执行字节码是基于栈的体系结构\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/yxwkf/p/5222589.html","tags":["jvm"],"categories":["服务器"]},{"title":"JVM类文件结构(一)Class类文件结构","url":"/2019/03/16/backend/java/jvm1/JVM类文件结构(一)Class类文件结构/","content":"## 解析\n* 不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器直接生成)。\n\n* Class文件是一组以8位字节为基础单位的二进制流。各个数据项严格按顺序排列，没有不论什么分隔符。\n\n* Class文件格式採用一种类似于C语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。\n    * 无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。\n    *  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。\n\n![image](/images/server/java/JVM/class.png)\n\n\n* 使用以下的类进行说明：\n```java\npackage com.test;\n\npublic class Test {\n\tprivate int m;\n\t\n\tpublic int getM(){\n\t\treturn m + 1;\n\t}\n}\n```\n* javap -verbose 执行后的可视byteCode（只存在两种数据类型：无符号数字与表）:\n```java\nClassfile /D:/workspace-github/jvm/target/production/jvm/com/songsy/Test.class\n  Last modified 2019-3-16; size 361 bytes\n  MD5 checksum bb8e54060828e4bf1f709c2f4434dca8\n  Compiled from \"Test.java\"\npublic class com.songsy.Test\n  minor version: 0\n  major version: 51\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #4.#18         // java/lang/Object.\"<init>\":()V\n   #2 = Fieldref           #3.#19         // com/songsy/Test.m:I\n   #3 = Class              #20            // com/songsy/Test\n   #4 = Class              #21            // java/lang/Object\n   #5 = Utf8               m\n   #6 = Utf8               I\n   #7 = Utf8               <init>\n   #8 = Utf8               ()V\n   #9 = Utf8               Code\n  #10 = Utf8               LineNumberTable\n  #11 = Utf8               LocalVariableTable\n  #12 = Utf8               this\n  #13 = Utf8               Lcom/songsy/Test;\n  #14 = Utf8               getM\n  #15 = Utf8               ()I\n  #16 = Utf8               SourceFile\n  #17 = Utf8               Test.java\n  #18 = NameAndType        #7:#8          // \"<init>\":()V\n  #19 = NameAndType        #5:#6          // m:I\n  #20 = Utf8               com/songsy/Test\n  #21 = Utf8               java/lang/Object\n{\n  public com.songsy.Test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 7: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/songsy/Test;\n\n  public int getM();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field m:I\n         4: iconst_1\n         5: iadd\n         6: ireturn\n      LineNumberTable:\n        line 11: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       7     0  this   Lcom/songsy/Test;\n}\nSourceFile: \"Test.java\"\n```\n\n* 编译后的class文件例如以下：\n\n![](/images/server/java/JVM/class1.png)\n\n### 1. 魔数与Class版本\n\n* 每一个class文件的头4个字节称为魔数，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。非常多文件存储标准中都使用魔数来进行身份识别。譬如图片格式gif、jpeg等。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，由于文件拓展格式能够任意修改。Class文件的魔数为：0xCAFEBABE（咖啡宝贝？）。这个魔数似乎也预示着日后JAVA这个商标名称的出现。\n\n![](/images/server/java/JVM/class2.png)\n\n* 第五六个字节是次版本（Minor Version）。第7和第8个字节是主版本（Major Version）。\n\n* 高版本号的JDK能够向下兼容曾经版本号的Class文件，可是无法执行以后版本号的Class文件，即使文件格式并未发生变化，虚拟机也必须拒绝执行超过其版本号号的Class文件。\n\n![](/images/server/java/JVM/class-version.png)\n\n### 2. 常量池\n* 紧接着版本之后就是常量池，常量池能够理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之中的一个。同一时候也是在Class文件里第一个出现的表类型数据项目\n\n![](/images/server/java/JVM/class3.png)\n\n* 常量池中主要存放两大类常量\n    * 字面量和符号引用。字面量如文本字符串、声明为final的常量值等\n    * 符号引用包含三类常量：类和接口的全限定名、字段的名称和描写叙述符、方法的名称和描写叙述符。\n    \n### 3. 访问标志\n* 在常量池结束之后，紧接着的两个字节代表訪问标志。用于识别一些类或者接口层次的訪问信息。包括：这个类是Class类还是接口；是否定义为public类型，是否被声明为final，具体的标志位及其含义例如以下表所看到的。\n \n![image](/images/server/java/JVM/class-access.png)\n\n* 依据上面的表格，測试类的訪问标志0x0021= 0x0001 | 0x0020 =ACC_PUBLIC | ACC_SUPER \n\n![](/images/server/java/JVM/class4.png)\n\n### 4. 类索引、父类索引和接口索引集合\n\n![](/images/server/java/JVM/class5.png)\n\n* Class文件里由这3项数据来确定这个类的继承关系\n    * this_class：类索引，用于确定这个类的全限定名，占2字节\n    * super_class：父类索引。用于确定这个类父类的全限定名（Java语言不同意多重继承，故父类索引仅仅有一个。除了java.lang.Object类之外全部类都有父类，故除了java.lang.Object类之外，全部类该字段值都不为0），占2字节\n    * interfaces_count：接口索引计数器。占2字节。接口索引计数器。占2字节。\n    * interfaces：接口索引集合，一组u2类型数据的集合。用来描写叙述这个类实现了哪些接口。这些被实现的接口将按implements语句（假设该类本身为接口，则为extends语句）后的接口顺序从左至右排列在接口的索引集合中\n* this_class、super_class与interfaces中保存的索引值均指向常量池中一个CONSTANT_Class_info类型的常量。通过这个常量中保存的索引值能够找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串this_class的值为0x0001，即常量池中第一个常量，super_class的值为0x0003，即常量池中的第三个常量，interfaces_counts的值为0x0000，故接口索引集合大小为0\n\n### 5. 字段表集合\n![](/images/server/java/JVM/class6.png)\n\n* 字段表用于描写叙述接口或者类中声明的变量，包含类级变量和实例级变量(是否是static)。但不包含在方法内部声明的局部变量。\n    * fields_count：字段表计数器。即字段表集合中的字段表数据个数。占2字节，其值为0x0001，即仅仅有一个字段表数据。也就是測试类中仅仅包括一个变量（不算方法内部变量）\n    * 字段表集合，一组字段表类型数据的集合。字段表用于描写叙述接口或类中声明的变量。包含类级别（static）和实例级别变量，不包含在方法内部声明的变量 \n### 6. 方法表集合\n* methods_count：方法表计数器，即方法表集合中的方法表数据个数。占2字节，其值为0x0002，即測试类中有2个方法(还自己主动添加了一个构造函数）\n\n* methods：方法表集合，一组方法表类型数据的集合。方法表结构和字段表结构一样：\n\n### 7. 属性表集合\n* 在Class文件、属性表、方法表中都能够包括自己的属性表集合。用于描写叙述某些场景的专有信息\n\n* 与Class文件里其他数据项对长度、顺序、格式的严格要求不同，属性表集合不要求当中包括的属性表具有严格的顺序，而且仅仅要属性的名称不与已有的属性名称反复。不论什么人实现的编译器可以向属性表中写入自定义的属性信息。虚拟机在执行时会忽略不能识别的属性，为了能正确解析Class文件\n\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/yxwkf/p/5222589.html","tags":["jvm"],"categories":["服务器"]},{"title":"JVM垃圾回收(五)GC分析","url":"/2019/03/11/backend/java/jvm1/JVM垃圾回收(五)GC分析/","content":"## GC日志查看\n* 可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。GC的日志是以替换的方式(>)写入的，而不是追加(>>)，如果下次写入到同一个文件中的话，以前的GC内容会被清空。\n* 对应的参数列表\n```sql\n-XX:+PrintGC 输出GC日志\n-XX:+PrintGCDetails 输出GC的详细日志\n-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）\n-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）\n-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息\n-Xloggc:../logs/gc.log 日志文件的输出路径\n```\n* 示例 `-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs`\n> 新生代回收日志\n```sql\n2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K->2K(948864K), 0.0059180 secs] 2186589K->1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n``` \n```sql\n2014-07-18T16:02:17.606+0800（当前时间戳）: 611.633（时间戳）: [GC（表示Young GC） 611.633: [DefNew（单线程Serial年轻代GC）: 843458K（年轻代垃圾回收前的大小）->2K（年轻代回收后的大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）] 2186589K（整个堆回收前的大小）->1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）]\n```\n> 老年代回收的日志如下：\n```sql\n2014-07-18T16:19:16.794+0800: 1630.821: [GC 1630.821: [DefNew: 1005567K->111679K(1005568K), 0.9152360 secs]1631.736: [Tenured:2573912K->1340650K(2574068K), 1.8511050 secs] 3122548K->1340650K(3579636K), [Perm : 17882K->17882K(21248K)], 2.7854350 secs] [Times: user=2.57 sys=0.22, real=2.79 secs]\n```\n\n# \n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/qlqwjy/p/7929414.html","tags":["jvm"],"categories":["服务器"]},{"title":"JVM垃圾回收(四)常用参数","url":"/2019/03/11/backend/java/jvm1/JVM垃圾回收(四)常用参数/","content":"> JVM参数的含义\n\n|    参数名称    |       含义       |     默认值   | 备注  |\n|:--------------|:--------------- |: ---------- |: ----------|\n|  -Xms         |     初始堆大小starting    |   物理内存的1/64(<1GB) | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.  |\n|  -Xmx         |    最大堆大小max     |  物理内存的1/4(<1GB) | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制  |\n|  -Xmn         |年轻代大小(1.4or lator)new  |  | 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 |\n|  -XX:NewSize         | 设置年轻代大小(for 1.3/1.4) |  |  |\n|  -XX:MaxNewSize         |年轻代最大值(for 1.3/1.4)  |  |  |\n|  -XX:PermSize         | 设置持久代(perm gen)初始值 | 物理内存的1/64 |  |\n|  -XX:MaxPermSize         | 设置持久代最大值 | 物理内存的1/4 |  |\n|  -Xss         |每个线程的堆栈大小  |  |  JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:\"”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。|\n|  -XX:ThreadStackSize         | Thread Stack Size |  |  |\n|  -XX:NewRatio         | 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) |  |  -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置|\n|  -XX:SurvivorRatio         | Eden区与Survivor区的大小比值 |  |  设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10|\n|  -XX:LargePageSizeInBytes         | 内存页的大小不可设置过大， 会影响Perm的大小 |  | =128m |\n|  -XX:+UseFastAccessorMethods         | 原始类型的快速优化 |  |  |\n|  -XX:+DisableExplicitGC         | 关闭System.gc() |  | 这个参数需要严格的测试 |\n|  -XX:MaxTenuringThreshold         | 垃圾最大年龄 |  |  如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效|\n|  -XX:+AggressiveOpts         | 加快编译 |  |  |\n|  -XX:+UseBiasedLocking         | 锁机制的性能改善 |  |  |\n|  -Xnoclassgc         |  禁用垃圾回收|  |  |\n|  -XX:SoftRefLRUPolicyMSPerMB         | 每兆堆空闲空间中SoftReference的存活时间 | 1s |  |\n|  -XX:PretenureSizeThreshold         | 对象超过多大是直接在旧生代分配 | 0 | 单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. |\n|  -XX:TLABWasteTargetPercent         |TLAB占eden区的百分比  |1%  |  |\n|  -XX:+CollectGen0First         | FullGC时是否先YGC | false |  |\n\n> 并行收集器相关参数\n\n|    参数名称    |       含义       |     默认值   | 备注  |\n|:--------------|:--------------- |: ---------- |: ----------|\n| -XX:+UseParallelGC |    Full GC采用parallel MSC(此项待验证)   |    |   选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)   |\n| -XX:+UseParNewGC  |  设置年轻代为并行收集     |    |  可与CMS收集同时使用JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值    |\n| -XX:ParallelGCThreads  |   并行收集器的线程数    |    |    此值最好配置与处理器数目相等 同样适用于CMS  |\n| -XX:+UseParallelOldGC  |   年老代垃圾收集方式为并行收集(Parallel Compacting)    |    |  这个是JAVA 6出现的参数选项    |\n| -XX:MaxGCPauseMillis  |    每次年轻代垃圾回收的最长时间(最大暂停时间)   |    |    如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.  |\n| -XX:+UseAdaptiveSizePolicy  |  自动选择年轻代区大小和相应的Survivor区比例     |    |  设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.    |\n| -XX:GCTimeRatio  |   设置垃圾回收时间占程序运行时间的百分比    |    |    公式为1/(1+n)  |\n| -XX:+ScavengeBeforeFullGC  | Full GC前调用YGC      |   true |    Do young generation GC prior to a full GC. (Introduced in 1.4.1.)  |\n\n> CMS相关参数\n\n|    参数名称    |       含义       |     默认值   | 备注  |\n|:--------------|:--------------- |: ---------- |: ----------|\n|-XX:+UseConcMarkSweepGC   |使用CMS内存收集   |   |  |\n|-XX:+AggressiveHeap   |   |   | 试图是使用大量的物理内存长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升） |\n|-XX:CMSFullGCsBeforeCompaction   | 多少次后进行内存压缩  |   |由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生\"碎片\",使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.  |\n|-XX:+CMSParallelRemarkEnabled  | 降低标记停顿  |   |  |\n|-XX+UseCMSCompactAtFullCollection  | 在FULL GC的时候， 对年老代的压缩  |   | CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片 |\n|-XX:+UseCMSInitiatingOccupancyOnly   |  使用手动定义初始化定义开始CMS收集 |   |  禁止hostspot自行触发CMS GC|\n|-XX:CMSInitiatingOccupancyFraction=70  | 使用cms作为垃圾回收使用70％后开始CMS收集  |  92 | 为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式 |\n|-XX:CMSInitiatingPermOccupancyFraction  | 设置Perm Gen使用到达多少比率时触发  |  92 |  |\n|-XX:+CMSIncrementalMode  | 设置为增量模式  |   | 用于单CPU情况 |\n|-XX:+CMSClassUnloadingEnabled  |   |   |  |\n\n\n> 辅助参数\n\n|    参数名称    |       含义       |     默认值   | 备注  |\n|:--------------|:--------------- |: ---------- |: ----------|\n|  -XX:+PrintGC |   |   | 输出形式:[GC 118250K->113543K(130112K), 0.0094143 secs][Full GC 121376K->10414K(130112K), 0.0650971 secs] |\n|  -XX:+PrintGCDetails |   |   |  输出形式:[GC [DefNew: 8614K->781K(9088K), 0.0123035 secs] 118250K->113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K->8614K(9088K), 0.0000665 secs][Tenured: 112761K->10414K(121024K), 0.0433488 secs] 121376K->10414K(130112K), 0.0436268 secs]|\n|  -XX:+PrintGCTimeStamps |   |   |  |\n|  -XX:+PrintGCApplicationStoppedTime | 打印垃圾回收期间程序暂停的时间.可与上面混合使用  |   | 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用输出形式:11.851: [GC 98328K->93620K(130112K), 0.0082960 secs] |\n|  -XX:+PrintGCApplicationConcurrentTime | 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用  |   | 输出形式:Total time for which application threads were stopped: 0.0468229 seconds |\n|  -XX:+PrintHeapAtGC | 打印GC前后的详细堆栈信息  |   |  |\n|  -Xloggc:filename |  把相关日志信息记录到文件以便分析，与上面几个配合使用 |   |  |\n|  -XX:+PrintClassHistogram | garbage collects before printing the histogram.  |   |  |\n|  -XX:+PrintTLAB |  查看TLAB空间的使用情况   |   |  |\n|   XX:+PrintTenuringDistribution |查看每次minor GC后新的存活周期的阈值   |   |Desired survivor size 1048576 bytes, new threshold 7 (max 15)new threshold 7即标识新的存活周期的阈值为7。  |\n> 备注\n* `-X` 开头参数的是非标准，不是所有虚拟机都支持，`-XX`更流氓，不保证其稳定性\n* \n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html","tags":["jvm"],"categories":["服务器"]},{"title":"JVM垃圾回收(三)内存分配及回收策略","url":"/2019/03/10/backend/java/jvm1/JVM垃圾回收(三)内存分配及回收策略/","content":"## 概述\n* Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。\n* 对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。\n    * TLAB: 首先讲讲什么是TLAB。内存分配的动作，可以按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。这么做的目的之一，也是为了并发创建一个对象时，保证创建对象的线程安全性。TLAB比较小，直接在TLAB上分配内存的方式称为快速分配方式，而TLAB大小不够，导致内存被分配在Eden区的内存分配方式称为慢速分配方式。\n* 接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。由于条件因素，只能在Client模式下测试，因此CMS和G1并未提及。\n## 解析\n\n### 1. 对象优先在Eden分配\n* 所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。\n    * 新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。\n    * 老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。\n \n![](/images/server/java/JVM/gc-generation.gif)\n\n* 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。这时会把存活的对象转移进Survivor区。\n    * `Minor GC` 新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。\n    * `Major GC` 老年代GC，指发生在老年代的GC。\n    * `Full GC` 包括前两个\n\n* 举例说明\n    * 下面的代码来看一下jvm具体是怎样分配的，下面的代码注释有详细解释\n    ```java\n    /**\n     * VM参数：\n     *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC\n     * 参数解析：\n     *      * 初始堆大小为20兆，不可扩展，年轻代大小为10兆剩下的10兆分配给老年代，PrintGCDetails打印内存回收日志，SurvivorRatio标识 eden与Survivor比例为8:1\n     *      * \"eden space 8192K from space 1024K to space 1024K\" 新生代总可用空间为9216KB (一个Eden区 + 一个Survivor区)\n     * @author songsy\n     * @date 2019/3/11 18:37\n     */\n    public class Jvm1 {\n    \n        private static final int _1KB = 1024;\n        private static final int _1MB = 1024 * _1KB;\n    \n        public static void testAllocation() {\n            byte [] allocation1,allocation2, allocation3,allocation4,allocation5;\n            allocation1 = new byte[2 * _1MB];\n            allocation2 = new byte[2 * _1MB];\n            allocation3 = new byte[2 * _1MB];\n            /**\n             * 执行到下一步出现一次Minor GC，因为发现Eden已经被占用了6Mb，剩余空间装不下4Mb，\n             * 执行gc的时候发现已有3*2Mb的对象无法放入Survivor（只有1mb）空间，所以只好通过\n             * 分配担保机制提前转移到老年代去\n             */\n            allocation4 = new byte[4 * _1MB];\n            /**\n             * Gc结束，4Mb的allocation4对象将分配在Eden区，老年代占用6Mb\n             */\n        }\n        public static void main(String[] args) {\n            testAllocation();\n        }\n    }\n    ``` \n    * 输出日志\n    ```\n    [GC[DefNew: 7485K->526K(9216K), 0.0076710 secs] 7485K->6671K(19456K), 0.0077381 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] \n    Heap\n     def new generation   total 9216K, used 4952K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)\n      eden space 8192K,  54% used [0x00000000f9a00000, 0x00000000f9e526c8, 0x00000000fa200000)\n      from space 1024K,  51% used [0x00000000fa300000, 0x00000000fa383bd8, 0x00000000fa400000)\n      to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)\n     tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)\n       the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)\n     compacting perm gen  total 21248K, used 2950K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)\n       the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0e1918, 0x00000000fb0e1a00, 0x00000000fc2c0000)\n    No shared spaces configured.\n    ```\n### 2. 大对象直接进入老年代\n* 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）。\n* 虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。\n* 举例说明\n    ```java\n    /**\n     * 测试大对象直接进入老年代\n     *\n     * VM参数：\n     *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC\n     * -XX:PretenureSizeThreshold=3145728 可选\n     * \n     * @author songsy\n     * @date 2019/3/11 18:37\n     */\n    public class Jvm2 {\n    \n        private static final int _1KB = 1024;\n        private static final int _1MB = 1024 * _1KB;\n    \n        public static void testAllocation() {\n            byte [] allocation1;\n            // 直接分配在老年代\n            allocation1 = new byte[4 * _1MB];\n        }\n        public static void main(String[] args) {\n            testAllocation();\n        }\n    }\n    ```\n    * 没设置PretenureSizeThreshold，可以看到新生代`def new generation   total 9216K, used 5773K`，老年代`tenured generation   total 10240K, used 0K`\n    ```\n    Heap\n     def new generation   total 9216K, used 5773K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)\n      eden space 8192K,  70% used [0x00000000f9a00000, 0x00000000f9fa3668, 0x00000000fa200000)\n      from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)\n      to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)\n     tenured generation   total 10240K, used 0K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)\n       the space 10240K,   0% used [0x00000000fa400000, 0x00000000fa400000, 0x00000000fa400200, 0x00000000fae00000)\n     compacting perm gen  total 21248K, used 3237K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)\n       the space 21248K,  15% used [0x00000000fae00000, 0x00000000fb129600, 0x00000000fb129600, 0x00000000fc2c0000)\n    No shared spaces configured.\n    ```\n    \n    * 设置了PretenureSizeThreshold结果，可以看到新生代`def new generation   total 9216K, used 1671K` ,老年代`tenured generation   total 10240K, used 4096K`\n    ```\n    Heap\n     def new generation   total 9216K, used 1671K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)\n      eden space 8192K,  20% used [0x00000000f9a00000, 0x00000000f9ba1c08, 0x00000000fa200000)\n      from space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)\n      to   space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)\n     tenured generation   total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)\n       the space 10240K,  40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000)\n     compacting perm gen  total 21248K, used 2938K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)\n       the space 21248K,  13% used [0x00000000fae00000, 0x00000000fb0de9e0, 0x00000000fb0dea00, 0x00000000fc2c0000)\n    No shared spaces configured.\n    ```\n### 3. 长期存活的对象将进入老年代\n* 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象放在新生代，那些对象放在老年代中\n* 为了能做到这一点，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数`-XX：MaxTenuringThreshold`设置。\n* 举例说明\n    ```java\n    /**\n     * 测试长期存活的对象进入老年代\n     *\n     * VM参数：\n     *      -verbose:gc -Xms20M  -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC\n     * -XX:MaxTenuringThreshold=1 可选\n     *\n     * @author songsy\n     * @date 2019/3/11 18:37\n     */\n    public class Jvm3 {\n    \n        private static final int _1KB = 1024;\n        private static final int _1MB = 1024 * _1KB;\n    \n        public static void testAllocation() {\n            byte [] allocation1,allocation2, allocation3;\n            allocation1 = new byte[_1MB / 4];\n            allocation2 = new byte[4 * _1MB];\n            allocation3 = new byte[4 * _1MB];\n            // 虽然此处赋值为null，但未进行Gc空间仍被占用，下一行代码会执行minor GC\n            allocation3 = null;\n            // 将MaxTenuringThreshold设为1，可以看出第二次Minor GC时，年轻代已经被清空，allocation1对象因为年龄符合MaxTenuringThreshold设置的值，因此进入老年代。\n            allocation3 = new byte[4 * _1MB];\n        }\n        public static void main(String[] args) {\n            testAllocation();\n        }\n    }\n    ```\n### 4. 动态对象年龄判定\n* 为了能更好的适应不同程序的内存状态，虚拟机并不是永远的要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升老年代的\n* 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。\n\n### 5. 空间分配担保\n* 内存分配是在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。\n* Parallel Scavenge收集器与其他收集器在空间分配担保上有一点差别, 正常是在Minor GC前进行检查, 而Parallel Scavenge收集器在Minor GC后也会进行检查。\n* 另外当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.csdn.net/v123411739/article/details/78941793 ","tags":["jvm"],"categories":["服务器"]},{"title":"JVM垃圾回收(二)垃圾回收器","url":"/2019/03/10/backend/java/jvm1/JVM垃圾回收(二)垃圾回收器/","content":"## 概述\n* 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。\n* Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的回收器可能会有很大差异，一般是提供参数供用户根据自己的应用特点和要求组合各个年代所使用的回收器\n* 这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图3-5所示，上半部分是新生代的回收器，下半部分是老年代的回收器\n\n![](/images/server/java/JVM/hotspot.png)\n\n### 1. Serial 收集器\n* Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。\n* 大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。\n* 新生代采用复制算法，老年代采用标记-整理算法。 \n* 虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。\n* 但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。\n\n![](/images/server/java/JVM/gcj1.jpg)\n\n### 2. Serial Old 收集器\n* Serial收集器的老年代版本，它同样是一个单线程收集器。\n* 它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。\n\n### 3. ParNew 收集器\n* ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。\n* 新生代采用复制算法，老年代采用标记-整理算法。 \n* 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。\n* 并行和并发概念补充：\n    * 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。\n    * 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。\n    \n![](/images/server/java/JVM/gcj2.jpg)\n\n### 4. Parallel Old收集器\n* Parallel Scavenge收集器的老年代版本。\n* 使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。\n\n\n### 5. Parallel Scavenge收集器\n* Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？\n* Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。\n```sql\n-XX:+UseParallelGC \n\n    使用Parallel收集器+ 老年代串行\n\n-XX:+UseParallelOldGC\n\n    使用Parallel收集器+ 老年代并行\n```\n* Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。\n* 新生代采用复制算法，老年代采用标记-整理算法。 \n\n![](/images/server/java/JVM/gcj3.jpg)\n### 6. CMS收集器\n\n* CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。\n* CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。\n* 从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：\n    * 初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 \n    * 并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。\n    * 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短\n    * 并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。\n    \n![](/images/server/java/JVM/gcj4.jpg)\n\n* 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：\n    * 对CPU资源敏感\n    * 无法处理浮动垃圾\n    * 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生\n### 7. G1收集器\n\n* G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.\n\n* 被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点\n    * G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。\n    * 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。\n    * 与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。\n    * 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。\n* G1收集器的运作大致分为以下几个步骤：\n    * 初始标记\n    * 并发标记\n    * 最终标记\n    * 筛选回收\n* G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html\n* https://blog.csdn.net/qq_34337272/article/details/82177383","tags":["jvm"],"categories":["服务器"]},{"title":"JVM垃圾回收(一)垃圾回收算法","url":"/2019/03/10/backend/java/jvm1/JVM垃圾回收(一)垃圾回收算法/","content":"## 概述\n* 猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。\n\n* 而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。\n \n\n## 判断对象是否存活的算法\n\n* 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧）\n\n### 1. 引用计数法\n* 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。\n\n* 一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。\n\n### 2. 可达性分析算法\n\n* 通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。\n\n![image](/images/server/java/JVM/gcroots.JPEG)\n\n* 上图中每个对象都存在引用链与GCRoots相连，表明对象还在，不能回收。有图中三个对象虽然互相引用，但是没有链接与GCRoots相连，则可判断它们是可回收的对象。\n    * 什么对象可以为`GCRoots`，\n        * 虚拟机栈中本地变量表引用的对象，局部变量\n        * 方法区中的类静态变量引用的对象及常量引用的对象\n        * 本地方法栈中JNI引用的对象\n    \n\n* 彻底死亡条件：\n  * 条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。\n  * 条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。\n* 引用\n    * 强引用`Object o = new Object()`\n        \n    * 软引用`SoftReference` 定义了软引用对象之后，GC可达的算法就切断与此对象的连接，那么下次垃圾回收的时候就会优化回收此对象\n        \n    * 弱引用\n    \n    * 虚引用\n\n## 垃圾回收算法\n\n### 1. 标记-清除算法\n\n![](/images/server/java/JVM/gc1.gif)\n\n* 该算法是最基础的收集算法，算法分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象\n\n* 之所以说它是最基础的算法是因为后续的算法都是基于这种思路并对其不足进行改进而得到的\n\n#### 缺点\n1. 效率不足\n2. 会产生大量不连续的内存碎片，碎片过多的话再分配一个较大对象时就无容身之地从而不得不提前触发另一次垃圾收集\n\n### 2. 复制算法\n\n![](/images/server/java/JVM/gc2.gif)\n\n* 为了解决效率问题，此算法把内存划分为相等大小的两个区域，每一只使用其中一个，回收过程中将存活的对象全部复制到另一个区域中，清空原区域。在年轻代中eden区和两个survivor区就是使用了此种算法。这种算法只复制存活的对象，成本较低，而且不会出现内存碎片问题\n\n* 现在的商业虚拟机都采用这种算法来回收新生代\n\n#### 缺点\n1. 费内存，需要2倍的内存空间\n\n### 3. 标记-整理算法\n\n![](/images/server/java/JVM/gc3.gif)\n\n* 该算法标记阶段和标记-清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。效率比“标记-清理”算法低，但不会产生内存碎片。\n\n### 4. 分代收集算法\n\n![](/images/server/java/JVM/gc4.jpg)\n\n* 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/aspirant/p/8662690.html\n* http://baijiahao.baidu.com/s?id=1565631804713416&wfr=spider&for=pc\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM运行时数据区域(六)方法区","url":"/2019/03/04/backend/java/jvm1/JVM运行时数据区域(六)方法区/","content":"## 概述\n* 方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。\n\n* 对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。\n\n* Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出\nOutOfMemoryError 异常。\n\n### 运行时常量池\n\n* 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\n* Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常* 量池中。\n\n* 运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。\n\n* 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常\n#### 1. String 类和常量池\n* 直接使用双引号声明出来的 String 对象会直接存储在常量池中。\n* 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。\n* 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。\n\n```java\n// 第一种方式是在常量池中拿对象\nString str1 = \"abcd\";\n// 第二种方式是直接在堆内存空间创建一个新的对象。 \nString str2 = new String(\"abcd\");\nSystem.out.println(str1==str2);//false\n``` \n\n\n#### 2. 8种基本类型的包装类和常量池\n* Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。\n* 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。\n```java\nInteger i1 = 33;\nInteger i2 = 33;\nSystem.out.println(i1 == i2);// 输出true\nInteger i11 = 333;\nInteger i22 = 333;\nSystem.out.println(i11 == i22);// 输出false\nDouble i3 = 1.2;\nDouble i4 = 1.2;\nSystem.out.println(i3 == i4);// 输出false\n```\n\n\n## 备注\n* 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。\n* JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。\n* JDK1.7 就开始“去永久代”的工作了。 1.7把字符串常量池从永久代中剥离出来，存放在堆空间中。\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM内存溢出异常(一)OutOfMemoryError","url":"/2019/03/04/backend/java/jvm1/JVM内存溢出异常(一)OutOfMemoryError/","content":"> 在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有可能发生OutOfMemoryError（OOM）异常的可能，下面将介绍这些运行时区域出现OOM的场景及解决方法\n\n## Java堆溢出\n* Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制之后就会产生内存溢出异常\n\n* 测试代码\n```java\n/**\n * Java堆内存异常测试\n *\n * VM参数：\n *      -Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError\n * 堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展\n * @author songsy\n * @date 2019/3/22 18:37\n */\npublic class Jvm4 {\n\n    public static void main(String[] args) {\n        List<Jvm4> list = new ArrayList<>();\n        while (true) {\n            list.add(new Jvm4());\n        }\n\n    }\n}\n```\n* 输出结果\n```sql\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to java_pid17684.hprof ...\nHeap dump file created [29356301 bytes in 0.114 secs]\nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space\n\tat java.util.Arrays.copyOf(Arrays.java:2245)\n\tat java.util.Arrays.copyOf(Arrays.java:2219)\n\tat java.util.ArrayList.grow(ArrayList.java:242)\n\tat java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216)\n\tat java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208)\n\tat java.util.ArrayList.add(ArrayList.java:440)\n\tat com.songsy.Jvm4.main(Jvm4.java:24)\n```\n* 我们可以在vm参数中配置`-XX:+HeapDumpOnOutOfMemoryError`参数，配置完成之后如果程序发生了`OutOfMemoryError`后会生成`堆转储快照`文件`java_pid17684.hprof`\n\n* 通过`JProfiler`打开此文件，发现都是`com.songsy.Jvm4.main`对象，原因是因为虚拟机限制了堆的最大空间(-Xmx20M)。当准备创建的对象需要的内存已经超过虚拟机堆所剩的空间。虚拟机会尝试通过`full GC`来回收内存，如果不行的话，就会抛出`OutOfMemoryError`\n\n\n![](/images/server/java/JVM/dump.jpg)\n\n## 虚拟机栈和本地方法栈溢出\n* 由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。\n* 关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：\n    * 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出`StackOverflowError`异常。\n    * 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。\n* 这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。\n* 测试代码：  \n```java\n/**\n * 测试 StackOverflowError异常\n * VM Args：-Xss128k\n * @author songsy\n * @date 2019/3/22 16:31\n */\npublic class JavaVMStackSOF {\n\n    private int stackLength = 1;\n\n    public void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n    public static void main(String[] args) throws Throwable {\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try {\n            oom.stackLeak();\n        } catch (Throwable e) {\n            // 抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。\n            System.out.println(\"stack length:\" + oom.stackLength);\n            throw e;\n        }\n    }\n}\n```\n\n* 输出结果\n\n```java\nstack length:11424\nException in thread \"main\" java.lang.StackOverflowError\n\tat com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:13)\n\tat com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:14)\n\tat com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:14)\n```\n* 测试代码2：\n```java\n/**\n * 测试 StackOverflowError异常\n * VM Args：-Xss128k\n * @author songsy\n * @date 2019/3/22 17:15\n */\npublic class JavaVMStackSOF1 {\n\n    private int stackLength = 1;\n\n    public void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n    public static void main(String[] args) {\n        JavaVMStackSOF1 oom = new JavaVMStackSOF1();\n        long e0 = 1;\n        long e1 = 1;\n        long e2 = 1;\n        long e3 = 1;\n        long e4 = 1;\n        long e5 = 1;\n        long e6 = 1;\n        long e7 = 1;\n        long e8 = 1;\n        long e9 = 1;\n        long q0 = 1;\n        long q1 = 1;\n        long q2 = 1;\n        long q3 = 1;\n        long q4 = 1;\n        long q5 = 1;\n        long q6 = 1;\n        long q7 = 1;\n        long q8 = 1;\n        long q9 = 1;\n        long r0 = 1;\n        long r1 = 1;\n        long r2 = 1;\n        long r3 = 1;\n        long r4 = 1;\n        long r5 = 1;\n        long r6 = 1;\n        long r7 = 1;\n        long r8 = 1;\n        long r9 = 1;\n        long t0 = 1;\n        long t1 = 1;\n        long t2 = 1;\n        long t3 = 1;\n        long t4 = 1;\n        long t5 = 1;\n        long t6 = 1;\n        long t7 = 1;\n        long t8 = 1;\n        long t9 = 1;\n        long y0 = 1;\n        long y1 = 1;\n        long y2 = 1;\n        long y3 = 1;\n        long y4 = 1;\n        long y5 = 1;\n        long y6 = 1;\n        long y7 = 1;\n        long y8 = 1;\n        long y9 = 1;\n        long u0 = 1;\n        long u1 = 1;\n        long u2 = 1;\n        long u3 = 1;\n        long u4 = 1;\n        long u5 = 1;\n        long u6 = 1;\n        long u7 = 1;\n        long u8 = 1;\n        long u9 = 1;\n        long i0 = 1;\n        long i1 = 1;\n        long i2 = 1;\n        long i3 = 1;\n        long i4 = 1;\n        long i5 = 1;\n        long i6 = 1;\n        long i7 = 1;\n        long i8 = 1;\n        long i9 = 1;\n        long o0 = 1;\n        long o1 = 1;\n        long o2 = 1;\n        long o3 = 1;\n        long o4 = 1;\n        long o5 = 1;\n        long o6 = 1;\n        long o7 = 1;\n        long o8 = 1;\n        long o9 = 1;\n        long p0 = 1;\n        long p1 = 1;\n        long p2 = 1;\n        long p3 = 1;\n        long p4 = 1;\n        long p5 = 1;\n        long p6 = 1;\n        long p7 = 1;\n        long p8 = 1;\n        long p9 = 1;\n        long a0 = 1;\n        long a1 = 1;\n        long a2 = 1;\n        long a3 = 1;\n        long a4 = 1;\n        long a5 = 1;\n        long a6 = 1;\n        long a7 = 1;\n        long a8 = 1;\n        long a9 = 1;\n        long s0 = 1;\n        long s1 = 1;\n        long s2 = 1;\n        long s3 = 1;\n        long s4 = 1;\n        long s5 = 1;\n        long s6 = 1;\n        long s7 = 1;\n        long s8 = 1;\n        long s9 = 1;\n        long d0 = 1;\n        long d1 = 1;\n        long d2 = 1;\n        long d3 = 1;\n        long d4 = 1;\n        long d5 = 1;\n        long d6 = 1;\n        long d7 = 1;\n        long d8 = 1;\n        long d9 = 1;\n        long f0 = 1;\n        long f1 = 1;\n        long f2 = 1;\n        long f3 = 1;\n        long f4 = 1;\n        long f5 = 1;\n        long f6 = 1;\n        long f7 = 1;\n        long f8 = 1;\n        long f9 = 1;\n        long g0 = 1;\n        long g1 = 1;\n        long g2 = 1;\n        long g3 = 1;\n        long g4 = 1;\n        long g5 = 1;\n        long g6 = 1;\n        long g7 = 1;\n        long g8 = 1;\n        long g9 = 1;\n        long h0 = 1;\n        long h1 = 1;\n        long h2 = 1;\n        long h3 = 1;\n        long h4 = 1;\n        long h5 = 1;\n        long h6 = 1;\n        long h7 = 1;\n        long h8 = 1;\n        long h9 = 1;\n        long j0 = 1;\n        long j1 = 1;\n        long j2 = 1;\n        long j3 = 1;\n        long j4 = 1;\n        long j5 = 1;\n        long j6 = 1;\n        long j7 = 1;\n        long j8 = 1;\n        long j9 = 1;\n        long k0 = 1;\n        long k1 = 1;\n        long k2 = 1;\n        long k3 = 1;\n        long k4 = 1;\n        long k5 = 1;\n        long k6 = 1;\n        long k7 = 1;\n        long k8 = 1;\n        long k9 = 1;\n        long l0 = 1;\n        long l1 = 1;\n        long l2 = 1;\n        long l3 = 1;\n        long l4 = 1;\n        long l5 = 1;\n        long l6 = 1;\n        long l7 = 1;\n        long l8 = 1;\n        long l9 = 1;\n        long z0 = 1;\n        long z1 = 1;\n        long z2 = 1;\n        long z3 = 1;\n        long z4 = 1;\n        long z5 = 1;\n        long z6 = 1;\n        long z7 = 1;\n        long z8 = 1;\n        long z9 = 1;\n        long c0 = 1;\n        long c1 = 1;\n        long c2 = 1;\n        long c3 = 1;\n        long c4 = 1;\n        long c5 = 1;\n        long c6 = 1;\n        long c7 = 1;\n        long c8 = 1;\n        long c9 = 1;\n        long v0 = 1;\n        long v1 = 1;\n        long v2 = 1;\n        long v3 = 1;\n        long v4 = 1;\n        long v5 = 1;\n        long v6 = 1;\n        long v7 = 1;\n        long v8 = 1;\n        long v9 = 1;\n        long b0 = 1;\n        long b1 = 1;\n        long b2 = 1;\n        long b3 = 1;\n        long b4 = 1;\n        long b5 = 1;\n        long b6 = 1;\n        long b7 = 1;\n        long b8 = 1;\n        long b9 = 1;\n        long n0 = 1;\n        long n1 = 1;\n        long n2 = 1;\n        long n3 = 1;\n        long n4 = 1;\n        long n5 = 1;\n        long n6 = 1;\n        long n7 = 1;\n        long n8 = 1;\n        long n9 = 1;\n        long m0 = 1;\n        long m1 = 1;\n        long m2 = 1;\n        long m3 = 1;\n        long m4 = 1;\n        long m5 = 1;\n        long m6 = 1;\n        long m7 = 1;\n        long m8 = 1;\n        long m9 = 1;\n        long qq0 = 1;\n        long qq1 = 1;\n        long qq2 = 1;\n        long qq3 = 1;\n        long qq4 = 1;\n        long qq5 = 1;\n        long qq6 = 1;\n        long qq7 = 1;\n        long qq8 = 1;\n        long qq9 = 1;\n        long ww0 = 1;\n        long ww1 = 1;\n        long ww2 = 1;\n        long ww3 = 1;\n        long ww4 = 1;\n        long ww5 = 1;\n        long ww6 = 1;\n        long ww7 = 1;\n        long ww8 = 1;\n        long ww9 = 1;\n        try {\n            oom.stackLeak();\n        } catch (Throwable e) {\n            System.out.println(\"stack length:\" + oom.stackLength);\n            throw e;\n        }\n    }\n}\n```\n\n* 实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。\n\n* 如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常，如代码清单2-5所示。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。\n\n* 其实原因不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。\n\n### java.lang.OutOfMemoryError： unable to create new native thread\n\n* 线上出现了这个问题导致服务直接挂，查看`jstack.log`发现大部分是名为`pool-253-thread-1`的线程，怀疑是线程池使用不当的问题\n\n* 先使用`ps -ef | grep java` 查看`java`进程的`pid`，得到`pid`之后`cat /proc/27653/status`查看`java`进程状态，`Threads:        917`线程数有917条\n\n```java\n[ops@sh-123 ~]$ cat /proc/27653/status\nName:   java\nUmask:  0022\nState:  S (sleeping)\nTgid:   27653\nNgid:   0\nPid:    27653\nPPid:   27652\nTracerPid:      0\nUid:    1001    1001    1001    1001\nGid:    1001    1001    1001    1001\nFDSize: 128\nGroups: 1001 \nVmPeak:  6888664 kB\nVmSize:  6888660 kB\nVmLck:         0 kB\nVmPin:         0 kB\nVmHWM:   1858868 kB\nVmRSS:   1818044 kB\nRssAnon:         1803264 kB\nRssFile:           14780 kB\nRssShmem:              0 kB\nVmData:  6717104 kB\nVmStk:       132 kB\nVmExe:         4 kB\nVmLib:     18780 kB\nVmPTE:      5744 kB\nVmSwap:        0 kB\nThreads:        917\nSigQ:   0/31215\nSigPnd: 0000000000000000\nShdPnd: 0000000000000000\nSigBlk: 0000000000000000\nSigIgn: 0000000000000002\nSigCgt: 2000000181005ccd\nCapInh: 0000000000000000\nCapPrm: 0000000000000000\nCapEff: 0000000000000000\nCapBnd: 0000001fffffffff\nCapAmb: 0000000000000000\nSeccomp:        0\nCpus_allowed:   f\nCpus_allowed_list:      0-3\nMems_allowed:   00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001\nMems_allowed_list:      0\nvoluntary_ctxt_switches:        5\nnonvoluntary_ctxt_switches:     1\n```\n\n* 再查看系统用户的最大进程数，发现`java`的进程数已超过系统的最大进程数\n    * `ulimit`值参数值大小的设置很重要，`root`的`ulimit`默认值是`65536`，普通用户的`ulimit`值默认是`1024`，当进程数过多的时候甚至连`ssh`都成问题。`max user processes`，用户最大进程数。\n    * 用`ulimit -a`命令查看`root`用户值的大小\n    ```java\n    [ops@sh-123 ~]$ ulimit -a\n    core file size          (blocks, -c) 0\n    data seg size           (kbytes, -d) unlimited\n    scheduling priority             (-e) 0\n    file size               (blocks, -f) unlimited\n    pending signals                 (-i) 31215\n    max locked memory       (kbytes, -l) 64\n    max memory size         (kbytes, -m) unlimited\n    open files                      (-n) 102400\n    pipe size            (512 bytes, -p) 8\n    POSIX message queues     (bytes, -q) 819200\n    real-time priority              (-r) 0\n    stack size              (kbytes, -s) 8192\n    cpu time               (seconds, -t) unlimited\n    max user processes              (-u) 4096\n    virtual memory          (kbytes, -v) unlimited\n    file locks                      (-x) unlimited\n    ```\n\n* 最后排查项目代码发现是`Executors.newFixedThreadPool()`出现的问题\n\n## 方法区和运行时常量池溢出\n* 由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。\n\n* `String.intern()`是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此`String`对象的字符串，则返回代表池中这个字符串的`String`对象；否则，将此`String`对象包含的字符串添加到常量池中，并且返回此`String`对象的引用。在`JDK 1.6`及之前的版本中，由于常量池分配在永久代内，我们可以通过`-XX:PermSize`和`-XX:MaxPermSize`限制方法区大小，从而间接限制其中常量池的容量，如代码清单2-6所示。\n\n* 测试代码\n```java\n/**\n * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M\n * @author songsy\n * @date 2019/3/22 17:31\n */\npublic class RuntimeConstantPoolOOM {\n\n    public static void main(String[] args) {\n        // 使用List保持着常量池引用，避免Full GC回收常量池行为\n        List<String> list = new ArrayList<String>();\n        // 10MB的PermSize在integer范围内足够产生OOM了\n        int i = 0;\n        while (true) {\n            list.add(String.valueOf(i++).intern());\n            System.out.println(String.valueOf(i++).intern());\n        }\n    }\n}\n```\n* 输出结果\n```java\nException in thread \"main\" java.lang.OutOfMemoryError: PermGen space  \nat java.lang.String.intern(Native Method)  \nat org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18) \n```\n* 从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。\n\n* 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。在代码清单2-8中，笔者借助CGLib直接操作字节码运行时生成了大量的动态类。\n\n* 值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中：当前的很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。另外，JVM上的动态语言（例如Groovy等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与代码清单2-8相似的溢出场景。\n\n* 代码清单2-8　借助CGLib使方法区出现内存溢出异常\n\n```java\n/**\n * VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M\n * @author songsy\n * @date 2019/3/22 17:45\n */\npublic class JavaMethodAreaOOM {\n\n    public static void main(String[] args) {\n        while (true) {\n            Enhancer enhancer = new Enhancer();\n            enhancer.setSuperclass(OOMObject.class);\n            enhancer.setUseCache(false);\n            enhancer.setCallback(new MethodInterceptor() {\n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n                    return proxy.invokeSuper(obj, args);\n                }\n            });\n            enhancer.create();\n        }\n    }\n\n    static class OOMObject {\n\n    }\n\n}\n```\n* 输出结果\n```java\nCaused by: java.lang.OutOfMemoryError: PermGen space  \nat java.lang.ClassLoader.defineClass1(Native Method)  \nat java.lang.ClassLoader.defineClassCond(ClassLoader.java:632)  \nat java.lang.ClassLoader.defineClass(ClassLoader.java:616)  \n... 8 more \n```\n* 方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。\n\n## 本机直接内存溢出\n* 直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。\n\n* 特点\n    * 本机直接内存的分配不会受到Java 堆大小的限制，受到本机总内存大小限制\n    * 直接内存也可以由 -XX:MaxDirectMemorySize 指定\n    * 直接内存申请空间耗费更高的性能\n    * 直接内存IO读写的性能要优于普通的堆内存\n* 当我们的需要频繁访问大的内存而不是申请和释放空间时，通过使用直接内存可以提高性能。\n  \n* 直接内存溢出测试，测试代码如下，运行时添加参数`-Xmx20M -XX:MaxDirectMemorySize=10M` 设置降低直接内存的空间来加快异常的抛出\n\n* 测试代码：\n```java\n/**\n * 本机直接内存溢出\n * VM args:-Xmx20M -XX:MaxDirectMemorySize=10M\n * @author songsy\n * @date 2019/3/22 18:08\n */\npublic class DirectMemoryOOM {\n\n    private static final int _1MB = 1024 * 1024;\n\n    public static void main(String[] args) throws Exception {\n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        unsafeField.setAccessible(true);\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true) {\n            unsafe.allocateMemory(_1MB);\n        }\n    }\n}\n```\n* 输出结果\n```java\nException in thread \"main\" java.lang.OutOfMemoryError\n\tat sun.misc.Unsafe.allocateMemory(Native Method)\n\tat com.songsy.DirectMemoryOOM.main(DirectMemoryOOM.java:22)\n```\n* 由DirectMemory导致的内存溢出，一个明显的特征就是再Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接的使用了NIO，那就可以考虑检查一下是不是这方面的原因。\n\n## 内存溢出及内存泄漏\n\n### 1、内存溢出 out of memory\n\n* 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出\n\n#### 1.1 方法区溢出 out of memory: PermGen space\n\n#### 1.2 本机直接内存溢出\n\n\n### 2、内存泄露 memory leak\n \n* 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光\n\n* memory leak会最终会导致out of memory！\n\n* 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 \n\n* 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. \n\n* 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到\n\n\n### 3、引起内存溢出的原因\n* 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；\n* 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；\n* 代码中存在死循环或循环产生过多重复的对象实体；\n* 使用的第三方软件中的BUG；\n* 启动参数内存值设定的过小；\n\n### 4、内存溢出的解决方案\n* 修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)\n* 检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。\n* 对代码进行走查和分析，找出可能发生内存溢出的位置。\n\n## 其他\n> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k\n* -Xmx3550m：设置JVM最大可用内存为3550M。\n* -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。\n* -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。\n* -Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/Sharley/p/5285045.html\n* https://blog.csdn.net/u012552052/article/details/44204735\n* https://blog.csdn.net/sells2012/article/details/18656263","tags":["jvm"],"categories":["服务器"]},{"title":"JVM运行时数据区域(五)堆","url":"/2019/03/04/backend/java/jvm1/JVM运行时数据区域(五)堆/","content":"## 概述\n* 堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。\n\n* 对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。\n\n* Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。\n\n* 根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。\n## 解析\n\n* 所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代和永久代，\n\n### 1. 新生代\n\n![](/images/server/java/JVM/eden.jpg)\n\n* 新创建的对象都是用新生代分配内存\n* 新生代又被进一步划分为Eden和Survivor区，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区，而Survivor由FromSpace和ToSpace组成。\n    * Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。\n    * ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。\n    * ServivorTo：保留了一次MinorGC过程中的幸存者。\n \n* MinorGC的过程：MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。\n\n* 新生代分为Eden、FromSpace、ToSpace是为了尽量让对象在新生代MinorGC，如果到了老年代之后MajorGC执行时间长\n\n### 2. 老年代\n* 老年代用于存放经过多次Minor GC之后依然存活的对象。\n\n* 老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。\n\n* MajorGC采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。\n\n* 当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。\n\n### 3. 永久代\n* 指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域. 它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。\n\n*  在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。\n\n* 空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制.\n\n* 采用元空间而不用永久代的几点原因：\n    * 1、为了解决永久代的OOM问题，元数据和class对象存在永久代中，容易出现性能问题和内存溢出。\n    * 2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出（因为堆空间有限，此消彼长）。\n    * 3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。\n    * 4、Oracle 可能会将HotSpot 与 JRockit 合二为一。\n\n![](/images/server/java/JVM/gc-generation.gif)\n\n* -Xmx20M -XX:MaxHeapSize简写，表示设置堆容量的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免堆自动扩展，减少程序运行时的垃圾回收次数，从而提供性能。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://www.cnblogs.com/Sharley/p/5285045.html\n* https://www.cnblogs.com/ygj0930/p/6522828.html\n\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM运行时数据区域(四)本地方法栈","url":"/2019/03/04/backend/java/jvm1/JVM运行时数据区域(四)本地方法栈/","content":"## 概述\n* 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。\n\n## 解析\n\n## Native Method\n* 简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern \"C\"告知C＋＋编译器去调用一个C的函数\n\n* 例如 `Object.java` 类下就有很多`Native Method` \n\n```java\npublic final native Class<?> getClass();\n```\n\n* 本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。\n\n* 为什么要使用Native Method\n    * 与java环境外交互：有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。\n    * 与操作系统交互：JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。\n    * Sun's Java： Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。\n\n## 栈溢出(StackOverflowError)\n\n* 栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口灯信息。局部变量表又包含基本数据类型，对象引用类型（局部变量表编译器完成，运行期间不会变化）\n\n* 所以我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度。那么最有可能的就是方法递归调用产生这种结果。\n\n* 我们需要使用参数 `-Xss` 去调整`JVM`栈的大小\n\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.csdn.net/qq_28885149/article/details/52672475\n\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM运行时数据区域(三)Java虚拟机栈","url":"/2019/03/04/backend/java/jvm1/JVM运行时数据区域(三)Java虚拟机栈/","content":"## 何为虚拟机栈\n* 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。\n \n* 与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。\n\n## 解析\n\n* 执行引擎运行的所有字节码指令只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示： \n\n![](/images/server/java/JVM/stackFrame.jpg)\n\n### 栈帧数据结构\n* 每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中\n\n* 我们先来理解一下虚拟机是如何执行一个方法的，这样我们才能理解为什么栈帧需要这些部分，这些部分分别提供了什么功能。首先我们的方法被编译成了字节码，并生成了可执行的命令。通过程序计数器，虚拟机会一行一行的执行命令，直到进入一个新的方法入口，对应虚拟机栈也就是新的栈帧入栈，当前栈帧改变，又或者遇到返回指令或出现异常结束了方法，对应虚拟机也就是出栈。\n\n\n#### 1、局部变量表\n* 是一片逻辑连续的内存空间，最小单位是Slot，用来存放方法参数和方法内部定义的局部变量\n* 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\n#### 2、操作数栈\n* 每个栈帧都包含一个被叫做操作数栈的后进先出的栈。叫操作栈，或者操作数栈。\n\n* 栈桢刚创建时，里面的操作数栈是空的。\n\n* Java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据、实例的字段等数据入栈。\n\n* 同时也有指令来支持出栈操作。\n \n* 向其他方法传参的参数，也存在操作数栈中。\n\n* 其他方法返回的结果，返回时存在操作数栈中。\n\n#### 3、动态链接\n* 一个方法调用另一个方法，或者一个类使用另一个类的成员变量时，总得知道被调用者的名字吧？(你可以不认识它本身，但调用它就需要知道他的名字)。符号引用就相当于名字，这些被调用者的名字就存放在Java字节码文件里。名字是知道了，但是Java真正运行起来的时候，真的能靠这个名字（符号引用）就能找到相应的类和方法吗？需要解析成相应的直接引用，利用直接引用来准确地找到。\n\n* 举个例子，就相当于我在0X0300H这个地址存入了一个数526，为了方便编程，我把这个给这个地址起了个别名叫A, 以后我编程的时候(运行之前)可以用别名A来暗示访问这个空间的数据，但其实程序运行起来后，实质上还是去寻找0X0300H这片空间来获取526这个数据的。\n\n* 这样的符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。\n#### 4、方法返回地址\n\n* 返回一个值给调用它的方法，方法正常完成发生在一个方法执行过程 中遇到了方法返回的字节码指令（§2.11.8）的时候，使用哪种返回指令取决于方法返回值的数 据类型（如果有返回值的话）。\n\n#### 5、附加信息\n\n\n## 参考转载\n\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.csdn.net/ychenfeng/article/details/77247807\n* https://blog.csdn.net/u014296316/article/details/82668670 \n\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM运行时数据区域(二)程序计数器","url":"/2019/03/04/backend/java/jvm1/JVM运行时数据区域(二)程序计数器/","content":"## 概述\n程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的`行号指示器`，在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成\n\n\n## 特点\n* 线程私有的\n* 是java虚拟机规范里面， 唯一 一个 没有规定任何 `OutOfMemoryError` 情况的区域\n* 生命周期随着线程，线程启动而产生，线程结束而消亡\n\n\n## 作用\n* 程序计数器，可以看做是当前线程执行的字节码的 行号指示器 ，这句话；要理解这句话，需要先知道字节码文件长什么样子，看下面的代码\n```java\n// java 文件被翻译为字节码的时候，字节码大概类似于下面的样子\npublic void haha(){\n// 原来的 haha 方法内部的 java 代码，被翻译为下面的类似于汇编语言的指令\n    0 xxxx ....\n    2 xxxx ....\n    4 xx  ...\n    5 xxx ...\n}\n```\n* 上面左边的 0、2、4、5 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的\n\n* 理解了程序计数器，就好理解它的这些特点了；我们都知道，Java是支持多线程的，当CPU执行权从 A 线程，转移到 B 线程的时候，JVM就要暂时挂起线程 A ，去执行线程 B ；当线程 A 再次得到CPU执行权的时候，又会挂起B线程，继续执行 A 线程 ；\n\n* 我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？\n\n* 答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）；\n\n* 那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，`程序计数器的内存空间是线程私有的` ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！\n\n* 那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被`创建`；\n\n* 程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，`jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域`；\n\n* 当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 ；\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://blog.csdn.net/youngyouth/article/details/79868299\n\n\n\n","tags":["jvm"],"categories":["服务器"]},{"title":"JVM运行时数据区域(一)介绍","url":"/2019/03/04/backend/java/jvm1/JVM运行时数据区域(一)介绍/","content":"## 前言\n* Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图\n\n> 1.7版本\n\n![](/images/server/java/JVM/jvm1.png)\n\n* Java 虚拟机的内存结构分为两部分\n    * 线程共享的（数据）\n        * 方法区\n        * Java 堆\n        * 直接内存(非运行时数据区的一部分)\n    * 线程私有的（指令）\n        * 虚拟机栈\n        * 本地方法栈\n        * 程序计数器\n\n> 1.8版本\n\n![](/images/server/java/JVM/18.jpg)\n\n* 1.8同1.7比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。\n\n## 运行时数据区域\n1. 程序计数器：指向当前线程正在执行的字节码指令。线程私有的。\n2. 虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈\n3. 本地方法栈：调用本地native的内存模型\n4. 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据\n5. 堆（Heap）：Java对象存储的地方\n\n## 参考转载\n* 周志明版  《深入理解Java虚拟机》\n* https://segmentfault.com/a/1190000014395186\n\n\n\n","tags":["jvm"],"categories":["服务器"]},{"title":"Mybatis源码(二十二)使用拦截器Interceptor完成分页","url":"/2018/12/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页/","content":"## 前言\n只要有列表就会有分页功能，利用Mybatis拦截器Interceptor可以十分方便的完成分页功能\n\n## 思路\n在执行查询sql之前的时候只要添加`limit`关键字，即可完成分页，除了分页之外需要`count(*)`获取数据总数，然后通过页码得到页数\n\n## 实现\n* `Page.java` 分页对象\n```java\npublic class Page<T> {\n    private int end;                                        // 当前页尾条记录位置\n    private int limit;                                      // 每页记录数\n    private int page;                                       // 当前页\n    private long total;                                     // 总记录数\n    private String sortName;                                // 排序列\n    private String sortOrder;                               // 排序方式\n    private Map<String, Object> params = new HashMap<>();   // 请求参数\n    private List<String> columns = Lists.newArrayList();    // 查询出来的参数\n    private List<T> rows = new ArrayList<>();               // 记录\n\n    /**\n     * 限制分页长度\n     * limit：0 不限制大小\n     * @param limit\n     */\n    public Page(int limit) {\n        this.limit = limit;\n    }\n\n    public Page(HttpServletRequest request) {\n        String param = null;\n        String value = null;\n\n        param = \"pageIndex\";\n        value = request.getParameter(param);\n        if (value != null && value.length() > 0) {\n            this.page = Integer.parseInt(value);\n        } else {\n            this.page = 1;\n        }\n\n        param = \"limit\";\n        value = request.getParameter(param);\n        if (value != null && value.length() > 0) {\n            this.limit = Integer.parseInt(value);\n            if (this.limit > 15) {\n                this.limit = 15;\n            }\n        } else {\n            this.limit = 15;\n        }\n\n        param = \"sortName\";\n        value = request.getParameter(param);\n        if (value != null && value.length() > 0) {\n            this.sortName = CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, value);\n        }\n\n        param = \"sortOrder\";\n        value = request.getParameter(param);\n        if (value != null && value.length() > 0) {\n            this.sortOrder = value;\n        } else {\n            this.sortOrder = \"asc\";\n        }\n\n        Map<String, String[]> paramMap = request.getParameterMap();\n        for (String key : paramMap.keySet()) {\n            if (key.startsWith(\"s_\")) {\n                String vkey = key.substring(2);\n                String[] _params = paramMap.get(key);\n                if (_params.length > 0 && StringUtils.isNotEmpty(_params[0])) {\n                    getParams().put(vkey, StringUtils.join(_params, \">\").trim());\n                }\n            }\n        }\n    }\n\n    /**\n     * 当前页首条记录位置\n     *\n     * @return\n     */\n    public int getStart() {\n        if (page == 0) {\n            return 0;\n        }\n        return (page - 1) * limit;\n    }\n\n    /**\n     * 总页数\n     *\n     * @return\n     */\n    public int getTotalPage() {\n        if (limit == 0) {\n            return 0;\n        }\n        return (int) Math.ceil(total / Double.valueOf(limit));\n    }\n\n    /**\n     * 必须和数据库字段一致\n     *\n     * @param sortName\n     */\n    public void setSortName(String sortName) {\n        this.sortName = sortName;\n    }\n\n    /**\n     * 设置默认排序方式\n     *\n     * @param sortName  需要排序的表字段，数据库字段\n     * @param sortOrder\n     */\n    public void sortDefault(String sortName, String sortOrder) {\n        if (org.apache.commons.lang3.StringUtils.isEmpty(getSortName()) || org.apache.commons.lang3.StringUtils.isEmpty(getSortOrder())) {\n            setSortName(sortName);\n            setSortOrder(sortOrder);\n        }\n    }\n\n    public String getSortName() {\n        return sortName;\n    }\n\n    public String getSortOrder() {\n        return sortOrder;\n    }\n\n    public void setSortOrder(String sortOrder) {\n        this.sortOrder = sortOrder;\n    }\n\n    public Map<String, Object> getParams() {\n        return params;\n    }\n\n    public void setParams(Map<String, Object> params) {\n        this.params = params;\n    }\n\n    public void setParams(String key, Object value) {\n        Assert.notNull(key, \"key must be not null\");\n        Assert.notNull(value, \"value must be not null \");\n        this.params.put(key, value);\n    }\n\n    public List<T> getRows() {\n        return rows;\n    }\n\n    public void setRows(List<T> rows) {\n        this.rows = rows;\n    }\n\n    public List<String> getColumns() {\n        return columns;\n    }\n\n    public void setColumns(List<String> columns) {\n        this.columns = columns;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public void setEnd(int end) {\n        this.end = end;\n    }\n\n    public int getLimit() {\n        return limit;\n    }\n\n    public void setLimit(int limit) {\n        this.limit = limit;\n    }\n\n    public int getPage() {\n        return page;\n    }\n\n    public void setPage(int page) {\n        this.page = page;\n    }\n\n    public long getTotal() {\n        return total;\n    }\n\n    public void setTotal(long total) {\n        this.total = total;\n    }\n}\n```\n\n\n* `PageInterceptor.java` 拦截器，此类`intercept` 方法是完成分页实现方法\n```java\n/**\n * mybatis拦截器，实现接口分页，拦截Executor接口的query方法\n */\n@Component\n@Intercepts({ @Signature(type = Executor.class, method = \"query\", args = { MappedStatement.class, Object.class,\n        RowBounds.class, ResultHandler.class }) })\npublic class PageInterceptor implements Interceptor {\n    private static Logger logger = LoggerFactory.getLogger(PageInterceptor.class);\n\n    static int MAPPED_STATEMENT_INDEX = 0;\n    static int PARAMETER_INDEX = 1;\n    static int ROWBOUNDS_INDEX = 2;\n    static int RESULT_HANDLER_INDEX = 3;\n\n    // 需要拦截的ID(正则匹配)\n    private static final String DEFAULT_PAGE_SQL_ID = \".*Page$\";\n\n\n    /**\n     * setProperties方法是用于在Mybatis配置文件中指定一些属性的。\n     * @param properties\n     */\n    @Override\n    public void setProperties(Properties properties) {\n\n    }\n\n    /**\n     * 拦截器用于封装目标对象\n     * 在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象\n     * @param o\n     * @return\n     */\n    @Override\n    public Object plugin(Object o) {\n        if (Executor.class.isAssignableFrom(o.getClass())) {\n            // 在这里返回新的 PageExecutor，用于装饰原Executor\n            return Plugin.wrap(new PageExecutor((Executor) o), this);\n        }\n        return Plugin.wrap(o, this);\n    }\n\n    /**\n     * 在这里完成分页及排序操作得到 新的BoundSql 然后执行查询\n     * @param invocation\n     * @return\n     * @throws Throwable\n     */\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        final Object[] queryArgs = invocation.getArgs();\n        // MappedStatement对象对应Mapper配置文件中的一个select/update/insert/delete节点，主要描述的是一条SQL语句\n        final MappedStatement mappedStatement = (MappedStatement) queryArgs[MAPPED_STATEMENT_INDEX];\n        // 获取查询参数\n        final Object parameterObject = queryArgs[PARAMETER_INDEX];\n        BoundSql boundSql = mappedStatement.getBoundSql(parameterObject);\n        // 拦截以Page结尾的查询方法\n        if (mappedStatement.getId().matches(DEFAULT_PAGE_SQL_ID)) {\n            if (parameterObject == null) {\n                throw new NullPointerException(\"parameterObject is null!\");\n            } else {\n                // 如果查询参数是Page对象\n                if (parameterObject instanceof Page<?>) {\n                    Page<?> page = (Page<?>) parameterObject;\n                    // 执行总记录数查询\n                    setTotalRecord(page, mappedStatement, boundSql);\n                    // 拼接排序sql\n                    String orderSql = getOrderSql(boundSql.getSql(), page);\n                    // 拼接分页sql\n                    String pageSql = getPageSql(orderSql, page);\n                    logger.debug(\"page sql :  {} \", pageSql);\n                    BoundSql newBoundSql = copyFromBoundSql(mappedStatement, boundSql, pageSql);\n                    MappedStatement newMappedStatement = copyFromMappedStatement(mappedStatement,\n                            new BoundSqlSqlSource(newBoundSql));\n                    queryArgs[ROWBOUNDS_INDEX] = new RowBounds(RowBounds.NO_ROW_OFFSET, RowBounds.NO_ROW_LIMIT);\n                    queryArgs[MAPPED_STATEMENT_INDEX] = newMappedStatement;\n                }\n            }\n        }\n        return invocation.proceed();\n    }\n\n    /**\n     * 得到新的 BoundSql\n     * @param ms\n     * @param boundSql\n     * @param sql\n     * @return\n     */\n    public static BoundSql copyFromBoundSql(MappedStatement ms, BoundSql boundSql, String sql) {\n        BoundSql newBoundSql = new BoundSql(ms.getConfiguration(), sql, boundSql.getParameterMappings(),\n                boundSql.getParameterObject());\n        for (ParameterMapping mapping : boundSql.getParameterMappings()) {\n            String prop = mapping.getProperty();\n            if (boundSql.hasAdditionalParameter(prop)) {\n                newBoundSql.setAdditionalParameter(prop, boundSql.getAdditionalParameter(prop));\n            }\n        }\n        return newBoundSql;\n    }\n\n    /**\n     * 得到新的 MappedStatement\n     * @param ms\n     * @param newSqlSource\n     * @return\n     */\n    private static MappedStatement copyFromMappedStatement(MappedStatement ms, SqlSource newSqlSource) {\n        MappedStatement.Builder builder = new MappedStatement.Builder(ms.getConfiguration(), ms.getId(), newSqlSource,\n                ms.getSqlCommandType());\n\n        builder.resource(ms.getResource());\n        builder.fetchSize(ms.getFetchSize());\n        builder.statementType(ms.getStatementType());\n        builder.keyGenerator(ms.getKeyGenerator());\n        String[] keyProperties = ms.getKeyProperties();\n        builder.keyProperty(keyProperties == null ? null : keyProperties[0]);\n        builder.timeout(ms.getTimeout());\n        builder.parameterMap(ms.getParameterMap());\n        builder.resultMaps(ms.getResultMaps());\n        builder.resultSetType(ms.getResultSetType());\n        builder.cache(ms.getCache());\n        builder.flushCacheRequired(ms.isFlushCacheRequired());\n        builder.useCache(ms.isUseCache());\n\n        return builder.build();\n    }\n\n    public static class BoundSqlSqlSource implements SqlSource {\n        BoundSql boundSql;\n\n        public BoundSqlSqlSource(BoundSql boundSql) {\n            this.boundSql = boundSql;\n        }\n\n        public BoundSql getBoundSql(Object parameterObject) {\n            return boundSql;\n        }\n    }\n\n    /**\n     * 查询数据总数\n     * @param page\n     * @param mappedStatement\n     * @param boundSql\n     */\n    private void setTotalRecord(Page<?> page, MappedStatement mappedStatement, BoundSql boundSql) throws Throwable {\n        String sql = getCountSql(boundSql.getSql());\n        List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n        BoundSql countBoundSql = new BoundSql(mappedStatement.getConfiguration(), sql, parameterMappings, page);\n        ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, page, countBoundSql);\n        Connection con = mappedStatement.getConfiguration().getEnvironment().getDataSource().getConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            int total = 0;\n            stmt = con.prepareStatement(sql);\n            parameterHandler.setParameters(stmt);\n            rs = stmt.executeQuery();\n            if (rs.next()) {\n                total = rs.getInt(1);\n            }\n            page.setTotal(total);\n            logger.debug(\"page count sql   : {}\", sql);\n            logger.debug(\"page count total : {}\", total);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.close(rs, stmt);\n            JdbcUtils.close(con);\n        }\n    }\n\n    /**\n     * 得到统计总数sql\n     * @param sql\n     * @return\n     */\n    private String getCountSql(String sql) {\n        int index = sql.indexOf(\"from\") == -1 ? sql.indexOf(\"FROM\") : sql.indexOf(\"from\");\n        return \"select count(*) \" + sql.substring(index);\n    }\n\n    /**\n     * 得到分页sql\n     * @param sql\n     * @param page\n     * @return\n     */\n    private String getPageSql(String sql, Page<?> page) {\n        if (page != null && page.getLimit() > 0) {\n            StringBuilder pageSql = getMySQLPageSql(sql, page);\n            return pageSql.toString();\n        } else {\n            return sql;\n        }\n    }\n\n    /**\n     * 得到排序sql\n     * @param sql\n     * @param page\n     * @return\n     */\n    private String getOrderSql(String sql, Page<?> page) {\n        if (org.apache.commons.lang3.StringUtils.isNotEmpty(page.getSortName())) {\n            StringBuilder pageSql = new StringBuilder(100);\n            pageSql.append(sql);\n            if ((page.getSortName().indexOf(\"_\") == -1)) {\n                page.setSortName(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, page.getSortName()));\n            }\n            if ((\"asc\".equalsIgnoreCase(page.getSortOrder()) || \"desc\".equalsIgnoreCase(page.getSortOrder()))) {\n                pageSql.append(\" order by \" + page.getSortName() + \" \" + page.getSortOrder());\n            }\n            return pageSql.toString();\n        } else {\n            return sql;\n        }\n    }\n\n    /**\n     * 得到mysql 分页语句\n     * @param sql\n     * @param page\n     * @return\n     */\n    public StringBuilder getMySQLPageSql(String sql, Page page) {\n        StringBuilder pageSql = new StringBuilder(100);\n        pageSql.append(sql);\n        pageSql.append(\" limit \" + page.getStart() + \",\" + page.getLimit());\n        return pageSql;\n    }\n}\n```\n* `PageExecutor.java` 用于装饰之前的`Executor`用于将结果赋值到Page对象的rows属性中\n```java\npublic class PageExecutor implements Executor {\n    private static Logger logger = LoggerFactory.getLogger(PageExecutor.class);\n\n    private final Executor executor;\n\n    public PageExecutor(Executor executor) {\n        this.executor = executor;\n    }\n\n    @Override\n    public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,\n                             CacheKey cacheKey, BoundSql boundSql) throws SQLException {\n        final List<E> rows = executor.query(ms, parameter, rowBounds, resultHandler);\n        if (parameter != null && parameter instanceof Page<?>) {\n            Page<E> page = (Page<E>) parameter;\n            doCache(ms, page, parameter, rowBounds);\n            // 将结果赋值到Page对象的rows属性\n            page.setRows(rows);\n        }\n        return rows;\n    }\n\n    @Override\n    public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n        final List<E> rows = executor.query(ms, parameter, rowBounds, resultHandler);\n        if (parameter != null && parameter instanceof Page<?>) {\n            Page<E> page = (Page<E>) parameter;\n            doCache(ms, page, parameter, rowBounds);\n            // 将结果赋值到Page对象的rows属性\n            page.setRows(rows);\n        }\n        return rows;\n    }\n\n    private <E> void doCache(MappedStatement ms, Page<E> result, Object parameter, RowBounds rowBounds) {\n        final Cache cache = ms.getCache();\n        if (executor.getClass().isAssignableFrom(CachingExecutor.class) && cache != null) {\n            BoundSql boundSql = ms.getBoundSql(parameter);\n            final CacheKey cacheKey = createCacheKey(ms, parameter, rowBounds, boundSql);\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"cache executor the cache's kye  is \" + cacheKey);\n            }\n            cache.putObject(cacheKey, result);\n        }\n    }\n\n    @Override\n    public void setExecutorWrapper(Executor executor) {\n        executor.setExecutorWrapper(executor);\n    }\n\n    @Override\n    public int update(MappedStatement ms, Object parameter) throws SQLException {\n        return executor.update(ms, parameter);\n    }\n\n    @Override\n    public List<BatchResult> flushStatements() throws SQLException {\n        return executor.flushStatements();\n    }\n\n    @Override\n    public void commit(boolean required) throws SQLException {\n        executor.commit(required);\n    }\n\n    @Override\n    public void rollback(boolean required) throws SQLException {\n        executor.rollback(required);\n    }\n\n    @Override\n    public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {\n        return executor.createCacheKey(ms, parameterObject, rowBounds, boundSql);\n    }\n\n    @Override\n    public boolean isCached(MappedStatement ms, CacheKey key) {\n        return executor.isCached(ms, key);\n    }\n\n    @Override\n    public void clearLocalCache() {\n        executor.clearLocalCache();\n    }\n\n    @Override\n    public void deferLoad(MappedStatement mappedStatement, MetaObject metaObject, String s, CacheKey cacheKey, Class<?> aClass) {\n        executor.deferLoad(mappedStatement, metaObject, s, cacheKey, aClass);\n    }\n\n    @Override\n    public Transaction getTransaction() {\n        return executor.getTransaction();\n    }\n\n    @Override\n    public void close(boolean forceRollback) {\n        executor.close(forceRollback);\n    }\n\n    @Override\n    public boolean isClosed() {\n        return executor.isClosed();\n    }\n\n\t@Override\n\tpublic <E> Cursor<E> queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n}\n```\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(二十三)Mybatis中#{}和${}","url":"/2018/12/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}/","content":"## 前言\n`Mybatis`的Sql语句传参有两种方式：`#{}`和`${}`\n\n* `#{}`是预编译处理\n    * Mybatis在处理`#{}`时，会将sql中的`#{}`替换为?号，调用PreparedStatement的set方法来赋值；\n    * 使用`#{}`可以有效的防止SQL注入，提高系统安全。\n    * 如：`order by #{sortName}#`，如果传入的值是111,那么解析成sql时的值为`order by \"111\"`,\n* `${}`是字符串替换\n    * Mybatis在处理`${}`时，就是把`${}`替换成变量的值。\n    * 如果是在SQL语句中插入一个不改变的字符串。比如，像`ORDER BY`，你可以这样来使用：`ORDER BY ${columnName}`\n\n\n## 举个栗子\n* 现在通过一个例子来分析其两者的区别\n> 测试类\n```java\n    /**\n     * 测试 $ 和 #\n     * @throws Exception\n     */\n    @Test\n    public void selectByUsernameAndPasswordTest() throws Exception {\n        // 读取配置文件\n        File file = new File(\"src/test/java/resources/mybatis-config.xml\");\n        InputStream inputStream = new FileInputStream(file);\n        // 构建SqlSessionFactory\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        // 得到SqlSession\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        // 得到Mapper\n        UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n        User user = new User();\n        user.setUsername(\"songsy\");\n        user.setPassword(\"root\");\n        System.out.println(mapper.selectByUsernameAndPassword(user));\n    }\n```\n> Mapper.xml 配置文件\n```xml\n    SELECT\n      *\n    FROM\n      sys_user\n    WHERE\n      username = ${username}\n    AND password = #{password}\n```\n\n* 执行`mapper`方法，打好断点，进入到`Executor`的query方法，关注`BoundSql boundSql = ms.getBoundSql(parameterObject);` 这行，`BoundSql`对象存放了处理完成之后的sql\n```java\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameterObject);\n\t//query时传入一个cachekey参数\n    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);\n    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n  }\n```\n* 如下图所示，`${username}` 已经替换成了 `songsy` ， #{password} 替换成了 `?`\n\n![image](/images/server/mybatis/boundSql.jpg)\n\n## 栗子剖析\n* Mybatis是怎样完成上面的替换解析过程呢，进入`BoundSql boundSql = ms.getBoundSql(parameterObject);` 方法，可以看到其实就是调用`sqlSource.getBoundSql`\n```java\n  public BoundSql getBoundSql(Object parameterObject) {\n\t// 其实就是调用sqlSource.getBoundSql\n    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n    if (parameterMappings == null || parameterMappings.isEmpty()) {\n      boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);\n    }\n    // check for nested result maps in parameter mappings (issue #30)\n    for (ParameterMapping pm : boundSql.getParameterMappings()) {\n      String rmId = pm.getResultMapId();\n      if (rmId != null) {\n        ResultMap rm = configuration.getResultMap(rmId);\n        if (rm != null) {\n          hasNestedResultMaps |= rm.hasNestedResultMaps();\n        }\n      }\n    }\n    return boundSql;\n  }\n```\n* 进入`sqlSource.getBoundSql(parameterObject);` ，因为sql不是静态sql所以进入`DynamicSqlSource` 类的`getBoundSql`方法，这里传入了我们的`user`查询对象\n```java\n/**\n * 动态SQL源码\n * @author Clinton Begin\n */\npublic class DynamicSqlSource implements SqlSource {\n\n  private Configuration configuration;\n  private SqlNode rootSqlNode;\n\n  public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) {\n    this.configuration = configuration;\n    this.rootSqlNode = rootSqlNode;\n  }\n\n  // 得到绑定的SQL\n  @Override\n  public BoundSql getBoundSql(Object parameterObject) {\n    // 生成一个动态上下文\n    DynamicContext context = new DynamicContext(configuration, parameterObject);\n\t// 这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数\n    rootSqlNode.apply(context);\n\t// 调用SqlSourceBuilder\n    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n    Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass();\n\t// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法\n    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());\n\t// 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用\n    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n    for (Map.Entry<String, Object> entry : context.getBindings().entrySet()) {\n      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());\n    }\n    return boundSql;\n  }\n}\n```\n* 下面的语句是动态sql的处理，循环执行`SqlNode.apply`方法，进入 `rootSqlNode.apply(context);`方法\n```java\n  DynamicContext context = new DynamicContext(configuration, parameterObject);\n  // 这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数\n  rootSqlNode.apply(context);\n```\n* 进入`rootSqlNode.apply(context);` 之后来到了`MixedSqlNode`类，这里依次调用list里每个元素的apply，如下图所示\n\n![image](/images/server/mybatis/MixeSqlNode.jpg)\n\n* 执行`sqlNode.apply(context);`方法这里进入到`TextSqlNode`的`apply`方法，这里又调用了`GenericTokenParser`类的`parser.parse(text)`方法\n\n```java\npublic class TextSqlNode implements SqlNode {\n  private String text;\n  private Pattern injectionFilter;\n\n  public TextSqlNode(String text) {\n    this(text, null);\n  }\n  \n  public TextSqlNode(String text, Pattern injectionFilter) {\n    this.text = text;\n    this.injectionFilter = injectionFilter;\n  }\n  \n  //判断是否是动态sql\n  public boolean isDynamic() {\n    DynamicCheckerTokenParser checker = new DynamicCheckerTokenParser();\n    GenericTokenParser parser = createParser(checker);\n    parser.parse(text);\n    return checker.isDynamic();\n  }\n\n  @Override\n  public boolean apply(DynamicContext context) {\n    GenericTokenParser parser = createParser(new BindingTokenParser(context, injectionFilter));\n    context.appendSql(parser.parse(text));\n    return true;\n  }\n  \n  ...\n```\n* 进入 `GenericTokenParser`类的`parser.parse(text)`方法，可以看到这个类是处理`#{}和${}参数`的主要方法\n```java\n/**\n * 普通记号解析器，处理#{}和${}参数\n * @author Clinton Begin\n */\npublic class GenericTokenParser {\n\n  // 有一个开始和结束记号\n  private final String openToken;\n  private final String closeToken;\n  // 记号处理器\n  private final TokenHandler handler;\n\n  public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) {\n    this.openToken = openToken;\n    this.closeToken = closeToken;\n    this.handler = handler;\n  }\n\n  public String parse(String text) {\n    StringBuilder builder = new StringBuilder();\n    if (text != null && text.length() > 0) {\n      char[] src = text.toCharArray();\n      int offset = 0;\n      int start = text.indexOf(openToken, offset);\n      // #{favouriteSection,jdbcType=VARCHAR}\n      // 这里是循环解析参数，参考GenericTokenParserTest,比如可以解析${first_name} ${initial} ${last_name} reporting.这样的字符串,里面有3个 ${}\n      while (start > -1) {\n    \t  // 判断一下 ${ 前面是否是反斜杠，这个逻辑在老版的mybatis中（如3.1.0）是没有的\n        if (start > 0 && src[start - 1] == '\\\\') {\n          // the variable is escaped. remove the backslash.\n      \t  // 新版已经没有调用substring了，改为调用如下的offset方式，提高了效率\n          // issue #760\n          builder.append(src, offset, start - offset - 1).append(openToken);\n          offset = start + openToken.length();\n        } else {\n          int end = text.indexOf(closeToken, start);\n          if (end == -1) {\n            builder.append(src, offset, src.length - offset);\n            offset = src.length;\n          } else {\n            builder.append(src, offset, start - offset);\n            offset = start + openToken.length();\n            String content = new String(src, offset, end - offset);\n            // 得到一对大括号里的字符串后，调用handler.handleToken,比如替换变量 ${username}这种功能\n            builder.append(handler.handleToken(content));\n            offset = end + closeToken.length();\n          }\n        }\n        start = text.indexOf(openToken, offset);\n      }\n      if (offset < src.length) {\n        builder.append(src, offset, src.length - offset);\n      }\n    }\n    return builder.toString();\n  }\n\n}\n```\n* 执行完`builder.append(handler.handleToken(content));` 这行代码之后就可以看到`${username}` 已经替换成`songsy`了\n\n![image](/images/server/mybatis/parse.jpg)\n\n\n* 到现在已经完成了`${username}` 的处理，回到 `DynamicSqlSource` 类中，现在是处理`#{password}` 这些参数了\n```java\npublic class DynamicSqlSource implements SqlSource {\n\n  private Configuration configuration;\n  private SqlNode rootSqlNode;\n\n  public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) {\n    this.configuration = configuration;\n    this.rootSqlNode = rootSqlNode;\n  }\n\n  // 得到绑定的SQL\n  @Override\n  public BoundSql getBoundSql(Object parameterObject) {\n    // 生成一个动态上下文\n    DynamicContext context = new DynamicContext(configuration, parameterObject);\n\t// 这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数\n    rootSqlNode.apply(context);\n\t// 调用SqlSourceBuilder\n    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n    Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass();\n\t// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#{password}都替换成?了，也就是最基本的JDBC的SQL写法\n    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());\n\t// 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用\n    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n    for (Map.Entry<String, Object> entry : context.getBindings().entrySet()) {\n      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());\n    }\n    return boundSql;\n  }\n}\n```\n* 下图是处理完动态sql节点及`${username}`之后的结果\n\n![](/images/server/mybatis/getBoundSql.jpg)\n\n* 处理完`${username}` 节点之后现在就是处理`#{password}` 节点了，解析完了就把那些参数#{password}都替换成?了，也就是最基本的JDBC的SQL写法\n```java\n\t// 调用SqlSourceBuilder\n    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n    Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass();\n\t// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#{password}都替换成?了，也就是最基本的JDBC的SQL写法\n    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());\n```\n* 进入`sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());`方法，之后又是进入 `GenericTokenParser`类的`parser.parse(text)`方法，只不过`handleToken`方法执行的是下面的代码\n```java\n   @Override\n    public String handleToken(String content) {\n      // 先构建参数映射\n      parameterMappings.add(buildParameterMapping(content));\n      // 如何替换很简单，永远是一个问号，但是参数的信息要记录在parameterMappings里面供后续使用\n      return \"?\";\n    }\n```\n* 最后拼接成的结果如下\n```sql\n        SELECT\n          *\n        FROM\n          sys_user\n        WHERE\n          username = songsy\n        AND password = ?\n```\n## 总结\n* `#{}`在一定程度上可以防止SQL的注入\n* `${}`一般用在动态表名，动态字段，设置排序字段上\n\n## 参考\n\nhttps://www.jianshu.com/p/a9cb929b533e","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(二十一)拦截器Interceptor原理探究","url":"/2018/12/21/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究/","content":"## 前言\n* MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用，拦截后用户可以完成一些额外的定制操作，比如实现分页，这一章节来介绍拦截器的一些基本知识及实现原理，下一章节将介绍如何用拦截器实现查询分页功能\n\n* 默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：\n````java\n// 拦截执行器的方法\nExecutor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\n// 拦截参数的处理\nParameterHandler (getParameterObject, setParameters)\n// 拦截结果集的处理\nResultSetHandler (handleResultSets, handleOutputParameters)\n// 拦截Sql语法构建的处理\nStatementHandler (prepare, parameterize, batch, update, query)\n````\n## 拦截器的使用\n* 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。\n```java\n// ExamplePlugin.java\n@Intercepts({@Signature(\n  type= Executor.class,\n  method = \"update\",\n  args = {MappedStatement.class,Object.class})})\npublic class ExamplePlugin implements Interceptor {\n  public Object intercept(Invocation invocation) throws Throwable {\n    return invocation.proceed();\n  }\n  public Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n  public void setProperties(Properties properties) {\n  }\n}\n```\n* xml 配置\n```xml\n<!-- mybatis-config.xml -->\n<plugins>\n  <plugin interceptor=\"org.mybatis.example.ExamplePlugin\">\n    <property name=\"someProperty\" value=\"100\"/>\n  </plugin>\n</plugins>\n```\n* 上面的插件将会拦截在 `Executor` 实例中所有的名为`update` 且参数为`(MappedStatement.class,Object.class)`的方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。\n## 拦截器原理探究\n\n### 拦截器定义\n* 首先我们看下MyBatis拦截器的接口定义 `Interceptor.java`\n```java\n/**\n * 拦截器\n * @author Clinton Begin\n */\npublic interface Interceptor {\n\n  // 在这里完成拦截操作\n  Object intercept(Invocation invocation) throws Throwable;\n\n  // 用于封装目标对象，我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象\n  Object plugin(Object target);\n\n  // 用于在Mybatis配置文件中指定一些属性的。\n  void setProperties(Properties properties);\n\n}\n```\n* `Signature`注解用于定义拦截方法，规则为：`type`这个类下方法名为`method`且参数为`args`的方法\n```java\n/**\n * 就是定义哪些类，方法，参数需要被拦截\n * @author Clinton Begin\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface Signature {\n\n  Class<?> type();\n\n  String method();\n\n  Class<?>[] args();\n}\n```\n* 当定义拦截器类之后就是要让`Mybatis`知道有哪些拦截器了，那`Mybatis`是怎么知道有哪些拦截器呢，通过以上章节可以知道Spring集成Mybatis有两种方法，一种是通过xml配置的方式，另一种是通过注解的方式，下面来介绍这两种方式是怎样获取定义好的拦截器的\n    * 通过xml配置的方式\n        * 先是在 `mybatis-config.xml` 定义好哪些拦截器\n            ```xml\n                <!-- mybatis-config.xml -->\n                <plugins>\n                  <plugin interceptor=\"org.mybatis.example.ExamplePlugin\">\n                    <property name=\"someProperty\" value=\"100\"/>\n                  </plugin>\n                </plugins>\n            ```\n        * 定义好之后那么Mybatis就会解析`pluginElement` 然后将会添加到`Configuration` 对象的`InterceptorChain`对象中，这样拦截器就解析完成了\n            ```java\n              private void pluginElement(XNode parent) throws Exception {\n                if (parent != null) {\n                  for (XNode child : parent.getChildren()) {\n                    String interceptor = child.getStringAttribute(\"interceptor\");\n                    Properties properties = child.getChildrenAsProperties();\n                    Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();\n                    interceptorInstance.setProperties(properties);\n                    //调用InterceptorChain.addInterceptor\n                    configuration.addInterceptor(interceptorInstance);\n                  }\n                }\n              }\n            ```\n        * 看看`InterceptorChain`类，内部就是一个拦截器的List，可以定义多个拦截器\n            ```java\n               \n              /**\n               * 拦截器链\n               * @author Clinton Begin\n               */\n              public class InterceptorChain {\n              \n                // 内部就是一个拦截器的List，可以定义多个拦截器\n                private final List<Interceptor> interceptors = new ArrayList<Interceptor>();\n              \n                public Object pluginAll(Object target) {\n                  // 循环调用每个Interceptor.plugin方法\n                  for (Interceptor interceptor : interceptors) {\n                    target = interceptor.plugin(target);\n                  }\n                  return target;\n                }\n              \n                public void addInterceptor(Interceptor interceptor) {\n                  interceptors.add(interceptor);\n                }\n                \n                public List<Interceptor> getInterceptors() {\n                  return Collections.unmodifiableList(interceptors);\n                }\n              \n              }\n            ```\n    * 通过注解的方式\n        * 通过注解的方式获取拦截器需要准备环境，查看第十九章\n        \n        * 在拦截器那个类添加`@Component` 让拦截器类注册成`Spring bean`，这样此拦截器将会自动装配到`Mybatis`中\n        ```java\n          @Component\n          @Intercepts({@Signature(\n            type= Executor.class,\n            method = \"update\",\n            args = {MappedStatement.class,Object.class})})\n          public class ExamplePlugin implements Interceptor {\n            public Object intercept(Invocation invocation) throws Throwable {\n              return invocation.proceed();\n            }\n            public Object plugin(Object target) {\n              return Plugin.wrap(target, this);\n            }\n            public void setProperties(Properties properties) {\n            }\n          }\n        ```\n        * 那么是怎么实现拦截器的自动装配到`Mybatis`中，可以查看`org.mybatis.spring.boot.autoconfigure` 包下的`MybatisAutoConfiguration` 类，查看其构造方法，关注`this.interceptors = interceptorsProvider.getIfAvailable();` 方法，这里实现了查找实现了`Interceptor`接口的的类，这个方法是Spring的方法，所以之前需要将拦截器类注册成Bean，这样Spring才能找到对应的拦截器\n        ```java\n            public MybatisAutoConfiguration(MybatisProperties properties,\n                                            ObjectProvider<Interceptor[]> interceptorsProvider,\n                                            ResourceLoader resourceLoader,\n                                            ObjectProvider<DatabaseIdProvider> databaseIdProvider,\n                                            ObjectProvider<List<ConfigurationCustomizer>> configurationCustomizersProvider) {\n              this.properties = properties;\n              this.interceptors = interceptorsProvider.getIfAvailable();\n              this.resourceLoader = resourceLoader;\n              this.databaseIdProvider = databaseIdProvider.getIfAvailable();\n              this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();\n            }\n        ```\n        * 现在来看`SqlSessionFactory`注册为Bean的过程，得到`interceptors`之后就需要将其添加到万能类`Configuration`中， 查看`SqlSessionFactoryBean`的`buildSqlSessionFactory` 方法，下面的代码就是此操作的实现\n        ```java\n           if (!isEmpty(this.plugins)) {\n              for (Interceptor plugin : this.plugins) {\n                configuration.addInterceptor(plugin);\n                if (LOGGER.isDebugEnabled()) {\n                  LOGGER.debug(\"Registered plugin: '\" + plugin + \"'\");\n                }\n              }\n            }\n        ```\n### 拦截器是如何拦截的\n* 以下4个方法都是`Configuration`的方法。这些方法在`MyBatis`的新增，删除，修改，查询这些操作中都会被执行到，执行的先后顺序是`Executor，ParameterHandler，ResultSetHandler，StatementHandler`(其中ParameterHandler和ResultSetHandler的创建是在创建StatementHandler（3个可用的实现类CallableStatementHandler,PreparedStatementHandler,SimpleStatementHandler）的时候，其构造函数调用的（这3个实现类的构造函数其实都调用了父类BaseStatementHandler的构造函数）。\n\n```java\npublic ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {\n    ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);\n    parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);\n    return parameterHandler;\n}\n\npublic ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,\n  ResultHandler resultHandler, BoundSql boundSql) {\n    ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);\n    resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);\n    return resultSetHandler;\n}\n\npublic StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {\n    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);\n    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);\n    return statementHandler;\n}\n\npublic Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) {\n    executorType = executorType == null ? defaultExecutorType : executorType;\n    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH == executorType) {\n      executor = new BatchExecutor(this, transaction);\n    } else if (ExecutorType.REUSE == executorType) {\n      executor = new ReuseExecutor(this, transaction);\n    } else {\n      executor = new SimpleExecutor(this, transaction);\n    }\n    if (cacheEnabled) {\n      executor = new CachingExecutor(executor, autoCommit);\n    }\n    executor = (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n}\n```\n* 这4个方法实例化了对应的对象之后，都会调用interceptorChain的pluginAll方法，InterceptorChain的pluginAll刚才已经介绍过了，就是遍历所有的拦截器，然后调用各个拦截器的plugin方法。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象\n```java\npublic Object pluginAll(Object target) {\n    // 循环调用每个Interceptor.plugin方法\n    for (Interceptor interceptor : interceptors) {\n      target = interceptor.plugin(target);\n    }\n    return target;\n  }\n```\n* 回到之前的拦截器类，这里查看`plugin`方法`Plugin.wrap(target, this);`，这里执行了`Plugin`类的`wrap(target, this)` 方法，返回了一个新的对象。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象\n```java\n@Intercepts({@Signature(\n  type= Executor.class,\n  method = \"update\",\n  args = {MappedStatement.class,Object.class})})\npublic class ExamplePlugin implements Interceptor {\n  public Object intercept(Invocation invocation) throws Throwable {\n    return invocation.proceed();\n  }\n  public Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n  public void setProperties(Properties properties) {\n  }\n}\n```\n* 进入`Plugin`类，可以看到这里用了动态代理模式来实现拦截器的拦截操作`Plugin.wrap(target, this);`返回的是一个动态代理对象，当其动态代理对象执行方法的时候就会执行本`Plugin`类的`invoke`方法\n```java\n/**\n * 插件,用的代理模式\n * @author Clinton Begin\n */\npublic class Plugin implements InvocationHandler {\n\n  private Object target;\n  private Interceptor interceptor;\n  private Map<Class<?>, Set<Method>> signatureMap;\n\n  private Plugin(Object target, Interceptor interceptor, Map<Class<?>, Set<Method>> signatureMap) {\n    this.target = target;\n    this.interceptor = interceptor;\n    this.signatureMap = signatureMap;\n  }\n\n  public static Object wrap(Object target, Interceptor interceptor) {\n    // 取得签名Map\n    Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);\n    // 取得要改变行为的类(ParameterHandler|ResultSetHandler|StatementHandler|Executor)\n    Class<?> type = target.getClass();\n    // 取得接口\n    Class<?>[] interfaces = getAllInterfaces(type, signatureMap);\n    // 产生代理\n    if (interfaces.length > 0) {\n      return Proxy.newProxyInstance(\n          type.getClassLoader(),\n          interfaces,\n          new Plugin(target, interceptor, signatureMap));\n    }\n    return target;\n  }\n\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    try {\n      // 看看如何拦截\n      Set<Method> methods = signatureMap.get(method.getDeclaringClass());\n      // 看哪些方法需要拦截\n      if (methods != null && methods.contains(method)) {\n        // 调用Interceptor.intercept，也即插入了我们自己的逻辑\n        return interceptor.intercept(new Invocation(target, method, args));\n      }\n      // 最后还是执行原来逻辑\n      return method.invoke(target, args);\n    } catch (Exception e) {\n      throw ExceptionUtil.unwrapThrowable(e);\n    }\n  }\n\n  // 取得签名Map\n  private static Map<Class<?>, Set<Method>> getSignatureMap(Interceptor interceptor) {\n    // 取Intercepts注解，例子可参见ExamplePlugin.java\n    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);\n    // issue #251\n    // 必须得有Intercepts注解，没有报错\n    if (interceptsAnnotation == null) {\n      throw new PluginException(\"No @Intercepts annotation was found in interceptor \" + interceptor.getClass().getName());      \n    }\n    // value是数组型，Signature的数组\n    Signature[] sigs = interceptsAnnotation.value();\n    // 每个class里有多个Method需要被拦截,所以这么定义\n    Map<Class<?>, Set<Method>> signatureMap = new HashMap<Class<?>, Set<Method>>();\n    for (Signature sig : sigs) {\n      Set<Method> methods = signatureMap.get(sig.type());\n      if (methods == null) {\n        methods = new HashSet<Method>();\n        signatureMap.put(sig.type(), methods);\n      }\n      try {\n        Method method = sig.type().getMethod(sig.method(), sig.args());\n        methods.add(method);\n      } catch (NoSuchMethodException e) {\n        throw new PluginException(\"Could not find method on \" + sig.type() + \" named \" + sig.method() + \". Cause: \" + e, e);\n      }\n    }\n    return signatureMap;\n  }\n\n  // 取得接口\n  private static Class<?>[] getAllInterfaces(Class<?> type, Map<Class<?>, Set<Method>> signatureMap) {\n    Set<Class<?>> interfaces = new HashSet<Class<?>>();\n    while (type != null) {\n      for (Class<?> c : type.getInterfaces()) {\n        //貌似只能拦截ParameterHandler|ResultSetHandler|StatementHandler|Executor\n        //拦截其他的无效\n        //当然我们可以覆盖Plugin.wrap方法，达到拦截其他类的功能\n        if (signatureMap.containsKey(c)) {\n          interfaces.add(c);\n        }\n      }\n      type = type.getSuperclass();\n    }\n    return interfaces.toArray(new Class<?>[interfaces.size()]);\n  }\n\n}\n```\n* 查看`invoke方法`,从而调用了我们之前定义的`interceptor.intercept();`的方法，这里是实现拦截的核心，`interceptor.intercept(new Invocation(target, method, args));` 这里插入了我们自己的逻辑\n```java\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    try {\n      // 看看如何拦截\n      Set<Method> methods = signatureMap.get(method.getDeclaringClass());\n      // 看哪些方法需要拦截\n      if (methods != null && methods.contains(method)) {\n        // 调用Interceptor.intercept，也即插入了我们自己的逻辑\n        return interceptor.intercept(new Invocation(target, method, args));\n      }\n      // 最后还是执行原来逻辑\n      return method.invoke(target, args);\n    } catch (Exception e) {\n      throw ExceptionUtil.unwrapThrowable(e);\n    }\n  }\n```\n* 回到之前的节点，在构建`Executor`的时候，`executor = (Executor) interceptorChain.pluginAll(executor);`这里返回的是 `Plugin.wrap(target, this);`一个动态代理对象\n```java\npublic Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) {\n    executorType = executorType == null ? defaultExecutorType : executorType;\n    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH == executorType) {\n      executor = new BatchExecutor(this, transaction);\n    } else if (ExecutorType.REUSE == executorType) {\n      executor = new ReuseExecutor(this, transaction);\n    } else {\n      executor = new SimpleExecutor(this, transaction);\n    }\n    if (cacheEnabled) {\n      executor = new CachingExecutor(executor, autoCommit);\n    }\n    executor = (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n}\n```\n* 所以当`SqlSession`执行`Executor`的方法时候，这里`Executor`是个动态代理之后的`Executor`，当执行`Executor`的方法的时候就会执行动态代理的invoke方法，在invoke方法执行我们额外的代码\n\n* 在此拦截器的任务才真正完成\n\n## 参考\n官网：http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins\n\nhttps://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(二十)Spring Mybatis集成之事务管理","url":"/2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十)Spring Mybatis集成之事务管理/","content":"## 前言\n使用 `MyBatis-Spring` 的主要原因是它允许 `MyBatis` 参与到 `Spring` 的事务管理中。而 不是给 `MyBatis` 创建一个新的特定的事务管理器,`MyBatis-Spring` 利用了存在于 Spring 中的 `DataSourceTransactionManager`。\n\n### 如何集成 `Spring`的事务管理\n \n* 配置 `DataSourceTransactionManager` Bean\n```xml\n    <!-- (事务管理)transaction manager, use JtaTransactionManager for global tx -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n```\n* 要注意, 为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的 是同一个数据源,否则事务管理器就无法工作了。\n\n* 一旦 `Spring` 的 `DataSourceTransactionManager` 配置好了,你可以在 `Spring` 中你可以使用`@Transactional` 注解来完成事物操作。在事务处理期间,一个单独的 `SqlSession` 对象（线程级别）将会被创建 和使用。当事务完成时,这个 `SqlSession` 会以合适的方式提交或回滚。相反如果没有开启事物那么`SqlSession` 对象就是方法级别的了，每次调用Mapper里的方法都会返回一个新的`SqlSession` 来处理，下面来看其内部是怎么实现的\n\n### 事务实现解析\n* 与Spring集成以后，Spring提供了一个全局唯一的`SqlSessionTemplate` 来完成`DefailtSqlSession`的功能\n\n* 进入`SqlSessionTemplate` 可以看到里面有个`SqlSession` 属性，看属性名可以看出这里又用了动态代理，为什么又要代理呢？下面来看看\n```java\n  // SqlSession代理\n  private final SqlSession sqlSessionProxy;\n```\n* 观察其构造方法，这里形成SqlSession代理类，再来看动态代理类`SqlSessionInterceptor`做了什么\n```java\n public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,\n      PersistenceExceptionTranslator exceptionTranslator) {\n\n    notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\");\n    notNull(executorType, \"Property 'executorType' is required\");\n\n    this.sqlSessionFactory = sqlSessionFactory;\n    this.executorType = executorType;\n    this.exceptionTranslator = exceptionTranslator;\n    // 形成SqlSession代理类\n    this.sqlSessionProxy = (SqlSession) newProxyInstance(\n        SqlSessionFactory.class.getClassLoader(),\n        new Class[] { SqlSession.class },\n        new SqlSessionInterceptor());\n  }\n```\n* 进入`SqlSessionInterceptor`类，这个`SqlSession`代理类的出现是为了让Spring 来管理`SqlSession` 的，从而实现事物管理\n\n```java\n  /**\n   * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession\n   * Proxy needed to route MyBatis method calls to the proper SqlSession got\n   * from Spring's Transaction Manager\n   * It also unwraps exceptions thrown by {@code Method#invoke(Object, Object...)} to\n   * pass a {@code PersistenceException} to the {@code PersistenceExceptionTranslator}.\n   */\n  private class SqlSessionInterceptor implements InvocationHandler {\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      // 获取SqlSession(这个SqlSession才是真正使用的，它不是线程安全的)\n      SqlSession sqlSession = getSqlSession(\n          SqlSessionTemplate.this.sqlSessionFactory,\n          SqlSessionTemplate.this.executorType,\n          SqlSessionTemplate.this.exceptionTranslator);\n      try {\n        // 调用真实SqlSession的方法\n        Object result = method.invoke(sqlSession, args);\n        // 判断一下当前的sqlSession是否被Spring托管\n        if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {\n          // force commit even on non-dirty sessions because some databases require\n          // a commit/rollback before calling close()\n          // 没有使用事务\n          sqlSession.commit(true);\n        }\n        return result;\n      } catch (Throwable t) {\n        Throwable unwrapped = unwrapThrowable(t);\n        if (SqlSessionTemplate.this.exceptionTranslator != null && unwrapped instanceof PersistenceException) {\n          // release the connection to avoid a deadlock if the translator is no loaded. See issue #22\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n          sqlSession = null;\n          Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);\n          if (translated != null) {\n            unwrapped = translated;\n          }\n        }\n        throw unwrapped;\n      } finally {\n        if (sqlSession != null) {\n          // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n        }\n      }\n    }\n  }\n```\n* 进入`getSqlSession()`方法，这里是获取`SqlSession` 的方法\n```java\n  public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) {\n\n    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);\n    notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED);\n\n    // 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder\n    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);\n\n    SqlSession session = sessionHolder(executorType, holder);\n    if (session != null) {\n      return session;\n    }\n    // 如果找不到，则根据执行类型构造一个新的sqlSession\n    LOGGER.debug(() -> \"Creating a new SqlSession\");\n    session = sessionFactory.openSession(executorType);\n\n    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);\n\n    return session;\n  }\n```\n* 关注`TransactionSynchronizationManager` 内部成员，这里使用`TreadLocal`记录事务的一些属性，用于应用扩展同步器的使用，在事务的开启，挂起，提交等各个点上回调应用的逻辑\n```java\n    // 应用代码随事务的声明周期绑定的对象\n\tprivate static final ThreadLocal<Map<Object, Object>> resources =\n\t\t\tnew NamedThreadLocal<>(\"Transactional resources\");\n\n    // synchronizations-使用的同步器，用于应用扩展\n\tprivate static final ThreadLocal<Set<TransactionSynchronization>> synchronizations =\n\t\t\tnew NamedThreadLocal<>(\"Transaction synchronizations\");\n    \n\t// 事务的名称\n\tprivate static final ThreadLocal<String> currentTransactionName =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction name\");\n    \n\t// 事务是否是只读\n\tprivate static final ThreadLocal<Boolean> currentTransactionReadOnly =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction read-only status\");\n    \n\t// 事务的隔离界别\n\tprivate static final ThreadLocal<Integer> currentTransactionIsolationLevel =\n\t\t\tnew NamedThreadLocal<>(\"Current transaction isolation level\");\n    \n\t// 事务是否开启\n\tprivate static final ThreadLocal<Boolean> actualTransactionActive =\n\t\t\tnew NamedThreadLocal<>(\"Actual transaction active\");\n\n```\n\n* 回到`SqlSessionInterceptor` 类`invoke`方法，这里有个if判断` if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {` 来判断是否开启了Spring事务，如果该Session未被Spring托管则自动commit\n```java\n  public static boolean isSqlSessionTransactional(SqlSession session, SqlSessionFactory sessionFactory) {\n    notNull(session, NO_SQL_SESSION_SPECIFIED);\n    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);\n\n    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);\n\n    return (holder != null) && (holder.getSqlSession() == session);\n  }\n```\n\n* 关注`invoke`方法的`finally`块的 `closeSqlSession()方法`，如果是开启了事务则没有执行`session.close();`\n```java\n    finally {\n        if (sqlSession != null) {\n          // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n        }\n      }\n```\n```java\n  public static void closeSqlSession(SqlSession session, SqlSessionFactory sessionFactory) {\n    notNull(session, NO_SQL_SESSION_SPECIFIED);\n    notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED);\n\n    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);\n    if ((holder != null) && (holder.getSqlSession() == session)) {\n      LOGGER.debug(() -> \"Releasing transactional SqlSession [\" + session + \"]\");\n      // 如果是开启了事务 SqlSession是没有被close的，所以方法体内使用的是一个SqlSession，当然一级缓存是生效的\n      holder.released();\n    } else {\n      LOGGER.debug(() -> \"Closing non transactional SqlSession [\" + session + \"]\");\n      session.close();\n    }\n  }\n```\n## 总结\n* 通过上述代码可以得出如果开启了事务，同一事务中同一个sqlSessionFactory创建的唯一sqlSession，一个事务中使用的是同一个sqlSession，为什么要用同一个sqlSession呢，是为了使用同一个connection (JDBC)\n* 如果没有开启事务，调用一次mapper里的方法将会新建一个sqlSession来执行方法\n\n## 参考\n\nhttp://www.mybatis.org/spring/zh/factorybean.html\n\nhttps://www.cnblogs.com/daxin/p/3544188.html","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析","url":"/2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析/","content":"## 前言\nMybatis与Spring的集成实现有两种方式，一种是通过XML配置，另一种是通过注解的信息进行配置，上一章节介绍了通过XML的方式来集成，这一章节来介绍如何通过注解的形式来在`Spring Boot`环境中集成`Mybatis`\n\n### 环境准备\n* 基于`MyBatis-Spring-Boot-Starter` 快速在`Spring Boot`环境中集成Mybatis，使用注解解决一切问题\n\n* 基于`Spring Boot`环境中添加依赖\n```xml\n    <dependency>\n        <groupId>org.mybatis.spring.boot</groupId>\n        <artifactId>mybatis-spring-boot-starter</artifactId>\n        <version>1.3.2</version>\n    </dependency>\n```\n* 配置类中添加注解\n```xml\n@MapperScan(\"com.songsy.iframe.mapper\")\n```\n\n* 添加配置（选填）\n```java\nmybatis:\n    type-aliases-package: com.songsy.iframe.model\n    type-handlers-package: com.songsy.iframe.typehandler\n    configuration:\n        map-underscore-to-camel-case: true\n        default-fetch-size: 100\n        default-statement-timeout: 30\n```\n* 以上完成之后就可以使用Mybatis了\n\n### 原理解析\n* 打开`mybatis-spring-boot-starter` 源码可以看到是个空壳子\n\n![image](/images/server/mybatis/spring-boot-starter.jpg)\n\n* 打开里面的`pom.xml`文件，可以看到其依赖，里面已经帮我们导入了`mybatis`及`mybatis-spring`的包\n```java\n  <modelVersion>4.0.0</modelVersion>\n  <parent>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot</artifactId>\n    <version>1.3.1</version>\n  </parent>\n  <artifactId>mybatis-spring-boot-starter</artifactId>\n  <name>mybatis-spring-boot-starter</name>\n  <dependencies>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-jdbc</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis.spring.boot</groupId>\n      <artifactId>mybatis-spring-boot-autoconfigure</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n    </dependency>\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis-spring</artifactId>\n    </dependency>\n  </dependencies>\n```\n* 关注`mybatis-spring-boot-autoconfigure` 包，这里完成了其自动配置的功能，可以看到里面就只有几个类\n\n![image](/images/server/mybatis/springboot-configure.jpg)\n\n* `MybatisProperties.java`是属性配置类\n```java\n@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)\npublic class MybatisProperties {\n\n  public static final String MYBATIS_PREFIX = \"mybatis\";\n\n  /**\n   * Location of MyBatis xml config file.\n   */\n  private String configLocation;\n\n  /**\n   * Locations of MyBatis mapper files.\n   */\n  private String[] mapperLocations;\n\n  /**\n   * Packages to search type aliases. (Package delimiters are \",; \\t\\n\")\n   */\n  private String typeAliasesPackage;\n\n  /**\n   * Packages to search for type handlers. (Package delimiters are \",; \\t\\n\")\n   */\n  private String typeHandlersPackage;\n\n  /**\n   * Indicates whether perform presence check of the MyBatis xml config file.\n   */\n  private boolean checkConfigLocation = false;\n\n  /**\n   * Execution mode for {@link org.mybatis.spring.SqlSessionTemplate}.\n   */\n  private ExecutorType executorType;\n\n  /**\n   * Externalized properties for MyBatis configuration.\n   */\n  private Properties configurationProperties;\n\n  /**\n   * A Configuration object for customize default settings. If {@link #configLocation}\n   * is specified, this property is not used.\n   */\n  @NestedConfigurationProperty\n  private Configuration configuration;\n  \n  ...\n```\n* `MybatisAutoConfiguration` 是完成自动配置的主要实现类，可以看到这里定义了`SqlSessionFactory`及`SqlSessionTemplate` Bean，这里完成了之前使用xml配置bean的功能\n```java\n/**\n * {@link EnableAutoConfiguration Auto-Configuration} for Mybatis. Contributes a\n * {@link SqlSessionFactory} and a {@link SqlSessionTemplate}.\n *\n * If {@link org.mybatis.spring.annotation.MapperScan} is used, or a\n * configuration file is specified as a property, those will be considered,\n * otherwise this auto-configuration will attempt to register mappers based on\n * the interface definitions in or under the root auto-configuration package.\n *\n * @author Eddú Meléndez\n * @author Josh Long\n * @author Kazuki Shimizu\n * @author Eduardo Macarrón\n */\n@org.springframework.context.annotation.Configuration\n@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })\n@ConditionalOnBean(DataSource.class)\n@EnableConfigurationProperties(MybatisProperties.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\npublic class MybatisAutoConfiguration {\n\n  private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class);\n\n  private final MybatisProperties properties;\n\n  private final Interceptor[] interceptors;\n\n  private final ResourceLoader resourceLoader;\n\n  private final DatabaseIdProvider databaseIdProvider;\n\n  private final List<ConfigurationCustomizer> configurationCustomizers;\n\n  public MybatisAutoConfiguration(MybatisProperties properties,\n                                  ObjectProvider<Interceptor[]> interceptorsProvider,\n                                  ResourceLoader resourceLoader,\n                                  ObjectProvider<DatabaseIdProvider> databaseIdProvider,\n                                  ObjectProvider<List<ConfigurationCustomizer>> configurationCustomizersProvider) {\n    this.properties = properties;\n    this.interceptors = interceptorsProvider.getIfAvailable();\n    this.resourceLoader = resourceLoader;\n    this.databaseIdProvider = databaseIdProvider.getIfAvailable();\n    this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();\n  }\n\n  @PostConstruct\n  public void checkConfigFileExists() {\n    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {\n      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());\n      Assert.state(resource.exists(), \"Cannot find config location: \" + resource\n          + \" (please add config file or check your Mybatis configuration)\");\n    }\n  }\n\n  @Bean\n  @ConditionalOnMissingBean\n  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();\n    factory.setDataSource(dataSource);\n    factory.setVfs(SpringBootVFS.class);\n    if (StringUtils.hasText(this.properties.getConfigLocation())) {\n      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));\n    }\n    Configuration configuration = this.properties.getConfiguration();\n    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {\n      configuration = new Configuration();\n    }\n    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {\n      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {\n        customizer.customize(configuration);\n      }\n    }\n    factory.setConfiguration(configuration);\n    if (this.properties.getConfigurationProperties() != null) {\n      factory.setConfigurationProperties(this.properties.getConfigurationProperties());\n    }\n    if (!ObjectUtils.isEmpty(this.interceptors)) {\n      factory.setPlugins(this.interceptors);\n    }\n    if (this.databaseIdProvider != null) {\n      factory.setDatabaseIdProvider(this.databaseIdProvider);\n    }\n    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {\n      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());\n    }\n    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {\n      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());\n    }\n    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {\n      factory.setMapperLocations(this.properties.resolveMapperLocations());\n    }\n\n    return factory.getObject();\n  }\n\n  @Bean\n  @ConditionalOnMissingBean\n  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n    ExecutorType executorType = this.properties.getExecutorType();\n    if (executorType != null) {\n      return new SqlSessionTemplate(sqlSessionFactory, executorType);\n    } else {\n      return new SqlSessionTemplate(sqlSessionFactory);\n    }\n  }\n\n  /**\n   * This will just scan the same base package as Spring Boot does. If you want\n   * more power, you can explicitly use\n   * {@link org.mybatis.spring.annotation.MapperScan} but this will get typed\n   * mappers working correctly, out-of-the-box, similar to using Spring Data JPA\n   * repositories.\n   */\n  public static class AutoConfiguredMapperScannerRegistrar\n      implements BeanFactoryAware, ImportBeanDefinitionRegistrar, ResourceLoaderAware {\n\n    private BeanFactory beanFactory;\n\n    private ResourceLoader resourceLoader;\n\n    @Override\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\n      logger.debug(\"Searching for mappers annotated with @Mapper\");\n\n      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);\n\n      try {\n        if (this.resourceLoader != null) {\n          scanner.setResourceLoader(this.resourceLoader);\n        }\n\n        List<String> packages = AutoConfigurationPackages.get(this.beanFactory);\n        if (logger.isDebugEnabled()) {\n          for (String pkg : packages) {\n            logger.debug(\"Using auto-configuration base package '{}'\", pkg);\n          }\n        }\n\n        scanner.setAnnotationClass(Mapper.class);\n        scanner.registerFilters();\n        scanner.doScan(StringUtils.toStringArray(packages));\n      } catch (IllegalStateException ex) {\n        logger.debug(\"Could not determine auto-configuration package, automatic mapper scanning disabled.\", ex);\n      }\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n      this.beanFactory = beanFactory;\n    }\n\n    @Override\n    public void setResourceLoader(ResourceLoader resourceLoader) {\n      this.resourceLoader = resourceLoader;\n    }\n  }\n\n  /**\n   * {@link org.mybatis.spring.annotation.MapperScan} ultimately ends up\n   * creating instances of {@link MapperFactoryBean}. If\n   * {@link org.mybatis.spring.annotation.MapperScan} is used then this\n   * auto-configuration is not needed. If it is _not_ used, however, then this\n   * will bring in a bean registrar and automatically register components based\n   * on the same component-scanning path as Spring Boot itself.\n   */\n  @org.springframework.context.annotation.Configuration\n  @Import({ AutoConfiguredMapperScannerRegistrar.class })\n  @ConditionalOnMissingBean(MapperFactoryBean.class)\n  public static class MapperScannerRegistrarNotFoundConfiguration {\n\n    @PostConstruct\n    public void afterPropertiesSet() {\n      logger.debug(\"No {} found.\", MapperFactoryBean.class.getName());\n    }\n  }\n\n}\n```\n\n* 通过注解配置来集成Spring、Mybatis 的方式可以看到是通过这个注解`@MapperScan`来实现的，查看注解可以看到通过`@Import(MapperScannerRegistrar.class)`把实例加入springIOC容器中\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Import(MapperScannerRegistrar.class) // 通过导入的方式实现把实例加入springIOC容器中\n@Repeatable(MapperScans.class)// 被此注解修饰的注解是可以重复的。注解的参数是可重复注解的存储容器注解类型。@Repeatable括号内的就相当于用来保存该注解内容的容器。\npublic @interface MapperScan {\n```\n* 查看`MapperScannerRegistrar`类，可以看到实现了 `ImportBeanDefinitionRegistrar`接口，重写了`registerBeanDefinitions`方法， 由于实现了该接口让该类成为了拥有注册bean的能力\n\n![image](/images/server/mybatis/MapperScannerRegistrar.png)\n\n* 进入`registerBeanDefinitions`方法\n```java\n  @Override\n  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n    // 拿到注解信息，内部实现是 LinkedHashMap\n    AnnotationAttributes mapperScanAttrs = AnnotationAttributes\n        .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));\n    if (mapperScanAttrs != null) {\n      registerBeanDefinitions(mapperScanAttrs, registry);\n    }\n  }\n```\n* 进入第二个`registerBeanDefinitions`方法，可以看到又出现了`ClassPathMapperScanner`这个类，果不其然，还是调用了`scanner.doScan(StringUtils.toStringArray(basePackages));` 这个方法完成了Mapper的注册\n```java\n  void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) {\n    // 获得spring的注册器registry\n    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);\n\n    // this check is needed in Spring 3.1\n    if (resourceLoader != null) {\n      scanner.setResourceLoader(resourceLoader);\n    }\n\n    Class<? extends Annotation> annotationClass = annoAttrs.getClass(\"annotationClass\");\n    if (!Annotation.class.equals(annotationClass)) {\n      scanner.setAnnotationClass(annotationClass);\n    }\n\n    Class<?> markerInterface = annoAttrs.getClass(\"markerInterface\");\n    if (!Class.class.equals(markerInterface)) {\n      scanner.setMarkerInterface(markerInterface);\n    }\n\n    Class<? extends BeanNameGenerator> generatorClass = annoAttrs.getClass(\"nameGenerator\");\n    if (!BeanNameGenerator.class.equals(generatorClass)) {\n      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));\n    }\n\n    Class<? extends MapperFactoryBean> mapperFactoryBeanClass = annoAttrs.getClass(\"factoryBean\");\n    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {\n      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));\n    }\n\n    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(\"sqlSessionTemplateRef\"));\n    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(\"sqlSessionFactoryRef\"));\n\n    List<String> basePackages = new ArrayList<>();\n    // 如果配置了包路径则将入进去\n    basePackages.addAll(\n        Arrays.stream(annoAttrs.getStringArray(\"value\"))\n            .filter(StringUtils::hasText)\n            .collect(Collectors.toList()));\n    // 与上面功能一致\n    basePackages.addAll(\n        Arrays.stream(annoAttrs.getStringArray(\"basePackages\"))\n            .filter(StringUtils::hasText)\n            .collect(Collectors.toList()));\n\n    basePackages.addAll(\n        Arrays.stream(annoAttrs.getClassArray(\"basePackageClasses\"))\n            .map(ClassUtils::getPackageName)\n            .collect(Collectors.toList()));\n\n    scanner.registerFilters();\n    // 开始扫描包\n    scanner.doScan(StringUtils.toStringArray(basePackages));\n  }\n```\n## 总结\n* 使用注解的方式集成Mybatis比xml配置的方式更为简洁，在`Spring Boot`项目中就是以这种方式来配置的\n* `mybatis-spring-boot-autoconfigure` 帮助我们完成了以下功能\n```xml\n  自动检测现有的DataSource。\n  将创建并注册的一个实例的SqlSessionFactory传递一个数据源作为使用输入SqlSessionFactoryBean的。\n  将创建并注册SqlSessionTemplate的实例从SqlSessionFactory中获取。\n  自动扫描映射器，将它们链接到SqlSessionTemplate并将它们注册到Spring上下文，以便将它们注入到bean中。\n```\n\n\n## 参考\n\nhttp://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析","url":"/2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析/","content":"## 前言\n在实际项目开发中，Mybatis一般都是与Spring集成配合使用的，Mybatis与Spring集成需要另一个项目`https://github.com/mybatis/spring`，该项目提供了Mybatis与Spring的集成实现，Mybatis与Spring的集成实现有两种方式，一种是通过XML配置，另一种是通过注解的信息进行配置，这一章节来介绍如何通过XML的方式来在Spring中集成Mybatis及实现原理\n\n### 开始集成\n* 在Spring环境中集成MyBatis\n\n* 添加依赖\n```xml\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>31-SNAPSHOT</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.0-SNAPSHOT</version>\n    </dependency>\n```\n* 添加xml配置\n```xml\n    <!-- 数据库连接池 -->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\n          init-method=\"init\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"${driver.encryption}\"/>\n        <property name=\"url\" value=\"${url.encryption}\"/>\n        <property name=\"username\" value=\"${user.encryption}\"/>\n        <property name=\"password\" value=\"${password.encryption}\"/>\n        <property name=\"initialSize\" value=\"1\"/>\n        <property name=\"minIdle\" value=\"1\"/>\n        <property name=\"maxActive\" value=\"20\"/>\n        <property name=\"maxWait\" value=\"60000\"/>\n        <property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/>\n        <property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/>\n        <property name=\"validationQuery\" value=\"SELECT 1 FROM DUAL\"/>\n        <property name=\"testWhileIdle\" value=\"true\"/>\n        <property name=\"testOnBorrow\" value=\"false\"/>\n        <property name=\"testOnReturn\" value=\"false\"/>\n        <property name=\"poolPreparedStatements\" value=\"true\"/>\n        <property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\"/>\n        <property name=\"filters\" value=\"stat,wall,log4j\"/>\n        <property name=\"connectionProperties\">\n            <value>clientEncoding=UTF-8</value>\n        </property>\n    </bean>\n\n    <!-- 配置SqlSessionFactory对象 -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.songsy.admin.entity\"/>\n        <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\n    </bean>\n\n    <!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\n        <property name=\"basePackage\" value=\"com.songsy.admin.dao\"></property>\n    </bean>\n\n\n    <!-- (事务管理)transaction manager, use JtaTransactionManager for global tx -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n```\n### 实现解析\n#### dataSource 配置数据源 \n* 在Spring框架中有如下3种获得DataSource对象的方法:\n1. 从JNDI获得DataSource\n2. 从第三方的连接池获得DataSource\n3. 使用DriverManagerDataSource获得DataSource\n\n* 用户可以根据需要选择不同的数据源配置\n\n#### 使用 SqlSessionFactoryBean 来创建`SqlSession`工厂\n\n* 在基本的 `MyBatis` 中,`session` 工厂可以使用 `SqlSessionFactoryBuilder` 来创建。而在 `MyBatis-Spring` 中,则使用 `SqlSessionFactoryBean` 来替代。\n\n\n* `SqlSessionFactoryBean.java`\n```java\npublic class SqlSessionFactoryBean implements FactoryBean<SqlSessionFactory>, InitializingBean, ApplicationListener<ApplicationEvent> {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean.class);\n\n  private Resource configLocation;\n\n  private Configuration configuration;\n\n  private Resource[] mapperLocations;\n\n  private DataSource dataSource;\n\n  private TransactionFactory transactionFactory;\n\n  private Properties configurationProperties;\n\n  private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();\n\n  private SqlSessionFactory sqlSessionFactory;\n\n  //EnvironmentAware requires spring 3.1\n  private String environment = SqlSessionFactoryBean.class.getSimpleName();\n\n  private boolean failFast;\n\n  private Interceptor[] plugins;\n\n  private TypeHandler<?>[] typeHandlers;\n\n  private String typeHandlersPackage;\n\n  private Class<?>[] typeAliases;\n\n  private String typeAliasesPackage;\n\n  private Class<?> typeAliasesSuperType;\n\n  //issue #19. No default provider.\n  private DatabaseIdProvider databaseIdProvider;\n\n  private Class<? extends VFS> vfs;\n\n  private Cache cache;\n\n  private ObjectFactory objectFactory;\n\n  private ObjectWrapperFactory objectWrapperFactory;\n  \n  @Override\n  public void afterPropertiesSet() throws Exception {\n    notNull(dataSource, \"Property 'dataSource' is required\");\n    notNull(sqlSessionFactoryBuilder, \"Property 'sqlSessionFactoryBuilder' is required\");\n    state((configuration == null && configLocation == null) || !(configuration != null && configLocation != null),\n           \"Property 'configuration' and 'configLocation' can not specified with together\");\n   \n    this.sqlSessionFactory = buildSqlSessionFactory();\n   }\n    \n   ...\n\n```\n* 要注意 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口,这就说明了由 Spring 最终创建的 bean 不是 SqlSessionFactoryBean 本身, 。 而是工厂类的 getObject()返回的方法的结果。这种情况下,Spring 将会在应用启动时为你 创建 SqlSessionFactory 对象,然后将它以 SqlSessionFactory 为名来存储。在 Java 中, 相同的代码是:\n```java\n    SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();\n    SqlSessionFactory sessionFactory = factoryBean.getObject();\n```\n\n* 关注`afterPropertiesSet` 方法，这个方法将在`Spring`将所有的属性被初始化后调用，只需要实现`InitializingBean`接口就行，里面的`buildSqlSessionFactory();` 方法，此方法是构建`SqlSessionFactory`的主体方法\n```java\n  protected SqlSessionFactory buildSqlSessionFactory() throws IOException {\n\n    Configuration configuration;\n\n    XMLConfigBuilder xmlConfigBuilder = null;\n    if (this.configuration != null) {\n      configuration = this.configuration;\n      if (configuration.getVariables() == null) {\n        configuration.setVariables(this.configurationProperties);\n      } else if (this.configurationProperties != null) {\n        configuration.getVariables().putAll(this.configurationProperties);\n      }\n    } else if (this.configLocation != null) {\n      // 解析Mybatis配置文件\n      xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties);\n      configuration = xmlConfigBuilder.getConfiguration();\n    } else {\n      LOGGER.debug(() -> \"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration\");\n      configuration = new Configuration();\n      if (this.configurationProperties != null) {\n        configuration.setVariables(this.configurationProperties);\n      }\n    }\n  \n    if (this.objectFactory != null) {\n      configuration.setObjectFactory(this.objectFactory);\n    }\n\n    if (this.objectWrapperFactory != null) {\n      configuration.setObjectWrapperFactory(this.objectWrapperFactory);\n    }\n\n    if (this.vfs != null) {\n      configuration.setVfsImpl(this.vfs);\n    }\n    // 基于包名注册别名\n    if (hasLength(this.typeAliasesPackage)) {\n      String[] typeAliasPackageArray = tokenizeToStringArray(this.typeAliasesPackage,\n          ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n      for (String packageToScan : typeAliasPackageArray) {\n        configuration.getTypeAliasRegistry().registerAliases(packageToScan,\n                typeAliasesSuperType == null ? Object.class : typeAliasesSuperType);\n        LOGGER.debug(() -> \"Scanned package: '\" + packageToScan + \"' for aliases\");\n      }\n    }\n    // 注册别名\n    if (!isEmpty(this.typeAliases)) {\n      for (Class<?> typeAlias : this.typeAliases) {\n        configuration.getTypeAliasRegistry().registerAlias(typeAlias);\n        LOGGER.debug(() -> \"Registered type alias: '\" + typeAlias + \"'\");\n      }\n    }\n    // 添加插件\n    if (!isEmpty(this.plugins)) {\n      for (Interceptor plugin : this.plugins) {\n        configuration.addInterceptor(plugin);\n        LOGGER.debug(() -> \"Registered plugin: '\" + plugin + \"'\");\n      }\n    }\n    // 基于包名注册类型处理器\n    if (hasLength(this.typeHandlersPackage)) {\n      String[] typeHandlersPackageArray = tokenizeToStringArray(this.typeHandlersPackage,\n          ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);\n      for (String packageToScan : typeHandlersPackageArray) {\n        configuration.getTypeHandlerRegistry().register(packageToScan);\n        LOGGER.debug(() -> \"Scanned package: '\" + packageToScan + \"' for type handlers\");\n      }\n    }\n    // 添加类型处理器\n    if (!isEmpty(this.typeHandlers)) {\n      for (TypeHandler<?> typeHandler : this.typeHandlers) {\n        configuration.getTypeHandlerRegistry().register(typeHandler);\n        LOGGER.debug(() -> \"Registered type handler: '\" + typeHandler + \"'\");\n      }\n    }\n\n    if (this.databaseIdProvider != null) {//fix #64 set databaseId before parse mapper xmls\n      try {\n        configuration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource));\n      } catch (SQLException e) {\n        throw new NestedIOException(\"Failed getting a databaseId\", e);\n      }\n    }\n\n    if (this.cache != null) {\n      configuration.addCache(this.cache);\n    }\n\n    if (xmlConfigBuilder != null) {\n      try {\n        xmlConfigBuilder.parse();\n        LOGGER.debug(() -> \"Parsed configuration file: '\" + this.configLocation + \"'\");\n      } catch (Exception ex) {\n        throw new NestedIOException(\"Failed to parse config resource: \" + this.configLocation, ex);\n      } finally {\n        ErrorContext.instance().reset();\n      }\n    }\n\n    if (this.transactionFactory == null) {\n      this.transactionFactory = new SpringManagedTransactionFactory();\n    }\n\n    configuration.setEnvironment(new Environment(this.environment, this.transactionFactory, this.dataSource));\n    // 解析Mapper\n    if (!isEmpty(this.mapperLocations)) {\n      for (Resource mapperLocation : this.mapperLocations) {\n        if (mapperLocation == null) {\n          continue;\n        }\n\n        try {\n          XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(),\n              configuration, mapperLocation.toString(), configuration.getSqlFragments());\n          xmlMapperBuilder.parse();\n        } catch (Exception e) {\n          throw new NestedIOException(\"Failed to parse mapping resource: '\" + mapperLocation + \"'\", e);\n        } finally {\n          ErrorContext.instance().reset();\n        }\n        LOGGER.debug(() -> \"Parsed mapper file: '\" + mapperLocation + \"'\");\n      }\n    } else {\n      LOGGER.debug(() -> \"Property 'mapperLocations' was not specified or no matching resources found\");\n    }\n\n    return this.sqlSessionFactoryBuilder.build(configuration);\n  }\n```\n\n* 如下配置可以看到设置了数据源`dataSource`，指定了Mybatis的配置文件`mybatis-config.xml`，配置了别名包路径`typeAliasesPackage`，及Mapper文件的路径\n```xml\n    <!-- 配置SqlSessionFactory对象 -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.songsy.admin.entity\"/>\n        <property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/>\n    </bean>\n```\n* basePackage 属性是让你为映射器接口文件设置基本的包路径。 你可以使用分号或逗号 作为分隔符设置多于一个的包路径。每个映射器将会在指定的包路径中递归地被搜索到。\n\n* `SqlSessionFactory` 有一个单独的必须属性,就是 `JDBC` 的 `DataSource`。这可以是任意 的 `DataSource`,其配置应该和其它 `Spring` 数据库连接是一样的。\n\n* 要注意这个配置文件不需要是一个完整的 `MyBatis` 配置。确切地说,任意环境,数据源 和 `MyBatis` 的事务管理器都会被忽略。`SqlSessionFactoryBean` 会创建它自己的,使用这些 值定制 `MyBatis` 的 `Environment` 时是需要的。\n\n#### 使用 MapperScannerConfigurer 来扫描Mapper \n* 使用`MapperScannerConfigurer`来注册所有的映射器，它将会查找类路径下的映射器并自动将它们创建成`MapperFactoryBean`，把`SqlSession`或者`SqlSessionFactory`注入进去\n\n![image](/images/server/mybatis/MapperScannerConfigurer.png)\n\n* `MapperScannerConfigurer`实现了 `BeanDefinitionRegistryPostProcessor`接口，如果实现了该接口，那么说明在`Spring Application`初始化的时候将会调用下面的方法\n```xml\n  @Override\n  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {\n    if (this.processPropertyPlaceHolders) {\n      // 处理PropertyResourceConfigurers 加载属性配置问题\n      processPropertyPlaceHolders();\n    }\n\n    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);\n    scanner.setAddToConfig(this.addToConfig);\n    scanner.setAnnotationClass(this.annotationClass);\n    scanner.setMarkerInterface(this.markerInterface);\n    scanner.setSqlSessionFactory(this.sqlSessionFactory);\n    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);\n    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);\n    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);\n    scanner.setResourceLoader(this.applicationContext);\n    scanner.setBeanNameGenerator(this.nameGenerator);\n    scanner.registerFilters();\n    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));\n  }\n```\n* 从上面代码可以看到是通过`ClassPathMapperScanner` 这个类来实现解析的，重点关注`scanner.scan()` 方法，进入该方法，因为`ClassPathMapperScanner`继承了`ClassPathBeanDefinitionScanner` 所以这里调用的是`ClassPathBeanDefinitionScanner`这个类的`scan()`方法，可以看到第二行`doScan(basePackages);` 这个方法是`ClassPathMapperScanner` 的本地方法，该方法重载了`ClassPathBeanDefinitionScanner`的`doScan`方法\n```java\n\tpublic int scan(String... basePackages) {\n\t\tint beanCountAtScanStart = this.registry.getBeanDefinitionCount();\n\n\t\tdoScan(basePackages);\n\n\t\t// Register annotation config processors, if necessary.\n\t\tif (this.includeAnnotationConfig) {\n\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n\t\t}\n\n\t\treturn (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);\n\t}\n```\n* 进入`doScan(basePackages);` 返回到`ClassPathMapperScanner` 这个类，这里是实现MapperScan的核心方法，可以看到通过Spring 的`ClassPathBeanDefinitionScanner` 类来生成`BeanDefinitionHolder`，这里是一个接口一个`BeanDefinitionHolder`\n```java\n  @Override\n  public Set<BeanDefinitionHolder> doScan(String... basePackages) {\n    // 通过Spring 的ClassPathBeanDefinitionScanner 类来生成BeanDefinitionHolder\n    Set<BeanDefinitionHolder> beanDefinitions = super.doScan(basePackages);\n\n    if (beanDefinitions.isEmpty()) {\n      LOGGER.warn(() -> \"No MyBatis mapper was found in '\" + Arrays.toString(basePackages) + \"' package. Please check your configuration.\");\n    } else {\n      // 在这里完成对Spring Bean的属性配置\n      processBeanDefinitions(beanDefinitions);\n    }\n    return beanDefinitions;\n  }\n```\n* 进入`processBeanDefinitions(beanDefinitions);` 方法，关注`definition.setBeanClass(this.mapperFactoryBean.getClass());`这一行，可以看到这里设置了Mapper类的Bean，实际的源头Bean是`MapperFactoryBean`\n```java\n  private void processBeanDefinitions(Set<BeanDefinitionHolder> beanDefinitions) {\n    GenericBeanDefinition definition;\n    for (BeanDefinitionHolder holder : beanDefinitions) {\n      definition = (GenericBeanDefinition) holder.getBeanDefinition();\n      String beanClassName = definition.getBeanClassName();\n      LOGGER.debug(() -> \"Creating MapperFactoryBean with name '\" + holder.getBeanName()\n          + \"' and '\" + beanClassName + \"' mapperInterface\");\n\n      // the mapper interface is the original class of the bean\n      // but, the actual class of the bean is MapperFactoryBean\n      definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59\n      // 设置了Mapper类的Bean，实际的源头Bean是MapperFactoryBean，Mapper是由该bean生成\n      definition.setBeanClass(this.mapperFactoryBean.getClass());\n\n      definition.getPropertyValues().add(\"addToConfig\", this.addToConfig);\n\n      boolean explicitFactoryUsed = false;\n      if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) {\n        definition.getPropertyValues().add(\"sqlSessionFactory\", new RuntimeBeanReference(this.sqlSessionFactoryBeanName));\n        explicitFactoryUsed = true;\n      } else if (this.sqlSessionFactory != null) {\n        definition.getPropertyValues().add(\"sqlSessionFactory\", this.sqlSessionFactory);\n        explicitFactoryUsed = true;\n      }\n\n      if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) {\n        if (explicitFactoryUsed) {\n          LOGGER.warn(() -> \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\");\n        }\n        definition.getPropertyValues().add(\"sqlSessionTemplate\", new RuntimeBeanReference(this.sqlSessionTemplateBeanName));\n        explicitFactoryUsed = true;\n      } else if (this.sqlSessionTemplate != null) {\n        if (explicitFactoryUsed) {\n          LOGGER.warn(() -> \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\");\n        }\n        definition.getPropertyValues().add(\"sqlSessionTemplate\", this.sqlSessionTemplate);\n        explicitFactoryUsed = true;\n      }\n\n      if (!explicitFactoryUsed) {\n        LOGGER.debug(() -> \"Enabling autowire by type for MapperFactoryBean with name '\" + holder.getBeanName() + \"'.\");\n        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);\n      }\n    }\n  }\n```\n* `MapperScannerConfigurer`不需要指定`SqlSessionFactory` 或`SqlSessionTemplate`,`MapperScannerConfigurer` 将会创建 `MapperFactoryBean`之后自动装配，如果你使用了一个以上的 DataSource ,那么自动装配可能会失效 。这种情况下你可以使用 `SqlSessionFactoryBeanName` 或 `SqlSessionTemplateBeanName` 属性来设置正确的 `Bean` 名 称来使用\n\n* 下面来看一下`MapperFactoryBean`，可以看到`getObject()`方法调用的是 `SqlSessionDaoSupport`类中 `SqlSessionTemplate` 类的`getMapper(this.mapperInterface);`方法，该Bean将会在这里返回了Mapper接口的动态代理类\n```java\npublic class MapperFactoryBean<T> extends SqlSessionDaoSupport implements FactoryBean<T> {\n\n  private Class<T> mapperInterface;\n\n  private boolean addToConfig = true;\n\n  public MapperFactoryBean() {\n    //intentionally empty \n  }\n  \n  public MapperFactoryBean(Class<T> mapperInterface) {\n    this.mapperInterface = mapperInterface;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  protected void checkDaoConfig() {\n    super.checkDaoConfig();\n\n    notNull(this.mapperInterface, \"Property 'mapperInterface' is required\");\n\n    Configuration configuration = getSqlSession().getConfiguration();\n    if (this.addToConfig && !configuration.hasMapper(this.mapperInterface)) {\n      try {\n        configuration.addMapper(this.mapperInterface);\n      } catch (Exception e) {\n        logger.error(\"Error while adding the mapper '\" + this.mapperInterface + \"' to configuration.\", e);\n        throw new IllegalArgumentException(e);\n      } finally {\n        ErrorContext.instance().reset();\n      }\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public T getObject() throws Exception {\n    return getSqlSession().getMapper(this.mapperInterface);\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public Class<T> getObjectType() {\n    return this.mapperInterface;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public boolean isSingleton() {\n    return true;\n  }\n\n  //------------- mutators --------------\n\n  /**\n   * Sets the mapper interface of the MyBatis mapper\n   *\n   * @param mapperInterface class of the interface\n   */\n  public void setMapperInterface(Class<T> mapperInterface) {\n    this.mapperInterface = mapperInterface;\n  }\n\n  /**\n   * Return the mapper interface of the MyBatis mapper\n   *\n   * @return class of the interface\n   */\n  public Class<T> getMapperInterface() {\n    return mapperInterface;\n  }\n\n  /**\n   * If addToConfig is false the mapper will not be added to MyBatis. This means\n   * it must have been included in mybatis-config.xml.\n   * <p>\n   * If it is true, the mapper will be added to MyBatis in the case it is not already\n   * registered.\n   * <p>\n   * By default addToConfig is true.\n   *\n   * @param addToConfig a flag that whether add mapper to MyBatis or not\n   */\n  public void setAddToConfig(boolean addToConfig) {\n    this.addToConfig = addToConfig;\n  }\n\n  /**\n   * Return the flag for addition into MyBatis config.\n   *\n   * @return true if the mapper will be added to MyBatis in the case it is not already\n   * registered.\n   */\n  public boolean isAddToConfig() {\n    return addToConfig;\n  }\n}\n```\n* `MapperFactoryBean` 创建的代理类实现了 `UserMapper` 接口,并且注入到应用程序中。 因为代理创建在运行时环境中(Runtime,译者注),那么指定的映射器必须是一个接口,而不是一个具体的实现类\n\n* `SqlSessionTemplate` 是`MyBatis-Spring`的核心。这个类负责管理`MyBatis`的`SqlSession`,调用MyBatis的SQL方法。`SqlSessionTemplate`是线程安全的，可以被多个DAO所共享使用\n\n```java\npublic class SqlSessionTemplate implements SqlSession, DisposableBean {\n\n  private final SqlSessionFactory sqlSessionFactory;\n\n  private final ExecutorType executorType;\n  // SqlSession代理\n  private final SqlSession sqlSessionProxy;\n\n  private final PersistenceExceptionTranslator exceptionTranslator;\n\n  /**\n   * Constructs a Spring managed SqlSession with the {@code SqlSessionFactory}\n   * provided as an argument.\n   *\n   * @param sqlSessionFactory a factory of SqlSession\n   */\n  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n    this(sqlSessionFactory, sqlSessionFactory.getConfiguration().getDefaultExecutorType());\n  }\n\n  /**\n   * Constructs a Spring managed SqlSession with the {@code SqlSessionFactory}\n   * provided as an argument and the given {@code ExecutorType}\n   * {@code ExecutorType} cannot be changed once the {@code SqlSessionTemplate}\n   * is constructed.\n   *\n   * @param sqlSessionFactory a factory of SqlSession\n   * @param executorType an executor type on session\n   */\n  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType) {\n    this(sqlSessionFactory, executorType,\n        new MyBatisExceptionTranslator(\n            sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), true));\n  }\n\n  /**\n   * Constructs a Spring managed {@code SqlSession} with the given\n   * {@code SqlSessionFactory} and {@code ExecutorType}.\n   * A custom {@code SQLExceptionTranslator} can be provided as an\n   * argument so any {@code PersistenceException} thrown by MyBatis\n   * can be custom translated to a {@code RuntimeException}\n   * The {@code SQLExceptionTranslator} can also be null and thus no\n   * exception translation will be done and MyBatis exceptions will be\n   * thrown\n   *\n   * @param sqlSessionFactory a factory of SqlSession\n   * @param executorType an executor type on session\n   * @param exceptionTranslator a translator of exception\n   */\n  public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,\n      PersistenceExceptionTranslator exceptionTranslator) {\n\n    notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\");\n    notNull(executorType, \"Property 'executorType' is required\");\n\n    this.sqlSessionFactory = sqlSessionFactory;\n    this.executorType = executorType;\n    this.exceptionTranslator = exceptionTranslator;\n    // 形成SqlSession代理类\n    this.sqlSessionProxy = (SqlSession) newProxyInstance(\n        SqlSessionFactory.class.getClassLoader(),\n        new Class[] { SqlSession.class },\n        new SqlSessionInterceptor());\n  }\n\n  /**\n   * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession\n   * Proxy needed to route MyBatis method calls to the proper SqlSession got\n   * from Spring's Transaction Manager\n   * It also unwraps exceptions thrown by {@code Method#invoke(Object, Object...)} to\n   * pass a {@code PersistenceException} to the {@code PersistenceExceptionTranslator}.\n   */\n  private class SqlSessionInterceptor implements InvocationHandler {\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n      // 每次新生成一个SqlSession，一次调用一个SqlSession\n      SqlSession sqlSession = getSqlSession(\n          SqlSessionTemplate.this.sqlSessionFactory,\n          SqlSessionTemplate.this.executorType,\n          SqlSessionTemplate.this.exceptionTranslator);\n      try {\n        Object result = method.invoke(sqlSession, args);\n        // 判断是否事务\n        if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) {\n          // force commit even on non-dirty sessions because some databases require\n          // a commit/rollback before calling close()\n          // 没有使用事务\n          sqlSession.commit(true);\n        }\n        return result;\n      } catch (Throwable t) {\n        Throwable unwrapped = unwrapThrowable(t);\n        if (SqlSessionTemplate.this.exceptionTranslator != null && unwrapped instanceof PersistenceException) {\n          // release the connection to avoid a deadlock if the translator is no loaded. See issue #22\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n          sqlSession = null;\n          Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);\n          if (translated != null) {\n            unwrapped = translated;\n          }\n        }\n        throw unwrapped;\n      } finally {\n        if (sqlSession != null) {\n          // 关闭SqlSession\n          closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory);\n        }\n      }\n    }\n  }\n  \n  ...\n  \n```\n* `SqlSessionTemplate` 自动装配实现\n\nTODO\n\n## 总结\n* `SqlSessionFactory` 为什么能被`Spring Ioc`容器管理的原因是因为`FactoryBean`这个接口，这是个支持泛型的接口，Spring 将会在应用启动时为你 创建`SqlSessionFactory`对象,然后将它以 `SqlSessionFactory`为名来存储。当把这个bean注入到Spring中去了以后，IOC容器中的其他类型就可以拿到`SqlSession`实例了，就可以进行相关的SQL执行任务了。\n* 当`SqlSessionFactory` 被`Spring`管理之后，如果单纯的使用`Mybatis`的话，是使用`session.getMapper(UserMapper.class)`来获取`mapper`的，但是现在在Spring环境中一般都是通过如下形式来调用的\n```java\n    @Autowire\n    private UserMapper userMapper;\n```\n* 所以`Spring Mybatis` 通过`MapperScannerConfigurer` 来将各个`UserMapper RoleMapper...`注册成为`Spring bean` (MapperFactoryBean)，由`MapperFactoryBean`来生成Mapper的代理类对象\n\n\n\n## 参考\n\nhttp://www.mybatis.org/spring/zh/factorybean.html\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十七)结果映射DefaultResultSetHandler","url":"/2018/12/09/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十七)结果映射DefaultResultSetHandler/","content":"## 前言\n上一章节介绍了Mybatis的参数绑定处理，本章将介绍Mybatis的结果映射过程，有执行就应该有结果，那Mybaits是怎样处理Jdbc返回的结果，并将结果映射成我们需要的对象呢？\n\n## 结果映射解析\n \n### 原生Jdbc结果映射\n\n> 还是老套路，在介绍Mybatis结果映射处理之前先来看一下原生Jdbc结果映射是怎样处理的，可以看到通过迭代`resultSet`并根据列名来获取的值\n```java\nresultSet=statement.executeQuery(sql);\nwhile (resultSet.next()){\n    String loginName=resultSet.getString(\"loginName\");\n    String userName=resultSet.getString(\"userName\");\n    String password=resultSet.getString(\"password\");\n    int sex=resultSet.getInt(\"sex\");\n}\n```\n### Mybatis结果映射解析\n#### 下面还是通过一个示例来介绍\n* 测试用例\n\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 得到SqlSession\nSqlSession sqlSession = sqlSessionFactory.openSession();\n// 得到Mapper\nUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);\nUser user = new User();\nuser.setUsername(\"admin\");\nSystem.out.println(userMapper1.selectSelective(user));\n```\n\n* xml 配置\n\n```java\n    <select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\">\n        SELECT\n          *\n        FROM\n          sys_user\n        <where>\n            <if test=\"id != null\">\n                AND id = #{id}\n            </if>\n            <if test=\"username != null and username != ''\">\n                AND username = #{username}\n            </if>\n            <if test=\"password != null\">\n                AND password = #{password}\n            </if>\n        </where>\n    </select>\n```\n* 还是打入断点进入`SimpleExecutor` 的 `doQuery` 方法\n```java\n  @Override\n  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n      Configuration configuration = ms.getConfiguration();\n      // 新建一个StatementHandler\n      // 这里看到ResultHandler传入了\n      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n      // 准备语句\n      stmt = prepareStatement(handler, ms.getStatementLog());\n      // StatementHandler.query\n      return handler.<E>query(stmt, resultHandler);\n    } finally {\n      closeStatement(stmt);\n    }\n  }\n```\n* 上一章节已经完成了`stmt = prepareStatement(handler, ms.getStatementLog());`操作，这一章节来处理`return handler.<E>query(stmt, resultHandler);`\n\n* 进入该方法之后转到 `RoutingStatementHandler` 之后又转入 `PreparedStatementHandler` 进入`query` 方法，如下如可以看到又出现了Jdbc代码`ps.execute();`\n```java\n  @Override\n  public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {\n    PreparedStatement ps = (PreparedStatement) statement;\n    ps.execute();\n    return resultSetHandler.<E> handleResultSets(ps);\n  }\n```\n* `execute` 完成之后就是处理结果集了`resultSetHandler.<E> handleResultSets(ps)`， 进入该方法之后进入到`DefaultResultSetHandler` 类的`handleResultSets` 方法，\n以下代码可以知道数据结果都是存放在`multipleResults` 里面\n\n```java\n  /**\n   * 处理ResultSets 并返回结果集\n   * @param stmt\n   * @return\n   * @throws SQLException\n   */\n  @Override\n  public List<Object> handleResultSets(Statement stmt) throws SQLException {\n    ErrorContext.instance().activity(\"handling results\").object(mappedStatement.getId());\n    // 存放所有数据\n    final List<Object> multipleResults = new ArrayList<Object>();\n\n    int resultSetCount = 0;\n    ResultSetWrapper rsw = getFirstResultSet(stmt);\n    // 由MappedStatement 获取ResultMap\n    List<ResultMap> resultMaps = mappedStatement.getResultMaps();\n    // 一般resultMaps里只有一个元素\n    int resultMapCount = resultMaps.size();\n    validateResultMapsCount(rsw, resultMapCount);\n    while (rsw != null && resultMapCount > resultSetCount) {\n      ResultMap resultMap = resultMaps.get(resultSetCount);\n      // 处理结果集\n      handleResultSet(rsw, resultMap, multipleResults, null);\n      rsw = getNextResultSet(stmt);\n      cleanUpAfterHandlingResultSet();\n      resultSetCount++;\n    }\n\n    String[] resultSets = mappedStatement.getResulSets();\n    if (resultSets != null) {\n      while (rsw != null && resultSetCount < resultSets.length) {\n        ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]);\n        if (parentMapping != null) {\n          String nestedResultMapId = parentMapping.getNestedResultMapId();\n          ResultMap resultMap = configuration.getResultMap(nestedResultMapId);\n          handleResultSet(rsw, resultMap, null, parentMapping);\n        }\n        rsw = getNextResultSet(stmt);\n        cleanUpAfterHandlingResultSet();\n        resultSetCount++;\n      }\n    }\n    return collapseSingleResultList(multipleResults);\n  }\n```\n* 继续跳入`handleResultSet(rsw, resultMap, multipleResults, null);` ，可以看到这行代码`multipleResults.add(defaultResultHandler.getResultList());` 将结果赋值到了`multipleResults`，下面的方法对`resultHandler` 进行了判断，我们现在是没有指定`ResultHandler`所以这里该值为`null`，将跳入默认的`ResultHandler` 处理类\n```java\n  // 处理结果集\n  private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List<Object> multipleResults, ResultMapping parentMapping) throws SQLException {\n    try {\n      if (parentMapping != null) {\n        handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping);\n      } else {\n        if (resultHandler == null) {\n          // 如果没有resultHandler\n          // 新建DefaultResultHandler\n          DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory);\n          // 调用自己的handleRowValues\n          handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);\n          // 得到记录的list\n          multipleResults.add(defaultResultHandler.getResultList());\n        } else {\n          //如果有resultHandler\n          handleRowValues(rsw, resultMap, resultHandler, rowBounds, null);\n        }\n      }\n    } finally {\n      //最后别忘了关闭结果集，这个居然出bug了\n      // issue #228 (close resultsets)\n      closeResultSet(rsw.getResultSet());\n    }\n  }\n```\n* 跳入`handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);`，这里有个是否有嵌套的结果集判读，当然如果是有的话肯定要特殊处理的\n```java\n  private void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException {\n    // 是否有嵌套的结果集\n    if (resultMap.hasNestedResultMaps()) {\n      ensureNoRowBounds();\n      checkResultHandler();\n      handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);\n    } else {\n      handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping);\n    }\n  }  \n```\n* 我们现在这没有嵌套，所以`else`进入`handleRowValuesForSimpleResultMap` 方法，可以看到这里是一行一行的处理结果，`ResultSetWrapper` 是对`ResultSet`的包装\n```java\n  /**\n   * 见方法名知 ResultMap根据处理行数据\n   * @param rsw\n   * @param resultMap\n   * @param resultHandler 结果存放在这，里面是一个List<Object>\n   * @param rowBounds\n   * @param parentMapping\n   * @throws SQLException\n   */\n  private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping)\n      throws SQLException {\n    DefaultResultContext resultContext = new DefaultResultContext();\n    skipRows(rsw.getResultSet(), rowBounds);\n    // 一行一行赋值 rsw.getResultSet().next() Jdbc\n    while (shouldProcessMoreRows(resultContext, rowBounds) && rsw.getResultSet().next()) {\n      ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null);\n      // 获取一行数据\n      Object rowValue = getRowValue(rsw, discriminatedResultMap);\n      storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet());\n    }\n  }\n```\n\n* 重点关注`Object rowValue = getRowValue(rsw, discriminatedResultMap);` 这里的处理，这里是处理一行的数据\n \n```java\n  // 核心，取得一行的值\n  private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap) throws SQLException {\n    // 实例化ResultLoaderMap(延迟加载器)\n    final ResultLoaderMap lazyLoader = new ResultLoaderMap();\n    // 调用自己的createResultObject,内部就是new一个对象(如果是简单类型，new完也把值赋进去)\n    Object resultObject = createResultObject(rsw, resultMap, lazyLoader, null);\n    if (resultObject != null && !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) {\n      // 一般不是简单类型不会有typehandler,这个if会进来\n      final MetaObject metaObject = configuration.newMetaObject(resultObject);\n      boolean foundValues = !resultMap.getConstructorResultMappings().isEmpty();\n      if (shouldApplyAutomaticMappings(resultMap, false)) {        \n        // 自动映射咯\n        // 这里把每个列的值都赋到相应的字段里去了\n    \tfoundValues = applyAutomaticMappings(rsw, resultMap, metaObject, null) || foundValues;\n      }\n      foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, null) || foundValues;\n      foundValues = lazyLoader.size() > 0 || foundValues;\n      resultObject = foundValues ? resultObject : null;\n      return resultObject;\n    }\n    return resultObject;\n  }\n```\n* 跳入`applyAutomaticMappings` 方法，可以看到这里是结果映射的核心代码，巧妙的用TypeHandler取得结果，根据columnName从ResultSet取值\n\n```java\n  /**\n   * 自动映射\n   * @param rsw 对 ResultSet 的包装\n   * @param resultMap ResultMap\n   * @param metaObject 返回的对象\n   * @param columnPrefix\n   * @return\n   * @throws SQLException\n   */\n  private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException {\n    // 得到表列名list\n    final List<String> unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix);\n    boolean foundValues = false;\n    // 一列一列数据循环赋值\n    for (String columnName : unmappedColumnNames) {\n      String propertyName = columnName;\n      if (columnPrefix != null && !columnPrefix.isEmpty()) {\n        // When columnPrefix is specified,\n        // ignore columns without the prefix.\n        if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) {\n          propertyName = columnName.substring(columnPrefix.length());\n        } else {\n          continue;\n        }\n      }\n      final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase());\n      if (property != null && metaObject.hasSetter(property)) {\n        final Class<?> propertyType = metaObject.getSetterType(property);\n        if (typeHandlerRegistry.hasTypeHandler(propertyType)) {\n          // 根据实体类字段类型获取对应的TypeHandler\n          final TypeHandler<?> typeHandler = rsw.getTypeHandler(propertyType, columnName);\n          // 巧妙的用TypeHandler取得结果，根据columnName从ResultSet取值\n          final Object value = typeHandler.getResult(rsw.getResultSet(), columnName);\n          // issue #377, call setter on nulls\n          if (value != null || configuration.isCallSettersOnNulls()) {\n            if (value != null || !propertyType.isPrimitive()) {\n              // 然后巧妙的用反射来设置到对象\n              metaObject.setValue(property, value);\n            }\n            foundValues = true;\n          }\n        }\n      }\n    }\n    return foundValues;\n  }\n```\n* 又出现了`TypeHandler`，下面的方法出现了Jdbc代码` return rs.getString(columnName);`\n\n```java\npublic class StringTypeHandler extends BaseTypeHandler<String> {\n\n\n  @Override\n  public String getNullableResult(ResultSet rs, String columnName)\n      throws SQLException {\n    return rs.getString(columnName);\n  }\n```\n\n* 在此Mybatis结果映射处理完成\n\n## 总结\n* Mybatis的参数绑定和结果映射最终处理都是通过不同的`TypeHandler`来处理的，Mybatis也支持自定义`TypeHandler` 但一般情况Mybatis提供的就可以应付常见需求了\n\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十六)参数绑定DefaultParameterHandler","url":"/2018/12/09/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十六)参数绑定DefaultParameterHandler/","content":"## 前言\nMybatis 一个重要功能是参数的自动绑定，Mybatis是怎样帮我们做好Jdbc的参数绑定的呢，这一章节来介绍Mybatis的参数绑定\n\n## 参数绑定解析\n \n### 原生Jdbc参数绑定\n\n> 在介绍Mybatis参数绑定之前先来看一下原生Jdbc参数绑定是怎样处理的，从下面的Jdbc代码可以看到，是通过下标顺序来设置参数值的，一个问号一个参数\n\n```java\nString sql = \"insert into user(sno,name,age)values(?,?,?)\";//定义一个要执行的SQL语句\nPreparedStatement ps = connection.prepareStatement(sql);\nps.setString(1,student.getSno());//设置SQL语句的第一个参数\nps.setString(2,student.getName());//设置SQL语句的第二个参数\nps.setInt(3,student.getAge());//设置SQL语句的第三个参数\n```\n### Mybatis参数绑定解析\n#### 下面通过一个示例来介绍\n\n* 测试用例，下面的代码是通过User对象来查找对应的数据，user设置了两个属性值id 和 admin\n\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 得到SqlSession\nSqlSession sqlSession = sqlSessionFactory.openSession();\n// 得到Mapper\nUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);\nUser user = new User();\nuser.setId(1);\nuser.setUsername(\"admin\");\nSystem.out.println(userMapper1.selectSelective(user));\n```\n\n* xml 配置\n\n```java\n    <select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\">\n        SELECT\n          *\n        FROM\n          sys_user\n        <where>\n            <if test=\"id != null\">\n                AND id = #{id}\n            </if>\n            <if test=\"username != null and username != ''\">\n                AND username = #{username}\n            </if>\n            <if test=\"password != null\">\n                AND password = #{password}\n            </if>\n        </where>\n    </select>\n```\n\n* 从第十五章可以知道，由传入的参数对象配合`SqlSource` 完成了动态Sql的处理， 下面是得到的结果 `SELECT * FROM sys_user WHERE id = ? AND username = ?`，这里得到了Jdbc的代码，现在要Mybatis要处理的就是这两个问号`?`\n\n![image](/images/server/mybatis/boundSql结果.png)\n\n* 还是打入断点进入`SimpleExecutor` 的 `doQuery` 方法，在这里可以看到这里新建了一个 `StatementHandler` 这个是SQL语句的执行器，在由来调度sql的参数绑定，sql执行，sql结果映射，现在重点关注`stmt = prepareStatement(handler, ms.getStatementLog());` 这一行，看方法名称就大概知道这里是sql之前预备处理\n\n```java\n  @Override\n  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n      Configuration configuration = ms.getConfiguration();\n      // 新建一个StatementHandler\n      // 这里看到ResultHandler传入了\n      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n      // 准备语句\n      stmt = prepareStatement(handler, ms.getStatementLog());\n      // StatementHandler.query\n      return handler.<E>query(stmt, resultHandler);\n    } finally {\n      closeStatement(stmt);\n    }\n  }\n```\n* 进入`stmt = prepareStatement(handler, ms.getStatementLog());` 方法，这里主要是对`Connection` 和 `sql参数` 进行了设置，继续跳入`handler.parameterize(stmt);`\n```java\n  private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {\n    Statement stmt;\n    Connection connection = getConnection(statementLog);\n    // 调用StatementHandler.prepare 设置Connection\n    stmt = handler.prepare(connection);\n    // 调用StatementHandler.parameterize 设置参数\n    handler.parameterize(stmt);\n    return stmt;\n  }\n```\n\n* 进入`handler.parameterize(stmt);`方法之后，转到 `RoutingStatementHandler` 之后又转入 `PreparedStatementHandler`，一系列的转发之后进入`DefaultParameterHandler` 类的`setParameters` 方法\n\n```java\npublic class DefaultParameterHandler implements ParameterHandler {\n\n  private final TypeHandlerRegistry typeHandlerRegistry;\n\n  private final MappedStatement mappedStatement;\n  // 参数对象\n  private final Object parameterObject;\n  // BoundSql\n  private BoundSql boundSql;\n  // 万能Configuration\n  private Configuration configuration;\n\n  public DefaultParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {\n    this.mappedStatement = mappedStatement;\n    this.configuration = mappedStatement.getConfiguration();\n    this.typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry();\n    this.parameterObject = parameterObject;\n    this.boundSql = boundSql;\n  }\n\n  @Override\n  public Object getParameterObject() {\n    return parameterObject;\n  }\n\n  // 设置参数\n  @Override\n  public void setParameters(PreparedStatement ps) throws SQLException {\n    ErrorContext.instance().activity(\"setting parameters\").object(mappedStatement.getParameterMap().getId());\n    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n    if (parameterMappings != null) {\n      // 循环设参数\n      for (int i = 0; i < parameterMappings.size(); i++) {\n        ParameterMapping parameterMapping = parameterMappings.get(i);\n        if (parameterMapping.getMode() != ParameterMode.OUT) {\n          // 如果不是OUT，才设进去\n          Object value;\n          String propertyName = parameterMapping.getProperty();\n          if (boundSql.hasAdditionalParameter(propertyName)) { // issue #448 ask first for additional params\n            // 若有额外的参数, 设为额外的参数\n            value = boundSql.getAdditionalParameter(propertyName);\n          } else if (parameterObject == null) {\n            // 若参数为null，直接设null\n            value = null;\n          } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {\n            // 若参数有相应的TypeHandler，直接设object\n            value = parameterObject;\n          } else {\n            // 除此以外，MetaObject.getValue反射取得值设进去\n            MetaObject metaObject = configuration.newMetaObject(parameterObject);\n            value = metaObject.getValue(propertyName);\n          }\n          // 类型处理器\n          TypeHandler typeHandler = parameterMapping.getTypeHandler();\n          JdbcType jdbcType = parameterMapping.getJdbcType();\n          if (value == null && jdbcType == null) {\n            // 不同类型的set方法不同，所以委派给子类的setParameter方法\n            jdbcType = configuration.getJdbcTypeForNull();\n          }\n          // 用在类型处理器进行赋值\n          typeHandler.setParameter(ps, i + 1, value, jdbcType);\n        }\n      }\n    }\n  }\n}\n```\n* 进入`setParameters` 方法之后，可以看到通过我们之前的`BoundSql` 得到 `ParamterMappings`对象，如下图可以知道是两个属性，然后下面的操作就是依次赋值了，不过这里有个特殊的地方，也是Mybatis参数绑定高明之处，就是赋值的操作是通过`TypeHandler` 来赋值的\n\n![image](/images/server/mybatis/paramterMappings.png)\n\n* 继续跳入`typeHandler.setParameter(ps, i + 1, value, jdbcType);` 来到 `IntegerTypeHandler`的 `setNonNullParameter`方法，有没有看到曙光`ps.setInt(i, parameter);` ,在这里做了Jdbc的参数绑定操作\n\n```java\npublic class IntegerTypeHandler extends BaseTypeHandler<Integer> {\n\n  @Override\n  public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType)\n      throws SQLException {\n    ps.setInt(i, parameter);\n  }\n```  \n* 同理第二个参数是字符类型，所以跳到`StringTypeHandler`\n```java\npublic class StringTypeHandler extends BaseTypeHandler<String> {\n\n  @Override\n  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType)\n      throws SQLException {\n    ps.setString(i, parameter);\n  }\n```\n\n* 在此完成Mybatis参数绑定\n\n## 总结\n* Mybatis的参数绑定是通过循环 `ParamterMappings`对象来依次对对象赋值的，具体赋值工作是对应的`TypeHandler` 来处理的，当然不同类型有不同的处理类","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十五)动态Sql实现之BoundSql","url":"/2018/12/08/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十五)动态Sql实现之BoundSql/","content":"## 前言\n上一章节介绍了`SqlSource` ，这一章节来介绍 `BoundSql`，`BoundSql` 由 `SqlSource` 生产，`BoundSql` 存放了动态sql处理后的`private String sql;`,动态内容处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数\n\n## BoundSql 介绍\n\n* 下面是 `BoundSql` 的源码，里面又对其变量的介绍\n\n```java\n/**\n * 绑定的SQL,是从SqlSource而来，将动态内容都处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数\n *\n * An actual SQL String got form an {@link SqlSource} after having processed any dynamic content.\n * The SQL may have SQL placeholders \"?\" and an list (ordered) of an parameter mappings\n * with the additional information for each parameter (at least the property name of the input object to read\n * the value from).\n * </br>\n * Can also have additional parameters that are created by the dynamic language (for loops, bind...).\n * @author Clinton Begin\n */\npublic class BoundSql {\n\n  // 处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数\n  private String sql;\n  // 参数映射对象\n  private List<ParameterMapping> parameterMappings;\n  // 外面传入的sql参数\n  private Object parameterObject;\n  // 额外参数？\n  private Map<String, Object> additionalParameters;\n  // 参数元数据\n  private MetaObject metaParameters;\n\n  public BoundSql(Configuration configuration, String sql, List<ParameterMapping> parameterMappings, Object parameterObject) {\n    this.sql = sql;\n    this.parameterMappings = parameterMappings;\n    this.parameterObject = parameterObject;\n    this.additionalParameters = new HashMap<String, Object>();\n    this.metaParameters = configuration.newMetaObject(additionalParameters);\n  }\n\n  public String getSql() {\n    return sql;\n  }\n\n  public List<ParameterMapping> getParameterMappings() {\n    return parameterMappings;\n  }\n\n  public Object getParameterObject() {\n    return parameterObject;\n  }\n\n  public boolean hasAdditionalParameter(String name) {\n    return metaParameters.hasGetter(name);\n  }\n\n  public void setAdditionalParameter(String name, Object value) {\n    metaParameters.setValue(name, value);\n  }\n\n  public Object getAdditionalParameter(String name) {\n    return metaParameters.getValue(name);\n  }\n}\n```\n\n## BoundSql 构造\n\n* `BoundSql` 由 `SqlSource` 生产，`SqlSource` 有四个实现类，但最常用的是 `DynamicSqlSource`，下面是其源码，可以看到只有一个方法`public BoundSql getBoundSql(Object parameterObject) `\n\n```java\n/**\n * 动态SQL源码\n * @author Clinton Begin\n */\npublic class DynamicSqlSource implements SqlSource {\n\n  private Configuration configuration;\n  private SqlNode rootSqlNode;\n\n  public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) {\n    this.configuration = configuration;\n    this.rootSqlNode = rootSqlNode;\n  }\n\n  // 得到绑定的SQL\n  @Override\n  public BoundSql getBoundSql(Object parameterObject) {\n    // 生成一个动态上下文\n    DynamicContext context = new DynamicContext(configuration, parameterObject);\n\t// 这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数\n    rootSqlNode.apply(context);\n\t// 调用SqlSourceBuilder\n    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n    Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass();\n\t// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法\n    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());\n\t// 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用\n    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n    for (Map.Entry<String, Object> entry : context.getBindings().entrySet()) {\n      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());\n    }\n    return boundSql;\n  }\n}\n```\n\n* 下面通过一个例子来解析 `BoundSql` 的构造\n\n> xml 配置文件\n```xml\n    <select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\">\n        SELECT\n          *\n        FROM\n          sys_user\n        <where>\n            <if test=\"id != null\">\n                AND id = #{id}\n            </if>\n            <if test=\"username != null and username != ''\">\n                AND username = #{username}\n            </if>\n            <if test=\"password != null\">\n                AND password = #{password}\n            </if>\n        </where>\n    </select>\n```\n\n> 测试用例，user对象给id和username赋值了对象\n\n```java\n        // 读取配置文件\n        File file = new File(\"src/test/java/resources/mybatis-config.xml\");\n        InputStream inputStream = new FileInputStream(file);\n        // 构建SqlSessionFactory\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n        // 得到SqlSession\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        // 得到Mapper\n        UserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);\n        User user = new User();\n        user.setId(1);\n        user.setUsername(\"admin\");\n        System.out.println(userMapper1.selectSelective(user));\n```\n\n* 打好断点进入到 `CachingExecutor` 的query方法，第一行可以看到 `BoundSql` 是由`MappedStatement` 的方法得到的，`getBoundSql` 方法只传入了参数对象，在这里是`User`对象\n\n```java\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameterObject);\n\t//query时传入一个cachekey参数\n    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);\n    return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n  }\n```\n\n* 进入`ms.getBoundSql(parameterObject);` 方法，重点关注 `BoundSql boundSql = sqlSource.getBoundSql(parameterObject);`，没错在这里出现了我们的`SqlSource`对象\n\n```java\n  public BoundSql getBoundSql(Object parameterObject) {\n\t//其实就是调用sqlSource.getBoundSql\n    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n    if (parameterMappings == null || parameterMappings.isEmpty()) {\n      boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject);\n    }\n\n    // check for nested result maps in parameter mappings (issue #30)\n    for (ParameterMapping pm : boundSql.getParameterMappings()) {\n      String rmId = pm.getResultMapId();\n      if (rmId != null) {\n        ResultMap rm = configuration.getResultMap(rmId);\n        if (rm != null) {\n          hasNestedResultMaps |= rm.hasNestedResultMaps();\n        }\n      }\n    }\n    return boundSql;\n  }\n```\n\n* 进入`sqlSource.getBoundSql(parameterObject)` 方法，这个方法是`DynamicSqlSource` 的唯一方法，当然SqlSource作用就是得到绑定后的`BoundSql`对象\n\n```java\n/**\n * 动态SQL源码\n * @author Clinton Begin\n */\npublic class DynamicSqlSource implements SqlSource {\n\n  private Configuration configuration;\n  private SqlNode rootSqlNode;\n\n  public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) {\n    this.configuration = configuration;\n    this.rootSqlNode = rootSqlNode;\n  }\n\n  // 得到绑定的SQL\n  @Override\n  public BoundSql getBoundSql(Object parameterObject) {\n    // 生成一个动态上下文\n    DynamicContext context = new DynamicContext(configuration, parameterObject);\n\t// 这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数\n    rootSqlNode.apply(context);\n\t// 调用SqlSourceBuilder\n    SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration);\n    Class<?> parameterType = parameterObject == null ? Object.class : parameterObject.getClass();\n\t// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法\n    SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());\n\t// 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用\n    BoundSql boundSql = sqlSource.getBoundSql(parameterObject);\n    for (Map.Entry<String, Object> entry : context.getBindings().entrySet()) {\n      boundSql.setAdditionalParameter(entry.getKey(), entry.getValue());\n    }\n    return boundSql;\n  }\n}\n```\n\n* 先看`rootSqlNode.apply(context);` 这行代码，打开断点进入会发现这里依次调用list里每个元素的apply方法，这里是实现动态SQL的关键，如果有嵌套的话也会嵌套执行里面的apply方法\n\n![image](/images/server/mybatis/MixedSqlNode.png)\n\n> 静态sqlNode 的apply方法就是直接 appendSql\n\n```java\npublic class StaticTextSqlNode implements SqlNode {\n  private String text;\n\n  public StaticTextSqlNode(String text) {\n    this.text = text;\n  }\n\n  @Override\n  public boolean apply(DynamicContext context) {\n\t//将文本加入context\n    context.appendSql(text);\n    return true;\n  }\n\n}\n```\n\n> if SQL节点的apply方法 会做一个判断，如果 `test=\"id != null\"` 这个表达式为true就会 `contents.apply(context);` 添加到`DynamicContext`中，`DynamicContext` 内部成员 `StringBuilder sqlBuilder` 来存放解析后的sql\n \n```java\n/**\n * if SQL节点\n *\n */\npublic class IfSqlNode implements SqlNode {\n  private ExpressionEvaluator evaluator;\n  private String test;\n  private SqlNode contents;\n\n  public IfSqlNode(SqlNode contents, String test) {\n    this.test = test;\n    this.contents = contents;\n    this.evaluator = new ExpressionEvaluator();\n  }\n\n  @Override\n  public boolean apply(DynamicContext context) {\n    // 如果满足条件，则apply，并返回true\n    if (evaluator.evaluateBoolean(test, context.getBindings())) {\n      contents.apply(context);\n      return true;\n    }\n    return false;\n  }\n\n}\n```\n* `rootSqlNode.apply(context);` 处理完成之后就会得到拼接后的sql如下图所示，可以看到这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数\n\n![image](/images/server/mybatis/DynamicContext.png)\n\n* `SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());` 这个方法是解析完了就把那些参数都替换成?，也就是最基本的JDBC的SQL写法，这个方法在以后章节将介绍\n\n* 最终的到的结果(`BoundSql`)如下图所示\n\n![image](/images/server/mybatis/boundSql结果.png)\n\n## 总结\n* `BoundSql` 由 `SqlSource` 构造而成，最终得到的是JDBC的SQL，而实现动态Sql的关键是 各个`SqlNode`的 `apply`方法\n* 通过源码可以看到Mybatis动态sql设计巧妙，分工明确","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十四)动态Sql实现之SqlSource","url":"/2018/12/08/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十四)动态Sql实现之SqlSource/","content":"## 前言\n从本章开始将介绍Mybatis是怎样实现动态sql的，介绍动态sql实现之前先介绍几个重要对象`SqlSource`，`SqlNode` ，`BoundSql` ,本章开始介绍`SqlSource`对象，\n\n前面第九章及第十章介绍了`SqlSource`的构造过程，在xml配置的select update节点的sql将会构造成 `SqlSource`，其 `SqlSource` 由一组`SqlNode`组成，现在来看一下`SqlSource`能做什么\n\n### SqlSource 分析\n* 查看`SqlSource` 是个接口，但他只有一个方法就是`BoundSql getBoundSql(Object parameterObject);` ，方法参数是sql的参数，然后根据参数来构造成`BoundSql`，所以他的作用是根据参数对象生产`BoundSql`，那么`BoundSql`有什么用呢，下一章节将介绍其作用\n```java\npublic interface SqlSource {\n\n  BoundSql getBoundSql(Object parameterObject);\n\n}\n```\n* 下图可以看到`SqlSource` 其实现类，主要有4种类型\n![image](/images/server/mybatis/SqlSource.gif)\n  \n1. DynamicSqlSource:处理动态sql语句。\n2. RawSqlSource：处理静态sql语句，其内部装饰StaticSqlSource。\n3. StaticSqlSource：处理静态sql，无论是静态sql，还是动态sql，最终的处理结果，都是静态sql。\n4. ProviderSqlSource:处理注解Annotation形式的sql。\n5. VelocitySqlSource:只是Mybatis的一个测试类\n\n* 举个栗子，下面是一个动态sql的xml\n```xml\n    <select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\">\n        SELECT\n          *\n        FROM\n          sys_user\n        <where>\n            <if test=\"id != null\">\n                AND id = #{id}\n            </if>\n            <if test=\"username != null and username != ''\">\n                AND username = #{username}\n            </if>\n            <if test=\"password != null\">\n                AND password = #{password}\n            </if>\n        </where>\n    </select>\n```\n* 那么解析成`SqlSource`将会是下面的样子，`SqlSource` 是存放在`MappedStatement`对象的，可以看到`SqlSource`是一堆嵌套的`SqlNode`组成\n\n![image](/images/server/mybatis/sqlSource.png)\n\n## 总结\n* 有图有栗子来理解`SqlSource` 就很形象了，有了`SqlSource`就相当于生产商品有基本原材料了，当然原材料(`SqlNode`)种类有很多，Mybatis会根据用户的需求(`**Mapper.xml`) 来采购不同的原材料","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十三)基于Mapper的二级缓存","url":"/2018/12/07/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十三)基于Mapper的二级缓存/","content":"## 前言\nmybatis的二级缓存主要是在Executor对象上来做文章，当mybatis发现你在mybatis.xml配置文件中设置了cacheEnabled=true时，mybatis在创建sqlsession时创建Executor对象，同时会对Executor加上装饰者【CacheExecutor】。CacheExecutor对于查询请求，会判断application级别的二级缓存是否有缓存结果，如果有查询结果则直接返回，如果没有再交给查询器Executor实现类，也就是【SimpleExecutor】来执行查询。再就是缓存结果，返回给用户。\n\n## 二级缓存的使用\n> 配置 mybatis-config.xml\n```xml\n    <settings>\n        <!--开启二级缓存-->\n        <setting name=\"cacheEnabled\" value=\"true\"/>\n    </settings>\n```\n> 配置Mapper xml文件，加上`<cache/>`\n```java\n    <cache/>\n```\n\n> 测试代码\n\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 得到SqlSession\nSqlSession sqlSession1 = sqlSessionFactory.openSession();\nSqlSession sqlSession2 = sqlSessionFactory.openSession();\nUserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);\nUserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);\n// 测试二级缓存\nSystem.out.println(userMapper1.selectByPrimaryKey(1));\nSystem.out.println(userMapper2.selectByPrimaryKey(1));\n```\n* 打好断点进入，这里是二级缓存的处理，从下面可以看到缓存是存放在`MappedStatement` 对象中的，所以说二级缓存是基于`Mapper`的，这是与多个`SqlSession`能够共享缓存的关键\n```java\n  public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n      throws SQLException {\n    Cache cache = ms.getCache();\n    // 默认情况下是没有开启缓存的(二级缓存).要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: <cache/>\n    // 简单的说，就是先查CacheKey，查不到再委托给实际的执行器去查\n    if (cache != null) {\n      flushCacheIfRequired(ms);\n      if (ms.isUseCache() && resultHandler == null) {\n        ensureNoOutParams(ms, parameterObject, boundSql);\n        @SuppressWarnings(\"unchecked\")\n        List<E> list = (List<E>) tcm.getObject(cache, key);\n        if (list == null) {\n          list = delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n          tcm.putObject(cache, key, list); // issue #578 and #116\n        }\n        return list;\n      }\n    }\n    return delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n  }\n```\n* 可以看到缓存放在`tcm` 变量上，打开 `TransactionalCacheManager` 类\n```java\npublic class TransactionalCacheManager {\n\n  //管理了许多TransactionalCache\n  private Map<Cache, TransactionalCache> transactionalCaches = new HashMap<Cache, TransactionalCache>();\n\n  public void clear(Cache cache) {\n    getTransactionalCache(cache).clear();\n  }\n\n  //得到某个TransactionalCache的值\n  public Object getObject(Cache cache, CacheKey key) {\n    return getTransactionalCache(cache).getObject(key);\n  }\n  \n  public void putObject(Cache cache, CacheKey key, Object value) {\n    getTransactionalCache(cache).putObject(key, value);\n  }\n\n  //提交时全部提交\n  public void commit() {\n    for (TransactionalCache txCache : transactionalCaches.values()) {\n      txCache.commit();\n    }\n  }\n\n  //回滚时全部回滚\n  public void rollback() {\n    for (TransactionalCache txCache : transactionalCaches.values()) {\n      txCache.rollback();\n    }\n  }\n\n  private TransactionalCache getTransactionalCache(Cache cache) {\n    TransactionalCache txCache = transactionalCaches.get(cache);\n    if (txCache == null) {\n      txCache = new TransactionalCache(cache);\n      transactionalCaches.put(cache, txCache);\n    }\n    return txCache;\n  }\n\n}\n```\n## 二级缓存过期策略\n* 映射语句文件中的所有 select 语句将会被缓存。\n* 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。\n* 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。\n* 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。\n* 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。\n* 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。\n\n### 二级缓存配置\n所有的这些属性都可以通过缓存元素的属性来修改。比如:\n```xml\n<cache\n  eviction=\"FIFO\"\n  flushInterval=\"60000\"\n  size=\"512\"\n  readOnly=\"true\"/>\n``` \n* 这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。\n\n可用的收回策略有: 默认的是 LRU。\n\n```xml\nLRU – 最近最少使用的:移除最长时间不被使用的对象。\nFIFO – 先进先出:按对象进入缓存的顺序来移除它们。\nSOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。\nWEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。\n```\n\n\n\nflushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。\n\nsize(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。\n\nreadOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。\n\n\n## 二级缓存设计\n\n![image]('/images/server/mybatis/level2Cache.jpg')\n\n## 总结\n* mybatis的二级缓存主要是在Executor对象上来做文章，当mybatis发现你在mybatis.xml配置文件中设置了cacheEnabled=true时，mybatis在创建sqlsession时创建Executor对象，同时会对Executor加上装饰者【CacheExecutor】。CacheExecutor对于查询请求，会判断application级别的二级缓存是否有缓存结果，如果有查询结果则直接返回，如果没有再交给查询器Executor实现类，也就是【SimpleExecutor】来执行查询。再就是缓存结果，返回给用户。\n* 避免使用二级缓存，如果出现联合查询语句，如果其中一张表发生了变化，就会出现脏数据的问题，因为缓存节点是根据namespace\n\n\n参考： http://www.mybatis.org/mybatis-3/zh\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十二)基于SqlSession的一级缓存","url":"/2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十二)基于SqlSession的一级缓存/","content":"## 前言\nMyBatis提供了一级缓存、二级缓存 这两种缓存机制，能够很好地处理和维护缓存，以提高系统的性能。本章的内容是介绍MyBatis的一级缓存，深入源码，解析MyBatis一级缓存的实现原理，二级缓存将在下一章介绍\n\n### 一级缓存的使用\n* 下面来通过代码来实践一级缓存，看看第二次查询是否使用了缓存\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 得到SqlSession\nSqlSession sqlSession = sqlSessionFactory.openSession();\n// 得到Mapper\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\nSystem.out.println(\"第一次查询: \"+userMapper.selectByPrimaryKey(1));\nSystem.out.println(\"第二次查询: \"+userMapper.selectByPrimaryKey(1));\n```\n* 上面的代码是用`SqlSession`获取了`UserMapper`，然后用`UserMapper` 进行了两次查询，打好断点进入`MapperProxy` 的`invoke` 方法\n```java\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法\n    // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行\n    if (Object.class.equals(method.getDeclaringClass())) {\n      try {\n        return method.invoke(this, args);\n      } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n      }\n    }\n    // 这里优化了，去缓存中找MapperMethod\n    final MapperMethod mapperMethod = cachedMapperMethod(method);\n    //执行\n    return mapperMethod.execute(sqlSession, args);\n  }\n```\n* 进入`mapperMethod.execute(sqlSession, args)` 之后跳呀跳进入`BaseExecutor` 的 `query` 方法，这个看到会创建一个`CacheKey`\n```java\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    // 得到绑定sql\n    BoundSql boundSql = ms.getBoundSql(parameter);\n    // 创建缓存Key\n    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);\n    // 查询\n    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);\n }\n```\n* 下面来看一下这个`key`是怎么生成的\n```java\n  //创建缓存Key\n  @Override\n  public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {\n    if (closed) {\n      throw new ExecutorException(\"Executor was closed.\");\n    }\n    CacheKey cacheKey = new CacheKey();\n    // MyBatis 对于其 Key 的生成采取规则为：[mappedStementId + offset + limit + SQL + queryParams + environment]生成一个哈希码\n    cacheKey.update(ms.getId());\n    cacheKey.update(Integer.valueOf(rowBounds.getOffset()));\n    cacheKey.update(Integer.valueOf(rowBounds.getLimit()));\n    cacheKey.update(boundSql.getSql());\n    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();\n    // mimic DefaultParameterHandler logic\n    // 模仿DefaultParameterHandler的逻辑,不再重复，请参考DefaultParameterHandler\n    for (int i = 0; i < parameterMappings.size(); i++) {\n      ParameterMapping parameterMapping = parameterMappings.get(i);\n      if (parameterMapping.getMode() != ParameterMode.OUT) {\n        Object value;\n        String propertyName = parameterMapping.getProperty();\n        if (boundSql.hasAdditionalParameter(propertyName)) {\n          value = boundSql.getAdditionalParameter(propertyName);\n        } else if (parameterObject == null) {\n          value = null;\n        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {\n          value = parameterObject;\n        } else {\n          MetaObject metaObject = configuration.newMetaObject(parameterObject);\n          value = metaObject.getValue(propertyName);\n        }\n        cacheKey.update(value);\n      }\n    }\n    if (configuration.getEnvironment() != null) {\n      // issue #176\n      cacheKey.update(configuration.getEnvironment().getId());\n    }\n    return cacheKey;\n  }   \n```\n* 得到`CacheKey` 之后 跳入`return query(ms, parameter, rowBounds, resultHandler, key, boundSql);` 在这里对一级缓存进行了处理\n```java\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId());\n    //如果已经关闭，报错\n    if (closed) {\n      throw new ExecutorException(\"Executor was closed.\");\n    }\n    //先清局部缓存，再查询.但仅查询堆栈为0，才清。为了处理递归调用\n    if (queryStack == 0 && ms.isFlushCacheRequired()) {\n      clearLocalCache();\n    }\n    List<E> list;\n    try {\n      //加一,这样递归调用到上面的时候就不会再清局部缓存了\n      queryStack++;\n      //先根据cachekey从localCache去查\n      list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;\n      if (list != null) {\n        //若查到localCache缓存，处理localOutputParameterCache\n        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n      } else {\n        //从数据库查\n        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n      }\n    } finally {\n      //清空堆栈\n      queryStack--;\n    }\n    if (queryStack == 0) {\n      //延迟加载队列中所有元素\n      for (DeferredLoad deferredLoad : deferredLoads) {\n        deferredLoad.load();\n      }\n      // issue #601\n      //清空延迟加载队列\n      deferredLoads.clear();\n      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {\n        // issue #482\n    \t//如果是STATEMENT，清本地缓存\n        clearLocalCache();\n      }\n    }\n    return list;\n  }\n```\n* 重点是下面几行代码，可以看到先根据cachekey从localCache去查，如果有就返回缓存里的数据，没有就从数据库里查\n```java\n      // 先根据cachekey从localCache去查\n      list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;\n      if (list != null) {\n        // 若查到localCache缓存，处理localOutputParameterCache\n        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n      } else {\n        // 从数据库查\n        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n      }\n```\n* 下面来看`localCache` 的本体`PerpetualCache`, 从下面的代码就可以看见其内部实现就是`Map<Object, Object> cache`\n```java\n/**\n * 永久缓存\n * 一旦存入就一直保持\n * @author Clinton Begin\n */\npublic class PerpetualCache implements Cache {\n\n  // 每个永久缓存有一个ID来识别\n  private String id;\n\n  // 内部就是一个HashMap,所有方法基本就是直接调用HashMap的方法\n  private Map<Object, Object> cache = new HashMap<Object, Object>();\n\n  public PerpetualCache(String id) {\n    this.id = id;\n  }\n\n  @Override\n  public String getId() {\n    return id;\n  }\n\n  @Override\n  public int getSize() {\n    return cache.size();\n  }\n\n  @Override\n  public void putObject(Object key, Object value) {\n    cache.put(key, value);\n  }\n\n  @Override\n  public Object getObject(Object key) {\n    return cache.get(key);\n  }\n\n  @Override\n  public Object removeObject(Object key) {\n    return cache.remove(key);\n  }\n\n  @Override\n  public void clear() {\n    cache.clear();\n  }\n\n  @Override\n  public ReadWriteLock getReadWriteLock() {\n    return null;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    //只要id相等就认为两个cache相同\n    if (getId() == null) {\n      throw new CacheException(\"Cache instances require an ID.\");\n    }\n    if (this == o) {\n      return true;\n    }\n    if (!(o instanceof Cache)) {\n      return false;\n    }\n\n    Cache otherCache = (Cache) o;\n    return getId().equals(otherCache.getId());\n  }\n\n  @Override\n  public int hashCode() {\n    if (getId() == null) {\n      throw new CacheException(\"Cache instances require an ID.\");\n    }\n    return getId().hashCode();\n  }\n\n}\n```\n* 现在回到主线，因为第一次查询一级缓存是没有数据的，所以继续执行`queryFromDatabase`，从下面的方法可以看到在这里实现了缓存的加入操作`localCache.putObject(key, list);`\n```java\n  // 从数据库查\n  private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    List<E> list;\n    // 先向缓存中放入占位符\n    localCache.putObject(key, EXECUTION_PLACEHOLDER);\n    try {\n      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);\n    } finally {\n      // 最后删除占位符\n      localCache.removeObject(key);\n    }\n    // 加入缓存\n    localCache.putObject(key, list);\n    // 如果是存储过程，OUT参数也加入缓存\n    if (ms.getStatementType() == StatementType.CALLABLE) {\n      localOutputParameterCache.putObject(key, parameter);\n    }\n    return list;\n  }\n```\n### 一级缓存的生命周期有多长\n* MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。\n\n![iamge](/images/server/mybatis/localCache.png)\n\n\n* 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；\n```java\n  @Override\n  public void close(boolean forceRollback) {\n    try {\n      try {\n        rollback(forceRollback);\n      } finally {\n        if (transaction != null) {\n          transaction.close();\n        }\n      }\n    } catch (SQLException e) {\n      // Ignore.  There's nothing that can be done at this point.\n      log.warn(\"Unexpected exception on closing transaction.  Cause: \" + e);\n    } finally {\n      transaction = null;\n      deferredLoads = null;\n      localCache = null;\n      localOutputParameterCache = null;\n      closed = true;\n    }\n  }\n```\n* 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；\n```java\n  @Override\n  public void clearLocalCache() {\n    if (!closed) {\n      localCache.clear();\n      localOutputParameterCache.clear();\n    }\n  }\n```\n* SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用；\n```java\n  // SqlSession.update/insert/delete会调用此方法\n  @Override\n  public int update(MappedStatement ms, Object parameter) throws SQLException {\n    ErrorContext.instance().resource(ms.getResource()).activity(\"executing an update\").object(ms.getId());\n    if (closed) {\n      throw new ExecutorException(\"Executor was closed.\");\n    }\n    //先清局部缓存，再更新，如何更新交由子类，模板方法模式\n    clearLocalCache();\n    return doUpdate(ms, parameter);\n  }\n```\n### 缓存分析\n \n#### 为什么要使用一级缓存\n使用缓存是为了提高查询效率，减少资源消费，如果我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同\n\n所以为了解决这一问题，减少资源的浪费，MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了\n\n如下图所示，MyBatis会在一次会话的表示----一个SqlSession对象中创建一个本地缓存(local cache)，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。\n\n![image](/images/server/mybatis/level1Cache.png)\n\n\n\n#### 一级缓存查询时序图\n![image](/images/server/mybatis/cache.png)\n\n\n#### CacheKey的定义\n> Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。\n\n* 现在最核心的问题出现了：怎样来确定一次查询的特征值？\n\n* MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询\n```xml\n1. 传入的statementId，对于MyBatis而言，你要使用它，必须需要一个statementId，它代表着你将执行什么样的Sql；\n\n2. MyBatis自身提供的分页功能是通过RowBounds来实现的，它通过rowBounds.offset和rowBounds.limit来过滤查询出来的结果集，这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页；\n\n3. 由于MyBatis底层还是依赖于JDBC实现的，那么，对于两次完全一模一样的查询，MyBatis要保证对于底层JDBC而言，也是完全一致的查询才行。而对于JDBC而言，两次查询，只要传入给JDBC的SQL语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。\n```\n\n* 下面是创建`CacheKey`的代码\n\n```java\n  //创建缓存Key\n  @Override\n  public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) {\n    if (closed) {\n      throw new ExecutorException(\"Executor was closed.\");\n    }\n    CacheKey cacheKey = new CacheKey();\n    // MyBatis 对于其 Key 的生成采取规则为：[mappedStementId + offset + limit + SQL + queryParams + environment]生成一个哈希码\n    cacheKey.update(ms.getId());\n    cacheKey.update(Integer.valueOf(rowBounds.getOffset()));\n    cacheKey.update(Integer.valueOf(rowBounds.getLimit()));\n    cacheKey.update(boundSql.getSql());\n    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();\n    TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();\n    // mimic DefaultParameterHandler logic\n    // 模仿DefaultParameterHandler的逻辑,不再重复，请参考DefaultParameterHandler\n    for (int i = 0; i < parameterMappings.size(); i++) {\n      ParameterMapping parameterMapping = parameterMappings.get(i);\n      if (parameterMapping.getMode() != ParameterMode.OUT) {\n        Object value;\n        String propertyName = parameterMapping.getProperty();\n        if (boundSql.hasAdditionalParameter(propertyName)) {\n          value = boundSql.getAdditionalParameter(propertyName);\n        } else if (parameterObject == null) {\n          value = null;\n        } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {\n          value = parameterObject;\n        } else {\n          MetaObject metaObject = configuration.newMetaObject(parameterObject);\n          value = metaObject.getValue(propertyName);\n        }\n        cacheKey.update(value);\n      }\n    }\n    if (configuration.getEnvironment() != null) {\n      // issue #176\n      cacheKey.update(configuration.getEnvironment().getId());\n    }\n    return cacheKey;\n  }   \n```\n\n## 总结\n1. 如果缓存中有数据就不用从数据库中获取，大大提高系统性能。\n2. 一级缓存的作用级别是Session级别的，因为一个Session中存放一个Executor。而一级缓存放在Executor。\n\n\n\n参考：\nhttps://blog.csdn.net/chenyao1994/article/details/79233725","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十一)MapperXML映射文件OGNL表达式","url":"/2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十一)MapperXML映射文件OGNL表达式/","content":"## 基本介绍\nOGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。\n\n\nStruts2框架使用OGNL作为默认的表达式语言\n\nOGNL是一种比EL强大很多倍的语言，支持对象方法调用，支持静态方法和字段访问，支持赋值操作等等。\nxwork提供了OGNL表达式。\n其jar包为ognl-x.x.x.jar。\n\n## MyBatis常用OGNL表达式\n```sql\n•e1 or e2\n•e1 and e2\n•e1 == e2,e1 eq e2\n•e1 != e2,e1 neq e2\n•e1 lt e2：小于\n•e1 lte e2：小于等于，其他gt（大于）,gte（大于等于）\n•e1 in e2\n•e1 not in e2\n•e1 + e2,e1 * e2,e1/e2,e1 - e2,e1%e2\n•!e,not e：非，求反\n•e.method(args)调用对象方法\n•e.property对象属性值\n•e1[ e2 ]按索引取值，List,数组和Map\n•@class@method(args)调用类的静态方法\n•@class@field调用类的静态字段值\n\n```\n\n\n## MyBatis中可以使用OGNL的地方有两处\n1. 动态SQL表达式中\n2. ${param}参数中\n\n上面这两处地方在MyBatis中处理的时候都是使用OGNL处理的。\n\n下面通过举例来说明这两种情况的用法。\n\n### 动态SQL表达式中\n> 下面代码中test的值会使用OGNL计算结果。\n```sql\n<select id=\"xxx\" ...>\n select id,name,... from country\n <where>\n <if test=\"name != null and name != ''\">\n  name like concat('%', #{name}, '%')\n </if>\n </where>\n</select>\n```\n> 通用 like 查询及<bind>的value值会使用OGNL计算\n```sql\n<select id=\"xxx\" ...>\n select id,name,... from country\n <bind name=\"nameLike\" value=\"'%' + name + '%'\"/>\n <where>\n <if test=\"name != null and name != ''\">\n  name like #{nameLike}\n </if>\n </where>\n</select>\n```\n> 通用Mapper中支持一种UUID的主键\n```sql\n<bind name=\"username_bind\" value='@java.util.UUID@randomUUID().toString().replace(\"-\", \"\")' />\n```\n### ${param}参数中\n```sql\n<select id=\"xxx\" ...>\n select id,name,... from country\n <where>\n <if test=\"name != null and name != ''\">\n  name like '${'%' + name + '%'}'\n </if>\n </where>\n</select>\n \n这里注意写的是${'%' + name + '%'} ，而不是%${name}% ，这两种方式的结果一样，但是处理过程不一样。\n \n在MyBatis中处理${}的时候，只是使用OGNL计算这个结果值，然后替换SQL中对应的${xxx} ，OGNL处理的只是${这里的表达式}。\n \n这里表达式可以是OGNL支持的所有表达式，可以写的很复杂，可以调用静态方法返回值，也可以调用静态的属性值。\n```\n参考：\n\nhttps://www.jb51.net/article/116160.htm\n\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(十)MapperXML映射文件构建SqlNode","url":"/2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十)MapperXML映射文件构建SqlNode/","content":"## 前言\n上一章节介绍了`SqlSource`的构造过程，`SqlSource` 由一堆`SqlNode`构成，本章来介绍`SqlNode`的构造，如下图可以看到`SqlNode`的主要成员\n![image](/images/server/mybatis/SqlNode.png)\n \n## 源码解析\n\n### SqlNode\n* 还是回到 `parseScriptNode` 方法，关注`List<SqlNode> contents = parseDynamicTags(context);` 这个方法会把 `select|insert|update|delete` 这些标签的sql解析成一堆SqlNode, 包括静态SqlNode 和动态SqlNode(可见上图) \n```java\n  public SqlSource parseScriptNode() {\n    // 获取SqlNode List\n    List<SqlNode> contents = parseDynamicTags(context);\n    MixedSqlNode rootSqlNode = new MixedSqlNode(contents);\n    SqlSource sqlSource = null;\n    if (isDynamic) {\n      sqlSource = new DynamicSqlSource(configuration, rootSqlNode);\n    } else {\n      sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);\n    }\n    return sqlSource;\n  }\n\n  List<SqlNode> parseDynamicTags(XNode node) {\n    // 一行一个SqlNode\n    List<SqlNode> contents = new ArrayList<SqlNode>();\n    NodeList children = node.getNode().getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      XNode child = node.newXNode(children.item(i));\n      // 如果节点类型CDATA或者是文本，构造一个TextSqlNode或StaticTextSqlNode\n      if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) {\n        String data = child.getStringBody(\"\");\n        TextSqlNode textSqlNode = new TextSqlNode(data);\n        if (textSqlNode.isDynamic()) {\n          contents.add(textSqlNode);\n          isDynamic = true;\n        } else {\n          contents.add(new StaticTextSqlNode(data));\n        }\n      } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // 如果是xml标签 trim|where|set...\n        String nodeName = child.getNode().getNodeName();\n        // 得到动态sql标签处理类 trim|where|set...\n        NodeHandler handler = nodeHandlers(nodeName);\n        if (handler == null) {\n          throw new BuilderException(\"Unknown element <\" + nodeName + \"> in SQL statement.\");\n        }\n        // 解析动态结点\n        handler.handleNode(child, contents);\n        isDynamic = true;\n      }\n    }\n    return contents;\n  }\n\n  NodeHandler nodeHandlers(String nodeName) {\n    Map<String, NodeHandler> map = new HashMap<String, NodeHandler>();\n    map.put(\"trim\", new TrimHandler());\n    map.put(\"where\", new WhereHandler());\n    map.put(\"set\", new SetHandler());\n    map.put(\"foreach\", new ForEachHandler());\n    map.put(\"if\", new IfHandler());\n    map.put(\"choose\", new ChooseHandler());\n    map.put(\"when\", new IfHandler());\n    map.put(\"otherwise\", new OtherwiseHandler());\n    map.put(\"bind\", new BindHandler());\n    return map.get(nodeName);\n  }\n```\n* SqlNode 是 Mybatis 实现动态sql的核心，下面来看看一些常用节点的的处理，`IfSqlNode` 节点\n```java\n/**\n * if SQL节点\n * @author Clinton Begin\n */\npublic class IfSqlNode implements SqlNode {\n  private ExpressionEvaluator evaluator;\n  private String test;\n  private SqlNode contents;\n\n  public IfSqlNode(SqlNode contents, String test) {\n    this.test = test;\n    this.contents = contents;\n    this.evaluator = new ExpressionEvaluator();\n  }\n\n  @Override\n  public boolean apply(DynamicContext context) {\n    // 如果满足条件，则apply，并返回true\n    if (evaluator.evaluateBoolean(test, context.getBindings())) {\n      contents.apply(context);\n      return true;\n    }\n    return false;\n  }\n}\n```\n\n* `ForEachSqlNode` 节点\n```java\n/**\n * foreach SQL节点\n * @author Clinton Begin\n */\npublic class ForEachSqlNode implements SqlNode {\n  public static final String ITEM_PREFIX = \"__frch_\";\n\n  private ExpressionEvaluator evaluator;\n  private String collectionExpression;\n  private SqlNode contents;\n  private String open;\n  private String close;\n  private String separator;\n  private String item;\n  private String index;\n  private Configuration configuration;\n\n  public ForEachSqlNode(Configuration configuration, SqlNode contents, String collectionExpression, String index, String item, String open, String close, String separator) {\n    this.evaluator = new ExpressionEvaluator();\n    this.collectionExpression = collectionExpression;\n    this.contents = contents;\n    this.open = open;\n    this.close = close;\n    this.separator = separator;\n    this.index = index;\n    this.item = item;\n    this.configuration = configuration;\n  }\n\n  @Override\n  public boolean apply(DynamicContext context) {\n    Map<String, Object> bindings = context.getBindings();\n\t//解析collectionExpression->iterable,核心用的ognl\n    final Iterable<?> iterable = evaluator.evaluateIterable(collectionExpression, bindings);\n    if (!iterable.iterator().hasNext()) {\n      return true;\n    }\n    boolean first = true;\n\t//加上(\n    applyOpen(context);\n    int i = 0;\n    for (Object o : iterable) {\n      DynamicContext oldContext = context;\n      if (first) {\n        context = new PrefixedContext(context, \"\");\n      } else if (separator != null) {\n        context = new PrefixedContext(context, separator);\n      } else {\n          context = new PrefixedContext(context, \"\");\n      }\n      int uniqueNumber = context.getUniqueNumber();\n      // Issue #709 \n      if (o instanceof Map.Entry) {\n        @SuppressWarnings(\"unchecked\") \n        Map.Entry<Object, Object> mapEntry = (Map.Entry<Object, Object>) o;\n        applyIndex(context, mapEntry.getKey(), uniqueNumber);\n        applyItem(context, mapEntry.getValue(), uniqueNumber);\n      } else {\n\t\t//索引\n        applyIndex(context, i, uniqueNumber);\n\t\t//加上一个元素\n        applyItem(context, o, uniqueNumber);\n      }\n      contents.apply(new FilteredDynamicContext(configuration, context, index, item, uniqueNumber));\n      if (first) {\n        first = !((PrefixedContext) context).isPrefixApplied();\n      }\n      context = oldContext;\n      i++;\n    }\n\t//加上)\n    applyClose(context);\n    return true;\n  }\n  \n  ...\n```\n\n* `MixedSqlNode` 这个Node比较特殊，获得的SqlNode会以list放在 `MixedSqlNode`中\n```java\n/**\n * 混合SQL节点\n * @author Clinton Begin\n */\npublic class MixedSqlNode implements SqlNode {\n  // 组合模式，拥有一个SqlNode的List\n  private List<SqlNode> contents;\n\n  public MixedSqlNode(List<SqlNode> contents) {\n    this.contents = contents;\n  }\n\n  @Override\n  public boolean apply(DynamicContext context) {\n    // 依次调用list里每个元素的apply\n    for (SqlNode sqlNode : contents) {\n      sqlNode.apply(context);\n    }\n    return true;\n  }\n}\n```\n* `selectByPrimaryKey` 解析成果，见下图\n```xml\n  <select id=\"selectByPrimaryKey\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.Integer\" >\n    select \n    <include refid=\"Base_Column_List\" />\n    from sys_role\n    where id = #{id,jdbcType=INTEGER}\n  </select>\n```\n![image](/images/server/mybatis/StaticTextNode.jpg)\n\n* `updateByPrimaryKeySelective` 解析成果，见下图\n```xml\n  <update id=\"updateByPrimaryKeySelective\" parameterType=\"org.apache.songsy.entity.Role\" >\n    update sys_role\n    <set >\n      <if test=\"roleName != null\" >\n        role_name = #{roleName,jdbcType=VARCHAR},\n      </if>\n      <if test=\"roleCode != null\" >\n        role_code = #{roleCode,jdbcType=VARCHAR},\n      </if>\n      <if test=\"roleDescribe != null\" >\n        role_describe = #{roleDescribe,jdbcType=VARCHAR},\n      </if>\n      <if test=\"createdDate != null\" >\n        created_date = #{createdDate,jdbcType=TIMESTAMP},\n      </if>\n      <if test=\"createdBy != null\" >\n        created_by = #{createdBy,jdbcType=VARCHAR},\n      </if>\n      <if test=\"lastModifiedDate != null\" >\n        last_modified_date = #{lastModifiedDate,jdbcType=TIMESTAMP},\n      </if>\n      <if test=\"lastModifiedBy != null\" >\n        last_modified_by = #{lastModifiedBy,jdbcType=VARCHAR},\n      </if>\n      <if test=\"remarks != null\" >\n        remarks = #{remarks,jdbcType=VARCHAR},\n      </if>\n      <if test=\"status != null\" >\n        status = #{status,jdbcType=INTEGER},\n      </if>\n      <if test=\"enable != null\" >\n        enable = #{enable,jdbcType=BIT},\n      </if>\n    </set>\n    where id = #{id,jdbcType=INTEGER}\n  </update>\n```\n![image](/images/server/mybatis/updateNode.jpg)\n## 总结\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(九)MapperXML映射文件构建SqlSource","url":"/2018/12/01/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(九)MapperXML映射文件构建SqlSource/","content":"## 前言\n上一章节介绍了`select|insert|update|delete` 这些sql标签会解析成`MappedStatement`对象，`MappedStatement` 对象的重点属性是`SqlSource`，本章来介绍`SqlSource`的构造过程，其最终执行的sql字符串就是由SqlSource提供的。\n \n## 源码解析\n\n### SqlSource 类\n\n下图可以看到其实现类，主要有4种类型\n\n![image](/images/server/mybatis/SqlSource.gif)\n\n1. DynamicSqlSource:处理动态sql语句。\n2. RawSqlSource：处理静态sql语句，其内部装饰StaticSqlSource。\n3. StaticSqlSource：处理静态sql，无论是静态sql，还是动态sql，最终的处理结果，都是静态sql。\n4. ProviderSqlSource:处理注解Annotation形式的sql。\n5. VelocitySqlSource:只是Mybatis的一个测试类\n\n\nDynamicSqlSource和StaticSqlSource的最大区别在于：StaticSqlSource的String sql，可以直接获取使用，而DynamicSqlSource的String sql需要逐一根据条件解析并拼接出最终的sql，方能使用。\n\n* Mybatis解析sql的时机\nMybatis对于用户在XXMapper.xml文件中配置的sql解析主要分为2个时机\n\n1. 静态sql：程序启动的时候解析\n\n2. 动态sql：用户进行查询等sql相关操作的时候解析\n\n* 什么是静态sql，动态sql？\n\n1. 如果select|insert|update|delete标签体内包含XML标签或者select|insert|update|delete标签体内的sql文本中包含${}参数占位符则为动态sql，否则为静态sql。\n\n2. 如下面的2个sql中，第一个为动态sql，第二个为静态sql\n```java\n<select id=\"selectUser\" parameterType=\"com.fit.bean.User\" resultType=\"com.fit.bean.User\" useCache=\"true\">\n\tselect id, name from tab_user where id = ${id}\n\t<if test=\"name!=null and name!=''\">\n\tand name=#{name}\n\t</if>\n\tand 1 = 1\n</select>\n \n<select id=\"selectUserById\" parameterType=\"int\" resultType=\"com.fit.bean.User\" useCache=\"true\">\n\tselect id, name from tab_user where id = #{id}\n</select>\n```\n\n\n* 进入 parseStatementNode 方法，关注`SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);`这一行，打好断点进入`langDriver.createSqlSource(configuration, context, parameterTypeClass);` 方法\n```java\npublic void parseStatementNode() {\n    String id = context.getStringAttribute(\"id\");\n    String databaseId = context.getStringAttribute(\"databaseId\");\n\n    //如果databaseId不匹配，退出\n    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {\n      return;\n    }\n\n    //暗示驱动程序每次批量返回的结果行数\n    Integer fetchSize = context.getIntAttribute(\"fetchSize\");\n    //超时时间\n    Integer timeout = context.getIntAttribute(\"timeout\");\n    //引用外部 parameterMap,已废弃\n    String parameterMap = context.getStringAttribute(\"parameterMap\");\n    //参数类型\n    String parameterType = context.getStringAttribute(\"parameterType\");\n    Class<?> parameterTypeClass = resolveClass(parameterType);\n    //引用外部的 resultMap(高级功能)\n    String resultMap = context.getStringAttribute(\"resultMap\");\n    //结果类型\n    String resultType = context.getStringAttribute(\"resultType\");\n    //脚本语言,mybatis3.2的新功能\n    String lang = context.getStringAttribute(\"lang\");\n    //得到语言驱动\n    LanguageDriver langDriver = getLanguageDriver(lang);\n\n    Class<?> resultTypeClass = resolveClass(resultType);\n    //结果集类型，FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE 中的一种\n    String resultSetType = context.getStringAttribute(\"resultSetType\");\n    //语句类型, STATEMENT|PREPARED|CALLABLE 的一种\n    StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString()));\n    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);\n\n    //获取命令类型(select|insert|update|delete)\n    String nodeName = context.getNode().getNodeName();\n    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));\n    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;\n    boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect);\n    //是否要缓存select结果\n    boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect);\n    //仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。\n    //这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 \n    boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false);\n\n    // Include Fragments before parsing\n    //解析之前先解析<include>SQL片段\n    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);\n    includeParser.applyIncludes(context.getNode());\n\n    // Parse selectKey after includes and remove them.\n    //解析之前先解析<selectKey>\n    processSelectKeyNodes(id, parameterTypeClass, langDriver);\n    \n    // Parse the SQL (pre: <selectKey> and <include> were parsed and removed)\n    //解析成SqlSource，一般是DynamicSqlSource\n    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);\n    String resultSets = context.getStringAttribute(\"resultSets\");\n    //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值\n    String keyProperty = context.getStringAttribute(\"keyProperty\");\n    //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值\n    String keyColumn = context.getStringAttribute(\"keyColumn\");\n    KeyGenerator keyGenerator;\n    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;\n    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);\n    if (configuration.hasKeyGenerator(keyStatementId)) {\n      keyGenerator = configuration.getKeyGenerator(keyStatementId);\n    } else {\n      keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\",\n          configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))\n          ? new Jdbc3KeyGenerator() : new NoKeyGenerator();\n    }\n\n\t//又去调助手类\n    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,\n        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,\n        resultSetTypeEnum, flushCache, useCache, resultOrdered, \n        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);\n  }\n```\n\n\n* 进入`langDriver.createSqlSource`方法后默认是进入 `XMLLanguageDriver`类 createSqlSource 方法，可以看到又调用了`XMLScriptBuilder` 类的`builder.parseScriptNode()` 方法\n```java\npublic class XMLLanguageDriver implements LanguageDriver {\n\n  @Override\n  public ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {\n    //返回默认的参数处理器\n\treturn new DefaultParameterHandler(mappedStatement, parameterObject, boundSql);\n  }\n\n  @Override\n  public SqlSource createSqlSource(Configuration configuration, XNode script, Class<?> parameterType) {\n\t//用XML脚本构建器解析\n    XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType);\n    return builder.parseScriptNode();\n  }\n\n  //注解方式构建mapper\n  @Override\n  public SqlSource createSqlSource(Configuration configuration, String script, Class<?> parameterType) {\n    // issue #3\n    if (script.startsWith(\"<script>\")) {\n      XPathParser parser = new XPathParser(script, false, configuration.getVariables(), new XMLMapperEntityResolver());\n      return createSqlSource(configuration, parser.evalNode(\"/script\"), parameterType);\n    } else {\n      // issue #127\n      script = PropertyParser.parse(script, configuration.getVariables());\n      TextSqlNode textSqlNode = new TextSqlNode(script);\n      //一种是动态，一种是原始\n      if (textSqlNode.isDynamic()) {\n        return new DynamicSqlSource(configuration, textSqlNode);\n      } else {\n        return new RawSqlSource(configuration, script, parameterType);\n      }\n    }\n  }\n}\n```\n* 进入`XMLScriptBuilder类` 根据 `isDynamic` 变量来返回 `DynamicSqlSource` 对象和 `RawSqlSource` 对象\n```java\npublic class XMLScriptBuilder extends BaseBuilder {\n\n  private XNode context;\n  private boolean isDynamic;\n  private Class<?> parameterType;\n\n  public XMLScriptBuilder(Configuration configuration, XNode context) {\n    this(configuration, context, null);\n  }\n\n  public XMLScriptBuilder(Configuration configuration, XNode context, Class<?> parameterType) {\n    super(configuration);\n    this.context = context;\n    this.parameterType = parameterType;\n  }\n\n  public SqlSource parseScriptNode() {\n    List<SqlNode> contents = parseDynamicTags(context);\n    MixedSqlNode rootSqlNode = new MixedSqlNode(contents);\n    SqlSource sqlSource = null;\n    if (isDynamic) {\n      sqlSource = new DynamicSqlSource(configuration, rootSqlNode);\n    } else {\n      sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType);\n    }\n    return sqlSource;\n  }\n\n  List<SqlNode> parseDynamicTags(XNode node) {\n    // 一行一个SqlNode\n    List<SqlNode> contents = new ArrayList<SqlNode>();\n    NodeList children = node.getNode().getChildNodes();\n    for (int i = 0; i < children.getLength(); i++) {\n      XNode child = node.newXNode(children.item(i));\n      // 如果节点类型CDATA或者是文本，构造一个TextSqlNode或StaticTextSqlNode\n      if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) {\n        String data = child.getStringBody(\"\");\n        TextSqlNode textSqlNode = new TextSqlNode(data);\n        if (textSqlNode.isDynamic()) {\n          contents.add(textSqlNode);\n          isDynamic = true;\n        } else {\n          contents.add(new StaticTextSqlNode(data));\n        }\n      } else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) { // 如果是xml标签 trim|where|set...\n        String nodeName = child.getNode().getNodeName();\n        // 得到动态sql标签处理类 trim|where|set...\n        NodeHandler handler = nodeHandlers(nodeName);\n        if (handler == null) {\n          throw new BuilderException(\"Unknown element <\" + nodeName + \"> in SQL statement.\");\n        }\n        // 解析动态结点\n        handler.handleNode(child, contents);\n        isDynamic = true;\n      }\n    }\n    return contents;\n  }\n\n  NodeHandler nodeHandlers(String nodeName) {\n    Map<String, NodeHandler> map = new HashMap<String, NodeHandler>();\n    map.put(\"trim\", new TrimHandler());\n    map.put(\"where\", new WhereHandler());\n    map.put(\"set\", new SetHandler());\n    map.put(\"foreach\", new ForEachHandler());\n    map.put(\"if\", new IfHandler());\n    map.put(\"choose\", new ChooseHandler());\n    map.put(\"when\", new IfHandler());\n    map.put(\"otherwise\", new OtherwiseHandler());\n    map.put(\"bind\", new BindHandler());\n    return map.get(nodeName);\n  }\n\n  private interface NodeHandler {\n    void handleNode(XNode nodeToHandle, List<SqlNode> targetContents);\n  }\n\n  private class BindHandler implements NodeHandler {\n    public BindHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      final String name = nodeToHandle.getStringAttribute(\"name\");\n      final String expression = nodeToHandle.getStringAttribute(\"value\");\n      final VarDeclSqlNode node = new VarDeclSqlNode(name, expression);\n      targetContents.add(node);\n    }\n  }\n\n  private class TrimHandler implements NodeHandler {\n    public TrimHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      List<SqlNode> contents = parseDynamicTags(nodeToHandle);\n      MixedSqlNode mixedSqlNode = new MixedSqlNode(contents);\n      String prefix = nodeToHandle.getStringAttribute(\"prefix\");\n      String prefixOverrides = nodeToHandle.getStringAttribute(\"prefixOverrides\");\n      String suffix = nodeToHandle.getStringAttribute(\"suffix\");\n      String suffixOverrides = nodeToHandle.getStringAttribute(\"suffixOverrides\");\n      TrimSqlNode trim = new TrimSqlNode(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides);\n      targetContents.add(trim);\n    }\n  }\n\n  private class WhereHandler implements NodeHandler {\n    public WhereHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      List<SqlNode> contents = parseDynamicTags(nodeToHandle);\n      MixedSqlNode mixedSqlNode = new MixedSqlNode(contents);\n      WhereSqlNode where = new WhereSqlNode(configuration, mixedSqlNode);\n      targetContents.add(where);\n    }\n  }\n\n  private class SetHandler implements NodeHandler {\n    public SetHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      List<SqlNode> contents = parseDynamicTags(nodeToHandle);\n      MixedSqlNode mixedSqlNode = new MixedSqlNode(contents);\n      SetSqlNode set = new SetSqlNode(configuration, mixedSqlNode);\n      targetContents.add(set);\n    }\n  }\n\n  private class ForEachHandler implements NodeHandler {\n    public ForEachHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      List<SqlNode> contents = parseDynamicTags(nodeToHandle);\n      MixedSqlNode mixedSqlNode = new MixedSqlNode(contents);\n      String collection = nodeToHandle.getStringAttribute(\"collection\");\n      String item = nodeToHandle.getStringAttribute(\"item\");\n      String index = nodeToHandle.getStringAttribute(\"index\");\n      String open = nodeToHandle.getStringAttribute(\"open\");\n      String close = nodeToHandle.getStringAttribute(\"close\");\n      String separator = nodeToHandle.getStringAttribute(\"separator\");\n      ForEachSqlNode forEachSqlNode = new ForEachSqlNode(configuration, mixedSqlNode, collection, index, item, open, close, separator);\n      targetContents.add(forEachSqlNode);\n    }\n  }\n\n  private class IfHandler implements NodeHandler {\n    public IfHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      List<SqlNode> contents = parseDynamicTags(nodeToHandle);\n      MixedSqlNode mixedSqlNode = new MixedSqlNode(contents);\n      String test = nodeToHandle.getStringAttribute(\"test\");\n      IfSqlNode ifSqlNode = new IfSqlNode(mixedSqlNode, test);\n      targetContents.add(ifSqlNode);\n    }\n  }\n\n  private class OtherwiseHandler implements NodeHandler {\n    public OtherwiseHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      List<SqlNode> contents = parseDynamicTags(nodeToHandle);\n      MixedSqlNode mixedSqlNode = new MixedSqlNode(contents);\n      targetContents.add(mixedSqlNode);\n    }\n  }\n\n  private class ChooseHandler implements NodeHandler {\n    public ChooseHandler() {\n      // Prevent Synthetic Access\n    }\n\n    @Override\n    public void handleNode(XNode nodeToHandle, List<SqlNode> targetContents) {\n      List<SqlNode> whenSqlNodes = new ArrayList<SqlNode>();\n      List<SqlNode> otherwiseSqlNodes = new ArrayList<SqlNode>();\n      handleWhenOtherwiseNodes(nodeToHandle, whenSqlNodes, otherwiseSqlNodes);\n      SqlNode defaultSqlNode = getDefaultSqlNode(otherwiseSqlNodes);\n      ChooseSqlNode chooseSqlNode = new ChooseSqlNode(whenSqlNodes, defaultSqlNode);\n      targetContents.add(chooseSqlNode);\n    }\n\n    private void handleWhenOtherwiseNodes(XNode chooseSqlNode, List<SqlNode> ifSqlNodes, List<SqlNode> defaultSqlNodes) {\n      List<XNode> children = chooseSqlNode.getChildren();\n      for (XNode child : children) {\n        String nodeName = child.getNode().getNodeName();\n        NodeHandler handler = nodeHandlers(nodeName);\n        if (handler instanceof IfHandler) {\n          handler.handleNode(child, ifSqlNodes);\n        } else if (handler instanceof OtherwiseHandler) {\n          handler.handleNode(child, defaultSqlNodes);\n        }\n      }\n    }\n\n    private SqlNode getDefaultSqlNode(List<SqlNode> defaultSqlNodes) {\n      SqlNode defaultSqlNode = null;\n      if (defaultSqlNodes.size() == 1) {\n        defaultSqlNode = defaultSqlNodes.get(0);\n      } else if (defaultSqlNodes.size() > 1) {\n        throw new BuilderException(\"Too many default (otherwise) elements in choose statement.\");\n      }\n      return defaultSqlNode;\n    }\n  }\n}\n```\n* 重点是这个方法`List<SqlNode> parseDynamicTags(XNode node) ` ，下面几行代码是处理动态sql的操作\n```java\n        // 得到动态sql标签处理类 trim|where|set...\n        NodeHandler handler = nodeHandlers(nodeName);\n        if (handler == null) {\n          throw new BuilderException(\"Unknown element <\" + nodeName + \"> in SQL statement.\");\n        }\n        // 解析动态结点\n        handler.handleNode(child, contents);\n        isDynamic = true;\n```\n* 通过 `nodeHandlers (nodeName)` 方法来获取相应的处理类\n```java\n  NodeHandler nodeHandlers(String nodeName) {\n    Map<String, NodeHandler> map = new HashMap<String, NodeHandler>();\n    map.put(\"trim\", new TrimHandler());\n    map.put(\"where\", new WhereHandler());\n    map.put(\"set\", new SetHandler());\n    map.put(\"foreach\", new ForEachHandler());\n    map.put(\"if\", new IfHandler());\n    map.put(\"choose\", new ChooseHandler());\n    map.put(\"when\", new IfHandler());\n    map.put(\"otherwise\", new OtherwiseHandler());\n    map.put(\"bind\", new BindHandler());\n    return map.get(nodeName);\n  }\n```\n* 各个Handler 处理类是 `XMLScriptBuilder` 的子类，实际上会转到各个SqlNode 处理类\n \n![image](/images/server/mybatis/SqlNode.png)\n\n## 总结\n* 解析mapper文件中的每个`<select/>,<insert/>,<update/>,<delete/>`节点内的SQL字符串(其中可能包含动态SQL部分,诸如`<if/>,<where/>等) `是这个`XMLScriptBuilder`类","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(八)MapperXML映射文件构建MappedStatement","url":"/2018/11/27/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(八)MapperXML映射文件构建MappedStatement/","content":"## 前言\n上一章节介绍了ResultMap标签的解析过程，这一章节来介绍`select|insert|update|delete` 这些sql标签的解析，这些节点会构造成`MappedStatement`类对象\n\n## 源码解析\n* 还是从 `SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);` 作为入口找到 `configurationElement(XNode context)` 方法，如下所示，按照步骤节点一步步解析，最后才是处理`select|insert|update|delete`节点 \n```java\n       private void configurationElement(XNode context) {\n         try {\n           //1.配置namespace\n           String namespace = context.getStringAttribute(\"namespace\");\n           if (namespace.equals(\"\")) {\n             throw new BuilderException(\"Mapper's namespace cannot be empty\");\n           }\n           builderAssistant.setCurrentNamespace(namespace);\n           //2.配置cache-ref\n           cacheRefElement(context.evalNode(\"cache-ref\"));\n           //3.配置cache\n           cacheElement(context.evalNode(\"cache\"));\n           //4.配置parameterMap(已经废弃,老式风格的参数映射)\n           parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n           //5.配置resultMap(高级功能)\n           resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n           //6.配置sql(定义可重用的 SQL 代码段)\n           sqlElement(context.evalNodes(\"/mapper/sql\"));\n           //7.配置select|insert|update|delete TODO\n           buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n         } catch (Exception e) {\n           throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e);\n         }\n       }\n```\n* 打好断点进入 `buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));` 方法，可以看到是一个或的匹配，匹配所有的select|insert|update|delete 这些标签\n```java\n  //7.配置select|insert|update|delete\n  private void buildStatementFromContext(List<XNode> list) {\n    //调用7.1构建语句\n    if (configuration.getDatabaseId() != null) {\n      buildStatementFromContext(list, configuration.getDatabaseId());\n    }\n    buildStatementFromContext(list, null);\n  }\n\n  // 7.1构建语句\n  private void buildStatementFromContext(List<XNode> list, String requiredDatabaseId) {\n    for (XNode context : list) {\n      // 构建所有语句,一个mapper下可以有很多select\n      // 语句比较复杂，核心都在这里面，所以调用XMLStatementBuilder\n      final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId);\n      try {\n        // 核心XMLStatementBuilder.parseStatementNode\n        statementParser.parseStatementNode();\n      } catch (IncompleteElementException e) {\n        // 如果出现SQL语句不完整，把它记下来，塞到configuration去\n        configuration.addIncompleteStatement(statementParser);\n      }\n    }\n  }\n```\n* 可以看到又涉及到了一个`XMLStatementBuilder.java` 来对这些标签进行解析，进入`statementParser.parseStatementNode();` 方法，可以看到xml标签的一些属性解析，最后是`builderAssistant.addMappedStatement(...)` 方法将构建好的`MappedStatement`对象添加到Configuration这个大佬身上\n```java\n  //解析语句(select|insert|update|delete)\n//<select\n//  id=\"selectPerson\"\n//  parameterType=\"int\"\n//  parameterMap=\"deprecated\"\n//  resultType=\"hashmap\"\n//  resultMap=\"personResultMap\"\n//  flushCache=\"false\"\n//  useCache=\"true\"\n//  timeout=\"10000\"\n//  fetchSize=\"256\"\n//  statementType=\"PREPARED\"\n//  resultSetType=\"FORWARD_ONLY\">\n//  SELECT * FROM PERSON WHERE ID = #{id}\n//</select>\n  public void parseStatementNode() {\n    String id = context.getStringAttribute(\"id\");\n    String databaseId = context.getStringAttribute(\"databaseId\");\n\n    //如果databaseId不匹配，退出\n    if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) {\n      return;\n    }\n\n    //暗示驱动程序每次批量返回的结果行数\n    Integer fetchSize = context.getIntAttribute(\"fetchSize\");\n    //超时时间\n    Integer timeout = context.getIntAttribute(\"timeout\");\n    //引用外部 parameterMap,已废弃\n    String parameterMap = context.getStringAttribute(\"parameterMap\");\n    //参数类型\n    String parameterType = context.getStringAttribute(\"parameterType\");\n    Class<?> parameterTypeClass = resolveClass(parameterType);\n    //引用外部的 resultMap(高级功能)\n    String resultMap = context.getStringAttribute(\"resultMap\");\n    //结果类型\n    String resultType = context.getStringAttribute(\"resultType\");\n    //脚本语言,mybatis3.2的新功能\n    String lang = context.getStringAttribute(\"lang\");\n    //得到语言驱动\n    LanguageDriver langDriver = getLanguageDriver(lang);\n\n    Class<?> resultTypeClass = resolveClass(resultType);\n    //结果集类型，FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE 中的一种\n    String resultSetType = context.getStringAttribute(\"resultSetType\");\n    //语句类型, STATEMENT|PREPARED|CALLABLE 的一种\n    StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString()));\n    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);\n\n    //获取命令类型(select|insert|update|delete)\n    String nodeName = context.getNode().getNodeName();\n    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));\n    boolean isSelect = sqlCommandType == SqlCommandType.SELECT;\n    boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect);\n    //是否要缓存select结果\n    boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect);\n    //仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。\n    //这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 \n    boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false);\n\n    // Include Fragments before parsing\n    //解析之前先解析<include>SQL片段\n    XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant);\n    includeParser.applyIncludes(context.getNode());\n\n    // Parse selectKey after includes and remove them.\n    //解析之前先解析<selectKey>\n    processSelectKeyNodes(id, parameterTypeClass, langDriver);\n    \n    // Parse the SQL (pre: <selectKey> and <include> were parsed and removed)\n    //解析成SqlSource，一般是DynamicSqlSource\n    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);\n    String resultSets = context.getStringAttribute(\"resultSets\");\n    //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值\n    String keyProperty = context.getStringAttribute(\"keyProperty\");\n    //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值\n    String keyColumn = context.getStringAttribute(\"keyColumn\");\n    KeyGenerator keyGenerator;\n    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;\n    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true);\n    if (configuration.hasKeyGenerator(keyStatementId)) {\n      keyGenerator = configuration.getKeyGenerator(keyStatementId);\n    } else {\n      keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\",\n          configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType))\n          ? new Jdbc3KeyGenerator() : new NoKeyGenerator();\n    }\n\n\t//又去调助手类\n    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,\n        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,\n        resultSetTypeEnum, flushCache, useCache, resultOrdered, \n        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);\n  }\n```\n* MappedStatement类在Mybatis框架中用于表示XML文件中一个sql语句节点，即一个<select>或者<update>标签。Mybatis框架在初始化阶段会对XML配置文件进行读取，将其中的sql语句节点对象化为一个个MappedStatement对象\n```java\npublic final class MappedStatement {\n  // xml文件位置\n  private String resource;\n  private Configuration configuration;\n  // 节点中的id属性加要命名空间比如 org.apache.songsy.mapper.RoleMapper.selectByPrimaryKey\n  private String id;\n  private Integer fetchSize;\n  private Integer timeout;\n  private StatementType statementType;\n  private ResultSetType resultSetType;\n  // SQL源码，实现动态sql\n  private SqlSource sqlSource;\n  private Cache cache;\n  private ParameterMap parameterMap;\n  private List<ResultMap> resultMaps;\n  private boolean flushCacheRequired;\n  private boolean useCache;\n  private boolean resultOrdered;\n  private SqlCommandType sqlCommandType;\n  private KeyGenerator keyGenerator;\n  private String[] keyProperties;\n  private String[] keyColumns;\n  private boolean hasNestedResultMaps;\n  private String databaseId;\n  private Log statementLog;\n  private LanguageDriver lang;\n  private String[] resultSets;\n\n  MappedStatement() {\n    // constructor disabled\n  }\n\n  //静态内部类，建造者模式\n  public static class Builder {\n    private MappedStatement mappedStatement = new MappedStatement();\n\n    public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) {\n      mappedStatement.configuration = configuration;\n      mappedStatement.id = id;\n      mappedStatement.sqlSource = sqlSource;\n      mappedStatement.statementType = StatementType.PREPARED;\n      mappedStatement.parameterMap = new ParameterMap.Builder(configuration, \"defaultParameterMap\", null, new ArrayList<ParameterMapping>()).build();\n      mappedStatement.resultMaps = new ArrayList<ResultMap>();\n      mappedStatement.timeout = configuration.getDefaultStatementTimeout();\n      mappedStatement.sqlCommandType = sqlCommandType;\n      mappedStatement.keyGenerator = configuration.isUseGeneratedKeys() && SqlCommandType.INSERT.equals(sqlCommandType) ? new Jdbc3KeyGenerator() : new NoKeyGenerator();\n      String logId = id;\n      if (configuration.getLogPrefix() != null) {\n        logId = configuration.getLogPrefix() + id;\n      }\n      mappedStatement.statementLog = LogFactory.getLog(logId);\n      mappedStatement.lang = configuration.getDefaultScriptingLanuageInstance();\n    }\n    ...\n```\n* `MappedStatement.java` 在哪里会调用呢，可以回顾一些第六章节`使用MapperProxy来执行方法`，下面是方法\n```java\n  // 核心selectList\n  @Override\n  public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n    try {\n      // 根据statement id找到对应的MappedStatement\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      // 转而用执行器来查询结果,注意这里传入的ResultHandler是null\n      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n``` \n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(七)MapperXML映射文件解析ResultMap","url":"/2018/11/26/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(七)MapperXML映射文件解析ResultMap/","content":"## 前言\nMyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单，第三章节已经介绍了Mapper XML 文件解析的整体过程，这一章节来介绍Mapper 映射文件下 `select|insert|update|delete` 这些节点的解析\n\n## 源码解析\n* 从 `SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);` 作为入口找到 `configurationElement(XNode context)` 方法，如下所示，按照步骤节点一步步解析，最后才是处理`select|insert|update|delete`节点 \n```java\n       private void configurationElement(XNode context) {\n         try {\n           //1.配置namespace\n           String namespace = context.getStringAttribute(\"namespace\");\n           if (namespace.equals(\"\")) {\n             throw new BuilderException(\"Mapper's namespace cannot be empty\");\n           }\n           builderAssistant.setCurrentNamespace(namespace);\n           //2.配置cache-ref\n           cacheRefElement(context.evalNode(\"cache-ref\"));\n           //3.配置cache\n           cacheElement(context.evalNode(\"cache\"));\n           //4.配置parameterMap(已经废弃,老式风格的参数映射)\n           parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n           //5.配置resultMap(高级功能)\n           resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n           //6.配置sql(定义可重用的 SQL 代码段)\n           sqlElement(context.evalNodes(\"/mapper/sql\"));\n           //7.配置select|insert|update|delete TODO\n           buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n         } catch (Exception e) {\n           throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e);\n         }\n       }\n```\n* 配置resultMap 解析，进入 `resultMapElements(context.evalNodes(\"/mapper/resultMap\"));` 方法\n```java\n  private void resultMapElements(List<XNode> list) throws Exception {\n    for (XNode resultMapNode : list) {\n      try {\n        // 循环遍历resultMap节点\n        resultMapElement(resultMapNode);\n      } catch (IncompleteElementException e) {\n        // ignore, it will be retried\n      }\n    }\n```\n* 进入 `resultMapElement(resultMapNode);` 方法, 这里就是构造ResultMap的主要方法了\n```java\n  private ResultMap resultMapElement(XNode resultMapNode, List<ResultMapping> additionalResultMappings) throws Exception {\n//错误上下文\n//取得标示符   (\"resultMap[userResultMap]\")\n//    <resultMap id=\"userResultMap\" type=\"User\">\n//      <id property=\"id\" column=\"user_id\" />\n//      <result property=\"username\" column=\"username\"/>\n//      <result property=\"password\" column=\"password\"/>\n//    </resultMap>\n    ErrorContext.instance().activity(\"processing \" + resultMapNode.getValueBasedIdentifier());\n    String id = resultMapNode.getStringAttribute(\"id\",\n        resultMapNode.getValueBasedIdentifier());\n    String type = resultMapNode.getStringAttribute(\"type\",\n        resultMapNode.getStringAttribute(\"ofType\",\n            resultMapNode.getStringAttribute(\"resultType\",\n                resultMapNode.getStringAttribute(\"javaType\"))));\n    String extend = resultMapNode.getStringAttribute(\"extends\");\n    //autoMapping\n    Boolean autoMapping = resultMapNode.getBooleanAttribute(\"autoMapping\");\n    Class<?> typeClass = resolveClass(type);\n    Discriminator discriminator = null;\n    List<ResultMapping> resultMappings = new ArrayList<ResultMapping>();\n    resultMappings.addAll(additionalResultMappings);\n    // 遍历resultMap 的子节点\n    List<XNode> resultChildren = resultMapNode.getChildren();\n    for (XNode resultChild : resultChildren) {\n      if (\"constructor\".equals(resultChild.getName())) {\n        //解析result map的constructor\n        processConstructorElement(resultChild, typeClass, resultMappings);\n      } else if (\"discriminator\".equals(resultChild.getName())) {\n        //解析result map的discriminator\n        discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);\n      } else {\n        List<ResultFlag> flags = new ArrayList<ResultFlag>();\n        if (\"id\".equals(resultChild.getName())) {\n          flags.add(ResultFlag.ID);\n        }\n        // 调5.1.1 buildResultMappingFromContext,得到ResultMapping\n        resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));\n      }\n    }\n    // 最后再调ResultMapResolver得到ResultMap\n    ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping);\n    try {\n      return resultMapResolver.resolve();\n    } catch (IncompleteElementException  e) {\n      configuration.addIncompleteResultMap(resultMapResolver);\n      throw e;\n    }\n  }\n```\n* 下面来看看`ResultMap` 这个类，可以看到一层套一层\n```java\npublic class ResultMap {\n  private String id;\n  private Class<?> type;\n  private List<ResultMapping> resultMappings;\n  private List<ResultMapping> idResultMappings;\n  private List<ResultMapping> constructorResultMappings;\n  private List<ResultMapping> propertyResultMappings;\n  private Set<String> mappedColumns;\n  private Discriminator discriminator;\n  private boolean hasNestedResultMaps;\n  private boolean hasNestedQueries;\n  private Boolean autoMapping;\n\n  private ResultMap() {\n  }\n\n  // 静态内部类，建造者模式\n  public static class Builder {\n    private ResultMap resultMap = new ResultMap();\n\n    public Builder(Configuration configuration, String id, Class<?> type, List<ResultMapping> resultMappings) {\n      this(configuration, id, type, resultMappings, null);\n    }\n\n    public Builder(Configuration configuration, String id, Class<?> type, List<ResultMapping> resultMappings, Boolean autoMapping) {\n      resultMap.id = id;\n      resultMap.type = type;\n      resultMap.resultMappings = resultMappings;\n      resultMap.autoMapping = autoMapping;\n    }\n\n    public Builder discriminator(Discriminator discriminator) {\n      resultMap.discriminator = discriminator;\n      return this;\n    }\n    \n    ...\n```\n* ResultMap 由多个 `ResultMapping.java` 构造成，下面看看这个类，和我们的mapper文件是一一对应的\n```xml\n    <resultMap id=\"BaseResultMap\" type=\"com.songsy.imybatis.test.entity.User\">\n        <id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/>\n        <result column=\"username\" property=\"username\" jdbcType=\"VARCHAR\"/>\n        <result column=\"password\" property=\"password\" jdbcType=\"VARCHAR\"/>\n        <result column=\"nickname\" property=\"nickname\" jdbcType=\"VARCHAR\"/>\n```\n\n```java\npublic class ResultMapping {\n\n  private Configuration configuration;\n  private String property;\n  private String column;\n  private Class<?> javaType;\n  private JdbcType jdbcType;\n  private TypeHandler<?> typeHandler;\n  private String nestedResultMapId;\n  private String nestedQueryId;\n  private Set<String> notNullColumns;\n  private String columnPrefix;\n  private List<ResultFlag> flags;\n  private List<ResultMapping> composites;\n  private String resultSet;\n  private String foreignColumn;\n  private boolean lazy;\n\n  ResultMapping() {\n  }\n\n  // 静态内部类，建造者模式\n  public static class Builder {\n    private ResultMapping resultMapping = new ResultMapping();\n\n    public Builder(Configuration configuration, String property, String column, TypeHandler<?> typeHandler) {\n      this(configuration, property);\n      resultMapping.column = column;\n      resultMapping.typeHandler = typeHandler;\n    }\n\n    public Builder(Configuration configuration, String property, String column, Class<?> javaType) {\n      this(configuration, property);\n      resultMapping.column = column;\n      resultMapping.javaType = javaType;\n    }\n\n    public Builder(Configuration configuration, String property) {\n      resultMapping.configuration = configuration;\n      resultMapping.property = property;\n      resultMapping.flags = new ArrayList<ResultFlag>();\n      resultMapping.composites = new ArrayList<ResultMapping>();\n      resultMapping.lazy = configuration.isLazyLoadingEnabled();\n    }\n\n    public Builder javaType(Class<?> javaType) {\n      resultMapping.javaType = javaType;\n      return this;\n    }\n\n    public Builder jdbcType(JdbcType jdbcType) {\n      resultMapping.jdbcType = jdbcType;\n      return this;\n    }\n\n    public Builder nestedResultMapId(String nestedResultMapId) {\n      resultMapping.nestedResultMapId = nestedResultMapId;\n      return this;\n    }\n\n    .... \n```\n## 总结\n* Mybatis最强大的元素，它可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中。\n* 当返回类型直接是一个ResultMap的时候也是非常有用的，这主要用在进行复杂联合查询上，因为进行简单查询是没有什么必要的，可以使用ResultType来处理","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(六)使用MapperProxy来执行方法","url":"/2018/11/23/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(六)使用MapperProxy来执行方法/","content":"## 前言\n上一章节通过SqlSession来获取Mapper的代理类`MapperProxy`， 有了代理类之后就可以执行里面的方法了\n\n## MapperProxy 执行方法\n* MapperProxy 继承 InvocationHandler 实现了动态代理，只要是调用的Mapper接口的方法都会进入到 里面的`invoke` 方法中，具体解释如下代码\n```java\n/**\n * 映射器代理，代理模式\n * @author Clinton Begin\n * @author Eduardo Macarron\n */\npublic class MapperProxy<T> implements InvocationHandler, Serializable {\n\n  private static final long serialVersionUID = -6424540398559729838L;\n  private final SqlSession sqlSession;\n  private final Class<T> mapperInterface;\n  // 使用了缓存\n  private final Map<Method, MapperMethod> methodCache;\n\n  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache) {\n    this.sqlSession = sqlSession;\n    this.mapperInterface = mapperInterface;\n    this.methodCache = methodCache;\n  }\n\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法\n    // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行\n    if (Object.class.equals(method.getDeclaringClass())) {\n      try {\n        return method.invoke(this, args);\n      } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n      }\n    }\n    // 这里优化了，去缓存中找MapperMethod\n    final MapperMethod mapperMethod = cachedMapperMethod(method);\n    // 真正的方法执行\n    return mapperMethod.execute(sqlSession, args);\n  }\n\n  // 去缓存中找MapperMethod\n  private MapperMethod cachedMapperMethod(Method method) {\n    MapperMethod mapperMethod = methodCache.get(method);\n    if (mapperMethod == null) {\n      // 找不到才去new\n      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());\n      methodCache.put(method, mapperMethod);\n    }\n    return mapperMethod;\n  }\n}\n```\n* 接下来关注这一行`mapperMethod.execute(sqlSession, args);` 这里是重头戏，我们打开 `MapperMethod` 这个类，重点关注`execute` 方法，可以看到在这里进行了一些路由转发(insert|update|delete|select，分别调用SqlSession的4大类方法，又回到了SqlSession中), 还有就是对查询参数的一些处理封装。\n```java\n/**\n * 映射器方法\n * @author Clinton Begin\n * @author Eduardo Macarron\n * @author Lasse Voss\n */\npublic class MapperMethod {\n\n  private final SqlCommand command;\n  private final MethodSignature method;\n\n  public MapperMethod(Class<?> mapperInterface, Method method, Configuration config) {\n    this.command = new SqlCommand(config, mapperInterface, method);\n    this.method = new MethodSignature(config, method);\n  }\n\n  //执行\n  public Object execute(SqlSession sqlSession, Object[] args) {\n    Object result;\n    //可以看到执行时就是4种情况，insert|update|delete|select，分别调用SqlSession的4大类方法\n    if (SqlCommandType.INSERT == command.getType()) {\n      Object param = method.convertArgsToSqlCommandParam(args);\n      result = rowCountResult(sqlSession.insert(command.getName(), param));\n    } else if (SqlCommandType.UPDATE == command.getType()) {\n      Object param = method.convertArgsToSqlCommandParam(args);\n      result = rowCountResult(sqlSession.update(command.getName(), param));\n    } else if (SqlCommandType.DELETE == command.getType()) {\n      Object param = method.convertArgsToSqlCommandParam(args);\n      result = rowCountResult(sqlSession.delete(command.getName(), param));\n    } else if (SqlCommandType.SELECT == command.getType()) {\n      if (method.returnsVoid() && method.hasResultHandler()) {\n        //如果有结果处理器\n        executeWithResultHandler(sqlSession, args);\n        result = null;\n      } else if (method.returnsMany()) {\n        //如果结果有多条记录\n        result = executeForMany(sqlSession, args);\n      } else if (method.returnsMap()) {\n        //如果结果是map\n        result = executeForMap(sqlSession, args);\n      } else {\n        //否则就是一条记录\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = sqlSession.selectOne(command.getName(), param);\n      }\n    } else {\n      throw new BindingException(\"Unknown execution method for: \" + command.getName());\n    }\n    if (result == null && method.getReturnType().isPrimitive() && !method.returnsVoid()) {\n      throw new BindingException(\"Mapper method '\" + command.getName() \n          + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\");\n    }\n    return result;\n  }\n\n\n  ... 放不下\n```\n* 现在来执行一条查询，根据断点一步步发掘\n```java\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\nSystem.out.println(userMapper.selectByPrimaryKey(1));\n```\n* 一大堆if判断进入到这里\n```java\n        Object param = method.convertArgsToSqlCommandParam(args);\n        result = sqlSession.selectOne(command.getName(), param);\n```\n* 进入 `sqlSession.selectOne(command.getName(), param);` 方法\n```java\n  @Override\n  public <T> T selectOne(String statement, Object parameter) {\n    // Popular vote was to return null on 0 results and throw exception on too many.\n    // 转而去调用selectList,很简单的，如果得到0条则返回null，得到1条则返回1条，得到多条报TooManyResultsException错\n    List<T> list = this.<T>selectList(statement, parameter);\n    if (list.size() == 1) {\n      return list.get(0);\n    } else if (list.size() > 1) {\n      throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size());\n    } else {\n      return null;\n    }\n  }\n```\n* selectOne 调用的是 selectList 方法，在这里可以看到 `MappedStatement` 及 `Executor`\n```java\n  // 核心selectList\n  @Override\n  public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n    try {\n      // 根据statement id找到对应的MappedStatement\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      // 转而用执行器来查询结果,注意这里传入的ResultHandler是null\n      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n```\n\n* 查看 MappedStatement 这里可以看到我们的sql\n\n![image](/images/server/mybatis/MappedStatement.jpg)\n\n* 继续跳入 executor.query 方法，这里面跳到 `CachingExecutor` 执行，这里面使用了装饰器模式，里面有个`private Executor delegate;`，装饰SimpleExecutor , 在SimpleExecutor基础的上添加了二级缓存的功能\n```java\n  @Override\n  public <E> List<E> query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)\n      throws SQLException {\n    Cache cache = ms.getCache();\n    // 默认情况下是没有开启缓存的(二级缓存).要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: <cache/>\n    // 简单的说，就是先查CacheKey，查不到再委托给实际的执行器去查\n    if (cache != null) {\n      flushCacheIfRequired(ms);\n      if (ms.isUseCache() && resultHandler == null) {\n        ensureNoOutParams(ms, parameterObject, boundSql);\n        @SuppressWarnings(\"unchecked\")\n        List<E> list = (List<E>) tcm.getObject(cache, key);\n        if (list == null) {\n          list = delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n          tcm.putObject(cache, key, list); // issue #578 and #116\n        }\n        return list;\n      }\n    }\n    return delegate.<E> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n  }\n```\n* 因为二级缓存是需要配置开启的，所以继续跳入 `delegate.<E> query` 方法，进入到`BaseExecutor` 方法，在这里可以看到一级缓存的处理\n\n```java\n  public <E> List<E> query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {\n    ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId());\n    // 如果已经关闭，报错\n    if (closed) {\n      throw new ExecutorException(\"Executor was closed.\");\n    }\n    // 先清局部缓存，再查询.但仅查询堆栈为0，才清。为了处理递归调用\n    if (queryStack == 0 && ms.isFlushCacheRequired()) {\n      clearLocalCache();\n    }\n    List<E> list;\n    try {\n      // 加一,这样递归调用到上面的时候就不会再清局部缓存了\n      queryStack++;\n      // 先根据cachekey从localCache去查\n      list = resultHandler == null ? (List<E>) localCache.getObject(key) : null;\n      if (list != null) {\n        // 若查到localCache缓存，处理localOutputParameterCache\n        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n      } else {\n        // 从数据库查\n        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n      }\n    } finally {\n      // 清空堆栈\n      queryStack--;\n    }\n    if (queryStack == 0) {\n      // 延迟加载队列中所有元素\n      for (DeferredLoad deferredLoad : deferredLoads) {\n        deferredLoad.load();\n      }\n      // issue #601\n      // 清空延迟加载队列\n      deferredLoads.clear();\n      if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {\n        // issue #482\n    \t// 如果是STATEMENT，清本地缓存\n        clearLocalCache();\n      }\n    }\n    return list;\n  }\n```\n* 继续跳入`queryFromDatabase()` 方法，从数据库查， 跳入到SimpleExecutor类\n```java\n  @Override\n  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n      Configuration configuration = ms.getConfiguration();\n      // 新建一个StatementHandler\n      // 这里看到ResultHandler传入了\n      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n      // 准备语句\n      stmt = prepareStatement(handler, ms.getStatementLog());\n      //StatementHandler.query\n      return handler.<E>query(stmt, resultHandler);\n    } finally {\n      closeStatement(stmt);\n    }\n  }\n```\n* 继续跳入 `doQuery()`方法\n```java\n  //select\n  @Override\n  public <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {\n    Statement stmt = null;\n    try {\n      Configuration configuration = ms.getConfiguration();\n      //新建一个StatementHandler\n      //这里看到ResultHandler传入了\n      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);\n      //准备语句\n      stmt = prepareStatement(handler, ms.getStatementLog());\n      //StatementHandler.query\n      return handler.<E>query(stmt, resultHandler);\n    } finally {\n      closeStatement(stmt);\n    }\n  }\n```\n\n\n* 继续跳入 handler.<E>query(), 这里又从`SimpleExecutor`类 跳入 `PreparedStatementHandler` 类中，终于在这里看到了我们的JDBC的代码，并通过 `ResultSetHandler` 类来处理我们的结果\n```java\n  @Override\n  public <E> List<E> query(Statement statement, ResultHandler resultHandler) throws SQLException {\n    PreparedStatement ps = (PreparedStatement) statement;\n    ps.execute();\n    return resultSetHandler.<E> handleResultSets(ps);\n  }\n```\n\n## 时序图\n![image](/images/server/mybatis/executer.png)\n\n## 总结\n* 可以看到一个方法的执行涉及到一大堆类，为什么要那么多类的，就是为了解耦，`高内聚，低耦合`，每个类都有其独有的功能，就像工厂流水线一样，一个部门做一个部门的事，专人做专事，这样也方便以后添加功能","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(五)通过SqlSession来获取Mapper的代理类","url":"/2018/11/23/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(五)通过SqlSession来获取MapperProxy/","content":"## 前言\n有了SqlSession 这个类之后，就可以通过`sqlSession.getMapper(UserMapper.class);`来获取`UserMapper`了\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 得到SqlSession\nSqlSession sqlSession = sqlSessionFactory.openSession();\n// 得到Mapper\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\nSystem.out.println(userMapper.selectByPrimaryKey(1));\n```\n## 获取Mapper\n* 查看代码又可以发现 Configuration 这个类的影子，哪里都有它的影子，当然因为Mapper的映射关系数据存在这里 \n```java\n  @Override\n  public <T> T getMapper(Class<T> type) {\n    // 最后会去调用MapperRegistry.getMapper\n    return configuration.<T>getMapper(type, this);\n  }\n```\n* 继续跟进 `configuration.<T>getMapper(type, this);` 方法，进入到Configuration 类中，可以发现是MapperRegistry 类维护了Mapper的映射关系\n```java\n  public <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n    return mapperRegistry.getMapper(type, sqlSession);\n  }\n```\n\n* 继续跟进`mapperRegistry.getMapper(type, sqlSession);` 方法，进入到 MapperRegistry 类中，可以看到里面的映射关系就是用`Map<Class<?>, MapperProxyFactory<?>> knownMappers` 一个Map来存放，Key是 Class对象，Value就是`MapperProxyFactory` 是Mapper代理类的生成工厂\n```java\n/**\n * 映射器注册机\n * @author Clinton Begin\n * @author Eduardo Macarron\n * @author Lasse Voss\n */\npublic class MapperRegistry {\n\n  private Configuration config;\n  // 将已经添加的映射都放入HashMap\n  private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap<Class<?>, MapperProxyFactory<?>>();\n\n  public MapperRegistry(Configuration config) {\n    this.config = config;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  // 返回代理类\n  public <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n    final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);\n    if (mapperProxyFactory == null) {\n      throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n    }\n    try {\n      return mapperProxyFactory.newInstance(sqlSession);\n    } catch (Exception e) {\n      throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n    }\n  }\n  \n  public <T> boolean hasMapper(Class<T> type) {\n    return knownMappers.containsKey(type);\n  }\n\n  // 看一下如何添加一个映射\n  public <T> void addMapper(Class<T> type) {\n    // mapper必须是接口！才会添加\n    if (type.isInterface()) {\n      if (hasMapper(type)) {\n        // 如果重复添加了，报错\n        throw new BindingException(\"Type \" + type + \" is already known to the MapperRegistry.\");\n      }\n      boolean loadCompleted = false;\n      try {\n        knownMappers.put(type, new MapperProxyFactory<T>(type));\n        // It's important that the type is added before the parser is run\n        // otherwise the binding may automatically be attempted by the\n        // mapper parser. If the type is already known, it won't try.\n        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);\n        parser.parse();\n        loadCompleted = true;\n      } finally {\n        // 如果加载过程中出现异常需要再将这个mapper从mybatis中删除,这种方式比较丑陋吧，难道是不得已而为之？\n        if (!loadCompleted) {\n          knownMappers.remove(type);\n        }\n      }\n    }\n  }\n\n  /**\n   * @since 3.2.2\n   */\n  public Collection<Class<?>> getMappers() {\n    return Collections.unmodifiableCollection(knownMappers.keySet());\n  }\n\n  /**\n   * @since 3.2.2\n   */\n  public void addMappers(String packageName, Class<?> superType) {\n    // 查找包下所有是superType的类\n    ResolverUtil<Class<?>> resolverUtil = new ResolverUtil<Class<?>>();\n    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);\n    Set<Class<? extends Class<?>>> mapperSet = resolverUtil.getClasses();\n    for (Class<?> mapperClass : mapperSet) {\n      addMapper(mapperClass);\n    }\n  }\n\n  /**\n   * @since 3.2.2\n   */\n  // 查找包下所有类\n  public void addMappers(String packageName) {\n    addMappers(packageName, Object.class);\n  }\n  \n}\n```\n* 查看该类可以发现 knownMappers 是通过 addMapper()方法来添加的，那么addMapper()是哪里调用的呢，大家还记得之前的`XMLConfigBuilder`这个类吗，就是这里来解析mapper节点的\n```xml\n   <mappers>\n        <mapper resource=\"resources/mapper/UserMapper.xml\"/>\n    </mappers>\n```\n回到XMLConfigBuilder类可以找到这个方法`mapperElement`，可以发现是通过 `configuration.addMappers(mapperPackage);` 及`configuration.addMapper(mapperInterface);` 来添加mapper映射的\n```xml\n  private void mapperElement(XNode parent) throws Exception {\n    if (parent != null) {\n      for (XNode child : parent.getChildren()) {\n        if (\"package\".equals(child.getName())) {\n          //10.4自动扫描包下所有映射器\n          String mapperPackage = child.getStringAttribute(\"name\");\n          configuration.addMappers(mapperPackage);\n        } else {\n          String resource = child.getStringAttribute(\"resource\");\n          String url = child.getStringAttribute(\"url\");\n          String mapperClass = child.getStringAttribute(\"class\");\n          if (resource != null && url == null && mapperClass == null) {\n            //10.1使用类路径\n            ErrorContext.instance().resource(resource);\n            InputStream inputStream = Resources.getResourceAsStream(resource);\n            //映射器比较复杂，调用XMLMapperBuilder\n            //注意在for循环里每个mapper都重新new一个XMLMapperBuilder，来解析\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url != null && mapperClass == null) {\n            //10.2使用绝对url路径\n            ErrorContext.instance().resource(url);\n            InputStream inputStream = Resources.getUrlAsStream(url);\n            //映射器比较复杂，调用XMLMapperBuilder\n            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());\n            mapperParser.parse();\n          } else if (resource == null && url == null && mapperClass != null) {\n            //10.3使用java类名\n            Class<?> mapperInterface = Resources.classForName(mapperClass);\n            //直接把这个映射加入配置\n            configuration.addMapper(mapperInterface);\n          } else {\n            throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\");\n          }\n        }\n      }\n    }\n  }\n```\n* 回归主线，在 `MapperRegistry` 类的  `getMapper` 方法，可以发现是通过`mapperProxyFactory.newInstance(sqlSession);` 是通过Mapper代理类工厂来获取Mapper的\n```java\n  // 返回代理类\n  public <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n    final MapperProxyFactory<T> mapperProxyFactory = (MapperProxyFactory<T>) knownMappers.get(type);\n    if (mapperProxyFactory == null) {\n      throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n    }\n    try {\n      return mapperProxyFactory.newInstance(sqlSession);\n    } catch (Exception e) {\n      throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n    }\n  }\n```\n* 继续跟进 `mapperProxyFactory.newInstance(sqlSession)` 进入到 `MapperProxyFactory`类中，没错就是在这里生成代理Mapper的，是用JDK自带的动态代理生成映射器\n```java\n/**\n * 映射器代理工厂\n * @author Lasse Voss\n */\npublic class MapperProxyFactory<T> {\n\n  private final Class<T> mapperInterface;\n  private Map<Method, MapperMethod> methodCache = new ConcurrentHashMap<Method, MapperMethod>();\n\n  public MapperProxyFactory(Class<T> mapperInterface) {\n    this.mapperInterface = mapperInterface;\n  }\n\n  public Class<T> getMapperInterface() {\n    return mapperInterface;\n  }\n\n  public Map<Method, MapperMethod> getMethodCache() {\n    return methodCache;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  protected T newInstance(MapperProxy<T> mapperProxy) {\n    // 用JDK自带的动态代理生成映射器\n    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);\n  }\n\n  public T newInstance(SqlSession sqlSession) {\n    final MapperProxy<T> mapperProxy = new MapperProxy<T>(sqlSession, mapperInterface, methodCache);\n    return newInstance(mapperProxy);\n  }\n\n}\n```\n* 看一下`MapperProxy.java` 的真面目，这就是真正的实现类，重点是 `mapperMethod.execute(sqlSession, args);` 这一句，这是真正的执行者\n```java\n/**\n * 映射器代理，代理模式\n * @author Clinton Begin\n * @author Eduardo Macarron\n */\npublic class MapperProxy<T> implements InvocationHandler, Serializable {\n\n  private static final long serialVersionUID = -6424540398559729838L;\n  private final SqlSession sqlSession;\n  private final Class<T> mapperInterface;\n  private final Map<Method, MapperMethod> methodCache;\n\n  public MapperProxy(SqlSession sqlSession, Class<T> mapperInterface, Map<Method, MapperMethod> methodCache) {\n    this.sqlSession = sqlSession;\n    this.mapperInterface = mapperInterface;\n    this.methodCache = methodCache;\n  }\n\n  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法\n    // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行\n    if (Object.class.equals(method.getDeclaringClass())) {\n      try {\n        return method.invoke(this, args);\n      } catch (Throwable t) {\n        throw ExceptionUtil.unwrapThrowable(t);\n      }\n    }\n    // 这里优化了，去缓存中找MapperMethod\n    final MapperMethod mapperMethod = cachedMapperMethod(method);\n    // 真正的执行方法\n    return mapperMethod.execute(sqlSession, args);\n  }\n\n  // 去缓存中找MapperMethod\n  private MapperMethod cachedMapperMethod(Method method) {\n    MapperMethod mapperMethod = methodCache.get(method);\n    if (mapperMethod == null) {\n      // 找不到才去new\n      mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration());\n      methodCache.put(method, mapperMethod);\n    }\n    return mapperMethod;\n  }\n\n}\n```\n## 时序图\n![image](/images/server/mybatis/mapper.png)\n\n## 总结\n* Mapper接口的实现类是Mybatis生成的代理类`MapperProxy.java`，所有接口的代理类是通过`MapperProxyFactory.java` 方法来生成的，这里可以看到Mybatis的高明之处就是所有Mapper接口的代理类都是通过`MapperProxy.java`来实现\n* 因为是Mapper接口，所以Mybatis代理类的实现运用的是JDK的动态代理","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(四)构建SqlSession","url":"/2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(四)构建SqlSession/","content":"## 前言\n有了SqlSessionFactory会话工厂 这个类之后，就可以通过`sqlSessionFactory.openSession();`来生成`SqlSession`了\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 得到SqlSession\nSqlSession sqlSession = sqlSessionFactory.openSession();\n// 得到Mapper\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\nSystem.out.println(userMapper.selectByPrimaryKey(1));\n```\n\n## SqlSession 简介\nSqlsession对应着一次数据库会话。由于数据库会话不是永久的，因此Sqlsession的生命周期也不应该是永久的，相反，在你每次访问数据库时都需要创建它（当然并不是说在Sqlsession里只能执行一次sql，你可以执行多次，当一旦关闭了Sqlsession就需要重新创建它）。创建Sqlsession的地方只有一个，那就是SqlsessionFactory的openSession方法\n\n\n\n## 构建 SqlSession\n* `SqlSession.java`\n```java\n/**\n * 这是MyBatis主要的一个类，用来执行SQL，获取映射器，管理事务\n * The primary Java interface for working with MyBatis.\n * Through this interface you can execute commands, get mappers and manage transactions.\n *\n * @author Clinton Begin\n */\npublic interface SqlSession extends Closeable {\n\n  // 语句执行方法\n  // 这些方法被用来执行SELECT，INSERT，UPDATE和DELETE语句。\n  /**\n   * Retrieve a single row mapped from the statement key\n   * 获取一条记录\n   * @param <T> the returned object type\n   * @param statement\n   * @return Mapped object\n   */\n  <T> T selectOne(String statement);\n\n  /**\n   * Retrieve a single row mapped from the statement key and parameter.\n   * 获取一条记录\n   * @param <T> the returned object type\n   * @param statement Unique identifier matching the statement to use.\n   * @param parameter A parameter object to pass to the statement.\n   * @return Mapped object\n   */\n  <T> T selectOne(String statement, Object parameter);\n\n  /**\n   * Retrieve a list of mapped objects from the statement key and parameter.\n   * 获取多条记录\n   * @param <E> the returned list element type\n   * @param statement Unique identifier matching the statement to use.\n   * @return List of mapped object\n   */\n  <E> List<E> selectList(String statement);\n\n  /**\n   * Retrieve a list of mapped objects from the statement key and parameter.\n   * 获取多条记录\n   * @param <E> the returned list element type\n   * @param statement Unique identifier matching the statement to use.\n   * @param parameter A parameter object to pass to the statement.\n   * @return List of mapped object\n   */\n  <E> List<E> selectList(String statement, Object parameter);\n\n  /**\n   * Retrieve a list of mapped objects from the statement key and parameter,\n   * within the specified row bounds.\n   * 获取多条记录,加上分页\n   * @param <E> the returned list element type\n   * @param statement Unique identifier matching the statement to use.\n   * @param parameter A parameter object to pass to the statement.\n   * @param rowBounds  Bounds to limit object retrieval\n   * @return List of mapped object\n   */\n  <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds);\n\n  /**\n   * The selectMap is a special case in that it is designed to convert a list\n   * of results into a Map based on one of the properties in the resulting\n   * objects.\n   * Eg. Return a of Map[Integer,Author] for selectMap(\"selectAuthors\",\"id\")\n   * 获取多条记录,并存入Map\n   * @param <K> the returned Map keys type\n   * @param <V> the returned Map values type\n   * @param statement Unique identifier matching the statement to use.\n   * @param mapKey The property to use as key for each value in the list.\n   * @return Map containing key pair data.\n   */\n  <K, V> Map<K, V> selectMap(String statement, String mapKey);\n\n  /**\n   * The selectMap is a special case in that it is designed to convert a list\n   * of results into a Map based on one of the properties in the resulting\n   * objects.\n   * 获取多条记录,并存入Map\n   * @param <K> the returned Map keys type\n   * @param <V> the returned Map values type\n   * @param statement Unique identifier matching the statement to use.\n   * @param parameter A parameter object to pass to the statement.\n   * @param mapKey The property to use as key for each value in the list.\n   * @return Map containing key pair data.\n   */\n  <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey);\n\n  /**\n   * The selectMap is a special case in that it is designed to convert a list\n   * of results into a Map based on one of the properties in the resulting\n   * objects.\n   * 获取多条记录,加上分页,并存入Map\n   * @param <K> the returned Map keys type\n   * @param <V> the returned Map values type\n   * @param statement Unique identifier matching the statement to use.\n   * @param parameter A parameter object to pass to the statement.\n   * @param mapKey The property to use as key for each value in the list.\n   * @param rowBounds  Bounds to limit object retrieval\n   * @return Map containing key pair data.\n   */\n  <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds);\n\n  /**\n   * Retrieve a single row mapped from the statement key and parameter\n   * using a {@code ResultHandler}.\n   * 获取一条记录,并转交给ResultHandler处理\n   * @param statement Unique identifier matching the statement to use.\n   * @param parameter A parameter object to pass to the statement.\n   * @param handler ResultHandler that will handle each retrieved row\n   * @return Mapped object\n   */\n  void select(String statement, Object parameter, ResultHandler handler);\n\n  /**\n   * Retrieve a single row mapped from the statement\n   * using a {@code ResultHandler}.\n   * 获取一条记录,并转交给ResultHandler处理\n   * @param statement Unique identifier matching the statement to use.\n   * @param handler ResultHandler that will handle each retrieved row\n   * @return Mapped object\n   */\n  void select(String statement, ResultHandler handler);\n\n  /**\n   * Retrieve a single row mapped from the statement key and parameter\n   * using a {@code ResultHandler} and {@code RowBounds}\n   * 获取一条记录,加上分页,并转交给ResultHandler处理\n   * @param statement Unique identifier matching the statement to use.\n   * @param rowBounds RowBound instance to limit the query results\n   * @param handler ResultHandler that will handle each retrieved row\n   * @return Mapped object\n   */\n  void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler);\n\n  /**\n   * Execute an insert statement.\n   * 插入记录\n   * @param statement Unique identifier matching the statement to execute.\n   * @return int The number of rows affected by the insert.\n   */\n  int insert(String statement);\n\n  /**\n   * Execute an insert statement with the given parameter object. Any generated\n   * autoincrement values or selectKey entries will modify the given parameter\n   * object properties. Only the number of rows affected will be returned.\n   * 插入记录\n   * @param statement Unique identifier matching the statement to execute.\n   * @param parameter A parameter object to pass to the statement.\n   * @return int The number of rows affected by the insert.\n   */\n  int insert(String statement, Object parameter);\n\n  /**\n   * Execute an update statement. The number of rows affected will be returned.\n   * 更新记录\n   * @param statement Unique identifier matching the statement to execute.\n   * @return int The number of rows affected by the update.\n   */\n  int update(String statement);\n\n  /**\n   * Execute an update statement. The number of rows affected will be returned.\n   * 更新记录\n   * @param statement Unique identifier matching the statement to execute.\n   * @param parameter A parameter object to pass to the statement.\n   * @return int The number of rows affected by the update.\n   */\n  int update(String statement, Object parameter);\n\n  /**\n   * Execute a delete statement. The number of rows affected will be returned.\n   * 删除记录\n   * @param statement Unique identifier matching the statement to execute.\n   * @return int The number of rows affected by the delete.\n   */\n  int delete(String statement);\n\n  /**\n   * Execute a delete statement. The number of rows affected will be returned.\n   * 删除记录\n   * @param statement Unique identifier matching the statement to execute.\n   * @param parameter A parameter object to pass to the statement.\n   * @return int The number of rows affected by the delete.\n   */\n  int delete(String statement, Object parameter);\n\n  //以下是事务控制方法,commit,rollback\n  /**\n   * Flushes batch statements and commits database connection.\n   * Note that database connection will not be committed if no updates/deletes/inserts were called.\n   * To force the commit call {@link SqlSession#commit(boolean)}\n   */\n  void commit();\n\n  /**\n   * Flushes batch statements and commits database connection.\n   * @param force forces connection commit\n   */\n  void commit(boolean force);\n\n  /**\n   * Discards pending batch statements and rolls database connection back.\n   * Note that database connection will not be rolled back if no updates/deletes/inserts were called.\n   * To force the rollback call {@link SqlSession#rollback(boolean)}\n   */\n  void rollback();\n\n  /**\n   * Discards pending batch statements and rolls database connection back.\n   * Note that database connection will not be rolled back if no updates/deletes/inserts were called.\n   * @param force forces connection rollback\n   */\n  void rollback(boolean force);\n\n  /**\n   * Flushes batch statements.\n   * 刷新批处理语句,返回批处理结果\n   * @return BatchResult list of updated records\n   * @since 3.0.6\n   */\n  List<BatchResult> flushStatements();\n\n  /**\n   * Closes the session\n   * 关闭Session\n   */\n  @Override\n  void close();\n\n  /**\n   * Clears local session cache\n   * 清理Session缓存\n   */\n  void clearCache();\n\n  /**\n   * Retrieves current configuration\n   * 得到配置\n   * @return Configuration\n   */\n  Configuration getConfiguration();\n\n  /**\n   * Retrieves a mapper.\n   * 得到映射器\n   * 这个巧妙的使用了泛型，使得类型安全\n   * 到了MyBatis 3，还可以用注解,这样xml都不用写了\n   * @param <T> the mapper type\n   * @param type Mapper interface class\n   * @return a mapper bound to this SqlSession\n   */\n  <T> T getMapper(Class<T> type);\n\n  /**\n   * Retrieves inner database connection\n   * 得到数据库连接\n   * @return Connection\n   */\n  Connection getConnection();\n}\n```\n\n* `DefaultSqlSession.java` 是 `SqlSession.java` 接口的默认实现，从`DefaultSqlSessionFactory`构建的是`DefaultSqlSession`, 查看`DefaultSqlSession.java`类成员又可以发现Configuration的影子，Executor成员是MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护\n\n```java\n/**\n * 默认SqlSession\n * @author Clinton Begin\n */\npublic class DefaultSqlSession implements SqlSession {\n\n  private Configuration configuration;\n  private Executor executor;\n\n  private boolean autoCommit;\n  private boolean dirty;\n  \n  public DefaultSqlSession(Configuration configuration, Executor executor, boolean autoCommit) {\n    this.configuration = configuration;\n    this.executor = executor;\n    this.dirty = false;\n    this.autoCommit = autoCommit;\n  }\n\n  public DefaultSqlSession(Configuration configuration, Executor executor) {\n    this(configuration, executor, false);\n  }\n\n  @Override\n  public <T> T selectOne(String statement) {\n    return this.<T>selectOne(statement, null);\n  }\n\n  // 核心selectOne\n  @Override\n  public <T> T selectOne(String statement, Object parameter) {\n    // Popular vote was to return null on 0 results and throw exception on too many.\n    // 转而去调用selectList,很简单的，如果得到0条则返回null，得到1条则返回1条，得到多条报TooManyResultsException错\n    List<T> list = this.<T>selectList(statement, parameter);\n    if (list.size() == 1) {\n      return list.get(0);\n    } else if (list.size() > 1) {\n      throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size());\n    } else {\n      return null;\n    }\n  }\n\n  @Override\n  public <K, V> Map<K, V> selectMap(String statement, String mapKey) {\n    return this.selectMap(statement, null, mapKey, RowBounds.DEFAULT);\n  }\n\n  @Override\n  public <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey) {\n    return this.selectMap(statement, parameter, mapKey, RowBounds.DEFAULT);\n  }\n\n  // 核心selectMap\n  @Override\n  public <K, V> Map<K, V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) {\n    //转而去调用selectList\n    final List<?> list = selectList(statement, parameter, rowBounds);\n    final DefaultMapResultHandler<K, V> mapResultHandler = new DefaultMapResultHandler<K, V>(mapKey,\n        configuration.getObjectFactory(), configuration.getObjectWrapperFactory());\n    final DefaultResultContext context = new DefaultResultContext();\n    for (Object o : list) {\n      // 循环用DefaultMapResultHandler处理每条记录\n      context.nextResultObject(o);\n      mapResultHandler.handleResult(context);\n    }\n    // 注意这个DefaultMapResultHandler里面存了所有已处理的记录(内部实现可能就是一个Map)，最后再返回一个Map\n    return mapResultHandler.getMappedResults();\n  }\n\n  @Override\n  public <E> List<E> selectList(String statement) {\n    return this.selectList(statement, null);\n  }\n\n  @Override\n  public <E> List<E> selectList(String statement, Object parameter) {\n    return this.selectList(statement, parameter, RowBounds.DEFAULT);\n  }\n\n  // 核心selectList\n  @Override\n  public <E> List<E> selectList(String statement, Object parameter, RowBounds rowBounds) {\n    try {\n      // 根据statement id找到对应的MappedStatement\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      // 转而用执行器来查询结果,注意这里传入的ResultHandler是null\n      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  @Override\n  public void select(String statement, Object parameter, ResultHandler handler) {\n    select(statement, parameter, RowBounds.DEFAULT, handler);\n  }\n\n  @Override\n  public void select(String statement, ResultHandler handler) {\n    select(statement, null, RowBounds.DEFAULT, handler);\n  }\n\n  //核心select,带有ResultHandler，和selectList代码差不多的，区别就一个ResultHandler\n  @Override\n  public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) {\n    try {\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      executor.query(ms, wrapCollection(parameter), rowBounds, handler);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error querying database.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  @Override\n  public int insert(String statement) {\n    return insert(statement, null);\n  }\n\n  @Override\n  public int insert(String statement, Object parameter) {\n    //insert也是调用update\n    return update(statement, parameter);\n  }\n\n  @Override\n  public int update(String statement) {\n    return update(statement, null);\n  }\n\n  // 核心update\n  @Override\n  public int update(String statement, Object parameter) {\n    try {\n      // 每次要更新之前，dirty标志设为true\n      dirty = true;\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      // 转而用执行器来update结果\n      return executor.update(ms, wrapCollection(parameter));\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error updating database.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  @Override\n  public int delete(String statement) {\n    //delete也是调用update\n    return update(statement, null);\n  }\n\n  @Override\n  public int delete(String statement, Object parameter) {\n    return update(statement, parameter);\n  }\n\n  @Override\n  public void commit() {\n    commit(false);\n  }\n\n  // 核心commit\n  @Override\n  public void commit(boolean force) {\n    try {\n      // 转而用执行器来commit\n      executor.commit(isCommitOrRollbackRequired(force));\n      // 每次commit之后，dirty标志设为false\n      dirty = false;\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error committing transaction.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  @Override\n  public void rollback() {\n    rollback(false);\n  }\n\n  // 核心rollback\n  @Override\n  public void rollback(boolean force) {\n    try {\n      // 转而用执行器来rollback\n      executor.rollback(isCommitOrRollbackRequired(force));\n      // 每次rollback之后，dirty标志设为false\n      dirty = false;\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error rolling back transaction.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  // 核心flushStatements\n  @Override\n  public List<BatchResult> flushStatements() {\n    try {\n      // 转而用执行器来flushStatements\n      return executor.flushStatements();\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error flushing statements.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  // 核心close\n  @Override\n  public void close() {\n    try {\n      // 转而用执行器来close\n      executor.close(isCommitOrRollbackRequired(false));\n      // 每次close之后，dirty标志设为false\n      dirty = false;\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  @Override\n  public Configuration getConfiguration() {\n    return configuration;\n  }\n\n  @Override\n  public <T> T getMapper(Class<T> type) {\n    // 最后会去调用MapperRegistry.getMapper\n    return configuration.<T>getMapper(type, this);\n  }\n\n  @Override\n  public Connection getConnection() {\n    try {\n      return executor.getTransaction().getConnection();\n    } catch (SQLException e) {\n      throw ExceptionFactory.wrapException(\"Error getting a new connection.  Cause: \" + e, e);\n    }\n  }\n\n  // 核心clearCache\n  @Override\n  public void clearCache() {\n    // 转而用执行器来clearLocalCache\n    executor.clearLocalCache();\n  }\n\n  // 检查是否需要强制commit或rollback\n  private boolean isCommitOrRollbackRequired(boolean force) {\n    return (!autoCommit && dirty) || force;\n  }\n\n  // 把参数包装成Collection\n  private Object wrapCollection(final Object object) {\n    if (object instanceof Collection) {\n      // 参数若是Collection型，做collection标记\n      StrictMap<Object> map = new StrictMap<Object>();\n      map.put(\"collection\", object);\n      if (object instanceof List) {\n        // 参数若是List型，做list标记\n        map.put(\"list\", object);\n      }\n      return map;      \n    } else if (object != null && object.getClass().isArray()) {\n      // 参数若是数组型，，做array标记\n      StrictMap<Object> map = new StrictMap<Object>();\n      map.put(\"array\", object);\n      return map;\n    }\n    // 参数若不是集合型，直接返回原来值\n    return object;\n  }\n\n  // 严格的Map，如果找不到对应的key，直接抛BindingException例外，而不是返回null\n  public static class StrictMap<V> extends HashMap<String, V> {\n\n    private static final long serialVersionUID = -5741767162221585340L;\n\n    @Override\n    public V get(Object key) {\n      if (!super.containsKey(key)) {\n        throw new BindingException(\"Parameter '\" + key + \"' not found. Available parameters are \" + this.keySet());\n      }\n      return super.get(key);\n    }\n\n  }\n\n}\n```\n## 时序图\n![iamge](/images/server/mybatis/SqlSessionFactory.png)\n\n## 总结\n* 通过源码可以看到`SqlSession`就像是公司的前台人员，正在干活的是 `Executor` ，人家来找公司谈合作，首先先和前台人员联系，然后再通过前台将人指到真正的实施者\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(三)构建SqlSessionFactory会话工厂","url":"/2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(三)构建SqlSessionFactory会话工厂/","content":"## 前言\n有了Mybatis整体脉络概念之后，现在就是来构建 SqlSessionFactory会话工厂 这个类了\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 得到SqlSession\nSqlSession sqlSession = sqlSessionFactory.openSession();\n// 得到Mapper\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\nSystem.out.println(userMapper.selectByPrimaryKey(1));\n```\n## SqlSessionFactory 简介\nSqlSessionFactory 是Mybatis的关键对象， 是创建SqlSession的工厂，工厂模式，SqlSessionFactory 由 SqlSessionFactoryBuilder 构建，每一个MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心\n\n![logo](/images/server/mybatis/SqlSessionFactory.jpg)\n\nSqlSessionFactory是个接口，它有两个实现类 `DefaultSqlSessionFactory.java`, `SqlSessionManager.java` ，Mybatis使用的是`DefaultSqlSessionFactory.java` 来作为其默认实现\n```java\npublic interface SqlSessionFactory {\n  SqlSession openSession();\n  SqlSession openSession(boolean autoCommit);\n  SqlSession openSession(Connection connection);\n  SqlSession openSession(TransactionIsolationLevel level);\n  SqlSession openSession(ExecutorType execType);\n  SqlSession openSession(ExecutorType execType, boolean autoCommit);\n  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);\n  SqlSession openSession(ExecutorType execType, Connection connection);\n  Configuration getConfiguration();\n}\n```\n\n\n## 构建 SqlSessionFactory \n* SqlSessionFactory 是通过`SqlSessionFactoryBuilder.java` 来构建的，build方法传入了一个配置文件的输入流\n\n* 打开`SqlSessionFactoryBuilder.java`类，可以发现都是build的重载方法，主要有有俩种配置文件的输入方式，一个是Reader ，另一个是通过InputStream，可以看到里面是通过`XMLConfigBuilder.java`来解析xml文件的，\n```java\npublic class SqlSessionFactoryBuilder {\n\n  public SqlSessionFactory build(Reader reader) {\n    return build(reader, null, null);\n  }\n\n  public SqlSessionFactory build(Reader reader, String environment) {\n    return build(reader, environment, null);\n  }\n\n  public SqlSessionFactory build(Reader reader, Properties properties) {\n    return build(reader, null, properties);\n  }\n\n  // 第4种方法是最常用的，它使用了一个参照了XML文档或更特定的SqlMapConfig.xml文件的Reader实例。\n  public SqlSessionFactory build(Reader reader, String environment, Properties properties) {\n    try {\n      // 委托XMLConfigBuilder来解析xml文件，并构建\n      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);\n      return build(parser.parse());\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n      ErrorContext.instance().reset();\n      try {\n        reader.close();\n      } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n      }\n    }\n  }\n\n  //以下3个方法都是调用下面第8种方法\n  public SqlSessionFactory build(InputStream inputStream) {\n    return build(inputStream, null, null);\n  }\n\n  public SqlSessionFactory build(InputStream inputStream, String environment) {\n    return build(inputStream, environment, null);\n  }\n\n  public SqlSessionFactory build(InputStream inputStream, Properties properties) {\n    return build(inputStream, null, properties);\n  }\n\n  // 第8种方法和第4种方法差不多，Reader换成了InputStream\n  // 可选的参数是environment和properties。Environment决定加载哪种环境(开发环境/生产环境)，包括数据源和事务管理器。\n  // 如果使用properties，那么就会加载那些properties（属性配置文件），那些属性可以用${propName}语法形式多次用在配置文件中。和Spring很像，一个思想？\n  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {\n    try {\n      // 委托XMLConfigBuilder来解析xml文件\n      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);\n      return build(parser.parse());\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e);\n    } finally {\n      ErrorContext.instance().reset();\n      try {\n        inputStream.close();\n      } catch (IOException e) {\n        // Intentionally ignore. Prefer previous error.\n      }\n    }\n  }\n    \n  //最后一个build方法使用了一个Configuration作为参数,并返回DefaultSqlSessionFactory\n  public SqlSessionFactory build(Configuration config) {\n    return new DefaultSqlSessionFactory(config);\n  }\n\n}\n```\n* 打开`XMLConfigBuilder.java`\n```java\n/**\n * XML配置构建器，建造者模式,继承BaseBuilder\n * @author Clinton Begin\n */\npublic class XMLConfigBuilder extends BaseBuilder {\n\n  // 是否已解析，XPath解析器\n  private boolean parsed;\n  // XPath解析器\n  private XPathParser parser;\n  // 环境\n  private String environment;\n\n  // 以下3个一组\n  public XMLConfigBuilder(Reader reader) {\n    this(reader, null, null);\n  }\n\n  public XMLConfigBuilder(Reader reader, String environment) {\n    this(reader, environment, null);\n  }\n\n  // 构造函数，转换成XPathParser再去调用构造函数\n  public XMLConfigBuilder(Reader reader, String environment, Properties props) {\n    // 构造一个需要验证，XMLMapperEntityResolver的XPathParser\n    this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props);\n  }\n\n  // 以下3个一组\n  public XMLConfigBuilder(InputStream inputStream) {\n    this(inputStream, null, null);\n  }\n\n  public XMLConfigBuilder(InputStream inputStream, String environment) {\n    this(inputStream, environment, null);\n  }\n\n  public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) {\n    this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props);\n  }\n\n  // 上面6个构造函数最后都合流到这个函数，传入XPathParser\n  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) {\n    // 首先调用父类初始化Configuration\n    super(new Configuration());\n    // 错误上下文设置成SQL Mapper Configuration(XML文件配置),以便后面出错了报错用\n    ErrorContext.instance().resource(\"SQL Mapper Configuration\");\n    // 将Properties全部设置到Configuration里面去\n    this.configuration.setVariables(props);\n    this.parsed = false;\n    this.environment = environment;\n    this.parser = parser;\n  }\n\n  // 解析配置\n  public Configuration parse() {\n    // 如果已经解析过了，报错\n    if (parsed) {\n      throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\");\n    }\n    parsed = true;\n//  <?xml version=\"1.0\" encoding=\"UTF-8\" ?> \n//  <!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \n//  \"http://mybatis.org/dtd/mybatis-3-config.dtd\"> \n//  <configuration> \n//  <environments default=\"development\"> \n//  <environment id=\"development\"> \n//  <transactionManager type=\"JDBC\"/> \n//  <dataSource type=\"POOLED\"> \n//  <property name=\"driver\" value=\"${driver}\"/> \n//  <property name=\"url\" value=\"${url}\"/> \n//  <property name=\"username\" value=\"${username}\"/> \n//  <property name=\"password\" value=\"${password}\"/> \n//  </dataSource> \n//  </environment> \n//  </environments> \n//  <mappers>  \n//  <mapper resource=\"org/mybatis/ex ample/BlogMapper.xml\"/> \n//  </mappers>  \n//  </configuration>\n    \n    // 根节点是configuration\n    parseConfiguration(parser.evalNode(\"/configuration\"));\n    return configuration;\n  }\n\n  // 解析配置\n  private void parseConfiguration(XNode root) {\n    try {\n      // 分步骤解析\n      //issue #117 read properties first\n      //1.properties\n      propertiesElement(root.evalNode(\"properties\"));\n      // 2.类型别名\n      typeAliasesElement(root.evalNode(\"typeAliases\"));\n      // 3.插件\n      pluginElement(root.evalNode(\"plugins\"));\n      // 4.对象工厂\n      objectFactoryElement(root.evalNode(\"objectFactory\"));\n      // 5.对象包装工厂\n      objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\"));\n      // 6.设置\n      settingsElement(root.evalNode(\"settings\"));\n      // read it after objectFactory and objectWrapperFactory issue #631\n      // 7.环境\n      environmentsElement(root.evalNode(\"environments\"));\n      // 8.databaseIdProvider\n      databaseIdProviderElement(root.evalNode(\"databaseIdProvider\"));\n      // 9.类型处理器\n      typeHandlerElement(root.evalNode(\"typeHandlers\"));\n      // 10.映射器\n      mapperElement(root.evalNode(\"mappers\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e);\n    }\n  }\n  \n  \n  ..... 未完\n```\n* XMLMapperBuilder.java 这个类是解析sql映射文件的 ，下面是核心代码， 可以看到Mybatis是将`select|insert|update|delete`这些都作为一个单独的节点\n```java\n  // 解析\n  public void parse() {\n    // 如果没有加载过再加载，防止重复加载\n    if (!configuration.isResourceLoaded(resource)) {\n      // 解析mapper节点\n      configurationElement(parser.evalNode(\"/mapper\"));\n      // 标记一下，已经加载过了\n      configuration.addLoadedResource(resource);\n      // 绑定映射器到namespace\n      bindMapperForNamespace();\n    }\n    parsePendingResultMaps();\n    parsePendingChacheRefs();\n    parsePendingStatements();\n  }\n\n  public XNode getSqlFragment(String refid) {\n    return sqlFragments.get(refid);\n  }\n\n\t//配置mapper元素\n//\t<mapper namespace=\"org.mybatis.example.BlogMapper\">\n//\t  <select id=\"selectBlog\" parameterType=\"int\" resultType=\"Blog\">\n//\t    select * from Blog where id = #{id}\n//\t  </select>\n//\t</mapper>\n  private void configurationElement(XNode context) {\n    try {\n      //1.配置namespace\n      String namespace = context.getStringAttribute(\"namespace\");\n      if (namespace.equals(\"\")) {\n        throw new BuilderException(\"Mapper's namespace cannot be empty\");\n      }\n      builderAssistant.setCurrentNamespace(namespace);\n      //2.配置cache-ref\n      cacheRefElement(context.evalNode(\"cache-ref\"));\n      //3.配置cache\n      cacheElement(context.evalNode(\"cache\"));\n      //4.配置parameterMap(已经废弃,老式风格的参数映射)\n      parameterMapElement(context.evalNodes(\"/mapper/parameterMap\"));\n      //5.配置resultMap(高级功能)\n      resultMapElements(context.evalNodes(\"/mapper/resultMap\"));\n      //6.配置sql(定义可重用的 SQL 代码段)\n      sqlElement(context.evalNodes(\"/mapper/sql\"));\n      //7.配置select|insert|update|delete TODO\n      buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\"));\n    } catch (Exception e) {\n      throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e);\n    }\n  }\n```\n* `DefaultSqlSessionFactory.java` 是构造SqlSession的默认实现，可以看到实现都是通过`configuration`该对象来获取配置信息，从而构造SqlSession\n```java\n/**\n * 默认实现的SqlSessionFactory\n * @author Clinton Begin\n */\npublic class DefaultSqlSessionFactory implements SqlSessionFactory {\n\n  private final Configuration configuration;\n\n  public DefaultSqlSessionFactory(Configuration configuration) {\n    this.configuration = configuration;\n  }\n\n  // 最终都会调用2种方法：openSessionFromDataSource,openSessionFromConnection\n  // 以下6个方法都会调用openSessionFromDataSource\n  @Override\n  public SqlSession openSession() {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);\n  }\n\n  @Override\n  public SqlSession openSession(boolean autoCommit) {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, autoCommit);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType) {\n    return openSessionFromDataSource(execType, null, false);\n  }\n\n  @Override\n  public SqlSession openSession(TransactionIsolationLevel level) {\n    return openSessionFromDataSource(configuration.getDefaultExecutorType(), level, false);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level) {\n    return openSessionFromDataSource(execType, level, false);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType, boolean autoCommit) {\n    return openSessionFromDataSource(execType, null, autoCommit);\n  }\n\n  //以下2个方法都会调用openSessionFromConnection\n  @Override\n  public SqlSession openSession(Connection connection) {\n    return openSessionFromConnection(configuration.getDefaultExecutorType(), connection);\n  }\n\n  @Override\n  public SqlSession openSession(ExecutorType execType, Connection connection) {\n    return openSessionFromConnection(execType, connection);\n  }\n\n  @Override\n  public Configuration getConfiguration() {\n    return configuration;\n  }\n\n  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {\n    Transaction tx = null;\n    try {\n      final Environment environment = configuration.getEnvironment();\n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n      // 通过事务工厂来产生一个事务\n      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);\n      // 生成一个执行器(事务包含在执行器里)\n      final Executor executor = configuration.newExecutor(tx, execType);\n      // 然后产生一个DefaultSqlSession\n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      // 如果打开事务出错，则关闭它\n      closeTransaction(tx); // may have fetched a connection so lets call close()\n      throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n      //最后清空错误上下文\n      ErrorContext.instance().reset();\n    }\n  }\n\n  private SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) {\n    try {\n      boolean autoCommit;\n      try {\n        autoCommit = connection.getAutoCommit();\n      } catch (SQLException e) {\n        // Failover to true, as most poor drivers\n        // or databases won't support transactions\n        autoCommit = true;\n      }      \n      final Environment environment = configuration.getEnvironment();\n      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);\n      final Transaction tx = transactionFactory.newTransaction(connection);\n      final Executor executor = configuration.newExecutor(tx, execType);\n      return new DefaultSqlSession(configuration, executor, autoCommit);\n    } catch (Exception e) {\n      throw ExceptionFactory.wrapException(\"Error opening session.  Cause: \" + e, e);\n    } finally {\n      ErrorContext.instance().reset();\n    }\n  }\n\n  private TransactionFactory getTransactionFactoryFromEnvironment(Environment environment) {\n    // 如果没有配置事务工厂，则返回托管事务工厂\n    if (environment == null || environment.getTransactionFactory() == null) {\n      return new ManagedTransactionFactory();\n    }\n    return environment.getTransactionFactory();\n  }\n\n  private void closeTransaction(Transaction tx) {\n    if (tx != null) {\n      try {\n        tx.close();\n      } catch (SQLException ignore) {\n        // Intentionally ignore. Prefer previous error.\n      }\n    }\n  }\n}\n```\n## 时序图\n![iamge](/images/server/mybatis/SqlSessionFactory.png)\n\n## 总结\n1. 涉及到两种设计模式：工厂模式(SqlSessionFactory.java)及建造者模式(XMLConfigBuilder.java)，通过命名可以发现其设计思想，学习大佬的命名规范\n2. SqlSessionFactory接口的默认实现是`DefaultSqlSessionFactory.java` DefaultSqlSessionFactory只有一个成员变量 Configuration ，所以构建SqlSessionFactory其实就是解析xml文件，构建Configuration的过程，Configuration是Mybatis的大头，所有的配置信息都存在里面\n3. 通过其运行流程可以看到每个类都有其独有的用途，各司其职，有生产SqlSession的类，又解析xml的类，有生产SqlSessionFactory的类，各个模块相互配合\n\n\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(二)Mybatis框架架构","url":"/2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二)Mybatis框架架构/","content":"## 引言\n本文主要讲解Mybatis的整体程序设计，理清楚框架的主要脉络，这样才能对源码有个整体的了解，先主干后分支，如果没有这些概念那么直接看源码的话肯定会很吃力的\n\n## 整体设计\n整体架构图\n![logo](/images/server/mybatis/mybatis-framework.png) \n\n### 运作流程\n#### (1)、加载配置并初始化\nMybatis配置包括两种配置，一种是Mybatis自身的框架配置，另一种是sql映射配置，Mybatis自身的框架配置有两种方式可以配置， 一处是配置文件，另一处是通过Java注解进行配置， 比如说Spring Boot项目整合Mybatis都是通过Java代码的方式来进行配置\n\n初始化是初始化框架基本配置，然后解析sql映射文件，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。\n\n#### (2)、接收调用请求\n通过接口来接收调用请求，真实企业环境一般都是通过接口的方式来进行调用，通过该接口将请求传递给下层的请求处理层进行处理。\n> 传统Mybatis工作模式，是创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。\n\n![image](/images/server/mybatis/mybatis-call2.png)\n\n> 接口工作模式，MyBatis 将配置文件中的每一个<mapper> 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟<mapper> 节点中的<select|update|delete|insert> 节点项对应，即<select|update|delete|insert> 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。\n\n![image](/images/server/mybatis/mybatis-call1.png)\n\n#### (3)、处理操作请求\n处理操作包括参数映射，sql解析，sql执行操作\n\n#### (4)、返回请求结果\n将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。\n\n\n## MyBatis的主要的核心部件\n![logo](/images/server/mybatis/mybatis-framework2.png) \n\n|    类名    |       描述       |\n|:-------|:------------- |\n|  SqlSession   |  作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能     | \n|  Executor   |   MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护    | \n|  StatementHandler   |  封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。     | \n|  ParameterHandler   |  负责对用户传递的参数转换成JDBC Statement 所需要的参数     | \n|  ResultSetHandler   |  负责将JDBC返回的ResultSet结果集对象转换成List类型的集合     | \n|  TypeHandler   |  负责java数据类型和jdbc数据类型之间的映射和转换     | \n|  MappedStatement   | MappedStatement维护了一条select update delete insert节点的封装      | \n|  SqlSource   |   负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中并返回    | \n|  BoundSql   |   表示动态生成的SQL语句以及相应的参数信息    | \n|  Configuration   |  MyBatis所有的配置信息都维持在Configuration对象之中。     | \n\n\n\n参考：\n\nhttps://blog.csdn.net/luanlouis/article/details/40422941\n\nhttp://chenjc-it.iteye.com/blog/1460990\n","tags":["mybatis"],"categories":["服务器"]},{"title":"Mybatis源码(一)本地编译Mybatis的源码","url":"/2018/11/21/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(一)本地编译Mybatis的源码/","content":"## 引言\n在开发过程中，对于Mybatis框架一直都是在使用阶段，对于其底层实现的细节不是十分清楚，所以利用空余时间学习Mybatis的源码，学习其设计思想，看看大佬是怎样设计一个框架的，提升自己的代码能力\n\n## 下载源码\n|  地址 |       网站    |     \n|:-------|:------------- |\n|  中文官网  |     http://www.mybatis.org/mybatis-3/zh/index.html    |  \n|源码地址|https://github.com/mybatis/mybatis-3|\n\n> 下载完源码包后使用maven进行编译 `mvn clean install` 可以发现会报error\n\n* 查看`pom.xml` 发现又一个父级依赖\n\n```xml\n  <parent>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-parent</artifactId>\n    <version>33-SNAPSHOT</version>\n  </parent>\n```\n* 所以需要把这些依赖下载下来\n```xml\n// 下载代码\ngit clone https://github.com/mybatis/parent.git\n\n// 编译代码\nmvn clean install\n```\n\n* 父级依赖完成之后更改Mybatis的源码，注意版本号需要一致\n```xml\n<parent>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-parent</artifactId>\n    <version>33-SNAPSHOT</version>\n    <relativePath>../parent/pom.xml</relativePath>\n  </parent>\n```\n* 解决部分插件版本问题\n\n告诉我们部分插件没有指定的相应的版本号，出于工程的稳定性考虑需要对使用的插件指定其版本号，并给出了合适的版本号，如图红色方框中的文字。我们只要在mybatisg工程的pom.xml文件中找到相对应的插件处添加<version>$NUM</version> 标签即可， $NUM代表具体的版本号。到这我们再执行mvn clean install 指令就可以将mybatis工程构建成功了。\n\n## 源码基本结构\n打开源码可以发现如下目录，通过包名就可以大概知道其模块功能\n\n![image](/images/server/mybatis/mybatis-source.jpg)\n\n## 解析\n以下章节将从下面的示例代码来一步步解析Mybatis的源码，分析其实现过程\n```java\n// 读取配置文件\nFile file = new File(\"src/test/java/resources/mybatis-config.xml\");\nInputStream inputStream = new FileInputStream(file);\n// 构建SqlSessionFactory会话工厂\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\n// 构建SqlSession\nSqlSession sqlSession = sqlSessionFactory.openSession();\n// 通过SqlSession来获取Mapper\nUserMapper userMapper = sqlSession.getMapper(UserMapper.class);\nSystem.out.println(userMapper.selectByPrimaryKey(1));~\n```\n\n--------------------- \n参考：https://blog.csdn.net/yums467/article/details/52801288 \n\n\n","tags":["mybatis"],"categories":["服务器"]},{"title":"SpringBoot配置Mybatis多数据源","url":"/2018/11/09/backend/framework/mybatis/SpringBoot配置Mybatis多数据源/","content":"### 背景\n同一个项目数据操作有时会涉及到多个数据库，所以需要在后台配置多个数据源，通过特定的设置选择指定的数据库\n\n### 目的\n可以配置多个数据源，项目默认使用master数据源，当有新的数据源需求时，可以通过注解的形式动态切换数据源\n\n### 实现\n源码: `https://github.com/songshuiyang/iframe`\n\n> `application.yml` 配置数据源\n```xml\nspring:\n  application:\n    name: iframe\n# 主数据库\nmaster:\n  datasource:\n    use-jndi: false\n    jndi-name: jdbc/datasource\n    url: jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&useSSL=false\n    username: root\n    password: root\n    driver-class: com.mysql.jdbc.Driver\n    initial-size: 0\n    min-idle: 10\n    max-active: 100\n    max-wait: 20000\n# 从数据库\nslave:\n  datasource:\n    use-jndi: false\n    jndi-name: jdbc/datasource\n    url: jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&useSSL=false\n    username: root\n    password: root\n    driver-class: com.mysql.jdbc.Driver\n    initial-size: 0\n    min-idle: 10\n    max-active: 100\n    max-wait: 20000\n```\n> `Config.java` 解析数据源配置\n\n```java\n/**\n * 继承TransactionManagementConfigurer可以自定义事务管理器\n * @author songsy\n * @Date 2018/11/7 17:09\n */\n@Configuration\n@EnableTransactionManagement\npublic class Config implements TransactionManagementConfigurer {\n\n    private static final Logger logger = LoggerFactory.getLogger(Config.class);\n\n    @Autowired\n    Environment env;\n\n    /**\n     * 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器\n     *\n     * @return\n     */\n    @Override\n    public PlatformTransactionManager annotationDrivenTransactionManager() {\n        return transactionManager();\n    }\n\n    /**\n     * 数据源\n     *\n     * @return\n     */\n    @Bean(name = \"dataSource\")\n    public DynamicDataSource dataSource() {\n        Map<Object, Object> targetDataSources = new HashMap<>();\n        for (String prefix : DATA_SOURCE_PREFIX) {\n            targetDataSources.put(prefix, createDataSource(prefix));\n        }\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        dynamicDataSource.setTargetDataSources(targetDataSources);\n        dynamicDataSource.setDefaultTargetDataSource(targetDataSources.get(MASTER_DATA_SOURCE_PREFIX));\n        return dynamicDataSource;\n    }\n\n    /**\n     * 创建事务管理器\n     *\n     * @return\n     */\n    @Bean\n    public PlatformTransactionManager transactionManager() {\n        DataSourceTransactionManager txManager = new DataSourceTransactionManager();\n        txManager.setDataSource(dataSource());\n        return txManager;\n    }\n\n    /**\n     * 创建数据源\n     *\n     * @param prefix\n     * @return\n     */\n    private DataSource createDataSource(String prefix) {\n        // 是否使用数据源\n        boolean useJndi = env.getProperty(prefix + \".\" + \"datasource.use-jndi\", Boolean.class, false);\n        // 数据源名称\n        String jndiName = env.getProperty(prefix + \".\" + \"datasource.jndi-name\", \"\");\n        // 数据库链接\n        String url = env.getProperty(prefix + \".\" + \"datasource.url\", \"\");\n        String username = env.getProperty(prefix + \".\" + \"datasource.username\", \"\");\n        String password = env.getProperty(prefix + \".\" + \"datasource.password\", \"\");\n        String driverClass = env.getProperty(prefix + \".\" + \"datasource.driver-class\", \"\");\n        // 数据源默认初始链接数\n        int initialSize = env.getProperty(prefix + \".\" + \"datasource.initial-size\", Integer.class,\n                DataSouceConstant.DEFAULT_DATASOURCE_INIT_SIZE);\n        // 数据源最大连接数\n        int maxActive = env.getProperty(prefix + \".\" + \"datasource.max-active\", Integer.class,\n                DataSouceConstant.DEFAULT_DATASOURCE_MAX_ACTIVE);\n        // 数据源最小连接数\n        int minIdle = env.getProperty(prefix + \".\" + \"datasource.min-idle\", Integer.class,\n                DataSouceConstant.DEFAULT_DATASOURCE_MIN_IDLE);\n        // 配置获取连接等待超时的时间\n        int maxWait = env.getProperty(prefix + \".\" + \"datasource.max-wait\", Integer.class,\n                DataSouceConstant.DEFAULT_DATASOURCE_MAX_WAIT);\n        if (useJndi) {\n            try {\n                logger.debug(\"get datasource from jndi - [{}].\", jndiName);\n                Context context = new InitialContext();\n                DataSource dataSource = (DataSource) context.lookup(jndiName);\n                return dataSource;\n            } catch (Exception e) {\n                logger.error(e.getMessage(), e);\n            }\n        } else {\n            logger.debug(\"create druid datasource.\");\n            logger.debug(\"url - {}.\", url);\n            logger.debug(\"username - {}.\", username);\n            logger.debug(\"password - {}.\", password);\n            logger.debug(\"driverClass - {}.\", driverClass);\n            logger.debug(\"initialSize - {}.\", initialSize);\n            logger.debug(\"maxActive - {}.\", maxActive);\n            logger.debug(\"minIdle - {}.\", minIdle);\n\n            try {\n                DruidDataSource datasource = new DruidDataSource();\n                datasource.setUrl(url);\n                datasource.setDriverClassName(driverClass);\n                datasource.setUsername(username);\n                datasource.setPassword(password);\n                datasource.setInitialSize(initialSize);\n                datasource.setMaxActive(maxActive);\n                datasource.setMinIdle(minIdle);\n                datasource.setMaxWait(maxWait);\n                datasource.setFilters(\"stat,slf4j\");\n                datasource.setProxyFilters(getDruidFilters());\n                return datasource;\n            } catch (Exception e) {\n            }\n\n        }\n        return null;\n    }\n\n    public List<Filter> getDruidFilters() {\n        Slf4jLogFilter slf4jLogFilter = new Slf4jLogFilter();\n        slf4jLogFilter.setDataSourceLogEnabled(false);\n        slf4jLogFilter.setStatementLogEnabled(false);\n        slf4jLogFilter.setStatementExecutableSqlLogEnable(true);\n        slf4jLogFilter.setResultSetLogEnabled(false);\n        slf4jLogFilter.setResultSetCloseAfterLogEnabled(false);\n        slf4jLogFilter.setConnectionLogEnabled(false);\n        List<Filter> filters = new ArrayList<>();\n        filters.add(new StatFilter());\n        filters.add(slf4jLogFilter);\n        return filters;\n    }\n}\n```\n> 新增 `@BindingDataSources` 注解，通过该注解实现数据源切换\n\n```java\n/**\n * 绑定数据源注解\n * @author songsy\n * @Date 2018/11/7 17:33\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface BindingDataSources {\n\n    String value() default \"master\";\n\n}\n```\n> 新增 `DynamicDataSource.java` 实现切换数据源\n\n```java\n/**\n * 继承AbstractRoutingDataSource实现determineCurrentLookupKey方法，该方法可以实现数据库的动态切换\n * @author songsy\n * @Date 2018/11/7 17:17\n */\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return DynamicDataSourceHolder.getDataSource();\n    }\n}\n\n```\n\n> 新增 `DynamicDataSourceHolder.java` 保存当前线程绑定的数据源信息\n```java\n/**\n * 保存当前线程绑定的数据源信息\n * @author songsy\n * @Date 2018/11/7 17:18\n */\npublic class DynamicDataSourceHolder {\n\n    private static final ThreadLocal<String> dataSourceHolder = new ThreadLocal<>();\n\n    public static void setDataSource(String dataSource) {\n        Assert.notNull(dataSource, \"dataSource cannot be null\");\n        dataSourceHolder.set(dataSource);\n    }\n\n    public static String getDataSource() {\n        return dataSourceHolder.get();\n    }\n\n    public static void removeDataSource() {\n        dataSourceHolder.remove();\n    }\n\n}\n```\n\n> 通过 `DynamicDataSourceAspect.java` AOP切面来获取数据源注解信息并设置到 ` private static final ThreadLocal<String> dataSourceHolder = new ThreadLocal<>();` 变量中，那么`determineCurrentLookupKey` 方法就可以根据当前线程数据源key值去动态切换数据源\n\n```java\n/**\n * 配置数据源切面\n * @author songsy\n * @Date 2018/11/7 17:35\n */\n@Aspect\n@Order(-1)// 保证该AOP在@Transactional之前执行\n@Component\npublic class DynamicDataSourceAspect {\n\n    private final static Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class);\n\n    @Pointcut(\"@annotation(com.songsy.iframe.core.persistence.datasource.annotation.BindingDataSources)\")\n    public void pointcut() {\n    }\n\n    @Before(\"pointcut() && @annotation(bindingDataSources)\")\n    public void setDynamicDataSource(JoinPoint point, BindingDataSources bindingDataSources) {\n        Object target = point.getTarget();\n        Method method = ((MethodSignature) point.getSignature()).getMethod();\n        logger.debug(\"切换数据源:  类名 - {}\", target.getClass().getCanonicalName());\n        logger.debug(\"切换数据源: 方法名 - {}\", method.getName());\n        String key = bindingDataSources.value();\n        DynamicDataSourceHolder.setDataSource(key);\n        logger.debug(\"切换数据源：[{}] 数据源切换成功.\", DynamicDataSourceHolder.getDataSource());\n    }\n\n    @After(\"pointcut()\")\n    public void clearDynamicDataSource(JoinPoint point) {\n        DynamicDataSourceHolder.removeDataSource();\n    }\n}\n```","tags":["Spring"],"categories":["服务器"]},{"title":"Mybatis通用增删改查实现","url":"/2018/11/04/backend/framework/mybatis/Mybatis通用增删改查实现/","content":"# iframe\n* 一个基于Mybtais的通用增删改查功能的工具包，mapper接口只要继承相应的接口，实体类添加几个注解即可面向对象操作数据\n* iframe 基于`Spring boot, Gradle, mybatis3`实现，代码已通过测试\n\n\n代码： `https://github.com/songshuiyang/iframe`\n\n### 为什么有这个开发需求：\n* 1、在实际整合了`Mybatis`的项目开发过程中经常会遇到变更数据库字段的情况，如果表结构发生了变化就需要重新修改mapper对应的xml文件，每次修改都要同步更新xml文件。\n* 2、在普通的mapper接口中发现普通的增删改查这些方法每一个mapper接口都有，通过对比可以发现方法除了实体类属性不一样之外，其他的都一样(如下所示)，而且mapper文件也有大量增删改查的sql\n```java\n    int deleteByPrimaryKey(E id);\n\n    int insert(T record);\n\n    int insertSelective(T record);\n\n    T selectByPrimaryKey(E id);\n\n    int updateByPrimaryKeySelective(T record);\n\n    int updateByPrimaryKey(T id);\n```\n\n### Mybatis 和 Hibernate 优缺点对比\n\n> 现在开源项目中持久层框架用到最多的基本就是 MyBatis 和 Hibernate\n\n#### Mybatis\n##### 优点\n* Mybatis入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验\n* 可以进行更为细致的SQL优化，可以减少查询字段\n##### 缺点\n* 虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。\n\n#### Hibernate\n##### 优点\n* 不需要编写的SQL语句(不需要编辑JDBC)，只需要操作相应的对象就可以了，就可以能够存储、更新、删除、加载对象，可以提高生产效率\n* 使用Hibernate，移植性好\n##### 缺点\n* 由于对持久层封装过于完整，导致开发人员无法对SQL进行优化，无法灵活使用JDBC的原生SQL，Hibernate封装了JDBC，所以没有JDBC直接访问数据库效率高。要使用数据库的特定优化机制的时候，不适合用Hibernate\n\n### 开发目的\n对比Mybatis 和 Hibernate 优缺点，可以发现他们之间的优缺点可以互补，为何不`取其精华, 去其糟粕, 双剑合并呢`, 所以初步想法是在Mybatis的基础框架上, 扩展一下其面向对象操作的功能。\n\n### 使用方法\n\n#### 准备\n* 在自己的项目中导入 `com.songsy.iframe.core.persistence.provider` 包下的所有文件。\n* 默认数据库各张表都有如下字段, 如果不符合项目需要即可修改对应的源码\n```sql\n  `created_date` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n  `created_by` varchar(32) DEFAULT NULL COMMENT '创建人',\n  `last_modified_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后修改时间',\n  `last_modified_by` varchar(32) DEFAULT NULL COMMENT '最后修改人',\n  `version` bigint(20) DEFAULT NULL COMMENT '版本',\n  `remarks` varchar(255) DEFAULT NULL COMMENT '备注',\n  `enable` bit(1) DEFAULT b'1' COMMENT '是否启用',\n```\n* mybatis版本在3.0以上，需要使用其新特性\n#### 使用\n* 实体类继承`BaseEntity.class`类获得公共属性\n```java\n/**\n * 实体类基类\n * @author songshuiyang\n * @date 2018/10/28 10:13\n */\n@Getter\n@Setter\npublic class BaseEntity<ID> implements Serializable {\n\n    private static final long serialVersionUID = -3873745966284869947L;\n\n    /**\n     * 主键\n     */\n    @Id(type = Integer.class)\n    @GeneratedValue(strategy = GenerationType.CUSTOM)\n    private ID id;\n    /**\n     * 创建人\n     */\n    private String createdBy;\n    /**\n     * 创建时间\n     */\n    private Date createdDate;\n    /**\n     * 最后修改人\n     */\n    private String lastModifiedBy;\n    /**\n     * 最后修改时间\n     */\n    private Date lastModifiedDate;\n    /**\n     * 备注\n     */\n    private String remarks;\n    /**\n     * 乐观锁字段\n     */\n    @Version\n    private Long version;\n    /**\n     * 逻辑删除标识\n     */\n    @Deleted\n    private boolean enable = true;\n    @Override\n    public int hashCode() {\n        return this.id != null ? this.id.hashCode() : null;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (!(obj instanceof BaseEntity)) {\n            return false;\n        }\n        BaseEntity i = (BaseEntity) obj;\n\n        if (i.getId() == null || this.getId() == null) {\n            return false;\n        }\n        if (this.getId().equals(i.getId())) {\n            return true;\n        }\n        return false;\n    }\n}\n```\n* 实体类加上对应的注解\n```java\n/**\n * 用户\n * @author songshuiyang\n * @date 2017/11/28 21:36\n */\n@Data\n@Entity\n@Table(name = \"sys_user\")\n@EqualsAndHashCode(callSuper = false)\npublic class User extends BaseEntity<Integer> {\n\n    private String username;\n\n    private String password;\n\n    private String nickname;\n\n    private Integer sex;\n\n    private Integer age;\n\n    private String phone;\n\n    private String email;\n\n    private String address;\n\n    private String salt;\n\n    @Column(name = \"head_portrait\")\n    private String headPortrait;\n}\n```\n> 注解是参照Jpa的注解来定制的，详情可见`com.songsy.iframe.core.persistence.provider.annotation`\n\n| 注解 | 作用 |\n| ------ | ------ | \n| @Entity | 修饰实体类，指明该类将映射到指定的数据表| \n| @Table | 当实体类与映射的数据库表名不同名时需要使用 @Table 注解，该注解与 @Entity 注解并列使用，使用其 name 属性指明数据库的表名, 不填写`name`属性则默认是类名的转化成`_`格式的表名 |\n| @Column | 当实体类属性名与数据库字段名不一致时, 可用该注解标识实体类对应在数据库的字段名| \n| @Id | 标识该属性为主键| \n| @GeneratedValue | 标注主键的生成策略，通过其 strategy 属性标识生成策略| \n| @Transient | 标注此注解后在操作数据表的时候将会忽略该属性 | \n| @Version | 标识乐观锁字段| \n| @Deleted | 逻辑删除标识| \n\n* mapper接口继承`BaseCurdMapper.java` ，Mapper层增加其通用增删改查方法, `<User,Integer>`：第一个是实体类类型，第二个标识主键类型\n```java\n/**\n * 用户\n * @author songshuiyang\n * @date 2017/11/28 20:12\n */\npublic interface UserMapper extends BaseCurdMapper<User,Integer> {\n\n}\n```\n增加的方法：\n```java\n    /**\n     * 查询所有数据\n     * @return\n     */\n    List<T> findAll();\n\n    /**\n     * 根据id查询记录\n     * @return\n     */\n    T findById(Object id);\n\n    /**\n     * 插入记录\n     * @param entity\n     * @return\n     */\n    int insert(T entity);\n\n    /**\n     * 更新记录\n     * @param entity\n     * @return\n     */\n    int update(T entity);\n\n    /**\n     * 更新记录(null值记录也更新)\n     * @param entity\n     * @return\n     */\n    int updateNull(T entity);\n\n    /**\n     * 根据id物理删除记录\n     * @param id\n     * @return\n     */\n    int deleteOne (Object id);\n\n    /**\n     * 根据id逻辑删除记录\n     * @param id\n     * @return\n     */\n    int logicDeleteOne (Object id);\n```\n\n* service接口继承`BaseService.java` ，Service层增加其通用增删改查方法\n```java\n/**\n * @author songshuiyang\n * @date 2018/10/28 10:13\n */\npublic interface UserService extends BaseService<User, Integer> {\n\n}\n```\n增加的方法：\n```java\n/**\n * @author songsy\n * @Date 2018/10/31 18:06\n */\npublic interface BaseService <T extends BaseEntity, ID extends Serializable>{\n\n    List<T> findAll();\n\n    T findById(ID id);\n\n    T saveSelective(T entity);\n\n    T saveSelective(T entity, Boolean hasId);\n\n    int updateNull(T entity);\n\n    int deleteOne (ID id);\n\n    int logicDeleteOne (ID id);\n}\n```\n\n* service实现类继承`AbstractBaseService.java` ，重写`getRepository()`方法\n```java\n/**\n * @author songshuiyang\n * @date 2018/10/28 10:13\n */\n@Service\npublic class UserServiceImpl extends AbstractBaseService<User, Integer> implements UserService  {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public BaseCurdMapper<User, Integer> getRepository() {\n        return userMapper;\n    }\n\n}\n```\nAbstractBaseService.java\n```java\n/**\n * 抽象service基类\n *\n * @author songsy\n * @Date 2018/131 17:17\n */\n@Slf4j\npublic abstract class AbstractBaseService<T extends BaseEntity, ID extends Serializable> {\n    \n    public abstract BaseCurdMapper<T, ID> getRepository();\n\n    public List<T> findAll() {\n        return getRepository().findAll();\n    }\n\n    public T findById(ID id) {\n        return getRepository().findById(id);\n    }\n\n    public int updateNull(T entity) {\n        return getRepository().updateNull(entity);\n    }\n\n    public int deleteOne(ID id) {\n        return getRepository().deleteOne(id);\n    }\n\n    public int logicDeleteOne(ID id) {\n        return getRepository().logicDeleteOne(id);\n    }\n\n    /**\n     * 通用插入更新方法\n     *\n     * @param entity\n     * @return\n     */\n    @Transactional\n    public T saveSelective(T entity) {\n        return saveSelective(entity, false);\n    }\n\n    @Transactional\n    public T saveSelective(T entity, Boolean hasId) {\n        if (hasId) {\n            // 之前已经生成了id\n            insertSelective(entity);\n        } else if (!StringUtils.isEmpty(entity.getId())) {\n            updateSelective(entity);\n            // 插入数据库之后 实体类乐观锁字段自增\n            entity.setVersion(entity.getVersion() + 1);\n        } else {\n            Class idClass = ReflectionUtils.getPrimarykeyClassType(entity.getClass());\n            // 如果主键是字符类型，则采用32位随机字符作为主键\n            if (idClass.equals(String.class)) {\n                entity.setId(IDGeneratorUtils.generateID());\n            } else {\n                // 默认主键由数据库自动生成（主要是自动增长型）\n            }\n            insertSelective(entity);\n        }\n        return entity;\n    }\n\n    private void insertSelective(T entity) {\n        entity.setCreatedDate(new Date());\n        entity.setLastModifiedDate(new Date());\n        entity.setVersion(new Long(1));\n        // 设置当前登录人\n//        if (null == entity.getCreatedBy()) {\n//            entity.setCreatedBy(\"\");\n//        }\n//        if (null == entity.getLastModifiedBy()) {\n//            entity.setLastModifiedBy(\"\");\n//        }\n        getRepository().insert(entity);\n    }\n\n    private void updateSelective(T entity) {\n        if (entity.getVersion() == null) {\n            throw new VersionException();\n        }\n        entity.setLastModifiedDate(new Date());\n        // 设置当前登录人\n//        if (null == entity.getLastModifiedBy()) {\n//            entity.setLastModifiedBy(\"\");\n//        }\n        Integer flag = getRepository().update(entity);\n        if (flag == 0) {\n            throw new UpdateException();\n        }\n    }\n}\n```\n#### 测试\n```java\n/**\n * @author songsy\n * @Date 2018/10/31 18:00\n */\npublic class UserServiceTest extends BaseTest {\n\n    @Autowired\n    UserService userService;\n    \n    @Test\n    public void findAll () {\n        userService.findAll();\n    }\n\n    @Test\n    public void insertUser () {\n        User user = new User();\n        user.setUsername(\"songsy\");\n        user.setAddress(\"广东深圳\");\n        user.setAge(88);\n        user.setEmail(\"1459074711@qq.com\");\n        user.setHeadPortrait(\"头像\");\n        user.setNickname(\"宋某\");\n        user.setPassword(\"root\");\n        user.setSex(1);\n        userService.saveSelective(user);\n    }\n\n    @Test\n    public void updateUser1 () {\n        User user = new User();\n        user.setId(48);\n        user.setUsername(\"songsy\");\n        user.setAddress(\"广东深圳\");\n        user.setAge(88);\n        user.setEmail(\"1459074711@qq.com\");\n        user.setHeadPortrait(\"头像\");\n        user.setNickname(\"宋某某\");\n        user.setPassword(\"root\");\n        user.setSex(1);\n        user.setVersion(1l);\n        userService.saveSelective(user);\n    }\n\n    @Test\n    public void updateUser2 () {\n        User user = userService.findAll().get(0);\n        User userDb = new User();\n        userDb.setId(user.getId());\n        userDb.setVersion(user.getVersion());\n        userDb.setUsername(\"测试乐观锁111\");\n        userService.saveSelective(userDb);\n    }\n    \n    @Test\n    public void updateNull () {\n        User user = userService.findById(50);\n        User userDb = new User();\n        userDb.setId(user.getId());\n        userDb.setVersion(user.getVersion());\n        userDb.setUsername(\"测试updateNull\");\n        userService.updateNull(userDb);\n    }\n\n    @Test\n    public void deleteOne () {\n        userService.deleteOne(48);\n    }\n\n    @Test\n    public void logicDeleteOne () {\n        userService.logicDeleteOne(49);\n    }\n}\n```\n\n#### 使用总结\n* 如果增加或者修改了数据库字段，只要修改对应的实体类文件即可，配合注解的使用可以十分方便完成修改，对于增删改查的操作代码再也不用一个个去修改xml文件了\n* 不用在每一个`mapper`接口, Mybatis xml文件添加一些重复的代码\n* 在service层即可完成通用增删改查方法，使用Mybatis也可以像`Hibernate` 那样用对象来更新数据库了\n\n### 实现解析\n> 详细实现可见`com.songsy.iframe.core.persistence.provider`\n\n按步骤解析：\n\n* 使用`Spring Aop`收集实体类信息及缓存起来，每次调用继承了`BaseCurdMapper.java`的Mapper接口就会触发\n```java\npackage com.songsy.iframe.core.persistence.provider.aspect;\n\nimport com.google.common.collect.Maps;\nimport com.songsy.iframe.core.persistence.provider.exception.ParameterizedTypeException;\nimport com.songsy.iframe.core.persistence.provider.mapper.BaseCurdMapper;\nimport com.songsy.iframe.core.persistence.provider.threadlocal.EntityProperty;\nimport com.songsy.iframe.core.persistence.provider.threadlocal.EntityThreadLocal;\nimport com.songsy.iframe.core.persistence.provider.utils.ReflectionUtils;\nimport org.apache.ibatis.binding.MapperProxy;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Type;\nimport java.util.Map;\n\n/**\n * BaseCurdMapper接口AOP，用于获取实体类属性\n *\n * @author songshuiyang\n * @date 2018/10/30 21:44\n */\n@Aspect\n@Component\npublic class BaseCurdMapperAspect {\n\n    private final static Logger logger = LoggerFactory.getLogger(BaseCurdMapperAspect.class);\n\n    /**\n     * 缓存实体类属性\n     * key: 实体类类型\n     * value: 实体类属性对象\n     */\n    private static Map<String, EntityProperty> entityPropertyMap = Maps.newHashMap();\n\n    /**\n     * 定义切点\n     * Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象，\n     * 当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。\n     */\n    @Pointcut(\"this(com.songsy.iframe.core.persistence.provider.mapper.BaseCurdMapper)\")\n    public void pointcut() {\n    }\n\n    /**\n     * 前置增强：获取BaseCurdMapper接口 泛型属性，并设置到ThreadLocal中\n     * @param point\n     */\n    @Before(\"pointcut()\")\n    public void before(JoinPoint point) {\n        Class entityClass = null;\n        Class entityIdClass = null;\n        Object target= point.getTarget();\n        // 是否继承 BaseCurdMapper 接口\n        if (BaseCurdMapper.class.isAssignableFrom(target.getClass())) {\n            // 获取Mybatis代理类对象\n            MapperProxy mapperProxy = (MapperProxy) Proxy.getInvocationHandler(target);\n            Class mapperInterface = (Class) ReflectionUtils.getFieldValue(mapperProxy, \"mapperInterface\");\n            // 获取接口泛型对象\n            ParameterizedType parameterizedType = (ParameterizedType) mapperInterface.getGenericInterfaces()[0];\n            Type[] types = parameterizedType.getActualTypeArguments();\n            if (types.length != 2) {\n                logger.error(\"parameterizedType type length error\");\n                throw new ParameterizedTypeException(parameterizedType.getTypeName());\n            }\n            try {\n                entityClass = Class.forName(types[0].getTypeName());\n                entityIdClass = Class.forName(types[1].getTypeName());\n                // 如果不存在则加入到entityPropertyMap缓存中\n                if (!entityPropertyMap.containsKey(entityClass.getName())) {\n                    EntityProperty entityProperty = new EntityProperty(entityClass, entityIdClass);\n                    entityPropertyMap.put(entityClass.getTypeName(),entityProperty);\n                }\n            } catch (ClassNotFoundException e) {\n                logger.error(e.getMessage());\n            }\n        }\n        // 设置ThreadLocal\n        if (null != entityClass) {\n            EntityThreadLocal.set(entityPropertyMap.get(entityClass.getName()));\n        }\n    }\n\n    /**\n     * 后置增强：清除 threadLocal 防止内存泄漏\n     * @param point\n     */\n    @After(\"pointcut()\")\n    public void after(JoinPoint point) {\n        EntityThreadLocal.remove();\n    }\n\n}\n```\n* 使用`ThreadLocal` 获取当前访问线程实体类信息\n```java\n/**\n * ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。\n * 每次调用mapper接口方法的时候，先把实体类的信息存放在ThreadLocal中\n * @author songshuiyang\n * @date 2018/10/30 21:27\n */\npublic class EntityThreadLocal {\n\n    private static ThreadLocal<EntityProperty> threadLocal = new ThreadLocal<>();\n\n    /**\n     * 获取当前线程的实体类属性\n     * @return\n     */\n    public static EntityProperty get () {\n        if (null == threadLocal) {\n            initialValue();\n        }\n        return threadLocal.get();\n    }\n\n    /**\n     * 设置当前线程的实体类属性\n     * @param entityProperty\n     */\n    public static void set(EntityProperty entityProperty) {\n        if (entityProperty != null) {\n            threadLocal.set(entityProperty);\n        }\n    }\n\n    /**\n     * 清除 threadLocal\n     */\n    public static void remove() {\n        threadLocal.remove();\n    }\n\n    /**\n     * 默认初始化Object.class\n     */\n    private static void initialValue() {\n        EntityProperty entityProperty = new EntityProperty();\n        entityProperty.setEntityClass(Object.class);\n        entityProperty.setIdClass(null);\n        threadLocal.set(entityProperty);\n    }\n}\n```\n\n* 使用Mybatis3的`@SelectProvider`、` @InsertProvider`, `@UpdateProvider`,`@DeleteProvider`，使用注解来配置Mapper\n```java\n/**\n * 通用增删改查Mapper\n * @author songshuiyang\n * @date 2018/10/28 11:22\n */\npublic interface CurdMapper<T extends BaseEntity, ID extends Serializable> {\n    /**\n     * 查询所有数据\n     * @return\n     */\n    @SelectProvider(type=MybatisProvider.class,method = MybatisProvider.FIND_ALL)\n    List<T> findAll();\n\n    /**\n     * 根据id查询记录\n     * @return\n     */\n    @SelectProvider(type=MybatisProvider.class, method = MybatisProvider.FIND_BY_ID)\n    T findById(Object id);\n\n    /**\n     * 插入记录\n     * @param entity\n     * @return\n     */\n    @InsertProvider(type=MybatisProvider.class, method = MybatisProvider.INSERT)\n    int insert(T entity);\n\n    /**\n     * 更新记录\n     * @param entity\n     * @return\n     */\n    @UpdateProvider(type=MybatisProvider.class, method = MybatisProvider.UPDATE)\n    int update(T entity);\n\n    /**\n     * 更新记录(null值记录也更新)\n     * @param entity\n     * @return\n     */\n    @UpdateProvider(type=MybatisProvider.class, method = MybatisProvider.UPDATE_NULL)\n    int updateNull(T entity);\n\n    /**\n     * 根据id物理删除记录\n     * @param id\n     * @return\n     */\n    @DeleteProvider(type=MybatisProvider.class, method = MybatisProvider.DELETE_ONE)\n    int deleteOne (Object id);\n\n    /**\n     * 根据id逻辑删除记录\n     * @param id\n     * @return\n     */\n    @DeleteProvider(type=MybatisProvider.class, method = MybatisProvider.LOGIC_DELETE_ONE)\n    int logicDeleteOne (Object id);\n\n\n    /**\n     * 分页查询\n     * @param page\n     * @return\n     */\n    @SelectProvider(type=MybatisProvider.class,method = MybatisProvider.FIND_AUTO_BY_PAGE)\n    List<T> findAutoByPage(Page<T> page);\n}\n```\n* 通用增删改查实现类，在这里实现sql的拼接\n\n```java\npackage com.songsy.iframe.core.persistence.provider;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.songsy.iframe.core.persistence.provider.annotation.Version;\nimport com.songsy.iframe.core.persistence.provider.entity.ColumnEntity;\nimport com.songsy.iframe.core.persistence.provider.entity.TableEntity;\nimport com.songsy.iframe.core.persistence.provider.utils.MybatisTableUtils;\nimport com.songsy.iframe.core.persistence.provider.utils.PageUtils;\nimport com.songsy.iframe.core.persistence.provider.utils.ReflectionUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.reflect.Field;\nimport java.text.ParseException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * 通用增删改查实现方法\n * @author songshuiyang\n * @date 2018/10/28 11:34\n */\npublic class CrudProvider {\n\n    private static Logger logger = LoggerFactory.getLogger(CrudProvider.class);\n\n    public static final String FIND_ALL = \"findAll\";\n    public static final String FIND_BY_ID = \"findById\";\n    public static final String INSERT = \"insert\";\n    public static final String UPDATE = \"update\";\n    public static final String UPDATE_NULL = \"updateNull\";\n    public static final String DELETE_ONE = \"deleteOne\";\n    public static final String LOGIC_DELETE_ONE =\"logicDeleteOne\";\n    public static final String FIND_AUTO_BY_PAGE = \"findAutoByPage\";\n\n    /**\n     * 查询所有数据\n     * @return\n     */\n    public String findAll() {\n        TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity();\n        String sql = \"SELECT * FROM \" +  tableEntity.getTableName();\n        return sql;\n    }\n\n    /**\n     * 根据id查询记录\n     * @param id\n     * @return\n     */\n    public String findById (Object id) {\n        TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity();\n        StringBuilder sb = new StringBuilder(\"SELECT \");\n        sb.append(\" * \");\n        sb.append(\"FROM\");\n        sb.append(\" \").append(tableEntity.getTableName()).append(\" \");\n        sb.append(\" WHERE \").append(tableEntity.getIdColumnEntity().getColumnName()).append(\"=\").append(id);\n        return sb.toString();\n    }\n\n    /**\n     * 插入记录\n     * @param entity\n     */\n    public String insert (Object entity) {\n        TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity();\n        List<ColumnEntity> columnEntities = tableEntity.getColumnEntities();\n        List<String> fieldNames = Lists.newArrayList();\n        List<String> columnNames = Lists.newArrayList();\n        for (ColumnEntity columnEntity : columnEntities) {\n            Object value = ReflectionUtils.getFieldValue(entity, columnEntity.getFieldName());\n            // 字段为null不插入\n            if (value != null) {\n                columnNames.add(columnEntity.getColumnName());\n                fieldNames.add(\"#{\" + columnEntity.getFieldName() + \"}\");\n            }\n        }\n        StringBuilder sb = new StringBuilder(\"INSERT INTO \");\n        sb.append(tableEntity.getTableName());\n        sb.append(\" (\");\n        sb.append(StringUtils.join(columnNames, \",\"));\n        sb.append(\") \");\n        sb.append(\" VALUES(\");\n        sb.append(StringUtils.join(fieldNames, \",\"));\n        sb.append(\")\");\n        String sql = sb.toString();\n        return sql;\n    }\n\n    /**\n     * 更新记录\n     * 字段属性为null不更新\n     * @param entity\n     */\n    public String  update (Object entity) {\n        TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity();\n        List<ColumnEntity> columnEntities = tableEntity.getColumnEntities();\n        ColumnEntity versionColumnEntity = null;\n        List<String> updateColumns = Lists.newArrayList();\n        for (ColumnEntity columnEntity : columnEntities) {\n            // 乐观锁处理 更新后version字段加一\n            Field field = columnEntity.getField();\n            Version version = field.getAnnotation(Version.class); {\n                if (version != null) {\n                    versionColumnEntity = columnEntity;\n                    updateColumns.add(columnEntity.getColumnName() + \" = \" + columnEntity.getFieldName() + \" + 1\");\n                    continue;\n                }\n            }\n            Object value = ReflectionUtils.getFieldValue(entity, columnEntity.getFieldName());\n            if (value != null) {\n                updateColumns.add(columnEntity.getColumnName() + \" = \" + \"#{\" + columnEntity.getFieldName() + \"}\");\n            }\n        }\n        StringBuilder sb = new StringBuilder(\"UPDATE \");\n        sb.append(tableEntity.getTableName());\n        sb.append(\" SET \");\n        sb.append(StringUtils.join(updateColumns, \",\"));\n        sb.append(\" WHERE \");\n        sb.append(tableEntity.getIdColumnEntity().getColumnName());\n        sb.append(\" = \");\n        sb.append(\"#{\" + tableEntity.getIdColumnEntity().getFieldName() + \"}\");\n        sb.append(\" and \");\n        sb.append(versionColumnEntity.getColumnName());\n        sb.append(\" = \");\n        sb.append(\"#{\" + versionColumnEntity.getFieldName() + \"}\");\n        String sql = sb.toString();\n        return sql;\n    }\n\n    /**\n     * 更新记录\n     * 字段属性为null 也会更新为null\n     * @param entity\n     */\n    public String  updateNull (Object entity) {\n        TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity();\n        List<ColumnEntity> columnEntities = tableEntity.getColumnEntities();\n        ColumnEntity versionColumnEntity = null;\n        List<String> updateColumns = Lists.newArrayList();\n        for (ColumnEntity columnEntity : columnEntities) {\n            // 乐观锁处理 更新后version字段加一\n            Field field = columnEntity.getField();\n            Version version = field.getAnnotation(Version.class); {\n                if (version != null) {\n                    versionColumnEntity = columnEntity;\n                    updateColumns.add(columnEntity.getColumnName() + \" = \" + columnEntity.getFieldName() + \" + 1\");\n                    continue;\n                }\n            }\n            updateColumns.add(columnEntity.getColumnName() + \" = \" + \"#{\" + columnEntity.getFieldName() + \"}\");\n        }\n        StringBuilder sb = new StringBuilder(\"UPDATE \");\n        sb.append(tableEntity.getTableName());\n        sb.append(\" SET \");\n        sb.append(StringUtils.join(updateColumns, \",\"));\n        sb.append(\" WHERE \");\n        sb.append(tableEntity.getIdColumnEntity().getColumnName());\n        sb.append(\" = \");\n        sb.append(\"#{\" + tableEntity.getIdColumnEntity().getFieldName() + \"}\");\n        sb.append(\" and \");\n        sb.append(versionColumnEntity.getColumnName());\n        sb.append(\" = \");\n        sb.append(\"#{\" + versionColumnEntity.getFieldName() + \"}\");\n        String sql = sb.toString();\n        return sql;\n    }\n\n    /**\n     * 根据id物理删除记录\n     * @param id\n     * @return\n     */\n    public String deleteOne(Object id) {\n        TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity();\n        String sql = \"DELETE FROM \" + tableEntity.getTableName() + \" WHERE \" + tableEntity.getIdColumnEntity().getColumnName()\n                + \" = #{id}\";\n        return sql;\n    }\n\n    /**\n     * 根据id逻辑删除记录\n     * @param id\n     * @return\n     */\n    public String logicDeleteOne(Object id) {\n        TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity();\n        String sql = \"UPDATE \" +\n                tableEntity.getTableName() +\n                \" SET \" + tableEntity.getDeleteColunmEntity().getColumnName() + \" = 0 \" +\n                \"WHERE \" + tableEntity.getIdColumnEntity().getColumnName() + \" = #{id}\";\n        return sql;\n    }\n}\n```\n\n","tags":["Spring"],"categories":["服务器"]},{"title":"Markdown语法","url":"/2018/11/01/backend/Markdown语法/","content":"### 图片\n```xml\n![logo](/images/server/mybatis/mybatis-framework.png) \n```\n![logo](/images/server/mybatis/mybatis-framework.png) \n\n### 表格:\n```xml\n|    a    |       b       |      c     |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐    |   右对齐   |\n```\n\n|    a    |       b       |      c     |\n|:-------:|:------------- | ----------:|\n|   居中  |     左对齐    |   右对齐   |\n\n> 全部左对齐\n\n```xml\n|    a    |       b       |      c     |\n|:-------|:------------- | :----------|\n|   左对齐  |     左对齐    |   左对齐   |\n```\n\n\n|    a    |       b       |      c     |\n|:-------|:------------- | :----------|\n|   左对齐  |     左对齐    |   左对齐   |\n","tags":["java"],"categories":["server"]},{"title":"工具类-guava工具包","url":"/2018/10/31/backend/java/utils/工具类-guava工具包/","content":"### 驼峰字符和下划线字符相互转换工具类\n\n导入Maven\n```xml\n<dependency>\n    <groupId>com.google.guava</groupId>\n    <artifactId>guava</artifactId>\n    <version>21.0</version>\n</dependency>\n```\n示例：\n```xml\nimport org.junit.Test;\n\nimport com.google.common.base.CaseFormat;\n\npublic class GuavaTester {\n    @Test\n    public void test() {\n        System.out.println(CaseFormat.LOWER_HYPHEN.to(CaseFormat.LOWER_CAMEL, \"test-data\"));//testData\n        System.out.println(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, \"test_data\"));//testData\n        System.out.println(CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, \"test_data\"));//TestData\n\n        System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, \"testdata\"));//testdata\n        System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, \"TestData\"));//test_data\n        System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, \"testData\"));//test-data\n    }\n}\n```\n\n","tags":["Java"],"categories":["server"]},{"title":"spring-data-jpa","url":"/2018/09/10/backend/framework/spring/spring-data/spring-data-jpa/","content":"\n![logo](/images/server/spring/spring-jpa/jpa1.png) \n\n![logo](/images/server/spring/spring-jpa/jpa2.png) \n\n![logo](/images/server/spring/spring-jpa/jpa3.png) ","tags":["jpa"],"categories":["服务器"]},{"title":"工具类-BigDecimal","url":"/2018/09/05/backend/java/utils/工具类-BigDecimal/","content":"### 构造函数\n\n* 参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。\n\n* 另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(\"0.1\") 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。\n\n* 当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。\n\n\n### 运算\n* 减乘除其实最终都返回的是一个新的BigDecimal对象，因为BigInteger与BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以a.add(b);虽然做了加法操作，但是a并没有保存加操作后的值，正确的用法应该是a=a.add(b);\n\n\n### 精度\n```java\nBigDecimal.setScale() 方法用于格式化小数点\n\nsetScale(1) 表示保留一位小数，默认用四舍五入方式\n\nsetScale(1,BigDecimal.ROUND_DOWN) 直接删除多余的小数位，2.31变成2.3、2.35会变成2.3\n\nsetScale(1,BigDecimal.ROUND_UP) 进位处理，2.31变成2.4 2.35变成2.4 \n\nsetScale(1,BigDecimal.ROUND_CEILING) 如果为正数，则舍入行为与 ROUND_UP 相同，反之舍入行为与 ROUND_DOWN 相同\n\nsetScale(1,BigDecimal.ROUND_FLOOR) 如果为正数，则舍入行为与 ROUND_DOWN 相同，反之舍入行为与 ROUND_UP 相同\n\nsetScale(1,BigDecimal.ROUND_HALF_UP) 四舍五入，2.35变成2.4\n\nsetScale(1,BigDecimal.ROUND_HALF_DOWN) 四舍五入，2.35变成2.3(如果是5则向下舍)，2.36变成2.4\n\nsetScale(1,BigDecimal.ROUND_HALF_EVEN) 银行家舍入法 如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同 如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。如 1.15>1.2 1.25>1.2\n```\n\n\n### 异常处理\n####  `foo.divide(bar));` 报异常\n\n```java\njava.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result。\n```\n\n原因：\n\n```java\n原来JAVA中如果用BigDecimal做除法的时候一定要在divide方法中传递第二个参数，定义精确到小数点后几位，否则在不整除的情况下，结果是无限循环小数时，就会抛出以上异常。\n解决方法：\n\nfoo.divide(bar, 2, BigDecimal.ROUND_HALF_UP);\n注意这个divide方法有两个重载的方法，一个是传两个参数的，一个是传三个参数的：\n\n两个参数的方法：\n\n@param divisor value by which this {@code BigDecimal} is to be divided. 传入除数\n\n@param roundingMode rounding mode to apply. 传入round的模式\n\n三个参数的方法：\n\n@param divisor value by which this {@code BigDecimal} is to be divided. 传入除数\n@param scale scale of the {@code BigDecimal} quotient to be returned. 传入精度\n@param roundingMode rounding mode to apply. 传入round的模式\n```","tags":["Java"],"categories":["server"]},{"title":"在SELECT 的读取锁定主要分为两种方式","url":"/2018/08/01/backend/database/在SELECT 的读取锁定主要分为两种方式/","content":"在SELECT 的读取锁定主要分为两种方式：\n* SELECT ... LOCK IN SHARE MODE\n* SELECT ... FOR UPDATE\n\n这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。\n\n而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。\n\n简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT ... UPDATE。\n\n### 悲观锁介绍\n> 　悲观锁是对数据被的修改持悲观态度（认为数据在被修改的时候一定会存在并发问题），因此在整个数据处理过程中将数据锁定。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在应用层中实现了加锁机制，也无法保证外部系统不会修改数据）。\n  \n#### 使用场景举例\n商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。如果不采用锁，那么操作方法如下：\n```java\n//1.查询出商品信息\nselect status from t_goods where id=1;\n//2.根据商品信息生成订单\ninsert into t_orders (id,goods_id) values (null,1);\n//3.修改商品status为2\nupdate t_goods set status=2;\n```\n\n上面这种场景在高并发访问的情况下很可能会出现问题。前面已经提到，只有当goods status为1时才能对该商品下单，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步Update操作的时候，有可能出现其他人先一步对商品下单把goods status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。\n\n#### 使用悲观锁来实现\n在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出goods信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。要使用悲观锁，我们必须关闭mysql数据库的自动提交属性。\n\n```java\nset autocommit=0;　　\n//设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：\n//0.开始事务\nbegin;/begin work;/start transaction; (三者选一就可以)\n//1.查询出商品信息\nselect status from t_goods where id=1 for update;\n//2.根据商品信息生成订单\ninsert into t_orders (id,goods_id) values (null,1);\n//3.修改商品status为2\nupdate t_goods set status=2;\n//4.提交事务\ncommit;/commit work;\n```\n注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。\n\n上面的第一步我们执行了一次查询操作：select status from t_goods where id=1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。\n\n注：需要注意的是，在事务中，只有SELECT ... FOR UPDATE 或LOCK IN SHARE MODE 相同数据时会等待其它事务结束后才执行，一般SELECT ... 则不受此影响。拿上面的实例来说，当我执行select status from t_goods where id=1 for update;后。我在另外的事务中如果再次执行select status from t_goods where id=1 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from t_goods where id=1;则能正常查询出数据，不会受第一个事务的影响。\n\n  　　","tags":["db"],"categories":["server"]},{"title":"Java基础-hashcode和equals的区别","url":"/2018/08/01/backend/java/basicKnowledge/Java基础-hashcode和equals的区别/","content":"## 前言：\n\n* 首先，我们要介绍hashCode()和equals()方法的作用是是什么，然后才说他的区别，说了区别之后再说使用的时候需要注意到的地方，这样的回答思路基本是OK的，如果你在了解一些其他人不知道的那就更好了！下边我们就开始介绍：\n\n## 分析：\n\n* 一、hashCode()和equals()是什么？\n    * hashCode()方法和equals()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致。\n* 二、hashCode()和equals()的区别\n    * 下边从两个角度介绍了他们的区别：一个是性能，一个是可靠性。他们之间的主要区别也基本体现在这里。\n        * 1、equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？\n            * 因为重写的equals（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。\n        * 2、hashCode()既然效率这么高为什么还要equals()呢？\n            * 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出（PS：以下两条结论是重点，很多人面试的时候都说不出来）：\n                * equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。\n                * hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。\n* 三、hashCode()和equals()使用的注意事项\n    * 1、对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！\n    * 2、这种大量的并且快速的对象对比一般使用的hash容器中，比如HashSet,HashMap,HashTable等等，比如HashSet里要求对象不能重复，则他内部必然要对添加进去的每个对象进行对比，而他的对比规则就是像上面说的那样，先hashCode()，如果hashCode()相同，再用equals()验证，如果hashCode()都不同，则肯定不同，这样对比的效率就很高了。\n    * 3、然而hashCode()和equals()一样都是基本类Object里的方法，而和equals()一样，Object里hashCode()里面只是返回当前对象的地址，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值，比如下面：\n## 其他\n* 1、阿里巴巴开发规范明确规定\n    * 只要重写 equals，就必须重写 hashCode；\n    * 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法；\n    * 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals； \n    * String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用；\n* 2、什么时候需要重写？\n    * 一般的地方不需要重载hashCode，只有当类需要放在HashTable、HashMap、HashSet等等hash结构的集合时才会重载hashCode。\n* 3、为什么equals()相等，hashCode就一定要相等，而hashCode相等，却不要求equals相等?\n    * 因为是按照hashCode来访问小内存块，所以hashCode必须相等。\n    * HashMap获取一个对象是比较key的hashCode相等和equals为true。\n    * 之所以hashCode相等，却可以equal不等，就比如ObjectA和ObjectB他们都有属性name，那么hashCode都以name计算，所以hashCode一样，但是两个对象属于不同类型，所以equals为false。\n* 4、为什么需要hashCode?\n    * 通过hashCode可以很快的查到小内存块。\n    * 通过hashCode比较比equals方法快，当get时先比较hashCode，如果hashCode不同，直接返回false。\n## 总结：\n\n## 参考：\n\n* https://www.liangzl.com/get-article-detail-97291.html\n","tags":["Java"],"categories":["server"]},{"title":"Java基础-null != a 与 a != null 区别","url":"/2018/08/01/backend/java/basicKnowledge/Java基础-null判断/","content":"> 在其他人的项目中经常会看到 `null ! = a` 这种写法, 但平常使用的是都是 `a != null` 这种写法\n \n#### 原因：\n功能上是没有区别的，企业里大多是时候是推荐第一种的，是因为能够防止程序员书写遗漏等号导致错误。比如：null != a 这样少了“！”也会报错。而a ！=null少了\"！\"就不会报错了。程序员有时候容易把 == 误写为 = ，如果把常量放前面 5 = i ，会编译错误，而写成i=5就不会报错了，所以这样写能发现这种笔误bug。\n\n#### 总结\n1. 所以在实际项目中，细节很重要，一个小小的问题有可能导致一系列的问题。\n2. 多阅读其他人的代码，借鉴其他人的思想及技巧。\n\n","tags":["Java"],"categories":["server"]},{"title":"高可用","url":"/2018/08/01/backend/server/JavaEE服务器/高可用/","content":"## 一、什么是高可用\n> 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。\n\n假设系统一直能够提供服务，我们说系统的可用性是100%。\n\n如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。\n\n很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。\n\n百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过www.baidu.com 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度最高的褒奖。\n\n## 如何保障系统的高可用\n\n我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。\n\n保证系统高可用，架构设计的核心准则是：冗余。\n\n有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。\n\n接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。\n\n## 分层高可用架构实践\n\n下面的图是常见的互联网分层架构\n![logo](/images/server/java/三高/20180607142425564.jpg)\n\n> 【客户端层】到【反向代理层】的高可用，\n\n是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。\n\n自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。\n\n> 【反向代理层->站点层】的高可用\n\n【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。\n\n自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。\n\n> 【站点层->服务层】的高可用\n\n【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。\n\n自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。 \n\n\n> 【服务层>数据库层】的高可用\n\n大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。\n\n\n参考： https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959728&idx=1&sn=933227840ec8cdc35d3a33ae3fe97ec5&chksm=bd2d046c8a5a8d7a13551124af36bedf68f7a6e31f6f32828678d2adb108b86b7e08c678f22f&scene=21#wechat_redirect\n\n","tags":["Java"],"categories":["server"]},{"title":"Java基础-Integer 类型与 int 的==比较","url":"/2018/07/25/backend/java/basicKnowledge/Java基础-Integer 类型与 int 的==比较/","content":"### 先上题\n```java\npackage com.lizi.basic;\n\npublic class IntegerDemo {\n\n    public static void main(String[] args) {\n        Integer a = new Integer(3);\n        Integer b = 3;\n        int c = 3;\n\n        System.out.println(a == b);\n        System.out.println(a == c);\n\n        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;\n        System.out.println(f1 == f2);\n        System.out.println(f3 == f4);\n    }\n\n}\n```\n#### 分析思路\n\n* 基本类型\n\n  基本数据类类型存的是数值本身\n* 引用类型 \n\n  引用类型变量在内存放的是数据的引用\n  \n基本类型通过 == 比较的是他们的值大小，而引用类型比较的是他们的引用地址\n\nInteger 用 == 比较的时候往往非常容易出错\n```java\n        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;\n        System.out.println(f1 == f2);\n        System.out.println(f3 == f4);\n        \n        // 当我们给一个Integer赋予一个int类型的时候会调用Integer的静态方法valueOf。\n        Integer f1 = Integer.valueOf(100); \n        Integer f2 = Integer.valueOf(100); \n        Integer f3 = Integer.valueOf(150); \n        Integer f4 = Integer.valueOf(150);\n```\n\n思考：那么Integer.valueOf()返回的Integer是不是是重新new Integer(num);来创建的呢？如果是这样的话，那么== 比较返回都是false，因为他们引用的堆地址不一样\n\n具体来看看Integer.valueOf的源码\n\n```java\n    public static Integer valueOf(int i) {\n        if (i >= IntegerCache.low && i <= IntegerCache.high)\n            return IntegerCache.cache[i + (-IntegerCache.low)];\n        return new Integer(i);\n    }\n```\n在IntegerCache中cache数组初始化如下，存入了-128 - 127的值\n```java\n        cache = new Integer[(high - low) + 1];\n        int j = low;\n        for(int k = 0; k < cache.length; k++)\n            cache[k] = new Integer(j++);\n```\n从上面我们可以知道给Interger 赋予的int数值在-128 - 127的时候，直接从cache中获取，这些cache引用对Integer对象地址是不变的，但是不在这个范围内的数字，则new Integer(i) 这个地址是新的地址，不可能一样的\n\n#### Integer 与 int\n```java\nInteger a = new Integer(3);\nInteger b = 3;\nint c = 3;\n\nSystem.out.println(a == b);\nSystem.out.println(a == c);\n\na == b分析\nInteger b = 3; 自动调用Integer.valueOf(3) 返回一个Integer的对象。 这个对象存放到cache中的\n\n而 Integer a = new Integer(3);这里创建了一个新的对象Integer 所以 a == b 返回的是false\n\na == c 分析\n一个Integer 与 int比较，先将Integer转换成int类型，再做值比较，所以返回的是true\n```\n\n#### 最后答案\n```java\n  public static void main(String[] args) {\n        Integer a = new Integer(3);\n        Integer b = 3;\n        int c = 3;\n\n        System.out.println(a == b);\n        System.out.println(a == c);\n\n        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;\n        System.out.println(f1 == f2);\n        System.out.println(f3 == f4);\n    }\n    \n    false\n    true\n    true\n    false\n```\n","tags":["Java"],"categories":["server"]},{"title":"设计模式(二一)行为型模式-备忘录模式","url":"/2018/07/22/backend/designPatterns/设计模式(二一)行为型模式-备忘录模式/","content":"备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。\n\n### 意图\n在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。\n\n### 主要解决\n所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。\n\n### 什么时候使用\n很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有\"后悔药\"可吃。\n\n### 如何解决\n通过一个备忘录类专门存储对象状态。\n\n### 关键代码\n客户不与备忘录类耦合，与备忘录管理类耦合。\n\n### 应用实例\n1、后悔药。 \n\n2、打游戏时的存档。 \n\n3、Windows 里的 ctri + z。 \n\n4、IE 中的后退。 \n\n5、数据库的事务管理。\n\n### 开发中常见场景\n1. 聊天服务器 消息推送\n2. Servlet 监听器的实现\n\n### 代码例子\n备忘录模式使用三个类 Memento、Originator 和 CareTaker。Memento 包含了要被恢复的对象的状态。Originator 创建并在 Memento 对象中存储状态。Caretaker 对象负责从 Memento 中恢复对象的状态。\n\nMementoPatternDemo，我们的演示类使用 CareTaker 和 Originator 对象来显示对象的状态恢复。\n\n```java\n// 创建 Memento 类。\npublic class Memento {\n   private String state;\n \n   public Memento(String state){\n      this.state = state;\n   }\n \n   public String getState(){\n      return state;\n   }  \n}\n\n// 创建 Originator 类。\npublic class Originator {\n   private String state;\n \n   public void setState(String state){\n      this.state = state;\n   }\n \n   public String getState(){\n      return state;\n   }\n \n   public Memento saveStateToMemento(){\n      return new Memento(state);\n   }\n \n   public void getStateFromMemento(Memento Memento){\n      state = Memento.getState();\n   }\n}\n\n// 创建 CareTaker 类。\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class CareTaker {\n   private List<Memento> mementoList = new ArrayList<Memento>();\n \n   public void add(Memento state){\n      mementoList.add(state);\n   }\n \n   public Memento get(int index){\n      return mementoList.get(index);\n   }\n}\n\n// 使用 CareTaker 和 Originator 对象。\npublic class MementoPatternDemo {\n   public static void main(String[] args) {\n      Originator originator = new Originator();\n      CareTaker careTaker = new CareTaker();\n      originator.setState(\"State #1\");\n      originator.setState(\"State #2\");\n      careTaker.add(originator.saveStateToMemento());\n      originator.setState(\"State #3\");\n      careTaker.add(originator.saveStateToMemento());\n      originator.setState(\"State #4\");\n \n      System.out.println(\"Current State: \" + originator.getState());    \n      originator.getStateFromMemento(careTaker.get(0));\n      System.out.println(\"First saved State: \" + originator.getState());\n      originator.getStateFromMemento(careTaker.get(1));\n      System.out.println(\"Second saved State: \" + originator.getState());\n   }\n}\n```\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(二十)行为型模式-观察者模式","url":"/2018/07/22/backend/designPatterns/设计模式(二十)行为型模式-观察者模式/","content":"当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。\n\n### 意图\n定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n### 主要解决\n一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n### 什么时候使用\n一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n\n### 如何解决\n使用面向对象技术，可以将这种依赖关系弱化。\n\n### 关键代码\n在抽象类里有一个 ArrayList 存放观察者们。\n\n### 应用实例、\n1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。\n\n\n### 开发中常见场景\n1. 聊天服务器 消息推送\n2. Servlet 监听器的实现\n\n### 代码例子\n```java\n// 观察者接口\npublic abstract class Observer {    \n    public abstract void update(String msg);\n}\n\n// 第一个观察者\npublic class F_Observer extends Observer {\n    public void update(String msg) {\n        System.out.println(F_Observer.class.getName() + \" : \" + msg);\n    }\n}\n\n// 第二个观察者\npublic class S_Observer extends Observer {\n    public void update(String msg) {\n        System.out.println(S_Observer.class.getName() + \" : \" + msg);\n    }\n}\n\n// 第三个观察者\npublic class T_Observer extends Observer {\n    public void update(String msg) {\n        System.out.println(T_Observer.class.getName() + \" : \" + msg);\n    }\n}\n\n// 被观察者\npublic class Subject {        \n    private List<Observer> observers = new ArrayList<>();    //状态改变    \n    public void setMsg(String msg) {        \n        notifyAll(msg);    \n    }   \n     //订阅    \n    public void addAttach(Observer observer) {        \n        observers.add(observer);    \n    }    \n    //通知所有订阅的观察者    \n    private void notifyAll(String msg) {        \n        for (Observer observer : observers) {            \n            observer.update(msg);        \n        }   \n    }\n}\n\n// 使用方法\npublic class Main {    \n    public static void main(String[] args) {        \n        F_Observer fObserver = new F_Observer();        \n        S_Observer sObserver = new S_Observer();        \n        T_Observer tObserver = new T_Observer();                \n        Subject subject = new Subject();        \n        subject.addAttach(fObserver);        \n        subject.addAttach(sObserver);        \n        subject.addAttach(tObserver);                \n        subject.setMsg(\"msg change\");    \n    }\n}\n\n\n```\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十九)行为型模式-状态方法模式","url":"/2018/07/22/backend/designPatterns/设计模式(十九)行为型模式-状态方法模式/","content":"在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。\n\n在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。\n### 意图\n允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。\n### 主要解决\n对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。\n### 什么时候使用\n代码中包含大量与对象状态有关的条件语句。\n\n### 如何解决\n将各种具体的状态类抽象出来。\n\n### 开发中常见场景\n\n\n### 代码例子\n```java\n// 创建一个接口。\npublic interface State {\n   public void doAction(Context context);\n}\n\n// 创建实现接口的实体类。\npublic class StartState implements State {\n \n   public void doAction(Context context) {\n      System.out.println(\"Player is in start state\");\n      context.setState(this); \n   }\n \n   public String toString(){\n      return \"Start State\";\n   }\n}\n// 创建实现接口的实体类。\npublic class StopState implements State {\n \n   public void doAction(Context context) {\n      System.out.println(\"Player is in stop state\");\n      context.setState(this); \n   }\n \n   public String toString(){\n      return \"Stop State\";\n   }\n}\n\n// 环境类，维护一个State对象，定义了当前的状态\npublic class Context {\n   private State state;\n \n   public Context(){\n      state = null;\n   }\n \n   public void setState(State state){\n      this.state = state;     \n   }\n \n   public State getState(){\n      return state;\n   }\n}\n\n// 使用 Context 来查看当状态 State 改变时的行为变化。\npublic class StatePatternDemo {\n   public static void main(String[] args) {\n      Context context = new Context();\n \n      StartState startState = new StartState();\n      startState.doAction(context);\n \n      System.out.println(context.getState().toString());\n \n      StopState stopState = new StopState();\n      stopState.doAction(context);\n \n      System.out.println(context.getState().toString());\n   }\n}\n\n\n```\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十八)行为型模式-模板方法模式","url":"/2018/07/22/backend/designPatterns/设计模式(十八)行为型模式-模板方法模式/","content":"在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板、一个骨架，但某些步骤延迟到子类中实现，调用将以抽象类中定义的方式进行。\n\n即：处理步骤父类中定义好，具体实现延迟到子类中定义\n\n### 意图\n定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。\n\n### 主要解决\n一些方法通用，却在每一个子类都重新写了这一方法。\n\n### 什么时候使用\n实现一个算法，整体步骤都很固定，但某些部分易变，易变部分可以抽象出来\n\n\n### 开发中常见场景\n1. 数据库访问的封装\n2. Junit单元测试\n\n\n### 代码例子\n```java\n// 创建一个抽象类，它的模板方法被设置为 final。\npublic abstract class Game {\n   abstract void initialize();\n   abstract void startPlay();\n   abstract void endPlay();\n \n   //模板\n   public final void play(){\n \n      //初始化游戏\n      initialize();\n \n      //开始游戏\n      startPlay();\n \n      //结束游戏\n      endPlay();\n   }\n}\n\n// 创建扩展了上述类的实体类。\npublic class Cricket extends Game {\n \n   @Override\n   void endPlay() {\n      System.out.println(\"Cricket Game Finished!\");\n   }\n \n   @Override\n   void initialize() {\n      System.out.println(\"Cricket Game Initialized! Start playing.\");\n   }\n \n   @Override\n   void startPlay() {\n      System.out.println(\"Cricket Game Started. Enjoy the game!\");\n   }\n}\n\npublic class Football extends Game {\n \n   @Override\n   void endPlay() {\n      System.out.println(\"Football Game Finished!\");\n   }\n \n   @Override\n   void initialize() {\n      System.out.println(\"Football Game Initialized! Start playing.\");\n   }\n \n   @Override\n   void startPlay() {\n      System.out.println(\"Football Game Started. Enjoy the game!\");\n   }\n}\n\n// 使用 Game 的模板方法 play() 来演示游戏的定义方式。\npublic class TemplatePatternDemo {\n   public static void main(String[] args) {\n \n      Game game = new Cricket();\n      game.play();\n      System.out.println();\n      game = new Football();\n      game.play();      \n   }\n}\n\n```\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十七)行为型模式-策略模式","url":"/2018/07/22/backend/designPatterns/设计模式(十七)行为型模式-策略模式/","content":"在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n### 意图\n定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n\n### 主要解决\n在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。\n\n一个系统有许多许多类，而区分它们的只是他们直接的行为。\n\n###  应用实例\n1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 \n2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 \n3、JAVA AWT 中的 LayoutManager。\n\n### 开发中常见场景\n1. Spring框架 Resource接口，资源访问策略\n2. HttpServlet service\n\n### 代码例子\n```java\n// 策略接口\npublic interface Strategy {\n\tpublic double getPrice(double  standardPrice);\n}\n\n// 很少来的新用户\npublic class NewCustomerFewStrategy implements Strategy {\n\n\t@Override\n\tpublic double getPrice(double standardPrice) {\n\t\tSystem.out.println(\"不打折，原价\");\n\t\treturn standardPrice;\n\t}\n\n}\n\n// 多次来的新用户\npublic class NewCustomerManyStrategy implements Strategy {\n\n\t@Override\n\tpublic double getPrice(double standardPrice) {\n\t\tSystem.out.println(\"打九折\");\n\t\treturn standardPrice*0.9;\n\t}\n\n}\n\n// 很少来的老用户\npublic class OldCustomerFewStrategy implements Strategy {\n\n\t@Override\n\tpublic double getPrice(double standardPrice) {\n\t\tSystem.out.println(\"打八五折\");\n\t\treturn standardPrice*0.85;\n\t}\n\n}\n\n// 经常来的老用户\npublic class OldCustomerManyStrategy implements Strategy {\n\n\t@Override\n\tpublic double getPrice(double standardPrice) {\n\t\tSystem.out.println(\"打八折\");\n\t\treturn standardPrice*0.8;\n\t}\n\n}\n\n/**\n * 负责和具体的策略类交互\n * 这样的话，具体的算法和直接的客户端调用分离了，使得算法可以独立于客户端独立的变化。\n * 如果使用spring的依赖注入功能，还可以通过配置文件，动态的注入不同策略对象，动态的切换不同的算法.\n * @author Administrator\n *\n */\npublic class Context {\n\t// 当前采用的算法对象\n\tprivate Strategy strategy;\t\n\n\t// 可以通过构造器来注入\n\tpublic Context(Strategy strategy) {\n\t\tsuper();\n\t\tthis.strategy = strategy;\n\t}\n\t//可以通过set方法来注入\n\tpublic void setStrategy(Strategy strategy) {\n\t\tthis.strategy = strategy;\n\t}\n\t\n\tpublic void pringPrice(double s){\n\t\tSystem.out.println(\"您该报价：\"+strategy.getPrice(s));\n\t}\n\t\n\t\n}\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tStrategy s1 = new OldCustomerManyStrategy();\n\t\tContext ctx = new Context(s1);\n\t\t\n\t\tctx.pringPrice(998);\n\t\t\n\t}\n}\n```\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十六)行为型模式-解释器模式","url":"/2018/07/22/backend/designPatterns/设计模式(十六)行为型模式-解释器模式/","content":"### 介绍\n解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。\n\n### 意图\n给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。\n\n### 主要解决\n对于一些固定文法构建一个解释句子的解释器。\n* EL表达式\n* 正则表达式\n* SQL语法\n* 数学表达式\n\n\n### 何时使用\n如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n\n### 如何解决\n构件语法树，定义终结符与非终结符。\n\n### 关键代码\n构件环境类，包含解释器之外的一些全局信息，一般是 HashMap。\n\n### 应用实例\n编译器、运算表达式计算。\n\n### 优点\n1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。\n\n### 缺点\n1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。\n\n### 使用场景\n1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。\n\n### 注意事项\n可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十五)行为型模式-命令模式","url":"/2018/07/22/backend/designPatterns/设计模式(十五)行为型模式-命令模式/","content":"### 核心\n命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n\n### 主要解决\n在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n\n### 场景\n1. 数据库事务机制的底层实现\n2. 命令的撤销和恢复\n\n### 何时使用\n在某些场合，比如要对行为进行\"记录、撤销/重做、事务\"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\"行为请求者\"与\"行为实现者\"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n\n### 如何解决：\n通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n\n### 例子\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十四)：行为型模式-中介模式","url":"/2018/07/22/backend/designPatterns/设计模式(十四)：行为型模式-中介模式/","content":"### 核心\n如果一个系统中对象之间的联系呈现为网状结构，对象之前存在大量多对多关系，将导致关系及其复杂，我们可以引入一个中介者对象，使各个同事对象只和中介者打交道\n\n中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。\n\n\n### 场景\n1. 公司都有总经理，各个部门有什么事都通报到总经理这里，总经理再通知各个相关部门，在这里总经理起到了一个中介、协调的作用\n2. 中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 \n3. 机场调度系统。 \n4. MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。\n\n\n### 例子\n我们通过聊天室实例来演示中介者模式。实例中，多个用户可以向聊天室发送消息，聊天室向所有的用户显示消息。我们将创建两个类 ChatRoom 和 User。User 对象使用 ChatRoom 方法来分享他们的消息。\n```java\n// 创建中介类。\nimport java.util.Date;\n \npublic class ChatRoom {\n   public static void showMessage(User user, String message){\n      System.out.println(new Date().toString()\n         + \" [\" + user.getName() +\"] : \" + message);\n   }\n}\n\n// 创建 user 类。\npublic class User {\n   private String name;\n \n   public String getName() {\n      return name;\n   }\n \n   public void setName(String name) {\n      this.name = name;\n   }\n \n   public User(String name){\n      this.name  = name;\n   }\n \n   public void sendMessage(String message){\n      ChatRoom.showMessage(this,message);\n   }\n}\n\n// 使用 User 对象来显示他们之间的通信。\npublic class MediatorPatternDemo {\n   public static void main(String[] args) {\n      User robert = new User(\"Robert\");\n      User john = new User(\"John\");\n \n      robert.sendMessage(\"Hi! John!\");\n      john.sendMessage(\"Hello! Robert!\");\n   }\n}\n\n```","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十三)行为型模式-迭代器模式","url":"/2018/07/22/backend/designPatterns/设计模式(十三)行为型模式-迭代器模式/","content":"### 定义\n迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。\n\n\n\n### 场景\n* 提供一种可以遍历聚合对象的方式，又称游标cursor模式\n* 聚合对象：存储数据\n* 迭代器：遍历数据\n\n\n### 例子\n```java\n// 自定义的迭代器接口\npublic interface MyIterator {\n\t// 将游标指向第一个元素\n\tvoid first();\n\t// 将游标指向下一个元素\n\tvoid next();\n\t// 判断是否存在下一个元素\n\tboolean hasNext();\n\t\n\tboolean isFirst();\n\t\n\tboolean isLast();\n\t\n\t// 获取当前游标指向的对象\n\tObject getCurrentObj();  \n}\n\n\n// 自定义的聚合类\npublic class ConcreteMyAggregate {\n\tprivate List<Object> list = new ArrayList<>();\n\n\tpublic void addObject(Object obj){\n\t\tthis.list.add(obj);\n\t}\n\tpublic void removeObject(Object obj){\n\t\tthis.list.remove(obj);\n\t}\n\n\tpublic List<Object> getList() {\n\t\treturn list;\n\t}\n\n\tpublic void setList(List<Object> list) {\n\t\tthis.list = list;\n\t}\n\t\n\t// 获得迭代器\n\tpublic MyIterator  createIterator(){\n\t\treturn new ConcreteIterator();\n\t}\n\n\t// 使用内部类定义迭代器，可以直接使用外部类的属性\n\tprivate class ConcreteIterator implements MyIterator {\n\n\t\tprivate int cursor;  //定义游标用于记录遍历时的位置\n\n\t\t@Override\n\t\tpublic void first() {\n\t\t\tcursor = 0;\n\t\t}\n\t\t@Override\n\t\tpublic Object getCurrentObj() {\n\t\t\treturn list.get(cursor);\n\t\t}\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\tif(cursor < list.size()){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t@Override\n\t\tpublic boolean isFirst() {\n\t\t\treturn cursor==0?true:false;\n\t\t}\n\t\t@Override\n\t\tpublic boolean isLast() {\n\t\t\treturn cursor==(list.size()-1)?true:false;\n\t\t}\n\t\t@Override\n\t\tpublic void next() {\n\t\t\tif(cursor < list.size()){\n\t\t\t\tcursor++;\n\t\t\t}\n\t\t}\n\t}\n}\n\npublic class Client {\n\t\n\tpublic static void main(String[] args) {\n\t\tConcreteMyAggregate cma = new ConcreteMyAggregate();\n\t\tcma.addObject(\"aa\");\n\t\tcma.addObject(\"bb\");\n\t\tcma.addObject(\"cc\");\n\t\t\n\t\tMyIterator iter = cma.createIterator();\n\t\twhile(iter.hasNext()){\n\t\t\tSystem.out.println(iter.getCurrentObj());\n\t\t\titer.next();\n\t\t}\n\t\t\n\t}\n}\n\n```","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十二)行为型模式-责任链模式","url":"/2018/07/22/backend/designPatterns/设计模式(十二)行为型模式-责任链模式/","content":"### 定义\n将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象\n\n### 使用场景\n1. Java异常机制，catch的匹配\n2. Servlet， 过滤器的链式处理\n\n\n### 分类\n1. 链表方式定义职责链\n\n2. 非链表方式定义职责链（集合，数组）\n\n### 场景\n* 打牌 轮流出牌\n* 接力赛跑\n* 公司盖章审批\n\n### 例子\n请假流程\n```java\n// 领导抽象类\npublic abstract class Leader {\n\tprotected String name;\n\t// 责任链上的后继对象\n\tprotected Leader nextLeader;\n\t\n\tpublic Leader(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\t\n\t// 设定责任链上的后继对象\n\tpublic void setNextLeader(Leader nextLeader) {\n\t\tthis.nextLeader = nextLeader;\n\t}\n\n\t// 处理请求的核心的业务方法\n\tpublic abstract void handleRequest(LeaveRequest request);\n}\n\n// 封装请假的基本信息\npublic class LeaveRequest {\n\tprivate String empName;\n\tprivate int leaveDays;\n\tprivate String reason;\n\t\n\t\n\tpublic LeaveRequest(String empName, int leaveDays, String reason) {\n\t\tsuper();\n\t\tthis.empName = empName;\n\t\tthis.leaveDays = leaveDays;\n\t\tthis.reason = reason;\n\t}\n}\n\n// 主任\npublic class Director extends Leader {\n\n\tpublic Director(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void handleRequest(LeaveRequest request) {\n\t\tif(request.getLeaveDays()<3){\n\t\t\tSystem.out.println(\"员工：\"+request.getEmpName()+\"请假，天数：\"+request.getLeaveDays()+\",理由：\"+request.getReason());\n\t\t\tSystem.out.println(\"主任：\"+this.name+\",审批通过！\");\n\t\t}else{\n\t\t\tif(this.nextLeader!=null){\n\t\t\t\tthis.nextLeader.handleRequest(request);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 总经理\npublic class GeneralManager extends Leader {\n\n\tpublic GeneralManager(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void handleRequest(LeaveRequest request) {\n\t\tif(request.getLeaveDays()<30){\n\t\t\tSystem.out.println(\"员工：\"+request.getEmpName()+\"请假，天数：\"+request.getLeaveDays()+\",理由：\"+request.getReason());\n\t\t\tSystem.out.println(\"总经理：\"+this.name+\",审批通过！\");\n\t\t}else{\n\t\t\tSystem.out.println(\"莫非\"+request.getEmpName()+\"想辞职，居然请假\"+request.getLeaveDays()+\"天！\");\n\t\t}\n\t}\n\n}\n\n// 经理\npublic class Manager extends Leader {\n\n\tpublic Manager(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void handleRequest(LeaveRequest request) {\n\t\tif(request.getLeaveDays()<10){\n\t\t\tSystem.out.println(\"员工：\"+request.getEmpName()+\"请假，天数：\"+request.getLeaveDays()+\",理由：\"+request.getReason());\n\t\t\tSystem.out.println(\"经理：\"+this.name+\",审批通过！\");\n\t\t}else{\n\t\t\tif(this.nextLeader!=null){\n\t\t\t\tthis.nextLeader.handleRequest(request);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n// 副总经理\npublic class ViceGeneralManager extends Leader {\n\n\tpublic ViceGeneralManager(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void handleRequest(LeaveRequest request) {\n\t\tif(request.getLeaveDays()<20){\n\t\t\tSystem.out.println(\"员工：\"+request.getEmpName()+\"请假，天数：\"+request.getLeaveDays()+\",理由：\"+request.getReason());\n\t\t\tSystem.out.println(\"副总经理：\"+this.name+\",审批通过！\");\n\t\t}else{\n\t\t\tif(this.nextLeader!=null){\n\t\t\t\tthis.nextLeader.handleRequest(request);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tLeader a = new Director(\"张三\");\n\t\tLeader b = new Manager(\"李四\");\n\t\tLeader b2 = new ViceGeneralManager(\"李小四\");\n\t\tLeader c = new GeneralManager(\"王五\");\n\t\t//组织责任链对象的关系\n\t\ta.setNextLeader(b);\n\t\tb.setNextLeader(b2);\n\t\tb2.setNextLeader(c);\n\t\t\n\t\t//开始请假操作\n\t\tLeaveRequest req1 = new LeaveRequest(\"TOM\", 15, \"回江西老家探亲！\");\n\t\ta.handleRequest(req1);\n\t\t\n\t}\n}\n\n\n\n```","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十一)结构型模式-享元模式","url":"/2018/07/22/backend/designPatterns/设计模式(十一)结构型模式-享元模式/","content":"### 核心\n* 享元模式以共享的方式高效的支持大量细粒度对象的重用\n* 享元对象能做到共享的关键是区分了内部状态和外部状态\n> 内部状态：可以共享，不会随环境变化而变化\n\n> 外部状态：不可以共享，会随环境的变化而变化\n\n### 场景\n内存属于稀缺资源，不要随便浪费，如果有很多和完全相同或相似的对象，我们可以通过享元模式，节省内存\n\n享元模式由于其共享的特性，可以在任何“池”中操作，比如线程池、数据库连接池\n\nString 类的设计也是享元模式\n\n### 例子\n围棋软件设计\n\n每一个围棋棋子都是一个对象，有如下属性：颜色，形状，大小，这些是可以共享的，称之为内部状态\n\n棋子位置不能共享，称之为外部状态\n```java\n// 享元类\npublic interface ChessFlyWeight {\n\tvoid setColor(String c);\n\tString getColor();\n\tvoid display(Coordinate c);\n}\n\n// 棋子类\nclass ConcreteChess implements ChessFlyWeight {\n    // 内部状态-颜色\n\tprivate String color;\n\t\n\tpublic ConcreteChess(String color) {\n\t\tsuper();\n\t\tthis.color = color;\n\t}\n\n\t@Override\n\tpublic void display(Coordinate c) {\n\t\tSystem.out.println(\"棋子颜色：\"+color);\n\t\tSystem.out.println(\"棋子位置：\"+c.getX()+\"----\"+c.getY());\n\t}\n\n\t@Override\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\n\t@Override\n\tpublic void setColor(String c) {\n\t\tthis.color = c;\n\t}\n\t\n}\n\n// 外部状态-用于棋子定位\npublic class Coordinate {\n\tprivate int x,y;\n\n\tpublic Coordinate(int x, int y) {\n\t\tsuper();\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int getX() {\n\t\treturn x;\n\t}\n\n\tpublic void setX(int x) {\n\t\tthis.x = x;\n\t}\n\n\tpublic int getY() {\n\t\treturn y;\n\t}\n\n\tpublic void setY(int y) {\n\t\tthis.y = y;\n\t}\n\t\n}\n\n// 享元工厂类\npublic class ChessFlyWeightFactory {\n\t// 享元池\n\tprivate static Map<String,ChessFlyWeight> map = new HashMap<String, ChessFlyWeight>();\n\t\n\tpublic static ChessFlyWeight  getChess(String color){\n\t\tif(map.get(color)!=null){\n\t\t\treturn map.get(color);\n\t\t}else{\n\t\t\tChessFlyWeight cfw = new ConcreteChess(color);\n\t\t\tmap.put(color, cfw);\n\t\t\treturn cfw;\n\t\t}\n\t}\n}\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tChessFlyWeight chess1 = ChessFlyWeightFactory.getChess(\"黑色\");\n\t\tChessFlyWeight chess2 = ChessFlyWeightFactory.getChess(\"黑色\");\n\n\t\t// 共享同一个状态\n\t\tSystem.out.println(chess1);\n\t\tSystem.out.println(chess2);\n\t\t\n\t\tSystem.out.println(\"增加外部状态的处理===========\");\n\t\tchess1.display(new Coordinate(10, 10));\n\t\tchess2.display(new Coordinate(20, 20));\n\t}\n}\n\n```","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(十)：结构型模式-外观模式","url":"/2018/07/22/backend/designPatterns/设计模式(十)：结构型模式-外观模式/","content":"遵循迪米特法则(最少知识法则)\n\n一个软件实体应当尽可能少的与其他实体发生相互作用\n\n外观模式也称蒙面模式\n\n### 核心\n为子系统提供统一的入口，封装子系统的复杂性，便于客户端调用\n\n\n\n### 例子\n\n感觉电脑的例子更形象：\n\n电脑整机是 CPU、内存、硬盘的外观。有了外观以后，启动电脑和关闭电脑都简化了。\n\n直接 new 一个电脑。\n\n在 new 电脑的同时把 cpu、内存、硬盘都初始化好并且接好线。\n\n对外暴露方法（启动电脑，关闭电脑）。\n\n启动电脑（按一下电源键）：启动CPU、启动内存、启动硬盘\n\n关闭电脑（按一下电源键）：关闭硬盘、关闭内存、关闭CPU\n\n\n\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(九)结构型模式-装饰器模式","url":"/2018/07/22/backend/designPatterns/设计模式(九)结构型模式-装饰器模式/","content":"\n### 职责\n* 动态的为一个对象增加新的功能，也叫包装器模式\n* 装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能，使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀\n* 降低系统的耦合度，可以动态的增加或删除对象的职责\n\n### 实现细节\nComponent 抽象构件角色\n> 真实对象与装饰对象有相同的接口，这样，客户端对象就能够以真实对象相同的方式同装饰对象交互\n\nConcreteComponent 具体构件角色(真实对象)\n> io流中的FileInputStream FileOutputStream\n\nDecorator 装饰角色\n> 持有一个抽象构件的引用，装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象，这样才能真实对象调用前后增加新的功能\n\nConcreteDecorator 具体装饰角色\n>负责给构件对象增加新的责任\n\n### 代码实现\n\n```java\n// 抽象构建\npublic interface ICar {\n\tvoid move();\n}\n\n// ConcreteComponent 具体构件角色(真实对象)\nclass Car implements ICar {\n\t@Override\n\tpublic void move() {\n\t\tSystem.out.println(\"陆地上跑！\");\n\t}\n}\n\n// Decorator装饰角色\nclass SuperCar implements ICar {\n\tprotected ICar car;\n\tpublic SuperCar(ICar car) {\n\t\tsuper();\n\t\tthis.car = car;\n\t}\n\n\t@Override\n\tpublic void move() {\n\t\tcar.move();\n\t}\n}\n\n// ConcreteDecorator具体装饰角色\nclass FlyCar extends SuperCar {\n\n\tpublic FlyCar(ICar car) {\n\t\tsuper(car);\n\t}\n\t\n\tpublic void fly(){\n\t\tSystem.out.println(\"天上飞！\");\n\t}\n\n\t@Override\n\tpublic void move() {\n\t\tsuper.move();\n\t\tfly();\n\t}\n\t\n}\n\n// ConcreteDecorator具体装饰角色\nclass WaterCar extends SuperCar {\n\t\n\tpublic WaterCar(ICar car) {\n\t\tsuper(car);\n\t}\n\t\n\tpublic void swim(){\n\t\tSystem.out.println(\"水上游！\");\n\t}\n\t\n\t@Override\n\tpublic void move() {\n\t\tsuper.move();\n\t\tswim();\n\t}\n\t\n}\n\n// ConcreteDecorator具体装饰角色\nclass AICar extends SuperCar {\n\t\n\tpublic AICar(ICar car) {\n\t\tsuper(car);\n\t}\n\t\n\tpublic void autoMove(){\n\t\tSystem.out.println(\"自动跑！\");\n\t}\n\t\n\t@Override\n\tpublic void move() {\n\t\tsuper.move();\n\t\tautoMove();\n\t}\n\t\n}\n\n\n\tpublic static void main(String[] args) {\n\t\tCar car  = new Car();\n\t\tcar.move();\n\t\t\n\t\tSystem.out.println(\"增加新的功能，飞行----------\");\n\t\tFlyCar flycar = new FlyCar(car);\n\t\tflycar.move();\n\t\t\n\t\tSystem.out.println(\"增加新的功能，水里游---------\");\n\t\tWaterCar  waterCar = new WaterCar(car);\n\t\twaterCar.move();\n\t\t\n\t\tSystem.out.println(\"增加两个新的功能，飞行，水里游-------\");\n\t\tWaterCar waterCar2 = new WaterCar(new FlyCar(car));\n\t\twaterCar2.move();\n\t}\n```\n\n\n### 应用场景\n* 操作系统的资源管理器\n* `XML`文件解析\n* `Junit`单元测试框架\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(八)结构型模式-组合模式","url":"/2018/07/22/backend/designPatterns/设计模式(八)结构型模式-组合模式/","content":"组合模式，就是在一个对象中包含其他对象，这些被包含的对象可能是终点对象（不再包含别的对象），也有可能是非终点对象（其内部还包含其他对象，或叫组对象），我们将对象称为节点，即一个根节点包含许多子节点，这些子节点有的不再包含子节点，而有的仍然包含子节点，以此类推。\n\n### 组合模式核心 \n> 抽象构件(Component)角色，定义了叶子与容器构件的共同点\n\n> 叶子(Leaf)构件角色：无子节点\n\n> 容器（Composite）构件角色：有容器特征，可以包括子节点\n```java\n// 抽象组件\npublic interface Component {\n\tvoid operation();\n}\n\n// 叶子组件\ninterface Leaf extends Component {\n}\n// 容器组件\ninterface Composite extends Component {\n\tvoid add(Component c);\n\tvoid remove(Component c);\n\tComponent getChild(int index);\n}\n```\n### 应用场景\n1. 操作系统的资源管理器\n2. XML文件解析\n3. Junit单元测试框架\n\n### 代码实现\n```java\n// 使用组合模式，模拟杀毒软件架构设计\npublic interface AbstractFile {\n\tvoid killVirus();  //杀毒\n}\n\n// 图片文件\nclass ImageFile implements AbstractFile {\n\tprivate String name;\n\t\n\tpublic ImageFile(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic void killVirus() {\n\t\tSystem.out.println(\"---图像文件：\"+name+\",进行查杀！\");\n\t}\n\t\n}\n\n// 文本文件\nclass TextFile implements AbstractFile {\n\tprivate String name;\n\tpublic TextFile(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\t@Override\n\tpublic void killVirus() {\n\t\tSystem.out.println(\"---文本文件：\"+name+\",进行查杀！\");\n\t}\n}\n// 视频文件\nclass VideoFile implements AbstractFile {\n\tprivate String name;\n\tpublic VideoFile(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\t@Override\n\tpublic void killVirus() {\n\t\tSystem.out.println(\"---视频文件：\"+name+\",进行查杀！\");\n\t}\n}\n// 文件夹\nclass Folder implements AbstractFile {\n\tprivate String name;\n\t//定义容器，用来存放本容器构建下的子节点\n\tprivate List<AbstractFile> list = new ArrayList<>();\n\tpublic Folder(String name) {\n\t\tsuper();\n\t\tthis.name = name;\n\t}\n\tpublic void add(AbstractFile file){\n\t\tlist.add(file);\n\t}\n\tpublic void remove(AbstractFile file){\n\t\tlist.remove(file);\n\t}\n\tpublic AbstractFile getChild(int index){\n\t\treturn list.get(index);\n\t}\n\t// 递归查杀子文件夹的文件\n\t@Override\n\tpublic void killVirus() {\n\t\tSystem.out.println(\"---文件夹：\"+name+\",进行查杀\");\n\t\tfor (AbstractFile file : list) {\n\t\t\tfile.killVirus();\n\t\t}\n\t}\n}\n\n// 开始杀毒\n\tpublic static void main(String[] args) {\n\t\tAbstractFile f2,f3,f4,f5;\n\t\t// D盘文件夹, 有以下俩个文件，和一个视频文件夹vidio\n\t\tFolder f1 = new Folder(\"D:/\");\n\t\tf2 = new ImageFile(\"老高的大头像.jpg\");\n\t\tf3 = new TextFile(\"Hello.txt\");\n\t\tf1.add(f2);\n\t\tf1.add(f3);\n\t\t\n\t\t// 视频文件夹vidio\n\t\tFolder f11 = new Folder(\"vidio\");\n\t\tf4 = new VideoFile(\"笑傲江湖.avi\");\n\t\tf5 = new VideoFile(\"神雕侠侣.avi\");\n\t\tf11.add(f4);\n\t\tf11.add(f5);\n\t\tf1.add(f11);\n\t\t\n\t\t// 开始杀毒\n\t\tf1.killVirus();\n\t\t\n\t\t\n\t}\n```\n\n\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(七)结构型模式-桥接模式","url":"/2018/07/22/backend/designPatterns/设计模式(七)结构型模式-桥接模式/","content":"\n### 核心本质\n> 处理多层继承结构，处理`多维度变化`的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联\n\n> 桥接模式可以取代多层继承的方案，多层继承违背了单一职责原则，复用性差，类的个数也非常多。桥接模式可以极大减少子类的个数，从而降低管理和维护的成本\n\n> 极大提高了系统可扩展性，从俩个变化维度中任意扩展一个维度，都不需要修改原有的系统。符合开闭原则\n\n> 就像一个桥，将俩个变化维度连接起来，各个维度都可以独立的变化，故称之为：桥模式\n\n### 应用场景\n1. JDBC驱动程序\n2. OA系统中的消息处理，普通消息，加急消息，特急消息\n\n\n### 代码实现\n\n```java\n// 品牌维度\npublic interface Brand {\n\tvoid sale();\n}\nclass Lenovo implements Brand {\n\n\t@Override\n\tpublic void sale() {\n\t\tSystem.out.println(\"销售联想电脑\");\n\t}\n\t\n}\nclass Dell implements Brand {\n\t\n\t@Override\n\tpublic void sale() {\n\t\tSystem.out.println(\"销售Dell电脑\");\n\t}\n}\nclass Shenzhou implements Brand {\n\t\n\t@Override\n\tpublic void sale() {\n\t\tSystem.out.println(\"销售神舟电脑\");\n\t}\n}\n\n// 电脑类型-通过组合将品牌桥接过来\npublic class Computer {\n\n\tprotected Brand brand;\n\n\tpublic Computer(Brand b) {\n\t\tthis.brand = b;\n\t}\n\tpublic void sale(){\n\t\tbrand.sale();\n\t}\n}\n\nclass Desktop extends Computer {\n\tpublic Desktop(Brand b) {\n\t\tsuper(b);\n\t}\n\t@Override\n\tpublic void sale() {\n\t\tsuper.sale();\n\t\tSystem.out.println(\"销售台式机\");\n\t}\n}\n\nclass Laptop extends Computer {\n\tpublic Laptop(Brand b) {\n\t\tsuper(b);\n\t}\n\t@Override\n\tpublic void sale() {\n\t\tsuper.sale();\n\t\tSystem.out.println(\"销售笔记本\");\n\t}\n}\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t//销售联想的笔记本电脑\n\t\tComputer  c = new Laptop(new Lenovo());\n\t\tc.sale();\n\t\t//销售神舟的台式机\n\t\tComputer c2 = new Desktop(new Shenzhou());\n\t\tc2.sale();\n\t}\n}\n\n```","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(六)结构型模式-代理模式","url":"/2018/07/22/backend/designPatterns/设计模式(六)结构型模式-代理模式/","content":"> 通过代理，控制对对象的访问，可以详细控制访问某个类对象的方法，在调用这个方法前做前置处理或者在方法之后做后置处理\n\n### 核心本质\n在代理模式`（Proxy Pattern）`中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。\n\n在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n\n### 分类\n1. 静态代理\n2. 动态代理\n\n### 应用场景\n1. `AOP`\n\n\n### 代码实现\n\n#### 静态代理\n```java\n// 明星接口\npublic interface Star {\n\t/**\n\t * 面谈\n\t */\n\tvoid confer();\n\t/**\n\t * 签合同\n\t */\n\tvoid signContract();\n\t/**\n\t * 订票\n\t */\n\tvoid bookTicket();\n\t/**\n\t * 唱歌\n\t */\n\tvoid sing();\n\t/**\n\t * 收钱\n\t */\n\tvoid collectMoney();\n}\n\n// 真实明星\npublic class RealStar implements Star {\n\n\t@Override\n\tpublic void bookTicket() {\n\t\tSystem.out.println(\"RealStar.bookTicket()\");\n\t}\n\n\t@Override\n\tpublic void collectMoney() {\n\t\tSystem.out.println(\"RealStar.collectMoney()\");\n\t}\n\n\t@Override\n\tpublic void confer() {\n\t\tSystem.out.println(\"RealStar.confer()\");\n\t}\n\n\t@Override\n\tpublic void signContract() {\n\t\tSystem.out.println(\"RealStar.signContract()\");\n\t}\n\n\t@Override\n\tpublic void sing() {\n\t\tSystem.out.println(\"RealStar(周杰伦本人).sing()\");\n\t}\n}\n\n// 明星经纪人\npublic class ProxyStar implements Star {\n\t\n\tprivate Star star;\n\t\n\tpublic ProxyStar(Star star) {\n\t\tsuper();\n\t\tthis.star = star;\n\t}\n\n\t@Override\n\tpublic void bookTicket() {\n\t\tSystem.out.println(\"ProxyStar.bookTicket()\");\n\t}\n\n\t@Override\n\tpublic void collectMoney() {\n\t\tSystem.out.println(\"ProxyStar.collectMoney()\");\n\t}\n\n\t@Override\n\tpublic void confer() {\n\t\tSystem.out.println(\"ProxyStar.confer()\");\n\t}\n\n\t@Override\n\tpublic void signContract() {\n\t\tSystem.out.println(\"ProxyStar.signContract()\");\n\t}\n\n\t@Override\n\tpublic void sing() {\n\t\tstar.sing();\n\t}\n\n}\n\n// 商演执行类\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\t// 需要找周杰伦来进行一次商演，直接找他的经纪人处理\n\t\tStar real = new RealStar();\n\t\tStar proxy = new ProxyStar(real);\n\t\tproxy.confer();\n\t\tproxy.signContract();\n\t\tproxy.bookTicket();\n\t\t// 经纪人不会唱歌需要他找到周杰伦来唱\n\t\tproxy.sing();\n\t\tproxy.collectMoney();\n\t\t\n\t}\n}\n\n```\n\n#### 动态代理 动态生成代理类\n* JDK 自带的动态代理\n* Java assist 字节码操作库实现\n* Cglib\n* Asm 底层使用指令，可维护性差\n\n\n##### JDK 自带的动态代理\nProxy: 动态生成代理类和对象\n\nInvocationHandler：处理器接口\n\n代码实现：\n```java\npublic interface Star {\n\t/**\n\t * 面谈\n\t */\n\tvoid confer();\n\t/**\n\t * 签合同\n\t */\n\tvoid signContract();\n\t/**\n\t * 订票\n\t */\n\tvoid bookTicket();\n\t/**\n\t * 唱歌\n\t */\n\tvoid sing();\n\t/**\n\t * 收钱\n\t */\n\tvoid collectMoney();\n}\n\n// 周杰伦\npublic class RealStar implements Star {\n\n\t@Override\n\tpublic void bookTicket() {\n\t\tSystem.out.println(\"RealStar.bookTicket()\");\n\t}\n\n\t@Override\n\tpublic void collectMoney() {\n\t\tSystem.out.println(\"RealStar.collectMoney()\");\n\t}\n\n\t@Override\n\tpublic void confer() {\n\t\tSystem.out.println(\"RealStar.confer()\");\n\t}\n\n\t@Override\n\tpublic void signContract() {\n\t\tSystem.out.println(\"RealStar.signContract()\");\n\t}\n\n\t@Override\n\tpublic void sing() {\n\t\tSystem.out.println(\"RealStar(周杰伦本人).sing()\");\n\t}\n}\n\n// 增强处理类\npublic class StarHandler implements InvocationHandler {\n\t\n\tStar realStar;\n\t\n\tpublic StarHandler(Star realStar) {\n\t\tsuper();\n\t\tthis.realStar = realStar;\n\t}\n    // 只要调用了被代理的方法都会执行该方法\n\t@Override\n\tpublic Object invoke(Object proxy, Method method, Object[] args)\n\t\t\tthrows Throwable {\n\t\tObject object = null;\n\t\t\n\t\tSystem.out.println(\"真正的方法执行前！\");\n\t\tSystem.out.println(\"面谈，签合同，预付款，订机票\");\n\t\t\n\t\tif(method.getName().equals(\"sing\")){\n\t\t\tobject = method.invoke(realStar, args);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"真正的方法执行后！\");\n\t\tSystem.out.println(\"收尾款\");\n\t\treturn object;\n\t}\n}\n// 演出开始\n\tpublic static void main(String[] args) {\n\t\t\n\t\tStar realStar = new RealStar();\n\t\tStarHandler handler = new StarHandler(realStar);\n\t\t\n\t\tStar proxy = (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), \n\t\t\t\tnew Class[]{Star.class}, handler);\n\t\t\n\t\tproxy.sing();\n\t\t\n\t}\n```\n\n\n#### 总结\n\n##### 静态代理\n1.可以做到在不修改目标对象的功能前提下,对目标功能扩展.\n\n2.缺点:因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.\n\n3.由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了所以说是静态代理，而动态代理是程序在运行过程中利用反射生成代理类 \n\n\n##### 动态代理\n\n1.在程序运行时，运用反射机制动态创建而成。由此可见，代理类可以为委托类预处理消息、把消息转发给委托类和事后处理消息等","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(五)结构型模式-适配器模式","url":"/2018/07/22/backend/designPatterns/设计模式(五)结构型模式-适配器模式/","content":"### 结构型模式核心作用\n是从程序的结构实现松解耦，从而可以扩大整体的类结构，用来解决更大的问题 \n\n### 核心本质\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。\n\n这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。\n\n### 分类\n1. 类适配器，通过继承\n2. 对象适配器，通过组合的方式\n\n\n\n### 代码实现\n> 在只有usb接口的电脑能够使用ps2接口的鼠标键盘，需要一个适配器将ps2的接口和usb的接口连接起来\n\n```java\n// 需要适配的对象\npublic class Ps2Mouse {\n\n    public void use(){\n        System.out.println(\"正在使用ps2接口类型的鼠标！\");\n    }\n\n}\n\n// 原对象处理接口\npublic interface Target {\n    // 处理方法\n    public void handle();\n}\n\n\n// 基于继承被适配类实现适配\npublic class TargetPs2Impl1 extends Ps2Mouse implements Target {\n    // 继承Ps2Mouse直接调用use方法\n    @Override\n    public void handle() {\n        super.use();\n    }\n}\n\n// 基于组合被适配类实现适配\npublic class TargetPs2Impl2 implements Target {\n\n   private Ps2Mouse ps2Mouse;\n\n   // 需要在构造函数的时候传入被适配类对象\n   public TargetPs2Impl2(Ps2Mouse ps2Mouse) {\n       this.ps2Mouse = ps2Mouse;\n\n   }\n    @Override\n    public void handle() {\n        ps2Mouse.use();\n    }\n}\n\n// 使用者\npublic class Person {\n    /**\n     * 使用鼠标\n     * @param target\n     */\n    public void useMouse(Target target) {\n        target.handle();\n    }\n\n\n    public static void main(String[] args) {\n        Person person = new Person();\n\n        // 使用适配器1可以使用ps2键盘了\n        Target target1 = new TargetPs2Impl1();\n        person.useMouse(target1);\n\n        // 使用适配器2可以使用ps2键盘了\n        Ps2Mouse ps2Mouse = new Ps2Mouse();\n        Target target2 = new TargetPs2Impl2(ps2Mouse);\n        person.useMouse(target2);\n\n    }\n}\n\n```\n\n### 应用场景\n* 美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V\n* JAVA 中的 jdbc。\n* 鼠标有usb接口和 ps2接口转化器\n* 旧系统改造和升级\n* `Spring MVC`的`HandlerAdapter`\n\n### 总结","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(四)创建型模式-原型模式","url":"/2018/07/21/backend/designPatterns/设计模式(四)创建型模式-原型模式/","content":"### 核心本质\n> 当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。\n\n> 克隆类似于new, 但是不同于new, new创建新的对象属性采用的是默认值，克隆出的对象属性值完全和原型对象相同，并且克隆出的新对象改变并不会影响原型对象\n\n### 应用场景\n1. Cloneable接口和clone方法\n2. 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐\"。\n3. JAVA 中的 StringBuilder。\n4. 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone 的方法创建一个对象，然后由工厂方法提供给调用者，比如Spring中Bean的创建实际就两种单例模式和原型模式，当然原型模式需要和工厂模式搭配起来\n\n### 代码实现\n```java\n/**\n * 浅复制\n * 1997,英国的克隆羊，多利！\n * 实现 Cloneable接口\n */\npublic class DeepCopySheep implements Cloneable,Serializable {\n\n\tprivate String sname;\n\n\tprivate Date birthday;\n\n\t/**\n\t * 直接调用object对象的clone()方法！\n\t * @return\n\t * @throws CloneNotSupportedException\n\t */\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tObject obj = super.clone();\n\t\treturn obj;\n\t}\n\n\n\tpublic String getSname() {\n\t\treturn sname;\n\t}\n\n\n\tpublic void setSname(String sname) {\n\t\tthis.sname = sname;\n\t}\n\n\n\tpublic Date getBirthday() {\n\t\treturn birthday;\n\t}\n\n\n\tpublic void setBirthday(Date birthday) {\n\t\tthis.birthday = birthday;\n\t}\n\n\n\tpublic DeepCopySheep(String sname, Date birthday) {\n\t\tsuper();\n\t\tthis.sname = sname;\n\t\tthis.birthday = birthday;\n\t}\n\t\n\tpublic DeepCopySheep() {\n\t}\n\t\n}\n\n/**\n * 深复制\n * 1997,英国的克隆羊，多利！\n */\npublic class ShallowCopySheep implements Cloneable {\n\tprivate String sname;\n\tprivate Date birthday;\n\n\t/**\n\t * 直接调用object对象的clone()方法！\n\t * @return\n\t * @throws CloneNotSupportedException\n\t */\n\t@Override\n\tprotected Object clone() throws CloneNotSupportedException {\n\t\tObject obj = super.clone();\n\t\t// 添加如下代码实现深复制(deep Clone)\n\t\tShallowCopySheep s = (ShallowCopySheep) obj;\n\t\t// 把属性也进行克隆！\n\t\ts.birthday = (Date) this.birthday.clone();\n\t\t\n\t\treturn obj;\n\t}\n\n\n\tpublic String getSname() {\n\t\treturn sname;\n\t}\n\n\n\tpublic void setSname(String sname) {\n\t\tthis.sname = sname;\n\t}\n\n\n\tpublic Date getBirthday() {\n\t\treturn birthday;\n\t}\n\n\n\tpublic void setBirthday(Date birthday) {\n\t\tthis.birthday = birthday;\n\t}\n\n\n\tpublic ShallowCopySheep(String sname, Date birthday) {\n\t\tsuper();\n\t\tthis.sname = sname;\n\t\tthis.birthday = birthday;\n\t}\n\t\n\tpublic ShallowCopySheep() {\n\t}\n\t\n}\n\n/**\n * 原型模式(深复制,使用序列化和反序列化的方式实现深复制)\n */\npublic class Client3 {\n\tpublic static void main(String[] args) throws CloneNotSupportedException, Exception {\n\t\tDate date = new Date(12312321331L);\n\t\tDeepCopySheep s1 = new DeepCopySheep(\"少利\",date);\n\t\tSystem.out.println(s1);\n\t\tSystem.out.println(s1.getSname());\n\t\tSystem.out.println(s1.getBirthday());\n\n\t\t\n\t\t// 使用序列化和反序列化实现深复制\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\tObjectOutputStream    oos = new ObjectOutputStream(bos);\n\t\toos.writeObject(s1);\n\t\tbyte[] bytes = bos.toByteArray();\n\t\t\n\t\tByteArrayInputStream  bis = new ByteArrayInputStream(bytes);\n\t\tObjectInputStream\t  ois = new ObjectInputStream(bis);\n\n\t\t// 克隆好的对象！\n\t\tDeepCopySheep s2 = (DeepCopySheep) ois.readObject();\n\t\t\n\t\tSystem.out.println(\"修改原型对象的属性值\");  \n\t\tdate.setTime(23432432423L);\n\t\t\n\t\tSystem.out.println(s1.getBirthday());\n\t\t\n\t\ts2.setSname(\"多利\");\n\t\tSystem.out.println(s2);\n\t\tSystem.out.println(s2.getSname());\n\t\tSystem.out.println(s2.getBirthday());\n\t}\n}\n\n```\n","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(三)创建型模式-建造者模式","url":"/2018/07/21/backend/designPatterns/设计模式(三)创建型模式-建造者模式/","content":"### 核心本质\n* 复杂对象的构建过程，分离了对象子组件的单独构造(builder)和装配(director)\n* 构造子对象\n* 装配子对象\n\n\n### 代码实现\n```java\n// 创建一个表示食物条目和食物包装的接口。\npublic interface Item {\n   public String name();\n   public Packing packing();\n   public float price();    \n}\npublic interface Packing {\n   public String pack();\n}\n\n// 创建实现 Packing 接口的实体类。\npublic class Wrapper implements Packing {\n \n   @Override\n   public String pack() {\n      return \"Wrapper\";\n   }\n}\npublic class Bottle implements Packing {\n \n   @Override\n   public String pack() {\n      return \"Bottle\";\n   }\n}\n\n\n// 创建实现 Item 接口的抽象类，该类提供了默认的功能。\npublic abstract class Burger implements Item {\n \n   @Override\n   public Packing packing() {\n      return new Wrapper();\n   }\n \n   @Override\n   public abstract float price();\n}\npublic abstract class ColdDrink implements Item {\n \n    @Override\n    public Packing packing() {\n       return new Bottle();\n    }\n \n    @Override\n    public abstract float price();\n}\n\n// 创建扩展了 Burger 和 ColdDrink 的实体类。\npublic class VegBurger extends Burger {\n \n   @Override\n   public float price() {\n      return 25.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Veg Burger\";\n   }\n}\npublic class ChickenBurger extends Burger {\n \n   @Override\n   public float price() {\n      return 50.5f;\n   }\n \n   @Override\n   public String name() {\n      return \"Chicken Burger\";\n   }\n}\npublic class Coke extends ColdDrink {\n \n   @Override\n   public float price() {\n      return 30.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Coke\";\n   }\n}\npublic class Pepsi extends ColdDrink {\n \n   @Override\n   public float price() {\n      return 35.0f;\n   }\n \n   @Override\n   public String name() {\n      return \"Pepsi\";\n   }\n}\n\n// 创建一个 Meal 类，带有上面定义的 Item 对象。\nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Meal {\n   private List<Item> items = new ArrayList<Item>();    \n \n   public void addItem(Item item){\n      items.add(item);\n   }\n \n   public float getCost(){\n      float cost = 0.0f;\n      for (Item item : items) {\n         cost += item.price();\n      }        \n      return cost;\n   }\n \n   public void showItems(){\n      for (Item item : items) {\n         System.out.print(\"Item : \"+item.name());\n         System.out.print(\", Packing : \"+item.packing().pack());\n         System.out.println(\", Price : \"+item.price());\n      }        \n   }    \n}\n\n// 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。\npublic class MealBuilder {\n \n   public Meal prepareVegMeal (){\n      Meal meal = new Meal();\n      meal.addItem(new VegBurger());\n      meal.addItem(new Coke());\n      return meal;\n   }   \n \n   public Meal prepareNonVegMeal (){\n      Meal meal = new Meal();\n      meal.addItem(new ChickenBurger());\n      meal.addItem(new Pepsi());\n      return meal;\n   }\n}\n\n// BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。\npublic class BuilderPatternDemo {\n   public static void main(String[] args) {\n      MealBuilder mealBuilder = new MealBuilder();\n \n      Meal vegMeal = mealBuilder.prepareVegMeal();\n      System.out.println(\"Veg Meal\");\n      vegMeal.showItems();\n      System.out.println(\"Total Cost: \" +vegMeal.getCost());\n \n      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();\n      System.out.println(\"\\n\\nNon-Veg Meal\");\n      nonVegMeal.showItems();\n      System.out.println(\"Total Cost: \" +nonVegMeal.getCost());\n   }\n}\n```\n\n### 应用场景\n* 构建一个复杂的产品，比如生产一台手机，电脑是不是有多个组件，各个组件的装配是不是有步骤问题\n* 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的\"套餐\"。\n* `JAVA` 中的 `StringBuilder`。\n* `Spring`中`BeanDefinitionBuilder`\n    * BeanDefinitionBuilder\n    ```java\n    public class BeanDefinitionBuilder {\n           /**\n        * The {@code BeanDefinition} instance we are creating.\n        */\n      private AbstractBeanDefinition beanDefinition;\n    \n      // ... some not important methods for this article\n    \n      // Some of building methods\n      /**\n        * Set the name of the parent definition of this bean definition.\n        */\n      public BeanDefinitionBuilder setParentName(String parentName) {\n        this.beanDefinition.setParentName(parentName);\n        return this;\n      }\n    \n      /**\n        * Set the name of the factory method to use for this definition.\n        */\n      public BeanDefinitionBuilder setFactoryMethod(String factoryMethod) {\n        this.beanDefinition.setFactoryMethodName(factoryMethod);\n        return this;\n      }\n    \n      /**\n        * Add an indexed constructor arg value. The current index is tracked internally\n        * and all additions are at the present point.\n        * @deprecated since Spring 2.5, in favor of {@link #addConstructorArgValue}\n        */\n      @Deprecated\n      public BeanDefinitionBuilder addConstructorArg(Object value) {\n        return addConstructorArgValue(value);\n      }\n    \n      /**\n        * Add an indexed constructor arg value. The current index is tracked internally\n        * and all additions are at the present point.\n        */\n      public BeanDefinitionBuilder addConstructorArgValue(Object value) {\n        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(\n                        this.constructorArgIndex++, value);\n        return this;\n      }\n    \n      /**\n        * Add a reference to a named bean as a constructor arg.\n        * @see #addConstructorArgValue(Object)\n        */\n      public BeanDefinitionBuilder addConstructorArgReference(String beanName) {\n        this.beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(\n                        this.constructorArgIndex++, new RuntimeBeanReference(beanName));\n        return this;\n      }\n    \n      /**\n        * Add the supplied property value under the given name.\n        */\n      public BeanDefinitionBuilder addPropertyValue(String name, Object value) {\n        this.beanDefinition.getPropertyValues().add(name, value);\n        return this;\n      }\n    \n      /**\n        * Add a reference to the specified bean name under the property specified.\n        * @param name the name of the property to add the reference to\n        * @param beanName the name of the bean being referenced\n        */\n      public BeanDefinitionBuilder addPropertyReference(String name, String beanName) {\n        this.beanDefinition.getPropertyValues().add(name, new RuntimeBeanReference(beanName));\n        return this;\n      }\n    \n      /**\n        * Set the init method for this definition.\n        */\n      public BeanDefinitionBuilder setInitMethodName(String methodName) {\n        this.beanDefinition.setInitMethodName(methodName);\n        return this;\n      }\n    \n      // Methods that can be used to construct BeanDefinition\n      /**\n        * Return the current BeanDefinition object in its raw (unvalidated) form.\n        * @see #getBeanDefinition()\n        */\n      public AbstractBeanDefinition getRawBeanDefinition() {\n        return this.beanDefinition;\n      }\n    \n      /**\n        * Validate and return the created BeanDefinition object.\n        */\n      public AbstractBeanDefinition getBeanDefinition() {\n        this.beanDefinition.validate();\n        return this.beanDefinition;\n      }\n    }\n    ```","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(二)创建型模式-工厂模式","url":"/2018/07/21/backend/designPatterns/设计模式(二)创建型模式-工厂模式/","content":"### 核心本质\n* 实例化对象，用工厂方法代替new操作\n* 将选择实现类、创建对象统一管理和控制，从而将调用者跟我们的实现类解耦\n\n### 分类\n1. 简单工厂模式\n2. 工厂方法模式\n3. 抽象工厂模式\n\n\n#### 简单工厂模式\n要点：\n> 实际项目中使用最多\n\n> 简单工厂模式也叫静态工厂模式，就是工厂类一般使用的是静态方法，通过接受不同的参数的不同来返回不同的实例对象\n\n> 对于增加新产品无能为力，不修改代码的话是无法进行扩展的\n\n\n```java\npublic interface Car {\n\tvoid run();\n}\n\n\npublic class Audi implements Car {\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"奥迪再跑！\");\n\t}\n\n}\n\npublic class Byd implements Car {\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"比亚迪再跑！\");\n\t}\n\n}\n\n\npublic class CarFactory {\n\t\n\tpublic static  Car createCar(String type){\n\t\tif(\"奥迪\".equals(type)){\n\t\t\treturn new Audi();\n\t\t}else if(\"比亚迪\".equals(type)){\n\t\t\treturn new Byd();\n\t\t}else{\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n}\n\npublic class CarFactory2 {\n\t\n\tpublic static  Car createAudi(){\n\t\treturn new Audi();\n\t}\n\tpublic static  Car createByd(){\n\t\treturn new Byd();\n\t}\n\t\n}\n```\n\n#### 工厂方法模式\n要点：\n> 简单工厂模式只有一个工厂类，而工厂方法模式有一组实现了相同接口的工厂类，方便扩展\n```java\npublic interface Car {\n\tvoid run();\n}\n\npublic interface CarFactory {\n\tCar createCar();\n}\n\n\npublic class Audi implements Car {\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"奥迪再跑！\");\n\t}\n}\n\npublic class AudiFactory implements CarFactory {\n\n\t@Override\n\tpublic Car createCar() {\n\t\treturn new Audi();\n\t}\n\n}\n\npublic class Benz implements Car {\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"奔驰再跑！\");\n\t}\n\n}\n\npublic class BenzFactory implements CarFactory {\n\n\t@Override\n\tpublic Car createCar() {\n\t\treturn new Benz();\n\t}\n\n}\n\npublic class Byd implements Car {\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"比亚迪再跑！\");\n\t}\n\n}\n\npublic class BydFactory implements CarFactory {\n\n\t@Override\n\tpublic Car createCar() {\n\t\treturn new Byd();\n\t}\n\n}\n\npublic class Client {\n\tpublic static void main(String[] args) {\n\t\tCar c1 = new AudiFactory().createCar();\n\t\tCar c2 = new BydFactory().createCar();\n\t\t\n\t\tc1.run();\n\t\tc2.run();\n\t}\n}\n```\n#### 抽象工厂模式\n* 用来生产不同产品族的全部产品。但对于增加新的产品无能为力，支持增加产品族\n\n* 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种，业务分类时，使用抽象工厂模式产生需要对象是一种非常好的解决方式\n\n##### 例子一\n\n```java\n// 引擎接口\npublic interface Engine {\n\tvoid run();\n\tvoid start();\n}\n// 好引擎\nclass LuxuryEngine implements Engine{\n\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"转的快！\");\n\t}\n\n\t@Override\n\tpublic void start() {\n\t\tSystem.out.println(\"启动快!可以自动启停！\");\n\t}\n\t\n}\n// 差引擎\nclass LowEngine implements Engine{\n\t\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(\"转的慢！\");\n\t}\n\t\n\t@Override\n\tpublic void start() {\n\t\tSystem.out.println(\"启动慢!\");\n\t}\n\t\n}\n\n// 座椅接口类\npublic interface Seat {\n\tvoid massage();\n}\n// 可以按摩的接口\nclass LuxurySeat implements Seat {\n\n\t@Override\n\tpublic void massage() {\n\t\tSystem.out.println(\"可以自动按摩！\");\n\t}\n\t\n}\n// 不能按摩的接口\nclass LowSeat implements Seat {\n\n\t@Override\n\tpublic void massage() {\n\t\tSystem.out.println(\"不能按摩！\");\n\t}\n\t\n}\n\n// 轮胎\npublic interface Tyre {\n\tvoid revolve();\n}\n\n// 好轮胎\nclass LuxuryTyre implements Tyre {\n\n\t@Override\n\tpublic void revolve() {\n\t\tSystem.out.println(\"旋转不磨损！\");\n\t}\n\t\n}\n// 差轮胎\nclass LowTyre implements Tyre {\n\n\t@Override\n\tpublic void revolve() {\n\t\tSystem.out.println(\"旋转磨损快！\");\n\t}\n\t\n}\n\n// 抽象工厂接口\npublic interface CarFactory {\n\tEngine createEngine();\n\tSeat createSeat();\n\tTyre createTyre();\n}\n// 抽象工厂实现类（奢饰汽车）\npublic class LuxuryCarFactory implements CarFactory {\n\n\t@Override\n\tpublic Engine createEngine() {\n\t\treturn new LuxuryEngine();\n\t}\n\n\t@Override\n\tpublic Seat createSeat() {\n\t\treturn new LuxurySeat();\n\t}\n\n\t@Override\n\tpublic Tyre createTyre() {\n\t\treturn new LuxuryTyre();\n\t}\n}\n\n// 抽象工厂实现类（普通汽车）\npublic class LowCarFactory implements CarFactory {\n\n\t@Override\n\tpublic Engine createEngine() {\n\t\treturn new LowEngine();\n\t}\n\n\t@Override\n\tpublic Seat createSeat() {\n\t\treturn new LowSeat();\n\t}\n\n\t@Override\n\tpublic Tyre createTyre() {\n\t\treturn new LowTyre();\n\t}\n}\n\npublic static void main(String[] args) {\n\tCarFactory  factory = new LuxuryCarFactory();\n\tEngine e = factory.createEngine();\n\te.run();\n\te.start();\t\n}\n```\n\n### 应用场景\n* `JDK`中`Calendar`的`getInstance`方法\n* `JDBC`中`Connection`对象的获取\n* `Spring`中的`BeanFactory`就是简单工厂模式的体现，根据传入一个唯一的标识来获得`Bean`对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定\n* `Spring`中的`FactoryBean`就是典型的工厂方法模式\n* 数据库连接池\n* 项目中读取配置文件的类\n\n\n### 总结","tags":["设计模式"],"categories":["server"]},{"title":"设计模式(一)创建型模式-单例模式","url":"/2018/07/21/backend/designPatterns/设计模式(一)创建型模式-单例模式/","content":"> 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n设计模式是一种思想、思维，将设计模式运用到工作实践中可以解决许多问题，也可以使项目变得更加健壮，更加可扩展性\n### 核心作用\n保证一个类只有一个实例，并且提供一个访问该实例的全局访问点\n\n### 单例模式的优点\n只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决\n\n常见的五种单例模式实现方式\n\n主要：\n* 饿汉式\n* 懒汉式\n\n其他\n* 双重检测锁式\n* 静态内部类式\n* 枚举单例\n\n#### 饿汉式\n> （线程安全，调用效率高，但是不能延时加载）\n```java\npackage com.pattern.singleton;\n\n/**\n * 饿汉式单例模式\n */\npublic class SingletonDemo1 {\n\t/**\n\t * 类初始化时，立即加载这个static对象（没有延时加载的优势）\n\t * 不会涉及多个线程对象访问该对象的问题，Java虚拟机只会装载一次该类\n\t */\n\tprivate static SingletonDemo1 instance = new SingletonDemo1();\n\t\n\t/**\n\t * 私有构造函数\n\t */\n\tprivate SingletonDemo1(){\n\t}\n\t\n\t/**\n\t * 方法没有同步，调用效率高！\n\t * @return\n\t */\n\tpublic static SingletonDemo1  getInstance(){\n\t\treturn instance;\n\t}\n}\n\n```\n#### 懒汉式\n>（线程安全，调用效率不高，但是可以延时加载）\n```java\npackage com.pattern.singleton;\n\n/**\n * 懒汉式单例模式\n *\n */\npublic class SingletonDemo2 {\n\n\t/**\n\t * 类初始化时，不初始化这个对象（延时加载，真正用的时候再创建）资源利用率高了。\n\t */\n\tprivate static SingletonDemo2 instance;\n\n\t/**\n\t * 私有化构造器\n\t */\n\tprivate SingletonDemo2(){\n\t}\n\n\t/**\n\t * 方法同步，调用效率低！\n\t * @return\n\t */\n\tpublic static  synchronized SingletonDemo2  getInstance(){\n\t\tif(instance==null){\n\t\t\tinstance = new SingletonDemo2();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n}\n```\n\n#### 双重检测锁式\n> （由于JVM底层内部模型原因，偶尔会出问题，不建议使用）\n```java\npackage com.pattern.singleton;\n\n/**\n * 双重检查锁实现单例模式\n */\npublic class SingletonDemo3 { \n\n  private static SingletonDemo3 instance = null; \n  // 将同步内容下方到if内部，提高了执行的效率，不用每次获取对象都进行同步，只有第一次才同步创建了以后就没必要了\n  public static SingletonDemo3 getInstance() { \n    if (instance == null) { \n      SingletonDemo3 sc; \n      synchronized (SingletonDemo3.class) { \n        sc = instance; \n        if (sc == null) { \n          synchronized (SingletonDemo3.class) { \n            if(sc == null) { \n              sc = new SingletonDemo3(); \n            } \n          } \n          instance = sc; \n        } \n      } \n    } \n    return instance; \n  } \n\n  private SingletonDemo3() { \n\n  } \n    \n}\n\n\n```\n#### 静态内部类式\n> （线程安全，调用效率高，可以延时加载）\n```java\npackage com.pattern.singleton;\n\n/**\n * 测试静态内部类实现单例模式\n * 这种方式：线程安全，调用效率高，并且实现了延时加载！\n */\npublic class SingletonDemo4 {\n\t\n\tprivate static class SingletonClassInstance {\n\t\tprivate static final SingletonDemo4 instance = new SingletonDemo4();\n\t}\n\t\n\tprivate SingletonDemo4(){\n\t}\n\n\t/**\n\t * 只有真正调用getInstance() 才会加载静态内部类，加载类时是线程安全的\n\t * 方法没有同步，调用效率高，兼备了并发和延时加载的优势\n\t * @return\n\t */\n\tpublic static SingletonDemo4  getInstance(){\n\t\treturn SingletonClassInstance.instance;\n\t}\n\t\n}\n\n```\n#### 枚举单例\n> （线程安全，调用效率高，不能延时加载）\n```java\npackage com.pattern.singleton;\n\n/**\n * 测试枚举式实现单例模式(没有延时加载)\n *\n */\npublic enum SingletonDemo5 {\n\t\n\t//这个枚举元素，本身就是单例对象！\n\tINSTANCE;\n\t\n\t//添加自己需要的操作！\n\tpublic void singletonOperation(){\n\t}\n}\n\n```\n\n### 常用应用场景\n* `Spring`中的`Bean`\n    * Spring框架对单例的支持不是采用上面的这些方式，而是采用单例注册表的方式进行实现的\n        ```java\n        /** Cache of singleton objects created by FactoryBeans: FactoryBean name --> object */\n        private final Map<String, Object> factoryBeanObjectCache = new ConcurrentHashMap<String, Object>(16);\n        ```\n* `Servlet`，每个`Servlet`也是单例\n* `windows` 的任务管理器\n* 数据库连接池\n* 项目中读取配置文件的类\n\n\n### 总结\n一般建议使用饿汉式，只有在要明确实现 lazy loading 效果时，则使用静态内部类式，如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。","tags":["设计模式"],"categories":["server"]},{"title":"基于 CentOS 搭建 Jenkins 自动化部署服务","url":"/2018/07/20/backend/server/centos/基于 CentOS 搭建 Jenkins服务/","content":"> 需求： 使用 Jenkins 完成 git + Maven项目 + Tomcat 自动化部署\n\n### 一： 环境准备\n\n#### 1. Jenkins环境准备\n\n##### 1.1 安装 jenkins-2.7.3\n```sql\n wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpm\n\n rpm -ivh jenkins-2.7.3-1.1.noarch.rpm\n```\n##### 1.2 配置启动\n```sql\n 1. 修改配置文件，默认端口为8080，如果不冲突则不需要修改      \n vim /etc/sysconfig/jenkins\n        JENKINS_PORT=\"9080\"\n \n 2. 配置JDK,启动服务如果报Java路径错误, 需要到vim /etc/profile 查看java路径\n \n        修改Jenkins启动配置文件，指定java安装路径。\n        /usr/local/jdk1.8.0_181/bin/java\n        \n        vim /etc/init.d/jenkins\n        在candidates中第一行添加java路径，如下：\n        candidates=\"\n        /usr/local/jdk1.8.0_181/bin/java\n        /etc/alternatives/java\n        /usr/lib/jvm/java-1.6.0/bin/java\n        /usr/lib/jvm/jre-1.6.0/bin/java\n        /usr/lib/jvm/java-1.7.0/bin/java\n        /usr/lib/jvm/jre-1.7.0/bin/java\n        /usr/lib/jvm/java-1.8.0/bin/java\n        /usr/lib/jvm/jre-1.8.0/bin/java\n        /usr/bin/java\n        \"                    \n \n 3. 修改jenkins用户 为\"root\"用户\n \n 4. 启动jenkins服务\n service jenkins restart\n\n 5. 启动完成之后即可通过ip 端口进行访问\n```\n![logo](/images/server/java/jenkins/jenkins1.png) \n\n#### 2. Git 环境准备\n```sql\n安装git\n[root@iZwz9fjhnq78zfjphj8hi4Z bin]# yum –y install git\n\n\n查看是否安装成功\n[root@iZwz9fjhnq78zfjphj8hi4Z bin]# git --version\ngit version 1.8.3.1\n```\n\n#### 3. Maven 环境准备\n##### 3.1 安装\n```sql\ncd /usr/local\n\nwget http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz\n\ntar zxf apache-maven-3.5.4-bin.tar.gz\n\nmv apache-maven-3.5.4 /usr/local/maven-3.5.4\n```\n##### 3.2 配置环境变量\n```sql\nvi /etc/profile然后还需要 配置环境变量。\n\n#在适当的位置添加\nexport M2_HOME=/usr/local/maven-3.5.4\nexport PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/bin\n\n保存退出后运行下面的命令使配置生效，或者重启服务器生效。\nsource /etc/profile\n\n验证版本\nmvn -v\n```\n##### 3.3 更换库源 阿里maven库\n```sql\n（1）找到 apache-maven-3.5.2\\conf 目录中的 settings.xml 文件\n（2）修改maven 本地仓库地址,\n       首先在D:\\Program Files创建文件夹MavenRepository ；\n       找到settings.xml 文件中  <localRepository> </localRepository>打开注释修改如下：\n    <localRepository>D:\\Program Files\\MavenRepository</localRepository>\n（3）添加阿里源 ，找到  <mirrors>  </ mirrors>标签，在标签内部 添加内容如下：\n    <mirror>\n      <id>AliMaven</id>\n      <name>aliyun maven</name>\n      <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n      <mirrorOf>central</mirrorOf>        \n    </mirror>\n\n```\n\n#### 4. 使用Jenkins\n##### 4.1 配置工具环境配置\n\n上面的环境都准备好了之后，先配置一下 参数(系统管理-> 全局工具配置) git不用配置使用默认\n\n![logo](/images/server/java/jenkins/jenkins-git.png) \n\n![logo](/images/server/java/jenkins/jenkins-jdk.png) \n\n![logo](/images/server/java/jenkins/jenkins-maven.png) \n\n##### 4.2 创建一个任务 \n\n1.点击创建任务，如果在创建项目时候，没有“创建一个Maven 项目”的选项。你需要安装Maven项目插件：Maven Integration plugin 。\n\n![logo](/images/server/java/jenkins/jenkins-mavenc.png) \n\n2.配置源码管理，jenkins会自动拉取代码放到`/var/lib/jenkins/workspace/任务名` 路径下\n\n![logo](/images/server/java/jenkins/jenkins-gitee.png) \n\n3.配置Maven构建，构建完后会自动打包\n\n![logo](/images/server/java/jenkins/jenkins-mavenbuild.png)\n\n4.编写shell脚本，maven构建完成之后就是把打好的包放在tomcat下了并启动\n\n```bash\n#!/bin/bash\n#引入了系统环境变量，这样系统环境变量里面没有export声明的也可以用\nsource /etc/profile\n\ntomcat_home=/usr/local/tomcat-8.0.48\nSHUTDOWN=$tomcat_home/bin/shutdown.sh\nSTARTTOMCAT=$tomcat_home/bin/startup.sh\n\necho \"停止tomcat服务 /usr/local/tomcat8.0.48/bin/shutdown.sh\"\n#/usr/local/tomcat8.0.48/bin/shutdown.sh\n\necho \"关闭$tomcat_home\"\n$SHUTDOWN\npidlist=`ps -ef |grep tomcat  |grep -v \"grep\"|awk '{print $2}'`\nkill -9 $pidlist\n\n\necho \"开始删除文件夹 usr/local/tomcat8.0.48/webapps/blogsys-parent\"\nrm -rf $tomcat_home/webapps/blogsys-parent\n\necho \"开始删除文件 /usr/local/tomcat8.0.48/webapps/blogsys-parent.war\"\nrm -rf $tomcat_home/webapps/blogsys-parent.war\n\necho \"开始拷贝文件 blogsys-parent.war 拷贝文件目录：/var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target >> /usr/local/tomcat8.0.48/webapps\"\n\ncp -ar /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target/blogsys-parent.war $tomcat_home/webapps/blogsys-parent.war\n\necho \"查找文件\"\nfind $tomcat_home/webapps/ -name  blogsys-parent.war\n\n\necho \"启动$tomcat_home\"\n$STARTTOMCAT\n\necho \"延时5秒\"\nsleep 5\n\necho \"关闭$tomcat_home\"\n$SHUTDOWN\npidlist=`ps -ef |grep tomcat  |grep -v \"grep\"|awk '{print $2}'`\nkill -9 $pidlist\n\necho \"延时5秒重新启动\"\nsleep 5\n\n# 脚本中功能是复制替换某两个配置文件，然后关闭tomcat，重启Tomcat。但是，Tomcat只是启动了一下，就关闭了，并没有启动Tomcat的进程。在网上查了资料，需要在执行脚本之前加入：export BUILD_ID=XXXXXX\nexport BUILD_ID=dontKillMe\necho \"启动$tomcat_home\"\n$STARTTOMCAT\n\n\necho \"延时10秒\"\nsleep 10\n\necho \"打印日志开始-》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》\"\ntail -2000 ${tomcat_home}/logs/catalina.out\n``` \n##### 启动任务\n可以看到日志输出\n```bash\nStarted by user songshuiyang\nBuilding in workspace /var/lib/jenkins/workspace/blogsys-parent\n > git rev-parse --is-inside-work-tree # timeout=10\nFetching changes from the remote Git repository\n > git config remote.origin.url https://gitee.com/songshuiyang/blogsys-parent.git # timeout=10\nFetching upstream changes from https://gitee.com/songshuiyang/blogsys-parent.git\n > git --version # timeout=10\nusing GIT_ASKPASS to set credentials 码云账号\n > git fetch --tags --progress https://gitee.com/songshuiyang/blogsys-parent.git +refs/heads/*:refs/remotes/origin/*\n > git rev-parse refs/remotes/origin/master^{commit} # timeout=10\n > git rev-parse refs/remotes/origin/origin/master^{commit} # timeout=10\nChecking out Revision 926c54ff215417d928b32201b50e2c2cb40b6ba8 (refs/remotes/origin/master)\n > git config core.sparsecheckout # timeout=10\n > git checkout -f 926c54ff215417d928b32201b50e2c2cb40b6ba8\nCommit message: \"优化 修复pom问题\"\n > git rev-list --no-walk 926c54ff215417d928b32201b50e2c2cb40b6ba8 # timeout=10\nParsing POMs\nEstablished TCP socket on 40447\n[blogsys-parent] $ /usr/local/jdk1.8.0_181/bin/java -cp /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven35-agent-1.12-alpha-1.jar:/usr/local/maven-3.5.4/boot/plexus-classworlds-2.5.2.jar:/usr/local/maven-3.5.4/conf/logging jenkins.maven3.agent.Maven35Main /usr/local/maven-3.5.4 /var/cache/jenkins/war/WEB-INF/lib/remoting-3.23.jar /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven35-interceptor-1.12-alpha-1.jar /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven3-interceptor-commons-1.12-alpha-1.jar 40447\n<===[JENKINS REMOTING CAPACITY]===>channel started\nExecuting Maven:  -B -f /var/lib/jenkins/workspace/blogsys-parent/pom.xml clean install -Dmaven.test.skip=true\n[INFO] Scanning for projects...\n[WARNING] \n[WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-admin:war:0.0.1-SNAPSHOT\n[WARNING] 'dependencies.dependency.systemPath' for json:json:jar should not point at files within the project directory, ${project.basedir}/src/main/webapp/WEB-INF/lib/json.jar will be unresolvable by dependent projects @ line 25, column 19\n[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: com.fasterxml.jackson.core:jackson-databind:jar -> version ${jackson-databind.version} vs 2.7.4 @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 244, column 21\n[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 383, column 21\n[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 407, column 21\n[WARNING] \n[WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-core:jar:0.0.1-SNAPSHOT\n[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 383, column 21\n[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 407, column 21\n[WARNING] \n[WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-parent:pom:0.0.1-SNAPSHOT\n[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: com.fasterxml.jackson.core:jackson-databind:jar -> version ${jackson-databind.version} vs 2.7.4 @ line 244, column 21\n[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ line 383, column 21\n[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ line 407, column 21\n[WARNING] \n[WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.\n[WARNING] \n[WARNING] For this reason, future Maven versions might no longer support building such malformed projects.\n[WARNING] \n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Build Order:\n[INFO] \n[INFO] blogsys-parent                                                     [pom]\n[INFO] blogsys-admin                                                      [war]\n[INFO] blogsys-core                                                       [jar]\n[INFO] \n[INFO] ----------------------< com.ecut:blogsys-parent >-----------------------\n[INFO] Building blogsys-parent 0.0.1-SNAPSHOT                             [1/3]\n[INFO] --------------------------------[ pom ]---------------------------------\n[INFO] \n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ blogsys-parent ---\n[INFO] \n[INFO] --- maven-install-plugin:2.4:install (default-install) @ blogsys-parent ---\n[INFO] Installing /var/lib/jenkins/workspace/blogsys-parent/pom.xml to /root/.m2/repository/com/ecut/blogsys-parent/0.0.1-SNAPSHOT/blogsys-parent-0.0.1-SNAPSHOT.pom\n[WARNING] Attempt to (de-)serialize anonymous class hudson.maven.reporters.MavenArtifactArchiver$2; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/\n[WARNING] Attempt to (de-)serialize anonymous class hudson.maven.reporters.MavenFingerprinter$1; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/\n[INFO] \n[INFO] -----------------------< com.ecut:blogsys-admin >-----------------------\n[INFO] Building blogsys-admin 0.0.1-SNAPSHOT                              [2/3]\n[INFO] --------------------------------[ war ]---------------------------------\n[INFO] \n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ blogsys-admin ---\n[INFO] Deleting /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ blogsys-admin ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] Copying 32 resources\n[INFO] \n[INFO] --- maven-compiler-plugin:2.3.2:compile (default-compile) @ blogsys-admin ---\n[INFO] Compiling 164 source files to /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target/classes\n[WARNING] /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/src/main/java/com/ecut/core/shiro/SecurityUtils.java:[8,15] BASE64Encoder is internal proprietary API and may be removed in a future release\n[WARNING] /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/src/main/java/com/ecut/core/utils/elven/encryption/DesEncryptUtils.java:[8,15] BASE64Decoder is internal proprietary API and may be removed in a future release\n\n.....\n\n```\n\n","tags":["jenkins"],"categories":["server"]},{"title":"Java集合-HashSet","url":"/2018/07/08/backend/java/collection/Java集合-HashSet/","content":"#### HashSet源码：\n```java\n  public class HashSet<E>  \n      extends AbstractSet<E>  \n      implements Set<E>, Cloneable, java.io.Serializable  \n  {  \n      static final long serialVersionUID = -5024744406713321676L;  \n    \n      // 底层使用HashMap来保存HashSet中所有元素。  \n      private transient HashMap<E,Object> map;  \n        \n      // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  \n      private static final Object PRESENT = new Object();  \n    \n      /** \n       * 默认的无参构造器，构造一个空的HashSet。 \n       *  \n       * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 \n       */  \n      public HashSet() {  \n        map = new HashMap<E,Object>();  \n      }  \n    \n      /** \n       * 构造一个包含指定collection中的元素的新set。 \n       * \n       * 实际底层使用默认的加载因子0.75和足以包含指定 \n       * collection中所有元素的初始容量来创建一个HashMap。 \n       * @param c 其中的元素将存放在此set中的collection。 \n       */  \n      public HashSet(Collection<? extends E> c) {  \n        map = new HashMap<E,Object>(Math.max((int) (c.size()/.75f) + 1, 16));  \n        addAll(c);  \n      }  \n    \n      /** \n       * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 \n       * \n       * 实际底层以相应的参数构造一个空的HashMap。 \n       * @param initialCapacity 初始容量。 \n       * @param loadFactor 加载因子。 \n       */  \n      public HashSet(int initialCapacity, float loadFactor) {  \n        map = new HashMap<E,Object>(initialCapacity, loadFactor);  \n      }  \n    \n      /** \n       * 以指定的initialCapacity构造一个空的HashSet。 \n       * \n       * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 \n       * @param initialCapacity 初始容量。 \n       */  \n      public HashSet(int initialCapacity) {  \n        map = new HashMap<E,Object>(initialCapacity);  \n      }  \n    \n      /** \n       * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 \n       * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 \n       * \n       * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 \n       * @param initialCapacity 初始容量。 \n       * @param loadFactor 加载因子。 \n       * @param dummy 标记。 \n       */  \n      HashSet(int initialCapacity, float loadFactor, boolean dummy) {  \n        map = new LinkedHashMap<E,Object>(initialCapacity, loadFactor);  \n      }  \n    \n      /** \n       * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 \n       *  \n       * 底层实际调用底层HashMap的keySet来返回所有的key。 \n       * 可见HashSet中的元素，只是存放在了底层HashMap的key上， \n       * value使用一个static final的Object对象标识。 \n       * @return 对此set中元素进行迭代的Iterator。 \n       */  \n      public Iterator<E> iterator() {  \n        return map.keySet().iterator();  \n      }  \n    \n      /** \n       * 返回此set中的元素的数量（set的容量）。 \n       * \n       * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 \n       * @return 此set中的元素的数量（set的容量）。 \n       */  \n      public int size() {  \n        return map.size();  \n      }  \n    \n      /** \n       * 如果此set不包含任何元素，则返回true。 \n       * \n       * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 \n       * @return 如果此set不包含任何元素，则返回true。 \n       */  \n      public boolean isEmpty() {  \n        return map.isEmpty();  \n      }  \n    \n      /** \n       * 如果此set包含指定元素，则返回true。 \n       * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) \n       * 的e元素时，返回true。 \n       * \n       * 底层实际调用HashMap的containsKey判断是否包含指定key。 \n       * @param o 在此set中的存在已得到测试的元素。 \n       * @return 如果此set包含指定元素，则返回true。 \n       */  \n      public boolean contains(Object o) {  \n        return map.containsKey(o);  \n      }  \n    \n      /** \n       * 如果此set中尚未包含指定元素，则添加指定元素。 \n       * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) \n       * 的元素e2，则向此set 添加指定的元素e。 \n       * 如果此set已包含该元素，则该调用不更改set并返回false。 \n       * \n       * 底层实际将将该元素作为key放入HashMap。 \n       * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key \n       * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， \n       * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， \n       * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， \n       * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 \n       * @param e 将添加到此set中的元素。 \n       * @return 如果此set尚未包含指定元素，则返回true。 \n       */  \n      public boolean add(E e) {  \n        return map.put(e, PRESENT)==null;  \n      }  \n    \n      /** \n       * 如果指定元素存在于此set中，则将其移除。 \n       * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， \n       * 则将其移除。如果此set已包含该元素，则返回true \n       * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 \n       * \n       * 底层实际调用HashMap的remove方法删除指定Entry。 \n       * @param o 如果存在于此set中则需要将其移除的对象。 \n       * @return 如果set包含指定元素，则返回true。 \n       */  \n      public boolean remove(Object o) {  \n        return map.remove(o)==PRESENT;  \n      }  \n    \n      /** \n       * 从此set中移除所有元素。此调用返回后，该set将为空。 \n       * \n       * 底层实际调用HashMap的clear方法清空Entry中所有元素。 \n       */  \n      public void clear() {  \n        map.clear();  \n      }  \n    \n      /** \n       * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 \n       * \n\n```\n#### HashSet保证元素不重复\nHashSet使用HashMap进行存放数据\n```java\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n```\n\nputVal方法\n```java\n    /**\n     * Implements Map.put and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @param value the value to put\n     * @param onlyIfAbsent if true, don't change existing value\n     * @param evict if false, the table is in creation mode.\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length; // 重新计算一下大小\n        // 获取要插入元素在 哈希桶中的位置\n        if ((p = tab[i = (n - 1) & hash]) == null) // 如果这个位置没有Node\n            tab[i] = newNode(hash, key, value, null); // 直接创建一个新的Node\n        else { // 说明此时在对应的索引位置已经有对象了\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p; // 判断原对象与插入的对象的key是否一样\n            else if (p instanceof TreeNode) // 如果 你定位到的元素是一个TreeNode(Node的一个子类，也是HashMap的一个内部类)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 那么就插入一TreeNode节点 定位到这个hash桶了 但是这里面是链表（没有进行过树化）\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { //说明原对象与插入的对象的key相同\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value; //将新插入的entry的value覆盖掉原来的entry的value\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount; // 修改次数+1 和fastRemove()有关也和并发修改有关\n        if (++size > threshold) // 如果大于了阙值 需要扩容的大小\n            resize(); // 重新设置hash桶的大小，也有可能进行树化，见后面代码\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n\n\n","tags":["Java"],"categories":["server"]},{"title":"Java集合-HashMap","url":"/2018/06/07/backend/java/collection/Java集合-HashMap/","content":"### 什么是HashMap\nHashMap分为俩个词理解，一个是Hash，另一个是Map\n\nHash: 散列将一个任意长度通过某种hash函数算法转化成一个固定的值\n\nMap：可以理解为地图点的位置\n\n我们如果想要找到地图上的某个点，就需要通过经纬度来定位，Hash就是这个值，我们可以通过这个值，找到我们所要的位置\n\n### HashMap 简介\nHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。\n\nHashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。\n\nHashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。\n\nHashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。\n通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。\n\n### HashMap源码笔记\n\n#### HashMap 常量定义\n```sql\n    /**\n     * The default initial capacity - MUST be a power of two.\n     * 默认初始容量，为16个\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n    /**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     * 最大容量： 1073741824\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n    /**\n     * The load factor used when none specified in constructor.\n     * 加载因子，当容量达到3/4的时候进行容量扩容, 不是满的时候再扩容\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    /**\n     * The bin count threshold for using a tree rather than list for a\n     * bin.  Bins are converted to trees when adding an element to a\n     * bin with at least this many nodes. The value must be greater\n     * than 2 and should be at least 8 to mesh with assumptions in\n     * tree removal about conversion back to plain bins upon\n     * shrinkage.\n     * .由链表转换成树的阈值TREEIFY_THRESHOLD 一个桶中bin（箱子）的存储方式由链表转换成树的阈值。即当桶中bin的数量超过TREEIFY_THRESHOLD时使用树来代替链表。默认值是8\n     */\n     static final int TREEIFY_THRESHOLD = 8;\n     /**\n     * The bin count threshold for untreeifying a (split) bin during a\n     * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n     * most 6 to mesh with shrinkage detection under removal.\n     * 当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 \n     */\n     static final int UNTREEIFY_THRESHOLD = 6;\n    \n    /**\n     * The smallest table capacity for which bins may be treeified.\n     * (Otherwise the table is resized if too many nodes in a bin.)\n     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts\n     * between resizing and treeification thresholds.\n     * 当桶中的bin被树化时最小的hash表容量。（如果没有达到这个阈值，即hash表容量小于MIN_TREEIFY_CAPACITY，当桶中bin的数量太多时会执行resize扩容操作）这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。\n     */\n    static final int MIN_TREEIFY_CAPACITY = 64;\n\n```\n\n#### putVal方法\n```java\n    /**\n     * Implements Map.put and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @param value the value to put\n     * @param onlyIfAbsent if true, don't change existing value\n     * @param evict if false, the table is in creation mode.\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length; // 重新计算一下大小\n        // 获取要插入元素在 哈希桶中的位置\n        if ((p = tab[i = (n - 1) & hash]) == null) // 如果这个位置没有Node\n            tab[i] = newNode(hash, key, value, null); // 直接创建一个新的Node\n        else { // 说明此时在对应的索引位置已经有对象了\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p; // 判断原对象与插入的对象的key是否一样\n            else if (p instanceof TreeNode) // 如果 你定位到的元素是一个TreeNode(Node的一个子类，也是HashMap的一个内部类)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 那么就插入一TreeNode节点 定位到这个hash桶了 但是这里面是链表（没有进行过树化）\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { //说明原对象与插入的对象的key相同\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value; //将新插入的entry的value覆盖掉原来的entry的value\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount; // 修改次数+1 和fastRemove()有关也和并发修改有关\n        if (++size > threshold) // 如果大于了阙值 需要扩容的大小\n            resize(); // 重新设置hash桶的大小，也有可能进行树化，见后面代码\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n### Java中的hashCode和equals\n\n#### 关于hashCode\n1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的\n2. 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同\n3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点\n4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里“\n\n再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。\n\n以下对hashCode的解读摘自其他博客：\n```sql\n1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有\n例如内存中有这样的位置\n0  1  2  3  4  5  6  7 \n而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。\n但如果用hashcode那就会使效率提高很多。\n我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。\n2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。\n也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。\n那么。重写了equals()，为什么还要重写hashCode()呢？\n想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊\n```\n#### 关于equals\nequals和==\n\n==用于比较引用和比较基本数据类型时具有不同的功能：\n比较基本数据类型，如果两个值相同，则结果为true\n而在比较引用时，如果引用指向内存中的同一对象，结果为true;\n\nequals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。\n### HashMap的实现原理\n#### HashMap概述\nHashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。\n在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n![logo](/images/server/java/集合/hashmap.jpg) \n\n从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。\n\n![logo](/images/server/java/集合/hashmap2.png) \n\n其中Java源码如下：\n```java\n\n/**\n * The table, resized as necessary. Length MUST Always be a power of two.\n */\ntransient Entry[] table;\n\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n    final K key;\n    V value;\n    Entry<K,V> next;\n    final int hash;\n    ……\n}\n```\n\n可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。\n\n#### HashMap实现存储和读取\n\n##### 存储\n```java\npublic V put(K key, V value) {\n    // HashMap允许存放null键和null值。\n    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。\n    if (key == null)\n        return putForNullKey(value);\n    // 根据key的keyCode重新计算hash值。\n    int hash = hash(key.hashCode());\n    // 搜索指定hash值在对应table中的索引。\n    int i = indexFor(hash, table.length);\n    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。\n    for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n            // 如果发现已有该键值，则存储新的值，并返回原始值\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    // 如果i索引处的Entry为null，表明此处还没有Entry。\n    modCount++;\n    // 将key、value添加到i索引处。\n    addEntry(hash, key, value, i);\n    return null;\n}\n```\n\n根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。\n\nhash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。\n```sql\nstatic int hash(int h) {\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n```\n\n我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。\n\n根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。\n\n通过这种方式就可以高效的解决HashMap的冲突问题。\n\n##### 读取\n```java\npublic V get(Object key) {\n    if (key == null)\n        return getForNullKey();\n    int hash = hash(key.hashCode());\n    for (Entry<K,V> e = table[indexFor(hash, table.length)];\n        e != null;\n        e = e.next) {\n        Object k;\n        if (e.hash == hash && ((k = e.key) == key || key.equals(k)))\n            return e.value;\n    }\n    return null;\n}\n```\n从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。\n\n归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。\n\n#### HashMap的resize\n\n当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。\n\n那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16*0.75=12的时候，就把数组的大小扩展为2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75*1000 < 1000, 也就是说为了让0.75 * size > 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&的问题，也避免了resize的问题。\n\n#### 总结\n1. 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标\n2. 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中\n3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。\n4. 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。\n\n\n转载参考：http://www.cnblogs.com/yuanblog/p/4441017.html","tags":["Java"],"categories":["server"]},{"title":"Nginx 笔记","url":"/2018/06/05/backend/server/centos/Nginx 笔记/","content":"### 一. 为什么使用Nginx\nNginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:\n\n1. 作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.\n\n2. 作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。\n\n3. 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。\n\n4. Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。\n基础功能\n\n### 二. 基础功能\n1. 处理静态文件，索引文件以及自动索引；\n\n2. 反向代理加速(无缓存)，简单的负载均衡和容错；\n\n3. FastCGI，简单的负载均衡和容错；\n\n4. 模块化的结构。过滤器包括gzipping, byte ranges, chunked responses, 以及 SSI-filter 。在SSI过滤器中，到同一个 proxy 或者 FastCGI 的多个子请求并发处理；\nSSL 和 TLS SNI 支持；\n","tags":["nginx"],"categories":["server"]},{"title":"基于 CentOS 搭建 Nginx 服务","url":"/2018/06/05/backend/server/centos/基于 CentOS 搭建 Nginx服务/","content":"### 1.安装使用Nginx\n#### 1.1 yum安装\n```sql\nyum install nginx\n```\n\n#### 1.2 提供目录权限\n```sql\n提供目录权限:\n　　我需要访问的目录是 /var/ftp, 用户是root, 所以修改如下配置:\n[root@S205 conf.d]# cat /etc/nginx/nginx.conf |grep user\nuser root;\n\n否则会出现这样的错误:\n[root@S205 conf.d]# tail /var/log/nginx/error.log \n2017/10/13 16:51:09 [error] 13383#0: *1 open() \"/home/data\" failed (13: Permission denied), client: 192.168.50.20, server: _, request: \"GET /data HTTP/1.1\", host: \"192.168.10.205:8080\"\n```\n<!-- more -->\n### 2.Nginx 命令\n#### 2.1 启动重启\n```sql\n\n[root@S205 conf.d]# systemctl enable nginx\n\n[root@S205 conf.d]# systemctl restart nginx\n\n[root@S205 conf.d]# vi /etc/nginx/nginx.conf\n```\n#### 2.2 \n\n### 3.Nginx 启用对文件目录的http访问\n解决以ftp路径形式的图片，在谷歌浏览器上不能正常访问的问题，所以使用http的形式访问文件\n\n#### 3.1 配置如下：\n采用： http://ip/uploadfile/文件路径的形式访问 或者 直接 http://ip/文件路径的形式访问\n```sql\n    server {\n        listen       80 default_server;\n        listen       [::]:80 default_server;\n        server_name  _;\n        root        /var/ftp/pub;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n          autoindex on;\n          autoindex_localtime on;\n        }\n\n        location /uploadfile {\n           alias /var/ftp/pub;\n           autoindex on;\n           autoindex_localtime on;\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n```\n#### 3.2 autoindex 和 autoindex_localtime 生成目录索引\n```sql\n  autoindex  on;                        #自动显示目录\n  autoindex_exact_size  off;            #改为off后，显示出文件的大概大小，单位是kB或者MB或者GB；即人性化方式显示文件大小否则以byte显示\n  autoindex_localtime on;               #显示的文件时间为文件的服务器时间；即按服务器时间显示\n  limit_rate_after 10m;                 #10m之后下载速度为10k\n```\n\n参考:http://blog.licess.com/nginx-autoindex/\n\n#### 3.2 解决目录列表文件名乱码问题\n\n```sql\nvi  /etc/nginx/nginx.conf \n\n加上 charset utf-8,gbk即可解决;\n\nuser  nginx;\nworker_processes  1;\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\nevents {\n    worker_connections  1024;\n}\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    access_log  /var/log/nginx/access.log  main;\n    sendfile        on;\n    #tcp_nopush     on;\n    keepalive_timeout  65;\n    #gzip  on;\n    include /etc/nginx/conf.d/*.conf;\n    autoindex on;\n    autoindex_exact_size off;\n    autoindex_localtime on;\n    charset utf-8,gbk;\n}\n```\n### 4.Nginx 配置反向代理\n```sql\n#user  nobody;\nworker_processes  1;\n#error_log  logs/error.log;\nerror_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#error_log /usr/local/etcinx/logs/error.log  warn;\n#pid        logsinx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #access_log  logs/access.log  main;\n    #tcp_nopush     on;\n    #keepalive_timeout  0;\n    \n    sendfile        on;\n    keepalive_timeout  65;\n\n    gzip  on;\n    gzip_min_length     1k;\n    gzip_comp_level     3;\n    gzip_buffers     4 16k;\n    gzip_vary on;\n\t\n    server {\n        listen       80;\n        server_name  localhost 192.168.0.252 songshuiyang.com;\n        \n        location / {\n            proxy_pass   http://127.0.0.1:4080;\n            proxy_set_header  Host $http_host;\n            proxy_set_header  X-Real-IP $remote_addr;\n            proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n\t\t    client_max_body_size 100m;\n        }\n\n        location /uploadfile {\n           alias /var/ftp/pub ;\n        }\n\n        location /webapp {\n\t\t\tproxy_pass   http://127.0.0.1:8068;\n\t\t\tproxy_set_header  Host $http_host;\n            proxy_set_header  X-Real-IP $remote_addr;\n            proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n\n        location /admin-webapp {\n            alias html/test-admin-webapp;\n        }\n\t\t\n\t\tlocation = /favicon.ico {\n\t\t\talias /var/ftp/pub/favicon.ico;\n\t\t}\n\n    }\n}\n#  include servers/*;\n```\n### 5.Nginx 简单的负载均衡的示例\n```sql\nhttp {\n  upstream myproject {\n  server 127.0.0.1:8000 weight=3;\n  server 127.0.0.1:8001;\n  server 127.0.0.1:8002;\n  server 127.0.0.1:8003;\n}\n\nserver {\n  listen 80;\n  server_name www.domain.com;\n  location / {\n   proxy_pass http://myproject;\n  }\n  }\n}\n```\n\n本文参考： http://www.bubuko.com/infodetail-2349571.html","tags":["nginx"],"categories":["server"]},{"title":"Shiro记事","url":"/2018/06/05/backend/framework/Shiro/Shiro记事/","content":"### Shiro内置了默认的拦截器\n\n\n### 配置Shiro使得多个角色可以访问同一URL\n在Shiro配置中，如果对某一URL作如下配置：\n\n`/a.jsp = roles[\"role1, role2\"]`\n\n其效果等效于hasAllRoles，即要求所有角色都满足才可访问。\n\n但在实际中，可能只需满足任一角色即可访问。在这种情况下，需要自己重载RolesAuthorizationFilter的isAccessAllowed，实现或的关系。具体实现如下：\n```\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\npublic class AnyOfRolesAuthorizationFilter extends RolesAuthorizationFilter {\n    @Override\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response,\n                                   Object mappedValue) throws IOException {\n        final Subject subject = getSubject(request, response);\n        final String[] rolesArray = (String[]) mappedValue;\n        if (rolesArray == null || rolesArray.length == 0) {\n\n            //no roles specified, so nothing to check - allow access.\n\n            return true;\n        }\n        for (String roleName : rolesArray) {\n\n            if (subject.hasRole(roleName)) {\n\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n相应地，在INI文件中作如下配置：\n```sql\n[main]\n...\nanyofroles = com.your.package.AnyOfRolesAuthorizationFilter\n[urls]\n...\n/path/to/some/url = anyofroles[\"role1,role2\"]\n```\n","tags":["shiro"],"categories":["server"]},{"title":"基于 CentOS 搭建 FTP 文件服务","url":"/2018/06/05/backend/server/centos/基于 CentOS 搭建 FTP 文件服务/","content":"### 1.安装并启动 FTP 服务\n#### 1.1 使用 yum 安装 vsftpd\n```sql\n# yum默认都是安装最新版的软件\nyum install -y vsftpd\n```\n#### 1.2 启动 vsftpd\n```sql\n安装完成后，启动 FTP 服务：\nservice vsftpd start\n\n启动后，可以看到系统已经监听了 21 端口：\nnetstat -nltp | grep 21\n\n此时，访问 ftp://主机ip 可浏览机器上的 /var/ftp目录了。\n```\n<!-- more -->\n### 2.配置 FTP 权限\n#### 2.1 了解 VSFTP 配置\n```sql\nvsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件：\n\nvsftpd.conf 为主要配置文件\nftpusers 配置禁止访问 FTP 服务器的用户列表\nuser_list 配置用户访问控制\n```\n#### 2.1 创建 FTP 用户\n```sql\n创建一个用户 ftpuser\nuseradd ftpuser\n为用户 ftpuser 设置密码\necho \"password\" | passwd ftpuser --stdin\n```\n#### 2.2 限制该用户仅能通过 FTP 访问\n```sql\n限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：\nusermod -s /sbin/nologin ftpuser\n```\n 命令笔记: \n```sql\n用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的crontab档。也需手动更改使用者的at工作档。采用NIS server须在server上更动相关的NIS设定。\n-c<备注>：修改用户帐号的备注文字；\n-d<登入目录>：修改用户登入时的目录；\n-e<有效期限>：修改帐号的有效期限；\n-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；\n-g<群组>：修改用户所属的群组；\n-G<群组>；修改用户所属的附加群组；\n-l<帐号名称>：修改用户帐号名称；\n-L：锁定用户密码，使密码无效；\n-s<shell>：修改用户登入后所使用的shell；\n-u<uid>：修改用户ID；\n-U:解除密码锁定。\n```\n#### 2.3 创建登录欢迎文件\n```sql\necho \"Welcome to use FTP service.\" > /var/ftp/welcome.txt\n```\n\n#### 2.4 配置权限\n```sql\n设置访问权限\nchmod a-w /var/ftp && chmod 777 -R /var/ftp/pub\n\n设置为用户的主目录：\nusermod -d /var/ftp ftpuser\n```\n命令笔记:\n```sql\n权限范围的表示法如下：\nu User，即文件或目录的拥有者；\ng Group，即文件或目录的所属群组；\no Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；\na All，即全部的用户，包含拥有者，所属群组以及其他用户；\nr 读取权限，数字代号为“4”;\nw 写入权限，数字代号为“2”；\nx 执行或切换权限，数字代号为“1”；\n- 不具任何权限，数字代号为“0”；\ns 特殊功能说明：变更文件或目录的权限。\n\n-c或——changes：效果类似“-v”参数，但仅回报更改的部分；\n-f或--quiet或——silent：不显示错误信息；\n-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；\n-v或——verbose：显示指令执行过程；\n--reference=<参考文件或目录>：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；\n<权限范围>+<权限设置>：开启权限范围的文件或目录的该选项权限设置；\n<权限范围>-<权限设置>：关闭权限范围的文件或目录的该选项权限设置；\n<权限范围>=<权限设置>：指定权限范围的文件或目录的该选项权限设置；\n\nLinux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內！\n\n例：rwx　rw-　r--\n\nr=读取属性　　//值＝4\nw=写入属性　　//值＝2\nx=执行属性　　//值＝1\n\nchmod u+x,g+w f01　　//为文件f01设置自己可以执行，组员可以写入的权限\nchmod u=rwx,g=rw,o=r f01\nchmod 764 f01\nchmod a+x f01　　//对文件f01的u,g,o都设置可执行属性\n文件的属主和属组属性设置\n\nchown user:market f01　　//把文件f01给uesr，添加到market组\nll -d f1  查看目录f1的属性\n```\n#### 2.5 备注\n一： 以上配置是匿名用户可以通过ftp://主机ip 即可访问文件，但不能上传文件，所以需要添加一个`ftpuser`用户ftp上传操作，这样做有俩个好处\n1. 访问文件可以通过一个ftp绝对路径访问(也可以通过nginx代理通过http的形式访问)，不需要输入用户名及密码\n2. 上传修改文件只能通过该(ftpuser)用户才能进行操作，保证了其安全性\n\n二： 阻止匿名访问和切换根目录\n```sql\n匿名访问和切换根目录都会给服务器带来安全风险，我们把这两个功能关闭。\n编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：\nvi /etc/vsftpd/vsftpd.conf\n \n# 禁用匿名用户  12 YES 改为NO\nanonymous_enable=NO\n\n# 禁止切换根目录 101 行 删除#\nchroot_local_user=YES\n编辑完成后保存配置，重新启动 FTP 服务\nservice vsftpd restart\n```\n\n\n本文参考： https://www.baidu.com/link?url=3FcSvP44zFbo33EoJBucNlE1ZKKkncTuckfxuvNFJhCPvQuZmlebtZRzRAW3-W0SH8Ep8dShtJ8NSjWlozkrPa&wd=&eqid=edc2684700001d70000000065b17479b","tags":["ftp"],"categories":["server"]},{"title":"使用微软提供的Office Online实现Office文档的在线查看,编辑等功能","url":"/2018/05/08/backend/other/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能/","content":"### 使用微软提供的Office Online实现Office文档的在线查看,编辑\n\n使用微软提供的Office Online平台只需要一个网址即可在线查看Xls,doc,PPT等文档\n#### 在线预览\nhttp://view.officeapps.live.com/op/view.aspx?src=要查看的文档地址\n\n#### 在线编辑\n在线编辑需要登录https://www.office.com并从onedrive中打开或新建文档也可以来自在线模板(下面的Excel来自Excel Online模板，编辑后的文件会保存到你的onedrive中)\n在线编辑Xls文档(部分功能不支持,但已经够用)","tags":["Java"],"categories":["server"]},{"title":"freemaker模板框架","url":"/2018/04/14/backend/framework/freemarker/freemaker模板框架/","content":"### freemaker 语法笔记\n* if 条件\n```xml\n      <#if entity.columnName == 'id' >\n       \n      <#elseif entity.columnName == 'id' >\n        \n      <#else>\n        \n      </#if>\n```\n\n* list 遍历元素\n````xml\n1. 遍历\n要想在Freemarker中遍历list,必须通过使用list指令,即<#list sequence as item>…</#list>\nsequence是集合(collection)的表达式，item是循环变量的名字，不能是表达式。\n\n<#list userList as user>\n  …\n</#list>\n\nList指令还隐含了两个循环变量：\n    item_index:当前迭代项在所有迭代项中的位置，是数字值。\n    item_has_next:用于判断当前迭代项是否是所有迭代项中的最后一项。\n    注意：在使用上述两个循环变量时，一定要将item换成你自己定义的循环变量名,item其实就是前缀罢了。\n\n    <#--Freemarker遍历list并应用list隐含变量item_index-->\n        item_index使用：\n        <#list userList as user>\n        第${user_index+1}个用户\n          用户名：${user.userName}\n          密  码：${user.userPassword}\n          年  龄: ${user.age}\n        </#list>\n    <#--Freemarker遍历list并应用list隐含变量item_has_next-->\n        item_has_next,size使用：\n        <#list userList as user>\n          用户名：${user.userName}\n          密  码：${user.userPassword}\n          年  龄: ${user.age}\n          <#if !user_has_next>\n          共有${userList?size}最后一个用户是:${user.userName}\n        </#if>\n        </#list>\n\n2. 排序\n\nsort升序排序函数\n    sort对序列(sequence)进行排序，要求序列中的变量必须是：字符串（按首字母排序）,数字，日期值。\n    <#list list?sort as l>…</#list>\nsort_by函数\n    sort_by有一个参数,该参数用于指定想要排序的子变量，排序是按照变量对应的值进行排序,如：\n    <#list userList?sort_by(“age”) as user>…</#list>\n    age是User对象的属性，排序是按age的值进行的。\nreverse降序排序函数\n    <#list list? reverse as l>…</#list>。reverse使用同sort相同。reverse还可以同sort_by一起使用\n    如：想让用户按年龄降序排序，那么可以这个样写<#list userList?sort_by(“age”)?reverse as user>…</#list>\n    \n    \n````","tags":["Java"],"categories":["server"]},{"title":"Spring 集成Redis","url":"/2018/04/08/backend/framework/cache/Redis/","content":"## 一：Redis\n\n### 1. 什么是Redis\nRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。\n\n官网: https://redis.io/\n\n中文教程网: http://www.redis.net.cn/tutorial/3501.html\n\n### 2. 基本介绍\n#### Redis 简介\n* Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。\n* Redis 与其他 key - value 缓存产品有以下三个特点：\n* Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n* Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n* Redis支持数据的备份，即master-slave模式的数据备份。\n\n#### Redis 优势\n* 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n* 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n* 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n* 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n#### Redis与其他key-value存储有什么不同？\n* Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\n* Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n<!--more-->\n### 3. 安装\n\n#### 3.1 windows环境\n下载地址: https://github.com/MicrosoftArchive/redis/releases\n\n#### 3.1.1 修改配置文件\n```sql\nredis.windows.conf 文件 配置密码 \n\n\n# requirepass foobared\nrequirepass shuiyang\n```\n#### 3.1.2 常用命令\n``` java\nredis服务安装成windows服务: redis-server --service-install redis.windows.conf\n\n开启服务：redis-server --service-start\n\n停止服务：redis-server --service-stop\n\n卸载服务：redis-server --service-uninstall\n```\n\n#### 3.1.3 Redis可视化管理工具\n* RedisStudio，百度云连接：http://pan.baidu.com/s/1gfIbLar  密码：mpne\n* Redis Desktop Manager https://redisdesktop.com/download\n\n                \n#### 3.2 Linux环境\n下载地址：http://www.redis.net.cn/download/，下载最新文档版本。\n#### 3.2.1 安装\n```sql\n$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz\n$ tar xzf redis-2.8.17.tar.gz\n$ cd redis-2.8.17\n$ make\n```\nmake完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli\n\n#### 3.2.1 启动服务\n下面启动redis服务.\n\n```sql\n$ ./redis-server\n```\n\n注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。\n\n```sql\n./redis-server redis.conf\n```\n\nredis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。\n\n#### 3.2.1 测试客户端程序\n启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：\n\n```sql\n$ ./redis-cli\nredis> set foo bar\nOK\nredis> get foo\n\"bar\"\n```\n\n### 4. 与Spring 集成\n\n#### 4.1 导入maven\n```xml\n        <!--redis-->\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.data</groupId>\n            <artifactId>spring-data-redis</artifactId>\n            <version>1.6.2.RELEASE</version>\n        </dependency>\n```\n\n#### 4.2 新建 `redis-config.properties`\n```xml\n# Redis settings\nredis.host=127.0.0.1\nredis.port=6379\nredis.pass=shuiyang\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\n#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal\nredis.maxActive=600\n#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。\nredis.maxWait=1000\n#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个\nredis.testOnBorrow=true\n```\n\n\n#### 4.3 新建 `applicationContext-redis.xml`\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context-4.0.xsd\n            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd\n            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n            http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd\">\n\n\n    <!-- 启用缓存注解开关 -->\n    <cache:annotation-driven cache-manager=\"cacheManager\"/>\n\n    <!-- 配置JedisPoolConfig实例 -->\n    <bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\">\n        <property name=\"maxIdle\" value=\"${redis.maxIdle}\" />\n        <property name=\"maxTotal\" value=\"${redis.maxActive}\" />\n        <property name=\"maxWaitMillis\" value=\"${redis.maxWait}\" />\n        <property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" />\n    </bean>\n\n    <!-- 配置JedisConnectionFactory -->\n    <bean id=\"jedisConnectionFactory\"\n          class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n        <property name=\"hostName\" value=\"${redis.host}\" />\n        <property name=\"port\" value=\"${redis.port}\" />\n         <property name=\"password\" value=\"${redis.pass}\" />\n        <property name=\"database\" value=\"${redis.dbIndex}\" />\n        <property name=\"poolConfig\" ref=\"poolConfig\" />\n    </bean>\n\n    <!-- 配置RedisTemplate -->\n    <bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\">\n        <property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n    </bean>\n\n    <!-- 配置RedisCacheManager -->\n    <bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\">\n        <constructor-arg name=\"redisOperations\" ref=\"redisTemplate\" />\n        <property name=\"defaultExpiration\" value=\"${redis.expiration}\" />\n    </bean>\n\n    <!-- 配置RedisCacheManager -->\n    <bean id=\"cacheManager\" class=\"org.springframework.cache.support.SimpleCacheManager\">\n        <property name=\"caches\">\n            <set>\n                <!-- 这里可以配置多个redis -->\n                <bean class=\"com.ecut.core.config.RedisCache\">\n                    <property name=\"redisTemplate\" ref=\"redisTemplate\" />\n                    <property name=\"name\" value=\"articlesDetail\"/>\n                </bean>\n                <bean class=\"com.ecut.core.config.RedisCache\">\n                    <property name=\"redisTemplate\" ref=\"redisTemplate\" />\n                    <property name=\"name\" value=\"getHotArticlesInCache\"/>\n                </bean>\n                <bean class=\"com.ecut.core.config.RedisCache\">\n                    <property name=\"redisTemplate\" ref=\"redisTemplate\" />\n                    <property name=\"name\" value=\"articlesList\"/>\n                </bean>\n            </set>\n        </property>\n    </bean>\n</beans>\n```\n#### 4.4 引入 `applicationContext-redis.xml redis-config.properties`\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:context=\"http://www.springframework.org/schema/context\"\n           xmlns:p=\"http://www.springframework.org/schema/p\"\n           xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n\thttp://www.springframework.org/schema/mvc\n\thttp://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\">\n\n    <!--使标注Spring注解的类生效-->\n    <context:component-scan base-package=\"com.ecut\"/>\n\n    <!-- 将多个配置文件读取到容器中，交给Spring管理 -->\n    <bean id=\"propertyConfigurer\" class=\"com.ecut.core.spring.PropertyPlaceholderConfigurerFilter\">\n        <property name=\"locations\">\n            <list>\n                <!-- 这里支持多种寻址方式：classpath和file -->\n                <value>classpath:project.properties</value>\n                <!-- 推荐使用file的方式引入，这样可以将配置和代码分离 -->\n                <value>classpath:jdbc.properties</value>\n                <value>classpath:redis-config.properties</value>\n            </list>\n        </property>\n    </bean>\n\n    <import resource=\"applicationContext-dao.xml\"/>\n    <import resource=\"applicationContext-shiro.xml\"/>\n    <!--encache redis选择一种缓存-->\n    <!--<import resource=\"applicationContext-encache.xml\"/>-->\n    <import resource=\"applicationContext-redis.xml\"/>\n</beans>\n```\n#### 4.5 新建 `RedisCache.java` Cache接口实现类 Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。\n```java\npackage com.ecut.core.config;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.lang3.SerializationUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.Cache;\nimport org.springframework.cache.support.SimpleValueWrapper;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.data.redis.connection.RedisConnection;\nimport org.springframework.data.redis.core.RedisCallback;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport java.io.Serializable;\n\n/**\n * Cache接口实现类\n *\n * 　Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。\n 　　在上面配置中可知，每个实现类都会注入一个redisTemplate实例，我们就可以通过redisTemplate来操作redis\n * @author songshuiyang\n * @date 2018/4/9 20:38\n */\npublic class RedisCache implements Cache {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    private RedisTemplate<String, Object> redisTemplate;\n\n    private String name;\n\n    @Override\n    public void clear() {\n        logger.info(\"----------------------------RedisCache  緩存清理-------------------------\");\n        redisTemplate.execute(new RedisCallback<String>() {\n            @Override\n            public String doInRedis(RedisConnection connection) throws DataAccessException {\n                connection.flushDb();\n                return \"ok\";\n            }\n        });\n    }\n\n    @Override\n    public void evict(Object key) {\n        logger.info(\"----------------------------RedisCache  緩存刪除-------------------------\");\n        final String keyf=key.toString();\n        redisTemplate.execute(new RedisCallback<Long>() {\n            @Override\n            public Long doInRedis(RedisConnection connection) throws DataAccessException {\n                return connection.del(keyf.getBytes());\n            }\n\n        });\n\n    }\n\n    @Override\n    public ValueWrapper get(Object key) {\n        logger.info(\"----------------------------RedisCache  缓存获取-------------------------\");\n        final String keyf = key.toString();\n        Object object = null;\n        object = redisTemplate.execute(new RedisCallback<Object>() {\n            @Override\n            public Object doInRedis(RedisConnection connection) throws DataAccessException {\n                byte[] key = keyf.getBytes();\n                byte[] value = connection.get(key);\n                if (value == null) {\n                    logger.info(\"----------------------------RedisCache 缓存不存在-------------------------\");\n                    return null;\n                }\n                return SerializationUtils.deserialize(value);\n            }\n        });\n        ValueWrapper obj=(object != null ? new SimpleValueWrapper(object) : null);\n        logger.info(\"----------------------------RedisCache 获取到内容-------------------------\");\n        return  obj;\n    }\n\n    @Override\n    public void put(Object key, Object value) {\n        System.out.println(\"-------加入缓存------\");\n        System.out.println(\"key----:\"+key);\n        System.out.println(\"key----:\"+value);\n        final String keyString = key.toString();\n        final Object valuef = value;\n        final long liveTime = 86400;\n        redisTemplate.execute(new RedisCallback<Long>() {\n            @Override\n            public Long doInRedis(RedisConnection connection) throws DataAccessException {\n                byte[] keyb = keyString.getBytes();\n                byte[] valueb = SerializationUtils.serialize((Serializable) valuef);\n                connection.set(keyb, valueb);\n                if (liveTime > 0) {\n                    connection.expire(keyb, liveTime);\n                }\n                return 1L;\n            }\n        });\n\n    }\n\n    @Override\n    public <T> T get(Object arg0, Class<T> arg1) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    @Override\n    public Object getNativeCache() {\n        return this.redisTemplate;\n    }\n\n    @Override\n    public ValueWrapper putIfAbsent(Object arg0, Object arg1) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public RedisTemplate<String, Object> getRedisTemplate() {\n        return redisTemplate;\n    }\n\n    public void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n#### 4.6 完成以上的配置之后就可以使用 Spring Cache注解来使用缓存了\n首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。\n* @Cacheable\n\n```sql\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 \n这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 \n可以使用key属性来指定key的生成规则。\n\n@Cacheable 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中\n  key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId，\n\n  一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， \n  本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等\n\n  condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL\n  \n  \n  // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1'\n  @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\")    \n  public User findById(String userId) {    \n      return (User) new User(\"1\", \"mengdee\");           \n  }    \n  \n  // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key\n  // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\"\n  @Cacheable(value=\"UserCache\", condition=\"#userId.length() < 12\")    \n  public boolean isReserved(String userId) {    \n      System.out.println(\"UserCache:\"+userId);    \n      return false;    \n  }\n```\n* @CachePut\n\n```sql\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。\n```\n\n* @CacheEvict\n```sql\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。\n\n@CacheEvict 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，同上\n  key：缓存的key，默认为空，同上\n  condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL\n  allEntries：true表示清除value中的全部缓存，默认为false\n\n  //清除掉UserCache中某个指定key的缓存    \n  @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\")    \n  public void removeUser(User user) {    \n      System.out.println(\"UserCache\"+user.getUserId());    \n  }    \n  \n  //清除掉UserCache中全部的缓存    \n  @CacheEvict(value=\"UserCache\", allEntries=true)    \n  public final void setReservedUsers(String[] reservedUsers) {    \n     System.out.println(\"UserCache deleteall\");    \n  }\n  \n  \n```\n* @Caching\n```sql\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") })\npublic Book importBooks(String deposit, Date date)\n\n```\n* @CacheConfig\n```sql\n与前面的缓存注解不同，这是一个类级别的注解。\n 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig(\"books\")\npublic class BookRepositoryImpl implements BookRepository {\n    @Cacheable\n    public Book findBook(ISBN isbn) {...}\n}\n```\n## 遇到的问题：\n* spring+redis报错org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V\n```java\n这个问题的原因大概就是spring-data-redis.jar包版本不对 ，下面版本可以正常启动\n\n        <dependency>\n            <groupId>org.springframework.data</groupId>\n            <artifactId>spring-data-redis</artifactId>\n            <version>1.6.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n```\n* Spring Cache 注解问题，使用redis缓存会出现类型转化的问题 ,还未解决\n\n\n\n## 参考： \nhttps://www.cnblogs.com/panter/p/6801210.html\nhttp://www.redis.net.cn/tutorial/3503.html\nhttps://www.cnblogs.com/hello-daocaoren/p/7891907.html\n\n\n","tags":["java"],"categories":["server"]},{"title":"微信公众号实现输入兑换码自动发红包功能","url":"/2018/04/03/backend/business/payment/微信公众号开通发红包功能/","content":"### 前言\n 公司积分抽奖活动有红包奖项(虽然基本上都是这个奖)，但是用户兑奖的过程十分麻烦: 需要先联系公司客服，然后加客服微信，加完之后客服发一个微信红包作为兑换。所以决定简化这个兑奖过程，能不能将这个兑奖的过程改为由用户自己兑换，不用联系公司客服也能兑奖。\n \n### 初步想法\n 公司有微信公众号，可以通过微信公众号进行发红包操作，一方面可以实现发送红包的功能，另一方面也可以推广公司的微信公众号。初步想法是用户在微信公众号里输入一个兑换码，然后微信自动发送一个红包给用户，用户只要点一下红包，红包就进用户自己口袋了\n \n### 业务流程\n如果用户抽奖中了红包奖励，系统弹出一个提示框，里面有公司的微信公众号二维码图片（微信公众平台可以获取），及兑奖的兑换码，提示用户关注微信公众号，在公众号里面输入兑换码就可以获取红包\n\n<!--more-->\n### 准备\n1、先介绍几个平台\n\nI.微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。\n\n平台入口：http://mp.weixin.qq.com。\n\nII.微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。\n\n平台入口：http://pay.weixin.qq.com\n\nIII. 红包接口地址： https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&index=3\n\n2、 在微信公众平台获取公众号二维码图片（提供了多种尺寸大小），该二维码是提供给用户扫描， 及公众账号appid\n\n3、 在微信商户平台上下载证书（账户中心 - 账户设置 - API安全 - API证书（下载zip压缩包格式即可，无须解压），获取 商户号（账户中心 - 账户设置 - 商户信息 - 基本账户信息 - 微信支付商户号），API密钥（账户中心 - 账户设置 - API安全 - API密钥 - 设置密钥（密钥为32位，需要自行重新设置，记录并保存好，实在没记住也可以更改） 这些参数\n\n4、 开通红包功能，以及充值红包金额，红包金额与充值交易金额是区分开来的，所以需要单独充值，发放现金红包将扣除商户的可用余额，请注意，可用余额并不是微信支付交易额，需要预先充值，确保可用余额充足。查看可用余额、充值、提现请登录微信支付商户平台，进入“资金管理”菜单，进行操作\n\n5、 介绍\n```java\n现金红包简介\n微信红包，2014年春节一经推出即受到广大用户好评，引发全民抢红包热潮。现将微信红包打造成“现金红包”，成为一款定向资金发放的营销工具，供商户使用。\n\n申请红包条件\n1、T+0 结算商户需满足两个条件：1、入驻满90天，2、截止今日往回推30天内连续正常交易。\n2、其余结算周期的商户无限制，可立即前往【商户平台】->【产品中心】申请开通。\n\n发放方式介绍\n商户发放现金红包有3种发放方式：\n1）接口发放\n商户根据文档”【商户平台】现金红包API文档V2“进行开发，一次调用可以给一个指定用户发送一个指定金额的红包，满足多元化的运营需求；\n2）通过上传openid文件发放\n收集要发送红包对象的openid，将openid编辑成txt文件，登录微信支付商户平台，使用上传文件功能发放。一份文件对应一个红包模板，便于管理；\n为了防止商户手误重复操作发送红包，创建的同一个文件只能上传一次。若需要重复发放则需要修改文件名称或重新创建。\n3）配置营销规则“满额送”发放\n配置的规则不可使用红包模版进行发放，商户须在【产品中心】-【现金红包】-【前往功能】中创建红包后配置自助规则：用户使用微信支付发生交易满足一定条件，立送现金红包。\n\n税务和发票问题\n商户给用户发红包，微信支付按照商户指定红包金额扣除完全对等的充值资金，资金最终进入用户零钱。微信支付并未从中收取资金作为营收，所以不予开具发票。\n发放现金红包请商户遵照国家法律依法纳税，在商户充值之前，我们默认商户已经合法上税，商户使用本功能的行为若涉及纳税或代扣代缴税款的义务，由商户自行承担该义务，我们不会替商户缴纳税款 。\n```\n\n### 程序实现\n1、用户抽奖中了红包奖励, 生成一笔抽奖记录，同时生成一笔红包记录，所以需要新建一个红包记录表(表结构如下图)，一开始生成的记录中红包状态是 0-未发放的状态，同时生成兑换码。\n\n兑换码规则：\n\n10位大写字母：3位固定字母开头 + 7位随机字母（大写字母是为了防止【数字0 与字母o O】【 1与字母l】混淆导致用户兑换不了奖， 3位固定字母是为了防止恶意用户无限次输入兑换码导致老是触发红包处理程序，如果不是以这个三个字母开头的文字，统一回复欢迎关注本微信公众号）\n\n```sql\nDROP TABLE IF EXISTS `ge_lottery_redpack_record`;\nCREATE TABLE `ge_lottery_redpack_record` (\n  `id` varchar(32) NOT NULL,\n  `created_by` varchar(32) NOT NULL,\n  `created_date` datetime NOT NULL,\n  `last_modified_by` varchar(32) NOT NULL,\n  `last_modified_date` datetime NOT NULL,\n  `remarks` varchar(255) DEFAULT NULL,\n  `version` int(11) DEFAULT NULL,\n  `locked` bit(1) DEFAULT b'0',\n  `enable` bit(1) DEFAULT b'0',\n  `fd_lottery_record_id` varchar(32) DEFAULT NULL COMMENT '中奖纪录id 作为外键',\n  `fd_status` int(11) DEFAULT NULL COMMENT '红包状态 0:未发放 1：已发放待领取 2：发放失败 3：已领取 4：未领取已退款',\n  `fd_redpack_send_date` datetime DEFAULT NULL COMMENT '红包发送时间(非微信)',\n  `fd_redpack_order_id` varchar(32) DEFAULT NULL COMMENT '微信红包订单单号',\n  `fd_redpack_openid` varchar(32) DEFAULT NULL COMMENT '微信红包订单用户在wxappid下的openid',\n  `fd_redeem_code` varchar(32) DEFAULT NULL COMMENT '兑换码',\n  `fd_redpack_price` decimal(19,4) DEFAULT NULL COMMENT '红包金额',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖红包纪录表';\n\n```\n2、用户得到兑换码之后，就是在微信公众号里输入兑换码，当用户输入兑换码之后，用户信息会发到我们自己服务器后台中, 这里用户触发的是文本事件，我们需要的是三个参数\n\n(1) 用户微信OpenID（用户在本微信公众号的唯一标识）\n\n(2) 用户发的兑换码\n\n(3) HttpServletRequest（用于获取用户ip，发红包接口入参需要）\n\n```java\n            // 文本事件\n            if (WechatBindUtil.MESSAGE_TEXT.equals(msgType)) {\n                String content = map.get(\"Content\").trim();\n                // 如果输入的文本是是以RED开头的, 执行发红包操作\n                if (content.startsWith(\"RED\")) {\n                    String resultContent = lotteryRedpackRecordService.sendRedpackByRedeemCode(fromUserName,content,req);\n                    message = WechatBindUtil.initText(toUserName, fromUserName, resultContent);\n                } else {\n                    message = WechatBindUtil.initText(toUserName, fromUserName, \"欢迎关注本微信公众号\");\n                }\n            }\n```\n3、如果输入的文本是是以RED开头的, 执行发红包操作, 首先是查询红包记录表有没有该兑换码且红包状态为未发放，如果有的话调用微信发红包接口，同时更改红包状态，记录\n红包发送时间，微信红包订单单号，微信红包订单用户在wxappid下的openid，没有的话给出提示，实现如下\n```java\n    /**\n     * 根据兑换码发送微信红包\n     * @param openid\n     * @param redeemCode\n     * @return\n     */\n    public String sendRedpackByRedeemCode (String openid, String redeemCode, HttpServletRequest request) {\n        Page<LotteryRedpackRecord> page = new Page<>(0);\n        page.setParams(\"fdRedeemCode\",redeemCode);\n        List<LotteryRedpackRecord> redpackRecords = findAutoByPage(page);\n        if (redpackRecords.size() != 0) {\n            LotteryRedpackRecord oldRecord = redpackRecords.get(0);\n            // 调用微信红包查询接口, 先更新红包纪录状态\n            updateRedpackState(oldRecord.getId());\n\n            // 更新完成之后获取新的红包纪录\n            LotteryRedpackRecord record = findById(oldRecord.getId());\n            Integer fdStatus = record.getFdStatus();\n            if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.未发放.getIndex())) {\n                RedpackDTO redpackDTO = new RedpackDTO();\n                // 以红包纪录id作为 微信红包接口请求的商品订单号 截取28位\n                String mchBillNo = record.getId();\n                mchBillNo= mchBillNo.substring(0,28);\n                redpackDTO.setMchBillNo(mchBillNo);\n                // 指定哪一个微信用户\n                redpackDTO.setReOpenid(openid);\n                // 红包价格\n                redpackDTO.setTotalAmount(record.getFdRedpackPrice());\n                // 调用接口的机器Ip地址\n                String clientIp = WxUtils.getRemoteIp(request);\n                redpackDTO.setClientIp(clientIp);\n                Map<String,String> sendredpackResult = weixinPayService.sendredpack(redpackDTO);\n\n                // 更新红包纪录表\n                LotteryRedpackRecord lotteryRedpackRecord = findById(record.getId());\n                lotteryRedpackRecord.setFdRedpackOpenid(openid);\n                if (sendredpackResult.get(\"status\").equals(\"success\")) {\n                    lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex());\n                    // 红包订单的微信单号-微信服务器上红包纪录的唯一标识\n                    String redpackOrderId = sendredpackResult.get(\"sendListid\");\n                    lotteryRedpackRecord.setFdRedpackOrderId(redpackOrderId);\n                    lotteryRedpackRecord.setFdRedpackSendDate(new Date());\n\n                    // 更新抽奖纪录表, 变为已兑换\n                    LotteryRecord lotteryRecord = lotteryRecordService.findById(record.getFdLotteryRecordId());\n                    lotteryRecord.setFdStatus(R.LotteryRecordItem.FdStatus.已兑换.getIndex());\n                    lotteryRecordService.saveSelective(lotteryRecord);\n                    saveSelective(lotteryRedpackRecord);\n                } else {\n                    lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex());\n                    lotteryRedpackRecord.setRemarks(sendredpackResult.get(\"message\"));\n                    saveSelective(lotteryRedpackRecord);\n                    return \"红包发送失败, 请及时联系对应的客服!\";\n                }\n            } else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex())) {\n                return \"该兑换码对应的红包已发送! 请注意查收\";\n            } else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex())) {\n                return \"红包发送失败, 请及时联系对应的客服!\";\n            } else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已领取.getIndex())) {\n                return \"该兑换码对应的红包已领取\";\n            } else {\n                return \"该兑换码对应的红包已过时, 请及时联系对应的客服\";\n            }\n        } else {\n            return \"该兑换码无效, 请输入正确的兑换码!\";\n        }\n        return \"红包已发送请注意查收! 注: 24小时后未领取该红包失效\";\n    }\n```\n4、调用微信红包接口\n\n```java\n    /**\n     * 微信公众号发红包接口\n     * @param redpackDTO\n     * @return\n     */\n    public Map<String,String> sendredpack(RedpackDTO redpackDTO) {\n        Map<String,String> resultMap = Maps.newHashMap();\n        Map<String,String> wxResultMap = Maps.newHashMap();\n        // 请求参数\n        Map<String, String> reqData = Maps.newHashMap();\n        logger.info(\"--------------------->>> 开始发送红包start\", redpackDTO);\n        try {\n            // 随机字符串\n            reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr());\n            // 商户订单号\n            reqData.put(\"mch_billno\",redpackDTO.getMchBillNo());\n            // 商户号\n            reqData.put(\"mch_id\", WxPcPayConfigImpl.MCH_ID);\n            // 公众账号appid\n            reqData.put(\"wxappid\", WxPcPayConfigImpl.SENDREDPACK_WX_APPID);\n            // 商户名称\n            reqData.put(\"send_name\", WxPcPayConfigImpl.SENDREDPACK_SEND_NAME);\n            // 用户openid\n            reqData.put(\"re_openid\",redpackDTO.getReOpenid());\n            // 付款金额\n            reqData.put(\"total_amount\", AmountUtils.transAmountToCent(redpackDTO.getTotalAmount()));\n            // 红包发放总人数\n            reqData.put(\"total_num\", WxPcPayConfigImpl.SENDREDPACK_TOTAL_NUM);\n            // 红包祝福语\n            reqData.put(\"wishing\", WxPcPayConfigImpl.SENDREDPACK_WISHING);\n            // Ip地址\n            reqData.put(\"client_ip\", redpackDTO.getClientIp());\n            // 活动名称\n            reqData.put(\"act_name\", WxPcPayConfigImpl.SENDREDPACK_ACT_NAME);\n            //备注\n            reqData.put(\"remark\", WxPcPayConfigImpl.SENDREDPACK_REMARK);\n            // 生成签名\n            reqData.put(\"sign\", WXPayUtil.generateSignature(reqData, WxPcPayConfigImpl.API_KEY, WXPayConstants.SignType.MD5 ));\n            String respXml = wxpay.requestWithCert(WxPcPayConfigImpl.SENDREDPACK_URL,reqData , 10000, 10000);\n            wxResultMap = WXPayUtil.xmlToMap(respXml);\n        } catch (Exception e) {\n            e.printStackTrace();\n            logger.info(\"--------------------->>> 微信公众号发送红包异常\");\n            resultMap.put(\"message\", e.getMessage());\n            resultMap.put(\"status\", \"failed\");\n        }\n        // 通信标识结果\n        String returnCode = wxResultMap.get(\"return_code\");\n        if (\"SUCCESS\".equals(returnCode)) {\n            String resultCode = wxResultMap.get(\"result_code\");\n            // 业务处理结果\n            if (\"SUCCESS\".equals(resultCode)) {\n                logger.info(\"--------------------->>> 微信公众号发送红包成功\");\n                // 红包订单的微信单号\n                String sendListid = wxResultMap.get(\"send_listid\");\n                resultMap.put(\"sendListid\",sendListid);\n                resultMap.put(\"message\",\"操作成功\");\n                resultMap.put(\"status\", \"success\");\n            } else {\n                logger.info(\"--------------------->>> 微信公众号发送红包失败, 原因: \" + wxResultMap.get(\"err_code_des\"));\n                String errCodeDes = wxResultMap.get(\"err_code_des\");\n                resultMap.put(\"message\",errCodeDes);\n                resultMap.put(\"status\", \"failed\");\n                return resultMap;\n            }\n        } else {\n            String returnMsg = wxResultMap.get(\"return_msg\");\n            logger.info(\"--------------------->>> 微信公众号发送红包失败, 原因: \" + returnMsg);\n            resultMap.put(\"message\", returnMsg);\n            resultMap.put(\"status\", \"failed\");\n            return resultMap;\n        }\n        return resultMap;\n    }\n```\n\n### 总结及注意事项\n1.红包是以分为单位，必须大于100分，小于20000分之间，这个很重要,不要一不小心把公司的钱都转出去了\n\n2.需要对请求参数进行加签操作，wxpay里面封装了方法\n\n3.现金红包接口请求是需要证书的，因为是出账，不像充值是属于进账不用证书， 需要调用`requestWithCert` 这个请求接口\n\n```java\n    /**\n     * 需要证书的请求\n     * @param strUrl String\n     * @param reqData 向wxpay post的请求数据  Map\n     * @param connectTimeoutMs 超时时间，单位是毫秒\n     * @param readTimeoutMs 超时时间，单位是毫秒\n     * @return API返回数据\n     * @throws Exception\n     */\n    public String requestWithCert(String strUrl, Map<String, String> reqData,\n                                  int connectTimeoutMs, int readTimeoutMs) throws Exception {\n```\n4.由于红包发出去了不知道用户有没有领取，所以可以用一个定时任务或者一个按钮调用微信红包状态查询接口，以更新红包的最新状态\n\n5.可以借助第三方平台，如摇摇啦应用平台，借助这些平台可以不用开发接口，只要配置好参数就可以使用了，但唯一的缺点是要钱\n","tags":["支付"],"categories":["server"]},{"title":"Docelver接口管理平台","url":"/2018/04/03/backend/testwork/Docelver接口管理平台/","content":"#### 前言 \n在项目开发过程中，开发一个功能模块，需要前后端开发进行接口定义并形成文档，如果使用doc这些文档去维护接口，多会出现纰漏，特别是在多人开发的项目中，缺点尤为明显，所以需要一个像代码版本控制（git svn）类型的平台去维护这些文档，方便开发人员进行接口维护，前后端开发人员联调接口，测试人员编写测试用例\n\n#### 市场上常用的接口管理平台\n\n##### 1. Rap 阿里出品\n官网地址：  http://rapapi.org/org/index.do\n\n官网介绍：\n\nRAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效率。我们的口号：提高效率，回家吃晚饭！\n\n使用体验：\n1. RAP的应用范围非常明确，是一个面向开发人员自测和联调的工具性平台，它更适合以开发为核心对接口进行维护\n\n##### 2. DOClever\n官网地址： http://www.doclever.cn/controller/index/index.html\n\n可以对接口信息进行编辑管理，支持get,post,put,delete,patch 五种方法，支持 https 和 https 协议，并且支持 query，body，json，raw，rest，formdata 的参数可视化编辑。同时对 json 可以进行无限层次可视化编辑。并且，状态码，代码注入，markdown 文档等附加功能应有尽有。\n\n\n \n\n接口调试运行，可以对参数进行加密，从md5 到 aes 一应俱全，返回参数与模型实时分析对比，给出不一致的地方，找出接口可能出现的问题。如果你不想手写文档，那么试试接口的数据生成功能，可以对接口运行的数据一键生成文档信息。\n\n \n\nmock 的无缝整合，DOClever 自己就是一个 mock 服务器，当你把接口的开发状态设置成已完成，本地 mock 便会自动请求真实接口数据，否则返回事先定义好的 mock 数据。\n\n \n\n支持 postman，rap，swagger 的导入，方便你做无缝迁移，同时也支持 html 文件的导出，方便你离线浏览！\n\n \n\n项目版本和接口快照功能并行，你可以为一个项目定义 1.0，1.1，1.2 版本，并且可以自由的在不同版本间切换回滚，再也不怕接口信息的遗失，同时接口也有快照功能，当你接口开发到一半或者接口需求变更的时候，可以随时查看之前编辑的接口信息。\n\n \n\n自动化测试功能，目前市面上类似平台的接口自动化测试大部分都是伪自动化，对于一个复杂的场景，比如获取验证码，登陆，获取订单列表，获取某个特定订单详情这样一个上下文关联的一系列操作无能为力。而 DOClever 独创的自动化测试功能，只需要你编写极少量的 javascript 代码便可以在网页里完成这样一系列操作，同时，DOClever 还提供了后台定时批量执行测试用例并把结果发送到团队成员邮箱的功能，你可以及时获取接口的运行状态。\n\n \n\n团队协作功能，很多类似的平台这样的功能是收费的，但是 DOClever 觉得好东西需要共享出来，你可以新建一个团队，并且把团队内的成员都拉进来，给他们分组，给他们分配相关的项目以及权限，发布团队公告等等。\n\n \n\nDOClever 开源免费，支持内网部署，很多公司考虑到数据的安全性，不愿意把接口放到公网上，没有关系，DOClever 给出一个方便快捷的解决方案，你可以把平台放到自己的内网上，完全不需要连接外网，同时功能一样也不少，即便是对于产品的升级，DOClever 也提供了很便捷的升级方案！\n","tags":["测试"],"categories":["server"]},{"title":"高并发","url":"/2018/04/01/backend/server/JavaEE服务器/高并发/","content":"## 一、什么是高并发\n> 通常指通过设计保证系统能够同时并行处理很多请求。\n\n高并发相关常用的一些指标\n\n参数 | 定义\n---|---\n响应时间 | 系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。\n吞吐量   | 单位时间内处理的请求数量。\nQPS | 每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。\n并发用户数 | 同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。\n\n## 二、如何提升系统的并发能力\n>互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。\n\n\n### 垂直扩展\n提升单机处理能力。垂直扩展的方式又有两种：\n\n1. 增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G，带宽；\n2. 提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；\n\n\n### 水平扩展\n下面的图是常见的互联网分层架构\n![logo](/images/server/java/三高/20180607142425564.jpg) \n\n#### 常见互联网分布式架构\n\n（1）客户端层：典型调用方是浏览器browser或者手机应用APP\n\n（2）反向代理层：系统入口，反向代理\n\n（3）站点应用层：实现核心应用逻辑，返回html或者json\n\n（4）服务层：如果实现了服务化，就有这一层\n\n（5）数据-缓存层：缓存加速访问存储\n\n（6）数据-数据库层：数据库固化数据存储\n\n\n#### 各分层水平扩展架构实践\n\n> 反向代理层的水平扩展: 配置多个服务器数量\n\n反向代理层的水平扩展，是通过“DNS轮询”实现的：dns-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。\n\n当nginx成为瓶颈的时候，只要增加服务器数量，新增nginx服务的部署，增加一个外网ip，就能扩展反向代理层的性能，做到理论上的无限高并发。\n\n> 站点层的水平扩展: 配置多个web服务\n\n站点层的水平扩展，是通过“nginx”实现的。通过修改nginx.conf，可以设置多个web后端。\n\n当web后端成为瓶颈的时候，新增web服务的部署，在nginx配置中配置上新的web后端，就能扩展站点层的性能，做到理论上的无限高并发。\n\n> 服务层的水平扩展\n\n1.服务层的水平扩展，是通过“服务连接池”实现的。\n\n站点层通过RPC-client调用下游的服务层RPC-server时，RPC-client中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在RPC-client处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。\n\n2.动静分离，页面静态化，CDN加速\n\n3.不要频繁的new对象,对于在整个应用中只需要存在一个实例的类使用单例模式\n\n> 数据层的水平扩展：缓存，数据库\n\n在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。\n\n## 三、如何处理高并发线程安全问题\n### Java进程加锁\n\n### 乐观锁与悲观锁\n#### 乐观锁\n乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。\n\n#### 悲观锁\n悲观锁，指数据被外界修改持保守态度(悲观),在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 。数据库中实现是对数据记录进行操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。\n\n一个例子：select * from 表 where .. for update;\n\n悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。\n\n乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。\n\n参考: https://blog.csdn.net/DreamWeaver_zhou/article/details/78587580","tags":["Java"],"categories":["server"]},{"title":"算法(一)Java经典算法","url":"/2018/04/01/backend/java/algorithm/算法(一)Java经典算法/","content":"## 排序算法\n\n### 冒泡排序\n```java\n       public void bubbleSort(int []a){\n           int len=a.length;\n           for(int i=0;i<len;i++){\n               for(int j=0;j<len-i-1;j++){//注意第二重循环的条件\n                   if(a[j]>a[j+1]){\n                       int temp=a[j];\n                       a[j]=a[j+1];\n                       a[j+1]=temp;\n                   }\n               }\n           }\n       }\n```\n### 选择排序\n```java\n    public void selectSort(int[]a){\n        int len=a.length;\n        for(int i=0;i<len;i++){//循环次数\n            int value=a[i];\n            int position=i;\n            for(int j=i+1;j<len;j++){//找到最小的值和位置\n                if(a[j]<value){\n                    value=a[j];\n                    position=j;\n                }\n            }\n            a[position]=a[i];//进行交换\n            a[i]=value;\n        }\n    }\n```\n## 查找算法\n### 二分查找\n```java\nimport java.util.Scanner;\n/*\n * 二分查找\n */\npublic class BinarySearch {\n    public static void main(String[] args) {\n        int[] arr={5,3,6,1,9,8,2,4,7};\n        //先打印输出原始数组数据\n        System.out.println(\"原始数组数据如下：\");\n        for (int n : arr) {\n            System.out.print(n+\" \");\n        }\n        System.out.println();\n        //首先对数组进行排序，这里用冒泡排序\n        for(int i=0;i<arr.length-1;i++){\n            for(int j=0;j<arr.length-1-i;j++){\n                if(arr[j]>arr[j+1]){\n                    int temp=arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=temp;\n                }\n            }\n        }\n        //遍历输出排序好的数组\n        System.out.println(\"经过冒泡排序后的数组：\");\n        for(int n:arr){\n            System.out.print(n+\" \");\n        }\n        System.out.println();//换行\n        Scanner input=new Scanner(System.in);\n        System.out.println(\"请输入你要查找的数：\");\n        int num=input.nextInt();\n        int result=binarySearch(arr, num);\n        if(result==-1){\n            System.out.println(\"你要查找的数不存在……\");\n        }\n        else{\n            System.out.println(\"你要查找的数存在，在数组中的位置是：\"+result);\n        }\n    }\n    //二分查找算法\n    public static int binarySearch(int[] arr,int num){\n    \n        int low=0;\n        int upper=arr.length-1;\n        while(low<=upper){\n            int mid=(upper+low)/2;\n            if(arr[mid]<num){\n                low=mid+1;\n            }\n            else if(arr[mid]>num){\n                upper=mid-1;\n            }\n            else\n                return mid;\n        }\n        return -1;\n    }\n}\n```","tags":["Java"],"categories":["server"]},{"title":"Windows批处理(cmd/bat)常用命令","url":"/2018/03/24/backend/windows bat/","content":"#### 需求\n在使用hexo写博客的时候, hexo d 老是不能把代码push上去，网上找了好多方法都不能解决, 只能自己手动把`public`文件下生成的文件自己敲git命令push上传, 每次写博客的时候都要执行这种操作, 次数多了会感觉厌烦, 所有想windows不是有批处理脚本吗, 所以自己查阅了一些资料, 写了一个草鸡简单的脚本\n\n* auto.bat\n```sql\n# 文件上传commit\ngit add -A\n\ngit commit -m \"auto commit\"\n\ngit push\n\necho copy file\nxcopy D:\\workspace\\hexo-log-bak\\hexo-log-bak\\public\\*.* D:\\workspace\\hexo-log-upload\\songshuiyang.github.io /s /y\n\necho 提交songshuiyang.github.io 文件\ncd ../../hexo-log-upload\\songshuiyang.github.io\n\ngit add -A\n\ngit commit -m \"auto commit\"\n\ngit push\n\ncd ../../hexo-log-bak/hexo-log-bak\n\n```\n<!--more-->\n#### 批处理文件\n批处理文件（batch file）包含一系列 DOS命令，通常用于自动执行重复性任务。用户只需双击批处理文件便可执行任务，而无需重复输入相同指令。编写批处理文件非常简单，但难点在于确保一切按顺序执行。编写严谨的批处理文件可以极大程度地节省时间，在应对重复性工作时尤其有效。\n\n在Windows中善用批处理可以简化很多重复工作\n\n##### 常用DOS命令\n```sql\n文件夹管理\n\n    cd 显示当前目录名或改变当前目录。\n    md 创建目录。\n    rd 删除一个目录。\n    dir 显示目录中的文件和子目录列表。\n    tree 以图形显示驱动器或路径的文件夹结构。\n    path 为可执行文件显示或设置一个搜索路径。\n    xcopy 复制文件和目录树。\n\n\n文件管理\n\n    type 显示文本文件的内容。\n    copy 将一份或多份文件复制到另一个位置。\n    del 删除一个或数个文件。\n    move 移动文件并重命名文件和目录。(Windows XP Home Edition中没有)\n    ren 重命名文件。\n    replace 替换文件。\n    attrib 显示或更改文件属性。\n    find 搜索字符串。\n    fc 比较两个文件或两个文件集并显示它们之间的不同\n网络命令\n\n    ping 进行网络连接测试、名称解析\n    ftp 文件传输\n    net 网络命令集及用户管理\n    telnet 远程登陆\n    ipconfig显示、修改TCP/IP设置\n    msg 给用户发送消息\n    arp 显示、修改局域网的IP地址-物理地址映射列表\n    \n系统管理\n\n    at 安排在特定日期和时间运行命令和程序\n    shutdown立即或定时关机或重启\n    tskill 结束进程\n    taskkill结束进程(比tskill高级，但WinXPHome版中无该命令)\n    tasklist显示进程列表(Windows XP Home Edition中没有)\n    sc 系统服务设置与控制\n    reg 注册表控制台工具\n    powercfg控制系统上的电源设置\n```\n\n##### 例子\n","tags":["java"],"categories":["server"]},{"title":"Spring 集成Encache","url":"/2018/03/24/backend/framework/cache/Encache/","content":"### 一：Encache\n\n#### 1. 什么是Encache\nEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。\n\n官网: http://www.ehcache.org/\n\n#### 2. 基本介绍\nEhcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。\n\nEhcache最初是由Greg Luck于2003年开始开发。2009年,该项目被Terracotta购买。软件仍然是开源,但一些新的主要功能(例如，快速可重启性之间的一致性的)只能在商业产品中使用，例如Enterprise EHCache and BigMemory。维基媒体Foundationannounced目前使用的就是Ehcache技术。\n\n<!--more-->\n#### 3. 特点\n主要的特性有：\n1. 快速\n2. 简单\n3. 多种缓存策略\n4. 缓存数据有两级：内存和磁盘，因此无需担心容量问题\n5. 缓存数据会在虚拟机重启的过程中写入磁盘\n6. 可以通过RMI、可插入API等方式进行分布式缓存\n7. 具有缓存和缓存管理器的侦听接口\n8. 支持多缓存管理器实例，以及一个实例的多个缓存区域\n9. 提供Hibernate的缓存实现\n\n\n#### ehcache与redis的区别\n1.redis的数据结构比较丰富，有key-value、hash、set等；ehcache比较简单，只有key-value\n\n2.ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。redis是通过socket访问到缓存服务，效率ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。\n\n### 二: Encache与Spring 集成\n#### 1. 前言\nSpring自身并没有实现缓存解决方案，但是对缓存管理功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。\n\nSpring Cache是作用在方法上的（不能理解为只注解在方法上），其核心思想是：当我们在调用一个缓存方法时会把该方法参数和返回结果作为一个键值存放在缓存中，等到下次利用同样的参数调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。所以在使用Spring Cache的时候我们要保证我们的缓存的方法对于相同的方法参数要有相同的返回结果。\n\n#### 2. 开始集成\n* 导入依赖\n```xml\n        <dependency>\n            <groupId>net.sf.ehcache</groupId>\n            <artifactId>ehcache</artifactId>\n            <version>2.10.3</version>\n        </dependency>\n```\n* 编写ehcache.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\">\n\n    <!-- 磁盘缓存位置 在Windows的缓存目录为：C:\\Users\\登录用户~1\\AppData\\Local\\Temp\\    Linux：/tmp -->\n    <diskStore path=\"java.io.tmpdir/ehcache\"/>\n\n    <!--name：缓存名称。-->\n    <!--maxElementsInMemory：缓存最大个数。-->\n    <!--eternal：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。-->\n    <!--timeToIdleSeconds：置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。-->\n    <!--timeToLiveSeconds：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。-->\n    <!--maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。-->\n    <!--overflowToDisk：内存不足时，是否启用磁盘缓存。-->\n    <!--diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。-->\n    <!--maxElementsOnDisk：硬盘最大缓存个数。-->\n    <!--diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。-->\n    <!--diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。-->\n    <!--memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。-->\n    <!--clearOnFlush：内存数量最大时是否清除。-->\n\n    <!--@Cacheable(value = \"users\", condition = \"#user.getId() <= 2\")-->\n    <!--@CachePut(value = \"users\", key = \"#user.getId()\")-->\n    <!--@CacheEvict(value = \"users\", allEntries = true)-->\n\n\n    <!-- 默认缓存 -->\n    <defaultCache\n            maxEntriesLocalHeap=\"10000\"\n            eternal=\"false\"\n            timeToIdleSeconds=\"120\"\n            timeToLiveSeconds=\"120\"\n            maxEntriesLocalDisk=\"10000000\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n        <persistence strategy=\"localTempSwap\"/>\n    </defaultCache>\n\n    <!-- 博客文章详情缓存 -->\n    <cache name=\"articlesDetail\"\n           maxElementsInMemory=\"1000\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"120\"\n           timeToLiveSeconds=\"120\"\n           overflowToDisk=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\"/>\n\n    <!-- hotArticles缓存 -->\n    <cache name=\"articlesDetail\"\n           maxElementsInMemory=\"1000\"\n           eternal=\"true\"\n           overflowToDisk=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\"/>\n\n</ehcache>\n```\n* 在需要缓存的地方加上缓存注解\n```java\n    /**\n     * 第一次执行会缓存文章,以id作为key, 第二次会直接取缓存的数据(需要在缓存有效期,过期会重新查询数据库)\n     * @param id\n     * @return\n     */\n    @Override\n    @Cacheable(value = \"articlesDetail\", key = \"#id\")\n    public BlogArticles selectByPrimaryKey(Integer id) {\n        return getMappser().selectByPrimaryKey(id);\n    }\n\n    /**\n     * 保存文章，同时删除record.getId()该已存的缓存数据\n     * @param record\n     * @return\n     */\n    @Override\n    @CacheEvict(value = \"articlesDetail\", key = \"#record.getId()\")\n    public int updateByPrimaryKeySelective(BlogArticles record) {\n        setCurrentOperator(record);\n        return getMappser().updateByPrimaryKeySelective(record);\n    }\n```\n#### 3. 注解讲解\n首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。\n* @Cacheable\n\n```sql\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 \n这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 \n可以使用key属性来指定key的生成规则。\n\n@Cacheable 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中\n  key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId，\n\n  一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， \n  本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等\n\n  condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL\n  \n  \n  // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1'\n  @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\")    \n  public User findById(String userId) {    \n      return (User) new User(\"1\", \"mengdee\");           \n  }    \n  \n  // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key\n  // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\"\n  @Cacheable(value=\"UserCache\", condition=\"#userId.length() < 12\")    \n  public boolean isReserved(String userId) {    \n      System.out.println(\"UserCache:\"+userId);    \n      return false;    \n  }\n```\n* @CachePut\n\n```sql\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。\n```\n\n* @CacheEvict\n```sql\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。\n\n@CacheEvict 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，同上\n  key：缓存的key，默认为空，同上\n  condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL\n  allEntries：true表示清除value中的全部缓存，默认为false\n\n  //清除掉UserCache中某个指定key的缓存    \n  @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\")    \n  public void removeUser(User user) {    \n      System.out.println(\"UserCache\"+user.getUserId());    \n  }    \n  \n  //清除掉UserCache中全部的缓存    \n  @CacheEvict(value=\"UserCache\", allEntries=true)    \n  public final void setReservedUsers(String[] reservedUsers) {    \n     System.out.println(\"UserCache deleteall\");    \n  }\n  \n  \n```\n* @Caching\n```sql\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") })\npublic Book importBooks(String deposit, Date date)\n\n```\n* @CacheConfig\n```sql\n与前面的缓存注解不同，这是一个类级别的注解。\n 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig(\"books\")\npublic class BookRepositoryImpl implements BookRepository {\n    @Cacheable\n    public Book findBook(ISBN isbn) {...}\n}\n\n```\n\n#### 4. 创建Cache工具类, 方便对cache进行管理\n``` java\npackage com.ecut.core.utils;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.Cache;\nimport org.springframework.cache.CacheManager;\n\n/**\n * 缓存工具类\n * @author songshuiyang\n * @date 2018/3/24 12:16\n */\npublic class CacheUtils {\n\n    private final static Logger logger = LoggerFactory.getLogger(CacheUtils.class);\n\n    private static CacheManager cacheManager = (CacheManager) SpringContextUtils.getBean(\"cacheManager\");\n\n    /**\n     * 获取缓存\n     * @param cacheName 缓存名\n     * @param key 键\n     * @return Object\n     */\n    public static Object get(String cacheName, Object key) {\n        Cache cache = cacheManager.getCache(cacheName);\n        if (cache != null) {\n            //这里需要判断是否null\n            if(cache.get(key) != null){\n                return cache.get(key).get();\n            }\n        }\n        return null;\n    }\n    /**\n     * 添加缓存\n     * 存在则更新\n     * @param cacheName 缓存名\n     * @param key 键\n     * @param value 值\n     */\n    public static void put(String cacheName, Object key, Object value) {\n        Cache cache = cacheManager.getCache(cacheName);\n        if(cache != null){\n            cache.put(key, value);\n        }\n    }\n    /**\n     * 清除缓存\n     * @param cacheName 缓存名\n     * @param key 键\n     */\n    public static void remove(String cacheName, Object key) {\n        Cache cache = cacheManager.getCache(cacheName);\n        if (cache != null) {\n            cache.evict(key);\n        }else{\n            logger.warn(\"this key is not in Cache\");\n        }\n    }\n}\n\n}\n\n```\n\n参考： \nhttps://blog.csdn.net/vbirdbest/article/details/72763048\nhttp://www.cnblogs.com/jingmoxukong/p/5975994.html","tags":["java"],"categories":["server"]},{"title":"hover.css","url":"/2018/03/20/frontend/hover/","content":"### Hover.css\nA collection of CSS3 powered hover effects to be applied to links, buttons, logos, SVG, featured images and so on. Easily apply to your own elements, modify or just use for inspiration. Available in CSS, Sass, and LESS.\n\n官网地址: http://ianlunn.github.io/Hover/\n\n演示地址: http://wow.techbrood.com/fiddle/852\n\n\n\n\n\n","tags":["css"],"categories":["client"]},{"title":"Linux 命令笔记","url":"/2018/03/08/backend/server/Linux/linux笔记/","content":"1. 出现问题 `bash: service: command not found`, \n\n解决方法：\n```sql\nyum install initscripts\n```\n2. 查看端口\n```sql\n# 查看80端口占用情况\nlsof -i tcp:80\n\n# 列出所有端口\nnetstat -ntlp\n\n# 查看端口状态\nnetstat -lnp|grep 88   #88请换为你的apache需要的端口，如：80\n\n# SSH执行以上命令，可以查看到88端口正在被哪个进程使用。如下图，进程号为 1777 。\n\n# 查看进程的详细信息\nps 1777\n\n# 杀掉进程\nkill -9 1777        #杀掉编号为1777的进程（请根据实际情况输入）\n```","tags":["server"],"categories":["服务器"]},{"title":"Docker笔记","url":"/2018/03/08/backend/server/Linux/Docker笔记/","content":"#### 什么是Docker\nDocker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了。作为一名 Java 程序员，我们是时候一起把 Docker 学起来了！\n\n1.传统虚拟化技术的体系架构：\n\n![logo](/images/server/docker/virtual mechine.png) \n\n可见，我们在宿主机的操作系统上，可安装了多个虚拟机，而在每个虚拟机中，通过虚拟化技术，实现了一个虚拟操作系统，随后，就可以在该虚拟操作系统上，安装自己所需的应用程序了。这一切看似非常简单，但其中的技术细节是相当高深莫测的，大神级人物都不一定说得清楚。\n<!--more-->\n\n凡是使用过虚拟机的同学，应该都知道，启动虚拟机就像启动一台计算机，初始化过程是相当慢的，我们需要等很久，才能看到登录界面。一旦虚拟机启动以后，就可以与宿主机建立网络连接，确保虚拟机与宿主机之间是互联互通的。不同的虚拟机之间却是相互隔离的，也就是说，彼此并不知道对方的存在，但每个虚拟机占用的都是宿主机的硬件与网络资源。\n\n2.Docker 技术的体系架构\n\n![logo](/images/server/docker/virtual mechine.png) \n\n可见，在宿主机的操作系统上，有一个 Docker 服务在运行（或者称为“Docker 引擎”），在此服务上，我们可开启多个 Docker 容器，而每个 Docker 容器中可运行自己所需的应用程序，Docker 容器之间也是相互隔离的，同样地，都是占用的宿主机的硬件与网络资源。、\n\nDocker 容器相对于虚拟机而言，除了在技术实现上完全不一样以外，启动速度较虚拟机而言有本质的飞跃，启动一个容器只在眨眼瞬间。不管是虚拟机还是 Docker 容器，它们都是为了隔离应用程序的运行环境，节省我们的硬件资源，为我们开发人员提供福利。\n\n\n3.Docker 的 Logo:\n\n![logo](/images/server/docker/docker logo.png) \n\n很明显，这是一只鲸鱼，它托着许多集装箱。我们可以把宿主机可当做这只鲸鱼，把相互隔离的容器可看成集装箱，每个集装箱中都包含自己的应用程序。这 Logo 简直的太形象了！\n\n4.Docker的应用场景\n```sql\n1. Web 应用的自动化打包和发布。\n\n2. 自动化测试和持续集成、发布。\n\n3. 在服务型环境中部署和调整数据库或其他的后台应用。\n```\n5.Docker 的优点\n```sql\n1、简化程序：\nDocker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的\t任务，在Docker容器的处理下，只需要数秒就能完成。\n\n2、避免选择恐惧症：\n如果你有选择恐惧症，还是资深患者。Docker 帮你\t打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。\n\n3、节省开支：\n一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。\n```\n#### Docker 术语\n\n   |     术语 | 说明    | \n    | --------   | --------------------:   | \n    |  Docker 镜像(Images)       | Docker 镜像是用于创建 Docker 容器的模板。 |\n    |  Docker 容器(Container)        | 容器是独立运行的一个或一组应用。     |\n    |  Docker 客户端(Client)     | Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 |\n    |  Docker 主机(Host)      |一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。     |\n    |  Docker 仓库(Registry) |      Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。|\n    |  Docker Machine       | Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。      |\n\n\n#### 使用Docker前先配置 Docker国内镜像或者使用registry-mirrors配置加速\n\n由于国内访问直接访问Docker hub网速比较慢，拉取镜像的时间就会比较长。一般我们会使用镜像加速或者直接从国内的一些平台镜像仓库上拉取。 \n\n```sql\n方法一： 网易镜像中心：https://c.163.com/hub#/m/home/ \n\n拉取镜像的命令是： docker pull 镜像名字 所以我们可以按照给出的镜像名字或者命令直接拉取。\n\neg: docker pull hub.c.163.com/library/tomcat:latest\n\n\n方法二： daocloud镜像市场：https://hub.daocloud.io/\n\n如果说还是想从dockerhub上拉取，那么使用加速器修改docker的registry-mirrors。这里使用的是DaoCloud的加速器。 \n\n首先在http://www.daocloud.io/进行注册登录。然后点击加速器，得到如下脚本\n\n    curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://24524c4f.m.daocloud.io Copy\n    该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。\n \n也可以自己手动修改 /etc/docker/daemon.json\n\n{\n \"registry-mirrors\": [\"http://ef017c13.m.daocloud.io\"],\n \"live-restore\": true\n}\n\n最后重启docker service docker restart\n```\n#### 安装 Docker\n1.前提条件\n```sql\n使用 yum 安装（CentOS 7下）\n\nDocker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n通过 uname -r 命令查看你当前的内核版本\n\n```\n2.安装\n```sql\nyum -y install docker\n```\n3.启动服务\n```sql\nservice docker start\n```\n4.测试运行 hello-world\n```sql\ndocker run hello-world\n```\n\n#### Docker中使用CentOS7镜像\n1.启动容器服务\n```genericsql\nsystemctl start docker.service \n```\n2.下载CentOS7 镜像\n```genericsql\n[root@JD docker]# docker pull centos:7.3.1611\nTrying to pull repository docker.io/library/centos ... \n7.3.1611: Pulling from docker.io/library/centos\n\n版本: https://hub.docker.com/_/centos/ 可以在这个网站上选择自己想要的版本\n  latest, centos7, 7 (docker/Dockerfile)\n  centos6, 6 (docker/Dockerfile)\n  centos7.4.1708, 7.4.1708 (docker/Dockerfile)\n  centos7.3.1611, 7.3.1611 (docker/Dockerfile)\n  centos7.2.1511, 7.2.1511 (docker/Dockerfile)\n  centos7.1.1503, 7.1.1503 (docker/Dockerfile)\n  centos7.0.1406, 7.0.1406 (docker/Dockerfile)\n  centos6.9, 6.9 (docker/Dockerfile)\n  centos6.8, 6.8 (docker/Dockerfile)\n  centos6.7, 6.7 (docker/Dockerfile)\n  centos6.6, 6.6 (docker/Dockerfile)\n```\n3.下载成功之后查看本地所有的镜像，得到centos的 IMAGE ID: 66ee80d59a68\n```sql\n[root@JD ~]# docker images\nREPOSITORY              TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/tomcat        latest              108db0e7c85e        2 weeks ago         557.4 MB\ndocker.io/hello-world   latest              f2a91732366c        3 months ago        1.848 kB\ndocker.io/centos        7.3.1611            66ee80d59a68        4 months ago        191.8 MB\n```\n\n4.启动docker中的CentOS7\n```sql\ndocker run -ti 66ee /bin/bash\n#6866 是 IMAGE ID 前四位数字-能区分出是哪个image即可\n\nroot@b4ad1d1c87da /]# \n#登录成功，接下来就可以为所欲为啦。\n\n命令笔记\n  容器是在镜像的基础上来运行的，一旦容器启动了，我们就可以登录到容器中，安装自己所需的软件或应用程序。既然镜像已经下载到本地，那么如何才能启动容器呢\n  \n  docker run -i -t -v /root/software/:/mnt/software/ 25c5298b1a36 /bin/bash\n\n  docker run <相关参数> <镜像 ID> <初始命令>\n\n    -i：表示以“交互模式”运行容器\n    -t：表示容器启动后会进入其命令行\n    -v：表示需要将本地哪个目录挂载到容器中，格式：-v <宿主机目录>:<容器目录>\n    假设我们的所有安装程序都放在了宿主机的/root/software/目录下，现在需要将其挂载到容器的/mnt/software/目录下。\n    \n  初始命令表示一旦容器启动，需要运行的命令，此时使用“/bin/bash”，表示什么也不做，只需进入命令行即可。\n\n\n\n```\n5.检查CentOS7系统\n```sql\nroot@b4ad1d1c87da  /]# uname -a\nLinux b4ad1d1c87da 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\n[root@b4ad1d1c87da /]# cat /etc/redhat-release \nCentOS Linux release 7.2.1511 (Core)\n```\n6.退出\n```sql\n  ctrl+d 退出容器且关闭, \n  docker ps 查看无,\n  ctrl+p+q 退出容器但不关闭, \n  docker ps\n```\n \n7.再进入CentOS7\n```sql\n[root@wxtest1607 ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nb4ad1d1c87da        6866                \"/bin/bash\"         12 seconds ago      Up 9 seconds                            mad_swanson\n                  drunk_hypatia\n得到 CONTAINER ID         \n[root@wxtest1607 ~]# docker exec -ti b4ad /bin/bash  \n[root@b4ad1d1c87da /]#\n\n```\n8.安装tomcat \n```sql\n 1. yum -y install tomcat\n \n 注：\n        在docker中通过systemctl 启动服务的时候总是报Failed to get D-Bus connection: Operation not permitted 这样的错误提示。\n     解决方法：\n        解决办法就是在docker run 的时候运行/usr/sbin/init 。比如：\n        docker run -ti 66ee /usr/sbin/init\n 2. 在Centos使用yum安装后，Tomcat相关的目录都已采用符号链接到/usr/share/tomcat6目录，包含webapps等，这很方便我们配置管理\n```\n\n转载：http://www.runoob.com/docker/docker-tutorial.html\n\n转载：http://developer.51cto.com/art/201702/529956.htm\n\n转载：http://www.jb51.net/article/112921.htm\n\n转载：https://www.jianshu.com/p/0aa535e681f5","tags":["server"],"categories":["服务器"]},{"title":"Mysql 用户及权限管理","url":"/2018/03/07/backend/database/Mysql 用户及权限管理d/","content":"### 权限控制\n授权语法：\n```sql\n    GRANT privileges (columns) ON what TO user IDENTIFIED BY \"password\" WITH GRANT OPTION\n    \n    权限列表:\n    ALTER: 修改表和索引。\n    CREATE: 创建数据库和表。\n    DELETE: 删除表中已有的记录。\n    DROP: 抛弃(删除)数据库和表。\n    INDEX: 创建或抛弃索引。\n    INSERT: 向表中插入新行。\n    REFERENCE: 未用。\n    SELECT: 检索表中的记录。\n    UPDATE: 修改现存表记录。\n    FILE: 读或写服务器上的文件。\n    PROCESS: 查看服务器中执行的线程信息或杀死线程。\n    RELOAD: 重载授权表或清空日志、主机缓存或表缓存。\n    SHUTDOWN: 关闭服务器。\n    ALL: 所有权限，ALL PRIVILEGES同义词。\n    USAGE: 特殊的 \"无权限\" 权限。\n    用 户账户包括 \"username\" 和 \"host\" 两部分，后者表示该用户被允许从何地接入。tom@'%' 表示任何地址，默认可以省略。还可以是 \"tom@192.168.1.%\"、\"tom@%.abc.com\" 等。数据库格式为 db@table，可以是 \"test.*\" 或 \"*.*\"，前者表示 test 数据库的所有表，后者表示所有数据库的所有表。\n    子句 \"WITH GRANT OPTION\" 表示该用户可以为其他用户分配权限。 \n```\n<!--more-->\n实例：\n\n```sql\n  use mysql\n\n  1. 新建用户, 并赋予所有数据库权限\n    GRANT ALL PRIVILEGES ON *.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION;\n  \n    说明:\n      1. username - 你将创建的用户名, host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.\n      2. 指定helloworld数据库: GRANT ALL PRIVILEGES ON helloword.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION;\n  \n  2. 指定该用户只能执行 select 和 update 命令\n    GRANT SELECT, UPDATE ON *.* TO 'username'@'%' IDENTIFIED BY 'password';\n  \n  3. 另外每当调整权限后，通常需要执行以下语句刷新权限：\n    FLUSH PRIVILEGES;\n\n  4. grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。\n    grant select on testdb.* to common_user@’%’\n    grant insert on testdb.* to common_user@’%’\n    grant update on testdb.* to common_user@’%’\n    grant delete on testdb.* to common_user@’%’\n    或者，用一条 MySQL 命令来替代：\n    grant select, insert, update, delete on testdb.* to common_user@’%’\n```\n\n### 用户\n```sql\n  1. 删除刚才创建的用户：\n    DROP USER username@localhost;\n  \n  2. 查看用户创建是否成功\n    select user,host from user ;\n    \n    +-----------+-----------+\n    | user      | host      |\n    +-----------+-----------+\n    | root      | %         |\n    | select    | %         |\n    | server    | %         |\n    | shuiyang  | %         |\n    | user      | %         |\n    | mysql.sys | localhost |\n    +-----------+-----------+\n    \n  3. 查看select用户的授权\n   show grants for select;\n   \n   MySQL [mysql]>  show grants for `select`;\n   +---------------------------------------------+\n   | Grants for select@%                         |\n   +---------------------------------------------+\n   | GRANT SELECT, UPDATE ON *.* TO 'select'@'%' |\n   +---------------------------------------------+\n   1 row in set (0.00 sec)\n   \n  4. 设置与更改用户密码\n  \n  SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword')\n  \n  如果是当前登陆用户用\n  \n  SET PASSWORD = PASSWORD(\"newpassword\");\n  \n```\n  \n  ","tags":["mysql"],"categories":["server"]},{"title":"Mysql 字符集和排序规则说明","url":"/2018/03/07/backend/database/Mysql 字符集和排序规则说明/","content":"### 字符集\n\n#### utf8mb4 和 utf8 比较\nUTF-8是使用1~4个字节，一种变长的编码格式。（字符编码 ）\n\nmb4即 most bytes 4，使用4个字节来表示完整的UTF-8。而MySQL中的utf8是utfmb3，只有三个字节，节省空间但不能表达全部的UTF-8，只能支持“基本多文种平面”（Basic Multilingual Plane，BMP）。\n\n推荐使用utf8mb4。\n\n### 排序规则\nci 是 case insensitive, 即 “大小写不敏感”, a 和 A 会在字符判断中会被当做一样的。 \n\nbin 是二进制, a 和 A 会别区别对待。 \n\n例如你运行如下sql, 那么在utf8_bin中你就找不到 txt = ‘A’ 的那一行, 而 utf8_general_ci 则可以。\n```sql\nSELECT * FROM table WHERE txt = 'a';\n```\n#### 常用排序规则\n1. utf8_general_ci：不区分大小写，这个你在注册用户名和邮箱的时候就要使用。 \n2. utf8_general_cs：区分大小写，如果用户名和邮箱用这个 就会照成不良后果。 \n3. utf8_bin：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容。\n\n#### 总结\n1. utf8_unicode_ci和utf8_general_ci对中、英文来说没有实质的差别。 \n2. utf8_general_ci：校对速度快，但准确度稍差。 \n3. utf8_unicode_ci：准确度高，但校对速度稍慢。 \n4. 如果你的应用有德语、法语或者俄语，请一定使用utf8_unicode_ci。一般用utf8_general_ci就够了，到现在也没发现问题。\n\n\n参考:\nhttps://www.cnblogs.com/zwakeup/p/8267204.html","tags":["mysql"],"categories":["server"]},{"title":"Centos7安装Mysql5.7.md","url":"/2018/03/07/backend/server/Linux/Centos7安装Mysql5.7/","content":"#### 一：配置YUM源\n>官网地址 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/\n\n1.下载mysql源安装包\n```sql\nwget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm\n```\n 命令笔记:\n```sql\nwget:\n用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用\n\n-a<日志文件>：在指定的日志文件中记录资料的执行过程；\n-A<后缀名>：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；\n-b：进行后台的方式运行wget；\n-B<连接地址>：设置参考的连接地址的基地地址；\n-c：继续执行上次终端的任务；\n-C<标志>：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；\n-d：调试模式运行指令；\n-D<域名列表>：设置顺着的域名列表，域名之间用“，”分隔；\n-e<指令>：作为文件“.wgetrc”中的一部分执行指定的指令；\n-h：显示指令帮助信息；\n-i<文件>：从指定文件获取要下载的URL地址；\n-l<目录列表>：设置顺着的目录列表，多个目录用“，”分隔；\n-L：仅顺着关联的连接；\n-r：递归下载方式；\n-nc：文件存在时，下载文件不覆盖原有文件；\n-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；\n-q：不显示指令执行过程；\n-nh：不查询主机名称；\n-v：显示详细执行过程；\n-V：显示版本信息；\n--passive-ftp：使用被动模式PASV连接FTP服务器；\n--follow-ftp：从HTML文件中下载FTP连接文件\n\n下载并以不同的文件名保存:\nwget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080\n\n```\n<!--more-->\n\n2.安装mysql源\n```sql\nyum localinstall mysql57-community-release-el7-8.noarch.rpm\n```\n\n 命令笔记:\n```sql\nyum命令\n\n是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\n\n选项:\n-h：显示帮助信息；\n-y：对所有的提问都回答“yes”；\n-c：指定配置文件；\n-q：安静模式；\n-v：详细模式；\n-d：设置调试等级（0-10）；\n-e：设置错误等级（0-10）；\n-R：设置yum处理一个命令的最大等待时间；\n-C：完全从缓存中运行，而不去下载或者更新任何头文件。\n\n参数：\ninstall：安装rpm软件包；\nupdate：更新rpm软件包；\ncheck-update：检查是否有可用的更新rpm软件包；\nremove：删除指定的rpm软件包；\nlist：显示软件包的信息；\nsearch：检查软件包的信息；\ninfo：显示指定的rpm软件包的描述信息和概要信息；\nclean：清理yum过期的缓存；\nshell：进入yum的shell提示符；\nresolvedep：显示rpm软件包的依赖关系；\nlocalinstall：安装本地的rpm软件包；\nlocalupdate：显示本地rpm软件包进行更新；\ndeplist：显示rpm软件包的所有依赖关系。\n\n\n实例\n部分常用的命令包括：\n\n自动搜索最快镜像插件：yum install yum-fastestmirror\n安装yum图形窗口插件：yum install yumex\n查看可能批量安装的列表：yum grouplist\n```\n3.检查mysql源是否安装成功\n```sql\nyum repolist enabled | grep \"mysql.*-community.*\"\n```\n![logo](/images/server/linux/mysql_install_success.png) \n\n看到上图所示表示mysql源安装成功。\n\n可以修改vim /etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。比如要安装5.6版本，将5.7源的enabled=1改成enabled=0。然后再将5.6源的enabled=0改成enabled=1即可 \n\n#### 二 安装MySQL\n```sql\n yum install mysql-community-server\n```\n命令笔记:\n```sql\n安装\n\nyum install              #全部安装\nyum install package1     #安装指定的安装包package1\nyum groupinsall group1   #安装程序组group1\n\n更新和升级\n\nyum update               #全部更新\nyum update package1      #更新指定程序包package1\nyum check-update         #检查可更新的程序\nyum upgrade package1     #升级指定程序包package1\nyum groupupdate group1   #升级程序组group1\n\n\n查找和显示\n\nyum info package1      #显示安装包信息package1\nyum list               #显示所有已经安装和可以安装的程序包\nyum list package1      #显示指定程序包安装情况package1\nyum groupinfo group1   #显示程序组group1信息yum search string 根据关键字string查找安装包\n\n删除程序\n\nyum remove &#124; erase package1   #删除程序包package1\nyum groupremove group1             #删除程序组group1\nyum deplist package1               #查看程序package1依赖情况\n```\n\n#### 三：启动MySQL服务\n1.启动\n```sql\n systemctl start mysqld\n```\n命令笔记：\n```sql\nsystemctl\n\n是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。\n\n任务\t                旧指令\t                        新指令\n使某服务自动启动\t    chkconfig --level 3 httpd on\tsystemctl enable httpd.service\n使某服务不自动启动\tchkconfig --level 3 httpd off\tsystemctl disable httpd.service\n检查服务状态\t        service httpd status\t        systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active)\n显示所有已启动的服务\tchkconfig --list\t            systemctl list-units --type=service\n启动某服务\t        service httpd start\t            systemctl start httpd.service\n停止某服务\t        service httpd stop\t            systemctl stop httpd.service\n重启某服务\t        service httpd restart\t        systemctl restart httpd.service\n\n```\n2.查看状态\n```sql\n查看MySQL的启动状态\nsystemctl status mysqld\n\n输出：\n● mysqld.service - MySQL Server\n   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)\n   Active: active (running) since Wed 2018-03-07 21:14:55 CST; 18min ago\n     Docs: man:mysqld(8)\n           http://dev.mysql.com/doc/refman/en/using-systemd.html\n  Process: 17338 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)\n  Process: 17320 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)\n Main PID: 17343 (mysqld)\n   CGroup: /system.slice/mysqld.service\n           └─17343 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid\n\nMar 07 21:14:54 VM_0_8_centos systemd[1]: Starting MySQL Server...\nMar 07 21:14:55 VM_0_8_centos systemd[1]: Started MySQL Server.\n\n```\n3.开机启动\n```sql\nsystemctl enable mysqld\nsystemctl daemon-reload\n```\n4.修改root本地登录密码\n```sql\nmysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：\n1. 修改密码策略\n      mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误\n\n   步骤1：不需要密码策略，添加/etc/my.cnf件中添加如下配置禁用即可：\n   validate_password = off\n   步骤2：重新启动mysql服务使配置生效：\n   systemctl restart mysqld   \n\n2. 查看初始密码： \n      grep 'temporary password' /var/log/mysqld.log\n   输出： \n      2018-03-07T13:01:08.963552Z 1 [Note] A temporary password is generated for root@localhost: zktt1wKFD.HN\n\n   得到临时密码: zktt1wKFD.HN\n\n3. 登录mysql: \n      mysql -uroot -p\n   输入临时密码进入mysql命令行\n\n4. 修改密码\n    set password for 'root'@'localhost'=password('MyNewPass4!');\n    \n5. 重启服务\n   systemctl restart mysqld   \n```\n#### 四：开启远程连接\n```sql\n登入mysql\n  mysql -uroot -p\n  \n使用mysql数据库\n  use mysql;\n  \n开启远程连接（root 用户名，% 所有人都可以访问 ，password 密码）\n  GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\n  \n  也可以添加一个新用户: \n  GRANT ALL PRIVILEGES ON *.* TO 'shuiyang'@'%' IDENTIFIED BY 'password!' WITH GRANT OPTION;\n  \n  FLUSH PRIVILEGES; \n  \n重起mysql服务\n  service mysqld restart\n如果执行完以上步骤，还是不能远程连接，那么我们需要查看服务器的防火墙是否开启\n  service iptables status\n如果防火墙开启，请关闭\n  service iptables stop\n```\n#### 五：配置默认编码为utf8\n```sql\n修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：\n\n[mysqld]\ncharacter_set_server=utf8\ninit_connect='SET NAMES utf8'\n\n重新启动mysql服务，查看数据库默认编码如下所示：\n\nmysql> show variables like '%character%';\n+--------------------------+----------------------------+\n| Variable_name            | Value                      |\n+--------------------------+----------------------------+\n| character_set_client     | utf8                       |\n| character_set_connection | utf8                       |\n| character_set_database   | utf8                       |\n| character_set_filesystem | binary                     |\n| character_set_results    | utf8                       |\n| character_set_server     | utf8                       |\n| character_set_system     | utf8                       |\n| character_sets_dir       | /usr/share/mysql/charsets/ |\n+--------------------------+----------------------------+\n8 rows in set (0.00 sec)\n```\n\n备注：\n```sql\n默认配置文件路径： \n配置文件：/etc/my.cnf \n日志文件：/var/log//var/log/mysqld.log \n服务启动脚本：/usr/lib/systemd/system/mysqld.service \nsocket文件：/var/run/mysqld/mysqld.pid\n```\n\n转载：https://www.linuxidc.com/Linux/2016-09/135288.htm\n转载:http://blog.csdn.net/sun614345456/article/details/53672150","tags":["server"],"categories":["服务器"]},{"title":"百度富文本框编辑器Ueditor的使用","url":"/2018/03/05/backend/other/百度富文本框编辑器Ueditor的使用/","content":"### 百度富文本框编辑器：\n官网： http://ueditor.baidu.com/website/ \n\n官网演示地址：http://ueditor.baidu.com/website/onlinedemo.html\n\nUEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码...\n<!--more-->\n#### 开始使用：\n参考:\nhttp://fex.baidu.com/ueditor/\n##### 1. 入门部署和体验\n\n##### 1.1下载编辑器\n\n到官网下载 UEditor 最新版：[官网地址]\n\n##### 1.2创建demo文件\n\n解压下载的包，在解压后的目录创建 demo.html 文件，填入下面的html代码\n\n```html\n<!DOCTYPE HTML>\n<html lang=\"en-US\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>ueditor demo</title>\n</head>\n\n<body>\n    <!-- 加载编辑器的容器 -->\n    <script id=\"container\" name=\"content\" type=\"text/plain\">\n        这里写你的初始化内容\n    </script>\n    <!-- 配置文件 -->\n    <script type=\"text/javascript\" src=\"ueditor.config.js\"></script>\n    <!-- 编辑器源码文件 -->\n    <script type=\"text/javascript\" src=\"ueditor.all.js\"></script>\n    <!-- 实例化编辑器 -->\n    <script type=\"text/javascript\">\n        var ue = UE.getEditor('container');\n    </script>\n</body>\n\n</html>\n```\n##### 1.3 在浏览器打开demo.html\n\n如果看到了编辑器，恭喜你，初次部署成功！\n\n##### 2. 整合jsp后端配置\n\n##### 2.1 下载 jsp 版本完整包\n\n下载地址: http://ueditor.baidu.com/website/download.html \n\n选择 [1.4.3.3 Jsp 版本]\n\n##### 2.2 下载之后会得到如下文件\n\n按照官网上的做法是把文件copy到webapp跟目录下 , 但我们是集成ueditor, 肯定不是放在根目录下, 所以我们把文件都复制到 webapp/static/plugins/ueditor 下, 方便管理\n\n![logo](/images/server/相关技术/ueditor目录结构图.png) \n\n##### 2.3 前台代码集成\n2.3.1 在需要集成ueditor的页面添加如下代码, 如果能看到编辑器则说明配置成功\n```html\n<!DOCTYPE HTML>\n<html lang=\"en-US\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>ueditor demo</title>\n    <link rel=\"stylesheet\" href=\"${ctx}static/plugins/ueditor/lang/zh-cn/zh-cn.js\" media=\"all\" />\n</head>\n\n<body>\n    <!-- 加载编辑器的容器 -->\n    <script id=\"container\" name=\"content\" type=\"text/plain\">\n        这里写你的初始化内容\n    </script>\n    <!-- 配置文件 -->\n    <script type=\"text/javascript\" src=\"${ctx}static/plugins/ueditor/ueditor.config.js\"></script>\n    <!-- 编辑器源码文件 -->\n    <script type=\"text/javascript\" src=\"${ctx}static/plugins/ueditor/ueditor.all.js\"></script>\n    <!-- 实例化编辑器 -->\n    <script type=\"text/javascript\">\n        var ueditor = UE.getEditor('container');\n    </script>\n</body>\n\n</html>\n```\n获取编辑器内容\n```html\nvar ueditor = UE.getEditor('container');\n\nvar content = ueditor.getContent(content);\n\n```\n\n设置编辑器内容\n```html\n // 等UEditor创建完成就使用UEditor的setContent函数\n var ueditor = UE.getEditor('container');\n ueditor.ready(function() {\n      ueditor.setContent(content);\n });\n```\n\n有了这些你可以处理一些普通文字, 但如果是要文件上传,图片上传,视频上传这些功能你就要进行一些后台代码的配置\n\n##### 2.4 后台代码集成\n\n后台环境： Spring + Spring Mvc + Mybatis + Maven\n\n##### 2.4.1 配置 ueditor.config.js\n\n原配置:\n```javascript\n    var URL = window.UEDITOR_HOME_URL || getUEBasePath();\n\n    /**\n     * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。\n     */\n    window.UEDITOR_CONFIG = {\n\n        //为编辑器实例添加一个路径，这个不能被注释\n        UEDITOR_HOME_URL: URL\n\n        // 服务器统一请求接口路径\n        , serverUrl: URL + \"jsp/controller.jsp\"\n\n        //工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的重新定义\n```\n修改后的配置：\n```javascript\n    window.UEDITOR_HOME_URL = \"/static/plugins/ueditor/\";\n\n    var URL = window.UEDITOR_HOME_URL || getUEBasePath();\n\n    /**\n     * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。\n     */\n    window.UEDITOR_CONFIG = {\n\n        //为编辑器实例添加一个路径，这个不能被注释\n        UEDITOR_HOME_URL: URL\n\n        // 服务器统一请求接口路径\n        , serverUrl: \"/ueditor/ueditorAction\"\n\n```\n\n1. 主要是 `window.UEDITOR_HOME_URL` 这个参数赋值成自己的ueditor的文件路径\n2. 修改 服务器统一请求接口路径 `/ueditor/ueditorAction` , 这样Ueditor后台服务接口就会请求到这个接口中来\n\n##### 2.4.2 新增后台服务接口\n\n第一步： 导入jar包, 我是只添加了最后俩个包，其他的包可以通过maven的形式导入，copy 这俩个包放到WEBINF/lib目录下, 然后配置Maven依赖\n![logo](/images/server/相关技术/jar.png) \n\n注：使用maven构建项目的时候需要进行如下配置, 这样maven构建的时候才不会报找不到lib目录下jar包的错误\n```sql\n    <dependency>\n      <groupId>json</groupId>\n      <artifactId>json</artifactId>\n      <version>1.0</version>\n      <scope>system</scope>\n      <systemPath>${project.basedir}/src/main/webapp/WEB-INF/lib/json.jar</systemPath>\n    </dependency>\n```\n\n第二步：新建 后台统一服务接口\n\n```java\n/**\n * Ueditor 后台统一服务接口\n * @author songshuiyang\n * @date 2018/3/4 18:11\n */\n@Controller\n@RequestMapping(\"/ueditor\")\npublic class UEditorController extends BaseController {\n    \n    private HttpServletRequest request = null;\n    \n    private String actionType = null;\n\n    private ConfigManager configManager = null;\n\n\n    @RequestMapping(value = \"ueditorAction\", method = {RequestMethod.GET,RequestMethod.POST})\n    @ResponseBody\n    public JSONObject exec (@RequestParam String action, HttpServletRequest request) {\n        String result;\n        this.actionType = action;\n        this.request = request;\n        String rootPath =  request.getSession().getServletContext().getRealPath(\"/\");\n        String contextPath = request.getContextPath();\n        this.configManager = ConfigManager.getInstance( rootPath, contextPath,\"/static/plugins/ueditor/jsp/controller.jsp\");\n\n        String callbackName = this.request.getParameter(\"callback\");\n\n        if ( callbackName != null ) {\n            result =  !validCallbackName( callbackName ) ? new BaseState( false, AppInfo.ILLEGAL ).toJSONString() : callbackName+\"(\"+this.invoke()+\");\";\n        } else {\n            result = this.invoke();\n        }\n        return JSONObject.fromObject(result);\n\n    }\n\n    public String invoke() {\n\n        if ( actionType == null || !ActionMap.mapping.containsKey( actionType ) ) {\n            return new BaseState( false, AppInfo.INVALID_ACTION ).toJSONString();\n        }\n\n        if ( this.configManager == null || !this.configManager.valid() ) {\n            return new BaseState( false, AppInfo.CONFIG_ERROR ).toJSONString();\n        }\n\n        State state = null;\n\n        int actionCode = ActionMap.getType( this.actionType );\n\n        Map<String, Object> conf;\n\n        switch ( actionCode ) {\n\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                conf = this.configManager.getConfig( actionCode );\n                state = new Uploader( request, conf ).doExec();\n                break;\n\n            case ActionMap.CATCH_IMAGE:\n                conf = configManager.getConfig( actionCode );\n                String[] list = this.request.getParameterValues( (String)conf.get( \"fieldName\" ) );\n                state = new ImageHunter( conf ).capture( list );\n                break;\n\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                conf = configManager.getConfig( actionCode );\n                int start = this.getStartIndex();\n                state = new FileManager( conf ).listFile( start );\n                break;\n\n        }\n\n        assert state != null;\n        return state.toJSONString();\n\n    }\n\n    private int getStartIndex () {\n\n        String start = this.request.getParameter( \"start\" );\n\n        try {\n            return Integer.parseInt( start );\n        } catch ( Exception e ) {\n            return 0;\n        }\n\n    }\n\n    /**\n     * callback参数验证\n     * @param name 名字\n     * @return boolean\n     */\n    private boolean validCallbackName ( String name ) {\n        return name.matches( \"^[a-zA-Z_]+[\\\\w0-9_]*$\" );\n    }\n}\n```\n\n一： 初始化ueditor的时候, ueditor会访问该接口, 此时`action` 参数是 `config` , 该接口会返回其`/static/plugins/ueditor/jsp/config.json` 配置的json参数，这些参数配置了上传功能的一些参数, 通过这些配置你可以DIY上传功能, ueditor获取到这些参数之后就可以使用上传功能了,否则你上传文件会提示： 后端配置项没有正常加载，上传插件不能正常使用！\n\n配置主要包括： 上传图片配置项 涂鸦图片上传配置项 截图工具上传 抓取远程图片配置 上传视频配置 上传文件配置\n\n二： 如要上传图片, ueditor会访问该接口, 此时`action` 参数是 `uploadimage` ，则会执行上传图片操作, 上传成功后会返回\n```sql\n{\n    \"state\": \"SUCCESS\",\n    \"url\": \"upload/demo.jpg\",\n    \"title\": \"demo.jpg\",\n    \"original\": \"demo.jpg\"\n}\n```\n三：由于系统文件上传使用的是阿里云的OSS所以需要将文件上传转到OSS处理上\n\n前台配置：\n```html\n<script type=\"text/javascript\">\n    // 当action是如下时，访问自己定义的服务接口\n    UE.Editor.prototype._bkGetActionUrl=UE.Editor.prototype.getActionUrl;\n    UE.Editor.prototype.getActionUrl=function(action){\n        // 上传图片, 文件, 视频\n        if (action == 'uploadimage' || action == 'uploadfile'  || action == 'uploadvideo') {\n            return '/file/uploadLocal';\n        }  else if( action== 'uploadscrawl'){ // 上传涂鸦，涂鸦请求是Base64字符需要请求另外的接口\n            return '/file/uploadScrawl';\n        }   else if(action == 'listimage'){\n            return this._bkGetActionUrl.call(this, action);\n        } else{\n            return this._bkGetActionUrl.call(this, action);\n        }\n    }\n    var ueditor = UE.getEditor('ueditorContainer');\n</script>\n```\n\n后台接口：\n```java\npackage com.ecut.admin.controller;\n\nimport com.aliyun.oss.ClientException;\nimport com.aliyun.oss.OSSException;\nimport com.ecut.admin.entity.OssFile;\nimport com.ecut.admin.entity.UeditorState;\nimport com.ecut.admin.service.impl.FileServiceImpl;\nimport com.ecut.core.base.BaseController;\nimport com.ecut.core.utils.Base64Utils;\nimport com.ecut.core.utils.MessageUtils;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.ecut.core.utils.MessageUtils.success;\n\n/**\n * 阿里云OSS文件上传控制器\n * @author songshuiyang\n * @date 2018/2/11 20:22\n */\n@Controller\n@RequestMapping(\"/file\")\npublic class FileController extends BaseController {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private FileServiceImpl fileServiceImpl;\n\n    /**\n     * 文件上传\n     * produces=\"application/json;charset=UTF-8 解决服务器返回406问题\n     * @param file\n     * @return\n     * @throws OSSException\n     * @throws ClientException\n     * @throws IOException\n     */\n    @RequestMapping(value = \"/uploadLocal\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\")\n    @ResponseBody\n    public UeditorState uploadLocalFile(@RequestParam(value = \"upfile\",required = false) MultipartFile file) throws OSSException, ClientException, IOException {\n        Map<String, Object> resultMap = new HashMap<>();\n        OssFile file1 = fileServiceImpl.uploadFileByMultipartFile(file);\n        UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName());\n        return ueditorState;\n    }\n    /**\n     * 上传涂鸦照片\n     * @param upfile\n     * @return\n     * @throws Exception\n     */\n    @RequestMapping(value = \"/uploadScrawl\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\")\n    @ResponseBody\n    public UeditorState uploadscrawl(String upfile) throws Exception {\n        byte [] bytes= Base64Utils.decode(upfile);\n        InputStream inputStream = new ByteArrayInputStream(bytes);\n        String fileType = \"image/png\";\n        Long fileSize = new Long((long)bytes.length);\n        String fileName = \"scrawl\" + System.currentTimeMillis() + \".png\";\n        String extensionName = \"png\";\n        OssFile file1 = fileServiceImpl.uploadFileByInputStream(inputStream, fileType,fileSize,fileName,extensionName);\n        UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName());\n        return ueditorState;\n    }\n}\n```\n##### 2.4.3 问题集合\n\n###### 解决百度ueditor富文本编辑器不能插入视频的问题/src掉链/src清空，不能显示视频\n转载：http://blog.csdn.net/qq_34787830/article/details/75092347\n\n> 直接下载到的百度富文本编辑器当插入视频的时候会自动清掉src，不显示视频造成这样的原因是:百度富文本编辑器的过滤器xssFilter导致插入视频异常，编辑器在切换源码的过程中过滤掉img的_url属性（用来存储视频url）\n\n解决办法:\n\n1.在配置文件ueditor.config.js中，定位 //xss过滤白名单，即,whitList:{ }，对 img: 增加 “_url” 属性： \n2. 在下面的 video 标签后面新增3给标签，使Ueditor分别能支持embed标签和iframe标签：\n```java\n source: ['src', 'type'],\n\n embed: ['type', 'class', 'pluginspage', 'src', 'width', 'height', 'align', 'style', 'wmode', 'play',  \n\n      +  'autoplay','loop', 'menu', 'allowscriptaccess', 'allowfullscreen', 'controls', 'preload'],\n\n iframe: ['src', 'class', 'height', 'width', 'max-width', 'max-height', 'align', 'frameborder', 'allowfullscreen']\n```","tags":["Java"],"categories":["server"]},{"title":"基于wordspress搭建个人博客系统","url":"/2018/03/04/backend/other/基于wordspress搭建个人博客系统/","content":"### 什么是Wordspress：\n官网： https://cn.wordpress.org/ 提供了中英版\n\nWordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。\n\nWordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。\n\nWordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的标准通用标记语言下的一个应用HTML代码、CSS、PHP等相关知识。\n\nWordPress官方支持中文版，同时有爱好者开发的第三方中文语言包，如wopus中文语言包。WordPress拥有成千上万个各式插件和不计其数的主题模板样式。\n<!--more-->\n### 搭建教程：\n参考下面的帖子写的十分详细\n\nhttps://www.jianshu.com/p/56750622cac9\n\n\n### LNMP一键安装包\nLNMP一键安装包是一个用Linux Shell编写的可以为CentOS/RHEL/Fedora/Aliyun/Amazon、Debian/Ubuntu/Raspbian/Deepin/Mint Linux VPS或独立主机安装LNMP(Nginx/MySQL/PHP)、LNMPA(Nginx/MySQL/PHP/Apache)、LAMP(Apache/MySQL/PHP)生产环境的Shell程序。\nhttps://lnmp.org/","tags":["Java"],"categories":["server"]},{"title":"Mysql 数据类型","url":"/2018/03/03/backend/database/Mysql 数据类型/","content":"MySQL中定义数据字段的类型对你数据库的优化是非常重要的。\n\nMySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。\n\n<!--more-->\n### 数值类型\nMySQL支持所有标准SQL数值数据类型。\n\n这些类型包括严格数值数据类型`(INTEGER、SMALLINT、DECIMAL和NUMERIC)`，以及近似数值数据类型`(FLOAT、REAL和DOUBLE PRECISION)`。\n\n关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。\n\nBIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。\n\n作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。\n\n![logo](/images/server/数据库/mysqlint.png) \n\n备注: \n1.BIT[M]\n\n位字段类型，M表示每个值的位数，范围从1到64，如果M被忽略，默认为1\n\n2.TINYINT[(M)] [UNSIGNED] [ZEROFILL]  M默认为4,占1个字节\n\n很小的整数。带符号的范围是-128到127。无符号的范围是0到255。\n\n3. BOOL，BOOLEAN\n\n是TINYINT(1)的同义词。zero值被视为假。非zero值视为真。\n\n4.SMALLINT[(M)] [UNSIGNED] [ZEROFILL] M默认为6,占2个字节\n\n小的整数。带符号的范围是-32768到32767。无符号的范围是0到65535。\n\n5.MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] M默认为9,占3个字节\n\n中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。\n\n6. INT[(M)] [UNSIGNED] [ZEROFILL]   M默认为11,占4个字节\n\n普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。\n\n7.BIGINT[(M)] [UNSIGNED] [ZEROFILL] M默认为20,占8个字节\n\n大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。\n\n注意：这里的M代表的并不是存储在数据库中的具体的长度，以前总是会误以为int(3)只能存储3个长度的数字，int(11)就会存储11个长度的数字，这是大错特错的。\n\ntinyint(1) 和 tinyint(4) 中的1和4并不表示存储长度，只有字段指定zerofill是有用，\n如tinyint(4)，如果实际值是2，如果列指定了zerofill，查询结果就是0002，左边用0来填充。\n\n### 日期和时间类型\n\n表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。\n\n每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。\n\nTIMESTAMP类型有专有的自动更新特性\n\n![logo](/images/server/数据库/mysqldate.png) \n\n### 字符串类型\n\n字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型\n\n![logo](/images/server/数据库/mysqlchar.png) \n\n","tags":["db"],"categories":["server"]},{"title":"animate.css","url":"/2018/03/03/frontend/animate/","content":"### 一 前言:\n#### 背景： \n在看其他人的项目的时候发现其动画效果做的不错，通过看人家的代码发现用了这个`animate.css`这个css组件，使用起来也是特别的方便，所以就把他copy到项目中来了，顿时档次就上升了\n\n#### 简介:\n`animate.css` 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。而且使用起来也是特别方便\n\n官网传送门: https://daneden.github.io/animate.css/\n\n在官网上有示例动画，主页也十分简洁，同时也提供了代码下载, 也可以看看这篇博客写的例子 `https://www.cnblogs.com/xiaohuochai/p/7372665.html`\n\n### 二 如何使用：\n\n#### 步骤：\n1. 在官网上下载 `animate.css` , 把他导入到项目中来, 也可以使用cdn `https://unpkg.com/animate.css@3.5.2/animate.min.css`\n2. 代码示例\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Document</title>\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/animate.css@3.5.2/animate.min.css\">\n        <style>\n            .box{height: 100px;width: 100px;background-color: lightblue}\n        </style>\n    </head>\n    <body>\n        <div class=\"box animated flash\"></div>\n    </body>\n</html>\n```\n3. 只要在元素中class 添加 `animated` 和相应的动画class名就可以实现动画效果, 当然也可以通过js动态设置class\n\n\n\n\n\n","tags":["css"],"categories":["client"]},{"title":"Spring mvc 前后台传值中文乱码问题","url":"/2018/02/28/backend/framework/spring/spring-mvc/Spring mvc 中文乱码问题/","content":"一： 解决GET请求参数到了后台中文乱码问题\n\n方式一: 修改tomcat配置, 暂时做法，没有找到更好的解决办法，换了tomcat了又要重新配置\n```java\n把tomcat下，server.xml下，添加如下配置，就解决了．\n\n  <Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/>\n```\n方式二: 自定义filter, 解决了get请求中文参数问题，但post请求参数到了后台就gg了\n\n<!--more-->\n\n1. 新建 `CustomEncodingFilter.java`\n```java\npackage com.ecut.core.web.filter;\n\nimport org.springframework.cglib.proxy.InvocationHandler;\nimport org.springframework.cglib.proxy.Proxy;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Method;\n\npublic class CustomEncodingFilter extends OncePerRequestFilter {\n    private String encoding;\n\n    public void setEncoding(String encoding) {\n        this.encoding = encoding;\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n            throws ServletException, IOException {\n        // 设置请求响应字符编码\n        request.setCharacterEncoding(encoding);\n        response.setCharacterEncoding(encoding);\n\n        // 传递给目标servlet或jsp的实际上是动态代理的对象，而不是原始的HttpServletRequest对象\n        request = (HttpServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(), request.getClass().getInterfaces(), new MyInvacationHandler(request));\n        chain.doFilter(request, response);\n    }\n\n    class MyInvacationHandler implements InvocationHandler {\n        private HttpServletRequest request;\n        MyInvacationHandler(HttpServletRequest request){\n            this.request=request;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            switch (method.getName()) {\n                case \"getParameter\":\n                    String value = request.getParameter((String)args[0]);\n                    try {\n                        if(value != null){\n                            value=new String(value.getBytes(\"ISO-8859-1\"),encoding);\n                        }\n                    } catch (UnsupportedEncodingException e) {\n                        e.printStackTrace();\n                    }\n                    return value;\n                case \"getParameterValues\":\n                    String[] values = request.getParameterValues((String)args[0]);\n                    if (values != null) {\n                        for (int i = 0; i < values.length; i++) {\n                            try {\n                                values[i] = new String(values[i].getBytes(\"ISO-8859-1\"),encoding);\n                            } catch (UnsupportedEncodingException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    }\n                    return values;\n                default:\n                    return method.invoke(request, args);\n            }\n        }\n\n    }\n}\n```\n2. 配置`web.xml`\n```java\n  <filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>com.ecut.core.web.filter.CharacterEncodingFilter</filter-class>\n    <async-supported>true</async-supported>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>UTF-8</param-value>\n    </init-param>\n    <init-param>\n      <param-name>forceEncoding</param-name>\n      <param-value>true</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n```\n二： 解决POST请求参数到了后台中文乱码问题\n```java\n  <filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <async-supported>true</async-supported>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>UTF-8</param-value>\n    </init-param>\n    <init-param>\n      <param-name>forceEncoding</param-name>\n      <param-value>true</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n```","tags":["Spring"],"categories":["服务器"]},{"title":"阿里巴巴Java编程规范","url":"/2018/02/13/backend/java/standard/阿里巴巴Java编程规范/","content":"### 前言：\n<center>关于《阿里巴巴Java开发手册》</center>\n\n\n\n你是否曾因Java代码规范版本纷杂而无所适从？\n\n你是否想过代码规范能将系统故障率降低20%？\n\n你是否曾因团队代码风格迥异而协同困难？\n\n你是否正在review一些原本可以避免的故障？\n\n你是否无法确定自己的代码足够健壮？ \n\n<!--more-->\n\n#### 码出高效，码出质量！\n相比C++代码规范业界已经达成共识，Java代码规范业界比较混乱，我们期待这次发布的Java代码规范能够给业界带来一个标准，促使整体行业代码规范水平得到提高，最终能够帮助企业和开发者提升代码质量和降低代码故障率。\n\n#### 阿里出品，质量保证！\n\n阿里Java技术团队一手打造出Dubbo、JStorm、Fastjson等诸多流行开源框架，部分已成为Apache基金会孵化项目；\n\n阿里在Java后端领域支撑起全球访问量最大的服务器集群；\n\nJava代码构建的阿里双11业务系统订单处理能力达到17.5万笔/秒；\n\n到目前已累计数亿行高并发、高稳定性的最佳Java代码实践；\n\n……\n\n此次公开的Java开发手册正是出自这样的团队，近万名阿里Java技术精英的经验总结，并经历了多次大规模一线实战检验及完善，铸就了这本高含金量的阿里Java开发手册。该手册以Java开发者为中心视角，划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱和故障敏感性，规约依次分为强制、推荐、参考三大类。此套规范不仅能让代码一目了然， 更有助于加强团队分工与合作、真正提升效率。 \n\n\n#### 无规矩不成方圆 无规范不能协作\n\n众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有规定靠右行驶，谁还敢上路行驶。 \n\n同理，对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，降低故障率，提升协作效率。开发手册详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，提高代码质量。比如，异常日志处理时的各种不规范行为；集合转换的各种坑；创建线程池出现的等待队列OOM等。 \n\n#### 阿里技术资深大咖联袂推荐\n\n阿里高级研究员多隆：工程师对于代码，一定要“精益求精”，不论从性能，还是简洁优雅，都要具备“精益求精”的工匠精神，认真打磨自己的作品。 \n\n阿里研究员毕玄：一个优秀的工程师和一个普通工程师的区别，不是现在满天飞的架构图，他的功底就是体现在他写的每一行代码上。 \n\n阿里研究员玄难：代码是软件工程里面的产品设计、系统架构设计等工作的最后承载体，代码的质量决定了一切工作的成败。 \n\n阿里巴巴B2B事业群CTO李纯：好的软件产品离不开工程师高质量的代码及相互间顺畅的沟通与合作。简单，适用的代码规约背后所传递的是技术上的追求卓越、协同合作的精神，是每个技术团队不可缺失的重要利器。 \n\n阿里研究员、HipHop作者：赵海平（花名：福贝）：程序员是创造个性化作品的艺术家，但同时也是需要团队合作的工种。个性化应尽量表现在代码效率和算法方面，牺牲小我，成就大我。\n\n#### 拥抱规范，远离伤害！\n     \n开发的同学们赶紧行动起来，遵守代码规范，你好，我好，大家好！\n\n\n##### 传送门\n1. 原文: https://yq.aliyun.com/articles/69327?spm=5176.100239.blogcont69327.158.xUUgiz&p=2#comments\n2. 「阿里巴巴编码规范」考试认证 : https://edu.aliyun.com/certification/cldt02 \n3. 点击下载《阿里巴巴Java开发手册》(纪念版): https://yq.aliyun.com/attachment/download/?id=4942\n4. IDE插件下载 : https://github.com/alibaba/p3c\n\n\n### 以下记录以下自己需要注意的一些规范, `遵守代码规范，你好，我好，大家好！`\n\n#### 编程规约\n\n#### 命名风格\n1. 【强制】\n\n     抽象类命名使用 Abstract 或 Base 开头； \n\n     异常类命名使用 Exception 结尾； \n    \n     测试类命名以它要测试的类的名称开始，以 Test 结尾。\n2. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n   \n   正例： `MAX_STOCK_COUNT`\n   \n   反例： `MAX_COUNT`\n3. 【强制】 POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\n   \n   反例： 定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted()， RPC 框架在反向解析的时候， “以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异\n                                                                常。\n4. 【强制】杜绝完全不规范的缩写， 避免望文不知义。\n\n   反例： AbstractClass“缩写” 命名成 AbsClass； condition“缩写” 命名成 condi，此类随\n   意缩写严重降低了代码的可阅读性。\n   \n5. 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词\n   组合来表达其意。\n   \n   正例： 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。\n   \n   反例： 变量 int a; 的随意命名方式。\n   \n6. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加） ，保持代码的简洁\n   性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是\n   与接口方法相关，并且是整个应用的基础常量。\n   \n   正例： 接口方法签名： void f();\n   \n   接口基础常量表示： String COMPANY = \"alibaba\";\n   \n   反例： 接口方法定义： public abstract void f();\n   \n   说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默\n   认实现。\n   \n7. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n   说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n   \n   正例： 枚举名字为 ProcessStatusEnum 的成员名称： SUCCESS / UNKOWN_REASON。\n   \n8. 【参考】各层命名规约：\n\n   > A) Service/DAO 层方法命名规约\n   \n   1） 获取单个对象的方法用 get 做前缀。\n   \n   2） 获取多个对象的方法用 list 做前缀。\n   \n   3） 获取统计值的方法用 count 做前缀。\n   \n   4） 插入的方法用 save/insert 做前缀。\n   \n   5） 删除的方法用 remove/delete 做前缀。\n   \n   6） 修改的方法用 update 做前缀。\n   \n   > B) 领域模型命名规约\n   \n   1） 数据对象： xxxDO， xxx 即为数据表名。\n   \n   2） 数据传输对象： xxxDTO， xxx 为业务领域相关的名称。\n   \n   3） 展示对象： xxxVO， xxx 一般为网页名称。\n   \n   4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n   \n#### 常量定义\n1. 【强制】不允许任何魔法值（即未经定义的常量） 直接出现在代码中。\n\n   反例： String key = \"Id#taobao_\" + tradeId;\n   \n   cache.put(key, value);\n2. 【推荐】不要使用一个常量类维护所有常量， 按常量功能进行归类，分开维护。\n\n   说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。\n   \n   正例： 缓存相关常量放在类 CacheConsts 下； 系统配置相关常量放在类 ConfigConsts 下。\n#### 代码格式\n1.示例\n```java\npublic static void main(String[] args) {\n    // 缩进 4 个空格\n    String say = \"hello\";\n    // 运算符的左右必须有一个空格\n    int flag = 0;阿里巴巴 Java 开发手册\n    // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号， 0 与右括号不需要空格\n    if (flag == 0) {\n        System.out.println(say);\n    }\n    // 左大括号前加空格且不换行；左大括号后换行\n    if (flag == 1) {\n        System.out.println(\"world\");\n        // 右大括号前换行，右大括号后有 else，不用换行\n    } else {\n        System.out.println(\"ok\");\n        // 在右大括号后直接结束，则必须换行\n    }\n}\n```\n2.【强制】 注释的双斜线与注释内容之间有且仅有一个空格。\n\n   正例： // 注释内容， 注意在//和注释内容之间有一个空格。\n   \n3.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：\n\n   1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。\n   \n   2） 运算符与下文一起换行。\n   \n   3） 方法调用的点符号与下文一起换行。\n   \n   4） 方法调用时，多个参数， 需要换行时， 在逗号后进行。\n   \n   5） 在括号前不要换行，见反例。\n   \n   正例：\n```java\n   StringBuffer sb = new StringBuffer();\n   // 超过 120 个字符的情况下，换行缩进 4 个空格， 点号和方法名称一起换行\n   sb.append(\"zi\").append(\"xin\")...\n       .append(\"huang\")...\n       .append(\"huang\")...\n       .append(\"huang\");\n```\n   反例：\n   ```java\n   StringBuffer sb = new StringBuffer();\n   // 超过 120 个字符的情况下，不要在括号前换行\n   sb.append(\"zi\").append(\"xin\")...append\n       (\"huang\");\n   // 参数很多的方法调用可能超过 120 个字符， 不要在逗号前换行\n   method(args1, args2, args3, ...\n      , argsX);\n   ```\n4.【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。\n\n   正例： 下例中实参的\"a\",后边必须要有一个空格。\n   \n   method(\"a\", \"b\", \"c\");\n5.【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义\n   之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。\n   说明： 没有必要插入多个空行进行隔开\n#### 注释规范\n1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用\n   // xxx 方式。\n   \n   说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注\n   释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高\n   阅读效率\n2. 【强制】所有的抽象方法（包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、\n   异常说明外，还必须指出该方法做什么事情，实现什么功能。\n   \n   说明： 对子类的实现要求，或者调用注意事项，请一并说明\n3. 【强制】所有的类都必须添加创建者和创建日期。\n\n4. 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持\n   英文原文即可\n5. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑\n   等的修改\n   \n   【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑\n   等的修改\n   \n6. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑\n   等的修改\n   \n7.  【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，\n   经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。\n   1） 待办事宜（TODO） :（标记人，标记时间， [预计处理时间]）\n   表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc\n   还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签） 。\n   2） 错误，不能工作（FIXME） :（标记人，标记时间， [预计处理时间]）\n   在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。\n#### 异常处理\n1. 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回\n   滚事务。\n2. 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回\n   滚事务。\n   \n#### MySQL 数据库 建表规约\n1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint\n（1 表示是， 0 表示否） 。\n\n说明： 任何字段如果为非负数，必须是 unsigned。\n\n正例： 表达逻辑删除的字段名 is_deleted， 1 表示删除， 0 表示未删除\n\n2.【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长\n    度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索\n    引效率。\n3.【强制】表必备三字段： id, gmt_create, gmt_modified。\n\n说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。 gmt_create,\ngmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被\n   动更新\n4.【推荐】表的命名最好是加上“业务名称_表的作用”。\n  正例： alipay_task / force_project / trade_config\n5.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。\n   说明： 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明\n   显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必\n   然有脏数据产生\n6.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致； 多表关联查询时，\n  保证被关联的字段需要有索引。\n  说明： 即使双表 join 也要注意表索引、 SQL 性能\n#### MySQL 数据库 SQL语句\n1. 【强制】不要使用 count(列名)或 count(常量)来替代 count(*)， count(*)是 SQL92 定义的\n标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。\n说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行","tags":["java"],"categories":["server"]},{"title":"解决CSS和JS文件的客户端缓存问题","url":"/2018/02/10/frontend/CSS和JS文件的客户端缓存问题/","content":"## 场景\n做项目的时候，发现自己修改了一个css文件但样式并没有应用，查看http请求(如下图)，注意这个参数`Status Code:200 OK (from disk cache)` , 说明文件是是之前浏览器缓存的文件，浏览器并没有请求我们新改的文件\n```java\nRequest URL:http://localhost:8080/static/layui/build/css/app.cssRequest Method:GET\nStatus Code:200 OK (from disk cache)\nRemote Address:127.0.0.1:8080\nReferrer Policy:no-referrer-when-downgrade\n```\n## 解决方法\n> 发现问题了，现在就是要解决如果是服务器js css等文件修改了，怎样让浏览器能够请求我们最新的文件, 通过查看其他人的解决方法，还有看了一下大厂`百度, 淘宝 , 新浪` 对这个问题的处理，总结了一下下面几种方法:\n\n#### 方法一: 在css文件上, js文件后面加上版本号`?v=1245365`\n```html\n<link rel=\"stylesheet\" href=\"${ctx}static/admin/css/main.css?v=1245365\" media=\"all\" />\n```\n1. 如果是经常更新的css文件版本号可以取当前时间的时间戳 `v=1518237859338` ,这样就可以每次都获取到最新的文件，但缺点就是每次刷新页面都会请求该文件，在项目开发过程中可以使用这种方式\n2. 如果是更新频率不高的的文件，可以取: `v=20180210` , 这样的话刷新页面就不会每次请求这个文件了，可以减轻服务器的压力 \n3. 如果是项目稳定了基本没有改动了，可以取一个固定值:`v=0.0.1`\n\n### 方法二：一个版本一个文件夹\n> 淘宝的做法: 用一个文件 `6.2.3`\n```html\nhttps://g.alicdn.com/kg/??component/6.2.3/extension/content-box/xtpl/view.xtpl-min.js\n```\n\n\n\n\n","tags":["css"],"categories":["client"]},{"title":"生成二维码图片(base64格式)","url":"/2018/01/29/backend/other/生成二维码图片(base64格式)/","content":"### 生成二维码图片(base64格式)\n\n\n<!--more-->\n```java\npackage com.guangeryi.mall.payment.weixin;\n\nimport com.google.zxing.BarcodeFormat;\nimport com.google.zxing.EncodeHintType;\nimport com.google.zxing.MultiFormatWriter;\nimport com.google.zxing.client.j2se.MatrixToImageWriter;\nimport com.google.zxing.common.BitMatrix;\nimport org.apache.commons.codec.binary.Base64;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class QRCodeUtils {\n\n    /**\n     * 生成二维码 Base64编码后字符串\n     *\n     * @param contents 内容\n     */\n    public static String encodeQRCodeBase64(String contents) {\n        return encodeQRCodeToBase64Str(contents);\n    }\n\n    /**\n     * 生成二维码 Base64编码后字符串 <img src=''> src填入该字符串显示图片\n     * （高度:300 , 宽度:300）\n     * @param contents 内容\n     */\n    private static String encodeQRCodeToBase64Str(String contents) {\n        int width = WxPcPayConfigImpl.QR_IMG_WIDTH;\n        int height = WxPcPayConfigImpl.QR_IMG_HEIGHT;\n        Map<EncodeHintType, Object> hints = new Hashtable<>();\n        String base64Img = \"data:image/png;base64,\";\n        // 指定编码格式\n        hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\");\n        try {\n            // 生成输出流\n            BitMatrix bitMatrix1 = new MultiFormatWriter().encode(contents,\n                    BarcodeFormat.QR_CODE, width, height, hints);\n            BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix1);\n            base64Img = base64Img + encodeToString(\"png\", image);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return base64Img;\n    }\n    /**\n     * 将图片转换成base64格式进行存储\n     *\n     * @param formatName 文件格式\n     * @param image      图片流\n     * @return base64字符串\n     */\n    private static String encodeToString(String formatName, BufferedImage image) {\n        String imageString = null;\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n            ImageIO.write(image, formatName, bos);\n            byte[] imageBytes = bos.toByteArray();\n            imageString = new String(Base64.encodeBase64(imageBytes));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return imageString;\n    }\n\n    public static void main(String[] args) {\n        // 输出在img标签中img属性中\n        System.out.println(encodeQRCodeBase64(\"你好\"));\n    }\n}\n```","tags":["Java"],"categories":["server"]},{"title":"根据手机区号获取城市地理位置","url":"/2018/01/29/backend/other/根据手机区号获取城市地理位置/","content":"### 根据手机区号获取城市地理位置\n\nhttpAPI:  http://www.ip138.com:8080/search.asp?action=mobile&mobile=%s\n\n<!--more-->\n```java\npackage com.guangeryi.mall.third.common;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.select.Elements;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class MobileLocationUtils {\n\n    private final static Logger logger = LoggerFactory.getLogger(MobileLocationUtils.class);\n\n    /**\n     * 根据手机号获取所在地信息\n     * @param mobile 手机号码\n     * @return 返回map\n     */\n    public static Map<String,Object> getMobileAddress (String mobile) {\n        Map<String,Object> map = new HashMap<>();\n        String returnStr= getMobileAddressUtils(mobile);\n        // 将160号的空格转化成32号的空格\n        returnStr = returnStr.replaceAll(\"[\\\\u00A0]+\", \" \");\n        // 去空格\n        returnStr = returnStr.trim();\n        String [] address = returnStr.split(\"\\\\s+\");\n        String province = \"\";// 省\n        String city = \"\";    // 市\n        // 直辖市\n        if (address.length == 1) {\n            province = address[0];\n            city = address[0];\n        }\n        if (address.length == 2) {\n            province = address[0];\n            city = address[1];\n        }\n        map.put(\"province\", province);\n        map.put(\"city\", city);\n        logger.info(mobile + \" 手机号所在信息:\" + map);\n        return map;\n    }\n\n    public static String getMobileAddressUtils(String mobile){\n        try {\n            String url = \"http://www.ip138.com:8080/search.asp?action=mobile&mobile=%s\";\n            url = String.format(url, mobile);\n            Document doc = Jsoup.connect(url).get();\n            Elements els = doc.getElementsByClass(\"tdc2\");\n            if(els.get(1).text().equals(\"mobile 不是数字! 验证手机号有误\") || els.get(1).text().equals(\"验证手机号有误\")) {\n                return \"未知\";\n            }\n            return els.get(1).text();\n        } catch (Exception e) {\n            return \"未知\";\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getMobileAddress(\"13117975845\"));\n    }\n}\n\n\n```","tags":["Java"],"categories":["server"]},{"title":"根据IP获取城市地理位置","url":"/2018/01/29/backend/other/根据IP获取城市地理位置/","content":"### 根据IP获取城市地理位置\n使用的是百度查询的api，试过到淘宝的API, 但是淘宝做了访问次数限制，如果批量查询的话直接timeout\n\n\n<!--more-->\n```java\npackage com.guangeryi.mall.third.common;\n\nimport net.sf.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 根据IP获取城市地理位置\n * 调用百度api：http://api.map.baidu.com/location/ip\n */\npublic class IpUtils {\n\n    private final static Logger logger = LoggerFactory.getLogger(AddressUtils.class);\n\n    /**\n     * 根据ip获取城市信息\n     * @param ip\n     * @return\n     */\n    public static Map<String, Object> getCityInfoByIp(String ip){\n        Map<String, Object> result = new HashMap<>();\n        result.put(\"status\",\"success\");\n        String jsonInfo = null;\n        try {\n            jsonInfo = getCityInfoByUrlAPI(ip);\n            logger.info(\"jsonInfo:\" + jsonInfo);\n        } catch (IOException e) {\n            logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常, ip:\" + ip, e);\n            result.put(\"status\",\"failed\");\n            return  result;\n        }\n        String province = \"\";\n        String city = \"\";\n        String district =\"\";\n        String street = \"\";\n        try {\n            JSONObject jsonObject = JSONObject.fromObject(jsonInfo);\n            if (jsonObject != null) {\n                if (jsonObject.getJSONObject(\"content\") != null) {\n                    JSONObject addressDetail = jsonObject.getJSONObject(\"content\").getJSONObject(\"address_detail\");\n                    province = (String)addressDetail.get(\"province\"); // 省\n                    city = (String)addressDetail.get(\"city\");         // 市\n                    district = (String)addressDetail.get(\"district\"); // 区\n                    street = (String)addressDetail.get(\"street\");     // 街道\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常,解析JSON异常 ip:\" + ip, e);\n            result.put(\"status\",\"failed\");\n            return  result;\n        }\n        result.put(\"province\",province);\n        result.put(\"city\",city);\n        result.put(\"district\",district);\n        result.put(\"street\",street);\n        return result;\n    }\n\n    /**\n     * 调用 api.map.baidu.com/location/ip 获取城市信息\n     * @param ip\n     * @return\n     * @throws IOException\n     */\n    private static String getCityInfoByUrlAPI(String ip) throws IOException {\n        String url = \"http://api.map.baidu.com/location/ip?ak=F454f8a5efe5e577997931cc01de3974&ip=\" + ip;\n        try (InputStream is = new URL(url).openStream()) {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n            String jsonText = getStrByReader(rd);\n            jsonText = decodeUnicode(jsonText);\n            return jsonText;\n        }\n    }\n    /**\n     * 获取流数据\n     * @param rd\n     * @return\n     * @throws IOException\n     */\n    private static String getStrByReader(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n    /**\n     * unicode 转换成 中文\n     *\n     * @author fanhui 2007-3-15\n     * @param theString 字符串\n     * @return String\n     */\n    private static String decodeUnicode(String theString) {\n        char aChar;\n        int len = theString.length();\n        StringBuilder outBuilder = new StringBuilder(len);\n        for (int x = 0; x < len;) {\n            aChar = theString.charAt(x++);\n            if (aChar == '\\\\') {\n                aChar = theString.charAt(x++);\n                if (aChar == 'u') {\n                    int value = 0;\n                    for (int i = 0; i < 4; i++) {\n                        aChar = theString.charAt(x++);\n                        switch (aChar) {\n                            case '0':\n                            case '1':\n                            case '2':\n                            case '3':\n                            case '4':\n                            case '5':\n                            case '6':\n                            case '7':\n                            case '8':\n                            case '9':\n                                value = (value << 4) + aChar - '0';\n                                break;\n                            case 'a':\n                            case 'b':\n                            case 'c':\n                            case 'd':\n                            case 'e':\n                            case 'f':\n                                value = (value << 4) + 10 + aChar - 'a';\n                                break;\n                            case 'A':\n                            case 'B':\n                            case 'C':\n                            case 'D':\n                            case 'E':\n                            case 'F':\n                                value = (value << 4) + 10 + aChar - 'A';\n                                break;\n                            default:\n                                throw new IllegalArgumentException(\"Malformed      encoding.\");\n                        }\n                    }\n                    outBuilder.append((char) value);\n                } else {\n                    if (aChar == 't') {\n                        aChar = '\\t';\n                    } else if (aChar == 'r') {\n                        aChar = '\\r';\n                    } else if (aChar == 'n') {\n                        aChar = '\\n';\n                    } else if (aChar == 'f') {\n                        aChar = '\\f';\n                    }\n                    outBuilder.append(aChar);\n                }\n            } else {\n                outBuilder.append(aChar);\n            }\n        }\n        return outBuilder.toString();\n    }\n    public static void main(String[] args) {\n        System.out.println(getCityInfoByIp(\"118.212.211.23\"));\n    }\n}\n\n```\n\n#### 获取用户真实IP地址\n\n```java\n    /**\n     * 获取用户真实IP地址，不使用request.getRemoteAddr()的原因是有可能用户使用了代理软件方式避免真实IP地址,\n     * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值\n     */\n    public static String getRemoteIp(HttpServletRequest request) {\n        String ip = request.getHeader(\"x-forwarded-for\");\n        if (ip != null && ip.length() != 0 && !\"unknown\".equalsIgnoreCase(ip)) {\n            // 多次反向代理后会有多个ip值，第一个ip才是真实ip\n            if(ip.contains(\",\")){\n                ip = ip.split(\",\")[0];\n            }\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"X-Real-IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getRemoteAddr();\n        }\n        // TODO 本地测试使用\n        if (!isIpv4(ip)) {\n            ip= \"120.27.129.177\"; // 服务器ip\n        }\n        return ip;\n    }\n```\n#### 校验IP地址\n\n```java\n    /**\n     * 校验IP地址\n     * @param ipAddress IP 地址\n     * @return true or false\n     */\n    public static boolean isIpv4(String ipAddress) {\n\n        String ip = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n                +\"(00?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n                +\"(00?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n                +\"(00?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n\n        Pattern pattern = Pattern.compile(ip);\n        Matcher matcher = pattern.matcher(ipAddress);\n        return matcher.matches();\n    }\n```","tags":["Java"],"categories":["server"]},{"title":"阿里云服务器搭建Javaweb运行环境","url":"/2018/01/20/backend/server/JavaEE服务器/阿里云服务器搭建Javaweb运行环境/","content":"### 一：前言\n借助阿里云的云翼计划的梯子买了个 阿里的ESC云服务器，学生专享优惠10块钱/月，原价一百多一个月，超级划算，当然服务器配置对于我们这些学生捣鼓捣鼓还是满足的。\n\n配置：\n\n|  配置 | 参数    | \n| -----   | -----:   | \n| CPU     | Intel Xeon E5-2682 v4 1核   |\n| 内存     | 2G 最新一代DDR4 内存        |\n| 带宽    | 1M带宽 VPC专有网络, I/O 优化 |\n| 系统盘   | 40G系统盘高效云盘           |\n\n系统：CentOS 7.3 64位(可选ubuntu, windows service)\n\n\nESC: 云服务器 ECS（Elastic Compute Service）是一种弹性可伸缩的计算服务，助您降低 IT 成本，提升运维效率，使您更专注于核心业务创新\n\n### 二：搭建步骤\n#### 2.1 购买 ESC云服务器\n购买链接:https://www.aliyun.com/product/ecs?spm=5176.8499797.765261.239.9Uf4pK, 当然如果是学生的话可以使用上面的云翼计划(https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8789780.765430.4.246c0fa5bHX2oK)优惠的方式购买，当时购买还送了(CDN流量包)和(OSS资源包) , 良心企业!!! \n\n#### 2.2 查看系统参数，及配置参数\n下单完成之后在 控制台-> 云服务器 ECS -> 实例 可看到系统自动为我们创建的 服务器实例, 里面提供了一些系统参数，还展示了系统的一些运行状态参数。\n\n我们需要的参数\n\n1.公网ip\n\n>访问实例需要用\n\n2.远程连接密码  \n\n> 这个在第一次使用浏览器远程连接主机的时候，阿里云会提供，记住只出现一次，可以用笔记本记录下来，以后每次用浏览器远程控制访问主机的时候需要提供\n\n3.登入系统的密码 \n\n在实例信息面板中有一个重置密码的功能，第一次需要自己设置，这个是主机系统的登入密码。 一开始用浏览器远程连接主机的时候，进入到了命令行界面, 要求输入密码的时候一直输入的是远程连接密码，导致一直登不进，查了一下资料发现系统登入密码需要自己创建, 登入用户 `root`\n\n4.安全组配置\n\n安全组配置是阿里云在系统做了一次网关过滤，外网访问主机，主机访问外网都需要配置这个参数，否则访问不到, 安全组配置分为入口和出口\n\n入口配置:\n\n- 把一些常用端口打开:`80 22(ssh, sftp) 23(telnet)` , 使用xshell和ftp都是使用的是22端口\n- 添加 `全部 ICMP` 协议类型, 端口范围为`-1/-1`, 没有这条规则则ping 不通主机\n\n\n#### 2.3 连接主机进行配置\n有了上面的配置就可以通过远程连接主机了, 我是使用`xshell` 进行远程连接, 使用`fileZilla`进行传输文件\n##### 2.3.1 配置 Java环境\n方式一：使用yum安装JDK 参考：https://www.cnblogs.com/sxdcgaq8080/p/7492426.html\n```sql\n1.查看yum库中都有哪些jdk版本(暂时只发现了openjdk): \n[root@localhost ~]# yum search java|grep jdk\n\n2.选择版本,进行安装\n[root@localhost ~]# yum install java-1.8.0-openjdk\n\n//安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_64\n\n3.设置环境变量\n[root@localhost ~]# vi /etc/profile\n在profile文件中添加如下内容\n#set java environment\nJAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el7_5.x86_64\nJRE_HOME=$JAVA_HOME/jre\nCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\nPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\nexport JAVA_HOME JRE_HOME CLASS_PATH PATH\n\n4.让修改生效\n[root@localhost java]# source /etc/profile\n```\n\n\n注: 如果出现`export =' not a valid identifier`\n```sql\n原因就是你修改的 /etc/profile 文件里\n你加过空格\n\n我的代码如下：\nexport JAVA_HOME = /usr/java/jdk1.7.0_75\nexport PATH = $JAVA_HOME/bin:$PATH\nexport CLASSPATH = .:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n\n修改为如下：\nexport JAVA_HOME=/usr/java/jdk1.7.0_75\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n将等号两边的空格去掉就可以了 ，大家要注意\n```\n\n##### 2.3.2 配置 Tomcat环境\n参考： http://www.linuxidc.com/Linux/2015-09/123118.htm\n```sql\n# tar -zxvf apache-tomcat-8.0.26.tar.gz // 解压压缩包        \n# mv apache-tomcat-8.0.26 tomcat // 改名\n\n```\n\n注: \n1.在ECS上启动tomcat后，第一次访问时间特别长\n```sql\n2017-04-25 10:16:04 INFO com.world.socket.ServerSocketListener  \n25-Apr-2017 10:18:48.171 INFO [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom CreaecureRandom instance for session ID generation using [SHA1PRNG] took [163,521] milliseconds. \n \n \n这个session ID引起的 \n\n解决办法：在JVM环境中解决 \n打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：securerandom.source=file:/dev/urandom \n替换成securerandom.source=file:/dev/./urandom\n```\n2.Centos打开、关闭、结束tomcat，及查看tomcat运行日志\n```sql\n启动：一般是执行sh tomcat/bin/startup.sh \n停止：一般是执行sh tomcat/bin/shutdown.sh脚本命令 \n查看：执行ps -ef |grep tomcat 输出如下 *** 5144 。。。等等.Bootstrap start 说明tomcat已经正常启动， 5144 就为进程号 pid = 5144 \n杀死：kill -9 5144\n\n\n------------------------linux下实时查看tomcat运行日志-------------------------\n1、先切换到：cd tomcat/logs\n2、tail -f catalina.out\n3、这样运行时就可以实时查看运行日志了\nCtrl+c 是退出tail命令。\n```\n\n##### 2.3.3 配置 Mysql环境\n参考： http://www.linuxidc.com/Linux/2016-09/134992.htm\n\n#### 2.4 投放项目文件\n使用`fileZilla`进行传输文件\n```sql\nTomcat中部署web项目的三种方式：\n1.部署解包的webapp目录\n2.打包的war文件\n3.Manager Web应用程序\n```","tags":["java"],"categories":["server"]},{"title":"组合注解","url":"/2018/01/14/backend/framework/spring/组合注解/","content":"### 组合注解\n> 用一个注解表示其他注解\n\nCombinationAnnocation.java\n\n```java\npackage com.smart.boot.groupAnno;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.lang.annotation.*;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n@ComponentScan\npublic @interface CombinationAnnocation {\n    String [] value() default {};\n}\n```\nConfig.java\n\n```java\npackage com.smart.boot.groupAnno;\n\n@CombinationAnnocation\npublic class Config {\n}\n\n```\n\nApplication.java\n```java\npackage com.smart.boot.groupAnno;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Application {\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        context.close();\n    }\n}\n```","tags":["Spring"],"categories":["服务器"]},{"title":"异步方法","url":"/2018/01/14/backend/framework/spring/异步方法/","content":"### 异步方法\n> 加入@Async注解可以让普通方法变为异步方法\n\nAsyncTaskService.java\n\n```java\npackage com.smart.boot.asyn;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class AsyncTaskService {\n    /**\n     * 异步方法\n     *\n     * @param i\n     */\n    @Async\n    public void task1(Integer i) {\n        System.out.println(\"执行异步任务\" + i);\n    }\n\n    @Async\n    public void task2(Integer i) {\n        System.out.println(\"执行异步任务+1 \" + (i + 1));\n    }\n}\n```\nConfig.java\n\n```java\npackage com.smart.boot.asyn;\n\nimport org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.scheduling.annotation.AsyncConfigurer;\nimport org.springframework.scheduling.annotation.EnableAsync;\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\nimport java.util.concurrent.Executor;\n\n@Configuration\n@ComponentScan(\"com.smart.boot.asyn\")\n@EnableAsync // 开启异步任务支持\npublic class Config implements AsyncConfigurer {\n    /**\n     * 获得一个基于线程池的 taskExecutor\n     *\n     * @return\n     */\n    @Override\n    public Executor getAsyncExecutor() {\n        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();\n        taskExecutor.setCorePoolSize(5);\n        taskExecutor.setMaxPoolSize(10);\n        taskExecutor.setQueueCapacity(25);\n        taskExecutor.initialize();\n        return taskExecutor;\n    }\n\n    @Override\n    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {\n        return null;\n    }\n}\n```\n\nApplication.java\n```java\npackage com.smart.boot.asyn;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Application {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        AsyncTaskService asyncTaskService = context.getBean(AsyncTaskService.class);\n        for (int i = 0; i < 10; i++) {\n            asyncTaskService.task1(i);\n            asyncTaskService.task2(i);\n        }\n        context.close();\n    }\n}\n```","tags":["Spring"],"categories":["服务器"]},{"title":"Spring 事件监听","url":"/2018/01/14/backend/framework/spring/spring 事件监听/","content":"### Spring 事件监听\n\n#### spring的事件(Application Event)\n**为Bean与Bean之间的消息通信提供了支持, 当第一个Bean处理完一件事之后, 需要另外一个Bean知道并能做出相应的处理, 这时可以通过事件监听来讲一个Bean监听另一个Bean**\n\n#### 观察者模式\n>Spring 事件监听是观察者模式的一种实现 \n\n意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n\n何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n\n如何解决：使用面向对象技术，可以将这种依赖关系弱化。\n\n>事件驱动模型简介\n\n事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点：\n\n1. 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）；\n2. 当目标发送改变（发布），观察者（订阅者）就可以接收到改变；\n3. 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。\n<!--more-->\n#### 实现流程\n1.自定义事件\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.ApplicationEvent;\n\npublic class DemoEvent extends ApplicationEvent {\n\n    private String msg;\n\n    public DemoEvent(Object source, String msg) {\n        super(source);\n        this.msg = msg;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    /**\n     * 去做一些事\n     */\n    public void todoSomethings() {\n        System.out.println(\"正在做第一件事 , 做完需要做第二件事\");\n    }\n}\n```\n\n2.定义事件监听器\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DemoListener implements ApplicationListener<DemoEvent> {\n    /**\n     * 对消息进行接受处理\n     * @param event\n     */\n    @Override\n    public void onApplicationEvent(DemoEvent event) {\n        String msg = event.getMsg();\n        System.out.println(\"DemoListener 接受到了消息\" + msg );\n        event.todoSomethings();\n        System.out.println(\"正在做第二件事\");\n    }\n}\n```\n3.发布事件\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DemoPublisher {\n    /**\n     * 注入ApplicationContext来发布事件\n     */\n    @Autowired\n    ApplicationContext context;\n\n    /**\n     * 发布事件\n     * @param msg\n     */\n    public void publish(String msg) {\n        context.publishEvent(new DemoEvent(this,msg));\n    }\n}\n\n```\n\n4.定义配置类\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan(\"com.smart.boot.event\")\npublic class Config {\n}\n\n```\n\n5.运行\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Application {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        DemoPublisher demoPublisher = context.getBean(DemoPublisher.class);\n        demoPublisher.publish(\"hello songshuiyang\");\n        context.close();\n    }\n}\n\n```\n\n6.实现结果\n```java\nDemoListener 接受到了消息hello songshuiyang\n正在做第一件事 , 做完需要做第二件事\n正在做第二件事\n```\n#### 总结\n1. 实现事件监听可以使业务解耦, 每个模块做好自己的事情即可, \n2. 可用在用户注册功能, eg: http://jinnianshilongnian.iteye.com/blog/1902886\n","tags":["Spring"],"categories":["服务器"]},{"title":"注解Value, Spring EL","url":"/2018/01/14/backend/framework/spring/注解Value/","content":"### @Value用法及配合Spring EL使用\n\n#### spring支持@Value注解获取一些配置信息及加载资源\n\n\n> ELConfig.java\n```java\npackage com.smart.boot.el;\n\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.Resource;\n\n@Configuration\n@ComponentScan(\"com.smart.boot.el\")\n@PropertySource(\"classpath:el.properties\")\npublic class ELConfig {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n    /**\n     * 注入普通字符串\n     */\n    @Value(\"songsy\")\n    private String str;\n    /**\n     * 通过el注入操作系统属性\n     */\n    @Value(\"# {systemProperties['os.name']}\")\n    private String osName;\n    /**\n     * 表达式结果\n     */\n    @Value(\"#{ T(java.lang.Math).random() * 100.0 }\")\n    private double randomNumber;\n    /**\n     * 注入其他Bean属性\n     */\n    @Value(\"#{eLService.another}\")\n    public String fromAnothor;\n    /**\n     * 注入文件资源\n     */\n    @Value(\"classpath:el.properties\")\n    private Resource testFile;\n    /**\n     * 注入网站资源\n     */\n    @Value(\"http://www.baidu.com\")\n    private Resource testUrl;\n    /**\n     * 注入配置文件\n     */\n    @Value(\"${book.name}\")\n    private String bookName;\n\n    /**\n     * 环境配置\n     * 环境在容器中是一个抽象的集合，是指应用环境的2个方面: profiles和 properties.\n     * profile:\n     * 配置是一个被命名的，bean定义的逻辑组，这些bean只有在给定的profile配置激活时才会注册到容器。不管是XML还是注解，\n     * Beans都有可能指派给profile配置。Environment环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。\n     * Properties:\n     * 扮演一个非常重要的角色,可能来源于一下源码变量:properties文件，JVM properties,system环境变量，JNDI, servlet context parameters上下文参数,\n     * 专门的Properties对象，Maps等等。Environment对象的作用，对于properties来说，是提供给用户方便的服务接口，方便撰写配置、方便解析配置。\n     * 作者：不迷失\n     * 链接：https://www.jianshu.com/p/49e950b0b008\n     * 來源：简书\n     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n     */\n    @Autowired\n    private Environment environment;\n\n    /**\n     * 若使用@Value注入, 则要配置一个PropertySourcesPlaceholderConfigurer\n     *\n     * @return\n     */\n    @Bean\n    public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {\n        return new PropertySourcesPlaceholderConfigurer();\n    }\n\n    public void print() throws Exception {\n        logger.info(\"str: \" + str);\n        logger.info(\"osName: \" + osName);\n        logger.info(\"randomNumber: \" + String.valueOf(randomNumber));\n        logger.info(\"fromAnothor: \" + fromAnothor);\n        logger.info(\"testFile: \" + IOUtils.toString(testFile.getInputStream()));\n        logger.info(\"testUrl: \" + IOUtils.toString(testUrl.getInputStream()));\n        logger.info(\"bookName: \" + bookName);\n        logger.info(\"environment: \" + environment.getProperty(\"book.author\"));\n    }\n}\n\n```\n\n<!--more-->\n> ELService.java\n```java\npackage com.smart.boot.el;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service(\"eLService\")\npublic class ELService {\n\n    public String another;\n\n    public String getAnother() {\n        return another;\n    }\n\n    @Autowired\n    public void setAnother() {\n        this.another = \"ELService 自动注入\";\n    }\n}\n\n```\n> ELMain.java\n```java\npackage com.smart.boot.el;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class ELMain {\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ELConfig.class);\n        ELConfig elConfig = context.getBean(ELConfig.class);\n        elConfig.print();\n        context.close();\n    }\n}\n```","tags":["Spring"],"categories":["服务器"]},{"title":"npm scripts","url":"/2018/01/14/frontend/npm/npm scripts/","content":"### 一、什么是 npm 脚本\nnpm 允许在package.json文件里面，使用scripts字段定义脚本命令。\n```sql\n{\n  // ...\n  \"scripts\": {\n    \"build\": \"node build.js\"\n  }\n}\n```\n上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。\n命令行下使用npm run命令，就可以执行这段脚本。\n```sql\n$ npm run build\n# 等同于执行\n$ node build.js\n```\n这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多\n1. 项目的相关脚本，可以集中在一个地方。\n2. 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。\n3. 可以利用 npm 提供的很多辅助功能。\n\n查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。\n```sql\n$ npm run\n```\n### 二：执行顺序\n如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。\n如果是并行执行（即同时的平行执行），可以使用&符号。\n```sql\n$ npm run script1.js & npm run script2.js\n```\n\n如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号\n```sql\n$ npm run script1.js && npm run script2.js\n```\n\n### 应用\n在 `package.json` 添加以下代码执行`npm run gg` 可以连续执行（hexo g）（hexo d）俩个命令，这样就不用每次执行俩个命令\n```sql\n \"scripts\": {\n    \"gg\": \"hexo g && hexo d\"\n  }\n```\n详见:http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html","tags":["npm"],"categories":["client"]},{"title":"接入银联支付接口","url":"/2018/01/11/backend/business/payment/接入银联支付接口/","content":"吐槽一下：\n\n> 1.银联支付SDK是没有提供独立的jar包的，高大上的银联把示例demo和sdk整合在一起了，支付流程和支付宝支付相似，支付需要到银联的支付页面\n\n> 2.证书说明：其实我们只需要一个邮件上的签名证书文件，官网上文档说的开发者调用接口前需要的其他证书在开发包中目录assets下都有，每个人都一样，没错，每个人都一样\n\n> 3.银联开发平台常常在下午6点发版本，遇到过俩次，第一次感到惊讶:银联网站挂了？不可能呀，过了十多分钟又恢复正常，晕\n\n> 4.代码不够规范，用代码检测工具一片黄色\n```java\n/**\n * @ClassName AcpService\n * @Description acpsdk接口服务类，接入商户集成请可以直接参考使用本类中的方法\n * @date 2016-7-22 下午2:44:37\n * 声明：以下代码只是为了方便接入方测试而提供的样例代码，商户可以根据自己需要，按照技术文档编写。该代码仅供参考，不提供编码，性能，规范性等方面的保障\n */\n```\n<!--more-->\n#### 大致步骤\n\n##### 一：下载demo及sdk\nhttps://open.unionpay.com/ajweb/product/newProDetail?proId=1&cataId=14\n\n##### 二：配置参数：\n\n接入银联支付审核 听头说好像是挺繁琐的，费时费力，接入银联支付设及到下面几个参数，其他的参数银联都帮我们配置好了\n\n1.商户号: 在银联商家技术服务中心可以看到 https://open.unionpay.com/ajweb/index，注意：在测试环境的商户号一致，刚开始我还不相信，通过客服才知道俩个是一样的，在测试账号信息里面可以看到\n\n2.后台通知地址：填写接收银联后台通知的地址，必须外网能访问\n\n3.前台通知地址：填写处理银联前台通知的地址，必须外网能访问\n\n4.签名证书: 在审核成功发送的邮件里面\n\n5.签名证书密码： 在审核成功发送的邮件里面有\n\n##### 三：调用支付接口\n\n```java\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\n\nthrows ServletException, IOException {\n\nresp.setContentType(\"text/html; charset=\"+ DemoBase.encoding);\n\n\n//前台页面传过来的\n\nString merId = req.getParameter(\"merId\");\n\nString txnAmt = req.getParameter(\"txnAmt\");\n\n\nMap<String, String> requestData = new HashMap<String, String>();\n\n\n/***银联全渠道系统，产品参数，除了encoding自行选择外其他不需修改***/\n\nrequestData.put(\"version\", DemoBase.version);     //版本号，全渠道默认值\n\nrequestData.put(\"encoding\", DemoBase.encoding);   //字符集编码，可以使用UTF-8,GBK两种方式\n\nrequestData.put(\"signMethod\", SDKConfig.getConfig().getSignMethod()); //签名方法\n\nrequestData.put(\"txnType\", \"01\");                 //交易类型 ，01：消费\n\nrequestData.put(\"txnSubType\", \"01\");              //交易子类型， 01：自助消费\n\nrequestData.put(\"bizType\", \"000201\");             //业务类型，B2C网关支付，手机wap支付\n\nrequestData.put(\"channelType\", \"07\");             //渠道类型，这个字段区分B2C网关支付和手机wap支付；07：PC,平板  08：手机\n\n\n/***商户接入参数***/\n\nrequestData.put(\"merId\", merId);                //商户号码，请改成自己申请的正式商户号或者open上注册得来的777测试商户号\n\nrequestData.put(\"accessType\", \"0\");               //接入类型，0：直连商户 \n\nrequestData.put(\"orderId\",DemoBase.getOrderId());             //商户订单号，8-40位数字字母，不能含“-”或“_”，可以自行定制规则\n\nrequestData.put(\"txnTime\", DemoBase.getCurrentTime());        //订单发送时间，取系统时间，格式为YYYYMMDDhhmmss，必须取当前时间，否则会报txnTime无效\n\nrequestData.put(\"currencyCode\", \"156\");           //交易币种（境内商户一般是156 人民币）\n\nrequestData.put(\"txnAmt\", txnAmt);                   //交易金额，单位分，不要带小数点\n\n//requestData.put(\"reqReserved\", \"透传字段\");              //请求方保留域，如需使用请启用即可；透传字段（可以实现商户自定义参数的追踪）本交易的后台通知,对本交易的交易状态查询交易、对账文件中均会原样返回，商户可以按需上传，长度为1-1024个字节。出现&={}[]符号时可能导致查询接口应答报文解析失败，建议尽量只传字母数字并使用|分割，或者可以最外层做一次base64编码(base64编码之后出现的等号不会导致解析失败可以不用管)。\n\n\n//前台通知地址 （需设置为外网能访问 http https均可），支付成功后的页面 点击“返回商户”按钮的时候将异步通知报文post到该地址\n\n//如果想要实现过几秒中自动跳转回商户页面权限，需联系银联业务申请开通自动返回商户权限\n\n//异步通知参数详见open.unionpay.com帮助中心 下载  产品接口规范  网关支付产品接口规范 消费交易 商户通知\n\nrequestData.put(\"frontUrl\", DemoBase.frontUrl);\n\n\n//后台通知地址（需设置为【外网】能访问 http https均可），支付成功后银联会自动将异步通知报文post到商户上送的该地址，失败的交易银联不会发送后台通知\n\n//后台通知参数详见open.unionpay.com帮助中心 下载  产品接口规范  网关支付产品接口规范 消费交易 商户通知\n\n//注意:1.需设置为外网能访问，否则收不到通知    2.http https均可  3.收单后台通知后需要10秒内返回http200或302状态码 \n\n//    4.如果银联通知服务器发送通知后10秒内未收到返回状态码或者应答码非http200，那么银联会间隔一段时间再次发送。总共发送5次，每次的间隔时间为0,1,2,4分钟。\n\n//    5.后台通知地址如果上送了带有？的参数，例如：http://abc/web?a=b&c=d 在后台通知处理程序验证签名之前需要编写逻辑将这些字段去掉再验签，否则将会验签失败\n\nrequestData.put(\"backUrl\", DemoBase.backUrl);\n\n// 订单超时时间。\n\n// 超过此时间后，除网银交易外，其他交易银联系统会拒绝受理，提示超时。 跳转银行网银交易如果超时后交易成功，会自动退款，大约5个工作日金额返还到持卡人账户。\n\n// 此时间建议取支付时的北京时间加15分钟。\n\n// 超过超时时间调查询接口应答origRespCode不是A6或者00的就可以判断为失败。\n\nrequestData.put(\"payTimeout\", new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date().getTime() + 15 * 60 * 1000));\n\n\n//////////////////////////////////////////////////\n\n//\n\n//       报文中特殊用法请查看 PCwap网关跳转支付特殊用法.txt\n\n//\n\n//////////////////////////////////////////////////\n\n\n/**请求参数设置完毕，以下对请求参数进行签名并生成html表单，将表单写入浏览器跳转打开银联页面**/\n\nMap<String, String> submitFromData = AcpService.sign(requestData,DemoBase.encoding);  //报文中certId,signature的值是在signData方法中获取并自动赋值的，只要证书配置正确即可。\n\n\nString requestFrontUrl = SDKConfig.getConfig().getFrontRequestUrl();  //获取请求银联的前台地址：对应属性文件acp_sdk.properties文件中的acpsdk.frontTransUrl\n\nString html = AcpService.createAutoFormHtml(requestFrontUrl, submitFromData,DemoBase.encoding);   //生成自动跳转的Html表单\n\n\nLogUtil.writeLog(\"打印请求HTML，此为请求报文，为联调排查问题的依据：\"+html);\n\n//将生成的html写到浏览器中完成自动跳转打开银联支付页面；这里调用signData之后，将html写到浏览器跳转到银联页面之前均不能对html中的表单项的名称和值进行修改，如果修改会导致验签不通过\n\nresp.getWriter().write(html);\n\n}\n``` \n##### 异步通知：与支付宝微信异步通知处理相同\n参考于：\nhttps://open.unionpay.com/ajweb/product/newProDetail?proId=1&cataId=14\n","tags":["支付"],"categories":["server"]},{"title":"接入微信扫码支付接口","url":"/2018/01/11/backend/business/payment/接入微信支付接口/","content":"#### 准备条件\n##### 开始之前先看一下微信的几个平台:\n1. 微信公众平台:\n是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。\n平台入口：http://mp.weixin.qq.com。\n2. 微信开放平台:\n微信开放平台是商户APP接入微信支付开放接口的申请入口，通过此平台可申请微信APP支付。\n平台入口：http://open.weixin.qq.com。\n3. 微信商户平台:\n微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。\n平台入口：http://pay.weixin.qq.com\n\n刚开始接入的时候有点昏，各种参数需要到不同的平台找, 不像支付宝一样只有一个开发平台，如果是接入微信扫码支付设及到微信公众平台和微信商户平台，如果是手机app微信支付，设及到微信开放平台和微信商户平台\n\n##### 开通支付功能:\n有了平台账号之后，然后就是开通支付功能，等待审核通过，当然审核过程有可能被退回，大多是描述信息或者经营类别与营业执照描述不一致\n<!--more-->\n#### 微信支付开发:\n> 下面是微信支付的业务流程时序图, 可以看到与支付宝的支付流程主要流程是差不多的，只不过微信扫码可以在本系统完成支付，没有发生页面跳转，可以自己DIY支付页面，只要将支付链接生成二维码图片即可完成支付\n![logo](/images/server/支付/weixin.png)    \n\n##### 接入微信支付步骤\n\n###### 1. 获取支付SDK\n\n gradle:地址    `compile(\"com.github.wxpay:wxpay-sdk:0.0.3\")`\n\n###### 2. 配置参数\n\n主要是如下参数, 可以配置在一个属性文件中方面配置\n\n1、APP ID ，应用ID（在公众平台--基本配置模块中）\n\n2、APP Sercret ，应用秘钥（在公众平台--基本配置模块中）32位数字大小写字母\n\n3、API Key，API的秘钥（在商户平台--API安全中设置）\n\n4、mchID , 商户号（在公众平台---微信支付---商户信息）\n\n5、order_api ， 统一下单API的接口\n\n6、notify_url    交易成功回调的接口的URL\n\n###### 3. 新建一个参数配置类\n\n> WxPcPayConfigImpl.java 继承 WXPayConfig.java\n\n```java\n/**\n * 微信支付PC端 基础属性配置\n */\npublic class WxPcPayConfigImpl implements WXPayConfig {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    // 配置文件地址\n    private static final String FILE_NAME = \"weixin_pc_pay.properties\";\n\n    // 服务号的应用ID\n    public static String APP_ID;\n    // 服务号的应用密钥\n    public static String APP_SECRET;\n    // 服务号的配置token\n    public static String TOKEN;\n    // 商户号\n    public static String MCH_ID;\n    // API密钥\n    public static String API_KEY;\n    // 签名加密方式\n    public static String SIGN_TYPE;\n    // 微信支付证书\n    public static String CERT_PATH;\n    // 异步回调地址\n    public static String NOTIFY_URL;\n    // 是否使用沙箱环境\n    public static boolean IS_USE_SANDBOX;\n    // 证书\n    private static byte[] certData;\n    // INSTANCE\n    private static WxPcPayConfigImpl INSTANCE;\n    // 配置对象\n    private static Configuration configs;\n    // 文件分隔符\n    public final static String SF_FILE_SEPARATOR = System.getProperty(\"file.separator\");//文件分隔符\n    // 二维码图片宽度\n    public final static int QR_IMG_WIDTH = 300;\n    // 二维码图片高度\n    public final static int QR_IMG_HEIGHT = 300;\n\n    /**\n     * 返回配置文件实例\n     *\n     * @return\n     * @throws Exception\n     */\n    public static WxPcPayConfigImpl getInstance() throws Exception {\n        if (INSTANCE == null) {\n            synchronized (WxPcPayConfigImpl.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = new WxPcPayConfigImpl();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n\n    /**\n     * 加载微信配置文件\n     */\n    public static synchronized void init() {\n        if (configs != null) {\n            return;\n        }\n        try {\n            configs = new PropertiesConfiguration(FILE_NAME);\n        } catch (ConfigurationException e) {\n            e.printStackTrace();\n        }\n\n        if (configs == null) {\n            throw new IllegalStateException(\"读取配置文件错误\" + FILE_NAME);\n        }\n        APP_ID = configs.getString(\"appId\");\n        APP_SECRET = configs.getString(\"appSecret\");\n        TOKEN = configs.getString(\"token\");\n        MCH_ID = configs.getString(\"mchId\");\n        API_KEY = configs.getString(\"apiKey\");\n        SIGN_TYPE = configs.getString(\"signType\");\n        CERT_PATH = configs.getString(\"certPath\");\n        IS_USE_SANDBOX = configs.getBoolean(\"isUseSandbox\");\n        NOTIFY_URL = configs.getString(\"notifyUrl\");\n\n        // 加载证书\n        File file;\n        try {\n            // file = new File(CERT_PATH);\n            Resource resource = new ClassPathResource(CERT_PATH);\n            file = resource.getFile();\n            InputStream certStream = new FileInputStream(file);\n            certData = new byte[(int) file.length()];\n            certStream.read(certData);\n            certStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    /**\n     * 获取 App ID\n     *\n     * @return App ID\n     */\n    @Override\n    public String getAppID() {\n        return APP_ID;\n    }\n    /**\n     * 获取 Mch ID\n     *\n     * @return Mch ID\n     */\n    @Override\n    public String getMchID() {\n        return MCH_ID;\n    }\n    /**\n     * 获取 API 密钥\n     *\n     * @return API密钥\n     */\n    @Override\n    public String getKey() {\n        return API_KEY;\n    }\n    /**\n     * 获取商户证书内容\n     *\n     * @return 商户证书内容\n     */\n    @Override\n    public InputStream getCertStream() {\n        ByteArrayInputStream certBis;\n        certBis = new ByteArrayInputStream(this.certData);\n        return certBis;\n    }\n    /**\n     * HTTP(S) 连接超时时间，单位毫秒\n     *\n     * @return\n     */\n    @Override\n    public int getHttpConnectTimeoutMs() {\n        return 8000;\n    }\n    /**\n     * HTTP(S) 读数据超时时间，单位毫秒\n     *\n     * @return\n     */\n    @Override\n    public int getHttpReadTimeoutMs() {\n        return 10000;\n    }\n\n    public byte[] getCertData() {\n        return certData;\n    }\n\n    public void setCertData(byte[] certData) {\n        this.certData = certData;\n    }\n}\n```\n###### 4. new 一个`WXPay`对象\n```java\nWXPay wxAppPay;\nWxPcPayConfigImpl pcConfig = WxPcPayConfigImpl.getInstance();\nwxpay = new WXPay(pcConfig, WXPayConstants.SignType.MD5, WxPcPayConfigImpl.IS_USE_SANDBOX);\n```\n\n\n###### 5. 有了\"对象\"之后就可以发送支付请求了\n```java\n    /**\n     * PC端微信支付请求\n     *\n     * @param domainId 商户订单号取实体类id\n     * @param amount   充值金额\n     * @return 处理结果数据\n     */\n    public Map<String, Object> weixinPay(String domainId, BigDecimal amount, HttpServletRequest request) {\n        Map<String, Object> resultMaps = new HashMap<>();\n        resultMaps.put(\"status\", \"success\");\n\n        HashMap<String, String> data = new HashMap<>();\n        String currentUserName = \"\";\n        if (AccountUtils.getCurrentUser() != null) {\n            if (StringUtils.isNotBlank(AccountUtils.getCurrentUser().getFdNickName())) {\n                currentUserName = AccountUtils.getCurrentUser().getFdNickName();\n            }\n        }\n        String description = currentUserName + \" 账户充值\";\n\n        data.put(\"body\", description);                                  // 商品描述\n        data.put(\"out_trade_no\", domainId);                             // 商户订单号\n        data.put(\"total_fee\", AmountUtils.transAmountToCent(amount));   // 总金额,单位为分\n        data.put(\"spbill_create_ip\", WxUtils.getRemoteIp(request));     // 发起人IP地址\n        data.put(\"notify_url\", WxPcPayConfigImpl.NOTIFY_URL);           // 异步通知地址\n        data.put(\"trade_type\", \"NATIVE\");                               // 此处指定为扫码支付\n        data.put(\"product_id\", domainId);                               // 商品ID,trade_type=NATIVE时（即扫码支付），此参数必传\n\n        Map<String, String> resultMap;\n        try {\n            resultMap = wxpay.unifiedOrder(data);\n            logger.info(\"微信生成二维码返回xml 转成Json\" + JsonFormatUtil.formatJson(resultMap.toString()));\n            System.out.println(resultMap);\n        } catch (Exception e) {\n            e.printStackTrace();\n            logger.error(\"微信支付处理异常\");\n            resultMaps.put(\"status\", \"failed\");\n            return resultMaps;\n        }\n        String returnCode = resultMap.get(\"return_code\");\n        // 返回结果\n        if (\"SUCCESS\".equals(returnCode)) {\n            String resultCode = resultMap.get(\"result_code\");\n            // 处理结果\n            if (\"SUCCESS\".equals(resultCode)) {\n                logger.info(\"订单号：{}生成微信支付码成功\", domainId);\n                String urlCode = resultMap.get(\"code_url\");\n                // 生成二维码\n                logger.info(\"\");\n                // WxUtils.encodeQRCode(urlCode,imgPath);\n                String imgBase64Str = WxUtils.encodeQRCodeBase64(urlCode);\n                // 是否是微信支付\n                resultMaps.put(\"id\", domainId);\n                resultMaps.put(\"isWxPay\", true);\n                resultMaps.put(\"img\", imgBase64Str);\n            } else {\n                String errCodeDes = resultMap.get(\"err_code_des\");\n                logger.info(\"订单号：{}生成微信支付码(系统)失败:{}\", domainId, errCodeDes);\n                resultMaps.put(\"status\", \"failed\");\n                return resultMaps;\n            }\n        } else {\n            String returnMsg = resultMap.get(\"return_msg\");\n            logger.info(\"(订单号：{}生成微信支付码(通信)失败:{}\", domainId, returnMsg);\n            resultMaps.put(\"status\", \"failed\");\n            return resultMaps;\n        }\n        return resultMaps;\n    }\n\n```\n\n微信支付统一下单接口:\n```java\n    /**\n     * 作用：统一下单<br>\n     * 场景：公共号支付、扫码支付、APP支付\n     * @param reqData 向wxpay post的请求数据\n     * @return API返回数据\n     * @throws Exception\n     */\n    public Map<String, String> unifiedOrder(Map<String, String> reqData) throws Exception {\n        return this.unifiedOrder(reqData, config.getHttpConnectTimeoutMs(), this.config.getHttpReadTimeoutMs());\n    }\n```\n###### 6. 生成支付二维码\n这里我是将二维码链接字符串转成字符流 然后生成Base64位的图片字符, 只要在<img src=\"\"> 设置src属性值，就可以完成图片展示，不用考虑生成的图片放在那里\n\n###### 7. 支付完成, 处理异步回调\n\n\n###### 备注： 微信支付是使用的xml进行传输数据，需要将xml转成map，当然微信SDK中也提供了工具类，提供了一些十分用的方法\n```java\npackage com.github.wxpay.sdk;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.util.*;\nimport java.security.MessageDigest;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport com.github.wxpay.sdk.WXPayConstants.SignType;\n\n\npublic class WXPayUtil {\n\n    /**\n     * XML格式字符串转换为Map\n     *\n     * @param strXML XML字符串\n     * @return XML数据转换后的Map\n     * @throws Exception\n     */\n    public static Map<String, String> xmlToMap(String strXML) throws Exception {\n        Map<String, String> data = new HashMap<String, String>();\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder();\n        InputStream stream = new ByteArrayInputStream(strXML.getBytes(\"UTF-8\"));\n        org.w3c.dom.Document doc = documentBuilder.parse(stream);\n        doc.getDocumentElement().normalize();\n        NodeList nodeList = doc.getDocumentElement().getChildNodes();\n        for (int idx=0; idx<nodeList.getLength(); ++idx) {\n            Node node = nodeList.item(idx);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                org.w3c.dom.Element element = (org.w3c.dom.Element) node;\n                data.put(element.getNodeName(), element.getTextContent());\n            }\n        }\n        try {\n            stream.close();\n        }\n        catch (Exception ex) {\n\n        }\n        return data;\n    }\n\n    /**\n     * 将Map转换为XML格式的字符串\n     *\n     * @param data Map类型数据\n     * @return XML格式的字符串\n     * @throws Exception\n     */\n    public static String mapToXml(Map<String, String> data) throws Exception {\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder();\n        org.w3c.dom.Document document = documentBuilder.newDocument();\n        org.w3c.dom.Element root = document.createElement(\"xml\");\n        document.appendChild(root);\n        for (String key: data.keySet()) {\n            String value = data.get(key);\n            if (value == null) {\n                value = \"\";\n            }\n            value = value.trim();\n            org.w3c.dom.Element filed = document.createElement(key);\n            filed.appendChild(document.createTextNode(value));\n            root.appendChild(filed);\n        }\n        TransformerFactory tf = TransformerFactory.newInstance();\n        Transformer transformer = tf.newTransformer();\n        DOMSource source = new DOMSource(document);\n        transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        StringWriter writer = new StringWriter();\n        StreamResult result = new StreamResult(writer);\n        transformer.transform(source, result);\n        String output = writer.getBuffer().toString(); //.replaceAll(\"\\n|\\r\", \"\");\n        try {\n            writer.close();\n        }\n        catch (Exception ex) {\n        }\n        return output;\n    }\n\n\n    /**\n     * 生成带有 sign 的 XML 格式字符串\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @return 含有sign字段的XML\n     */\n    public static String generateSignedXml(final Map<String, String> data, String key) throws Exception {\n        return generateSignedXml(data, key, SignType.MD5);\n    }\n\n    /**\n     * 生成带有 sign 的 XML 格式字符串\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @param signType 签名类型\n     * @return 含有sign字段的XML\n     */\n    public static String generateSignedXml(final Map<String, String> data, String key, SignType signType) throws Exception {\n        String sign = generateSignature(data, key, signType);\n        data.put(WXPayConstants.FIELD_SIGN, sign);\n        return mapToXml(data);\n    }\n\n\n    /**\n     * 判断签名是否正确\n     *\n     * @param xmlStr XML格式数据\n     * @param key API密钥\n     * @return 签名是否正确\n     * @throws Exception\n     */\n    public static boolean isSignatureValid(String xmlStr, String key) throws Exception {\n        Map<String, String> data = xmlToMap(xmlStr);\n        if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) {\n            return false;\n        }\n        String sign = data.get(WXPayConstants.FIELD_SIGN);\n        return generateSignature(data, key).equals(sign);\n    }\n\n    /**\n     * 判断签名是否正确，必须包含sign字段，否则返回false。使用MD5签名。\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @return 签名是否正确\n     * @throws Exception\n     */\n    public static boolean isSignatureValid(Map<String, String> data, String key) throws Exception {\n        return isSignatureValid(data, key, SignType.MD5);\n    }\n\n    /**\n     * 判断签名是否正确，必须包含sign字段，否则返回false。\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @param signType 签名方式\n     * @return 签名是否正确\n     * @throws Exception\n     */\n    public static boolean isSignatureValid(Map<String, String> data, String key, SignType signType) throws Exception {\n        if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) {\n            return false;\n        }\n        String sign = data.get(WXPayConstants.FIELD_SIGN);\n        return generateSignature(data, key, signType).equals(sign);\n    }\n\n    /**\n     * 生成签名\n     *\n     * @param data 待签名数据\n     * @param key API密钥\n     * @return 签名\n     */\n    public static String generateSignature(final Map<String, String> data, String key) throws Exception {\n        return generateSignature(data, key, SignType.MD5);\n    }\n\n    /**\n     * 生成签名. 注意，若含有sign_type字段，必须和signType参数保持一致。\n     *\n     * @param data 待签名数据\n     * @param key API密钥\n     * @param signType 签名方式\n     * @return 签名\n     */\n    public static String generateSignature(final Map<String, String> data, String key, SignType signType) throws Exception {\n        Set<String> keySet = data.keySet();\n        String[] keyArray = keySet.toArray(new String[keySet.size()]);\n        Arrays.sort(keyArray);\n        StringBuilder sb = new StringBuilder();\n        for (String k : keyArray) {\n            if (k.equals(WXPayConstants.FIELD_SIGN)) {\n                continue;\n            }\n            if (data.get(k).trim().length() > 0) // 参数值为空，则不参与签名\n                sb.append(k).append(\"=\").append(data.get(k).trim()).append(\"&\");\n        }\n        sb.append(\"key=\").append(key);\n        if (SignType.MD5.equals(signType)) {\n            return MD5(sb.toString()).toUpperCase();\n        }\n        else if (SignType.HMACSHA256.equals(signType)) {\n            return HMACSHA256(sb.toString(), key);\n        }\n        else {\n            throw new Exception(String.format(\"Invalid sign_type: %s\", signType));\n        }\n    }\n\n\n    /**\n     * 获取随机字符串 Nonce Str\n     *\n     * @return String 随机字符串\n     */\n    public static String generateNonceStr() {\n        return UUID.randomUUID().toString().replaceAll(\"-\", \"\").substring(0, 32);\n    }\n\n\n    /**\n     * 生成 MD5\n     *\n     * @param data 待处理数据\n     * @return MD5结果\n     */\n    public static String MD5(String data) throws Exception {\n        java.security.MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] array = md.digest(data.getBytes(\"UTF-8\"));\n        StringBuilder sb = new StringBuilder();\n        for (byte item : array) {\n            sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));\n        }\n        return sb.toString().toUpperCase();\n    }\n\n    /**\n     * 生成 HMACSHA256\n     * @param data 待处理数据\n     * @param key 密钥\n     * @return 加密结果\n     * @throws Exception\n     */\n    public static String HMACSHA256(String data, String key) throws Exception {\n        Mac sha256_HMAC = Mac.getInstance(\"HmacSHA256\");\n        SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"HmacSHA256\");\n        sha256_HMAC.init(secret_key);\n        byte[] array = sha256_HMAC.doFinal(data.getBytes(\"UTF-8\"));\n        StringBuilder sb = new StringBuilder();\n        for (byte item : array) {\n            sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));\n        }\n        return sb.toString().toUpperCase();\n    }\n}\n```\n\n\n参考于: \nhttp://mp.weixin.qq.com\n\nhttp://open.weixin.qq.com\n\nhttp://pay.weixin.qq.com\n\n\n","tags":["支付"],"categories":["server"]},{"title":"接入支付宝支付接口","url":"/2018/01/10/backend/business/payment/接入支付宝支付接口/","content":"### 一: 应用场景\n1. 主要应用于一些交易平台商品订单支付，账户充值，线上收费这些有支付需求的交易\n\n2. 用户通过支付宝PC收银台完成支付，交易款项即时给到商户支付宝账户\n\n![logo](/images/server/支付/taobao.png)\n\n![logo](/images/server/支付/12306.png) \n\n<!--more-->\n\n### 二: 准备条件\n1. 一个公司, 不是公司的话是不能接入商户支付宝网关支付的, 当然支付宝是分个人用户和商户用户的, 如果是个人网站的话可以贴个自己收款二维码上去进行收款, 如果是正在运营的商户企业收取费用的话是要接入支付宝网关支付功能进行收费, 这样的话可以看起来bigger更高\n\n2. 企业或个体工商户，具有真实有效的营业执照，且支付宝账户名称需与营业执照主体一致\n\n3. 网站通过ICP备案，能正常访问，页面显示完整，有明确的运营内容与完整的商品信息。\n\n### 三：接入支付宝支付功能步骤\n\n#### 第一步：创建应用\n要在应用中使用支付宝开放产品的接口能力：\n\n1. 需要先去蚂蚁金服开放平台，在开发者中心创建登记您的应用，此时将获得应用唯一标识（APPID）\n2. 请在【功能信息】中点击【添加功能】，选择【电脑网站支付】\n3. 提交审核（需要上传公司营业执照,填写法人身份信息等等），等待审核通过，该应用正式可以使用\n\n> TIPS：电脑网站支付接口需签约后才能调用\n\n#### 第二步：配置密钥\n\n开发者调用接口前需要先生成RSA密钥，RSA密钥包含应用私钥(APP_PRIVATE_KEY)、应用公钥(APP_PUBLIC_KEY）。生成密钥后在开放平台管理中心进行密钥配置，配置完成后可以获取支付宝公钥(ALIPAY_PUBLIC_KEY)。\n\n\n**用途：**\n支付宝发送信息给商户系统时，使用支付宝私钥对数据进行加签，商户获取到支付宝加签的信息后使用支付宝公钥对数据进行验签，得到正确的数据。\n商户系统给支付宝发送信息时，使用商户自己的私钥对数据加签，支付宝获取到数据后使用商家上传的公钥进行验签。\n\n\n**加签步骤:**\n\n1.筛选\n\n获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign与sign_type参数。\n\n2.排序\n\n将筛选的参数按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。\n拼接\u000b将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&字符连接起来，此时生成的字符串为待签名字符串。商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝\n\n3.拼接\n\n将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&字符连接起来，此时生成的字符串为待签名字符串。\n\n4.加签\n\n商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝\n\n\n**验签步骤：**\n\n与加签步骤一致，只不过是延签是使用公钥算出sign值，两方算出的sign值都一致的话则延签成功\n\n#### 第三步：搭建和配置开发环境\n1. 需要到支付宝开发平台下载服务端SDK,打包即用, 十分方便\n\n2. 配置参数\n```java\nAlipayClient alipayClient = new DefaultAlipayClient(URL,APP_ID,APP_PRIVATE_KEY,FORMAT,CHARSET,ALIPAY_PUBLIC_KEY,SIGN_TYPE);\n\n// URL:支付宝网关（固定） https://openapi.alipay.com/gateway.do, 如果是沙箱环境的话: https://openapi.alipaydev.com/gateway.do\n// APP_ID:创建应用时获取, 支付宝提供\n// APP_PRIVATE_KEY: 应用私钥, 运用支付宝提供的工具进行生成\n// FORMAT: json（固定）\n// CHARSET: 编码格式\n// ALIPAY_PUBLIC_KEY: 支付宝公钥, 由支付宝提供\n// SIGN_TYPE： 加签类型，商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2\n```\n> 配置完参数之后就可以调用支付宝的支付接口了, 十分方便, 阿里阿里 !!!\n3. 配置完参数之后先来看一下支付的调用流程：\n![logo](/images/server/支付/step.png) \n\n4. 接下来就是发起支付请求了\n```java\nimport com.alipay.api.*;\nimport com.alipay.api.request.*; \npublic void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException,IOException { \n//获得初始化的AlipayClient \nAlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\", APP_ID, APP_PRIVATE_KEY, FORMAT, CHARSET, ALIPAY_PUBLIC_KEY, SIGN_TYPE);\n//创建支付请求的对应request\nAlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();\n//设置请求参数及回跳地址和通知地址\n alipayRequest.setBizContent(\n\"{\" + \" \\\"out_trade_no\\\":\\\"20150320010101001\\\",\n\" + \" \\\"total_amount\":88.88,\n\" + \" \\\"subject\\\":title\\\",\n\" + \" \\\"body\\\":\\\"Iphone6 16G\\\",\n\" + }\");\n//跳转地址就是支付完成之后，支付宝自动执行页面重定向,就是跳转到我们设置的页面\nalipayRequest.setReturnUrl(\"http://www.songshuiyang.site/return_url\"); \n//通知地址就是支付宝会根据API中商户传入的notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统。\nalipayRequest.setNotifyUrl(\"http://www.songshuiyang.site/notify_url\");\nString form=\"\";\ntry { \n //调用SDK生成html表单\n  form = alipayClient.pageExecute(alipayRequest).getBody(); \n} catch (AlipayApiException e) { \n  e.printStackTrace(); \n} \n//直接将完整的表单html输出到页面\nhttpResponse.setContentType(\"text/html;charset=\" + CHARSET); httpResponse.getWriter().write(form); httpResponse.getWriter().flush(); httpResponse.getWriter().close(); \n} \n```\n\n**支付接口生成的html代码**\n```html\n<form name=\"punchout_form\" method=\"post\" action=\"https://openapi.alipay.com/gateway.do?charset=utf-8&method=alipay.trade.page.pay&sign=jsgXRru7b%2FHLO76SMPoj6lIuCnKJ9lkLo%2BTPIKfetqMOd8kyp2zYBZ456Dvf0eb4SyYgUrOjAgTkNW2AkgJh%2BbLJDu3eAtQVAUEEzFGy2Ix3uE3j3lPLHZDs1cF7g8vw7hwfmEqe8CE8OCJ%2B79J0Hp6YFOH8vnJEDUPvjla2AsCO0mhAsnYxm30rmqgDqJPfZLytOvRD5FF%2BoBd4UPH%2Budk7vCn9lEX%2BkEe7YBa3E7l6vWxXz%2BJDKGL9ZMHNtUzYUaid%2F%2BIugVLqtECybldd8YDZUFnz92Iq%2BOwIL09MzNtb6iC9AypfQxlTseFezDihBn%2Fey5itIovqntbLLdxt2g%3D%3D&return_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment%2Findex&notify_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment2%2Falipay_notify&version=1.0&app_id=123456789101554&sign_type=RSA2&timestamp=2018-01-01+14%3A27%3A50&alipay_sdk=alipay-sdk-java-dynamicVersionNo&format=json\">\n   <input type=\"hidden\" name=\"biz_content\" value=\"{&quot;out_trade_no&quot;:&quot;160b06765224a9aee66a6654541b947f&quot;,&quot;total_amount&quot;:&quot;0.01&quot;,&quot;subject&quot;:&quot;江西广而易科技有限公司  账户充值&quot;,&quot;body&quot;:&quot;充值金额: 0.01&quot;,&quot;product_code&quot;:&quot;FAST_INSTANT_TRADE_PAY&quot;}\">\n     <input type=\"submit\" value=\"立即支付\" style=\"display:none\" >\n</form>\n<script>document.forms[0].submit();</script>\n```\n\n**注意**\n1. action 链接后面的sign值就是签名字符串, 用于校验数据的来源还有数据有没有被修改\n2. biz_content 是业务参数\n3. html输出到页面后会跳转到支付的支付页面\n\n#### 第四步：扫码支付进行的步骤\n1.支付\n ![logo](/images/server/支付/pagePay.jpg) \n\n2.支付成功会自动跳转到商户页面(同步通知) \n\n> 就是前面设置的 alipayRequest.setReturnUrl(\"http://www.songshuiyang.site/return_url\");,这部是支付完成之后支付宝的处理程序进行了页面重定向, 不是支付宝主动触发的。\n ![logo](/images/server/支付/paysuccess.png) \n\n3.系统后台收到异步通知\n\n> 对于PC网站支付的交易，在用户支付完成之后，支付宝会根据API中商户传入的alipayRequest.setNotifyUrl(\"http://www.songshuiyang.site/notify_url\");，通过POST请求的形式将支付结果作为参数通知到商户系统，该方式的作用是页面跳转同步通知没有处理订单更新，需要通过异步通知的方式去通知系统后台更新流水\n\n4.进行异步通知处理\n\n> 程序执行完后必须打印输出“success”。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）；\n\n处理代码:\n```java\n//将异步通知中收到的所有参数都存放到map中\nMap<String, String> paramsMap = ...;\n//调用SDK验证签名\nboolean signVerified = AlipaySignature.rsaCheckV1(paramsMap, ALIPAY_PUBLIC_KEY, CHARSET, SIGN_TYPE) \nif(signVerfied){ \n// TODO 验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验\n1、商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，\n2、判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），\n3、校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方\n4、验证app_id是否为该商户本身。\n// 二次校验成功，继续商户自身业务处理，处理完成之后返回success\n\n} else {\n // TODO 验签失败则记录异常日志，并在response中返回failure. \n} \n```\n\n**注意：** \n1.  这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致延签失败\n\n5. 如果是异步通知处理失败\n> 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付异步通知；需要自己手动向支付宝发送查询请求，根据查询出来的结果确定该交易是否成功\n\n```java\nAlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\",\"app_id\",\"your private_key\",\"json\",\"GBK\",\"alipay_public_key\",\"RSA2\"); \n//创建查询请求的对应request\nAlipayTradeQueryRequest request = new AlipayTradeQueryRequest();\nrequest.setBizContent(\"{\" + \n\"\\\"out_trade_no\\\":\\\"20150320010101001\\\",\n\" + \"\\\"trade_no\\\":\\\"2014112611001004680073956707\\\"\" + \n\"}\"); \nAlipayTradeQueryResponse response = alipayClient.execute(request); \nif(response.isSuccess()){ \n//交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）、TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）、TRADE_SUCCESS（交易支付成功）、TRADE_FINISHED（交易结束，不可退款）\n    System.out.println(\"调用成功\"); \n} else {\n    System.out.println(\"调用失败\"); \n\n```\n\n**注意：** \n1.  这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致签名失败\n\n#### 五：支付宝网关支付API\n|     接口英文名 | 接口中文    | \n    | --------   | -----:   | \n    | alipay.trade.page.pay       | 统一收单下单并支付页面接口 |\n    |  alipay.trade.refund        | 统一收单交易退款接口      |\n    | alipay.trade.fastpay.refund.query      | 统一收单交易退款查询接口 |\n    |  alipay.trade.query       | 统一收单线下交易查询接口     |\n    | alipay.trade.close       | 统一收单交易关闭接口 |\n    |  alipay.data.dataservice.bill.downloadurl.query       | 查询对账单下载地址      |\n\n#### 六： 使用沙箱环境进行测试\n\n> 蚂蚁沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑（当前沙箱支持产品请参考“沙箱支持产品列表”）。\u000b在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。\n \n ![logo](/images/server/支付/sandbox.png)\n \n> 可以体验一把土豪的感觉, 不用在真实环境下使用一分钱测试联调大法了\n\n#### 七：总结\n\n1. 支付宝的支付接口进行了高度封装，可以拿过来直接使用，不必关心怎样签名&验签、HTTP接口请求这些处理\n\n2. 在进行数据传输通信的同时，需要校验传输数据的来源，数据有没有进行修改，防止恶意数据攻击\n\n \n#### 注:\n本文内容参考支付宝开放平台文档内容, 一切以官方文档为准, 链接地址: https://open.alipay.com/platform/home.htm","tags":["支付"],"categories":["server"]},{"title":"Java基础-ASCII 160 空格","url":"/2018/01/09/backend/java/basicKnowledge/Java基础-ASCII 160 空格/","content":"### 场景\n>获取从http传输过来的字符串的时候，碰到解析字符串不能分割字符串的情况\n```java\nString str = doc.get(0); // str = \"江西省 赣州市\"\nString [] area = str.spilt(\"\\\\s+\");\n```\n运行上面的代码的时候发现不能截取字符串, 初步怀疑是编码问题，然而经过验证发现并不是,然后就通过字符串截取成 char 字符发现，该char字符ASCII是160,\n马上查找资料发现是空格分两种编码格式: 1: 普通的空格,ASCII码为32  2:第二种是 网页上的 &nbsp 空格,ASCII为160, 才发现空格也是有多种情况\n\n解决方法:\n```java\n// 需要将ASCII为160的空格转成普通的空格\nstr = str.replaceAll(\"[\\\\s\\\\u00A0]+\", \" \");\n\n```\n\n","tags":["Java"],"categories":["server"]},{"title":"Java基础-一切皆是对象","url":"/2018/01/09/backend/java/basicKnowledge/Java基础-一切皆是对象/","content":"##### # 用引用操纵对象\n> 在Java的世界里，一切都被视为对象，尽管一切都看成是对象，但操纵的标识符实际上是对象的一个引用,可将这一\n                                                   情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对电视机的控制，那么手上拿着的是遥控板，而非电视机。\n```sql\n遥控器  -->   电视\n引用    -->   对象\n```\n\n##### # 高精度数字\n```sql\nBigInteger 支持任意精度的整数。也就是说，我们可精确表示任意大小的整数值，同时在运算过程中不会丢失任何信息。\nBigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。\n\n对应于我们针对主类型执行的操作。也就是说，能对 int 或 float 做的事情，对 BigInteger 和 BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。\n```\n\n##### # 基本数据类型默认值\n\n##### 类文件的限制\n1. 每个文件只能有一个public类, 也可以没有public，如果有的话必须与文件名相同\n\n","tags":["Java"],"categories":["server"]},{"title":"Mysql 如何设置字段自动获取当前时间","url":"/2017/12/17/backend/database/Mysql 如何设置字段自动获取当前时间/","content":"应用场景：\n```sql\n1、在数据表中，要记录每条数据是什么时候创建的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录创建时间；\n\n2、在数据库中，要记录每条数据是什么时候修改的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录修改时间；\n```\n\n实现方式:\n```sql\n--修改CreateTime 设置默认时间 CURRENT_TIMESTAMP \nALTER TABLE `table_name`\nMODIFY COLUMN  `created_date` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' ;\n\n\n--修改 UpdateTime 设置 默认时间 CURRENT_TIMESTAMP   设置更新时间为 ON UPDATE CURRENT_TIMESTAMP \n\nALTER TABLE `table_name`\nMODIFY COLUMN `last_modified_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间' ;\n```\n\n转自：https://www.cnblogs.com/lhj588/p/4245719.html","tags":["db"],"categories":["server"]},{"title":"Druid Monitor","url":"/2017/12/11/backend/database/Druid Monitor/","content":"## Druid Monitor监控JavaSE和JavaWeb\n\n效果图:\n![logo](/images/server/数据库/druidMonitor.png) \n\nhttp://blog.csdn.net/binglovezi/article/details/50610269","tags":["druid"],"categories":["server"]},{"title":"Maven 41种骨架","url":"/2017/11/18/backend/buildTool/Maven/maven 骨架/","content":"Maven 的41种骨架功能介绍\n ...>mvn archetype:generate\n```sql\n1: internal -> appfuse-basic-jsf (创建一个基于Hibernate，Spring和JSF的Web应用程序的原型) \n2: internal -> appfuse-basic-spring (创建一个基于Hibernate，Spring和Spring MVC的Web应用程序的原型) \n3: internal -> appfuse-basic-struts (创建一个基于Hibernate，Spring和Struts 2的Web应用程序的原型) \n4: internal -> appfuse-basic-tapestry (创建一个基于Hibernate, Spring 和 Tapestry 4的Web应用程序的原型) \n5: internal -> appfuse-core (创建一个基于 Hibernate and Spring 和 XFire的jar应用程序的原型) \n6: internal -> appfuse-modular-jsf (创建一个基于 Hibernate，Spring和JSF的模块化应用原型) \n7: internal -> appfuse-modular-spring (创建一个基于 Hibernate, Spring 和 Spring MVC 的模块化应用原型) \n8: internal -> appfuse-modular-struts (创建一个基于 Hibernate, Spring 和 Struts 2 的模块化应用原型) \n9: internal -> appfuse-modular-tapestry (创建一个基于 Hibernate, Spring 和 Tapestry 4 的模块化应用原型) \n10: internal -> maven-archetype-j2ee-simple (一个简单的J2EE的Java应用程序) \n11: internal -> maven-archetype-marmalade-mojo (一个Maven的 插件开发项目 using marmalade) \n12: internal -> maven-archetype-mojo (一个Maven的Java插件开发项目) \n13: internal -> maven-archetype-portlet (一个简单的portlet应用程序) \n14: internal -> maven-archetype-profiles () \n15: internal -> maven-archetype-quickstart () \n16: internal -> maven-archetype-site-simple (简单的网站生成项目) \n17: internal -> maven-archetype-site (更复杂的网站项目) \n18: internal -> maven-archetype-webapp (一个简单的Java Web应用程序) \n19: internal -> jini-service-archetype (Archetype for Jini service project creation) \n20: internal -> softeu-archetype-seam (JSF+Facelets+Seam Archetype) \n21: internal -> softeu-archetype-seam-simple (JSF+Facelets+Seam (无残留) 原型) \n22: internal -> softeu-archetype-jsf (JSF+Facelets 原型) \n23: internal -> jpa-maven-archetype (JPA 应用程序) \n24: internal -> spring-osgi-bundle-archetype (Spring-OSGi 原型) \n25: internal -> confluence-plugin-archetype (Atlassian 聚合插件原型) \n26: internal -> jira-plugin-archetype (Atlassian JIRA 插件原型) \n27: internal -> maven-archetype-har (Hibernate 存档) \n28: internal -> maven-archetype-sar (JBoss 服务存档) \n29: internal -> wicket-archetype-quickstart (一个简单的Apache Wicket的项目) \n30: internal -> scala-archetype-simple (一个简单的scala的项目) \n31: internal -> lift-archetype-blank (一个 blank/empty liftweb 项目) \n32: internal -> lift-archetype-basic (基本（liftweb）项目) \n33: internal -> cocoon-22-archetype-block-plain ([http://cocoapacorg2/maven-plugins/]) \n34: internal -> cocoon-22-archetype-block ([http://cocoapacorg2/maven-plugins/]) \n35: internal -> cocoon-22-archetype-webapp ([http://cocoapacorg2/maven-plugins/]) \n36: internal -> myfaces-archetype-helloworld (使用MyFaces的一个简单的原型) \n37: internal -> myfaces-archetype-helloworld-facelets (一个使用MyFaces和Facelets的简单原型) \n38: internal -> myfaces-archetype-trinidad (一个使用MyFaces和Trinidad的简单原型) \n39: internal -> myfaces-archetype-jsfcomponents (一种使用MyFaces创建定制JSF组件的简单的原型) \n40: internal -> gmaven-archetype-basic (Groovy的基本原型) \n41: internal -> gmaven-archetype-mojo (Groovy mojo 原型)\n```\n原文: https://www.cnblogs.com/iusmile/archive/2012/11/14/2770118.html\n","tags":["maven"],"categories":["服务器"]},{"title":"Spring Aop","url":"/2017/11/18/backend/framework/spring/Spring Aop/","content":"## Spring Aop\n\n### 一: 概念 \n\n#### 1. 什么是AOP\n \n在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。\n\n####  2. 为什么要用Aop\n利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。在不改变原有方法的基础添加一些功能 , 比如:日志记录，性能统计，安全控制，事务处理，异常处理等等。\n\n<!--more-->\n\n####  3. Aop 术语\n> 连接点(JoinPoint)\n\n 程序执行到某个特定位置 , Spring 仅支持方法级的连接点(方法执行前，方法完成后，抛出异常后)\n\n> 切点(Pointcut)\n\n 从连接点的基础上引出的概念，是指特定的连接点，一个类有好多方法,每个方法又有多个连接点，则需要切点来限定一个小范围的连接点\n \n> 通知、增强处理(Advice)\n\n   就是指你所需要添加的功能及这个功能什么时候(通知)实现 , 比如一个业务方法需要实现日志功能 , 那么就需要专门在一个地方定义好需要做什么，然后定义什么时候执行(方法执行前？，方法完成后？，抛出异常？。。。)\n  \n   Spring 切面可应用的 5 种通知类型：\n   1. Before——在方法调用之前调用通知\n   2. After——在方法完成之后调用通知，无论方法执行成功与否\n   3. After-returning——在方法执行成功之后调用通知\n   4. After-throwing——在方法抛出异常后进行通知\n   5. Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为\n\n> 引入(introduction)\n \n  特殊的增强，为类添加一些属性和方法\n\n> 切面(Aspect)\n\n 切面由切点和增强组成 , 及包括横切逻辑的定义，也包括切点的定义, \n\n> 目标对象(Target)\n\n 增强逻辑的织入目标类 , 如果没有Aop,那么目标对象就要自己实现(日志记录，性能统计，安全控制，事务处理，异常处理)这些功能，那么一个方法就会变成很杂乱\n \n> 织入(Weaing)\n\n 将增强添加到目标对象的具体连接点上, Spring使用动态代理织入\n \n \n Aop有三种织入方式\n 1. 编译期织入\n 2. 类装载期织入\n 3. 动态代理织入: 在运行期间为目标类添加增强生成子类的方式\n### 二: Spring Aop 的应用\n\n> Spring Aop的使用一般通过俩种方式:第一种是通过注解的，第二种是通过xml配置\n\n#### 通过注解的方式实现Aop\n\n1. 第一步 Maven 导包\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <parent>\n        <groupId>ecut</groupId>\n        <artifactId>spring-parent</artifactId>\n        <version>0.0.1-SNAPSHOT</version>\n    </parent>\n\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>ecut</groupId>\n    <artifactId>spring-aop</artifactId>\n    <packaging>jar</packaging>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>spring-aop</name>\n\n    <dependencies>\n        <!-- spring 核心 -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-beans</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n\n        <!-- spring aop -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aspects</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n\n        <!--test-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- 日志 -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n        </dependency>\n\n\n    </dependencies>\n    <build>\n        <finalName>spring-aop</finalName>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <configuration>\n                    <skip>true</skip>\n                </configuration>\n            </plugin>\n\n            <!--@Override is not allowed when implementing interface method-->\n            <!-- 编码和编译和JDK版本 -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>2.3.2</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>utf8</encoding>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n2. 第二步 编写一个基于 @AspectJ 的切面\n```java\npackage com.aop.learn.aspectj;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author songshuiyang\n * @title: @Aspect\n * @description:\n * @date 2017/11/15\n */\n@Component\n@Aspect // 通过该注解将该类标识为一个切面\npublic class PreGreetingAspect {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 前置增强, greetTo方法执行前触发此方法\n     *\n     */\n    @Before(\"execution(* greetTo(..))\") // 定义切点和增强类型（前置增强,可以带任何参数，和任意的返回值）\n    public void beforeGreeting() { // 增强的横切逻辑\n        logger.info(\"How are you Aspect 使用了前置增强\");\n    } \n}\n\n```\n3: 编写目标对象\n\n> Writer.java 接口\n\n```java\npackage com.aop.learn.service;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15\n */\npublic interface Writer {\n\n    public void greetTo();\n\n}\n\n\n```\n> NativeWaiter.java 实现方法\n```java\npackage com.aop.learn.service.impl;\n\nimport com.aop.learn.annotation.NeedTest;\nimport com.aop.learn.service.Writer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15\n */\n@Service\npublic class NativeWaiter implements Writer {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void greetTo() {\n        logger.info(\"执行方法体: \");\n    }\n    \n}\n```\n\n4：Spring配置文件\n> applicationContext.xml\n```xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"\n    http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n\thttp://www.springframework.org/schema/aop\n\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n\">\n    <context:component-scan base-package=\"com.aop.learn\"/>\n\n    <!--基于@AspectJ切面的驱动器,自动为Spring容器中匹配@AspectJ切面的Bean创建代理，完成切面织入-->\n    <aop:aspectj-autoproxy/>\n    <!--<aop:aspectj-autoproxy proxy-target-class=\"true\"/> 表示使用CGLib动态代理技术织入增强-->\n\n\n</beans>\n```\n\n5: 测试类\n\n测试基类\n> BaseTest.java\n```java\npackage com.aop.test;\n\nimport org.junit.runner.RunWith;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15 \n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:/spring/applicationContext.xml\")\npublic class BaseTest extends AbstractJUnit4SpringContextTests {\n\n    public Logger logger = LoggerFactory.getLogger(this.getClass());\n}\n\n```\n\n测试类\n> AspectTest.java\n\n````java\npackage com.aop.test.service;\n\nimport com.aop.learn.service.AgentWriter;\nimport com.aop.learn.service.Seller;\nimport com.aop.learn.service.Writer;\nimport com.aop.test.BaseTest;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * @author songshuiyang\n * @title: 基于spring配置使用@AspectJ切面\n * @description:\n * @date 2017/11/15 \n */\npublic class AspectTest extends BaseTest {\n\n \n    @Autowired\n    private Writer writer;\n    \n    /**\n     * 基于spring配置使用@AspectJ切面\n     */\n    @Test\n    public void test1() {\n        writer.greetTo();\n    }\n}\n\n````\n6: 效果图,完成 aop增强\n![logo](/images/server/springaop/aop.png)\n \n\n#### \n\n#### \n#### \n#### \n\n\n#### 通过xml schema的方式实现Aop\n\n> applicationContext-schema.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n\n\n\thttp://www.springframework.org/schema/aop\n\thttp://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n\n    <!-- aop:config 配置一个基于Schema的切面，aop:config 可以定义多个切面-->\n    <aop:config proxy-target-class=\"true\">\n        <!--aop:pointcut 配置命名切点,可以被其他增强引用-->\n        <aop:pointcut id=\"greetToPointcut\"\n                      expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..))\"/>\n        <aop:pointcut id=\"bindParmPointcut\"\n                      expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..)) and args(clientName)\"/>\n\n        <!-- aop:advisor 是切点和增强的复合体,仅包含一个切点和增强-->\n        <aop:advisor advice-ref=\"advisorMethods\"\n                     pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* serveTo(..))\"/>\n\n        <!--aop:aspect 元素标签定义切面,其内部可以定义多个增强-->\n        <aop:aspect ref=\"adviceMethods\">\n            <!-- aop:before前置增强 method 增强方法， pointcut 切点表达式-->\n            <aop:before method=\"preGreeting\"\n                        pointcut-ref=\"greetToPointcut\"/>\n            <!-- aop:before后置增强-->\n            <aop:after-returning method=\"afterGreeting\"\n                                 pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* name(..))\"\n                                 returning=\"retVal\"/>\n            <!-- 测试绑定连接点信息-->\n            <aop:after method=\"bindParmGreet\"\n                       pointcut-ref=\"bindParmPointcut\"/>\n        </aop:aspect>\n\n\n    </aop:config>\n\n    <!--增强方法所在的Bean-->\n    <bean id=\"adviceMethods\" class=\"com.aop.learn.schema.AdviceMethods\"/>\n    <bean id=\"nativeWaiter\" class=\"com.aop.learn.service.impl.NativeWaiter\"/>\n    <bean id=\"advisorMethods\" class=\"com.aop.learn.schema.AdvisorMethods\"/>\n\n</beans>\n```\n\n>AdviceMethods.java\n```java\npackage com.aop.learn.schema;\n\n/**\n * @author songshuiyang\n * @title: Schema 用作增强的方法\n * @description:\n * @date 2017/11/18 \n */\npublic class AdviceMethods {\n    /**\n     * 前置增强\n     */\n    public void preGreeting() {\n        System.out.println(\"-------------前置增强\");\n    }\n\n    /**\n     * 后置增强\n     *\n     * @param retVal\n     */\n    public void afterGreeting(String retVal) {\n        System.out.println(\"-------------后置增强,返回的参数\" + retVal);\n    }\n\n    /**\n     * 绑定连接点信息\n     *\n     * @param clientName\n     */\n    public void bindParmGreet(String clientName) {\n        System.out.println(\"-------------绑定连接点信息 的参数\" + clientName);\n\n    }\n\n}\n\n```\n\n>NativeWaiter.java\n```java\npackage com.aop.learn.service.impl;\n\nimport com.aop.learn.annotation.NeedTest;\nimport com.aop.learn.service.Writer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15\n */\n@Service\npublic class NativeWaiter implements Writer {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void greetTo(String clientName) {\n        logger.info(\"-------------greetTo \" + clientName);\n    }\n\n    @Override\n    public void greetTo(String clientName, Integer age) {\n        logger.info(\"-------------greetTo \" + clientName + \"  \" + age + \"岁\");\n    }\n\n    @Override\n    public void serveTo(String clientName) {\n        logger.info(\"-------------serveTo \" + clientName);\n    }\n\n    @Override\n    @NeedTest()\n    public void nestTo() {\n        logger.info(\"开始执行 nestTo() 函数\");\n    }\n\n    @Override\n    public String name() {\n        return \"宋水阳\";\n    }\n\n    @Override\n    public void throwExcetion() {\n        throw new IllegalArgumentException(\"抛出异常了\");\n    }\n}\n\n```\n\n>AdvisorMethods.java\n```java\npackage com.aop.learn.schema;\n\nimport org.springframework.aop.MethodBeforeAdvice;\n\nimport java.lang.reflect.Method;\n\n/**\n * @author songshuiyang\n * @title: aop:advisor 是切点和增强的复合体,仅包含一个切点和增强\n * @description:\n * @date 2017/11/18\n */\npublic class AdvisorMethods implements MethodBeforeAdvice {\n\n    @Override\n    public void before(Method method, Object[] args, Object taget) throws Throwable {\n        System.out.println(\"--------------执行aop:advisor增强----------------\");\n        System.out.println(\"获取的参数\" + args[0]);\n    }\n}\n\n```\n\n","tags":["Spring"],"categories":["服务器"]},{"title":"myBatis笔记","url":"/2017/11/14/backend/framework/mybatis/mybatis笔记/","content":"### mybatis foreach标签\n> foreach 标签中 item属性名如果和其他参数中同名(如以下代码:item=\"id\" 和 if test=\"id != null\" 同名),即使没有传入id参数,SQL也会执行 AND id = #{id}\n#### mapper文件:\n```xml\n    <select id=\"findPageList\" parameterType=\"map\" resultType=\"user\">\n        SELECT *\n        FROM user\n        <where>\n            <if test=\"IN_id != null\">\n                id IN\n                <foreach collection=\"IN_id\" index=\"index\" item=\"id\" open=\"(\" separator=\",\" close=\")\">\n                    #{id}\n                </foreach>\n            </if>\n            <if test=\"id != null\">\n              AND id = #{id}\n            </if>\n        </where>\n    </select>\n```\n#### dao层\n```java\n    List<User> findPageList(Map<String, Object> map);\n```\n#### 测试方法\n```xml\n    @Test\n    public void test2() {\n        Map<String, Object> map = new HashMap<String, Object>();\n        List<Integer> idList = new ArrayList<Integer>();\n        idList.add(1);\n        idList.add(4);\n        idList.add(5);\n        map.put(\"IN_id\", idList);\n        userMapper.findPageList(map);\n    }\n```\n#### 结果\n````java\n==>  Preparing: SELECT * FROM user WHERE id IN ( ? , ? , ? ) AND id = ? \n==> Parameters: 1(Integer), 4(Integer), 5(Integer), 5(Integer)\n<==      Total: 1\n````","tags":["Spring"],"categories":["服务器"]},{"title":"Spring Task","url":"/2017/11/07/backend/framework/spring/Spring Task/","content":"## Spring Task\n>spring task作为定时任务的处理,是Spring自带的一个设定时间自动任务调度,提供了两种方式进行配置，一种是注解的方式，而另外一种就是XML配置方式了。\n\n<!--more-->\n### 基于XML配置文件的方式\n>applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:task=\"http://www.springframework.org/schema/task\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/task\n    http://www.springframework.org/schema/task/spring-task.xsd\">\n\n    <!--使用配置文件的方式,注册 xmlTaskJob bean中的job1方法,每隔一秒执行 -->\n    <task:scheduled-tasks>\n         <task:scheduled ref=\"xmlTaskJob\" method=\"job1\" cron=\"*/1 * * * * ?\"/>\n    </task:scheduled-tasks>\n\n    <context:component-scan base-package=\"com.learn.schedule.service\"/>\n</beans>\n\n```\n>XmlTaskJob.Java\n```java\npackage com.learn.schedule.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n\n/**\n * @author songshuiyang\n * @title: 基于xml文件配置的定时任务\n * @description:\n * @date 2017/11/7 22:20\n */\n@Service\npublic class XmlTaskJob {\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    public void job1() {\n        logger.info(\"基于xml文件配置的定时任务，每隔一秒执行\");\n    }\n\n}\n```\n>Test.java\n````java\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/7 22:45\n */\npublic class Test {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/spring/applicationContext.xml\");\n    }\n}\n````\n### 基于注解配置文件的方式更简单\n>applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:task=\"http://www.springframework.org/schema/task\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/task\n    http://www.springframework.org/schema/task/spring-task.xsd\">\n\n    <!-- 启动定时器 基于注解-->\n    <task:annotation-driven/>\n\n    <context:component-scan base-package=\"com.learn.schedule.service\"/>\n</beans>\n```\n>AnnotationTaskJob.Java\n```java\npackage com.learn.schedule.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author songshuiyang\n * @title: 基于注解配置的定时任务\n * @description:\n * @date 2017/11/7 22:42\n */\n@Component\npublic class AnnotationTaskJob {\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Scheduled(cron = \"*/2 * * * * ?\") //每2秒执行一次\n    public void job() {\n        logger.info(\"基于注解配置的定时任务，每隔俩秒执行\");\n    }\n}\n```\n>效果:\n![logo](/images/server/spring-schedule.gif) ","tags":["Spring"],"categories":["服务器"]},{"title":"Spring","url":"/2017/10/24/backend/framework/spring/学习笔记/","content":"### 轻量级(重量级)的框架 \n> 轻量级框架和重量级框架的区别是什么？很多人以为是以框架之间的耦合性强弱作为判断标准。其实不然，实际上是以启动程序需要的资源来决定。比如，EJB启动的时候，需要消耗大量的资源，内存，CPU等，所以是重量级。而Spring则不，所以是轻量级框架。就是看加载的资源 spring也不能说是轻量级的 EJB默认在应用启动的时候把所有资源和服务都加载进来而spring则是你定制服务 需要什么开什么 如果把spring的所有服务都用上的话 可以认为你是用了一个重量级的框架 实质还是看框架所需要的系统资源大小.\n\n### IOC 底层原理使用到的技术\n\n1. xml配置文件\n    `<bean id=\"user\" class=\"java.com.ecut.User\">`\n   \n2. dom4j解析xml配置文件\n\n3. 工厂设计模式\n\n4. 反射","tags":["Spring"],"categories":["服务器"]},{"title":"Git初始配置","url":"/2017/10/22/backend/buildTool/git/git初始配置/","content":"## 使用Git的前的初始配置\n\n### 1. 配置提交时的用户名与邮件名称(注:只是标识本次commit是谁提交的)\n1.1 通过命令的方式\n```sql\n$ git config --global user.name \"songshuiyang\"\n$ git config --global user.email songshiuyang@foxmail.com\n\n注: global 全局配置,在此电脑上的所有项目的git提交都会用这个用户名和邮件\n```\n1.2 通过修改配置文件的方式\n\n```sql\n文件路径: 用户目录/.gitconfig  文件\n把name email改成(新增)自己的配置即可\n[user]\n\tname = songshuiyang\n\temail = songshiuyang@foxmail.com\n```\n### 2. 配置 短命令\n2.1 通过命令的方式\n```sql\n$ git config --global alias.st status\n$ git config --global alias.ci commit\n$ git congig --global alias.co checkout\n$ git congig --global alias.br branch\n```\n2.2 通过修改配置文件的方式\n```sql\n[alias]\n    co = checkout\n    ci = commit\n    st = status\n    cm = commit -m\n    br = branch\n    bm = branch -m\n    bd = branch -D\n    cb = checkout -b\n    df = diff\n    ls = log --stat\n    lp = log -p\n    plo = pull origin\n    plode = pull origin develop\n    pho = push origin\n```\n### 3. 配置文件\n>Git的三个配置文件\n1. 版本库级别的配置文件,文件路径: `项目路径/.git/config`\n2. 全局配置文件, 文件路径: `用户目录/.gitconfig` \n3. 系统级配置文件,文件路径: `安装目录/etc目录下`\n\n优先级: 版本库级别的配置文件 >  全局配置文件  > 系统级配置文件\n\n### 4. 文件 `.git/index `\n\n实际上就是一个包括文件索引的目录树,像是一个虚拟的工作区,记录了文件名和文件的状态信息(时间戳和文件长度),文件的内容保存在`.git/objects目录下`,文件索引建立了文件和对象库中对象实体之间的对应\n\n工作区,版本区,暂存区原理图\n\n![git](/images/server/git/git-image.jpg)\n\n\n\n","tags":["git"],"categories":["server"]},{"title":"编译构建部署版本工具","url":"/2017/10/14/backend/buildTool/git/如何修改Git commit的信息/","content":"转自：\nhttp://www.cnblogs.com/shenh062326/p/git.html","tags":["git"],"categories":["server"]},{"title":"Hibernate Validator","url":"/2017/10/14/backend/framework/Hibernate/Hibernate Validator/","content":"### Hibernate Validator\nHibernate Validator 是 Bean Validation 的参考实现 。Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。\n在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。\n\n#### 1. Bean Validation 中内置的 constraint\n|注解            |          作用|\n| --------       | :----: |\n| @Valid         |   被注释的元素是一个对象，需要检查此对象的所有字段值  |\n|@Valid\t        |    被注释的元素是一个对象，需要检查此对象的所有字段值\n|@Null\t |   被注释的元素必须为 null\n|@NotNull\t |   被注释的元素必须不为 null\n|@AssertTrue\t |   被注释的元素必须为 true\n|@AssertFalse\t |   被注释的元素必须为 false\n|@Min(value)\t |   被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n|@Max(value)\t |   被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n|@DecimalMin(value) |   \t被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n|@DecimalMax(value) |   \t被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n|@Size(max, min)\t |   被注释的元素的大小必须在指定的范围内\n|@Digits (integer, fraction) |   \t被注释的元素必须是一个数字，其值必须在可接受的范围内\n|@Past\t |   被注释的元素必须是一个过去的日期\n|@Future\t |   被注释的元素必须是一个将来的日期\n|@Pattern(value)\t |   被注释的元素必须符合指定的正则表达式\n\n#### 2. Hibernate Validator 附加的 constraint\n| 注解            |           作用|\n|------------     |:-------:|\n|@Email\t被注释的元素必须是电子邮箱地址\n|@Length(min=, max=)\t| 被注释的字符串的大小必须在指定的范围内\n|@NotEmpty\t| 被注释的字符串的必须非空\n|@Range(min=, max=)\t| 被注释的元素必须在合适的范围内\n|@NotBlank\t| 被注释的字符串的必须非空\n|@URL(protocol=,host=,    port=, regexp=, flags=)\t|被注释的字符串必须是一个有效的url\n|@CreditCardNumber | 被注释的字符串必须通过Luhn校验算法， 银行卡，信用卡等号码一般都用Luhn 计算合法性\n|@ScriptAssert (lang=, script=, alias=)\t|要有Java Scripting API 即JSR 223 (\"Scripting for the JavaTM Platform\")的实现\n|@SafeHtml(whitelistType=, additionalTags=)|classpath中要有jsoup包\n#### 举个栗子\n```java\npublic class User {  \n      \n    @NotBlank  \n    private String name;  \n      \n    //年龄要大于18岁  \n    @Min(18)  \n    private int age;  \n  \n    @Email  \n    private String email;  \n      \n    //嵌套验证  \n    @Valid  \n    private Product products;  \n      \n    ... //省略getter，setter  \n}  \n  \npublic class Product {  \n      \n    @NotBlank  \n    private String name;  \n      \n    //价格在10元-50元之间  \n    @Range(min=10,max=50)  \n    private int price;  \n      \n    ... //省略getter，setter  \n} \n```\n转自:http://blog.csdn.net/u011851478/article/details/51842157\n","tags":["Hibernate"],"categories":["server"]},{"title":"编译构建部署版本工具","url":"/2017/10/14/backend/buildTool/grandle/","content":"### Grandle\n![gradle](/images/server/gradle.gif)\n\n#### 易百教程\nhttp://www.yiibai.com/gradle/\n\n#### Gradle学习系列之一——Gradle快速入门\n\nhttp://www.cnblogs.com/CloudTeng/p/3417762.html\n\n#### android grandle\n\nhttp://www.jianshu.com/p/9df3c3b6067a","tags":["java"],"categories":["server"]},{"title":"github","url":"/2017/10/08/technology/github/","content":"### watch、star、fork 的使用\n\n#### watch\n>对于别人的项目，默认自己都处于 Not watching 的状态，当你选择 Watching，表示你以后会关注这个项目的所有动态，这个项目以后只要发生变动，如被别人提交了 pull request、被别人发起了issue等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。\n\n#### star\n\n>当你点击 star，表示你喜欢这个项目或者通俗点，可以把他理解成朋友圈的点赞吧，表示对这个项目的支持\n\n#### fork\n>当选择 fork，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步（注意）。","tags":["web"],"categories":["技术"]},{"title":"计算属性","url":"/2017/10/05/frontend/计算属性/","content":"计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：\n```html\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\n```javascript\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\n\n","tags":["vue"],"categories":["client"]},{"title":"v-model v-bind","url":"/2017/10/05/frontend/v-model和v-bind的区别/","content":"Mustache (双大括号写法)不能在 HTML 属性中使用，应使用 v-bind 指令：\n```aidl\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除：\n```aidl\n<button v-bind:disabled=\"someDynamicCondition\">Button</button>\n```\n1. v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=\"表达式\"\n\n2. v-bind用于绑定属性和数据 ，其缩写为“ : ” 也就是v-bind:id  === :id  \n\n3. v-model用在表单控件上的，用于实现双向数据绑定，所以如果你用在除了表单控件以外的标签是没有任何效果的。\n\n> v-bind\n```aidl\n<!-- 绑定一个属性 -->\n<img v-bind:src=\"imageSrc\">\n<!-- 缩写 -->\n<img :src=\"imageSrc\">\n<!-- 内联字符串拼接 -->\n<img :src=\"'/path/to/images/' + fileName\">\n<!-- class 绑定 -->\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n<!-- style 绑定 -->\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n<!-- 绑定一个有属性的对象 -->\n<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n<!-- 通过 prop 修饰符绑定 DOM 属性 -->\n<div v-bind:text-content.prop=\"text\"></div>\n<!-- prop 绑定。“prop”必须在 my-component 中声明。-->\n<my-component :prop=\"someThing\"></my-component>\n<!-- 通过 $props 将父组件的 props 一起传给子组件 -->\n<child-component v-bind=\"$props\"></child-component>\n<!-- XLink -->\n<svg><a :xlink:special=\"foo\"></a></svg>\n```","tags":["vue"],"categories":["client"]},{"title":"Vue.js","url":"/2017/10/03/frontend/Vue/","content":"### 前缀 $，实例属性与方法\n这些只是Vue的命名规则，为了缺分普通变量属性，避免我们自己声明或者添加自定义属性导致覆\n### 生命周期\nbeforecreated：el 和 data 并未初始化 \n\ncreated:完成了 data 数据的初始化，el没有\n\nbeforeMount：完成了 el 和 data 初始化 \n\nmounted ：完成挂载\n\n<!--more-->\n\n生命周期\n\n![lifecyc](/images/client/lifecycle.jpg)\n\n生命周期钩子\n\n![life](/images/client/vue Lifecycle hooks.png)\n\n钩子函数\n\n钩子函数就是指再所有函数执行前，我先执行了的函数，即 钩住 我感兴趣的函数，只要它执行，我就先执行,这个解释666\n\n### 双向绑定\n\nv-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。\n\n在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。\n\n### 数据\n \n如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：\n\n```json\ndata: {\n  newTodoText: '',\n  visitCount: 0,\n  hideCompletedTodos: false,\n  todos: [],\n  error: null\n}\n```\n### 一个对象的 v-for\n\n```html\n<div v-for=\"(value, key, index) in object\">\n  {{ index }}. {{ key }}: {{ value }}\n</div>\n```\n```angularjs\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      firstName: 'John',\n      lastName: 'Doe',\n      age: 30\n    }\n  }\n})\n```\n索引 key value\n\n````html\n<div v-for=\"(value, key, index) in object\">\n  {{ index }}. {{ key }}: {{ value }}\n</div>\n````\n\n```html\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联 -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n### vue模板只能有一个根对象\n```sql\n<template>\n  <h2>底部</h2>\n  <span v-text=\"msgFromFather\"></span>\n</template>\n```\n报错\n```sql\nComponent template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.\n```\n原来vue模板只能有一个根对象\n所以你想要出现正常的效果，你的用一个div来或是别的标签来包裹全部的元素\n```html\n<template>\n   <div>\n\t <h2>底部</h2>\n\t <span v-text=\"msgFromFather\"></span>\n   </div>\n</template>\n```\n\n\n\n\n\n","tags":["vue"],"categories":["client"]},{"title":"其他插件","url":"/2017/10/01/technology/其他插件/","tags":["web"],"categories":["技术"]},{"title":"嵌入网易云插件","url":"/2017/10/01/essay/网易云/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=355 height=86 src=\"//music.163.com/outchain/player?type=2&id=28411368&auto=1&height=66\"></iframe>\n\n\n\n\n","tags":["web"],"categories":["随笔"]},{"title":"增加畅言功能","url":"/2017/10/01/technology/增加畅言功能/","content":"## 畅言- 专业的社会化评论系统\n>网址:https://changyan.kuaizhan.com/\n\n添加功能:\n1. 根据上面的网址注册\n2. 复制 畅言秘钥(SourceID)\n3. 复制以下代码，并粘贴到您网页源代码的```<body>与</body>```之间想要出现畅言评论框的位置。如果您的网站使用了模板，请将代码粘贴到模板代码中。\n```aidl\n<div id=\"SOHUCS\" sid=\"请将此处替换为配置SourceID的语句\"></div>\n<script charset=\"utf-8\" type=\"text/javascript\" src=\"https://changyan.sohu.com/upload/changyan.js\" ></script>\n<script type=\"text/javascript\">\nwindow.changyan.api.config({\nappid: 'cytf5fPKF',\nconf: 'prod_ee3a22e2c13174e193691fbc93e3cbc8'\n});\n</script>\n```\n效果:\n![view](/images/畅言.png)\n\n网站需要备案,不然只有15天的试用期:\n\nICP备案： 只要网站在国内不管网站大小都需要在工信部网站在线申请备案号，但提供的审核资料可能就是不真实的，因为工信部不会去实际的核实。\n工信部要求的仅仅是有备案号即视为合法网站","tags":["web"],"categories":["技术"]},{"title":"nodeJs","url":"/2017/10/01/frontend/nodeJs/","content":"# Node.js\nNode.js 让 JavaScript 编写服务器端应用程序成为可能。它建立在 JavaScript V8（C++ 编写的） 运行时之上，所以它很快。最初，它旨在为应用程序提供服务器环境，但是开发人员开始利用它来创建工具，帮助他们本地的任务自动化。此后，一个全新基于 Node 工具（如 Grunt 和 Gulp）的生态系统，使得前端开发改头换面。\n\n要使用 Node.js 中的这些工具（或包），我们需要一种有效的方式来安装和管理它们。这就要用到node 包管理器： npm 了。它能够安装你想要的包，而且提供一个强大接口来使用它们。在使用 npm 之前，首先得在系统上安装 Node.js。\n\n## NPM（node package manager）node包管理器\n\n>将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。\n\n### package.json包描述信息\n\n如果我们的项目依赖了很多package，一个一个地安装那将是个体力活。我们可以将项目依赖的包都在package.json这个文件里声明，然后一行命令搞定\n\n```\nnpm install\n```\n\n### 安装方式\n\n本地安装：package会被下载到当前所在目录，也只能在当前目录下使用。\n\n全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。'\n\n### devDependencies和dependencies的区别\n使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如：\n\n--save-dev\n\n--save\n\n但是当安装新包的时候如何让它保持最新呢？我们可以使用 –save 标识。\n\n在 package.json 文件里面提现出来的区别就是，使用 --save-dev 安装的 插件，被写入到 devDependencies 对象里面去，而使用 --save 安装的插件，责被写入到 dependencies 对象里面去。\n\n那 package.json 文件里面的 devDependencies  和 dependencies 对象有什么区别呢？\n\ndevDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的。","tags":["npm"],"categories":["client"]},{"title":"Java基础-枚举类","url":"/2017/09/29/backend/java/basicKnowledge/Java基础-枚举类/","content":"\n>枚举是用来构建常量数据结构的模板，这个模板可扩展。枚举的使用增强了程序的健壮性\n\n## 1. 常量\n```aidl\npublic enum Color {\n     \n     RED, GREEN, BLANK, YELLOW \n \n}\n```\n\n## 2. switch \n```\npublic class B {\n \n    public static void main(String[] args) {\n \n        showColor( Color.RED );\n \n    }\n \n    static void showColor(Color color){\n        switch ( color ) {\n        case BLANK:\n            System.out.println( color );\n            break;\n        case RED :\n            System.out.println( color );\n            break;\n        default:\n            System.out.println( color );\n            break;\n        }\n         \n    }\n}\n```\n\n## 3. 自定义函数\n```aidl\npublic enum Color {\n     \n     RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);\n     \n     \n    private String name ;\n    private int index ;\n     \n    private Color( String name , int index ){\n        this.name = name ;\n        this.index = index ;\n    }\n     \n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getIndex() {\n        return index;\n    }\n    public void setIndex(int index) {\n        this.index = index;\n    }\n     \n``` \n\n","tags":["Java"],"categories":["server"]},{"title":"Spring Assert","url":"/2017/09/29/backend/framework/spring/Assert 的学习/","content":"## Assert（当要判断一个方法传入的参数时，我们就可以使用断言。）\n>package org.springframework.util\n\n### 1. notNull(Object object) \n\n当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null；\n\n### 2. isTrue(boolean expression) / isTrue(boolean expression, String message) \n\n当 expression 不为 true 抛出异常；\n\n### 3. notEmpty(Collection collection) / notEmpty(Collection collection, String message) \n\n当集合未包含元素时抛出异常。\n\nnotEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断；\n\n### 4. hasLength(String text) / hasLength(String text, String message)  \n\n当 text 为 null 或长度为 0 时抛出异常；\n\n### 5. hasText(String text) / hasText(String text, String message)  \n\ntext 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常；\n\n### 6. isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message)  \n\n如果 obj 不能被正确造型为 clazz 指定的类将抛出异常；\n\n### 7. isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message)  \n\nsubType 必须可以按类型匹配于 superType，否则将抛出异常；","tags":["Spring"],"categories":["服务器"]},{"title":"Hibernate 问题记录","url":"/2017/09/24/backend/framework/Hibernate/hibernate问题集合/","content":"### org.hibernate.MappingException: Unknown entity常见问题\n\n1. 可能原因一\n\n 检查实体类是否导入的是 javax.persistence 下的包\n \n2. 可能原因二\n\n 没有在cfg文件中加入 *.hbm.xml造成的\n \n3. hibernate版本问题,一代版本一代神\n\n  4.5 版本\n  ```\n  ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).build();\n  ```\n  5.2 版本\n  ```\n  ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build();\n  ```\n  \n  ","tags":["Hibernate"],"categories":["server"]},{"title":"Hibernate笔记","url":"/2017/09/23/backend/framework/Hibernate/Hibernate笔记/","content":"## hibernate.properties \n\n> 使用 hibernate.properties 文件配置Hibernate 需要在代码里面手动添加持久化类,所以在实际开发中不使用hibernate.property 文件作为配置文件的原因\n","tags":["Hibernate"],"categories":["server"]},{"title":"Hibernate 例子","url":"/2017/09/23/backend/framework/Hibernate/Hibernate/","content":"## 概述:\n>面向Java环境的对象/关系数据库映射工具,用于将面向对象模型表示的对象映射到基于SQL的关系模型的数据结构中,消除那些针对特定数据库厂商的SQL代码,并把结果集从表格式的形式转换成值对象的形式\n\n<!--more-->\n## Hibernate的数据库操作\n### 直接采用了POJO(普通的传统的Java对象)作为持久化类\n```$xslt\npackage com.hibernate.entity;\n\nimport javax.persistence.*;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/9/23 23:41\n */\n@Entity /*标明持久化类*/\n@Table(name = \"user\")\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键生成策略\n    private String id;\n\n    private String name;\n\n    private int sex;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getSex() {\n        return sex;\n    }\n\n    public void setSex(int sex) {\n        this.sex = sex;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", sex=\" + sex +\n                '}';\n    }\n}\n\n```\nHibernate基本上是使用了JPA的标准注解(javax.persistence)\n>JPA\n 1. JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。\nSun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。\n\n2. JPA是一种规范，而Hibernate是它的一种实现。除了Hibernate，还有EclipseLink(曾经的toplink)，OpenJPA等可供选择，所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。\n\n###  配置文件 (#.properties , XML配置文件的形式)\n```aidl\n<?xml version=\"1.0\" encoding=\"GBK\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n        \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n<hibernate-configuration>\n  <session-factory>\n    <!-- 指定连接数据库所用的驱动 -->\n    <property name=\"connection.driver_class\">com.mysql.jdbc.Driver</property>\n    <!-- 指定连接数据库的url，其中hibernate是本应用连接的数据库名 -->\n    <property name=\"connection.url\">jdbc:mysql://localhost/ecut</property>\n    <!-- 指定连接数据库的用户名 -->\n    <property name=\"connection.username\">root</property>\n    <!-- 指定连接数据库的密码 -->\n    <property name=\"connection.password\">root</property>\n    <!-- 指定连接池里最大连接数 -->\n    <property name=\"hibernate.c3p0.max_size\">20</property>\n    <!-- 指定连接池里最小连接数 -->\n    <property name=\"hibernate.c3p0.min_size\">1</property>\n    <!-- 指定连接池里连接的超时时长 -->\n    <property name=\"hibernate.c3p0.timeout\">5000</property>\n    <!-- 指定连接池里最大缓存多少个Statement对象 -->\n    <property name=\"hibernate.c3p0.max_statements\">100</property>\n    <property name=\"hibernate.c3p0.idle_test_period\">3000</property>\n    <property name=\"hibernate.c3p0.acquire_increment\">2</property>\n    <property name=\"hibernate.c3p0.validate\">true</property>\n    <!-- 指定数据库方言 -->\n    <property name=\"dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</property>\n    <!-- 根据需要自动创建数据表 -->\n    <property name=\"hbm2ddl.auto\">update</property><!--①-->\n    <!-- 显示Hibernate持久化操作所生成的SQL -->\n    <property name=\"show_sql\">true</property>\n    <!-- 将SQL脚本进行格式化后再输出 -->\n    <property name=\"hibernate.format_sql\">true</property>\n\n    <mapping class=\"com.hibernate.entity.User\"/>\n\n  </session-factory>\n</hibernate-configuration>\n```\n\n###  测试方法\n```aidl\npublic class UserManagerTest {\n    @Test\n    public void test1(){\n        // 实例化Configuration，\n        Configuration conf = new Configuration().configure();\n        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build();\n        // 以Configuration实例创建SessionFactory实例\n        SessionFactory sf = conf.buildSessionFactory(serviceRegistry);\n        // 创建Session\n        Session sess = sf.openSession();\n        // 开始事务\n        Transaction tx = sess.beginTransaction();\n        // 创建消息对象\n        User user = new User();\n        // 设置消息标题和消息内容\n       user.setName(\"hibernate\");\n       user.setSex(12);\n       sess.save(user);\n        // 提交事务\n        tx.commit();\n        // 关闭Session\n        sess.close();\n        sf.close();\n\n    }\n}\n```\n\n","tags":["Hibernate"],"categories":["server"]},{"title":"Java基础-Java位运算","url":"/2017/09/22/backend/java/basicKnowledge/Java基础-位运算/","content":"### 与运算符 &\nint a=129;\n\nint b=128;\n\na & b = 128\n\n解析:\n\n“a”的值是129，转换成二进制就是10000001，而“b”的值是128，转换成二进制就是10000000。根据与运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128。\n\n### 或运算 |\nint a=129;\n\nint b=128;\n\na & b = 129\n\n解析:\n\na 的值是129，转换成二进制就是10000001，而b 的值是128，转换成二进制就是10000000，根据或运算符的运算规律，只有两个位有一个是1，结果才是1，可以知道结果就是10000001，即129。\n\n### 非运算符 ~\n\n如果位为0，结果是1，如果位为1，结果是0\n\n\n### 异或运算符 ^\n\n异或运算符是用符号“^”表示的，其运算规律是：\n\n两个操作数的位中，相同则结果为0，不同则结果为1。下面看一个简单的例子。\n\nint a=15;\n\nint b=2;\n\n\na^b a 与 b 异或的结果是：13\n\n分析上面的程序段：a 的值是15，转换成二进制为1111，而b 的值是2，转换成二进制为0010，根据异或的运算规律，可以得出其结果为1101 即13。\n\n","tags":["Java"],"categories":["server"]},{"title":"Java集合-遍历Map","url":"/2017/09/22/backend/java/collection/Java集合-遍历Map/","content":"## Java中如何遍历Map对象的4种方法\n\n>既然java中的所有map都实现了Map接口，以下方法适用于任何map实现（HashMap, TreeMap, LinkedHashMap, Hashtable, 等等）\n\n### 方法一: 在for-each循环中使用entries来遍历\n\n>这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用\n\n````java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \nfor (Map.Entry<Integer, Integer> entry : map.entrySet()) {  \n  \n    System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());  \n  \n} \n````\n注意：for-each循环在java 5中被引入所以该方法只能应用于java 5或更高的版本中。如果你遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此在遍历前你总是应该检查空引用。\n\n### 方法二: 在for-each循环中遍历keys或values。\n>如果只需要map中的键或者值，你可以通过keySet或values来实现遍历，而不是用entrySet。\n```java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \n//遍历map中的键  \n  \nfor (Integer key : map.keySet()) {  \n  \n    System.out.println(\"Key = \" + key);  \n  \n}  \n  \n//遍历map中的值  \n  \nfor (Integer value : map.values()) {  \n  \n    System.out.println(\"Value = \" + value);  \n  \n}  \n```\n该方法比entrySet遍历在性能上稍好（快了10%），而且代码更加干净。\n\n### 方法三: 使用Iterator遍历\n>使用泛型：\n```java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \nIterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n  \n    Map.Entry<Integer, Integer> entry = entries.next();  \n  \n    System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());  \n  \n}  \n```\n>不使用泛型:\n```java\nMap map = new HashMap();  \n  \nIterator entries = map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n  \n    Map.Entry entry = (Map.Entry) entries.next();  \n  \n    Integer key = (Integer)entry.getKey();  \n  \n    Integer value = (Integer)entry.getValue();  \n  \n    System.out.println(\"Key = \" + key + \", Value = \" + value);  \n  \n}  \n```\n你也可以在keySet和values上应用同样的方法。\n\n该种方式看起来冗余却有其优点所在。首先，在老版本java中这是惟一遍历map的方式。另一个好处是，你可以在遍历时调用iterator.remove()来删除entries，另两个方法则不能。根据javadoc的说明，如果在for-each遍历中尝试使用此方法，结果是不可预测的。\n\n从性能方面看，该方法类同于for-each遍历（即方法二）的性能。\n\n### 方法四: 通过键找值遍历（效率低）\n>作为方法一的替代，这个代码看上去更加干净；但实际上它相当慢且无效率。因为从键取值是耗时的操作（与方法一相比，在不同的Map实现中该方法慢了20%~200%）。如果你安装了FindBugs，它会做出检查并警告你关于哪些是低效率的遍历。所以尽量避免使用。\n```java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \nfor (Integer key : map.keySet()) {  \n  \n    Integer value = map.get(key);  \n  \n    System.out.println(\"Key = \" + key + \", Value = \" + value);  \n  \n}  \n```\n\n## 总结\n如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)。\n\n转自：http://blog.csdn.net/tjcyjd/article/details/11111401","tags":["Java"],"categories":["server"]},{"title":"Java基础-概念","url":"/2017/09/21/backend/java/basicKnowledge/Java基础-概念/","content":">全局变量和static修饰的局部变量\n\n默认初始化为 0 。因为全局变量和static静态局部变量存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 0x00。\n\n>Java中的switch-case语句\n\nswitch接受的参数类型有10种，分别是基本类型的byte,short,int,char，以及引用类型的String(只有JavaSE 7 和以后的版本 可以接受String类型参数),enum和byte,short,int,char的封装类Byte,Short,Integer,Character\ncase 后紧跟常量表达式，不能是变量。\n\n>Maps.newHashMap();\n\n Map<String, Object> result = new HashMap<String,Object>();\n \n \n 上面这种是java原生API写法\n 下面这种是google的guava.jar提供的写法，目的是为了简化代码。唯一的区别就是简化代码\n \n \n Map<String, Object> result = Maps.newHashMap();\n>泛型\n\n仅仅是java的一颗语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。\n\n>重载的概念\n\n\n 方法名称相同，参数个数、次序、类型不同\n \n 因此重载对返回值没有要求，可以相同，也可以不同\n \n 但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载","tags":["Java"],"categories":["server"]},{"title":"常见的编码方式","url":"/2017/09/21/backend/other/常见的编码方式/","content":"### 计算机为什么要编码\n在计算机中所有的数据都是以0,1来存储的,那字符是怎样在计算机存储的呢,美国的科学家把一个特定的数字对应一个特定的字母进行存储和传输，比如我需要存储字母a，那么我存入一个数字97(即在计算机中存入二进制(01100001)，这个过程叫做编码(encode)，而我们在读取数据的时候，当遇到97时，我们就让计算机显示字母a，这个过程叫做解码(decode)。\n### 编码发展历史简介\n\n<!--more-->\n\n#### 第一阶段ASCII\n规则:\n\n\n1. 所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。\n\n\n2. 把所有的标点符号，英文大小写全部放在32-126范围中。\n\n\n3. 防止以后出现需要补充的情况，把128-255位这么多位置留出来，应该足够用了吧！所以设置一个字节8位二进制，把这个标准叫American Standard Code for Information Interchange(美国标准信息交换代码，简写为ASCII)，标准制定结束。\n\n实现方式:\n\n第一位始终未0，后面7位表示0-127的范围，一个数字对应一个字母或者标点符号，亦或者控制符号，即所有的ASCII码的统一形式为0xxxx xxxx。\n\n#### 第二阶段 GB2312,GBK, BIG5 Latin1, ISO-8859-1, JIS, ANSI...\n\n>计算机技术到了欧洲，欧洲人发现怎么我们的那么多符号没有编进去啊！\n所以欧洲\"砖家\"坐到了一起，开始讨论。\n发现既然美国人把第一位流出来了，那么我们就用128-255的位置好了。\n\n规则:\n\n1. 128-159之间为控制字符，160-255位文字符号，其中包括了西欧语言、希腊语、泰语、阿拉伯语、希伯来语。\n\n\n2. 刚好把美国人给的空间全部用完，世界真美好，谢谢美利坚预留的每一个位置。\n\n\n3. 砖家们决定把他们的编码名称叫做Latin1，后面由于欧洲统一制定ISO标准，所以又有了一个ISO的名称，即ISO-8859-1。\n\n实现方式:\n\n\n\n1. 0-127的所有位置不动，那么可以兼容ASCII，二进制位0xxx xxxx\n\n\n2. 128-255位置全部用完，二进制位1xxx xxxx\n由于所有的位置全部用完，而欧元符号实在指定标准之后才出现的，所以在这个码表中连欧洲人自己的货币符号都没有办法放进去。\n\n>计算机技术当然也传到了亚洲大地，比如中国。\n中国砖家们坐在一起发现，美国人搞的这个东西真的有问题，预留才128-255的空间，可是我们的汉字个数远远超出了这个数目啊，怎么办？？\n后面聪明的中国砖家们发现，只能使用2个字节了，否则真的搞不定。\n由于必须和美国原来制定的ASCII不冲突，所以指定了如下规则\n\n规则:\n\n1. 如果一个字节中第一位为0，那么这就是一个ASCII字符。\n\n\n2. 如果一个字节中第一位为1，那么这个是汉字，认定需要2个字节才表示一个编码的文字。\n把这个码表叫GB2312\n这个码表中包含汉字6763个和非汉字图形字符682个。\n还有很多的空间没有用到，索性全部预留了吧。\n\n实现方式:\n\n\n1. 0xxxxxxx：表示为ASCII字符\n\n\n2. -1xxxxxxx 1xxxxxxx：表示为汉字\n\n后面再次添加更多的字符进去，再次命名为GB18030，兼容GBK。由于汉字很多，2个字节并不能完全包括进去，所以GB18030采用2\\4位混编的形式。\n\n当然计算机也传到了日本(JIS)、韩国、台湾(BIG5)等等地方，大家全部发挥自己的聪明才智，各自实现了自己的编码。这些编码都与ASCII兼容，但是相互之间不兼容。\n\n使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为\"MBCS（Muilti-Bytes Charecter Set，多字节字符集）\"。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 windows下要转码成gb2312,gbk只需要把文本保存为ANSI编码即可。 不同ANSI编码之间互不兼容\n\n#### 第三阶段\n>随着通讯越来越多，而老美发现在自己公司需要国际化的时候，自己原来埋的这个雷真的害了自己。\n于是乎，开始研讨把世界上几乎所有文字全部放在一个码表中，而这个包罗万象的码表就叫做Unicode，即万国码。\nUnicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。\n实际上，在软件制造商的协会（unicode.org）在做这个工作时，国际标准化组织（ISO）在做同样的事情，最后大家都意识到世界上并不需要两个不同的万国码，于是大家坐在一起合并研究的成果，最后的结果就是现在的Unicode。\n\n### 各个编码及其范围\n#### ASCII\n\n编码范围00-7F，其中00-1F、FF为控制字符。其它为英文字母、数字、标点符号。\n\n#### Latin1\n\n编码范围00-FF，其中00-7F同ASCII，80-9F为控制符、9F-FF为字母和标点符号.\n\n#### CP1252\n\n微软的企业标准，补充了一些符号和欧元符号，为Latin1的超集。\n\n#### GB2312\n\n编码范围为A1A1-F7FE(剔除xx7F)，共23940个码位。其中很多区间没有用到，而汉字使用的区间为B0A1-F7FE，其他为标点符号和特殊字符。\n除常用简体汉字字符外还包括希腊字母、日文平假名及片假名字母、俄语西里尔字母等字符，未收录繁体中文汉字和一些生僻字。\n对汉字进行了分区管理，其中第一个字节为区位码，包括下面区位。\n01-09区为特殊符号。\n16-55区为一级汉字，按拼音排序。\n56-87区为二级汉字，按部首/笔画排序。\n10-15区及88-94区则未有编码。\n第二个字节为位字节，01-94总计94个。\n为什么实际选择不是01-5E，而是选择A1-F7的位置呢？\n因为英文可见字符区间为20-7F，加上128(也就是最高位为1)后得到的取件即是A1-FE\n区位码使用了0xA1-0xF7(把01-87区的区号加上0xA0)，位字节使用了0xA1-0xFE(把01-94加上 0xA0)\n\n#### GBK\n\n编码范围为8140-FEFE,兼容GB2312，仍然有部分区间没有用到。\nGBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的 汉字部首符号、竖排标点符号等字符。\nGBK对GB2312就是，你有的，我也有，你没得的，我还有！\n\n#### CP936\n\nCP936是微软指定的标准，属于企业标准，和GBK的有些许差别，绝大多数情况下可以把CP936当作GBK的别名。\n\n#### BIG5\n\nBig5是双字节编码，高字节编码范围是0x81-0xFE，低字节编码范围是0x40-0x7E和0xA1-0xFE。和GBK相比，少了低字节是0x80-0xA0的组合。0x8140-0xA0FE是保留区域，用于用户造字区。\nBig5收录的汉字只包括繁体汉字，不包括简体汉字，一些生僻的汉字也没有收录。\n\n#### CP950\n\n微软的企业标准，可以理解为是对 Big5的扩展。\n\n#### GB18030\n\n编码范围同GBK，补充了更多的字符，由于Unicode开始流行且GB18030补充的字符都比较生僻，所以实际使用上基本是GBK。\nGB18030编码是变长编码，有单字节、双字节和四字节三种方式。GB18030的单字节编码范围是0x00-0x7F，完全等同与ASCII；双字节编码的范围和GBK相同，高字节是0x81-0xFE，低字节的编 码范围是0x40-0x7E和0x80-FE；四字节编码中第一、三字节的编码范围是0x81-0xFE，二、四字节是0x30-0x39。\n\n#### Unicode\n\n中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。\n一个蛋疼的问题就是这个区间全部都是文字，中文标点没有包含在其中，中文标点散落在各个位置。详细请看http://blog.chinaunix.net/uid-12348673-id-3335307.html。\n一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，详细情况可以参考网址：http://www.cnblogs.com/sosoft/p/3456631.html\n\n#### Unicode的实现方式\n>Unicode只是进行了编码，也就是说只是一个码表，至于具体怎么实现，并没有规定。\n下面是Unicode的几种实现方法。\n##### Unicode UTF-8之间的关系\n简单来说：\nUnicode 是「字符集」\n\nUTF-8 是「编码规则」\n\n其中：\n\n字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）\n\n编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）\n\nUnicode定义了所有可以用来表示字符的数值集合（称之为Code Point）。UTF-8和UTF-16等UTF标准定义了这些数值和字符的映射关系。\n\n正如名字所示，在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分，例如，在UTF－8和ASCII中，“A”的编码都是0x41. \nUTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。\n\n##### UTF-8 (UCS Transfer Format:Unicode转做某种格式) \n\nUTF-8以字节为单位对Unicode进行编码。\n\n从Unicode到UTF-8的编码方式如下：  \n\nUnicode编码(16进制)  ║ UTF-8 字节流(二进制)  \n\n000000 - 00007F   ║ 0xxxxxxx  \n\n000080 - 0007FF   ║ 110xxxxx 10xxxxxx  \n\n000800 - 00FFFF   ║ 1110xxxx 10xxxxxx 10xxxxxx  \n\n010000 - 10FFFF   ║ 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n特点:UTF-8的特点是对不同范围的字符使用不同长度的编码\n\n##### UTF-16\n\n在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。而在辅助平面定义的字符，会以代理对（surrogate pair）的形式，以两个2字节的值来储存。\nUTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16却无法兼容于ASCII编码。\n可以认为UTF-16是下面介绍的UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的是同一的意思。但当引入辅助平面字符后，就称为UTF-16了。现在若有软件声称自己支援UCS-2编码，那其实是暗指它不能支援在UTF-16中超过2bytes的字集。对于小于0x10000的UCS码，UTF-16编码就等于UCS码。\n如果一个UTF-16文件没有指定BOM，默认应该是UTF-16BE，但是在Intel x86中却是UTF-16LE。所以在现实世界中有很多的没有指定大小尾的UTF-16却是UTF-16LE。\n\n##### UTF-32\n\n每一个Unicode码位使用恰好32位元。可以粗暴的认为UTF-32和下面要介绍的UCS-4是等同的。\n\n##### UCS-2\n\n采用2个字节，定长的表示每一个字符，所以总计可以表示2^16个字符。\n\n##### UCS-4\n\nUCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行(rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。\ngroup 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。\n将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。\n\n\n转自:http://www.cnblogs.com/jessonluo/p/4800331.html\n\n\n### 编码检测\n到底采用什么编码，如果能检测就好了。专家们也是这么想的，所以专家给每种格式和字节序规定了一些特殊的编码，\n\n这些编码在unicode 中是没有使用的，所以不用担心会冲突。\n\n这个叫做BOM（Byte Order Mark）头。意思是字节序标志头。通过它基本能确定编码格式和字节序。\n\nUTF编码　║　Byte Order Mark \n　　\nUTF-8　  ║　EF BB BF 　　\n\nUTF-16LE ║　FF FE 　　\n\nUTF-16BE ║　FE FF 　　\n\nUTF-32LE ║　FF FE 00 00 　　\n\nUTF-32BE ║　00 00 FE FF\n所以通过检测文件前面的BOM头，基本能确定编码格式和字节序。\n但是这个BOM头只是建议添加，不是强制的，所以不少软件和系统没有添加这个BOM头（所以有些软件格式中有带BOM头\n\n和NoBOM头的选择），这个时候要检测什么格式，就比较麻烦了\n当然可以检测，但是不能保证100%准确，只能通过编码范围从概率上来检查，虽然准确度还是比较高，但是不能保证\n\n100%。所以，时常看到检测错误的软件，也不奇怪了。\n\n### UTF-8 与UTF-16的区别\n\n   UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.\n\n   于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定.\n\n   于是UTF-8和UTF-16的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用UTF-8就比UTF-16节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16就占优势了,可以节省很多空间.另外还有个容错问题,等会再讲","tags":["Java"],"categories":["server"]},{"title":"Struts2 问题总结","url":"/2017/09/19/backend/framework/Struts2/Struts2 问题总结/","content":"## 上传图片出现错误\n但是，明明上传的文件格式是正确，还是出现：\n\n    Content-Type not allowed: file \"09poC_wallpapers.jpg\" \"upload_1ea6fe4e_13611ac7d7c__8000_00000012.tmp\" image/pjpeg \n\n\nfirefox 和 ie 的文件类型区别\n    Firefox：\n    \t\n    \n    image/jpeg, image/bmp, image/gif, image/png\n    \n    ie 6：\n    \t\n    \n     image/pjpeg ,image/bmp, image/gif, image/x-png\n    \n    ie 7：\n    \t\n    \n    image/pjpeg, image/bmp, image/gif, image/x-png\n    \n    ie 8：\n    \t\n    \n    image/pjpeg, image/bmp, image/gif, image/x-png\n    \n    Ie 9： \n    \t\n    \n    image/jpeg, image/bmp, image/gif, image/png \n解决方法\n\n    <param name=\"allowedTypes\">\n      image/bmp,image/png,image/gif,image/jpeg,image/jpg,\n      image/pjpeg ,image/bmp, image/gif, image/x-png,\n    </param>","tags":["struts2"],"categories":["服务器"]},{"title":"Struts2 的简单实例","url":"/2017/09/16/backend/framework/Struts2/Struts2 的简单实例/","content":"## Struts2 实现流程\n1. 浏览器发送请求\n2. 到达 StrutsPrepareAndExecuteFilter ( 核心控制器 )\n3. 分发到指定 XXXAction ( 业务控制器 ) 调用业务方法\n4. 返回逻辑视图名\n5. StrutsPrepareAndExecuteFilter forward到物理视图,生成响应内容，输出响应","tags":["struts2"],"categories":["服务器"]},{"title":"Servlet-web.xml中配置JSP属性","url":"/2017/09/15/backend/java/servlet/Servlet-web.xml中配置JSP属性/","content":"## web.xml中配置JSP属性\n>为什么要在web.xml配置JSP属性\n\n如果许多JSP有着相似的属性，那么在每个JSP文件的顶部重复添加page指令是非常麻烦的工作。幸运的是，在部署描述符中可以配置通用的JSP属性。\n\n> web.xml中添加JSP属性样例\n\n    <jsp-config>  \n     \t<jsp-property-group>  \n     \t\t<url-pattern>*.jsp</url-pattern>  \n     \t\t<url-pattern>*.jspf</url-pattern>  \n     \t\t<page-encoding>UTF-8</page-encoding>  \n     \t\t<scripting-invalid>false</scripting-invalid>  \n     \t\t<include-prelude>/WEB-INF/jsp/base.jspf</include-prelude>  \n     \t\t<trim-directive-whitespaces>true</trim-directive-whitespaces>  \n     \t\t<default-content-type>text/html</default-content-type>  \n     \t\t</jsp-property-group>  \n    </jsp-config> \n\n<jsp-config>中可以包含任意数目的<jsp-property-group>标签。通过为<jsp-property-group>定义不同的<url-pattern>标签来区分不同的属性组。\n<include-prelude>标签，将告诉容器在所有属于改该属性组的JSP的头部添加文件/WEB-INF/jsp/base.jspf。\n<include-coda>标签定义了包含在组中所有JSP尾部的文件。\n\n在一个JSP组中可以同时使用这些标签多次。\n<page-encoding>与page指令的pageEncoding特性一致。\n<default-content-type>标签可以定义内容类型，默认为text/html\n<trim-directive-whitespaces>也是一个特别有用的属性，该属性告诉JSP转换器删除响应输出中的空白，只保留指令、声明、脚本和其他JSP标签创建的文本。\n<scripting-invalid>标签可以实现完全禁止JSP中的Java\n<el-ignored>的作用类似，不过它对应的是page指令中的isELIgnored特性。\n除了<url-pattern>，<jsp-property-group>中所有标签都是可选的，但在使用它们时必须按照下面的顺序添加到<jsp-property-group>中(忽略掉部希望使用的标签)：<url-pattern>、<el-ignored>、<page-encoding>、<scripting-invalid>、<is-xml>、<include-prelude>、<include-coda>、<deferred-syntax-allowed-as-literal>、<trim-directive-whitespace>、<default-content-type>、<buffer>、<error-on-undeclared-namespace>。","tags":["jsp"],"categories":["服务器"]},{"title":"Servlet","url":"/2017/09/14/backend/java/servlet/Servlet-概述/","content":"## Servlet\n服务器端小程序,运行在服务器端的程序，用于处理及响应客户端的请求,自MVC规范出现之后,Servlet仅仅只作为控制器\n\n## Servlet和Jsp的区别\n1. Servlet中没有内置对象,原来JSP中的内置对象都必须有程序显式创建\n2. Servlet对于HTML标签只能使用页面输出流逐行输出，所以自MVC规范出现之后,Servlet仅仅只作为控制器\n\n<!-- more -->\n\n## @WebServlet \n\n从3.0开始配置Servlet可以使用注解的形式\n>有些人可能会遇到这种种情况，在采用注解WebServlet配置Servlet的时候，明明在配置了urlPatterns属性，部署应用程序的时候也没有出错。但是就是在浏览器发请求的时候访问不到资源，报404错误request resource is not available。捣腾了半天也不知道，到底是哪而出错了？\n Servlet3.0之后新增了注解，用于简化Servlet、Filter及Listener的声明，这样就在配置Servlet的时候多了一个选择。Servlet3.0的部署描述文件web.xml的顶层标签<web-app>有一个metadata-complete属性，该属性为true，则容器在部署时只依赖部署描述文件，忽略所有标注，如果不配置该属性，或者将其设置为false，则表示启动标注支持。当metadata-complete=\"false\"时，web.xml和注解对于Servlet的影响同时起作用，两种方法定义的url-partten都可以访问到该Servlet，但是当通过web.xml定义的url-partten访问时，注解定义的属性（初始化参数等）将失效。\n\n### 属性值\nname\tString\t指定Servlet 的 name 属性，等价于 <servlet-name>。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。\n\nvalue\tString[]\t该属性等价于 urlPatterns 属性。两个属性不能同时使用。\n\nurlPatterns\tString[]\t指定一组 Servlet 的 URL 匹配模式。等价于<url-pattern>标签。\n\nloadOnStartup\tint\t指定 Servlet 的加载顺序，等价于 <load-on-startup>标签。\n\ninitParams\tWebInitParam[]\t指定一组 Servlet 初始化参数，等价于<init-param>标签。\n\nasyncSupported\tboolean\t声明 Servlet 是否支持异步操作模式，等价于<async-supported> 标签。\n\ndescription\tString\t该 Servlet 的描述信息，等价于 <description>标签。\n\ndisplayName\tString\t该 Servlet 的显示名，通常配合工具使用，等价于 <display-name>标签。\n## 创建Servlet有俩个时机\n1. 用户请求某个Servlet，系统创建该Servlet的实例,所以Servlet第一次访问的时间是较长的，因为要初始化Servlet\n2. Web应用启动立即创建Servlet实例,即load-on-startup Servlet\n\n## Servlet 生命周期\n1. 创建实例\n2. Web容器调用Servlet的init方法，对Servlet进行初始化。\n3. 初始化后将一直存在于容器中，用于响应客户端请求,get post service用于响应用户请求\n4. 通常在Web应用关闭之时销毁Servlet，先调用Servlet的destory()方法\n\n## 使用Servlet作为表现层如有以下几个劣势\n1. 所有的Html标签都需要页面输出流完成\n2. 前端人员无法参与到页面的编写\n3. 可维护性差，页面代码不好调试\n","tags":["server"],"categories":["服务器"]},{"title":"Servlet-JSP脚本中的九个内置对象","url":"/2017/09/14/backend/java/servlet/Servlet-JSP脚本中的九个内置对象/","content":"JSP脚本中包含九个内置对象，这九个内置对象都是Servlet API接口的实例，只是JSP规范对它们进行了默认初始化（由JSP页面对应的Servlet的_jspService()方法来创建这些实例),也就是说它们已经是对象，可以直接使用\n\n    1\tpageContext\tjavax.servlet.jsp.PageContext\n    \n    2\trequest\tjavax.servlet.http.HttpServletRequest\n    \n    3\tresponse\tjavax.servlet.http.HttpServletResponse\n    \n    4\tsession\tjavax.servlet.http.HttpSession\n    \n    5\tapplication\tjavax.servlet.ServletContext\n    \n    6\tconfig\tjavax.servlet.ServletConfig\n    \n    7\tout\tjavax.servlet.jsp.JspWriter\n    \n    8\tpage\tjava.lang.Object\n    \n    9\texception\tjava.lang.Throwable\n\n<!--more-->\n### page对象\npage对象表示当前一个JSP页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。page对象在开发中几乎不用，了解一下即可\n### out对象\nout对象代表一个页面输出流，通常用于在页面上输出变量值及常量。一般在使用输出表达式的地方都可以使用out对象达到同样的效果。out是个页面输出流，负责输出页面的内容，但是用out需要编写更多的代码。<%=  %>表达式的本质就是out.write(…);\n对于页面上的某个html标签来讲\n<table><tr></tr></table>\n如果使用了out即\n\n      <%\n    \tout.println(“<table>”);\n    \tout.println(“<tr>”);\n    \tout.println(“</tr>”);\n    \tout.println(“</table>”);\n      %>\n\n### pageContext对象\npageContext对象是JSP技术中最重要的一个对象，它代表JSP页面的运行环境，这个对象不仅封装了对其它8大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。\n\n    getException方法\t\t返回exception隐式对象\n    getPage方法\t\t\t返回page隐式对象\n    getRequest方法\t\t返回request隐式对象\n    getResponse方法\t\t返回response隐式对象\n    getServletConfig方法 返回config隐式对象\n    getServletContext方法返回application隐式对象\n    getSession方法\t\t返回session隐式对象\n    getOut方法\t\t\t返回out隐式对象\n\n>pageContext 封装其它8大内置对象的意义\n\n　　如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，把pageContext传递给谁，谁就能成为一个动态web资源，那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢，在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了java代码，那么就应该想办法把java代码移除掉，我们可以开发一个自定义标签来移除jsp页面上的java代码，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个java类，在调用java类的时候就会把pageContext对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。\n\n>pageContext 作为域对象\n\npageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。\n\npageContext对象的常用方法\n\n    1 public void setAttribute(java.lang.String name,java.lang.Object value)\n    2 public java.lang.Object getAttribute(java.lang.String name)\n    3 public void removeAttribute(java.lang.String name)\n    4 public java.lang.Object findAttribute(java.lang.String name)\n\n\n\n### application 对象\n - 在整个Web应用的多个JSP、Servlet之间的共享数据。通常被定义为数据字典来使用。通常在一处实现application.setAttribute(“name”,value);来定义一个变量，在JSP中使用application.getAttribute(“name”);获取值；在Servlet中使用一个实例的ServletContext对象sc.getAttribute(“name”);获取值。\n我们可以把application理解成一个Map对象，任何JSP、Servlet都可以把某个变量放入application中保存，并指出一个属性名；而该应用的其他JSP、Servlet就可以根据该属性名来得到这个变量。由于application对象代表整个Web应用，所以只应该把Web应用的状态数据放入到application中。\n - 访问Web应用的配置参数，在web.xml中配置类似的参数，该标签是<web-app></web-app>下的子标签。即\n    \n\n    <context-param>\n       <param-name>name</param-name>\n       <param-value>value</param-value>\n    </context-param>\n    \n\n 在JSP中可以通过 application.getInitParameter(“name”);取得配置的参数，在Servlet中可以先实例个ServletContext对象即：\n final javax.servlet.ServletContext application;\n然后就可以取值了，即：\n\n    application = pageContext.getServletContext();\n    application.getInitParameter(\"name\");\n\n这里通常被用作普通java Web开发中数据库用户名，密码的获取时使用，因为在项目开发用的密码不一定和部署在服务器上的密码一致，但是把它写到这里便于修改这些有关项目的参数。 \n\n### config 对象\nconfig对象代表当前的JSP配置信息，但JSP页面通常无需配置，因此也就不存在配置信息，该对象在JSP页面用的比较少，但在Servlet中用处则相对较大，因为Servlet需要在web.xml文件中进行配置，可以指定配置参数。但是如果说要为某个JSP配置一些参数的话，也是跟配置Servlet一样需要在web.xml中配置，也就说吧JSP当成Servlet配置\n\n    <servlet>\n       <servlet-name>Configure</servlet-name>\n       <jsp-file>/getcontextparam.jsp</jsp-file>\n       <init-param>\n     <param-name>conn</param-name>\n     <param-value>connnn</param-value>\n       </init-param>\n     </servlet>\n     <servlet-mapping>\n       <servlet-name>Configure</servlet-name>\n       <url-pattern>/configure</url-pattern>\n     </servlet-mapping>\n其中这里“<jsp-file>/getcontextparam.jsp</jsp-file>”是表明把某个JSP配置成Servlet。\n在地址栏中访问时要输入http://localhost:8080/test/configure（url-pattern中内容）\n在JSP中获取参数时使用config.getInitParameter(\"conn\")即可。\n\n### exception 对象\n该实例代表其他页面的异常和错误,只有当页面是错误处理页面，即编译指令page的isErrorPage属性为true时,该对象才可以使用","tags":["jsp"],"categories":["服务器"]},{"title":"Spring mvc整合velocity","url":"/2017/09/11/backend/framework/velocity/Spring mvc整合velocity/","content":"# 添加Maven依赖: #\n        <!--springmvc集成 velocity-->\n        <dependency>\n            <groupId>org.apache.velocity</groupId>\n            <artifactId>velocity</artifactId>\n            <version>1.7</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.velocity</groupId>\n            <artifactId>velocity-tools</artifactId>\n            <version>2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n<!--more-->\n# applicationContext-mvc配置文件: #\n    <!--》》》》》》》》》》》》》》》   添加velocity显示技术 》》》》》》》》》》》》》》》》》-->\n    <!-- velocity环境配置 -->\n    <bean id=\"velocityConfig\" class=\"org.springframework.web.servlet.view.velocity.VelocityConfigurer\">\n        <!-- velocity配置文件路径  或者直接用velocityProperties属性 -->\n        <property name=\"configLocation\" value=\"classpath:velocity.properties\"/>\n        <!-- velocity模板路径 -->\n        <property name=\"resourceLoaderPath\" value=\"/WEB-INF/templates/\"/>\n    </bean>\n    <!-- velocity视图解析器 -->\n    <bean id=\"velocityViewResolver\" class=\"org.springframework.web.servlet.view.velocity.VelocityLayoutViewResolver\">\n        <property name=\"order\" value=\"0\"/>\n        <property name=\"contentType\" value=\"text/html;charset=UTF-8\"/>\n        <property name=\"cache\" value=\"true\"/>\n        <property name=\"suffix\" value=\".vm\"/>\n        <property name=\"layoutUrl\" value=\"layout/layout.vm\"/>\n        <property name=\"exposeSpringMacroHelpers\" value=\"true\" /><!--是否使用spring对宏定义的支持-->\n        <property name=\"exposeSessionAttributes\" value=\"true\" /><!--是否开放request属性-->\n        <property name=\"requestContextAttribute\" value=\"request\"/><!--request属性引用名称-->\n        <property name=\"dateToolAttribute\" value=\"dateTool\"/>\n        <property name=\"numberToolAttribute\" value=\"numberTool\"/>\n    </bean>\n# velocity.properties 配置文件 #\n该文件velocity.properties 在下面的包路径可以找到 org.apache.velocity.runtime.defaults.velocity.properties\n\n\n    #设置字符集\n    #encoding\n    input.encoding  =UTF-8\n    output.encoding=UTF-8\n    contentType=text/html;charset=UTF-8\n    \n    \n    #autoreload when vm changed\n    file.resource.loader.cache=false\n    file.resource.loader.modificationCheckInterval  =1\n    velocimacro.library.autoreload=false\n# 显示文件目录结构 #\n![](/images/server/velocity-layout.png)\n\n## header.mv \n\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-store\"/>\n    <meta http-equiv=\"Pragma\" content=\"no-cache\"/>\n    <meta http-equiv=\"Expires\" content=\"3600\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" name=\"viewport\">\n\n## layout.mv ##\n    <html>\n    <head>\n    <title>$!page_title</title>\n    #parse(\"default/header.vm\")\n    </head>\n    <body>\n    \n    <div>\n    \n    $screen_content\n    \n    </div>\n    \n    </body>\n    </html>\n## velocity.mv ##\n    <html>\n    <head>\n    <title>Spring MVC and Velocity</title>\n    </head>\n    <body>\n    <h1>Spring MVC and Velocity</h1>\n    \n       Hello  ${hello}\n    \n    <hr />\n    Copyright &copy 2014 lm\n    </body>\n    </html>\n## velocity 基本语法 ##\nVelocity的基本语法：\n1、\"#\"用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#iinclude、#parse、#macro等；\n如:\n#if($info.imgs)\n<img src=\"$info.imgs\" border=0>\n#else\n<img src=\"noPhoto.jpg\">\n#end\n\n\n2、\"$\"用来标识一个对象(或理解为变量)；如\n如：$i、$msg、$TagUtil.options(...)等。\n\n\n3、\"{}\"用来明确标识Velocity变量；\n比如在页面中，页面中有一个$someonename，此时，Velocity将把someonename作为变量名，若我们程序是想在someone这 个变量的后面紧接着显示name字符，则上面的标签应该改成${someone}name。\n\n\n4、\"!\"用来强制把不存在的变量显示为空白。\n如当页面中包含$msg，如果msg对象有值，将显示msg的值，如果不存在msg对象同，则在页面中将显示$msg字符。这是我们不希望的，为了把不存 在的变量或变量值为null的对象显示为空白，则只需要在变量名前加一个“!”号即可。\n如：$!msg\n\n5、循#foreach( $info in $list) $info.someList #end，环读取集合list中的对象\n#foreach( $info in $hotL包含文件#inclue(\"模板文件名\")或#parse(\"模板文件名\")st1) \n<a href=\"/blog/list?&cid=$!info.cid\" target=\"_blank\">$!info.title</a><br>\n#end \n上面的脚本表示循环遍历hotList1集合中的对象，并输出对象的相关内容。\n\n6、包含文件#inclue(\"模板文件名\")或#parse(\"模板文件名\")\n主要用于处理具有相同内容的页面，比如每个网站的顶部或尾部内容。\n使用方法，可以参考EasyJF开源Blog及EasyJF开源论坛中的应用！\n如：#parse(\"/blog/top.html\")或#include(\"/blog/top.html\")\nparse与include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示。","tags":["Spring Mvc"],"categories":["server"]},{"title":"常用的JavaEE服务器","url":"/2017/09/10/backend/server/JavaEE服务器/常用的JavaEE服务器/","content":"# Web服务器 #\n## 1：Tomcat ##\n\t与Java结合的最好、开源、Oracle官方推荐的JSP服务器\n## 2：Jetty  ##\n\t嵌入式服务器：在应用中加入Jetty的Jar文件,即可提供Web服务，最好搭配Maven使用，采用maven jetty插件，即可通过简单的配置，执行命令即可启动web服务\n## 3：Resin ##\n\t目前最快的Jsp，Servlet运行平台，支持EJB,个人免费，商业交钱\n# Java EE服务器 #\n## 1：JBoss ##\n\t开源，全面支持各种最新的Java EE规范\n## 2：GlassFish ##\n\tOracle官方提供的JavaEE服务器\n## 3：WebLogic ##\n\t收费所以牛逼\n## 4：WebSphere ##\n\tIBM收费也是牛逼,WebSphere 是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的软件。","tags":["server"],"categories":["服务器"]},{"title":"新建博客方法","url":"/2017/09/10/essay/新建博客方法/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!--more-->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["github"],"categories":["随笔"]},{"title":"前端学习技术","url":"/2017/09/10/frontend/前端学习技术/","content":"技术架构图:\n<!--more-->\n![logo](/images/client.jpg)","tags":["web"],"categories":["client"]},{"title":"Hexo问题总结","url":"/2017/09/09/essay/hexo问题总结/","content":"# Hexo问题总结\n\n\n- **hexo部署后，CNAME会被自动删除，怎么办？**\n\n&nbsp;&nbsp;&nbsp;&nbsp;准确来说 CNAME 文件是放在 hexo 项目下的 source 目录，你再运行下hexo generade\n然后你再去 public 目录中看看就明白了BTW，为了达到更有说服力的验证，最好在开始前先运行下hexo clean\n这样会先删除 public 目录\n\n- **HEXO发布到Github上，README.md文件正常显示的解决**\n\n&nbsp;&nbsp;&nbsp;&nbsp;使用hexo d 发布本地编译过的代码到github上的时候，发现这个README.md文件也被解析的乱七八糟的，不是一般的github项目里面的README.md文件的显示样式，查了下，在最外层的_config.yml里面把\nskip_render: README.md\n添加这个配置，就OK啦。\n\n\n- **指定端口启动**\n\n    ` hexo server -p 4001`\n\n- **如何在markdowm中添加本地图片**\n\t\n    建议将图片统一放在 `source/images` 文件夹中。然后通过绝对路径` ![](/images/image.jpg)` 引用\n    \n- **卸载hexo**\n    `npm uninstall hexo -g `\n- hexo版本\n```xml\nhexo: 3.7.0\nhexo-cli: 1.0.3\n```","tags":["github"],"categories":["技术"]},{"title":"第一篇博客","url":"/2017/09/09/essay/第一篇博客/","content":"# 使用hexo+github搭建免费个人博客\n## 优势:\n1. 全是静态文件，访问速度快；\n2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；\n3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；\n4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；\n5. 博客内容可以轻松打包、转移、发布到其它平台；\n\n\n<!--more-->\n##  hexo\n\n### 简介\nHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。\n\n官网： http://hexo.io\n\ngithub: https://github.com/hexojs/hexo\n\n### 原理\n由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。\n\n\n### 注意事项 \n1. 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行\n2. hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导\n3. hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的\n4. 使用Hexo搭建博客时，需要区分『博客源代码』和『博客生成代码』\n\t1. 『博客源代码』: Hexo的源码，包括themes目录（博客模板），source目录(使用MarkDown写的博客)等\n\t2. 『博客生成代码』： 执行hexo generate或者hexo server命令生成的代码，是Hexo自动生成的，再public目录\n\n\n### 常用命令\n    hexo new \"postName\" \t #新建文章\n    hexo new page \"pageName\" #新建页面\n    hexo generate \t\t\t #生成静态页面至public目录\n    hexo server \t\t     #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n    hexo deploy \t\t\t #部署到GitHub\n    hexo help  \t\t\t\t #查看帮助\n    hexo version  \t\t\t #查看Hexo的版本\n### \n\n### hexo的文件结构\n    ├── _config.yml \n    ├── db.json\n    ├── node_modules \n    ├── package.json\n    ├── public \n    ├── scaffolds \n    ├── source #所有文章文件放在这里\n    └── themes #主题文件夹\n\n    _config.yml  站点的配置文件。\n    db.json   缓存文件\n    node_modules   安装的插件以及hexo所需的一些node.js模块。\n    package.json  应用程序信息，配置hexo运行需要的js包。\n    public  最终所见网页的所有内容\n    scaffolds   模板文件夹。当新建一个文章时，会默认包含对应模板的内容。\n    source  资源文件夹是存放用户资源的地方。所有的源文件都会被保存在_post文件夹中。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n    themes  存放主题文件，hexo会根据主题来生成静态页面。\n\n### 图片测试\n![logo](/images/dont-run.gif) ","tags":["nodejs"],"categories":["技术"]}]