[{"title":"HashSet","url":"/2018/07/08/Web后台/Java/集合容器/HashSet/","content":"#### HashSet源码：\n```java\n  public class HashSet<E>  \n      extends AbstractSet<E>  \n      implements Set<E>, Cloneable, java.io.Serializable  \n  {  \n      static final long serialVersionUID = -5024744406713321676L;  \n    \n      // 底层使用HashMap来保存HashSet中所有元素。  \n      private transient HashMap<E,Object> map;  \n        \n      // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。  \n      private static final Object PRESENT = new Object();  \n    \n      /** \n       * 默认的无参构造器，构造一个空的HashSet。 \n       *  \n       * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 \n       */  \n      public HashSet() {  \n        map = new HashMap<E,Object>();  \n      }  \n    \n      /** \n       * 构造一个包含指定collection中的元素的新set。 \n       * \n       * 实际底层使用默认的加载因子0.75和足以包含指定 \n       * collection中所有元素的初始容量来创建一个HashMap。 \n       * @param c 其中的元素将存放在此set中的collection。 \n       */  \n      public HashSet(Collection<? extends E> c) {  \n        map = new HashMap<E,Object>(Math.max((int) (c.size()/.75f) + 1, 16));  \n        addAll(c);  \n      }  \n    \n      /** \n       * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 \n       * \n       * 实际底层以相应的参数构造一个空的HashMap。 \n       * @param initialCapacity 初始容量。 \n       * @param loadFactor 加载因子。 \n       */  \n      public HashSet(int initialCapacity, float loadFactor) {  \n        map = new HashMap<E,Object>(initialCapacity, loadFactor);  \n      }  \n    \n      /** \n       * 以指定的initialCapacity构造一个空的HashSet。 \n       * \n       * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 \n       * @param initialCapacity 初始容量。 \n       */  \n      public HashSet(int initialCapacity) {  \n        map = new HashMap<E,Object>(initialCapacity);  \n      }  \n    \n      /** \n       * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 \n       * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 \n       * \n       * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 \n       * @param initialCapacity 初始容量。 \n       * @param loadFactor 加载因子。 \n       * @param dummy 标记。 \n       */  \n      HashSet(int initialCapacity, float loadFactor, boolean dummy) {  \n        map = new LinkedHashMap<E,Object>(initialCapacity, loadFactor);  \n      }  \n    \n      /** \n       * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 \n       *  \n       * 底层实际调用底层HashMap的keySet来返回所有的key。 \n       * 可见HashSet中的元素，只是存放在了底层HashMap的key上， \n       * value使用一个static final的Object对象标识。 \n       * @return 对此set中元素进行迭代的Iterator。 \n       */  \n      public Iterator<E> iterator() {  \n        return map.keySet().iterator();  \n      }  \n    \n      /** \n       * 返回此set中的元素的数量（set的容量）。 \n       * \n       * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 \n       * @return 此set中的元素的数量（set的容量）。 \n       */  \n      public int size() {  \n        return map.size();  \n      }  \n    \n      /** \n       * 如果此set不包含任何元素，则返回true。 \n       * \n       * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 \n       * @return 如果此set不包含任何元素，则返回true。 \n       */  \n      public boolean isEmpty() {  \n        return map.isEmpty();  \n      }  \n    \n      /** \n       * 如果此set包含指定元素，则返回true。 \n       * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) \n       * 的e元素时，返回true。 \n       * \n       * 底层实际调用HashMap的containsKey判断是否包含指定key。 \n       * @param o 在此set中的存在已得到测试的元素。 \n       * @return 如果此set包含指定元素，则返回true。 \n       */  \n      public boolean contains(Object o) {  \n        return map.containsKey(o);  \n      }  \n    \n      /** \n       * 如果此set中尚未包含指定元素，则添加指定元素。 \n       * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) \n       * 的元素e2，则向此set 添加指定的元素e。 \n       * 如果此set已包含该元素，则该调用不更改set并返回false。 \n       * \n       * 底层实际将将该元素作为key放入HashMap。 \n       * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key \n       * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， \n       * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， \n       * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， \n       * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 \n       * @param e 将添加到此set中的元素。 \n       * @return 如果此set尚未包含指定元素，则返回true。 \n       */  \n      public boolean add(E e) {  \n        return map.put(e, PRESENT)==null;  \n      }  \n    \n      /** \n       * 如果指定元素存在于此set中，则将其移除。 \n       * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， \n       * 则将其移除。如果此set已包含该元素，则返回true \n       * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 \n       * \n       * 底层实际调用HashMap的remove方法删除指定Entry。 \n       * @param o 如果存在于此set中则需要将其移除的对象。 \n       * @return 如果set包含指定元素，则返回true。 \n       */  \n      public boolean remove(Object o) {  \n        return map.remove(o)==PRESENT;  \n      }  \n    \n      /** \n       * 从此set中移除所有元素。此调用返回后，该set将为空。 \n       * \n       * 底层实际调用HashMap的clear方法清空Entry中所有元素。 \n       */  \n      public void clear() {  \n        map.clear();  \n      }  \n    \n      /** \n       * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 \n       * \n\n```\n#### HashSet保证元素不重复\nHashSet使用HashMap进行存放数据\n```java\n    public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n    }\n```\n\nputVal方法\n```java\n    /**\n     * Implements Map.put and related methods\n     *\n     * @param hash hash for key\n     * @param key the key\n     * @param value the value to put\n     * @param onlyIfAbsent if true, don't change existing value\n     * @param evict if false, the table is in creation mode.\n     * @return previous value, or null if none\n     */\n    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length; // 重新计算一下大小\n        // 获取要插入元素在 哈希桶中的位置\n        if ((p = tab[i = (n - 1) & hash]) == null) // 如果这个位置没有Node\n            tab[i] = newNode(hash, key, value, null); // 直接创建一个新的Node\n        else { // 说明此时在对应的索引位置已经有对象了\n            Node<K,V> e; K k;\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p; // 判断原对象与插入的对象的key是否一样\n            else if (p instanceof TreeNode) // 如果 你定位到的元素是一个TreeNode(Node的一个子类，也是HashMap的一个内部类)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 那么就插入一TreeNode节点 定位到这个hash桶了 但是这里面是链表（没有进行过树化）\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { //说明原对象与插入的对象的key相同\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value; //将新插入的entry的value覆盖掉原来的entry的value\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount; // 修改次数+1 和fastRemove()有关也和并发修改有关\n        if (++size > threshold) // 如果大于了阙值 需要扩容的大小\n            resize(); // 重新设置hash桶的大小，也有可能进行树化，见后面代码\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n\n\n\n","tags":["Java"],"categories":["server"]},{"title":"HashMap理解笔记","url":"/2018/06/07/Web后台/Java/HashMap理解笔记/","content":"### 什么是HashMap\nHashMap分为俩个词理解，一个是Hash，另一个是Map\n\nHash: 散列将一个任意长度通过某种hash函数算法转化成一个固定的值\n\nMap：可以理解为地图点的位置\n\n我们如果想要找到地图上的某个点，就需要通过经纬度来定位，Hash就是这个值，我们可以通过这个值，找到我们所要的位置\n\n### HashMap 简介\nHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。\n\nHashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。\n\nHashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。\n\nHashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。\n通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。\n\n### HashMap源码笔记\n\n#### HashMap 常量定义\n```sql\n    /**\n     * The default initial capacity - MUST be a power of two.\n     * 默认初始容量，为16个\n     */\n    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n    /**\n     * The maximum capacity, used if a higher value is implicitly specified\n     * by either of the constructors with arguments.\n     * MUST be a power of two <= 1<<30.\n     * 最大容量： 1073741824\n     */\n    static final int MAXIMUM_CAPACITY = 1 << 30;\n    /**\n     * The load factor used when none specified in constructor.\n     * 加载因子，当容量达到3/4的时候进行容量扩容, 不是满的时候再扩容\n     */\n    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n    /**\n     * The bin count threshold for using a tree rather than list for a\n     * bin.  Bins are converted to trees when adding an element to a\n     * bin with at least this many nodes. The value must be greater\n     * than 2 and should be at least 8 to mesh with assumptions in\n     * tree removal about conversion back to plain bins upon\n     * shrinkage.\n     * .由链表转换成树的阈值TREEIFY_THRESHOLD 一个桶中bin（箱子）的存储方式由链表转换成树的阈值。即当桶中bin的数量超过TREEIFY_THRESHOLD时使用树来代替链表。默认值是8\n     */\n     static final int TREEIFY_THRESHOLD = 8;\n     /**\n     * The bin count threshold for untreeifying a (split) bin during a\n     * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n     * most 6 to mesh with shrinkage detection under removal.\n     * 当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 \n     */\n     static final int UNTREEIFY_THRESHOLD = 6;\n    \n    /**\n     * The smallest table capacity for which bins may be treeified.\n     * (Otherwise the table is resized if too many nodes in a bin.)\n     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts\n     * between resizing and treeification thresholds.\n     * 当桶中的bin被树化时最小的hash表容量。（如果没有达到这个阈值，即hash表容量小于MIN_TREEIFY_CAPACITY，当桶中bin的数量太多时会执行resize扩容操作）这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。\n     */\n    static final int MIN_TREEIFY_CAPACITY = 64;\n\n```","tags":["Java"],"categories":["server"]},{"title":"Nginx 笔记","url":"/2018/06/05/Web后台/centos/Nginx 笔记/","content":"### 一. 为什么使用Nginx\nNginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性:\n\n1. 作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.\n\n2. 作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。\n\n3. 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。\n\n4. Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。\n基础功能\n\n### 二. 基础功能\n1. 处理静态文件，索引文件以及自动索引；\n\n2. 反向代理加速(无缓存)，简单的负载均衡和容错；\n\n3. FastCGI，简单的负载均衡和容错；\n\n4. 模块化的结构。过滤器包括gzipping, byte ranges, chunked responses, 以及 SSI-filter 。在SSI过滤器中，到同一个 proxy 或者 FastCGI 的多个子请求并发处理；\nSSL 和 TLS SNI 支持；\n","tags":["nginx"],"categories":["server"]},{"title":"基于 CentOS 搭建 Nginx 服务","url":"/2018/06/05/Web后台/centos/基于 CentOS 搭建 Nginx服务/","content":"### 1.安装使用Nginx\n#### 1.1 yum安装\n```sql\nyum install nginx\n```\n\n#### 1.2 提供目录权限\n```sql\n提供目录权限:\n　　我需要访问的目录是 /var/ftp, 用户是root, 所以修改如下配置:\n[root@S205 conf.d]# cat /etc/nginx/nginx.conf |grep user\nuser root;\n\n否则会出现这样的错误:\n[root@S205 conf.d]# tail /var/log/nginx/error.log \n2017/10/13 16:51:09 [error] 13383#0: *1 open() \"/home/data\" failed (13: Permission denied), client: 192.168.50.20, server: _, request: \"GET /data HTTP/1.1\", host: \"192.168.10.205:8080\"\n```\n<!-- more -->\n### 2.Nginx 命令\n#### 2.1 启动重启\n```sql\n\n[root@S205 conf.d]# systemctl enable nginx\n\n[root@S205 conf.d]# systemctl restart nginx\n\n[root@S205 conf.d]# vi /etc/nginx/nginx.conf\n```\n#### 2.2 \n\n### 3.Nginx 启用对文件目录的http访问\n解决以ftp路径形式的图片，在谷歌浏览器上不能正常访问的问题，所以使用http的形式访问文件\n\n#### 3.1 配置如下：\n采用： http://ip/uploadfile/文件路径的形式访问 或者 直接 http://ip/文件路径的形式访问\n```sql\n    server {\n        listen       80 default_server;\n        listen       [::]:80 default_server;\n        server_name  _;\n        root        /var/ftp/pub;\n\n        # Load configuration files for the default server block.\n        include /etc/nginx/default.d/*.conf;\n\n        location / {\n          autoindex on;\n          autoindex_localtime on;\n        }\n\n        location /uploadfile {\n           alias /var/ftp/pub;\n           autoindex on;\n           autoindex_localtime on;\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n```\n#### 3.2 autoindex 和 autoindex_localtime 生成目录索引\n```sql\n  autoindex  on;                        #自动显示目录\n  autoindex_exact_size  off;            #改为off后，显示出文件的大概大小，单位是kB或者MB或者GB；即人性化方式显示文件大小否则以byte显示\n  autoindex_localtime on;               #显示的文件时间为文件的服务器时间；即按服务器时间显示\n  limit_rate_after 10m;                 #10m之后下载速度为10k\n```\n\n参考:http://blog.licess.com/nginx-autoindex/\n\n#### 3.2 解决目录列表文件名乱码问题\n\n```sql\nvi  /etc/nginx/nginx.conf \n\n加上 charset utf-8,gbk即可解决;\n\nuser  nginx;\nworker_processes  1;\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\nevents {\n    worker_connections  1024;\n}\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    access_log  /var/log/nginx/access.log  main;\n    sendfile        on;\n    #tcp_nopush     on;\n    keepalive_timeout  65;\n    #gzip  on;\n    include /etc/nginx/conf.d/*.conf;\n    autoindex on;\n    autoindex_exact_size off;\n    autoindex_localtime on;\n    charset utf-8,gbk;\n}\n```\n### 4.Nginx 配置反向代理\n```sql\n#user  nobody;\nworker_processes  1;\n#error_log  logs/error.log;\nerror_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#error_log /usr/local/etcinx/logs/error.log  warn;\n#pid        logsinx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n    #                  '$status $body_bytes_sent \"$http_referer\" '\n    #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #access_log  logs/access.log  main;\n    #tcp_nopush     on;\n    #keepalive_timeout  0;\n    \n    sendfile        on;\n    keepalive_timeout  65;\n\n    gzip  on;\n    gzip_min_length     1k;\n    gzip_comp_level     3;\n    gzip_buffers     4 16k;\n    gzip_vary on;\n\t\n    server {\n        listen       80;\n        server_name  localhost 192.168.0.252 songshuiyang.com;\n        \n        location / {\n            proxy_pass   http://127.0.0.1:4080;\n            proxy_set_header  Host $http_host;\n            proxy_set_header  X-Real-IP $remote_addr;\n            proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n\t\t    client_max_body_size 100m;\n        }\n\n        location /uploadfile {\n           alias /var/ftp/pub ;\n        }\n\n        location /webapp {\n\t\t\tproxy_pass   http://127.0.0.1:8068;\n\t\t\tproxy_set_header  Host $http_host;\n            proxy_set_header  X-Real-IP $remote_addr;\n            proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n\n        location /admin-webapp {\n            alias html/test-admin-webapp;\n        }\n\t\t\n\t\tlocation = /favicon.ico {\n\t\t\talias /var/ftp/pub/favicon.ico;\n\t\t}\n\n    }\n}\n#  include servers/*;\n```\n### 5.Nginx 简单的负载均衡的示例\n```sql\nhttp {\n  upstream myproject {\n  server 127.0.0.1:8000 weight=3;\n  server 127.0.0.1:8001;\n  server 127.0.0.1:8002;\n  server 127.0.0.1:8003;\n}\n\nserver {\n  listen 80;\n  server_name www.domain.com;\n  location / {\n   proxy_pass http://myproject;\n  }\n  }\n}\n```\n\n本文参考： http://www.bubuko.com/infodetail-2349571.html","tags":["nginx"],"categories":["server"]},{"title":"基于 CentOS 搭建 FTP 文件服务","url":"/2018/06/05/Web后台/centos/基于 CentOS 搭建 FTP 文件服务/","content":"### 1.安装并启动 FTP 服务\n#### 1.1 使用 yum 安装 vsftpd\n```sql\n# yum默认都是安装最新版的软件\nyum install -y vsftpd\n```\n#### 1.2 启动 vsftpd\n```sql\n安装完成后，启动 FTP 服务：\nservice vsftpd start\n\n启动后，可以看到系统已经监听了 21 端口：\nnetstat -nltp | grep 21\n\n此时，访问 ftp://主机ip 可浏览机器上的 /var/ftp目录了。\n```\n<!-- more -->\n### 2.配置 FTP 权限\n#### 2.1 了解 VSFTP 配置\n```sql\nvsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件：\n\nvsftpd.conf 为主要配置文件\nftpusers 配置禁止访问 FTP 服务器的用户列表\nuser_list 配置用户访问控制\n```\n#### 2.1 创建 FTP 用户\n```sql\n创建一个用户 ftpuser\nuseradd ftpuser\n为用户 ftpuser 设置密码\necho \"password\" | passwd ftpuser --stdin\n```\n#### 2.2 限制该用户仅能通过 FTP 访问\n```sql\n限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：\nusermod -s /sbin/nologin ftpuser\n```\n 命令笔记: \n```sql\n用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的crontab档。也需手动更改使用者的at工作档。采用NIS server须在server上更动相关的NIS设定。\n-c<备注>：修改用户帐号的备注文字；\n-d<登入目录>：修改用户登入时的目录；\n-e<有效期限>：修改帐号的有效期限；\n-f<缓冲天数>：修改在密码过期后多少天即关闭该帐号；\n-g<群组>：修改用户所属的群组；\n-G<群组>；修改用户所属的附加群组；\n-l<帐号名称>：修改用户帐号名称；\n-L：锁定用户密码，使密码无效；\n-s<shell>：修改用户登入后所使用的shell；\n-u<uid>：修改用户ID；\n-U:解除密码锁定。\n```\n#### 2.3 创建登录欢迎文件\n```sql\necho \"Welcome to use FTP service.\" > /var/ftp/welcome.txt\n```\n\n#### 2.4 配置权限\n```sql\n设置访问权限\nchmod a-w /var/ftp && chmod 777 -R /var/ftp/pub\n\n设置为用户的主目录：\nusermod -d /var/ftp ftpuser\n```\n命令笔记:\n```sql\n权限范围的表示法如下：\nu User，即文件或目录的拥有者；\ng Group，即文件或目录的所属群组；\no Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；\na All，即全部的用户，包含拥有者，所属群组以及其他用户；\nr 读取权限，数字代号为“4”;\nw 写入权限，数字代号为“2”；\nx 执行或切换权限，数字代号为“1”；\n- 不具任何权限，数字代号为“0”；\ns 特殊功能说明：变更文件或目录的权限。\n\n-c或——changes：效果类似“-v”参数，但仅回报更改的部分；\n-f或--quiet或——silent：不显示错误信息；\n-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；\n-v或——verbose：显示指令执行过程；\n--reference=<参考文件或目录>：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；\n<权限范围>+<权限设置>：开启权限范围的文件或目录的该选项权限设置；\n<权限范围>-<权限设置>：关闭权限范围的文件或目录的该选项权限设置；\n<权限范围>=<权限设置>：指定权限范围的文件或目录的该选项权限设置；\n\nLinux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內！\n\n例：rwx　rw-　r--\n\nr=读取属性　　//值＝4\nw=写入属性　　//值＝2\nx=执行属性　　//值＝1\n\nchmod u+x,g+w f01　　//为文件f01设置自己可以执行，组员可以写入的权限\nchmod u=rwx,g=rw,o=r f01\nchmod 764 f01\nchmod a+x f01　　//对文件f01的u,g,o都设置可执行属性\n文件的属主和属组属性设置\n\nchown user:market f01　　//把文件f01给uesr，添加到market组\nll -d f1  查看目录f1的属性\n```\n#### 2.5 备注\n一： 以上配置是匿名用户可以通过ftp://主机ip 即可访问文件，但不能上传文件，所以需要添加一个`ftpuser`用户ftp上传操作，这样做有俩个好处\n1. 访问文件可以通过一个ftp绝对路径访问(也可以通过nginx代理通过http的形式访问)，不需要输入用户名及密码\n2. 上传修改文件只能通过该(ftpuser)用户才能进行操作，保证了其安全性\n\n二： 阻止匿名访问和切换根目录\n```sql\n匿名访问和切换根目录都会给服务器带来安全风险，我们把这两个功能关闭。\n编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：\nvi /etc/vsftpd/vsftpd.conf\n \n# 禁用匿名用户  12 YES 改为NO\nanonymous_enable=NO\n\n# 禁止切换根目录 101 行 删除#\nchroot_local_user=YES\n编辑完成后保存配置，重新启动 FTP 服务\nservice vsftpd restart\n```\n\n\n本文参考： https://www.baidu.com/link?url=3FcSvP44zFbo33EoJBucNlE1ZKKkncTuckfxuvNFJhCPvQuZmlebtZRzRAW3-W0SH8Ep8dShtJ8NSjWlozkrPa&wd=&eqid=edc2684700001d70000000065b17479b","tags":["ftp"],"categories":["server"]},{"title":"基于 CentOS 搭建 FTP 文件服务","url":"/2018/06/05/Web后台/centos/基于 CentOS 搭建 Jenkins服务/","content":"### 1.安装jenkins\n#### 1.1 拉取库的配置到本地对应文件\n```sql\nsudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo\n\njenkins.repo内容是这样：\n\n[jenkins]\nname=Jenkins-stable\nbaseurl=http://pkg.jenkins.io/redhat-stable\ngpgcheck=1\n```\n#### 1.2 导入公钥\n```\nsudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key\n```\n#### 1.3 安装jenkins\n```sql\n安装jenkins＃`-y`参数：回答全部问题为是\nsudo yum -y install jenkins\n```\n### 2.配置jenkins\n#### 2.1 配置端口\n```sql\nvi /etc/sysconfig/jenkins\n\nJENKINS_PORT=\"8080\"\n```\n\n### 3.启动jenkins\n```sql\nsudo service jenkins start\n```","tags":["ftp"],"categories":["server"]},{"title":"Shiro记事","url":"/2018/06/05/Web后台/Shiro/Shiro记事/","content":"### Shiro内置了默认的拦截器\n\n\n### 配置Shiro使得多个角色可以访问同一URL\n在Shiro配置中，如果对某一URL作如下配置：\n\n`/a.jsp = roles[\"role1, role2\"]`\n\n其效果等效于hasAllRoles，即要求所有角色都满足才可访问。\n\n但在实际中，可能只需满足任一角色即可访问。在这种情况下，需要自己重载RolesAuthorizationFilter的isAccessAllowed，实现或的关系。具体实现如下：\n```\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\npublic class AnyOfRolesAuthorizationFilter extends RolesAuthorizationFilter {\n    @Override\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response,\n                                   Object mappedValue) throws IOException {\n        final Subject subject = getSubject(request, response);\n        final String[] rolesArray = (String[]) mappedValue;\n        if (rolesArray == null || rolesArray.length == 0) {\n\n            //no roles specified, so nothing to check - allow access.\n\n            return true;\n        }\n        for (String roleName : rolesArray) {\n\n            if (subject.hasRole(roleName)) {\n\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n相应地，在INI文件中作如下配置：\n```sql\n[main]\n...\nanyofroles = com.your.package.AnyOfRolesAuthorizationFilter\n[urls]\n...\n/path/to/some/url = anyofroles[\"role1,role2\"]\n```\n","tags":["shiro"],"categories":["server"]},{"title":"使用微软提供的Office Online实现Office文档的在线查看,编辑等功能","url":"/2018/05/08/Web后台/相关技术/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能/","content":"### 使用微软提供的Office Online实现Office文档的在线查看,编辑\n\n使用微软提供的Office Online平台只需要一个网址即可在线查看Xls,doc,PPT等文档\n#### 在线预览\nhttp://view.officeapps.live.com/op/view.aspx?src=要查看的文档地址\n\n#### 在线编辑\n在线编辑需要登录https://www.office.com并从onedrive中打开或新建文档也可以来自在线模板(下面的Excel来自Excel Online模板，编辑后的文件会保存到你的onedrive中)\n在线编辑Xls文档(部分功能不支持,但已经够用)","tags":["Java"],"categories":["server"]},{"title":"freemaker模板框架","url":"/2018/04/14/Web后台/模板框架/freemaker模板框架/","content":"### freemaker 语法笔记\n* if 条件\n```xml\n      <#if entity.columnName == 'id' >\n       \n      <#elseif entity.columnName == 'id' >\n        \n      <#else>\n        \n      </#if>\n```\n\n* list 遍历元素\n````xml\n1. 遍历\n要想在Freemarker中遍历list,必须通过使用list指令,即<#list sequence as item>…</#list>\nsequence是集合(collection)的表达式，item是循环变量的名字，不能是表达式。\n\n<#list userList as user>\n  …\n</#list>\n\nList指令还隐含了两个循环变量：\n    item_index:当前迭代项在所有迭代项中的位置，是数字值。\n    item_has_next:用于判断当前迭代项是否是所有迭代项中的最后一项。\n    注意：在使用上述两个循环变量时，一定要将item换成你自己定义的循环变量名,item其实就是前缀罢了。\n\n    <#--Freemarker遍历list并应用list隐含变量item_index-->\n        item_index使用：\n        <#list userList as user>\n        第${user_index+1}个用户\n          用户名：${user.userName}\n          密  码：${user.userPassword}\n          年  龄: ${user.age}\n        </#list>\n    <#--Freemarker遍历list并应用list隐含变量item_has_next-->\n        item_has_next,size使用：\n        <#list userList as user>\n          用户名：${user.userName}\n          密  码：${user.userPassword}\n          年  龄: ${user.age}\n          <#if !user_has_next>\n          共有${userList?size}最后一个用户是:${user.userName}\n        </#if>\n        </#list>\n\n2. 排序\n\nsort升序排序函数\n    sort对序列(sequence)进行排序，要求序列中的变量必须是：字符串（按首字母排序）,数字，日期值。\n    <#list list?sort as l>…</#list>\nsort_by函数\n    sort_by有一个参数,该参数用于指定想要排序的子变量，排序是按照变量对应的值进行排序,如：\n    <#list userList?sort_by(“age”) as user>…</#list>\n    age是User对象的属性，排序是按age的值进行的。\nreverse降序排序函数\n    <#list list? reverse as l>…</#list>。reverse使用同sort相同。reverse还可以同sort_by一起使用\n    如：想让用户按年龄降序排序，那么可以这个样写<#list userList?sort_by(“age”)?reverse as user>…</#list>\n    \n    \n````","tags":["Java"],"categories":["server"]},{"title":"Java获取数据表元数据","url":"/2018/04/14/Web后台/Java/Java获取数据表元数据/","tags":["Java"],"categories":["server"]},{"title":"Spring 集成Redis","url":"/2018/04/08/Web后台/缓存技术/Redis/","content":"## 一：Redis\n\n### 1. 什么是Redis\nRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。\n\n官网: https://redis.io/\n\n中文教程网: http://www.redis.net.cn/tutorial/3501.html\n\n### 2. 基本介绍\n#### Redis 简介\n* Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。\n* Redis 与其他 key - value 缓存产品有以下三个特点：\n* Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n* Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n* Redis支持数据的备份，即master-slave模式的数据备份。\n\n#### Redis 优势\n* 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n* 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n* 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n* 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n#### Redis与其他key-value存储有什么不同？\n* Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。\n* Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。\n\n<!--more-->\n### 3. 安装\n\n#### 3.1 windows环境\n下载地址: https://github.com/MicrosoftArchive/redis/releases\n\n#### 3.1.1 修改配置文件\n```sql\nredis.windows.conf 文件 配置密码 \n\n\n# requirepass foobared\nrequirepass shuiyang\n```\n#### 3.1.2 常用命令\n``` java\nredis服务安装成windows服务: redis-server --service-install redis.windows.conf\n\n开启服务：redis-server --service-start\n\n停止服务：redis-server --service-stop\n\n卸载服务：redis-server --service-uninstall\n```\n\n#### 3.1.3 Redis可视化管理工具\n* RedisStudio，百度云连接：http://pan.baidu.com/s/1gfIbLar  密码：mpne\n* Redis Desktop Manager https://redisdesktop.com/download\n\n                \n#### 3.2 Linux环境\n下载地址：http://www.redis.net.cn/download/，下载最新文档版本。\n#### 3.2.1 安装\n```sql\n$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz\n$ tar xzf redis-2.8.17.tar.gz\n$ cd redis-2.8.17\n$ make\n```\nmake完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli\n\n#### 3.2.1 启动服务\n下面启动redis服务.\n\n```sql\n$ ./redis-server\n```\n\n注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。\n\n```sql\n./redis-server redis.conf\n```\n\nredis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。\n\n#### 3.2.1 测试客户端程序\n启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如：\n\n```sql\n$ ./redis-cli\nredis> set foo bar\nOK\nredis> get foo\n\"bar\"\n```\n\n### 4. 与Spring 集成\n\n#### 4.1 导入maven\n```xml\n        <!--redis-->\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.data</groupId>\n            <artifactId>spring-data-redis</artifactId>\n            <version>1.6.2.RELEASE</version>\n        </dependency>\n```\n\n#### 4.2 新建 `redis-config.properties`\n```xml\n# Redis settings\nredis.host=127.0.0.1\nredis.port=6379\nredis.pass=shuiyang\nredis.dbIndex=0\nredis.expiration=3000\n#最大空闲数\nredis.maxIdle=300\n#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotal\nredis.maxActive=600\n#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。\nredis.maxWait=1000\n#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个\nredis.testOnBorrow=true\n```\n\n\n#### 4.3 新建 `applicationContext-redis.xml`\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n            http://www.springframework.org/schema/context\n            http://www.springframework.org/schema/context/spring-context-4.0.xsd\n            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd\n            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\n            http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd\">\n\n\n    <!-- 启用缓存注解开关 -->\n    <cache:annotation-driven cache-manager=\"cacheManager\"/>\n\n    <!-- 配置JedisPoolConfig实例 -->\n    <bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\">\n        <property name=\"maxIdle\" value=\"${redis.maxIdle}\" />\n        <property name=\"maxTotal\" value=\"${redis.maxActive}\" />\n        <property name=\"maxWaitMillis\" value=\"${redis.maxWait}\" />\n        <property name=\"testOnBorrow\" value=\"${redis.testOnBorrow}\" />\n    </bean>\n\n    <!-- 配置JedisConnectionFactory -->\n    <bean id=\"jedisConnectionFactory\"\n          class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\">\n        <property name=\"hostName\" value=\"${redis.host}\" />\n        <property name=\"port\" value=\"${redis.port}\" />\n         <property name=\"password\" value=\"${redis.pass}\" />\n        <property name=\"database\" value=\"${redis.dbIndex}\" />\n        <property name=\"poolConfig\" ref=\"poolConfig\" />\n    </bean>\n\n    <!-- 配置RedisTemplate -->\n    <bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\">\n        <property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" />\n    </bean>\n\n    <!-- 配置RedisCacheManager -->\n    <bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\">\n        <constructor-arg name=\"redisOperations\" ref=\"redisTemplate\" />\n        <property name=\"defaultExpiration\" value=\"${redis.expiration}\" />\n    </bean>\n\n    <!-- 配置RedisCacheManager -->\n    <bean id=\"cacheManager\" class=\"org.springframework.cache.support.SimpleCacheManager\">\n        <property name=\"caches\">\n            <set>\n                <!-- 这里可以配置多个redis -->\n                <bean class=\"com.ecut.core.config.RedisCache\">\n                    <property name=\"redisTemplate\" ref=\"redisTemplate\" />\n                    <property name=\"name\" value=\"articlesDetail\"/>\n                </bean>\n                <bean class=\"com.ecut.core.config.RedisCache\">\n                    <property name=\"redisTemplate\" ref=\"redisTemplate\" />\n                    <property name=\"name\" value=\"getHotArticlesInCache\"/>\n                </bean>\n                <bean class=\"com.ecut.core.config.RedisCache\">\n                    <property name=\"redisTemplate\" ref=\"redisTemplate\" />\n                    <property name=\"name\" value=\"articlesList\"/>\n                </bean>\n            </set>\n        </property>\n    </bean>\n</beans>\n```\n#### 4.4 引入 `applicationContext-redis.xml redis-config.properties`\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xmlns:context=\"http://www.springframework.org/schema/context\"\n           xmlns:p=\"http://www.springframework.org/schema/p\"\n           xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n           xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n\thttp://www.springframework.org/schema/mvc\n\thttp://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\">\n\n    <!--使标注Spring注解的类生效-->\n    <context:component-scan base-package=\"com.ecut\"/>\n\n    <!-- 将多个配置文件读取到容器中，交给Spring管理 -->\n    <bean id=\"propertyConfigurer\" class=\"com.ecut.core.spring.PropertyPlaceholderConfigurerFilter\">\n        <property name=\"locations\">\n            <list>\n                <!-- 这里支持多种寻址方式：classpath和file -->\n                <value>classpath:project.properties</value>\n                <!-- 推荐使用file的方式引入，这样可以将配置和代码分离 -->\n                <value>classpath:jdbc.properties</value>\n                <value>classpath:redis-config.properties</value>\n            </list>\n        </property>\n    </bean>\n\n    <import resource=\"applicationContext-dao.xml\"/>\n    <import resource=\"applicationContext-shiro.xml\"/>\n    <!--encache redis选择一种缓存-->\n    <!--<import resource=\"applicationContext-encache.xml\"/>-->\n    <import resource=\"applicationContext-redis.xml\"/>\n</beans>\n```\n#### 4.5 新建 `RedisCache.java` Cache接口实现类 Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。\n```java\npackage com.ecut.core.config;\n\nimport java.io.Serializable;\n\nimport org.apache.commons.lang3.SerializationUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.Cache;\nimport org.springframework.cache.support.SimpleValueWrapper;\nimport org.springframework.dao.DataAccessException;\nimport org.springframework.data.redis.connection.RedisConnection;\nimport org.springframework.data.redis.core.RedisCallback;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport java.io.Serializable;\n\n/**\n * Cache接口实现类\n *\n * 　Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。\n 　　在上面配置中可知，每个实现类都会注入一个redisTemplate实例，我们就可以通过redisTemplate来操作redis\n * @author songshuiyang\n * @date 2018/4/9 20:38\n */\npublic class RedisCache implements Cache {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    private RedisTemplate<String, Object> redisTemplate;\n\n    private String name;\n\n    @Override\n    public void clear() {\n        logger.info(\"----------------------------RedisCache  緩存清理-------------------------\");\n        redisTemplate.execute(new RedisCallback<String>() {\n            @Override\n            public String doInRedis(RedisConnection connection) throws DataAccessException {\n                connection.flushDb();\n                return \"ok\";\n            }\n        });\n    }\n\n    @Override\n    public void evict(Object key) {\n        logger.info(\"----------------------------RedisCache  緩存刪除-------------------------\");\n        final String keyf=key.toString();\n        redisTemplate.execute(new RedisCallback<Long>() {\n            @Override\n            public Long doInRedis(RedisConnection connection) throws DataAccessException {\n                return connection.del(keyf.getBytes());\n            }\n\n        });\n\n    }\n\n    @Override\n    public ValueWrapper get(Object key) {\n        logger.info(\"----------------------------RedisCache  缓存获取-------------------------\");\n        final String keyf = key.toString();\n        Object object = null;\n        object = redisTemplate.execute(new RedisCallback<Object>() {\n            @Override\n            public Object doInRedis(RedisConnection connection) throws DataAccessException {\n                byte[] key = keyf.getBytes();\n                byte[] value = connection.get(key);\n                if (value == null) {\n                    logger.info(\"----------------------------RedisCache 缓存不存在-------------------------\");\n                    return null;\n                }\n                return SerializationUtils.deserialize(value);\n            }\n        });\n        ValueWrapper obj=(object != null ? new SimpleValueWrapper(object) : null);\n        logger.info(\"----------------------------RedisCache 获取到内容-------------------------\");\n        return  obj;\n    }\n\n    @Override\n    public void put(Object key, Object value) {\n        System.out.println(\"-------加入缓存------\");\n        System.out.println(\"key----:\"+key);\n        System.out.println(\"key----:\"+value);\n        final String keyString = key.toString();\n        final Object valuef = value;\n        final long liveTime = 86400;\n        redisTemplate.execute(new RedisCallback<Long>() {\n            @Override\n            public Long doInRedis(RedisConnection connection) throws DataAccessException {\n                byte[] keyb = keyString.getBytes();\n                byte[] valueb = SerializationUtils.serialize((Serializable) valuef);\n                connection.set(keyb, valueb);\n                if (liveTime > 0) {\n                    connection.expire(keyb, liveTime);\n                }\n                return 1L;\n            }\n        });\n\n    }\n\n    @Override\n    public <T> T get(Object arg0, Class<T> arg1) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    @Override\n    public Object getNativeCache() {\n        return this.redisTemplate;\n    }\n\n    @Override\n    public ValueWrapper putIfAbsent(Object arg0, Object arg1) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n\n    public RedisTemplate<String, Object> getRedisTemplate() {\n        return redisTemplate;\n    }\n\n    public void setRedisTemplate(RedisTemplate<String, Object> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n#### 4.6 完成以上的配置之后就可以使用 Spring Cache注解来使用缓存了\n首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。\n* @Cacheable\n\n```sql\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 \n这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 \n可以使用key属性来指定key的生成规则。\n\n@Cacheable 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中\n  key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId，\n\n  一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， \n  本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等\n\n  condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL\n  \n  \n  // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1'\n  @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\")    \n  public User findById(String userId) {    \n      return (User) new User(\"1\", \"mengdee\");           \n  }    \n  \n  // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key\n  // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\"\n  @Cacheable(value=\"UserCache\", condition=\"#userId.length() < 12\")    \n  public boolean isReserved(String userId) {    \n      System.out.println(\"UserCache:\"+userId);    \n      return false;    \n  }\n```\n* @CachePut\n\n```sql\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。\n```\n\n* @CacheEvict\n```sql\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。\n\n@CacheEvict 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，同上\n  key：缓存的key，默认为空，同上\n  condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL\n  allEntries：true表示清除value中的全部缓存，默认为false\n\n  //清除掉UserCache中某个指定key的缓存    \n  @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\")    \n  public void removeUser(User user) {    \n      System.out.println(\"UserCache\"+user.getUserId());    \n  }    \n  \n  //清除掉UserCache中全部的缓存    \n  @CacheEvict(value=\"UserCache\", allEntries=true)    \n  public final void setReservedUsers(String[] reservedUsers) {    \n     System.out.println(\"UserCache deleteall\");    \n  }\n  \n  \n```\n* @Caching\n```sql\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") })\npublic Book importBooks(String deposit, Date date)\n\n```\n* @CacheConfig\n```sql\n与前面的缓存注解不同，这是一个类级别的注解。\n 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig(\"books\")\npublic class BookRepositoryImpl implements BookRepository {\n    @Cacheable\n    public Book findBook(ISBN isbn) {...}\n}\n```\n## 遇到的问题：\n* spring+redis报错org.springframework.core.serializer.support.DeserializingConverter.<init>(Ljava/lang/ClassLoader;)V\n```java\n这个问题的原因大概就是spring-data-redis.jar包版本不对 ，下面版本可以正常启动\n\n        <dependency>\n            <groupId>org.springframework.data</groupId>\n            <artifactId>spring-data-redis</artifactId>\n            <version>1.6.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>redis.clients</groupId>\n            <artifactId>jedis</artifactId>\n            <version>2.9.0</version>\n        </dependency>\n```\n* Spring Cache 注解问题，使用redis缓存会出现类型转化的问题 ,还未解决\n\n\n\n## 参考： \nhttps://www.cnblogs.com/panter/p/6801210.html\nhttp://www.redis.net.cn/tutorial/3503.html\nhttps://www.cnblogs.com/hello-daocaoren/p/7891907.html\n\n\n","tags":["java"],"categories":["server"]},{"title":"微信公众号实现输入兑换码自动发红包功能","url":"/2018/04/03/Web后台/支付/微信公众号开通发红包功能/","content":"### 前言\n 公司积分抽奖活动有红包奖项(虽然基本上都是这个奖)，但是用户兑奖的过程十分麻烦: 需要先联系公司客服，然后加客服微信，加完之后客服发一个微信红包作为兑换。所以决定简化这个兑奖过程，能不能将这个兑奖的过程改为由用户自己兑换，不用联系公司客服也能兑奖。\n \n### 初步想法\n 公司有微信公众号，可以通过微信公众号进行发红包操作，一方面可以实现发送红包的功能，另一方面也可以推广公司的微信公众号。初步想法是用户在微信公众号里输入一个兑换码，然后微信自动发送一个红包给用户，用户只要点一下红包，红包就进用户自己口袋了\n \n### 业务流程\n如果用户抽奖中了红包奖励，系统弹出一个提示框，里面有公司的微信公众号二维码图片（微信公众平台可以获取），及兑奖的兑换码，提示用户关注微信公众号，在公众号里面输入兑换码就可以获取红包\n\n<!--more-->\n### 准备\n1、先介绍几个平台\n\nI.微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。\n\n平台入口：http://mp.weixin.qq.com。\n\nII.微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。\n\n平台入口：http://pay.weixin.qq.com\n\nIII. 红包接口地址： https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&index=3\n\n2、 在微信公众平台获取公众号二维码图片（提供了多种尺寸大小），该二维码是提供给用户扫描， 及公众账号appid\n\n3、 在微信商户平台上下载证书（账户中心 - 账户设置 - API安全 - API证书（下载zip压缩包格式即可，无须解压），获取 商户号（账户中心 - 账户设置 - 商户信息 - 基本账户信息 - 微信支付商户号），API密钥（账户中心 - 账户设置 - API安全 - API密钥 - 设置密钥（密钥为32位，需要自行重新设置，记录并保存好，实在没记住也可以更改） 这些参数\n\n4、 开通红包功能，以及充值红包金额，红包金额与充值交易金额是区分开来的，所以需要单独充值，发放现金红包将扣除商户的可用余额，请注意，可用余额并不是微信支付交易额，需要预先充值，确保可用余额充足。查看可用余额、充值、提现请登录微信支付商户平台，进入“资金管理”菜单，进行操作\n\n5、 介绍\n```java\n现金红包简介\n微信红包，2014年春节一经推出即受到广大用户好评，引发全民抢红包热潮。现将微信红包打造成“现金红包”，成为一款定向资金发放的营销工具，供商户使用。\n\n申请红包条件\n1、T+0 结算商户需满足两个条件：1、入驻满90天，2、截止今日往回推30天内连续正常交易。\n2、其余结算周期的商户无限制，可立即前往【商户平台】->【产品中心】申请开通。\n\n发放方式介绍\n商户发放现金红包有3种发放方式：\n1）接口发放\n商户根据文档”【商户平台】现金红包API文档V2“进行开发，一次调用可以给一个指定用户发送一个指定金额的红包，满足多元化的运营需求；\n2）通过上传openid文件发放\n收集要发送红包对象的openid，将openid编辑成txt文件，登录微信支付商户平台，使用上传文件功能发放。一份文件对应一个红包模板，便于管理；\n为了防止商户手误重复操作发送红包，创建的同一个文件只能上传一次。若需要重复发放则需要修改文件名称或重新创建。\n3）配置营销规则“满额送”发放\n配置的规则不可使用红包模版进行发放，商户须在【产品中心】-【现金红包】-【前往功能】中创建红包后配置自助规则：用户使用微信支付发生交易满足一定条件，立送现金红包。\n\n税务和发票问题\n商户给用户发红包，微信支付按照商户指定红包金额扣除完全对等的充值资金，资金最终进入用户零钱。微信支付并未从中收取资金作为营收，所以不予开具发票。\n发放现金红包请商户遵照国家法律依法纳税，在商户充值之前，我们默认商户已经合法上税，商户使用本功能的行为若涉及纳税或代扣代缴税款的义务，由商户自行承担该义务，我们不会替商户缴纳税款 。\n```\n\n### 程序实现\n1、用户抽奖中了红包奖励, 生成一笔抽奖记录，同时生成一笔红包记录，所以需要新建一个红包记录表(表结构如下图)，一开始生成的记录中红包状态是 0-未发放的状态，同时生成兑换码。\n\n兑换码规则：\n\n10位大写字母：3位固定字母开头 + 7位随机字母（大写字母是为了防止【数字0 与字母o O】【 1与字母l】混淆导致用户兑换不了奖， 3位固定字母是为了防止恶意用户无限次输入兑换码导致老是触发红包处理程序，如果不是以这个三个字母开头的文字，统一回复欢迎关注本微信公众号）\n\n```sql\nDROP TABLE IF EXISTS `ge_lottery_redpack_record`;\nCREATE TABLE `ge_lottery_redpack_record` (\n  `id` varchar(32) NOT NULL,\n  `created_by` varchar(32) NOT NULL,\n  `created_date` datetime NOT NULL,\n  `last_modified_by` varchar(32) NOT NULL,\n  `last_modified_date` datetime NOT NULL,\n  `remarks` varchar(255) DEFAULT NULL,\n  `version` int(11) DEFAULT NULL,\n  `locked` bit(1) DEFAULT b'0',\n  `enable` bit(1) DEFAULT b'0',\n  `fd_lottery_record_id` varchar(32) DEFAULT NULL COMMENT '中奖纪录id 作为外键',\n  `fd_status` int(11) DEFAULT NULL COMMENT '红包状态 0:未发放 1：已发放待领取 2：发放失败 3：已领取 4：未领取已退款',\n  `fd_redpack_send_date` datetime DEFAULT NULL COMMENT '红包发送时间(非微信)',\n  `fd_redpack_order_id` varchar(32) DEFAULT NULL COMMENT '微信红包订单单号',\n  `fd_redpack_openid` varchar(32) DEFAULT NULL COMMENT '微信红包订单用户在wxappid下的openid',\n  `fd_redeem_code` varchar(32) DEFAULT NULL COMMENT '兑换码',\n  `fd_redpack_price` decimal(19,4) DEFAULT NULL COMMENT '红包金额',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖红包纪录表';\n\n```\n2、用户得到兑换码之后，就是在微信公众号里输入兑换码，当用户输入兑换码之后，用户信息会发到我们自己服务器后台中, 这里用户触发的是文本事件，我们需要的是三个参数\n\n(1) 用户微信OpenID（用户在本微信公众号的唯一标识）\n\n(2) 用户发的兑换码\n\n(3) HttpServletRequest（用于获取用户ip，发红包接口入参需要）\n\n```java\n            // 文本事件\n            if (WechatBindUtil.MESSAGE_TEXT.equals(msgType)) {\n                String content = map.get(\"Content\").trim();\n                // 如果输入的文本是是以RED开头的, 执行发红包操作\n                if (content.startsWith(\"RED\")) {\n                    String resultContent = lotteryRedpackRecordService.sendRedpackByRedeemCode(fromUserName,content,req);\n                    message = WechatBindUtil.initText(toUserName, fromUserName, resultContent);\n                } else {\n                    message = WechatBindUtil.initText(toUserName, fromUserName, \"欢迎关注本微信公众号\");\n                }\n            }\n```\n3、如果输入的文本是是以RED开头的, 执行发红包操作, 首先是查询红包记录表有没有该兑换码且红包状态为未发放，如果有的话调用微信发红包接口，同时更改红包状态，记录\n红包发送时间，微信红包订单单号，微信红包订单用户在wxappid下的openid，没有的话给出提示，实现如下\n```java\n    /**\n     * 根据兑换码发送微信红包\n     * @param openid\n     * @param redeemCode\n     * @return\n     */\n    public String sendRedpackByRedeemCode (String openid, String redeemCode, HttpServletRequest request) {\n        Page<LotteryRedpackRecord> page = new Page<>(0);\n        page.setParams(\"fdRedeemCode\",redeemCode);\n        List<LotteryRedpackRecord> redpackRecords = findAutoByPage(page);\n        if (redpackRecords.size() != 0) {\n            LotteryRedpackRecord oldRecord = redpackRecords.get(0);\n            // 调用微信红包查询接口, 先更新红包纪录状态\n            updateRedpackState(oldRecord.getId());\n\n            // 更新完成之后获取新的红包纪录\n            LotteryRedpackRecord record = findById(oldRecord.getId());\n            Integer fdStatus = record.getFdStatus();\n            if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.未发放.getIndex())) {\n                RedpackDTO redpackDTO = new RedpackDTO();\n                // 以红包纪录id作为 微信红包接口请求的商品订单号 截取28位\n                String mchBillNo = record.getId();\n                mchBillNo= mchBillNo.substring(0,28);\n                redpackDTO.setMchBillNo(mchBillNo);\n                // 指定哪一个微信用户\n                redpackDTO.setReOpenid(openid);\n                // 红包价格\n                redpackDTO.setTotalAmount(record.getFdRedpackPrice());\n                // 调用接口的机器Ip地址\n                String clientIp = WxUtils.getRemoteIp(request);\n                redpackDTO.setClientIp(clientIp);\n                Map<String,String> sendredpackResult = weixinPayService.sendredpack(redpackDTO);\n\n                // 更新红包纪录表\n                LotteryRedpackRecord lotteryRedpackRecord = findById(record.getId());\n                lotteryRedpackRecord.setFdRedpackOpenid(openid);\n                if (sendredpackResult.get(\"status\").equals(\"success\")) {\n                    lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex());\n                    // 红包订单的微信单号-微信服务器上红包纪录的唯一标识\n                    String redpackOrderId = sendredpackResult.get(\"sendListid\");\n                    lotteryRedpackRecord.setFdRedpackOrderId(redpackOrderId);\n                    lotteryRedpackRecord.setFdRedpackSendDate(new Date());\n\n                    // 更新抽奖纪录表, 变为已兑换\n                    LotteryRecord lotteryRecord = lotteryRecordService.findById(record.getFdLotteryRecordId());\n                    lotteryRecord.setFdStatus(R.LotteryRecordItem.FdStatus.已兑换.getIndex());\n                    lotteryRecordService.saveSelective(lotteryRecord);\n                    saveSelective(lotteryRedpackRecord);\n                } else {\n                    lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex());\n                    lotteryRedpackRecord.setRemarks(sendredpackResult.get(\"message\"));\n                    saveSelective(lotteryRedpackRecord);\n                    return \"红包发送失败, 请及时联系对应的客服!\";\n                }\n            } else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex())) {\n                return \"该兑换码对应的红包已发送! 请注意查收\";\n            } else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex())) {\n                return \"红包发送失败, 请及时联系对应的客服!\";\n            } else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已领取.getIndex())) {\n                return \"该兑换码对应的红包已领取\";\n            } else {\n                return \"该兑换码对应的红包已过时, 请及时联系对应的客服\";\n            }\n        } else {\n            return \"该兑换码无效, 请输入正确的兑换码!\";\n        }\n        return \"红包已发送请注意查收! 注: 24小时后未领取该红包失效\";\n    }\n```\n4、调用微信红包接口\n\n```java\n    /**\n     * 微信公众号发红包接口\n     * @param redpackDTO\n     * @return\n     */\n    public Map<String,String> sendredpack(RedpackDTO redpackDTO) {\n        Map<String,String> resultMap = Maps.newHashMap();\n        Map<String,String> wxResultMap = Maps.newHashMap();\n        // 请求参数\n        Map<String, String> reqData = Maps.newHashMap();\n        logger.info(\"--------------------->>> 开始发送红包start\", redpackDTO);\n        try {\n            // 随机字符串\n            reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr());\n            // 商户订单号\n            reqData.put(\"mch_billno\",redpackDTO.getMchBillNo());\n            // 商户号\n            reqData.put(\"mch_id\", WxPcPayConfigImpl.MCH_ID);\n            // 公众账号appid\n            reqData.put(\"wxappid\", WxPcPayConfigImpl.SENDREDPACK_WX_APPID);\n            // 商户名称\n            reqData.put(\"send_name\", WxPcPayConfigImpl.SENDREDPACK_SEND_NAME);\n            // 用户openid\n            reqData.put(\"re_openid\",redpackDTO.getReOpenid());\n            // 付款金额\n            reqData.put(\"total_amount\", AmountUtils.transAmountToCent(redpackDTO.getTotalAmount()));\n            // 红包发放总人数\n            reqData.put(\"total_num\", WxPcPayConfigImpl.SENDREDPACK_TOTAL_NUM);\n            // 红包祝福语\n            reqData.put(\"wishing\", WxPcPayConfigImpl.SENDREDPACK_WISHING);\n            // Ip地址\n            reqData.put(\"client_ip\", redpackDTO.getClientIp());\n            // 活动名称\n            reqData.put(\"act_name\", WxPcPayConfigImpl.SENDREDPACK_ACT_NAME);\n            //备注\n            reqData.put(\"remark\", WxPcPayConfigImpl.SENDREDPACK_REMARK);\n            // 生成签名\n            reqData.put(\"sign\", WXPayUtil.generateSignature(reqData, WxPcPayConfigImpl.API_KEY, WXPayConstants.SignType.MD5 ));\n            String respXml = wxpay.requestWithCert(WxPcPayConfigImpl.SENDREDPACK_URL,reqData , 10000, 10000);\n            wxResultMap = WXPayUtil.xmlToMap(respXml);\n        } catch (Exception e) {\n            e.printStackTrace();\n            logger.info(\"--------------------->>> 微信公众号发送红包异常\");\n            resultMap.put(\"message\", e.getMessage());\n            resultMap.put(\"status\", \"failed\");\n        }\n        // 通信标识结果\n        String returnCode = wxResultMap.get(\"return_code\");\n        if (\"SUCCESS\".equals(returnCode)) {\n            String resultCode = wxResultMap.get(\"result_code\");\n            // 业务处理结果\n            if (\"SUCCESS\".equals(resultCode)) {\n                logger.info(\"--------------------->>> 微信公众号发送红包成功\");\n                // 红包订单的微信单号\n                String sendListid = wxResultMap.get(\"send_listid\");\n                resultMap.put(\"sendListid\",sendListid);\n                resultMap.put(\"message\",\"操作成功\");\n                resultMap.put(\"status\", \"success\");\n            } else {\n                logger.info(\"--------------------->>> 微信公众号发送红包失败, 原因: \" + wxResultMap.get(\"err_code_des\"));\n                String errCodeDes = wxResultMap.get(\"err_code_des\");\n                resultMap.put(\"message\",errCodeDes);\n                resultMap.put(\"status\", \"failed\");\n                return resultMap;\n            }\n        } else {\n            String returnMsg = wxResultMap.get(\"return_msg\");\n            logger.info(\"--------------------->>> 微信公众号发送红包失败, 原因: \" + returnMsg);\n            resultMap.put(\"message\", returnMsg);\n            resultMap.put(\"status\", \"failed\");\n            return resultMap;\n        }\n        return resultMap;\n    }\n```\n\n### 总结及注意事项\n1.红包是以分为单位，必须大于100分，小于20000分之间，这个很重要,不要一不小心把公司的钱都转出去了\n\n2.需要对请求参数进行加签操作，wxpay里面封装了方法\n\n3.现金红包接口请求是需要证书的，因为是出账，不像充值是属于进账不用证书， 需要调用`requestWithCert` 这个请求接口\n\n```java\n    /**\n     * 需要证书的请求\n     * @param strUrl String\n     * @param reqData 向wxpay post的请求数据  Map\n     * @param connectTimeoutMs 超时时间，单位是毫秒\n     * @param readTimeoutMs 超时时间，单位是毫秒\n     * @return API返回数据\n     * @throws Exception\n     */\n    public String requestWithCert(String strUrl, Map<String, String> reqData,\n                                  int connectTimeoutMs, int readTimeoutMs) throws Exception {\n```\n4.由于红包发出去了不知道用户有没有领取，所以可以用一个定时任务或者一个按钮调用微信红包状态查询接口，以更新红包的最新状态\n\n5.可以借助第三方平台，如摇摇啦应用平台，借助这些平台可以不用开发接口，只要配置好参数就可以使用了，但唯一的缺点是要钱\n","tags":["支付"],"categories":["server"]},{"title":"Docelver接口管理平台","url":"/2018/04/03/Web后台/测试/Docelver接口管理平台/","content":"#### 前言 \n在项目开发过程中，开发一个功能模块，需要前后端开发进行接口定义并形成文档，如果使用doc这些文档去维护接口，多会出现纰漏，特别是在多人开发的项目中，缺点尤为明显，所以需要一个像代码版本控制（git svn）类型的平台去维护这些文档，方便开发人员进行接口维护，前后端开发人员联调接口，测试人员编写测试用例\n\n#### 市场上常用的接口管理平台\n\n##### 1. Rap 阿里出品\n官网地址：  http://rapapi.org/org/index.do\n\n官网介绍：\n\nRAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效率。我们的口号：提高效率，回家吃晚饭！\n\n使用体验：\n1. RAP的应用范围非常明确，是一个面向开发人员自测和联调的工具性平台，它更适合以开发为核心对接口进行维护\n\n##### 2. DOClever\n官网地址： http://www.doclever.cn/controller/index/index.html\n\n可以对接口信息进行编辑管理，支持get,post,put,delete,patch 五种方法，支持 https 和 https 协议，并且支持 query，body，json，raw，rest，formdata 的参数可视化编辑。同时对 json 可以进行无限层次可视化编辑。并且，状态码，代码注入，markdown 文档等附加功能应有尽有。\n\n\n \n\n接口调试运行，可以对参数进行加密，从md5 到 aes 一应俱全，返回参数与模型实时分析对比，给出不一致的地方，找出接口可能出现的问题。如果你不想手写文档，那么试试接口的数据生成功能，可以对接口运行的数据一键生成文档信息。\n\n \n\nmock 的无缝整合，DOClever 自己就是一个 mock 服务器，当你把接口的开发状态设置成已完成，本地 mock 便会自动请求真实接口数据，否则返回事先定义好的 mock 数据。\n\n \n\n支持 postman，rap，swagger 的导入，方便你做无缝迁移，同时也支持 html 文件的导出，方便你离线浏览！\n\n \n\n项目版本和接口快照功能并行，你可以为一个项目定义 1.0，1.1，1.2 版本，并且可以自由的在不同版本间切换回滚，再也不怕接口信息的遗失，同时接口也有快照功能，当你接口开发到一半或者接口需求变更的时候，可以随时查看之前编辑的接口信息。\n\n \n\n自动化测试功能，目前市面上类似平台的接口自动化测试大部分都是伪自动化，对于一个复杂的场景，比如获取验证码，登陆，获取订单列表，获取某个特定订单详情这样一个上下文关联的一系列操作无能为力。而 DOClever 独创的自动化测试功能，只需要你编写极少量的 javascript 代码便可以在网页里完成这样一系列操作，同时，DOClever 还提供了后台定时批量执行测试用例并把结果发送到团队成员邮箱的功能，你可以及时获取接口的运行状态。\n\n \n\n团队协作功能，很多类似的平台这样的功能是收费的，但是 DOClever 觉得好东西需要共享出来，你可以新建一个团队，并且把团队内的成员都拉进来，给他们分组，给他们分配相关的项目以及权限，发布团队公告等等。\n\n \n\nDOClever 开源免费，支持内网部署，很多公司考虑到数据的安全性，不愿意把接口放到公网上，没有关系，DOClever 给出一个方便快捷的解决方案，你可以把平台放到自己的内网上，完全不需要连接外网，同时功能一样也不少，即便是对于产品的升级，DOClever 也提供了很便捷的升级方案！\n","tags":["测试"],"categories":["server"]},{"title":"Windows批处理(cmd/bat)常用命令","url":"/2018/03/24/Web后台/windows bat/","content":"#### 需求\n在使用hexo写博客的时候, hexo d 老是不能把代码push上去，网上找了好多方法都不能解决, 只能自己手动把`public`文件下生成的文件自己敲git命令push上传, 每次写博客的时候都要执行这种操作, 次数多了会感觉厌烦, 所有想windows不是有批处理脚本吗, 所以自己查阅了一些资料, 写了一个草鸡简单的脚本\n\n* auto.bat\n```sql\n# 文件上传commit\ngit add -A\n\ngit commit -m \"auto commit\"\n\ngit push\n\necho copy file\nxcopy D:\\workspace\\hexo-log-bak\\hexo-log-bak\\public\\*.* D:\\workspace\\hexo-log-upload\\songshuiyang.github.io /s /y\n\necho 提交songshuiyang.github.io 文件\ncd ../../hexo-log-upload\\songshuiyang.github.io\n\ngit add -A\n\ngit commit -m \"auto commit\"\n\ngit push\n\ncd ../../hexo-log-bak/hexo-log-bak\n\n```\n<!--more-->\n#### 批处理文件\n批处理文件（batch file）包含一系列 DOS命令，通常用于自动执行重复性任务。用户只需双击批处理文件便可执行任务，而无需重复输入相同指令。编写批处理文件非常简单，但难点在于确保一切按顺序执行。编写严谨的批处理文件可以极大程度地节省时间，在应对重复性工作时尤其有效。\n\n在Windows中善用批处理可以简化很多重复工作\n\n##### 常用DOS命令\n```sql\n文件夹管理\n\n    cd 显示当前目录名或改变当前目录。\n    md 创建目录。\n    rd 删除一个目录。\n    dir 显示目录中的文件和子目录列表。\n    tree 以图形显示驱动器或路径的文件夹结构。\n    path 为可执行文件显示或设置一个搜索路径。\n    xcopy 复制文件和目录树。\n\n\n文件管理\n\n    type 显示文本文件的内容。\n    copy 将一份或多份文件复制到另一个位置。\n    del 删除一个或数个文件。\n    move 移动文件并重命名文件和目录。(Windows XP Home Edition中没有)\n    ren 重命名文件。\n    replace 替换文件。\n    attrib 显示或更改文件属性。\n    find 搜索字符串。\n    fc 比较两个文件或两个文件集并显示它们之间的不同\n网络命令\n\n    ping 进行网络连接测试、名称解析\n    ftp 文件传输\n    net 网络命令集及用户管理\n    telnet 远程登陆\n    ipconfig显示、修改TCP/IP设置\n    msg 给用户发送消息\n    arp 显示、修改局域网的IP地址-物理地址映射列表\n    \n系统管理\n\n    at 安排在特定日期和时间运行命令和程序\n    shutdown立即或定时关机或重启\n    tskill 结束进程\n    taskkill结束进程(比tskill高级，但WinXPHome版中无该命令)\n    tasklist显示进程列表(Windows XP Home Edition中没有)\n    sc 系统服务设置与控制\n    reg 注册表控制台工具\n    powercfg控制系统上的电源设置\n```\n\n##### 例子\n","tags":["java"],"categories":["server"]},{"title":"Spring 集成Encache","url":"/2018/03/24/Web后台/缓存技术/Encache/","content":"### 一：Encache\n\n#### 1. 什么是Encache\nEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。\n\n官网: http://www.ehcache.org/\n\n#### 2. 基本介绍\nEhcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。\n\nEhcache最初是由Greg Luck于2003年开始开发。2009年,该项目被Terracotta购买。软件仍然是开源,但一些新的主要功能(例如，快速可重启性之间的一致性的)只能在商业产品中使用，例如Enterprise EHCache and BigMemory。维基媒体Foundationannounced目前使用的就是Ehcache技术。\n\n<!--more-->\n#### 3. 特点\n主要的特性有：\n1. 快速\n2. 简单\n3. 多种缓存策略\n4. 缓存数据有两级：内存和磁盘，因此无需担心容量问题\n5. 缓存数据会在虚拟机重启的过程中写入磁盘\n6. 可以通过RMI、可插入API等方式进行分布式缓存\n7. 具有缓存和缓存管理器的侦听接口\n8. 支持多缓存管理器实例，以及一个实例的多个缓存区域\n9. 提供Hibernate的缓存实现\n\n\n#### ehcache与redis的区别\n1.redis的数据结构比较丰富，有key-value、hash、set等；ehcache比较简单，只有key-value\n\n2.ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。redis是通过socket访问到缓存服务，效率ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。\n\n### 二: Encache与Spring 集成\n#### 1. 前言\nSpring自身并没有实现缓存解决方案，但是对缓存管理功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。\n\nSpring Cache是作用在方法上的（不能理解为只注解在方法上），其核心思想是：当我们在调用一个缓存方法时会把该方法参数和返回结果作为一个键值存放在缓存中，等到下次利用同样的参数调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。所以在使用Spring Cache的时候我们要保证我们的缓存的方法对于相同的方法参数要有相同的返回结果。\n\n#### 2. 开始集成\n* 导入依赖\n```xml\n        <dependency>\n            <groupId>net.sf.ehcache</groupId>\n            <artifactId>ehcache</artifactId>\n            <version>2.10.3</version>\n        </dependency>\n```\n* 编写ehcache.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\">\n\n    <!-- 磁盘缓存位置 在Windows的缓存目录为：C:\\Users\\登录用户~1\\AppData\\Local\\Temp\\    Linux：/tmp -->\n    <diskStore path=\"java.io.tmpdir/ehcache\"/>\n\n    <!--name：缓存名称。-->\n    <!--maxElementsInMemory：缓存最大个数。-->\n    <!--eternal：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。-->\n    <!--timeToIdleSeconds：置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。-->\n    <!--timeToLiveSeconds：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。-->\n    <!--maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。-->\n    <!--overflowToDisk：内存不足时，是否启用磁盘缓存。-->\n    <!--diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。-->\n    <!--maxElementsOnDisk：硬盘最大缓存个数。-->\n    <!--diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。-->\n    <!--diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。-->\n    <!--memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。-->\n    <!--clearOnFlush：内存数量最大时是否清除。-->\n\n    <!--@Cacheable(value = \"users\", condition = \"#user.getId() <= 2\")-->\n    <!--@CachePut(value = \"users\", key = \"#user.getId()\")-->\n    <!--@CacheEvict(value = \"users\", allEntries = true)-->\n\n\n    <!-- 默认缓存 -->\n    <defaultCache\n            maxEntriesLocalHeap=\"10000\"\n            eternal=\"false\"\n            timeToIdleSeconds=\"120\"\n            timeToLiveSeconds=\"120\"\n            maxEntriesLocalDisk=\"10000000\"\n            diskExpiryThreadIntervalSeconds=\"120\"\n            memoryStoreEvictionPolicy=\"LRU\">\n        <persistence strategy=\"localTempSwap\"/>\n    </defaultCache>\n\n    <!-- 博客文章详情缓存 -->\n    <cache name=\"articlesDetail\"\n           maxElementsInMemory=\"1000\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"120\"\n           timeToLiveSeconds=\"120\"\n           overflowToDisk=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\"/>\n\n    <!-- hotArticles缓存 -->\n    <cache name=\"articlesDetail\"\n           maxElementsInMemory=\"1000\"\n           eternal=\"true\"\n           overflowToDisk=\"false\"\n           memoryStoreEvictionPolicy=\"LRU\"/>\n\n</ehcache>\n```\n* 在需要缓存的地方加上缓存注解\n```java\n    /**\n     * 第一次执行会缓存文章,以id作为key, 第二次会直接取缓存的数据(需要在缓存有效期,过期会重新查询数据库)\n     * @param id\n     * @return\n     */\n    @Override\n    @Cacheable(value = \"articlesDetail\", key = \"#id\")\n    public BlogArticles selectByPrimaryKey(Integer id) {\n        return getMappser().selectByPrimaryKey(id);\n    }\n\n    /**\n     * 保存文章，同时删除record.getId()该已存的缓存数据\n     * @param record\n     * @return\n     */\n    @Override\n    @CacheEvict(value = \"articlesDetail\", key = \"#record.getId()\")\n    public int updateByPrimaryKeySelective(BlogArticles record) {\n        setCurrentOperator(record);\n        return getMappser().updateByPrimaryKeySelective(record);\n    }\n```\n#### 3. 注解讲解\n首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。\n* @Cacheable\n\n```sql\n表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 \n这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 \n可以使用key属性来指定key的生成规则。\n\n@Cacheable 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中\n  key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId，\n\n  一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， \n  本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等\n\n  condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL\n  \n  \n  // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1'\n  @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\")    \n  public User findById(String userId) {    \n      return (User) new User(\"1\", \"mengdee\");           \n  }    \n  \n  // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key\n  // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\"\n  @Cacheable(value=\"UserCache\", condition=\"#userId.length() < 12\")    \n  public boolean isReserved(String userId) {    \n      System.out.println(\"UserCache:\"+userId);    \n      return false;    \n  }\n```\n* @CachePut\n\n```sql\n与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。\n```\n\n* @CacheEvict\n```sql\n与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。\n\n@CacheEvict 支持如下几个参数：\n\n  value：缓存位置名称，不能为空，同上\n  key：缓存的key，默认为空，同上\n  condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL\n  allEntries：true表示清除value中的全部缓存，默认为false\n\n  //清除掉UserCache中某个指定key的缓存    \n  @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\")    \n  public void removeUser(User user) {    \n      System.out.println(\"UserCache\"+user.getUserId());    \n  }    \n  \n  //清除掉UserCache中全部的缓存    \n  @CacheEvict(value=\"UserCache\", allEntries=true)    \n  public final void setReservedUsers(String[] reservedUsers) {    \n     System.out.println(\"UserCache deleteall\");    \n  }\n  \n  \n```\n* @Caching\n```sql\n如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。\n\n@Caching(evict = { @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") })\npublic Book importBooks(String deposit, Date date)\n\n```\n* @CacheConfig\n```sql\n与前面的缓存注解不同，这是一个类级别的注解。\n 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。\n\n@CacheConfig(\"books\")\npublic class BookRepositoryImpl implements BookRepository {\n    @Cacheable\n    public Book findBook(ISBN isbn) {...}\n}\n\n```\n\n#### 4. 创建Cache工具类, 方便对cache进行管理\n``` java\npackage com.ecut.core.utils;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.Cache;\nimport org.springframework.cache.CacheManager;\n\n/**\n * 缓存工具类\n * @author songshuiyang\n * @date 2018/3/24 12:16\n */\npublic class CacheUtils {\n\n    private final static Logger logger = LoggerFactory.getLogger(CacheUtils.class);\n\n    private static CacheManager cacheManager = (CacheManager) SpringContextUtils.getBean(\"cacheManager\");\n\n    /**\n     * 获取缓存\n     * @param cacheName 缓存名\n     * @param key 键\n     * @return Object\n     */\n    public static Object get(String cacheName, Object key) {\n        Cache cache = cacheManager.getCache(cacheName);\n        if (cache != null) {\n            //这里需要判断是否null\n            if(cache.get(key) != null){\n                return cache.get(key).get();\n            }\n        }\n        return null;\n    }\n    /**\n     * 添加缓存\n     * 存在则更新\n     * @param cacheName 缓存名\n     * @param key 键\n     * @param value 值\n     */\n    public static void put(String cacheName, Object key, Object value) {\n        Cache cache = cacheManager.getCache(cacheName);\n        if(cache != null){\n            cache.put(key, value);\n        }\n    }\n    /**\n     * 清除缓存\n     * @param cacheName 缓存名\n     * @param key 键\n     */\n    public static void remove(String cacheName, Object key) {\n        Cache cache = cacheManager.getCache(cacheName);\n        if (cache != null) {\n            cache.evict(key);\n        }else{\n            logger.warn(\"this key is not in Cache\");\n        }\n    }\n}\n\n}\n\n```\n\n参考： \nhttps://blog.csdn.net/vbirdbest/article/details/72763048\nhttp://www.cnblogs.com/jingmoxukong/p/5975994.html","tags":["java"],"categories":["server"]},{"title":"hover.css","url":"/2018/03/20/Web前端/hover/","content":"### Hover.css\nA collection of CSS3 powered hover effects to be applied to links, buttons, logos, SVG, featured images and so on. Easily apply to your own elements, modify or just use for inspiration. Available in CSS, Sass, and LESS.\n\n官网地址: http://ianlunn.github.io/Hover/\n\n演示地址: http://wow.techbrood.com/fiddle/852\n\n\n\n\n\n","tags":["css"],"categories":["client"]},{"title":"Linux 命令笔记","url":"/2018/03/08/Web后台/Linux/linux笔记/","content":"1. 出现问题 `bash: service: command not found`, \n\n解决方法：\n```sql\nyum install initscripts\n```\n2. 查看端口\n```sql\n# 查看80端口占用情况\nlsof -i tcp:80\n\n# 列出所有端口\nnetstat -ntlp\n\n# 查看端口状态\nnetstat -lnp|grep 88   #88请换为你的apache需要的端口，如：80\n\n# SSH执行以上命令，可以查看到88端口正在被哪个进程使用。如下图，进程号为 1777 。\n\n# 查看进程的详细信息\nps 1777\n\n# 杀掉进程\nkill -9 1777        #杀掉编号为1777的进程（请根据实际情况输入）\n```","tags":["server"],"categories":["服务器"]},{"title":"Docker笔记","url":"/2018/03/08/Web后台/Linux/Docker笔记/","content":"#### 什么是Docker\nDocker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了。作为一名 Java 程序员，我们是时候一起把 Docker 学起来了！\n\n1.传统虚拟化技术的体系架构：\n\n![logo](/images/server/docker/virtual mechine.png) \n\n可见，我们在宿主机的操作系统上，可安装了多个虚拟机，而在每个虚拟机中，通过虚拟化技术，实现了一个虚拟操作系统，随后，就可以在该虚拟操作系统上，安装自己所需的应用程序了。这一切看似非常简单，但其中的技术细节是相当高深莫测的，大神级人物都不一定说得清楚。\n<!--more-->\n\n凡是使用过虚拟机的同学，应该都知道，启动虚拟机就像启动一台计算机，初始化过程是相当慢的，我们需要等很久，才能看到登录界面。一旦虚拟机启动以后，就可以与宿主机建立网络连接，确保虚拟机与宿主机之间是互联互通的。不同的虚拟机之间却是相互隔离的，也就是说，彼此并不知道对方的存在，但每个虚拟机占用的都是宿主机的硬件与网络资源。\n\n2.Docker 技术的体系架构\n\n![logo](/images/server/docker/virtual mechine.png) \n\n可见，在宿主机的操作系统上，有一个 Docker 服务在运行（或者称为“Docker 引擎”），在此服务上，我们可开启多个 Docker 容器，而每个 Docker 容器中可运行自己所需的应用程序，Docker 容器之间也是相互隔离的，同样地，都是占用的宿主机的硬件与网络资源。、\n\nDocker 容器相对于虚拟机而言，除了在技术实现上完全不一样以外，启动速度较虚拟机而言有本质的飞跃，启动一个容器只在眨眼瞬间。不管是虚拟机还是 Docker 容器，它们都是为了隔离应用程序的运行环境，节省我们的硬件资源，为我们开发人员提供福利。\n\n\n3.Docker 的 Logo:\n\n![logo](/images/server/docker/docker logo.png) \n\n很明显，这是一只鲸鱼，它托着许多集装箱。我们可以把宿主机可当做这只鲸鱼，把相互隔离的容器可看成集装箱，每个集装箱中都包含自己的应用程序。这 Logo 简直的太形象了！\n\n4.Docker的应用场景\n```sql\n1. Web 应用的自动化打包和发布。\n\n2. 自动化测试和持续集成、发布。\n\n3. 在服务型环境中部署和调整数据库或其他的后台应用。\n```\n5.Docker 的优点\n```sql\n1、简化程序：\nDocker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的\t任务，在Docker容器的处理下，只需要数秒就能完成。\n\n2、避免选择恐惧症：\n如果你有选择恐惧症，还是资深患者。Docker 帮你\t打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。\n\n3、节省开支：\n一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。\n```\n#### Docker 术语\n\n   |     术语 | 说明    | \n    | --------   | --------------------:   | \n    |  Docker 镜像(Images)       | Docker 镜像是用于创建 Docker 容器的模板。 |\n    |  Docker 容器(Container)        | 容器是独立运行的一个或一组应用。     |\n    |  Docker 客户端(Client)     | Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 |\n    |  Docker 主机(Host)      |一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。     |\n    |  Docker 仓库(Registry) |      Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。|\n    |  Docker Machine       | Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。      |\n\n\n#### 使用Docker前先配置 Docker国内镜像或者使用registry-mirrors配置加速\n\n由于国内访问直接访问Docker hub网速比较慢，拉取镜像的时间就会比较长。一般我们会使用镜像加速或者直接从国内的一些平台镜像仓库上拉取。 \n\n```sql\n方法一： 网易镜像中心：https://c.163.com/hub#/m/home/ \n\n拉取镜像的命令是： docker pull 镜像名字 所以我们可以按照给出的镜像名字或者命令直接拉取。\n\neg: docker pull hub.c.163.com/library/tomcat:latest\n\n\n方法二： daocloud镜像市场：https://hub.daocloud.io/\n\n如果说还是想从dockerhub上拉取，那么使用加速器修改docker的registry-mirrors。这里使用的是DaoCloud的加速器。 \n\n首先在http://www.daocloud.io/进行注册登录。然后点击加速器，得到如下脚本\n\n    curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://24524c4f.m.daocloud.io Copy\n    该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。\n \n也可以自己手动修改 /etc/docker/daemon.json\n\n{\n \"registry-mirrors\": [\"http://ef017c13.m.daocloud.io\"],\n \"live-restore\": true\n}\n\n最后重启docker service docker restart\n```\n#### 安装 Docker\n1.前提条件\n```sql\n使用 yum 安装（CentOS 7下）\n\nDocker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n通过 uname -r 命令查看你当前的内核版本\n\n```\n2.安装\n```sql\nyum -y install docker\n```\n3.启动服务\n```sql\nservice docker start\n```\n4.测试运行 hello-world\n```sql\ndocker run hello-world\n```\n\n#### Docker中使用CentOS7镜像\n1.启动容器服务\n```genericsql\nsystemctl start docker.service \n```\n2.下载CentOS7 镜像\n```genericsql\n[root@JD docker]# docker pull centos:7.3.1611\nTrying to pull repository docker.io/library/centos ... \n7.3.1611: Pulling from docker.io/library/centos\n\n版本: https://hub.docker.com/_/centos/ 可以在这个网站上选择自己想要的版本\n  latest, centos7, 7 (docker/Dockerfile)\n  centos6, 6 (docker/Dockerfile)\n  centos7.4.1708, 7.4.1708 (docker/Dockerfile)\n  centos7.3.1611, 7.3.1611 (docker/Dockerfile)\n  centos7.2.1511, 7.2.1511 (docker/Dockerfile)\n  centos7.1.1503, 7.1.1503 (docker/Dockerfile)\n  centos7.0.1406, 7.0.1406 (docker/Dockerfile)\n  centos6.9, 6.9 (docker/Dockerfile)\n  centos6.8, 6.8 (docker/Dockerfile)\n  centos6.7, 6.7 (docker/Dockerfile)\n  centos6.6, 6.6 (docker/Dockerfile)\n```\n3.下载成功之后查看本地所有的镜像，得到centos的 IMAGE ID: 66ee80d59a68\n```sql\n[root@JD ~]# docker images\nREPOSITORY              TAG                 IMAGE ID            CREATED             SIZE\ndocker.io/tomcat        latest              108db0e7c85e        2 weeks ago         557.4 MB\ndocker.io/hello-world   latest              f2a91732366c        3 months ago        1.848 kB\ndocker.io/centos        7.3.1611            66ee80d59a68        4 months ago        191.8 MB\n```\n\n4.启动docker中的CentOS7\n```sql\ndocker run -ti 66ee /bin/bash\n#6866 是 IMAGE ID 前四位数字-能区分出是哪个image即可\n\nroot@b4ad1d1c87da /]# \n#登录成功，接下来就可以为所欲为啦。\n\n命令笔记\n  容器是在镜像的基础上来运行的，一旦容器启动了，我们就可以登录到容器中，安装自己所需的软件或应用程序。既然镜像已经下载到本地，那么如何才能启动容器呢\n  \n  docker run -i -t -v /root/software/:/mnt/software/ 25c5298b1a36 /bin/bash\n\n  docker run <相关参数> <镜像 ID> <初始命令>\n\n    -i：表示以“交互模式”运行容器\n    -t：表示容器启动后会进入其命令行\n    -v：表示需要将本地哪个目录挂载到容器中，格式：-v <宿主机目录>:<容器目录>\n    假设我们的所有安装程序都放在了宿主机的/root/software/目录下，现在需要将其挂载到容器的/mnt/software/目录下。\n    \n  初始命令表示一旦容器启动，需要运行的命令，此时使用“/bin/bash”，表示什么也不做，只需进入命令行即可。\n\n\n\n```\n5.检查CentOS7系统\n```sql\nroot@b4ad1d1c87da  /]# uname -a\nLinux b4ad1d1c87da 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux\n[root@b4ad1d1c87da /]# cat /etc/redhat-release \nCentOS Linux release 7.2.1511 (Core)\n```\n6.退出\n```sql\n  ctrl+d 退出容器且关闭, \n  docker ps 查看无,\n  ctrl+p+q 退出容器但不关闭, \n  docker ps\n```\n \n7.再进入CentOS7\n```sql\n[root@wxtest1607 ~]# docker ps -a\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nb4ad1d1c87da        6866                \"/bin/bash\"         12 seconds ago      Up 9 seconds                            mad_swanson\n                  drunk_hypatia\n得到 CONTAINER ID         \n[root@wxtest1607 ~]# docker exec -ti b4ad /bin/bash  \n[root@b4ad1d1c87da /]#\n\n```\n8.安装tomcat \n```sql\n 1. yum -y install tomcat\n \n 注：\n        在docker中通过systemctl 启动服务的时候总是报Failed to get D-Bus connection: Operation not permitted 这样的错误提示。\n     解决方法：\n        解决办法就是在docker run 的时候运行/usr/sbin/init 。比如：\n        docker run -ti 66ee /usr/sbin/init\n 2. 在Centos使用yum安装后，Tomcat相关的目录都已采用符号链接到/usr/share/tomcat6目录，包含webapps等，这很方便我们配置管理\n```\n\n转载：http://www.runoob.com/docker/docker-tutorial.html\n\n转载：http://developer.51cto.com/art/201702/529956.htm\n\n转载：http://www.jb51.net/article/112921.htm\n\n转载：https://www.jianshu.com/p/0aa535e681f5","tags":["server"],"categories":["服务器"]},{"title":"mysql 用户及权限管理","url":"/2018/03/07/Web后台/数据库/mysql 用户及权限管理/","content":"### 权限控制\n授权语法：\n```sql\n    GRANT privileges (columns) ON what TO user IDENTIFIED BY \"password\" WITH GRANT OPTION\n    \n    权限列表:\n    ALTER: 修改表和索引。\n    CREATE: 创建数据库和表。\n    DELETE: 删除表中已有的记录。\n    DROP: 抛弃(删除)数据库和表。\n    INDEX: 创建或抛弃索引。\n    INSERT: 向表中插入新行。\n    REFERENCE: 未用。\n    SELECT: 检索表中的记录。\n    UPDATE: 修改现存表记录。\n    FILE: 读或写服务器上的文件。\n    PROCESS: 查看服务器中执行的线程信息或杀死线程。\n    RELOAD: 重载授权表或清空日志、主机缓存或表缓存。\n    SHUTDOWN: 关闭服务器。\n    ALL: 所有权限，ALL PRIVILEGES同义词。\n    USAGE: 特殊的 \"无权限\" 权限。\n    用 户账户包括 \"username\" 和 \"host\" 两部分，后者表示该用户被允许从何地接入。tom@'%' 表示任何地址，默认可以省略。还可以是 \"tom@192.168.1.%\"、\"tom@%.abc.com\" 等。数据库格式为 db@table，可以是 \"test.*\" 或 \"*.*\"，前者表示 test 数据库的所有表，后者表示所有数据库的所有表。\n    子句 \"WITH GRANT OPTION\" 表示该用户可以为其他用户分配权限。 \n```\n<!--more-->\n实例：\n\n```sql\n  use mysql\n\n  1. 新建用户, 并赋予所有数据库权限\n    GRANT ALL PRIVILEGES ON *.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION;\n  \n    说明:\n      1. username - 你将创建的用户名, host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.\n      2. 指定helloworld数据库: GRANT ALL PRIVILEGES ON helloword.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION;\n  \n  2. 指定该用户只能执行 select 和 update 命令\n    GRANT SELECT, UPDATE ON *.* TO 'username'@'%' IDENTIFIED BY 'password';\n  \n  3. 另外每当调整权限后，通常需要执行以下语句刷新权限：\n    FLUSH PRIVILEGES;\n\n  4. grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。\n    grant select on testdb.* to common_user@’%’\n    grant insert on testdb.* to common_user@’%’\n    grant update on testdb.* to common_user@’%’\n    grant delete on testdb.* to common_user@’%’\n    或者，用一条 MySQL 命令来替代：\n    grant select, insert, update, delete on testdb.* to common_user@’%’\n```\n\n### 用户\n```sql\n  1. 删除刚才创建的用户：\n    DROP USER username@localhost;\n  \n  2. 查看用户创建是否成功\n    select user,host from user ;\n    \n    +-----------+-----------+\n    | user      | host      |\n    +-----------+-----------+\n    | root      | %         |\n    | select    | %         |\n    | server    | %         |\n    | shuiyang  | %         |\n    | user      | %         |\n    | mysql.sys | localhost |\n    +-----------+-----------+\n    \n  3. 查看select用户的授权\n   show grants for select;\n   \n   MySQL [mysql]>  show grants for `select`;\n   +---------------------------------------------+\n   | Grants for select@%                         |\n   +---------------------------------------------+\n   | GRANT SELECT, UPDATE ON *.* TO 'select'@'%' |\n   +---------------------------------------------+\n   1 row in set (0.00 sec)\n   \n  4. 设置与更改用户密码\n  \n  SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword')\n  \n  如果是当前登陆用户用\n  \n  SET PASSWORD = PASSWORD(\"newpassword\");\n  \n```\n  \n  ","tags":["mysql"],"categories":["server"]},{"title":"Centos7安装Mysql5.7.md","url":"/2018/03/07/Web后台/Linux/Centos7安装Mysql5.7/","content":"#### 一：配置YUM源\n>官网地址 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/\n\n1.下载mysql源安装包\n```sql\nwget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm\n```\n 命令笔记:\n```sql\nwget:\n用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用\n\n-a<日志文件>：在指定的日志文件中记录资料的执行过程；\n-A<后缀名>：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；\n-b：进行后台的方式运行wget；\n-B<连接地址>：设置参考的连接地址的基地地址；\n-c：继续执行上次终端的任务；\n-C<标志>：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；\n-d：调试模式运行指令；\n-D<域名列表>：设置顺着的域名列表，域名之间用“，”分隔；\n-e<指令>：作为文件“.wgetrc”中的一部分执行指定的指令；\n-h：显示指令帮助信息；\n-i<文件>：从指定文件获取要下载的URL地址；\n-l<目录列表>：设置顺着的目录列表，多个目录用“，”分隔；\n-L：仅顺着关联的连接；\n-r：递归下载方式；\n-nc：文件存在时，下载文件不覆盖原有文件；\n-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；\n-q：不显示指令执行过程；\n-nh：不查询主机名称；\n-v：显示详细执行过程；\n-V：显示版本信息；\n--passive-ftp：使用被动模式PASV连接FTP服务器；\n--follow-ftp：从HTML文件中下载FTP连接文件\n\n下载并以不同的文件名保存:\nwget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080\n\n```\n<!--more-->\n\n2.安装mysql源\n```sql\nyum localinstall mysql57-community-release-el7-8.noarch.rpm\n```\n\n 命令笔记:\n```sql\nyum命令\n\n是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。\n\n选项:\n-h：显示帮助信息；\n-y：对所有的提问都回答“yes”；\n-c：指定配置文件；\n-q：安静模式；\n-v：详细模式；\n-d：设置调试等级（0-10）；\n-e：设置错误等级（0-10）；\n-R：设置yum处理一个命令的最大等待时间；\n-C：完全从缓存中运行，而不去下载或者更新任何头文件。\n\n参数：\ninstall：安装rpm软件包；\nupdate：更新rpm软件包；\ncheck-update：检查是否有可用的更新rpm软件包；\nremove：删除指定的rpm软件包；\nlist：显示软件包的信息；\nsearch：检查软件包的信息；\ninfo：显示指定的rpm软件包的描述信息和概要信息；\nclean：清理yum过期的缓存；\nshell：进入yum的shell提示符；\nresolvedep：显示rpm软件包的依赖关系；\nlocalinstall：安装本地的rpm软件包；\nlocalupdate：显示本地rpm软件包进行更新；\ndeplist：显示rpm软件包的所有依赖关系。\n\n\n实例\n部分常用的命令包括：\n\n自动搜索最快镜像插件：yum install yum-fastestmirror\n安装yum图形窗口插件：yum install yumex\n查看可能批量安装的列表：yum grouplist\n```\n3.检查mysql源是否安装成功\n```sql\nyum repolist enabled | grep \"mysql.*-community.*\"\n```\n![logo](/images/server/linux/mysql_install_success.png) \n\n看到上图所示表示mysql源安装成功。\n\n可以修改vim /etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。比如要安装5.6版本，将5.7源的enabled=1改成enabled=0。然后再将5.6源的enabled=0改成enabled=1即可 \n\n#### 二 安装MySQL\n```sql\n yum install mysql-community-server\n```\n命令笔记:\n```sql\n安装\n\nyum install              #全部安装\nyum install package1     #安装指定的安装包package1\nyum groupinsall group1   #安装程序组group1\n\n更新和升级\n\nyum update               #全部更新\nyum update package1      #更新指定程序包package1\nyum check-update         #检查可更新的程序\nyum upgrade package1     #升级指定程序包package1\nyum groupupdate group1   #升级程序组group1\n\n\n查找和显示\n\nyum info package1      #显示安装包信息package1\nyum list               #显示所有已经安装和可以安装的程序包\nyum list package1      #显示指定程序包安装情况package1\nyum groupinfo group1   #显示程序组group1信息yum search string 根据关键字string查找安装包\n\n删除程序\n\nyum remove &#124; erase package1   #删除程序包package1\nyum groupremove group1             #删除程序组group1\nyum deplist package1               #查看程序package1依赖情况\n```\n\n#### 三：启动MySQL服务\n1.启动\n```sql\n systemctl start mysqld\n```\n命令笔记：\n```sql\nsystemctl\n\n是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。\n\n任务\t                旧指令\t                        新指令\n使某服务自动启动\t    chkconfig --level 3 httpd on\tsystemctl enable httpd.service\n使某服务不自动启动\tchkconfig --level 3 httpd off\tsystemctl disable httpd.service\n检查服务状态\t        service httpd status\t        systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active)\n显示所有已启动的服务\tchkconfig --list\t            systemctl list-units --type=service\n启动某服务\t        service httpd start\t            systemctl start httpd.service\n停止某服务\t        service httpd stop\t            systemctl stop httpd.service\n重启某服务\t        service httpd restart\t        systemctl restart httpd.service\n\n```\n2.查看状态\n```sql\n查看MySQL的启动状态\nsystemctl status mysqld\n\n输出：\n● mysqld.service - MySQL Server\n   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)\n   Active: active (running) since Wed 2018-03-07 21:14:55 CST; 18min ago\n     Docs: man:mysqld(8)\n           http://dev.mysql.com/doc/refman/en/using-systemd.html\n  Process: 17338 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)\n  Process: 17320 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)\n Main PID: 17343 (mysqld)\n   CGroup: /system.slice/mysqld.service\n           └─17343 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid\n\nMar 07 21:14:54 VM_0_8_centos systemd[1]: Starting MySQL Server...\nMar 07 21:14:55 VM_0_8_centos systemd[1]: Started MySQL Server.\n\n```\n3.开机启动\n```sql\nsystemctl enable mysqld\nsystemctl daemon-reload\n```\n4.修改root本地登录密码\n```sql\nmysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：\n1. 修改密码策略\n      mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误\n\n   步骤1：不需要密码策略，添加/etc/my.cnf件中添加如下配置禁用即可：\n   validate_password = off\n   步骤2：重新启动mysql服务使配置生效：\n   systemctl restart mysqld   \n\n2. 查看初始密码： \n      grep 'temporary password' /var/log/mysqld.log\n   输出： \n      2018-03-07T13:01:08.963552Z 1 [Note] A temporary password is generated for root@localhost: zktt1wKFD.HN\n\n   得到临时密码: zktt1wKFD.HN\n\n3. 登录mysql: \n      mysql -uroot -p\n   输入临时密码进入mysql命令行\n\n4. 修改密码\n    set password for 'root'@'localhost'=password('MyNewPass4!');\n    \n5. 重启服务\n   systemctl restart mysqld   \n```\n#### 四：开启远程连接\n```sql\n登入mysql\n  mysql -uroot -p\n  \n使用mysql数据库\n  use mysql;\n  \n开启远程连接（root 用户名，% 所有人都可以访问 ，password 密码）\n  GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\n  \n  也可以添加一个新用户: \n  GRANT ALL PRIVILEGES ON *.* TO 'shuiyang'@'%' IDENTIFIED BY 'password!' WITH GRANT OPTION;\n  \n  FLUSH PRIVILEGES; \n  \n重起mysql服务\n  service mysqld restart\n如果执行完以上步骤，还是不能远程连接，那么我们需要查看服务器的防火墙是否开启\n  service iptables status\n如果防火墙开启，请关闭\n  service iptables stop\n```\n#### 五：配置默认编码为utf8\n```sql\n修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：\n\n[mysqld]\ncharacter_set_server=utf8\ninit_connect='SET NAMES utf8'\n\n重新启动mysql服务，查看数据库默认编码如下所示：\n\nmysql> show variables like '%character%';\n+--------------------------+----------------------------+\n| Variable_name            | Value                      |\n+--------------------------+----------------------------+\n| character_set_client     | utf8                       |\n| character_set_connection | utf8                       |\n| character_set_database   | utf8                       |\n| character_set_filesystem | binary                     |\n| character_set_results    | utf8                       |\n| character_set_server     | utf8                       |\n| character_set_system     | utf8                       |\n| character_sets_dir       | /usr/share/mysql/charsets/ |\n+--------------------------+----------------------------+\n8 rows in set (0.00 sec)\n```\n\n备注：\n```sql\n默认配置文件路径： \n配置文件：/etc/my.cnf \n日志文件：/var/log//var/log/mysqld.log \n服务启动脚本：/usr/lib/systemd/system/mysqld.service \nsocket文件：/var/run/mysqld/mysqld.pid\n```\n\n转载：https://www.linuxidc.com/Linux/2016-09/135288.htm\n转载:http://blog.csdn.net/sun614345456/article/details/53672150","tags":["server"],"categories":["服务器"]},{"title":"百度富文本框编辑器Ueditor的使用","url":"/2018/03/05/Web后台/相关技术/百度富文本框编辑器Ueditor的使用/","content":"### 百度富文本框编辑器：\n官网： http://ueditor.baidu.com/website/ \n\n官网演示地址：http://ueditor.baidu.com/website/onlinedemo.html\n\nUEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码...\n<!--more-->\n#### 开始使用：\n参考:\nhttp://fex.baidu.com/ueditor/\n##### 1. 入门部署和体验\n\n##### 1.1下载编辑器\n\n到官网下载 UEditor 最新版：[官网地址]\n\n##### 1.2创建demo文件\n\n解压下载的包，在解压后的目录创建 demo.html 文件，填入下面的html代码\n\n```html\n<!DOCTYPE HTML>\n<html lang=\"en-US\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>ueditor demo</title>\n</head>\n\n<body>\n    <!-- 加载编辑器的容器 -->\n    <script id=\"container\" name=\"content\" type=\"text/plain\">\n        这里写你的初始化内容\n    </script>\n    <!-- 配置文件 -->\n    <script type=\"text/javascript\" src=\"ueditor.config.js\"></script>\n    <!-- 编辑器源码文件 -->\n    <script type=\"text/javascript\" src=\"ueditor.all.js\"></script>\n    <!-- 实例化编辑器 -->\n    <script type=\"text/javascript\">\n        var ue = UE.getEditor('container');\n    </script>\n</body>\n\n</html>\n```\n##### 1.3 在浏览器打开demo.html\n\n如果看到了编辑器，恭喜你，初次部署成功！\n\n##### 2. 整合jsp后端配置\n\n##### 2.1 下载 jsp 版本完整包\n\n下载地址: http://ueditor.baidu.com/website/download.html \n\n选择 [1.4.3.3 Jsp 版本]\n\n##### 2.2 下载之后会得到如下文件\n\n按照官网上的做法是把文件copy到webapp跟目录下 , 但我们是集成ueditor, 肯定不是放在根目录下, 所以我们把文件都复制到 webapp/static/plugins/ueditor 下, 方便管理\n\n![logo](/images/server/相关技术/ueditor目录结构图.png) \n\n##### 2.3 前台代码集成\n2.3.1 在需要集成ueditor的页面添加如下代码, 如果能看到编辑器则说明配置成功\n```html\n<!DOCTYPE HTML>\n<html lang=\"en-US\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <title>ueditor demo</title>\n    <link rel=\"stylesheet\" href=\"${ctx}static/plugins/ueditor/lang/zh-cn/zh-cn.js\" media=\"all\" />\n</head>\n\n<body>\n    <!-- 加载编辑器的容器 -->\n    <script id=\"container\" name=\"content\" type=\"text/plain\">\n        这里写你的初始化内容\n    </script>\n    <!-- 配置文件 -->\n    <script type=\"text/javascript\" src=\"${ctx}static/plugins/ueditor/ueditor.config.js\"></script>\n    <!-- 编辑器源码文件 -->\n    <script type=\"text/javascript\" src=\"${ctx}static/plugins/ueditor/ueditor.all.js\"></script>\n    <!-- 实例化编辑器 -->\n    <script type=\"text/javascript\">\n        var ueditor = UE.getEditor('container');\n    </script>\n</body>\n\n</html>\n```\n获取编辑器内容\n```html\nvar ueditor = UE.getEditor('container');\n\nvar content = ueditor.getContent(content);\n\n```\n\n设置编辑器内容\n```html\n // 等UEditor创建完成就使用UEditor的setContent函数\n var ueditor = UE.getEditor('container');\n ueditor.ready(function() {\n      ueditor.setContent(content);\n });\n```\n\n有了这些你可以处理一些普通文字, 但如果是要文件上传,图片上传,视频上传这些功能你就要进行一些后台代码的配置\n\n##### 2.4 后台代码集成\n\n后台环境： Spring + Spring Mvc + Mybatis + Maven\n\n##### 2.4.1 配置 ueditor.config.js\n\n原配置:\n```javascript\n    var URL = window.UEDITOR_HOME_URL || getUEBasePath();\n\n    /**\n     * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。\n     */\n    window.UEDITOR_CONFIG = {\n\n        //为编辑器实例添加一个路径，这个不能被注释\n        UEDITOR_HOME_URL: URL\n\n        // 服务器统一请求接口路径\n        , serverUrl: URL + \"jsp/controller.jsp\"\n\n        //工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的重新定义\n```\n修改后的配置：\n```javascript\n    window.UEDITOR_HOME_URL = \"/static/plugins/ueditor/\";\n\n    var URL = window.UEDITOR_HOME_URL || getUEBasePath();\n\n    /**\n     * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。\n     */\n    window.UEDITOR_CONFIG = {\n\n        //为编辑器实例添加一个路径，这个不能被注释\n        UEDITOR_HOME_URL: URL\n\n        // 服务器统一请求接口路径\n        , serverUrl: \"/ueditor/ueditorAction\"\n\n```\n\n1. 主要是 `window.UEDITOR_HOME_URL` 这个参数赋值成自己的ueditor的文件路径\n2. 修改 服务器统一请求接口路径 `/ueditor/ueditorAction` , 这样Ueditor后台服务接口就会请求到这个接口中来\n\n##### 2.4.2 新增后台服务接口\n\n第一步： 导入jar包, 我是只添加了最后俩个包，其他的包可以通过maven的形式导入，copy 这俩个包放到WEBINF/lib目录下, 然后配置Maven依赖\n![logo](/images/server/相关技术/jar.png) \n\n注：使用maven构建项目的时候需要进行如下配置, 这样maven构建的时候才不会报找不到lib目录下jar包的错误\n```sql\n    <dependency>\n      <groupId>json</groupId>\n      <artifactId>json</artifactId>\n      <version>1.0</version>\n      <scope>system</scope>\n      <systemPath>${project.basedir}/src/main/webapp/WEB-INF/lib/json.jar</systemPath>\n    </dependency>\n```\n\n第二步：新建 后台统一服务接口\n\n```java\n/**\n * Ueditor 后台统一服务接口\n * @author songshuiyang\n * @date 2018/3/4 18:11\n */\n@Controller\n@RequestMapping(\"/ueditor\")\npublic class UEditorController extends BaseController {\n    \n    private HttpServletRequest request = null;\n    \n    private String actionType = null;\n\n    private ConfigManager configManager = null;\n\n\n    @RequestMapping(value = \"ueditorAction\", method = {RequestMethod.GET,RequestMethod.POST})\n    @ResponseBody\n    public JSONObject exec (@RequestParam String action, HttpServletRequest request) {\n        String result;\n        this.actionType = action;\n        this.request = request;\n        String rootPath =  request.getSession().getServletContext().getRealPath(\"/\");\n        String contextPath = request.getContextPath();\n        this.configManager = ConfigManager.getInstance( rootPath, contextPath,\"/static/plugins/ueditor/jsp/controller.jsp\");\n\n        String callbackName = this.request.getParameter(\"callback\");\n\n        if ( callbackName != null ) {\n            result =  !validCallbackName( callbackName ) ? new BaseState( false, AppInfo.ILLEGAL ).toJSONString() : callbackName+\"(\"+this.invoke()+\");\";\n        } else {\n            result = this.invoke();\n        }\n        return JSONObject.fromObject(result);\n\n    }\n\n    public String invoke() {\n\n        if ( actionType == null || !ActionMap.mapping.containsKey( actionType ) ) {\n            return new BaseState( false, AppInfo.INVALID_ACTION ).toJSONString();\n        }\n\n        if ( this.configManager == null || !this.configManager.valid() ) {\n            return new BaseState( false, AppInfo.CONFIG_ERROR ).toJSONString();\n        }\n\n        State state = null;\n\n        int actionCode = ActionMap.getType( this.actionType );\n\n        Map<String, Object> conf;\n\n        switch ( actionCode ) {\n\n            case ActionMap.CONFIG:\n                return this.configManager.getAllConfig().toString();\n\n            case ActionMap.UPLOAD_IMAGE:\n            case ActionMap.UPLOAD_SCRAWL:\n            case ActionMap.UPLOAD_VIDEO:\n            case ActionMap.UPLOAD_FILE:\n                conf = this.configManager.getConfig( actionCode );\n                state = new Uploader( request, conf ).doExec();\n                break;\n\n            case ActionMap.CATCH_IMAGE:\n                conf = configManager.getConfig( actionCode );\n                String[] list = this.request.getParameterValues( (String)conf.get( \"fieldName\" ) );\n                state = new ImageHunter( conf ).capture( list );\n                break;\n\n            case ActionMap.LIST_IMAGE:\n            case ActionMap.LIST_FILE:\n                conf = configManager.getConfig( actionCode );\n                int start = this.getStartIndex();\n                state = new FileManager( conf ).listFile( start );\n                break;\n\n        }\n\n        assert state != null;\n        return state.toJSONString();\n\n    }\n\n    private int getStartIndex () {\n\n        String start = this.request.getParameter( \"start\" );\n\n        try {\n            return Integer.parseInt( start );\n        } catch ( Exception e ) {\n            return 0;\n        }\n\n    }\n\n    /**\n     * callback参数验证\n     * @param name 名字\n     * @return boolean\n     */\n    private boolean validCallbackName ( String name ) {\n        return name.matches( \"^[a-zA-Z_]+[\\\\w0-9_]*$\" );\n    }\n}\n```\n\n一： 初始化ueditor的时候, ueditor会访问该接口, 此时`action` 参数是 `config` , 该接口会返回其`/static/plugins/ueditor/jsp/config.json` 配置的json参数，这些参数配置了上传功能的一些参数, 通过这些配置你可以DIY上传功能, ueditor获取到这些参数之后就可以使用上传功能了,否则你上传文件会提示： 后端配置项没有正常加载，上传插件不能正常使用！\n\n配置主要包括： 上传图片配置项 涂鸦图片上传配置项 截图工具上传 抓取远程图片配置 上传视频配置 上传文件配置\n\n二： 如要上传图片, ueditor会访问该接口, 此时`action` 参数是 `uploadimage` ，则会执行上传图片操作, 上传成功后会返回\n```sql\n{\n    \"state\": \"SUCCESS\",\n    \"url\": \"upload/demo.jpg\",\n    \"title\": \"demo.jpg\",\n    \"original\": \"demo.jpg\"\n}\n```\n三：由于系统文件上传使用的是阿里云的OSS所以需要将文件上传转到OSS处理上\n\n前台配置：\n```html\n<script type=\"text/javascript\">\n    // 当action是如下时，访问自己定义的服务接口\n    UE.Editor.prototype._bkGetActionUrl=UE.Editor.prototype.getActionUrl;\n    UE.Editor.prototype.getActionUrl=function(action){\n        // 上传图片, 文件, 视频\n        if (action == 'uploadimage' || action == 'uploadfile'  || action == 'uploadvideo') {\n            return '/file/uploadLocal';\n        }  else if( action== 'uploadscrawl'){ // 上传涂鸦，涂鸦请求是Base64字符需要请求另外的接口\n            return '/file/uploadScrawl';\n        }   else if(action == 'listimage'){\n            return this._bkGetActionUrl.call(this, action);\n        } else{\n            return this._bkGetActionUrl.call(this, action);\n        }\n    }\n    var ueditor = UE.getEditor('ueditorContainer');\n</script>\n```\n\n后台接口：\n```java\npackage com.ecut.admin.controller;\n\nimport com.aliyun.oss.ClientException;\nimport com.aliyun.oss.OSSException;\nimport com.ecut.admin.entity.OssFile;\nimport com.ecut.admin.entity.UeditorState;\nimport com.ecut.admin.service.impl.FileServiceImpl;\nimport com.ecut.core.base.BaseController;\nimport com.ecut.core.utils.Base64Utils;\nimport com.ecut.core.utils.MessageUtils;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.MediaType;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.multipart.MultipartFile;\nimport org.springframework.web.multipart.MultipartHttpServletRequest;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.ecut.core.utils.MessageUtils.success;\n\n/**\n * 阿里云OSS文件上传控制器\n * @author songshuiyang\n * @date 2018/2/11 20:22\n */\n@Controller\n@RequestMapping(\"/file\")\npublic class FileController extends BaseController {\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Autowired\n    private FileServiceImpl fileServiceImpl;\n\n    /**\n     * 文件上传\n     * produces=\"application/json;charset=UTF-8 解决服务器返回406问题\n     * @param file\n     * @return\n     * @throws OSSException\n     * @throws ClientException\n     * @throws IOException\n     */\n    @RequestMapping(value = \"/uploadLocal\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\")\n    @ResponseBody\n    public UeditorState uploadLocalFile(@RequestParam(value = \"upfile\",required = false) MultipartFile file) throws OSSException, ClientException, IOException {\n        Map<String, Object> resultMap = new HashMap<>();\n        OssFile file1 = fileServiceImpl.uploadFileByMultipartFile(file);\n        UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName());\n        return ueditorState;\n    }\n    /**\n     * 上传涂鸦照片\n     * @param upfile\n     * @return\n     * @throws Exception\n     */\n    @RequestMapping(value = \"/uploadScrawl\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\")\n    @ResponseBody\n    public UeditorState uploadscrawl(String upfile) throws Exception {\n        byte [] bytes= Base64Utils.decode(upfile);\n        InputStream inputStream = new ByteArrayInputStream(bytes);\n        String fileType = \"image/png\";\n        Long fileSize = new Long((long)bytes.length);\n        String fileName = \"scrawl\" + System.currentTimeMillis() + \".png\";\n        String extensionName = \"png\";\n        OssFile file1 = fileServiceImpl.uploadFileByInputStream(inputStream, fileType,fileSize,fileName,extensionName);\n        UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName());\n        return ueditorState;\n    }\n}\n```\n##### 2.4.3 问题集合\n\n###### 解决百度ueditor富文本编辑器不能插入视频的问题/src掉链/src清空，不能显示视频\n转载：http://blog.csdn.net/qq_34787830/article/details/75092347\n\n> 直接下载到的百度富文本编辑器当插入视频的时候会自动清掉src，不显示视频造成这样的原因是:百度富文本编辑器的过滤器xssFilter导致插入视频异常，编辑器在切换源码的过程中过滤掉img的_url属性（用来存储视频url）\n\n解决办法:\n\n1.在配置文件ueditor.config.js中，定位 //xss过滤白名单，即,whitList:{ }，对 img: 增加 “_url” 属性： \n2. 在下面的 video 标签后面新增3给标签，使Ueditor分别能支持embed标签和iframe标签：\n```java\n source: ['src', 'type'],\n\n embed: ['type', 'class', 'pluginspage', 'src', 'width', 'height', 'align', 'style', 'wmode', 'play',  \n\n      +  'autoplay','loop', 'menu', 'allowscriptaccess', 'allowfullscreen', 'controls', 'preload'],\n\n iframe: ['src', 'class', 'height', 'width', 'max-width', 'max-height', 'align', 'frameborder', 'allowfullscreen']\n```","tags":["Java"],"categories":["server"]},{"title":"基于wordspress搭建个人博客系统","url":"/2018/03/04/Web后台/相关技术/基于wordspress搭建个人博客系统/","content":"### 什么是Wordspress：\n官网： https://cn.wordpress.org/ 提供了中英版\n\nWordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。\n\nWordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。\n\nWordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的标准通用标记语言下的一个应用HTML代码、CSS、PHP等相关知识。\n\nWordPress官方支持中文版，同时有爱好者开发的第三方中文语言包，如wopus中文语言包。WordPress拥有成千上万个各式插件和不计其数的主题模板样式。\n<!--more-->\n### 搭建教程：\n参考下面的帖子写的十分详细\n\nhttps://www.jianshu.com/p/56750622cac9\n\n\n### LNMP一键安装包\nLNMP一键安装包是一个用Linux Shell编写的可以为CentOS/RHEL/Fedora/Aliyun/Amazon、Debian/Ubuntu/Raspbian/Deepin/Mint Linux VPS或独立主机安装LNMP(Nginx/MySQL/PHP)、LNMPA(Nginx/MySQL/PHP/Apache)、LAMP(Apache/MySQL/PHP)生产环境的Shell程序。\nhttps://lnmp.org/","tags":["Java"],"categories":["server"]},{"title":"Mysql 数据类型.md","url":"/2018/03/03/Web后台/数据库/Mysql 数据类型/","content":"MySQL中定义数据字段的类型对你数据库的优化是非常重要的。\n\nMySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。\n\n<!--more-->\n### 数值类型\nMySQL支持所有标准SQL数值数据类型。\n\n这些类型包括严格数值数据类型`(INTEGER、SMALLINT、DECIMAL和NUMERIC)`，以及近似数值数据类型`(FLOAT、REAL和DOUBLE PRECISION)`。\n\n关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。\n\nBIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。\n\n作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。\n\n![logo](/images/server/数据库/mysqlint.png) \n\n备注: \n1.BIT[M]\n\n位字段类型，M表示每个值的位数，范围从1到64，如果M被忽略，默认为1\n\n2.TINYINT[(M)] [UNSIGNED] [ZEROFILL]  M默认为4,占1个字节\n\n很小的整数。带符号的范围是-128到127。无符号的范围是0到255。\n\n3. BOOL，BOOLEAN\n\n是TINYINT(1)的同义词。zero值被视为假。非zero值视为真。\n\n4.SMALLINT[(M)] [UNSIGNED] [ZEROFILL] M默认为6,占2个字节\n\n小的整数。带符号的范围是-32768到32767。无符号的范围是0到65535。\n\n5.MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] M默认为9,占3个字节\n\n中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。\n\n6. INT[(M)] [UNSIGNED] [ZEROFILL]   M默认为11,占4个字节\n\n普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。\n\n7.BIGINT[(M)] [UNSIGNED] [ZEROFILL] M默认为20,占8个字节\n\n大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。\n\n注意：这里的M代表的并不是存储在数据库中的具体的长度，以前总是会误以为int(3)只能存储3个长度的数字，int(11)就会存储11个长度的数字，这是大错特错的。\n\ntinyint(1) 和 tinyint(4) 中的1和4并不表示存储长度，只有字段指定zerofill是有用，\n如tinyint(4)，如果实际值是2，如果列指定了zerofill，查询结果就是0002，左边用0来填充。\n\n### 日期和时间类型\n\n表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。\n\n每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。\n\nTIMESTAMP类型有专有的自动更新特性\n\n![logo](/images/server/数据库/mysqldate.png) \n\n### 字符串类型\n\n字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型\n\n![logo](/images/server/数据库/mysqlchar.png) \n\n","tags":["db"],"categories":["server"]},{"title":"animate.css","url":"/2018/03/03/Web前端/animate/","content":"### 一 前言:\n#### 背景： \n在看其他人的项目的时候发现其动画效果做的不错，通过看人家的代码发现用了这个`animate.css`这个css组件，使用起来也是特别的方便，所以就把他copy到项目中来了，顿时档次就上升了\n\n#### 简介:\n`animate.css` 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。而且使用起来也是特别方便\n\n官网传送门: https://daneden.github.io/animate.css/\n\n在官网上有示例动画，主页也十分简洁，同时也提供了代码下载, 也可以看看这篇博客写的例子 `https://www.cnblogs.com/xiaohuochai/p/7372665.html`\n\n### 二 如何使用：\n\n#### 步骤：\n1. 在官网上下载 `animate.css` , 把他导入到项目中来, 也可以使用cdn `https://unpkg.com/animate.css@3.5.2/animate.min.css`\n2. 代码示例\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Document</title>\n        <link rel=\"stylesheet\" href=\"https://unpkg.com/animate.css@3.5.2/animate.min.css\">\n        <style>\n            .box{height: 100px;width: 100px;background-color: lightblue}\n        </style>\n    </head>\n    <body>\n        <div class=\"box animated flash\"></div>\n    </body>\n</html>\n```\n3. 只要在元素中class 添加 `animated` 和相应的动画class名就可以实现动画效果, 当然也可以通过js动态设置class\n\n\n\n\n\n","tags":["css"],"categories":["client"]},{"title":"Spring mvc 前后台传值中文乱码问题","url":"/2018/02/28/Web后台/Spring/spring-mvc/Spring mvc 中文乱码问题/","content":"一： 解决GET请求参数到了后台中文乱码问题\n\n方式一: 修改tomcat配置, 暂时做法，没有找到更好的解决办法，换了tomcat了又要重新配置\n```java\n把tomcat下，server.xml下，添加如下配置，就解决了．\n\n  <Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/>\n```\n方式二: 自定义filter, 解决了get请求中文参数问题，但post请求参数到了后台就gg了\n\n<!--more-->\n\n1. 新建 `CustomEncodingFilter.java`\n```java\npackage com.ecut.core.web.filter;\n\nimport org.springframework.cglib.proxy.InvocationHandler;\nimport org.springframework.cglib.proxy.Proxy;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Method;\n\npublic class CustomEncodingFilter extends OncePerRequestFilter {\n    private String encoding;\n\n    public void setEncoding(String encoding) {\n        this.encoding = encoding;\n    }\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n            throws ServletException, IOException {\n        // 设置请求响应字符编码\n        request.setCharacterEncoding(encoding);\n        response.setCharacterEncoding(encoding);\n\n        // 传递给目标servlet或jsp的实际上是动态代理的对象，而不是原始的HttpServletRequest对象\n        request = (HttpServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(), request.getClass().getInterfaces(), new MyInvacationHandler(request));\n        chain.doFilter(request, response);\n    }\n\n    class MyInvacationHandler implements InvocationHandler {\n        private HttpServletRequest request;\n        MyInvacationHandler(HttpServletRequest request){\n            this.request=request;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            switch (method.getName()) {\n                case \"getParameter\":\n                    String value = request.getParameter((String)args[0]);\n                    try {\n                        if(value != null){\n                            value=new String(value.getBytes(\"ISO-8859-1\"),encoding);\n                        }\n                    } catch (UnsupportedEncodingException e) {\n                        e.printStackTrace();\n                    }\n                    return value;\n                case \"getParameterValues\":\n                    String[] values = request.getParameterValues((String)args[0]);\n                    if (values != null) {\n                        for (int i = 0; i < values.length; i++) {\n                            try {\n                                values[i] = new String(values[i].getBytes(\"ISO-8859-1\"),encoding);\n                            } catch (UnsupportedEncodingException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    }\n                    return values;\n                default:\n                    return method.invoke(request, args);\n            }\n        }\n\n    }\n}\n```\n2. 配置`web.xml`\n```java\n  <filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>com.ecut.core.web.filter.CharacterEncodingFilter</filter-class>\n    <async-supported>true</async-supported>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>UTF-8</param-value>\n    </init-param>\n    <init-param>\n      <param-name>forceEncoding</param-name>\n      <param-value>true</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n```\n二： 解决POST请求参数到了后台中文乱码问题\n```java\n  <filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <async-supported>true</async-supported>\n    <init-param>\n      <param-name>encoding</param-name>\n      <param-value>UTF-8</param-value>\n    </init-param>\n    <init-param>\n      <param-name>forceEncoding</param-name>\n      <param-value>true</param-value>\n    </init-param>\n  </filter>\n  <filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n```","tags":["Spring"],"categories":["服务器"]},{"title":"阿里巴巴Java编程规范","url":"/2018/02/13/Web后台/编程规范/阿里巴巴Java编程规范/","content":"### 前言：\n<center>关于《阿里巴巴Java开发手册》</center>\n\n\n\n你是否曾因Java代码规范版本纷杂而无所适从？\n\n你是否想过代码规范能将系统故障率降低20%？\n\n你是否曾因团队代码风格迥异而协同困难？\n\n你是否正在review一些原本可以避免的故障？\n\n你是否无法确定自己的代码足够健壮？ \n\n<!--more-->\n\n#### 码出高效，码出质量！\n相比C++代码规范业界已经达成共识，Java代码规范业界比较混乱，我们期待这次发布的Java代码规范能够给业界带来一个标准，促使整体行业代码规范水平得到提高，最终能够帮助企业和开发者提升代码质量和降低代码故障率。\n\n#### 阿里出品，质量保证！\n\n阿里Java技术团队一手打造出Dubbo、JStorm、Fastjson等诸多流行开源框架，部分已成为Apache基金会孵化项目；\n\n阿里在Java后端领域支撑起全球访问量最大的服务器集群；\n\nJava代码构建的阿里双11业务系统订单处理能力达到17.5万笔/秒；\n\n到目前已累计数亿行高并发、高稳定性的最佳Java代码实践；\n\n……\n\n此次公开的Java开发手册正是出自这样的团队，近万名阿里Java技术精英的经验总结，并经历了多次大规模一线实战检验及完善，铸就了这本高含金量的阿里Java开发手册。该手册以Java开发者为中心视角，划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱和故障敏感性，规约依次分为强制、推荐、参考三大类。此套规范不仅能让代码一目了然， 更有助于加强团队分工与合作、真正提升效率。 \n\n\n#### 无规矩不成方圆 无规范不能协作\n\n众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有规定靠右行驶，谁还敢上路行驶。 \n\n同理，对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，降低故障率，提升协作效率。开发手册详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，提高代码质量。比如，异常日志处理时的各种不规范行为；集合转换的各种坑；创建线程池出现的等待队列OOM等。 \n\n#### 阿里技术资深大咖联袂推荐\n\n阿里高级研究员多隆：工程师对于代码，一定要“精益求精”，不论从性能，还是简洁优雅，都要具备“精益求精”的工匠精神，认真打磨自己的作品。 \n\n阿里研究员毕玄：一个优秀的工程师和一个普通工程师的区别，不是现在满天飞的架构图，他的功底就是体现在他写的每一行代码上。 \n\n阿里研究员玄难：代码是软件工程里面的产品设计、系统架构设计等工作的最后承载体，代码的质量决定了一切工作的成败。 \n\n阿里巴巴B2B事业群CTO李纯：好的软件产品离不开工程师高质量的代码及相互间顺畅的沟通与合作。简单，适用的代码规约背后所传递的是技术上的追求卓越、协同合作的精神，是每个技术团队不可缺失的重要利器。 \n\n阿里研究员、HipHop作者：赵海平（花名：福贝）：程序员是创造个性化作品的艺术家，但同时也是需要团队合作的工种。个性化应尽量表现在代码效率和算法方面，牺牲小我，成就大我。\n\n#### 拥抱规范，远离伤害！\n     \n开发的同学们赶紧行动起来，遵守代码规范，你好，我好，大家好！\n\n\n##### 传送门\n1. 原文: https://yq.aliyun.com/articles/69327?spm=5176.100239.blogcont69327.158.xUUgiz&p=2#comments\n2. 「阿里巴巴编码规范」考试认证 : https://edu.aliyun.com/certification/cldt02 \n3. 点击下载《阿里巴巴Java开发手册》(纪念版): https://yq.aliyun.com/attachment/download/?id=4942\n4. IDE插件下载 : https://github.com/alibaba/p3c\n\n\n### 以下记录以下自己需要注意的一些规范, `遵守代码规范，你好，我好，大家好！`\n\n#### 编程规约\n\n#### 命名风格\n1. 【强制】\n\n     抽象类命名使用 Abstract 或 Base 开头； \n\n     异常类命名使用 Exception 结尾； \n    \n     测试类命名以它要测试的类的名称开始，以 Test 结尾。\n2. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n   \n   正例： `MAX_STOCK_COUNT`\n   \n   反例： `MAX_COUNT`\n3. 【强制】 POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。\n   \n   反例： 定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted()， RPC 框架在反向解析的时候， “以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异\n                                                                常。\n4. 【强制】杜绝完全不规范的缩写， 避免望文不知义。\n\n   反例： AbstractClass“缩写” 命名成 AbsClass； condition“缩写” 命名成 condi，此类随\n   意缩写严重降低了代码的可阅读性。\n   \n5. 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词\n   组合来表达其意。\n   \n   正例： 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。\n   \n   反例： 变量 int a; 的随意命名方式。\n   \n6. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加） ，保持代码的简洁\n   性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是\n   与接口方法相关，并且是整个应用的基础常量。\n   \n   正例： 接口方法签名： void f();\n   \n   接口基础常量表示： String COMPANY = \"alibaba\";\n   \n   反例： 接口方法定义： public abstract void f();\n   \n   说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默\n   认实现。\n   \n7. 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n   说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n   \n   正例： 枚举名字为 ProcessStatusEnum 的成员名称： SUCCESS / UNKOWN_REASON。\n   \n8. 【参考】各层命名规约：\n\n   > A) Service/DAO 层方法命名规约\n   \n   1） 获取单个对象的方法用 get 做前缀。\n   \n   2） 获取多个对象的方法用 list 做前缀。\n   \n   3） 获取统计值的方法用 count 做前缀。\n   \n   4） 插入的方法用 save/insert 做前缀。\n   \n   5） 删除的方法用 remove/delete 做前缀。\n   \n   6） 修改的方法用 update 做前缀。\n   \n   > B) 领域模型命名规约\n   \n   1） 数据对象： xxxDO， xxx 即为数据表名。\n   \n   2） 数据传输对象： xxxDTO， xxx 为业务领域相关的名称。\n   \n   3） 展示对象： xxxVO， xxx 一般为网页名称。\n   \n   4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n   \n#### 常量定义\n1. 【强制】不允许任何魔法值（即未经定义的常量） 直接出现在代码中。\n\n   反例： String key = \"Id#taobao_\" + tradeId;\n   \n   cache.put(key, value);\n2. 【推荐】不要使用一个常量类维护所有常量， 按常量功能进行归类，分开维护。\n\n   说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。\n   \n   正例： 缓存相关常量放在类 CacheConsts 下； 系统配置相关常量放在类 ConfigConsts 下。\n#### 代码格式\n1.示例\n```java\npublic static void main(String[] args) {\n    // 缩进 4 个空格\n    String say = \"hello\";\n    // 运算符的左右必须有一个空格\n    int flag = 0;阿里巴巴 Java 开发手册\n    // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号， 0 与右括号不需要空格\n    if (flag == 0) {\n        System.out.println(say);\n    }\n    // 左大括号前加空格且不换行；左大括号后换行\n    if (flag == 1) {\n        System.out.println(\"world\");\n        // 右大括号前换行，右大括号后有 else，不用换行\n    } else {\n        System.out.println(\"ok\");\n        // 在右大括号后直接结束，则必须换行\n    }\n}\n```\n2.【强制】 注释的双斜线与注释内容之间有且仅有一个空格。\n\n   正例： // 注释内容， 注意在//和注释内容之间有一个空格。\n   \n3.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：\n\n   1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。\n   \n   2） 运算符与下文一起换行。\n   \n   3） 方法调用的点符号与下文一起换行。\n   \n   4） 方法调用时，多个参数， 需要换行时， 在逗号后进行。\n   \n   5） 在括号前不要换行，见反例。\n   \n   正例：\n```java\n   StringBuffer sb = new StringBuffer();\n   // 超过 120 个字符的情况下，换行缩进 4 个空格， 点号和方法名称一起换行\n   sb.append(\"zi\").append(\"xin\")...\n       .append(\"huang\")...\n       .append(\"huang\")...\n       .append(\"huang\");\n```\n   反例：\n   ```java\n   StringBuffer sb = new StringBuffer();\n   // 超过 120 个字符的情况下，不要在括号前换行\n   sb.append(\"zi\").append(\"xin\")...append\n       (\"huang\");\n   // 参数很多的方法调用可能超过 120 个字符， 不要在逗号前换行\n   method(args1, args2, args3, ...\n      , argsX);\n   ```\n4.【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。\n\n   正例： 下例中实参的\"a\",后边必须要有一个空格。\n   \n   method(\"a\", \"b\", \"c\");\n5.【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义\n   之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。\n   说明： 没有必要插入多个空行进行隔开\n#### 注释规范\n1. 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用\n   // xxx 方式。\n   \n   说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注\n   释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高\n   阅读效率\n2. 【强制】所有的抽象方法（包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、\n   异常说明外，还必须指出该方法做什么事情，实现什么功能。\n   \n   说明： 对子类的实现要求，或者调用注意事项，请一并说明\n3. 【强制】所有的类都必须添加创建者和创建日期。\n\n4. 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持\n   英文原文即可\n5. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑\n   等的修改\n   \n   【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑\n   等的修改\n   \n6. 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑\n   等的修改\n   \n7.  【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，\n   经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。\n   1） 待办事宜（TODO） :（标记人，标记时间， [预计处理时间]）\n   表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc\n   还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签） 。\n   2） 错误，不能工作（FIXME） :（标记人，标记时间， [预计处理时间]）\n   在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。\n#### 异常处理\n1. 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回\n   滚事务。\n2. 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回\n   滚事务。\n   \n#### MySQL 数据库 建表规约\n1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint\n（1 表示是， 0 表示否） 。\n\n说明： 任何字段如果为非负数，必须是 unsigned。\n\n正例： 表达逻辑删除的字段名 is_deleted， 1 表示删除， 0 表示未删除\n\n2.【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长\n    度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索\n    引效率。\n3.【强制】表必备三字段： id, gmt_create, gmt_modified。\n\n说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。 gmt_create,\ngmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被\n   动更新\n4.【推荐】表的命名最好是加上“业务名称_表的作用”。\n  正例： alipay_task / force_project / trade_config\n5.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。\n   说明： 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明\n   显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必\n   然有脏数据产生\n6.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致； 多表关联查询时，\n  保证被关联的字段需要有索引。\n  说明： 即使双表 join 也要注意表索引、 SQL 性能\n#### MySQL 数据库 SQL语句\n1. 【强制】不要使用 count(列名)或 count(常量)来替代 count(*)， count(*)是 SQL92 定义的\n标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。\n说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行","tags":["java"],"categories":["server"]},{"title":"解决CSS和JS文件的客户端缓存问题","url":"/2018/02/10/Web前端/CSS和JS文件的客户端缓存问题/","content":"## 场景\n做项目的时候，发现自己修改了一个css文件但样式并没有应用，查看http请求(如下图)，注意这个参数`Status Code:200 OK (from disk cache)` , 说明文件是是之前浏览器缓存的文件，浏览器并没有请求我们新改的文件\n```java\nRequest URL:http://localhost:8080/static/layui/build/css/app.cssRequest Method:GET\nStatus Code:200 OK (from disk cache)\nRemote Address:127.0.0.1:8080\nReferrer Policy:no-referrer-when-downgrade\n```\n## 解决方法\n> 发现问题了，现在就是要解决如果是服务器js css等文件修改了，怎样让浏览器能够请求我们最新的文件, 通过查看其他人的解决方法，还有看了一下大厂`百度, 淘宝 , 新浪` 对这个问题的处理，总结了一下下面几种方法:\n\n#### 方法一: 在css文件上, js文件后面加上版本号`?v=1245365`\n```html\n<link rel=\"stylesheet\" href=\"${ctx}static/admin/css/main.css?v=1245365\" media=\"all\" />\n```\n1. 如果是经常更新的css文件版本号可以取当前时间的时间戳 `v=1518237859338` ,这样就可以每次都获取到最新的文件，但缺点就是每次刷新页面都会请求该文件，在项目开发过程中可以使用这种方式\n2. 如果是更新频率不高的的文件，可以取: `v=20180210` , 这样的话刷新页面就不会每次请求这个文件了，可以减轻服务器的压力 \n3. 如果是项目稳定了基本没有改动了，可以取一个固定值:`v=0.0.1`\n\n### 方法二：一个版本一个文件夹\n> 淘宝的做法: 用一个文件 `6.2.3`\n```html\nhttps://g.alicdn.com/kg/??component/6.2.3/extension/content-box/xtpl/view.xtpl-min.js\n```\n\n\n\n\n","tags":["js"],"categories":["client"]},{"title":"生成二维码图片(base64格式)","url":"/2018/01/29/Web后台/相关技术/生成二维码图片(base64格式)/","content":"### 生成二维码图片(base64格式)\n\n\n<!--more-->\n```java\npackage com.guangeryi.mall.payment.weixin;\n\nimport com.google.zxing.BarcodeFormat;\nimport com.google.zxing.EncodeHintType;\nimport com.google.zxing.MultiFormatWriter;\nimport com.google.zxing.client.j2se.MatrixToImageWriter;\nimport com.google.zxing.common.BitMatrix;\nimport org.apache.commons.codec.binary.Base64;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.Hashtable;\nimport java.util.Map;\n\npublic class QRCodeUtils {\n\n    /**\n     * 生成二维码 Base64编码后字符串\n     *\n     * @param contents 内容\n     */\n    public static String encodeQRCodeBase64(String contents) {\n        return encodeQRCodeToBase64Str(contents);\n    }\n\n    /**\n     * 生成二维码 Base64编码后字符串 <img src=''> src填入该字符串显示图片\n     * （高度:300 , 宽度:300）\n     * @param contents 内容\n     */\n    private static String encodeQRCodeToBase64Str(String contents) {\n        int width = WxPcPayConfigImpl.QR_IMG_WIDTH;\n        int height = WxPcPayConfigImpl.QR_IMG_HEIGHT;\n        Map<EncodeHintType, Object> hints = new Hashtable<>();\n        String base64Img = \"data:image/png;base64,\";\n        // 指定编码格式\n        hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\");\n        try {\n            // 生成输出流\n            BitMatrix bitMatrix1 = new MultiFormatWriter().encode(contents,\n                    BarcodeFormat.QR_CODE, width, height, hints);\n            BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix1);\n            base64Img = base64Img + encodeToString(\"png\", image);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return base64Img;\n    }\n    /**\n     * 将图片转换成base64格式进行存储\n     *\n     * @param formatName 文件格式\n     * @param image      图片流\n     * @return base64字符串\n     */\n    private static String encodeToString(String formatName, BufferedImage image) {\n        String imageString = null;\n        try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n            ImageIO.write(image, formatName, bos);\n            byte[] imageBytes = bos.toByteArray();\n            imageString = new String(Base64.encodeBase64(imageBytes));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return imageString;\n    }\n\n    public static void main(String[] args) {\n        // 输出在img标签中img属性中\n        System.out.println(encodeQRCodeBase64(\"你好\"));\n    }\n}\n```","tags":["Java"],"categories":["server"]},{"title":"根据手机区号获取城市地理位置","url":"/2018/01/29/Web后台/相关技术/根据手机区号获取城市地理位置/","content":"### 根据手机区号获取城市地理位置\n\nhttpAPI:  http://www.ip138.com:8080/search.asp?action=mobile&mobile=%s\n\n<!--more-->\n```java\npackage com.guangeryi.mall.third.common;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.select.Elements;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class MobileLocationUtils {\n\n    private final static Logger logger = LoggerFactory.getLogger(MobileLocationUtils.class);\n\n    /**\n     * 根据手机号获取所在地信息\n     * @param mobile 手机号码\n     * @return 返回map\n     */\n    public static Map<String,Object> getMobileAddress (String mobile) {\n        Map<String,Object> map = new HashMap<>();\n        String returnStr= getMobileAddressUtils(mobile);\n        // 将160号的空格转化成32号的空格\n        returnStr = returnStr.replaceAll(\"[\\\\u00A0]+\", \" \");\n        // 去空格\n        returnStr = returnStr.trim();\n        String [] address = returnStr.split(\"\\\\s+\");\n        String province = \"\";// 省\n        String city = \"\";    // 市\n        // 直辖市\n        if (address.length == 1) {\n            province = address[0];\n            city = address[0];\n        }\n        if (address.length == 2) {\n            province = address[0];\n            city = address[1];\n        }\n        map.put(\"province\", province);\n        map.put(\"city\", city);\n        logger.info(mobile + \" 手机号所在信息:\" + map);\n        return map;\n    }\n\n    public static String getMobileAddressUtils(String mobile){\n        try {\n            String url = \"http://www.ip138.com:8080/search.asp?action=mobile&mobile=%s\";\n            url = String.format(url, mobile);\n            Document doc = Jsoup.connect(url).get();\n            Elements els = doc.getElementsByClass(\"tdc2\");\n            if(els.get(1).text().equals(\"mobile 不是数字! 验证手机号有误\") || els.get(1).text().equals(\"验证手机号有误\")) {\n                return \"未知\";\n            }\n            return els.get(1).text();\n        } catch (Exception e) {\n            return \"未知\";\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getMobileAddress(\"13117975845\"));\n    }\n}\n\n\n```","tags":["Java"],"categories":["server"]},{"title":"根据IP获取城市地理位置","url":"/2018/01/29/Web后台/相关技术/根据IP获取城市地理位置/","content":"### 根据IP获取城市地理位置\n使用的是百度查询的api，试过到淘宝的API, 但是淘宝做了访问次数限制，如果批量查询的话直接timeout\n\n\n<!--more-->\n```java\npackage com.guangeryi.mall.third.common;\n\nimport net.sf.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.*;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * 根据IP获取城市地理位置\n * 调用百度api：http://api.map.baidu.com/location/ip\n */\npublic class IpUtils {\n\n    private final static Logger logger = LoggerFactory.getLogger(AddressUtils.class);\n\n    /**\n     * 根据ip获取城市信息\n     * @param ip\n     * @return\n     */\n    public static Map<String, Object> getCityInfoByIp(String ip){\n        Map<String, Object> result = new HashMap<>();\n        result.put(\"status\",\"success\");\n        String jsonInfo = null;\n        try {\n            jsonInfo = getCityInfoByUrlAPI(ip);\n            logger.info(\"jsonInfo:\" + jsonInfo);\n        } catch (IOException e) {\n            logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常, ip:\" + ip, e);\n            result.put(\"status\",\"failed\");\n            return  result;\n        }\n        String province = \"\";\n        String city = \"\";\n        String district =\"\";\n        String street = \"\";\n        try {\n            JSONObject jsonObject = JSONObject.fromObject(jsonInfo);\n            if (jsonObject != null) {\n                if (jsonObject.getJSONObject(\"content\") != null) {\n                    JSONObject addressDetail = jsonObject.getJSONObject(\"content\").getJSONObject(\"address_detail\");\n                    province = (String)addressDetail.get(\"province\"); // 省\n                    city = (String)addressDetail.get(\"city\");         // 市\n                    district = (String)addressDetail.get(\"district\"); // 区\n                    street = (String)addressDetail.get(\"street\");     // 街道\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常,解析JSON异常 ip:\" + ip, e);\n            result.put(\"status\",\"failed\");\n            return  result;\n        }\n        result.put(\"province\",province);\n        result.put(\"city\",city);\n        result.put(\"district\",district);\n        result.put(\"street\",street);\n        return result;\n    }\n\n    /**\n     * 调用 api.map.baidu.com/location/ip 获取城市信息\n     * @param ip\n     * @return\n     * @throws IOException\n     */\n    private static String getCityInfoByUrlAPI(String ip) throws IOException {\n        String url = \"http://api.map.baidu.com/location/ip?ak=F454f8a5efe5e577997931cc01de3974&ip=\" + ip;\n        try (InputStream is = new URL(url).openStream()) {\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\")));\n            String jsonText = getStrByReader(rd);\n            jsonText = decodeUnicode(jsonText);\n            return jsonText;\n        }\n    }\n    /**\n     * 获取流数据\n     * @param rd\n     * @return\n     * @throws IOException\n     */\n    private static String getStrByReader(Reader rd) throws IOException {\n        StringBuilder sb = new StringBuilder();\n        int cp;\n        while ((cp = rd.read()) != -1) {\n            sb.append((char) cp);\n        }\n        return sb.toString();\n    }\n    /**\n     * unicode 转换成 中文\n     *\n     * @author fanhui 2007-3-15\n     * @param theString 字符串\n     * @return String\n     */\n    private static String decodeUnicode(String theString) {\n        char aChar;\n        int len = theString.length();\n        StringBuilder outBuilder = new StringBuilder(len);\n        for (int x = 0; x < len;) {\n            aChar = theString.charAt(x++);\n            if (aChar == '\\\\') {\n                aChar = theString.charAt(x++);\n                if (aChar == 'u') {\n                    int value = 0;\n                    for (int i = 0; i < 4; i++) {\n                        aChar = theString.charAt(x++);\n                        switch (aChar) {\n                            case '0':\n                            case '1':\n                            case '2':\n                            case '3':\n                            case '4':\n                            case '5':\n                            case '6':\n                            case '7':\n                            case '8':\n                            case '9':\n                                value = (value << 4) + aChar - '0';\n                                break;\n                            case 'a':\n                            case 'b':\n                            case 'c':\n                            case 'd':\n                            case 'e':\n                            case 'f':\n                                value = (value << 4) + 10 + aChar - 'a';\n                                break;\n                            case 'A':\n                            case 'B':\n                            case 'C':\n                            case 'D':\n                            case 'E':\n                            case 'F':\n                                value = (value << 4) + 10 + aChar - 'A';\n                                break;\n                            default:\n                                throw new IllegalArgumentException(\"Malformed      encoding.\");\n                        }\n                    }\n                    outBuilder.append((char) value);\n                } else {\n                    if (aChar == 't') {\n                        aChar = '\\t';\n                    } else if (aChar == 'r') {\n                        aChar = '\\r';\n                    } else if (aChar == 'n') {\n                        aChar = '\\n';\n                    } else if (aChar == 'f') {\n                        aChar = '\\f';\n                    }\n                    outBuilder.append(aChar);\n                }\n            } else {\n                outBuilder.append(aChar);\n            }\n        }\n        return outBuilder.toString();\n    }\n    public static void main(String[] args) {\n        System.out.println(getCityInfoByIp(\"118.212.211.23\"));\n    }\n}\n\n```\n\n#### 获取用户真实IP地址\n\n```java\n    /**\n     * 获取用户真实IP地址，不使用request.getRemoteAddr()的原因是有可能用户使用了代理软件方式避免真实IP地址,\n     * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值\n     */\n    public static String getRemoteIp(HttpServletRequest request) {\n        String ip = request.getHeader(\"x-forwarded-for\");\n        if (ip != null && ip.length() != 0 && !\"unknown\".equalsIgnoreCase(ip)) {\n            // 多次反向代理后会有多个ip值，第一个ip才是真实ip\n            if(ip.contains(\",\")){\n                ip = ip.split(\",\")[0];\n            }\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"Proxy-Client-IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"WL-Proxy-Client-IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"HTTP_CLIENT_IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"HTTP_X_FORWARDED_FOR\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getHeader(\"X-Real-IP\");\n        }\n        if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) {\n            ip = request.getRemoteAddr();\n        }\n        // TODO 本地测试使用\n        if (!isIpv4(ip)) {\n            ip= \"120.27.129.177\"; // 服务器ip\n        }\n        return ip;\n    }\n```\n#### 校验IP地址\n\n```java\n    /**\n     * 校验IP地址\n     * @param ipAddress IP 地址\n     * @return true or false\n     */\n    public static boolean isIpv4(String ipAddress) {\n\n        String ip = \"^(1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\"\n                +\"(00?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n                +\"(00?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\"\n                +\"(00?\\\\d|1\\\\d{2}|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\";\n\n        Pattern pattern = Pattern.compile(ip);\n        Matcher matcher = pattern.matcher(ipAddress);\n        return matcher.matches();\n    }\n```","tags":["Java"],"categories":["server"]},{"title":"阿里云服务器搭建Javaweb运行环境","url":"/2018/01/20/Web后台/JavaEE服务器/阿里云服务器搭建Javaweb运行环境/","content":"### 一：前言\n借助阿里云的云翼计划的梯子买了个 阿里的ESC云服务器，学生专享优惠10块钱/月，原价一百多一个月，超级划算，当然服务器配置对于我们这些学生捣鼓捣鼓还是满足的。\n\n配置：\n\n|  配置 | 参数    | \n| -----   | -----:   | \n| CPU     | Intel Xeon E5-2682 v4 1核   |\n| 内存     | 2G 最新一代DDR4 内存        |\n| 带宽    | 1M带宽 VPC专有网络, I/O 优化 |\n| 系统盘   | 40G系统盘高效云盘           |\n\n系统：CentOS 7.3 64位(可选ubuntu, windows service)\n\n\nESC: 云服务器 ECS（Elastic Compute Service）是一种弹性可伸缩的计算服务，助您降低 IT 成本，提升运维效率，使您更专注于核心业务创新\n\n### 二：搭建步骤\n#### 2.1 购买 ESC云服务器\n购买链接:https://www.aliyun.com/product/ecs?spm=5176.8499797.765261.239.9Uf4pK, 当然如果是学生的话可以使用上面的云翼计划(https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8789780.765430.4.246c0fa5bHX2oK)优惠的方式购买，当时购买还送了(CDN流量包)和(OSS资源包) , 良心企业!!! \n\n#### 2.2 查看系统参数，及配置参数\n下单完成之后在 控制台-> 云服务器 ECS -> 实例 可看到系统自动为我们创建的 服务器实例, 里面提供了一些系统参数，还展示了系统的一些运行状态参数。\n\n我们需要的参数\n\n1.公网ip\n\n>访问实例需要用\n\n2.远程连接密码  \n\n> 这个在第一次使用浏览器远程连接主机的时候，阿里云会提供，记住只出现一次，可以用笔记本记录下来，以后每次用浏览器远程控制访问主机的时候需要提供\n\n3.登入系统的密码 \n\n在实例信息面板中有一个重置密码的功能，第一次需要自己设置，这个是主机系统的登入密码。 一开始用浏览器远程连接主机的时候，进入到了命令行界面, 要求输入密码的时候一直输入的是远程连接密码，导致一直登不进，查了一下资料发现系统登入密码需要自己创建, 登入用户 `root`\n\n4.安全组配置\n\n安全组配置是阿里云在系统做了一次网关过滤，外网访问主机，主机访问外网都需要配置这个参数，否则访问不到, 安全组配置分为入口和出口\n\n入口配置:\n\n- 把一些常用端口打开:`80 22(ssh, sftp) 23(telnet)` , 使用xshell和ftp都是使用的是22端口\n- 添加 `全部 ICMP` 协议类型, 端口范围为`-1/-1`, 没有这条规则则ping 不通主机\n\n\n#### 2.3 连接主机进行配置\n有了上面的配置就可以通过远程连接主机了, 我是使用`xshell` 进行远程连接, 使用`fileZilla`进行传输文件\n##### 2.3.1 配置 Java环境\n方式一：使用yum安装JDK 参考：https://www.cnblogs.com/sxdcgaq8080/p/7492426.html\n```sql\n1.查看yum库中都有哪些jdk版本(暂时只发现了openjdk): \n[root@localhost ~]# yum search java|grep jdk\n\n2.选择版本,进行安装\n[root@localhost ~]# yum install java-1.8.0-openjdk\n\n//安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_64\n\n3.设置环境变量\n[root@localhost ~]# vi /etc/profile\n在profile文件中添加如下内容\n#set java environment\nJAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el7_5.x86_64\nJRE_HOME=$JAVA_HOME/jre\nCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib\nPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin\nexport JAVA_HOME JRE_HOME CLASS_PATH PATH\n\n4.让修改生效\n[root@localhost java]# source /etc/profile\n```\n\n\n注: 如果出现`export =' not a valid identifier`\n```sql\n原因就是你修改的 /etc/profile 文件里\n你加过空格\n\n我的代码如下：\nexport JAVA_HOME = /usr/java/jdk1.7.0_75\nexport PATH = $JAVA_HOME/bin:$PATH\nexport CLASSPATH = .:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n\n修改为如下：\nexport JAVA_HOME=/usr/java/jdk1.7.0_75\nexport PATH=$JAVA_HOME/bin:$PATH\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n将等号两边的空格去掉就可以了 ，大家要注意\n```\n\n##### 2.3.2 配置 Tomcat环境\n参考： http://www.linuxidc.com/Linux/2015-09/123118.htm\n```sql\n# tar -zxvf apache-tomcat-8.0.26.tar.gz // 解压压缩包        \n# mv apache-tomcat-8.0.26 tomcat // 改名\n\n```\n\n注: \n1.在ECS上启动tomcat后，第一次访问时间特别长\n```sql\n2017-04-25 10:16:04 INFO com.world.socket.ServerSocketListener  \n25-Apr-2017 10:18:48.171 INFO [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom CreaecureRandom instance for session ID generation using [SHA1PRNG] took [163,521] milliseconds. \n \n \n这个session ID引起的 \n\n解决办法：在JVM环境中解决 \n打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：securerandom.source=file:/dev/urandom \n替换成securerandom.source=file:/dev/./urandom\n```\n2.Centos打开、关闭、结束tomcat，及查看tomcat运行日志\n```sql\n启动：一般是执行sh tomcat/bin/startup.sh \n停止：一般是执行sh tomcat/bin/shutdown.sh脚本命令 \n查看：执行ps -ef |grep tomcat 输出如下 *** 5144 。。。等等.Bootstrap start 说明tomcat已经正常启动， 5144 就为进程号 pid = 5144 \n杀死：kill -9 5144\n\n\n------------------------linux下实时查看tomcat运行日志-------------------------\n1、先切换到：cd tomcat/logs\n2、tail -f catalina.out\n3、这样运行时就可以实时查看运行日志了\nCtrl+c 是退出tail命令。\n```\n\n##### 2.3.3 配置 Mysql环境\n参考： http://www.linuxidc.com/Linux/2016-09/134992.htm\n\n#### 2.4 投放项目文件\n使用`fileZilla`进行传输文件\n```sql\nTomcat中部署web项目的三种方式：\n1.部署解包的webapp目录\n2.打包的war文件\n3.Manager Web应用程序\n```","tags":["java"],"categories":["server"]},{"title":"Spring boot","url":"/2018/01/15/Web后台/Spring/spring-boot/spring-boot/","content":"### 什么是Spring-boot\nSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程(习惯优于配置)。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。\n\n\n### 核心功能\n1. 独立运行的Spring项目,可以以jar包的形式独立运行, 运行一个Spring boot项目只要通过 `java -jar xx.jar`\n2. 内嵌Tomcat, Jetty, Undertow 无需以war包形式部署项目\n3. 提供starter简化Maven配置\n4. 自动配置Bean, 极大的减少了我们要使用的配置\n\n### 优点\n1. 快速构建项目\n2. 对主流开发框架的无配置集成\n3. 项目可独立运行\n4. 提供运行时的应用监控\n","tags":["Spring"],"categories":["服务器"]},{"title":"组合注解","url":"/2018/01/14/Web后台/Spring/spring-boot/组合注解/","content":"### 组合注解\n> 用一个注解表示其他注解\n\nCombinationAnnocation.java\n\n```java\npackage com.smart.boot.groupAnno;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\nimport java.lang.annotation.*;\n\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n@ComponentScan\npublic @interface CombinationAnnocation {\n    String [] value() default {};\n}\n```\nConfig.java\n\n```java\npackage com.smart.boot.groupAnno;\n\n@CombinationAnnocation\npublic class Config {\n}\n\n```\n\nApplication.java\n```java\npackage com.smart.boot.groupAnno;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Application {\n\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        context.close();\n    }\n}\n```","tags":["Spring"],"categories":["服务器"]},{"title":"异步方法","url":"/2018/01/14/Web后台/Spring/spring-boot/异步方法/","content":"### 异步方法\n> 加入@Async注解可以让普通方法变为异步方法\n\nAsyncTaskService.java\n\n```java\npackage com.smart.boot.asyn;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class AsyncTaskService {\n    /**\n     * 异步方法\n     *\n     * @param i\n     */\n    @Async\n    public void task1(Integer i) {\n        System.out.println(\"执行异步任务\" + i);\n    }\n\n    @Async\n    public void task2(Integer i) {\n        System.out.println(\"执行异步任务+1 \" + (i + 1));\n    }\n}\n```\nConfig.java\n\n```java\npackage com.smart.boot.asyn;\n\nimport org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.scheduling.annotation.AsyncConfigurer;\nimport org.springframework.scheduling.annotation.EnableAsync;\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\nimport java.util.concurrent.Executor;\n\n@Configuration\n@ComponentScan(\"com.smart.boot.asyn\")\n@EnableAsync // 开启异步任务支持\npublic class Config implements AsyncConfigurer {\n    /**\n     * 获得一个基于线程池的 taskExecutor\n     *\n     * @return\n     */\n    @Override\n    public Executor getAsyncExecutor() {\n        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();\n        taskExecutor.setCorePoolSize(5);\n        taskExecutor.setMaxPoolSize(10);\n        taskExecutor.setQueueCapacity(25);\n        taskExecutor.initialize();\n        return taskExecutor;\n    }\n\n    @Override\n    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {\n        return null;\n    }\n}\n```\n\nApplication.java\n```java\npackage com.smart.boot.asyn;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Application {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        AsyncTaskService asyncTaskService = context.getBean(AsyncTaskService.class);\n        for (int i = 0; i < 10; i++) {\n            asyncTaskService.task1(i);\n            asyncTaskService.task2(i);\n        }\n        context.close();\n    }\n}\n```","tags":["Spring"],"categories":["服务器"]},{"title":"Spring 事件监听","url":"/2018/01/14/Web后台/Spring/spring-boot/spring 事件监听/","content":"### Spring 事件监听\n\n#### spring的事件(Application Event)\n**为Bean与Bean之间的消息通信提供了支持, 当第一个Bean处理完一件事之后, 需要另外一个Bean知道并能做出相应的处理, 这时可以通过事件监听来讲一个Bean监听另一个Bean**\n\n#### 观察者模式\n>Spring 事件监听是观察者模式的一种实现 \n\n意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n\n主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n\n何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n\n如何解决：使用面向对象技术，可以将这种依赖关系弱化。\n\n>事件驱动模型简介\n\n事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点：\n\n1. 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）；\n2. 当目标发送改变（发布），观察者（订阅者）就可以接收到改变；\n3. 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。\n<!--more-->\n#### 实现流程\n1.自定义事件\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.ApplicationEvent;\n\npublic class DemoEvent extends ApplicationEvent {\n\n    private String msg;\n\n    public DemoEvent(Object source, String msg) {\n        super(source);\n        this.msg = msg;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n\n    /**\n     * 去做一些事\n     */\n    public void todoSomethings() {\n        System.out.println(\"正在做第一件事 , 做完需要做第二件事\");\n    }\n}\n```\n\n2.定义事件监听器\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DemoListener implements ApplicationListener<DemoEvent> {\n    /**\n     * 对消息进行接受处理\n     * @param event\n     */\n    @Override\n    public void onApplicationEvent(DemoEvent event) {\n        String msg = event.getMsg();\n        System.out.println(\"DemoListener 接受到了消息\" + msg );\n        event.todoSomethings();\n        System.out.println(\"正在做第二件事\");\n    }\n}\n```\n3.发布事件\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class DemoPublisher {\n    /**\n     * 注入ApplicationContext来发布事件\n     */\n    @Autowired\n    ApplicationContext context;\n\n    /**\n     * 发布事件\n     * @param msg\n     */\n    public void publish(String msg) {\n        context.publishEvent(new DemoEvent(this,msg));\n    }\n}\n\n```\n\n4.定义配置类\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@ComponentScan(\"com.smart.boot.event\")\npublic class Config {\n}\n\n```\n\n5.运行\n```java\npackage com.smart.boot.event;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class Application {\n    public static void main(String[] args) {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class);\n        DemoPublisher demoPublisher = context.getBean(DemoPublisher.class);\n        demoPublisher.publish(\"hello songshuiyang\");\n        context.close();\n    }\n}\n\n```\n\n6.实现结果\n```java\nDemoListener 接受到了消息hello songshuiyang\n正在做第一件事 , 做完需要做第二件事\n正在做第二件事\n```\n#### 总结\n1. 实现事件监听可以使业务解耦, 每个模块做好自己的事情即可, \n2. 可用在用户注册功能, eg: http://jinnianshilongnian.iteye.com/blog/1902886\n","tags":["Spring"],"categories":["服务器"]},{"title":"注解Value, Spring EL","url":"/2018/01/14/Web后台/Spring/spring-boot/注解Value/","content":"### @Value用法及配合Spring EL使用\n\n#### spring支持@Value注解获取一些配置信息及加载资源\n\n\n> ELConfig.java\n```java\npackage com.smart.boot.el;\n\nimport org.apache.commons.io.IOUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.Resource;\n\n@Configuration\n@ComponentScan(\"com.smart.boot.el\")\n@PropertySource(\"classpath:el.properties\")\npublic class ELConfig {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n    /**\n     * 注入普通字符串\n     */\n    @Value(\"songsy\")\n    private String str;\n    /**\n     * 通过el注入操作系统属性\n     */\n    @Value(\"# {systemProperties['os.name']}\")\n    private String osName;\n    /**\n     * 表达式结果\n     */\n    @Value(\"#{ T(java.lang.Math).random() * 100.0 }\")\n    private double randomNumber;\n    /**\n     * 注入其他Bean属性\n     */\n    @Value(\"#{eLService.another}\")\n    public String fromAnothor;\n    /**\n     * 注入文件资源\n     */\n    @Value(\"classpath:el.properties\")\n    private Resource testFile;\n    /**\n     * 注入网站资源\n     */\n    @Value(\"http://www.baidu.com\")\n    private Resource testUrl;\n    /**\n     * 注入配置文件\n     */\n    @Value(\"${book.name}\")\n    private String bookName;\n\n    /**\n     * 环境配置\n     * 环境在容器中是一个抽象的集合，是指应用环境的2个方面: profiles和 properties.\n     * profile:\n     * 配置是一个被命名的，bean定义的逻辑组，这些bean只有在给定的profile配置激活时才会注册到容器。不管是XML还是注解，\n     * Beans都有可能指派给profile配置。Environment环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。\n     * Properties:\n     * 扮演一个非常重要的角色,可能来源于一下源码变量:properties文件，JVM properties,system环境变量，JNDI, servlet context parameters上下文参数,\n     * 专门的Properties对象，Maps等等。Environment对象的作用，对于properties来说，是提供给用户方便的服务接口，方便撰写配置、方便解析配置。\n     * 作者：不迷失\n     * 链接：https://www.jianshu.com/p/49e950b0b008\n     * 來源：简书\n     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n     */\n    @Autowired\n    private Environment environment;\n\n    /**\n     * 若使用@Value注入, 则要配置一个PropertySourcesPlaceholderConfigurer\n     *\n     * @return\n     */\n    @Bean\n    public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() {\n        return new PropertySourcesPlaceholderConfigurer();\n    }\n\n    public void print() throws Exception {\n        logger.info(\"str: \" + str);\n        logger.info(\"osName: \" + osName);\n        logger.info(\"randomNumber: \" + String.valueOf(randomNumber));\n        logger.info(\"fromAnothor: \" + fromAnothor);\n        logger.info(\"testFile: \" + IOUtils.toString(testFile.getInputStream()));\n        logger.info(\"testUrl: \" + IOUtils.toString(testUrl.getInputStream()));\n        logger.info(\"bookName: \" + bookName);\n        logger.info(\"environment: \" + environment.getProperty(\"book.author\"));\n    }\n}\n\n```\n\n<!--more-->\n> ELService.java\n```java\npackage com.smart.boot.el;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service(\"eLService\")\npublic class ELService {\n\n    public String another;\n\n    public String getAnother() {\n        return another;\n    }\n\n    @Autowired\n    public void setAnother() {\n        this.another = \"ELService 自动注入\";\n    }\n}\n\n```\n> ELMain.java\n```java\npackage com.smart.boot.el;\n\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class ELMain {\n    public static void main(String[] args) throws Exception {\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ELConfig.class);\n        ELConfig elConfig = context.getBean(ELConfig.class);\n        elConfig.print();\n        context.close();\n    }\n}\n```","tags":["Spring"],"categories":["服务器"]},{"title":"npm scripts","url":"/2018/01/14/Web前端/npm/npm scripts/","content":"### 一、什么是 npm 脚本\nnpm 允许在package.json文件里面，使用scripts字段定义脚本命令。\n```sql\n{\n  // ...\n  \"scripts\": {\n    \"build\": \"node build.js\"\n  }\n}\n```\n上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。\n命令行下使用npm run命令，就可以执行这段脚本。\n```sql\n$ npm run build\n# 等同于执行\n$ node build.js\n```\n这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多\n1. 项目的相关脚本，可以集中在一个地方。\n2. 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。\n3. 可以利用 npm 提供的很多辅助功能。\n\n查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。\n```sql\n$ npm run\n```\n### 二：执行顺序\n如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。\n如果是并行执行（即同时的平行执行），可以使用&符号。\n```sql\n$ npm run script1.js & npm run script2.js\n```\n\n如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号\n```sql\n$ npm run script1.js && npm run script2.js\n```\n\n### 应用\n在 `package.json` 添加以下代码执行`npm run gg` 可以连续执行（hexo g）（hexo d）俩个命令，这样就不用每次执行俩个命令\n```sql\n \"scripts\": {\n    \"gg\": \"hexo g && hexo d\"\n  }\n```\n详见:http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html","tags":["npm"],"categories":["client"]},{"title":"接入银联支付接口","url":"/2018/01/11/Web后台/支付/接入银联支付接口/","content":"吐槽一下：\n\n> 1.银联支付SDK是没有提供独立的jar包的，高大上的银联把示例demo和sdk整合在一起了，支付流程和支付宝支付相似，支付需要到银联的支付页面\n\n> 2.证书说明：其实我们只需要一个邮件上的签名证书文件，官网上文档说的开发者调用接口前需要的其他证书在开发包中目录assets下都有，每个人都一样，没错，每个人都一样\n\n> 3.银联开发平台常常在下午6点发版本，遇到过俩次，第一次感到惊讶:银联网站挂了？不可能呀，过了十多分钟又恢复正常，晕\n\n> 4.代码不够规范，用代码检测工具一片黄色\n```java\n/**\n * @ClassName AcpService\n * @Description acpsdk接口服务类，接入商户集成请可以直接参考使用本类中的方法\n * @date 2016-7-22 下午2:44:37\n * 声明：以下代码只是为了方便接入方测试而提供的样例代码，商户可以根据自己需要，按照技术文档编写。该代码仅供参考，不提供编码，性能，规范性等方面的保障\n */\n```\n<!--more-->\n#### 大致步骤\n\n##### 一：下载demo及sdk\nhttps://open.unionpay.com/ajweb/product/newProDetail?proId=1&cataId=14\n\n##### 二：配置参数：\n\n接入银联支付审核 听头说好像是挺繁琐的，费时费力，接入银联支付设及到下面几个参数，其他的参数银联都帮我们配置好了\n\n1.商户号: 在银联商家技术服务中心可以看到 https://open.unionpay.com/ajweb/index，注意：在测试环境的商户号一致，刚开始我还不相信，通过客服才知道俩个是一样的，在测试账号信息里面可以看到\n\n2.后台通知地址：填写接收银联后台通知的地址，必须外网能访问\n\n3.前台通知地址：填写处理银联前台通知的地址，必须外网能访问\n\n4.签名证书: 在审核成功发送的邮件里面\n\n5.签名证书密码： 在审核成功发送的邮件里面有\n\n##### 三：调用支付接口\n\n```java\nprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\n\nthrows ServletException, IOException {\n\nresp.setContentType(\"text/html; charset=\"+ DemoBase.encoding);\n\n\n//前台页面传过来的\n\nString merId = req.getParameter(\"merId\");\n\nString txnAmt = req.getParameter(\"txnAmt\");\n\n\nMap<String, String> requestData = new HashMap<String, String>();\n\n\n/***银联全渠道系统，产品参数，除了encoding自行选择外其他不需修改***/\n\nrequestData.put(\"version\", DemoBase.version);     //版本号，全渠道默认值\n\nrequestData.put(\"encoding\", DemoBase.encoding);   //字符集编码，可以使用UTF-8,GBK两种方式\n\nrequestData.put(\"signMethod\", SDKConfig.getConfig().getSignMethod()); //签名方法\n\nrequestData.put(\"txnType\", \"01\");                 //交易类型 ，01：消费\n\nrequestData.put(\"txnSubType\", \"01\");              //交易子类型， 01：自助消费\n\nrequestData.put(\"bizType\", \"000201\");             //业务类型，B2C网关支付，手机wap支付\n\nrequestData.put(\"channelType\", \"07\");             //渠道类型，这个字段区分B2C网关支付和手机wap支付；07：PC,平板  08：手机\n\n\n/***商户接入参数***/\n\nrequestData.put(\"merId\", merId);                //商户号码，请改成自己申请的正式商户号或者open上注册得来的777测试商户号\n\nrequestData.put(\"accessType\", \"0\");               //接入类型，0：直连商户 \n\nrequestData.put(\"orderId\",DemoBase.getOrderId());             //商户订单号，8-40位数字字母，不能含“-”或“_”，可以自行定制规则\n\nrequestData.put(\"txnTime\", DemoBase.getCurrentTime());        //订单发送时间，取系统时间，格式为YYYYMMDDhhmmss，必须取当前时间，否则会报txnTime无效\n\nrequestData.put(\"currencyCode\", \"156\");           //交易币种（境内商户一般是156 人民币）\n\nrequestData.put(\"txnAmt\", txnAmt);                   //交易金额，单位分，不要带小数点\n\n//requestData.put(\"reqReserved\", \"透传字段\");              //请求方保留域，如需使用请启用即可；透传字段（可以实现商户自定义参数的追踪）本交易的后台通知,对本交易的交易状态查询交易、对账文件中均会原样返回，商户可以按需上传，长度为1-1024个字节。出现&={}[]符号时可能导致查询接口应答报文解析失败，建议尽量只传字母数字并使用|分割，或者可以最外层做一次base64编码(base64编码之后出现的等号不会导致解析失败可以不用管)。\n\n\n//前台通知地址 （需设置为外网能访问 http https均可），支付成功后的页面 点击“返回商户”按钮的时候将异步通知报文post到该地址\n\n//如果想要实现过几秒中自动跳转回商户页面权限，需联系银联业务申请开通自动返回商户权限\n\n//异步通知参数详见open.unionpay.com帮助中心 下载  产品接口规范  网关支付产品接口规范 消费交易 商户通知\n\nrequestData.put(\"frontUrl\", DemoBase.frontUrl);\n\n\n//后台通知地址（需设置为【外网】能访问 http https均可），支付成功后银联会自动将异步通知报文post到商户上送的该地址，失败的交易银联不会发送后台通知\n\n//后台通知参数详见open.unionpay.com帮助中心 下载  产品接口规范  网关支付产品接口规范 消费交易 商户通知\n\n//注意:1.需设置为外网能访问，否则收不到通知    2.http https均可  3.收单后台通知后需要10秒内返回http200或302状态码 \n\n//    4.如果银联通知服务器发送通知后10秒内未收到返回状态码或者应答码非http200，那么银联会间隔一段时间再次发送。总共发送5次，每次的间隔时间为0,1,2,4分钟。\n\n//    5.后台通知地址如果上送了带有？的参数，例如：http://abc/web?a=b&c=d 在后台通知处理程序验证签名之前需要编写逻辑将这些字段去掉再验签，否则将会验签失败\n\nrequestData.put(\"backUrl\", DemoBase.backUrl);\n\n// 订单超时时间。\n\n// 超过此时间后，除网银交易外，其他交易银联系统会拒绝受理，提示超时。 跳转银行网银交易如果超时后交易成功，会自动退款，大约5个工作日金额返还到持卡人账户。\n\n// 此时间建议取支付时的北京时间加15分钟。\n\n// 超过超时时间调查询接口应答origRespCode不是A6或者00的就可以判断为失败。\n\nrequestData.put(\"payTimeout\", new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date().getTime() + 15 * 60 * 1000));\n\n\n//////////////////////////////////////////////////\n\n//\n\n//       报文中特殊用法请查看 PCwap网关跳转支付特殊用法.txt\n\n//\n\n//////////////////////////////////////////////////\n\n\n/**请求参数设置完毕，以下对请求参数进行签名并生成html表单，将表单写入浏览器跳转打开银联页面**/\n\nMap<String, String> submitFromData = AcpService.sign(requestData,DemoBase.encoding);  //报文中certId,signature的值是在signData方法中获取并自动赋值的，只要证书配置正确即可。\n\n\nString requestFrontUrl = SDKConfig.getConfig().getFrontRequestUrl();  //获取请求银联的前台地址：对应属性文件acp_sdk.properties文件中的acpsdk.frontTransUrl\n\nString html = AcpService.createAutoFormHtml(requestFrontUrl, submitFromData,DemoBase.encoding);   //生成自动跳转的Html表单\n\n\nLogUtil.writeLog(\"打印请求HTML，此为请求报文，为联调排查问题的依据：\"+html);\n\n//将生成的html写到浏览器中完成自动跳转打开银联支付页面；这里调用signData之后，将html写到浏览器跳转到银联页面之前均不能对html中的表单项的名称和值进行修改，如果修改会导致验签不通过\n\nresp.getWriter().write(html);\n\n}\n``` \n##### 异步通知：与支付宝微信异步通知处理相同\n参考于：\nhttps://open.unionpay.com/ajweb/product/newProDetail?proId=1&cataId=14\n","tags":["支付"],"categories":["server"]},{"title":"接入微信扫码支付接口","url":"/2018/01/11/Web后台/支付/接入微信支付接口/","content":"#### 准备条件\n##### 开始之前先看一下微信的几个平台:\n1. 微信公众平台:\n是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。\n平台入口：http://mp.weixin.qq.com。\n2. 微信开放平台:\n微信开放平台是商户APP接入微信支付开放接口的申请入口，通过此平台可申请微信APP支付。\n平台入口：http://open.weixin.qq.com。\n3. 微信商户平台:\n微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。\n平台入口：http://pay.weixin.qq.com\n\n刚开始接入的时候有点昏，各种参数需要到不同的平台找, 不像支付宝一样只有一个开发平台，如果是接入微信扫码支付设及到微信公众平台和微信商户平台，如果是手机app微信支付，设及到微信开放平台和微信商户平台\n\n##### 开通支付功能:\n有了平台账号之后，然后就是开通支付功能，等待审核通过，当然审核过程有可能被退回，大多是描述信息或者经营类别与营业执照描述不一致\n<!--more-->\n#### 微信支付开发:\n> 下面是微信支付的业务流程时序图, 可以看到与支付宝的支付流程主要流程是差不多的，只不过微信扫码可以在本系统完成支付，没有发生页面跳转，可以自己DIY支付页面，只要将支付链接生成二维码图片即可完成支付\n![logo](/images/server/支付/weixin.png)    \n\n##### 接入微信支付步骤\n\n###### 1. 获取支付SDK\n\n gradle:地址    `compile(\"com.github.wxpay:wxpay-sdk:0.0.3\")`\n\n###### 2. 配置参数\n\n主要是如下参数, 可以配置在一个属性文件中方面配置\n\n1、APP ID ，应用ID（在公众平台--基本配置模块中）\n\n2、APP Sercret ，应用秘钥（在公众平台--基本配置模块中）32位数字大小写字母\n\n3、API Key，API的秘钥（在商户平台--API安全中设置）\n\n4、mchID , 商户号（在公众平台---微信支付---商户信息）\n\n5、order_api ， 统一下单API的接口\n\n6、notify_url    交易成功回调的接口的URL\n\n###### 3. 新建一个参数配置类\n\n> WxPcPayConfigImpl.java 继承 WXPayConfig.java\n\n```java\n/**\n * 微信支付PC端 基础属性配置\n */\npublic class WxPcPayConfigImpl implements WXPayConfig {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    // 配置文件地址\n    private static final String FILE_NAME = \"weixin_pc_pay.properties\";\n\n    // 服务号的应用ID\n    public static String APP_ID;\n    // 服务号的应用密钥\n    public static String APP_SECRET;\n    // 服务号的配置token\n    public static String TOKEN;\n    // 商户号\n    public static String MCH_ID;\n    // API密钥\n    public static String API_KEY;\n    // 签名加密方式\n    public static String SIGN_TYPE;\n    // 微信支付证书\n    public static String CERT_PATH;\n    // 异步回调地址\n    public static String NOTIFY_URL;\n    // 是否使用沙箱环境\n    public static boolean IS_USE_SANDBOX;\n    // 证书\n    private static byte[] certData;\n    // INSTANCE\n    private static WxPcPayConfigImpl INSTANCE;\n    // 配置对象\n    private static Configuration configs;\n    // 文件分隔符\n    public final static String SF_FILE_SEPARATOR = System.getProperty(\"file.separator\");//文件分隔符\n    // 二维码图片宽度\n    public final static int QR_IMG_WIDTH = 300;\n    // 二维码图片高度\n    public final static int QR_IMG_HEIGHT = 300;\n\n    /**\n     * 返回配置文件实例\n     *\n     * @return\n     * @throws Exception\n     */\n    public static WxPcPayConfigImpl getInstance() throws Exception {\n        if (INSTANCE == null) {\n            synchronized (WxPcPayConfigImpl.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = new WxPcPayConfigImpl();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n\n    /**\n     * 加载微信配置文件\n     */\n    public static synchronized void init() {\n        if (configs != null) {\n            return;\n        }\n        try {\n            configs = new PropertiesConfiguration(FILE_NAME);\n        } catch (ConfigurationException e) {\n            e.printStackTrace();\n        }\n\n        if (configs == null) {\n            throw new IllegalStateException(\"读取配置文件错误\" + FILE_NAME);\n        }\n        APP_ID = configs.getString(\"appId\");\n        APP_SECRET = configs.getString(\"appSecret\");\n        TOKEN = configs.getString(\"token\");\n        MCH_ID = configs.getString(\"mchId\");\n        API_KEY = configs.getString(\"apiKey\");\n        SIGN_TYPE = configs.getString(\"signType\");\n        CERT_PATH = configs.getString(\"certPath\");\n        IS_USE_SANDBOX = configs.getBoolean(\"isUseSandbox\");\n        NOTIFY_URL = configs.getString(\"notifyUrl\");\n\n        // 加载证书\n        File file;\n        try {\n            // file = new File(CERT_PATH);\n            Resource resource = new ClassPathResource(CERT_PATH);\n            file = resource.getFile();\n            InputStream certStream = new FileInputStream(file);\n            certData = new byte[(int) file.length()];\n            certStream.read(certData);\n            certStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    /**\n     * 获取 App ID\n     *\n     * @return App ID\n     */\n    @Override\n    public String getAppID() {\n        return APP_ID;\n    }\n    /**\n     * 获取 Mch ID\n     *\n     * @return Mch ID\n     */\n    @Override\n    public String getMchID() {\n        return MCH_ID;\n    }\n    /**\n     * 获取 API 密钥\n     *\n     * @return API密钥\n     */\n    @Override\n    public String getKey() {\n        return API_KEY;\n    }\n    /**\n     * 获取商户证书内容\n     *\n     * @return 商户证书内容\n     */\n    @Override\n    public InputStream getCertStream() {\n        ByteArrayInputStream certBis;\n        certBis = new ByteArrayInputStream(this.certData);\n        return certBis;\n    }\n    /**\n     * HTTP(S) 连接超时时间，单位毫秒\n     *\n     * @return\n     */\n    @Override\n    public int getHttpConnectTimeoutMs() {\n        return 8000;\n    }\n    /**\n     * HTTP(S) 读数据超时时间，单位毫秒\n     *\n     * @return\n     */\n    @Override\n    public int getHttpReadTimeoutMs() {\n        return 10000;\n    }\n\n    public byte[] getCertData() {\n        return certData;\n    }\n\n    public void setCertData(byte[] certData) {\n        this.certData = certData;\n    }\n}\n```\n###### 4. new 一个`WXPay`对象\n```java\nWXPay wxAppPay;\nWxPcPayConfigImpl pcConfig = WxPcPayConfigImpl.getInstance();\nwxpay = new WXPay(pcConfig, WXPayConstants.SignType.MD5, WxPcPayConfigImpl.IS_USE_SANDBOX);\n```\n\n\n###### 5. 有了\"对象\"之后就可以发送支付请求了\n```java\n    /**\n     * PC端微信支付请求\n     *\n     * @param domainId 商户订单号取实体类id\n     * @param amount   充值金额\n     * @return 处理结果数据\n     */\n    public Map<String, Object> weixinPay(String domainId, BigDecimal amount, HttpServletRequest request) {\n        Map<String, Object> resultMaps = new HashMap<>();\n        resultMaps.put(\"status\", \"success\");\n\n        HashMap<String, String> data = new HashMap<>();\n        String currentUserName = \"\";\n        if (AccountUtils.getCurrentUser() != null) {\n            if (StringUtils.isNotBlank(AccountUtils.getCurrentUser().getFdNickName())) {\n                currentUserName = AccountUtils.getCurrentUser().getFdNickName();\n            }\n        }\n        String description = currentUserName + \" 账户充值\";\n\n        data.put(\"body\", description);                                  // 商品描述\n        data.put(\"out_trade_no\", domainId);                             // 商户订单号\n        data.put(\"total_fee\", AmountUtils.transAmountToCent(amount));   // 总金额,单位为分\n        data.put(\"spbill_create_ip\", WxUtils.getRemoteIp(request));     // 发起人IP地址\n        data.put(\"notify_url\", WxPcPayConfigImpl.NOTIFY_URL);           // 异步通知地址\n        data.put(\"trade_type\", \"NATIVE\");                               // 此处指定为扫码支付\n        data.put(\"product_id\", domainId);                               // 商品ID,trade_type=NATIVE时（即扫码支付），此参数必传\n\n        Map<String, String> resultMap;\n        try {\n            resultMap = wxpay.unifiedOrder(data);\n            logger.info(\"微信生成二维码返回xml 转成Json\" + JsonFormatUtil.formatJson(resultMap.toString()));\n            System.out.println(resultMap);\n        } catch (Exception e) {\n            e.printStackTrace();\n            logger.error(\"微信支付处理异常\");\n            resultMaps.put(\"status\", \"failed\");\n            return resultMaps;\n        }\n        String returnCode = resultMap.get(\"return_code\");\n        // 返回结果\n        if (\"SUCCESS\".equals(returnCode)) {\n            String resultCode = resultMap.get(\"result_code\");\n            // 处理结果\n            if (\"SUCCESS\".equals(resultCode)) {\n                logger.info(\"订单号：{}生成微信支付码成功\", domainId);\n                String urlCode = resultMap.get(\"code_url\");\n                // 生成二维码\n                logger.info(\"\");\n                // WxUtils.encodeQRCode(urlCode,imgPath);\n                String imgBase64Str = WxUtils.encodeQRCodeBase64(urlCode);\n                // 是否是微信支付\n                resultMaps.put(\"id\", domainId);\n                resultMaps.put(\"isWxPay\", true);\n                resultMaps.put(\"img\", imgBase64Str);\n            } else {\n                String errCodeDes = resultMap.get(\"err_code_des\");\n                logger.info(\"订单号：{}生成微信支付码(系统)失败:{}\", domainId, errCodeDes);\n                resultMaps.put(\"status\", \"failed\");\n                return resultMaps;\n            }\n        } else {\n            String returnMsg = resultMap.get(\"return_msg\");\n            logger.info(\"(订单号：{}生成微信支付码(通信)失败:{}\", domainId, returnMsg);\n            resultMaps.put(\"status\", \"failed\");\n            return resultMaps;\n        }\n        return resultMaps;\n    }\n\n```\n\n微信支付统一下单接口:\n```java\n    /**\n     * 作用：统一下单<br>\n     * 场景：公共号支付、扫码支付、APP支付\n     * @param reqData 向wxpay post的请求数据\n     * @return API返回数据\n     * @throws Exception\n     */\n    public Map<String, String> unifiedOrder(Map<String, String> reqData) throws Exception {\n        return this.unifiedOrder(reqData, config.getHttpConnectTimeoutMs(), this.config.getHttpReadTimeoutMs());\n    }\n```\n###### 6. 生成支付二维码\n这里我是将二维码链接字符串转成字符流 然后生成Base64位的图片字符, 只要在<img src=\"\"> 设置src属性值，就可以完成图片展示，不用考虑生成的图片放在那里\n\n###### 7. 支付完成, 处理异步回调\n\n\n###### 备注： 微信支付是使用的xml进行传输数据，需要将xml转成map，当然微信SDK中也提供了工具类，提供了一些十分用的方法\n```java\npackage com.github.wxpay.sdk;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.util.*;\nimport java.security.MessageDigest;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport com.github.wxpay.sdk.WXPayConstants.SignType;\n\n\npublic class WXPayUtil {\n\n    /**\n     * XML格式字符串转换为Map\n     *\n     * @param strXML XML字符串\n     * @return XML数据转换后的Map\n     * @throws Exception\n     */\n    public static Map<String, String> xmlToMap(String strXML) throws Exception {\n        Map<String, String> data = new HashMap<String, String>();\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder();\n        InputStream stream = new ByteArrayInputStream(strXML.getBytes(\"UTF-8\"));\n        org.w3c.dom.Document doc = documentBuilder.parse(stream);\n        doc.getDocumentElement().normalize();\n        NodeList nodeList = doc.getDocumentElement().getChildNodes();\n        for (int idx=0; idx<nodeList.getLength(); ++idx) {\n            Node node = nodeList.item(idx);\n            if (node.getNodeType() == Node.ELEMENT_NODE) {\n                org.w3c.dom.Element element = (org.w3c.dom.Element) node;\n                data.put(element.getNodeName(), element.getTextContent());\n            }\n        }\n        try {\n            stream.close();\n        }\n        catch (Exception ex) {\n\n        }\n        return data;\n    }\n\n    /**\n     * 将Map转换为XML格式的字符串\n     *\n     * @param data Map类型数据\n     * @return XML格式的字符串\n     * @throws Exception\n     */\n    public static String mapToXml(Map<String, String> data) throws Exception {\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder();\n        org.w3c.dom.Document document = documentBuilder.newDocument();\n        org.w3c.dom.Element root = document.createElement(\"xml\");\n        document.appendChild(root);\n        for (String key: data.keySet()) {\n            String value = data.get(key);\n            if (value == null) {\n                value = \"\";\n            }\n            value = value.trim();\n            org.w3c.dom.Element filed = document.createElement(key);\n            filed.appendChild(document.createTextNode(value));\n            root.appendChild(filed);\n        }\n        TransformerFactory tf = TransformerFactory.newInstance();\n        Transformer transformer = tf.newTransformer();\n        DOMSource source = new DOMSource(document);\n        transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n        StringWriter writer = new StringWriter();\n        StreamResult result = new StreamResult(writer);\n        transformer.transform(source, result);\n        String output = writer.getBuffer().toString(); //.replaceAll(\"\\n|\\r\", \"\");\n        try {\n            writer.close();\n        }\n        catch (Exception ex) {\n        }\n        return output;\n    }\n\n\n    /**\n     * 生成带有 sign 的 XML 格式字符串\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @return 含有sign字段的XML\n     */\n    public static String generateSignedXml(final Map<String, String> data, String key) throws Exception {\n        return generateSignedXml(data, key, SignType.MD5);\n    }\n\n    /**\n     * 生成带有 sign 的 XML 格式字符串\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @param signType 签名类型\n     * @return 含有sign字段的XML\n     */\n    public static String generateSignedXml(final Map<String, String> data, String key, SignType signType) throws Exception {\n        String sign = generateSignature(data, key, signType);\n        data.put(WXPayConstants.FIELD_SIGN, sign);\n        return mapToXml(data);\n    }\n\n\n    /**\n     * 判断签名是否正确\n     *\n     * @param xmlStr XML格式数据\n     * @param key API密钥\n     * @return 签名是否正确\n     * @throws Exception\n     */\n    public static boolean isSignatureValid(String xmlStr, String key) throws Exception {\n        Map<String, String> data = xmlToMap(xmlStr);\n        if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) {\n            return false;\n        }\n        String sign = data.get(WXPayConstants.FIELD_SIGN);\n        return generateSignature(data, key).equals(sign);\n    }\n\n    /**\n     * 判断签名是否正确，必须包含sign字段，否则返回false。使用MD5签名。\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @return 签名是否正确\n     * @throws Exception\n     */\n    public static boolean isSignatureValid(Map<String, String> data, String key) throws Exception {\n        return isSignatureValid(data, key, SignType.MD5);\n    }\n\n    /**\n     * 判断签名是否正确，必须包含sign字段，否则返回false。\n     *\n     * @param data Map类型数据\n     * @param key API密钥\n     * @param signType 签名方式\n     * @return 签名是否正确\n     * @throws Exception\n     */\n    public static boolean isSignatureValid(Map<String, String> data, String key, SignType signType) throws Exception {\n        if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) {\n            return false;\n        }\n        String sign = data.get(WXPayConstants.FIELD_SIGN);\n        return generateSignature(data, key, signType).equals(sign);\n    }\n\n    /**\n     * 生成签名\n     *\n     * @param data 待签名数据\n     * @param key API密钥\n     * @return 签名\n     */\n    public static String generateSignature(final Map<String, String> data, String key) throws Exception {\n        return generateSignature(data, key, SignType.MD5);\n    }\n\n    /**\n     * 生成签名. 注意，若含有sign_type字段，必须和signType参数保持一致。\n     *\n     * @param data 待签名数据\n     * @param key API密钥\n     * @param signType 签名方式\n     * @return 签名\n     */\n    public static String generateSignature(final Map<String, String> data, String key, SignType signType) throws Exception {\n        Set<String> keySet = data.keySet();\n        String[] keyArray = keySet.toArray(new String[keySet.size()]);\n        Arrays.sort(keyArray);\n        StringBuilder sb = new StringBuilder();\n        for (String k : keyArray) {\n            if (k.equals(WXPayConstants.FIELD_SIGN)) {\n                continue;\n            }\n            if (data.get(k).trim().length() > 0) // 参数值为空，则不参与签名\n                sb.append(k).append(\"=\").append(data.get(k).trim()).append(\"&\");\n        }\n        sb.append(\"key=\").append(key);\n        if (SignType.MD5.equals(signType)) {\n            return MD5(sb.toString()).toUpperCase();\n        }\n        else if (SignType.HMACSHA256.equals(signType)) {\n            return HMACSHA256(sb.toString(), key);\n        }\n        else {\n            throw new Exception(String.format(\"Invalid sign_type: %s\", signType));\n        }\n    }\n\n\n    /**\n     * 获取随机字符串 Nonce Str\n     *\n     * @return String 随机字符串\n     */\n    public static String generateNonceStr() {\n        return UUID.randomUUID().toString().replaceAll(\"-\", \"\").substring(0, 32);\n    }\n\n\n    /**\n     * 生成 MD5\n     *\n     * @param data 待处理数据\n     * @return MD5结果\n     */\n    public static String MD5(String data) throws Exception {\n        java.security.MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] array = md.digest(data.getBytes(\"UTF-8\"));\n        StringBuilder sb = new StringBuilder();\n        for (byte item : array) {\n            sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));\n        }\n        return sb.toString().toUpperCase();\n    }\n\n    /**\n     * 生成 HMACSHA256\n     * @param data 待处理数据\n     * @param key 密钥\n     * @return 加密结果\n     * @throws Exception\n     */\n    public static String HMACSHA256(String data, String key) throws Exception {\n        Mac sha256_HMAC = Mac.getInstance(\"HmacSHA256\");\n        SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"HmacSHA256\");\n        sha256_HMAC.init(secret_key);\n        byte[] array = sha256_HMAC.doFinal(data.getBytes(\"UTF-8\"));\n        StringBuilder sb = new StringBuilder();\n        for (byte item : array) {\n            sb.append(Integer.toHexString((item & 0xFF) | 0x100).substring(1, 3));\n        }\n        return sb.toString().toUpperCase();\n    }\n}\n```\n\n\n参考于: \nhttp://mp.weixin.qq.com\n\nhttp://open.weixin.qq.com\n\nhttp://pay.weixin.qq.com\n\n\n","tags":["支付"],"categories":["server"]},{"title":"PC网站上如何接入支付宝网关支付功能","url":"/2018/01/10/Web后台/支付/PC网站上如何接入支付宝网关支付功能/","content":"### 一: 应用场景\n1. 主要应用于一些交易平台商品订单支付，账户充值，线上收费这些有支付需求的交易\n\n2. 用户通过支付宝PC收银台完成支付，交易款项即时给到商户支付宝账户\n\n![logo](/images/server/支付/taobao.png)\n\n![logo](/images/server/支付/12306.png) \n\n<!--more-->\n\n### 二: 准备条件\n1. 一个公司, 不是公司的话是不能接入商户支付宝网关支付的, 当然支付宝是分个人用户和商户用户的, 如果是个人网站的话可以贴个自己收款二维码上去进行收款, 如果是正在运营的商户企业收取费用的话是要接入支付宝网关支付功能进行收费, 这样的话可以看起来bigger更高\n\n2. 企业或个体工商户，具有真实有效的营业执照，且支付宝账户名称需与营业执照主体一致\n\n3. 网站通过ICP备案，能正常访问，页面显示完整，有明确的运营内容与完整的商品信息。\n\n### 三：接入支付宝支付功能步骤\n\n#### 第一步：创建应用\n要在应用中使用支付宝开放产品的接口能力：\n\n1. 需要先去蚂蚁金服开放平台，在开发者中心创建登记您的应用，此时将获得应用唯一标识（APPID）\n2. 请在【功能信息】中点击【添加功能】，选择【电脑网站支付】\n3. 提交审核（需要上传公司营业执照,填写法人身份信息等等），等待审核通过，该应用正式可以使用\n\n> TIPS：电脑网站支付接口需签约后才能调用\n\n#### 第二步：配置密钥\n\n开发者调用接口前需要先生成RSA密钥，RSA密钥包含应用私钥(APP_PRIVATE_KEY)、应用公钥(APP_PUBLIC_KEY）。生成密钥后在开放平台管理中心进行密钥配置，配置完成后可以获取支付宝公钥(ALIPAY_PUBLIC_KEY)。\n\n\n**用途：**\n支付宝发送信息给商户系统时，使用支付宝私钥对数据进行加签，商户获取到支付宝加签的信息后使用支付宝公钥对数据进行验签，得到正确的数据。\n商户系统给支付宝发送信息时，使用商户自己的私钥对数据加签，支付宝获取到数据后使用商家上传的公钥进行验签。\n\n\n**加签步骤:**\n\n1.筛选\n\n获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign与sign_type参数。\n\n2.排序\n\n将筛选的参数按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。\n拼接\u000b将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&字符连接起来，此时生成的字符串为待签名字符串。商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝\n\n3.拼接\n\n将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&字符连接起来，此时生成的字符串为待签名字符串。\n\n4.加签\n\n商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝\n\n\n**验签步骤：**\n\n与加签步骤一致，只不过是延签是使用公钥算出sign值，两方算出的sign值都一致的话则延签成功\n\n#### 第三步：搭建和配置开发环境\n1. 需要到支付宝开发平台下载服务端SDK,打包即用, 十分方便\n\n2. 配置参数\n```java\nAlipayClient alipayClient = new DefaultAlipayClient(URL,APP_ID,APP_PRIVATE_KEY,FORMAT,CHARSET,ALIPAY_PUBLIC_KEY,SIGN_TYPE);\n\n// URL:支付宝网关（固定） https://openapi.alipay.com/gateway.do, 如果是沙箱环境的话: https://openapi.alipaydev.com/gateway.do\n// APP_ID:创建应用时获取, 支付宝提供\n// APP_PRIVATE_KEY: 应用私钥, 运用支付宝提供的工具进行生成\n// FORMAT: json（固定）\n// CHARSET: 编码格式\n// ALIPAY_PUBLIC_KEY: 支付宝公钥, 由支付宝提供\n// SIGN_TYPE： 加签类型，商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2\n```\n> 配置完参数之后就可以调用支付宝的支付接口了, 十分方便, 阿里阿里 !!!\n3. 配置完参数之后先来看一下支付的调用流程：\n![logo](/images/server/支付/step.png) \n\n4. 接下来就是发起支付请求了\n```java\nimport com.alipay.api.*;\nimport com.alipay.api.request.*; \npublic void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException,IOException { \n//获得初始化的AlipayClient \nAlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\", APP_ID, APP_PRIVATE_KEY, FORMAT, CHARSET, ALIPAY_PUBLIC_KEY, SIGN_TYPE);\n//创建支付请求的对应request\nAlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();\n//设置请求参数及回跳地址和通知地址\n alipayRequest.setBizContent(\n\"{\" + \" \\\"out_trade_no\\\":\\\"20150320010101001\\\",\n\" + \" \\\"total_amount\":88.88,\n\" + \" \\\"subject\\\":title\\\",\n\" + \" \\\"body\\\":\\\"Iphone6 16G\\\",\n\" + }\");\n//跳转地址就是支付完成之后，支付宝自动执行页面重定向,就是跳转到我们设置的页面\nalipayRequest.setReturnUrl(\"http://www.songshuiyang.site/return_url\"); \n//通知地址就是支付宝会根据API中商户传入的notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统。\nalipayRequest.setNotifyUrl(\"http://www.songshuiyang.site/notify_url\");\nString form=\"\";\ntry { \n //调用SDK生成html表单\n  form = alipayClient.pageExecute(alipayRequest).getBody(); \n} catch (AlipayApiException e) { \n  e.printStackTrace(); \n} \n//直接将完整的表单html输出到页面\nhttpResponse.setContentType(\"text/html;charset=\" + CHARSET); httpResponse.getWriter().write(form); httpResponse.getWriter().flush(); httpResponse.getWriter().close(); \n} \n```\n\n**支付接口生成的html代码**\n```html\n<form name=\"punchout_form\" method=\"post\" action=\"https://openapi.alipay.com/gateway.do?charset=utf-8&method=alipay.trade.page.pay&sign=jsgXRru7b%2FHLO76SMPoj6lIuCnKJ9lkLo%2BTPIKfetqMOd8kyp2zYBZ456Dvf0eb4SyYgUrOjAgTkNW2AkgJh%2BbLJDu3eAtQVAUEEzFGy2Ix3uE3j3lPLHZDs1cF7g8vw7hwfmEqe8CE8OCJ%2B79J0Hp6YFOH8vnJEDUPvjla2AsCO0mhAsnYxm30rmqgDqJPfZLytOvRD5FF%2BoBd4UPH%2Budk7vCn9lEX%2BkEe7YBa3E7l6vWxXz%2BJDKGL9ZMHNtUzYUaid%2F%2BIugVLqtECybldd8YDZUFnz92Iq%2BOwIL09MzNtb6iC9AypfQxlTseFezDihBn%2Fey5itIovqntbLLdxt2g%3D%3D&return_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment%2Findex&notify_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment2%2Falipay_notify&version=1.0&app_id=123456789101554&sign_type=RSA2&timestamp=2018-01-01+14%3A27%3A50&alipay_sdk=alipay-sdk-java-dynamicVersionNo&format=json\">\n   <input type=\"hidden\" name=\"biz_content\" value=\"{&quot;out_trade_no&quot;:&quot;160b06765224a9aee66a6654541b947f&quot;,&quot;total_amount&quot;:&quot;0.01&quot;,&quot;subject&quot;:&quot;江西广而易科技有限公司  账户充值&quot;,&quot;body&quot;:&quot;充值金额: 0.01&quot;,&quot;product_code&quot;:&quot;FAST_INSTANT_TRADE_PAY&quot;}\">\n     <input type=\"submit\" value=\"立即支付\" style=\"display:none\" >\n</form>\n<script>document.forms[0].submit();</script>\n```\n\n**注意**\n1. action 链接后面的sign值就是签名字符串, 用于校验数据的来源还有数据有没有被修改\n2. biz_content 是业务参数\n3. html输出到页面后会跳转到支付的支付页面\n\n#### 第四步：扫码支付进行的步骤\n1.支付\n ![logo](/images/server/支付/pagePay.jpg) \n\n2.支付成功会自动跳转到商户页面(同步通知) \n\n> 就是前面设置的 alipayRequest.setReturnUrl(\"http://www.songshuiyang.site/return_url\");,这部是支付完成之后支付宝的处理程序进行了页面重定向, 不是支付宝主动触发的。\n ![logo](/images/server/支付/paysuccess.png) \n\n3.系统后台收到异步通知\n\n> 对于PC网站支付的交易，在用户支付完成之后，支付宝会根据API中商户传入的alipayRequest.setNotifyUrl(\"http://www.songshuiyang.site/notify_url\");，通过POST请求的形式将支付结果作为参数通知到商户系统，该方式的作用是页面跳转同步通知没有处理订单更新，需要通过异步通知的方式去通知系统后台更新流水\n\n4.进行异步通知处理\n\n> 程序执行完后必须打印输出“success”。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）；\n\n处理代码:\n```java\n//将异步通知中收到的所有参数都存放到map中\nMap<String, String> paramsMap = ...;\n//调用SDK验证签名\nboolean signVerified = AlipaySignature.rsaCheckV1(paramsMap, ALIPAY_PUBLIC_KEY, CHARSET, SIGN_TYPE) \nif(signVerfied){ \n// TODO 验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验\n1、商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，\n2、判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），\n3、校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方\n4、验证app_id是否为该商户本身。\n// 二次校验成功，继续商户自身业务处理，处理完成之后返回success\n\n} else {\n // TODO 验签失败则记录异常日志，并在response中返回failure. \n} \n```\n\n**注意：** \n1.  这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致延签失败\n\n5. 如果是异步通知处理失败\n> 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付异步通知；需要自己手动向支付宝发送查询请求，根据查询出来的结果确定该交易是否成功\n\n```java\nAlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\",\"app_id\",\"your private_key\",\"json\",\"GBK\",\"alipay_public_key\",\"RSA2\"); \n//创建查询请求的对应request\nAlipayTradeQueryRequest request = new AlipayTradeQueryRequest();\nrequest.setBizContent(\"{\" + \n\"\\\"out_trade_no\\\":\\\"20150320010101001\\\",\n\" + \"\\\"trade_no\\\":\\\"2014112611001004680073956707\\\"\" + \n\"}\"); \nAlipayTradeQueryResponse response = alipayClient.execute(request); \nif(response.isSuccess()){ \n//交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）、TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）、TRADE_SUCCESS（交易支付成功）、TRADE_FINISHED（交易结束，不可退款）\n    System.out.println(\"调用成功\"); \n} else {\n    System.out.println(\"调用失败\"); \n\n```\n\n**注意：** \n1.  这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致签名失败\n\n#### 五：支付宝网关支付API\n|     接口英文名 | 接口中文    | \n    | --------   | -----:   | \n    | alipay.trade.page.pay       | 统一收单下单并支付页面接口 |\n    |  alipay.trade.refund        | 统一收单交易退款接口      |\n    | alipay.trade.fastpay.refund.query      | 统一收单交易退款查询接口 |\n    |  alipay.trade.query       | 统一收单线下交易查询接口     |\n    | alipay.trade.close       | 统一收单交易关闭接口 |\n    |  alipay.data.dataservice.bill.downloadurl.query       | 查询对账单下载地址      |\n\n#### 六： 使用沙箱环境进行测试\n\n> 蚂蚁沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑（当前沙箱支持产品请参考“沙箱支持产品列表”）。\u000b在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。\n \n ![logo](/images/server/支付/sandbox.png)\n \n> 可以体验一把土豪的感觉, 不用在真实环境下使用一分钱测试联调大法了\n\n#### 七：总结\n\n1. 支付宝的支付接口进行了高度封装，可以拿过来直接使用，不必关心怎样签名&验签、HTTP接口请求这些处理\n\n2. 在进行数据传输通信的同时，需要校验传输数据的来源，数据有没有进行修改，防止恶意数据攻击\n\n \n#### 注:\n本文内容参考支付宝开放平台文档内容, 一切以官方文档为准, 链接地址: https://open.alipay.com/platform/home.htm","tags":["支付"],"categories":["server"]},{"title":"Ascii 160空格问题","url":"/2018/01/09/Web后台/Java/ASCII 160 空格/","content":"### 场景\n>获取从http传输过来的字符串的时候，碰到解析字符串不能分割字符串的情况\n```java\nString str = doc.get(0); // str = \"江西省 赣州市\"\nString [] area = str.spilt(\"\\\\s+\");\n```\n运行上面的代码的时候发现不能截取字符串, 初步怀疑是编码问题，然而经过验证发现并不是,然后就通过字符串截取成 char 字符发现，该char字符ASCII是160,\n马上查找资料发现是空格分两种编码格式: 1: 普通的空格,ASCII码为32  2:第二种是 网页上的 &nbsp 空格,ASCII为160, 才发现空格也是有多种情况\n\n解决方法:\n```java\n// 需要将ASCII为160的空格转成普通的空格\nstr = str.replaceAll(\"[\\\\s\\\\u00A0]+\", \" \");\n\n```\n\n","tags":["Java"],"categories":["server"]},{"title":"编程思想笔记","url":"/2018/01/09/Web后台/Java/Java编程思想/第二章-一切皆是对象/","content":"##### # 用引用操纵对象\n> 在Java的世界里，一切都被视为对象，尽管一切都看成是对象，但操纵的标识符实际上是对象的一个引用,可将这一\n                                                   情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对电视机的控制，那么手上拿着的是遥控板，而非电视机。\n```sql\n遥控器  -->   电视\n引用    -->   对象\n```\n\n##### # 高精度数字\n```sql\nBigInteger 支持任意精度的整数。也就是说，我们可精确表示任意大小的整数值，同时在运算过程中不会丢失任何信息。\nBigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。\n\n对应于我们针对主类型执行的操作。也就是说，能对 int 或 float 做的事情，对 BigInteger 和 BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。\n```\n\n##### # 基本数据类型默认值\n\n##### 类文件的限制\n1. 每个文件只能有一个public类, 也可以没有public，如果有的话必须与文件名相同\n\n","tags":["Java"],"categories":["server"]},{"title":"Mysql 如何设置字段自动获取当前时间","url":"/2017/12/17/Web后台/数据库/Mysql 如何设置字段自动获取当前时间/","content":"应用场景：\n```sql\n1、在数据表中，要记录每条数据是什么时候创建的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录创建时间；\n\n2、在数据库中，要记录每条数据是什么时候修改的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录修改时间；\n```\n\n实现方式:\n```sql\n--修改CreateTime 设置默认时间 CURRENT_TIMESTAMP \nALTER TABLE `table_name`\nMODIFY COLUMN  `created_date` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' ;\n\n\n--修改 UpdateTime 设置 默认时间 CURRENT_TIMESTAMP   设置更新时间为 ON UPDATE CURRENT_TIMESTAMP \n\nALTER TABLE `table_name`\nMODIFY COLUMN `last_modified_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间' ;\n```\n\n转自：https://www.cnblogs.com/lhj588/p/4245719.html","tags":["db"],"categories":["server"]},{"title":"Druid Monitor","url":"/2017/12/11/Web后台/数据库/Druid Monitor/","content":"## Druid Monitor监控JavaSE和JavaWeb\n\n效果图:\n![logo](/images/server/数据库/druidMonitor.png) \n\nhttp://blog.csdn.net/binglovezi/article/details/50610269","tags":["druid"],"categories":["server"]},{"title":"Maven 41种骨架","url":"/2017/11/18/Web后台/Maven/maven 骨架/","content":"Maven 的41种骨架功能介绍\n ...>mvn archetype:generate\n```sql\n1: internal -> appfuse-basic-jsf (创建一个基于Hibernate，Spring和JSF的Web应用程序的原型) \n2: internal -> appfuse-basic-spring (创建一个基于Hibernate，Spring和Spring MVC的Web应用程序的原型) \n3: internal -> appfuse-basic-struts (创建一个基于Hibernate，Spring和Struts 2的Web应用程序的原型) \n4: internal -> appfuse-basic-tapestry (创建一个基于Hibernate, Spring 和 Tapestry 4的Web应用程序的原型) \n5: internal -> appfuse-core (创建一个基于 Hibernate and Spring 和 XFire的jar应用程序的原型) \n6: internal -> appfuse-modular-jsf (创建一个基于 Hibernate，Spring和JSF的模块化应用原型) \n7: internal -> appfuse-modular-spring (创建一个基于 Hibernate, Spring 和 Spring MVC 的模块化应用原型) \n8: internal -> appfuse-modular-struts (创建一个基于 Hibernate, Spring 和 Struts 2 的模块化应用原型) \n9: internal -> appfuse-modular-tapestry (创建一个基于 Hibernate, Spring 和 Tapestry 4 的模块化应用原型) \n10: internal -> maven-archetype-j2ee-simple (一个简单的J2EE的Java应用程序) \n11: internal -> maven-archetype-marmalade-mojo (一个Maven的 插件开发项目 using marmalade) \n12: internal -> maven-archetype-mojo (一个Maven的Java插件开发项目) \n13: internal -> maven-archetype-portlet (一个简单的portlet应用程序) \n14: internal -> maven-archetype-profiles () \n15: internal -> maven-archetype-quickstart () \n16: internal -> maven-archetype-site-simple (简单的网站生成项目) \n17: internal -> maven-archetype-site (更复杂的网站项目) \n18: internal -> maven-archetype-webapp (一个简单的Java Web应用程序) \n19: internal -> jini-service-archetype (Archetype for Jini service project creation) \n20: internal -> softeu-archetype-seam (JSF+Facelets+Seam Archetype) \n21: internal -> softeu-archetype-seam-simple (JSF+Facelets+Seam (无残留) 原型) \n22: internal -> softeu-archetype-jsf (JSF+Facelets 原型) \n23: internal -> jpa-maven-archetype (JPA 应用程序) \n24: internal -> spring-osgi-bundle-archetype (Spring-OSGi 原型) \n25: internal -> confluence-plugin-archetype (Atlassian 聚合插件原型) \n26: internal -> jira-plugin-archetype (Atlassian JIRA 插件原型) \n27: internal -> maven-archetype-har (Hibernate 存档) \n28: internal -> maven-archetype-sar (JBoss 服务存档) \n29: internal -> wicket-archetype-quickstart (一个简单的Apache Wicket的项目) \n30: internal -> scala-archetype-simple (一个简单的scala的项目) \n31: internal -> lift-archetype-blank (一个 blank/empty liftweb 项目) \n32: internal -> lift-archetype-basic (基本（liftweb）项目) \n33: internal -> cocoon-22-archetype-block-plain ([http://cocoapacorg2/maven-plugins/]) \n34: internal -> cocoon-22-archetype-block ([http://cocoapacorg2/maven-plugins/]) \n35: internal -> cocoon-22-archetype-webapp ([http://cocoapacorg2/maven-plugins/]) \n36: internal -> myfaces-archetype-helloworld (使用MyFaces的一个简单的原型) \n37: internal -> myfaces-archetype-helloworld-facelets (一个使用MyFaces和Facelets的简单原型) \n38: internal -> myfaces-archetype-trinidad (一个使用MyFaces和Trinidad的简单原型) \n39: internal -> myfaces-archetype-jsfcomponents (一种使用MyFaces创建定制JSF组件的简单的原型) \n40: internal -> gmaven-archetype-basic (Groovy的基本原型) \n41: internal -> gmaven-archetype-mojo (Groovy mojo 原型)\n```\n原文: https://www.cnblogs.com/iusmile/archive/2012/11/14/2770118.html\n","tags":["maven"],"categories":["服务器"]},{"title":"Spring Aop","url":"/2017/11/18/Web后台/Spring/Spring Aop/","content":"## Spring Aop\n\n### 一: 概念 \n\n#### 1. 什么是AOP\n \n在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。\n\n####  2. 为什么要用Aop\n利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。在不改变原有方法的基础添加一些功能 , 比如:日志记录，性能统计，安全控制，事务处理，异常处理等等。\n\n<!--more-->\n\n####  3. Aop 术语\n> 连接点(JoinPoint)\n\n 程序执行到某个特定位置 , Spring 仅支持方法级的连接点(方法执行前，方法完成后，抛出异常后)\n\n> 切点(Pointcut)\n\n 从连接点的基础上引出的概念，是指特定的连接点，一个类有好多方法,每个方法又有多个连接点，则需要切点来限定一个小范围的连接点\n \n> 通知、增强处理(Advice)\n\n   就是指你所需要添加的功能及这个功能什么时候(通知)实现 , 比如一个业务方法需要实现日志功能 , 那么就需要专门在一个地方定义好需要做什么，然后定义什么时候执行(方法执行前？，方法完成后？，抛出异常？。。。)\n  \n   Spring 切面可应用的 5 种通知类型：\n   1. Before——在方法调用之前调用通知\n   2. After——在方法完成之后调用通知，无论方法执行成功与否\n   3. After-returning——在方法执行成功之后调用通知\n   4. After-throwing——在方法抛出异常后进行通知\n   5. Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为\n\n> 引入(introduction)\n \n  特殊的增强，为类添加一些属性和方法\n\n> 切面(Aspect)\n\n 切面由切点和增强组成 , 及包括横切逻辑的定义，也包括切点的定义, \n\n> 目标对象(Target)\n\n 增强逻辑的织入目标类 , 如果没有Aop,那么目标对象就要自己实现(日志记录，性能统计，安全控制，事务处理，异常处理)这些功能，那么一个方法就会变成很杂乱\n \n> 织入(Weaing)\n\n 将增强添加到目标对象的具体连接点上, Spring使用动态代理织入\n \n \n Aop有三种织入方式\n 1. 编译期织入\n 2. 类装载期织入\n 3. 动态代理织入: 在运行期间为目标类添加增强生成子类的方式\n### 二: Spring Aop 的应用\n\n> Spring Aop的使用一般通过俩种方式:第一种是通过注解的，第二种是通过xml配置\n\n#### 通过注解的方式实现Aop\n\n1. 第一步 Maven 导包\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <parent>\n        <groupId>ecut</groupId>\n        <artifactId>spring-parent</artifactId>\n        <version>0.0.1-SNAPSHOT</version>\n    </parent>\n\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>ecut</groupId>\n    <artifactId>spring-aop</artifactId>\n    <packaging>jar</packaging>\n    <version>0.0.1-SNAPSHOT</version>\n    <name>spring-aop</name>\n\n    <dependencies>\n        <!-- spring 核心 -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-beans</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n        </dependency>\n\n        <!-- spring aop -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aspects</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n\n        <!--test-->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-test</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <scope>test</scope>\n        </dependency>\n\n        <!-- 日志 -->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-api</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n        </dependency>\n\n\n    </dependencies>\n    <build>\n        <finalName>spring-aop</finalName>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-surefire-plugin</artifactId>\n                <configuration>\n                    <skip>true</skip>\n                </configuration>\n            </plugin>\n\n            <!--@Override is not allowed when implementing interface method-->\n            <!-- 编码和编译和JDK版本 -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>2.3.2</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>utf8</encoding>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n2. 第二步 编写一个基于 @AspectJ 的切面\n```java\npackage com.aop.learn.aspectj;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author songshuiyang\n * @title: @Aspect\n * @description:\n * @date 2017/11/15\n */\n@Component\n@Aspect // 通过该注解将该类标识为一个切面\npublic class PreGreetingAspect {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 前置增强, greetTo方法执行前触发此方法\n     *\n     */\n    @Before(\"execution(* greetTo(..))\") // 定义切点和增强类型（前置增强,可以带任何参数，和任意的返回值）\n    public void beforeGreeting() { // 增强的横切逻辑\n        logger.info(\"How are you Aspect 使用了前置增强\");\n    } \n}\n\n```\n3: 编写目标对象\n\n> Writer.java 接口\n\n```java\npackage com.aop.learn.service;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15\n */\npublic interface Writer {\n\n    public void greetTo();\n\n}\n\n\n```\n> NativeWaiter.java 实现方法\n```java\npackage com.aop.learn.service.impl;\n\nimport com.aop.learn.annotation.NeedTest;\nimport com.aop.learn.service.Writer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15\n */\n@Service\npublic class NativeWaiter implements Writer {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void greetTo() {\n        logger.info(\"执行方法体: \");\n    }\n    \n}\n```\n\n4：Spring配置文件\n> applicationContext.xml\n```xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"\n    http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n    http://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n\thttp://www.springframework.org/schema/aop\n\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n\">\n    <context:component-scan base-package=\"com.aop.learn\"/>\n\n    <!--基于@AspectJ切面的驱动器,自动为Spring容器中匹配@AspectJ切面的Bean创建代理，完成切面织入-->\n    <aop:aspectj-autoproxy/>\n    <!--<aop:aspectj-autoproxy proxy-target-class=\"true\"/> 表示使用CGLib动态代理技术织入增强-->\n\n\n</beans>\n```\n\n5: 测试类\n\n测试基类\n> BaseTest.java\n```java\npackage com.aop.test;\n\nimport org.junit.runner.RunWith;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15 \n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(\"classpath:/spring/applicationContext.xml\")\npublic class BaseTest extends AbstractJUnit4SpringContextTests {\n\n    public Logger logger = LoggerFactory.getLogger(this.getClass());\n}\n\n```\n\n测试类\n> AspectTest.java\n\n````java\npackage com.aop.test.service;\n\nimport com.aop.learn.service.AgentWriter;\nimport com.aop.learn.service.Seller;\nimport com.aop.learn.service.Writer;\nimport com.aop.test.BaseTest;\nimport org.junit.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * @author songshuiyang\n * @title: 基于spring配置使用@AspectJ切面\n * @description:\n * @date 2017/11/15 \n */\npublic class AspectTest extends BaseTest {\n\n \n    @Autowired\n    private Writer writer;\n    \n    /**\n     * 基于spring配置使用@AspectJ切面\n     */\n    @Test\n    public void test1() {\n        writer.greetTo();\n    }\n}\n\n````\n6: 效果图,完成 aop增强\n![logo](/images/server/springaop/aop.png)\n \n\n#### \n\n#### \n#### \n#### \n\n\n#### 通过xml schema的方式实现Aop\n\n> applicationContext-schema.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    http://www.springframework.org/schema/beans/spring-beans.xsd\n\n\n\thttp://www.springframework.org/schema/aop\n\thttp://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n\n    <!-- aop:config 配置一个基于Schema的切面，aop:config 可以定义多个切面-->\n    <aop:config proxy-target-class=\"true\">\n        <!--aop:pointcut 配置命名切点,可以被其他增强引用-->\n        <aop:pointcut id=\"greetToPointcut\"\n                      expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..))\"/>\n        <aop:pointcut id=\"bindParmPointcut\"\n                      expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..)) and args(clientName)\"/>\n\n        <!-- aop:advisor 是切点和增强的复合体,仅包含一个切点和增强-->\n        <aop:advisor advice-ref=\"advisorMethods\"\n                     pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* serveTo(..))\"/>\n\n        <!--aop:aspect 元素标签定义切面,其内部可以定义多个增强-->\n        <aop:aspect ref=\"adviceMethods\">\n            <!-- aop:before前置增强 method 增强方法， pointcut 切点表达式-->\n            <aop:before method=\"preGreeting\"\n                        pointcut-ref=\"greetToPointcut\"/>\n            <!-- aop:before后置增强-->\n            <aop:after-returning method=\"afterGreeting\"\n                                 pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* name(..))\"\n                                 returning=\"retVal\"/>\n            <!-- 测试绑定连接点信息-->\n            <aop:after method=\"bindParmGreet\"\n                       pointcut-ref=\"bindParmPointcut\"/>\n        </aop:aspect>\n\n\n    </aop:config>\n\n    <!--增强方法所在的Bean-->\n    <bean id=\"adviceMethods\" class=\"com.aop.learn.schema.AdviceMethods\"/>\n    <bean id=\"nativeWaiter\" class=\"com.aop.learn.service.impl.NativeWaiter\"/>\n    <bean id=\"advisorMethods\" class=\"com.aop.learn.schema.AdvisorMethods\"/>\n\n</beans>\n```\n\n>AdviceMethods.java\n```java\npackage com.aop.learn.schema;\n\n/**\n * @author songshuiyang\n * @title: Schema 用作增强的方法\n * @description:\n * @date 2017/11/18 \n */\npublic class AdviceMethods {\n    /**\n     * 前置增强\n     */\n    public void preGreeting() {\n        System.out.println(\"-------------前置增强\");\n    }\n\n    /**\n     * 后置增强\n     *\n     * @param retVal\n     */\n    public void afterGreeting(String retVal) {\n        System.out.println(\"-------------后置增强,返回的参数\" + retVal);\n    }\n\n    /**\n     * 绑定连接点信息\n     *\n     * @param clientName\n     */\n    public void bindParmGreet(String clientName) {\n        System.out.println(\"-------------绑定连接点信息 的参数\" + clientName);\n\n    }\n\n}\n\n```\n\n>NativeWaiter.java\n```java\npackage com.aop.learn.service.impl;\n\nimport com.aop.learn.annotation.NeedTest;\nimport com.aop.learn.service.Writer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/15\n */\n@Service\npublic class NativeWaiter implements Writer {\n\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Override\n    public void greetTo(String clientName) {\n        logger.info(\"-------------greetTo \" + clientName);\n    }\n\n    @Override\n    public void greetTo(String clientName, Integer age) {\n        logger.info(\"-------------greetTo \" + clientName + \"  \" + age + \"岁\");\n    }\n\n    @Override\n    public void serveTo(String clientName) {\n        logger.info(\"-------------serveTo \" + clientName);\n    }\n\n    @Override\n    @NeedTest()\n    public void nestTo() {\n        logger.info(\"开始执行 nestTo() 函数\");\n    }\n\n    @Override\n    public String name() {\n        return \"宋水阳\";\n    }\n\n    @Override\n    public void throwExcetion() {\n        throw new IllegalArgumentException(\"抛出异常了\");\n    }\n}\n\n```\n\n>AdvisorMethods.java\n```java\npackage com.aop.learn.schema;\n\nimport org.springframework.aop.MethodBeforeAdvice;\n\nimport java.lang.reflect.Method;\n\n/**\n * @author songshuiyang\n * @title: aop:advisor 是切点和增强的复合体,仅包含一个切点和增强\n * @description:\n * @date 2017/11/18\n */\npublic class AdvisorMethods implements MethodBeforeAdvice {\n\n    @Override\n    public void before(Method method, Object[] args, Object taget) throws Throwable {\n        System.out.println(\"--------------执行aop:advisor增强----------------\");\n        System.out.println(\"获取的参数\" + args[0]);\n    }\n}\n\n```\n\n","tags":["Spring"],"categories":["服务器"]},{"title":"myBatis笔记","url":"/2017/11/14/Web后台/mybatis/mybatis笔记/","content":"### mybatis foreach标签\n> foreach 标签中 item属性名如果和其他参数中同名(如以下代码:item=\"id\" 和 if test=\"id != null\" 同名),即使没有传入id参数,SQL也会执行 AND id = #{id}\n#### mapper文件:\n```xml\n    <select id=\"findPageList\" parameterType=\"map\" resultType=\"user\">\n        SELECT *\n        FROM user\n        <where>\n            <if test=\"IN_id != null\">\n                id IN\n                <foreach collection=\"IN_id\" index=\"index\" item=\"id\" open=\"(\" separator=\",\" close=\")\">\n                    #{id}\n                </foreach>\n            </if>\n            <if test=\"id != null\">\n              AND id = #{id}\n            </if>\n        </where>\n    </select>\n```\n#### dao层\n```java\n    List<User> findPageList(Map<String, Object> map);\n```\n#### 测试方法\n```xml\n    @Test\n    public void test2() {\n        Map<String, Object> map = new HashMap<String, Object>();\n        List<Integer> idList = new ArrayList<Integer>();\n        idList.add(1);\n        idList.add(4);\n        idList.add(5);\n        map.put(\"IN_id\", idList);\n        userMapper.findPageList(map);\n    }\n```\n#### 结果\n````java\n==>  Preparing: SELECT * FROM user WHERE id IN ( ? , ? , ? ) AND id = ? \n==> Parameters: 1(Integer), 4(Integer), 5(Integer), 5(Integer)\n<==      Total: 1\n````","tags":["mybatis"],"categories":["服务器"]},{"title":"Spring aop execution","url":"/2017/11/07/Web后台/Spring/Spring aop execution/","content":"> execution() 是最常见的切点函数,语法形式为\n```java\nexcution(<修饰符模式> ? <返回类型模式> <方法名模式>(<参数模式>) <异常模式>?) \n```\n<!--more-->\n> 有代码有真相:\n```java\npackage com.aop.learn.aspectj;\n\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author songshuiyang\n * @title: execution() 实例\n * @description:\n * @date 2017/11/15 23:05\n */\n@Aspect\n@Component\npublic class ExecutionAspect {\n\n    /**\n     * 匹配所有目标类的public方法\n     */\n    @Before(\"execution(public * *(..))\")\n    public void beforeAspect(){\n\n    }\n    /**\n     * 匹配所有以To为后缀的方法\n     */\n    @Before(\"execution(* *To(..))\")\n    public void beforeAspect1(){\n\n    }\n    /**\n     * 匹配Waiter接口中的所有方法\n     */\n    @Before(\"execution(* com.aop.learn.service.Writer.*(..))\")\n    public void beforeAspect2(){\n\n    }\n    /**\n     * 匹配Waiter接口中及其实现类的方法\n     */\n    @Before(\"execution(* com.aop.learn.service.Writer+.*(..))\")\n    public void beforeAspect3(){\n\n    }\n    /**\n     * 匹配 com.aop.learn.service 包下所有类的所有方法\n     */\n    @Before(\"execution(* com.aop.learn.service.*(..))\")\n    public void beforeAspect4(){\n\n    }\n    /**\n     * 匹配 com.aop.learn.service 包,子孙包下所有类的所有方法\n     */\n    @Before(\"execution(* com.aop.learn.service..*(..))\")\n    public void beforeAspect5(){\n\n    }\n    /**\n     * 匹配 包名前缀为com的任何包下类名后缀为ive的方法,方法必须以Smart为前缀\n     */\n    @Before(\"execution(* com..*.*ive.Smart*(..))\")\n    public void beforeAspect6(){\n\n    }\n    /**\n     * 匹配 save(String name,int age) 函数\n     */\n    @Before(\"execution(* save(String,int))\")\n    public void beforeAspect7(){\n\n    }\n    /**\n     * 匹配 save(String name,*) 函数 第二个参数为任意类型\n     */\n    @Before(\"execution(* save(String,*))\")\n    public void beforeAspect8(){\n\n    }\n    /**\n     * 匹配 save(String name,..) 函数 除第一个参数固定外,接受后面有任意个入参且入参类型不限\n     */\n    @Before(\"execution(* save(String,..))\")\n    public void beforeAspect9(){\n\n    }\n    /**\n     * 匹配 save(String+) 函数  String+ 表示入参类型是String的子类\n     */\n    @Before(\"execution(* save(String+))\")\n    public void beforeAspect10(){\n\n    }\n\n\n}\n\n```","tags":["Spring"],"categories":["服务器"]},{"title":"Spring Task","url":"/2017/11/07/Web后台/Spring/Spring Task/","content":"## Spring Task\n>spring task作为定时任务的处理,是Spring自带的一个设定时间自动任务调度,提供了两种方式进行配置，一种是注解的方式，而另外一种就是XML配置方式了。\n\n<!--more-->\n### 基于XML配置文件的方式\n>applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:task=\"http://www.springframework.org/schema/task\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/task\n    http://www.springframework.org/schema/task/spring-task.xsd\">\n\n    <!--使用配置文件的方式,注册 xmlTaskJob bean中的job1方法,每隔一秒执行 -->\n    <task:scheduled-tasks>\n         <task:scheduled ref=\"xmlTaskJob\" method=\"job1\" cron=\"*/1 * * * * ?\"/>\n    </task:scheduled-tasks>\n\n    <context:component-scan base-package=\"com.learn.schedule.service\"/>\n</beans>\n\n```\n>XmlTaskJob.Java\n```java\npackage com.learn.schedule.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Service;\n\n\n/**\n * @author songshuiyang\n * @title: 基于xml文件配置的定时任务\n * @description:\n * @date 2017/11/7 22:20\n */\n@Service\npublic class XmlTaskJob {\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    public void job1() {\n        logger.info(\"基于xml文件配置的定时任务，每隔一秒执行\");\n    }\n\n}\n```\n>Test.java\n````java\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/11/7 22:45\n */\npublic class Test {\n    public static void main(String[] args) {\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/spring/applicationContext.xml\");\n    }\n}\n````\n### 基于注解配置文件的方式更简单\n>applicationContext.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:task=\"http://www.springframework.org/schema/task\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\thttp://www.springframework.org/schema/context\n\thttp://www.springframework.org/schema/context/spring-context.xsd\n    http://www.springframework.org/schema/task\n    http://www.springframework.org/schema/task/spring-task.xsd\">\n\n    <!-- 启动定时器 基于注解-->\n    <task:annotation-driven/>\n\n    <context:component-scan base-package=\"com.learn.schedule.service\"/>\n</beans>\n```\n>AnnotationTaskJob.Java\n```java\npackage com.learn.schedule.service;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author songshuiyang\n * @title: 基于注解配置的定时任务\n * @description:\n * @date 2017/11/7 22:42\n */\n@Component\npublic class AnnotationTaskJob {\n    private Logger logger = LoggerFactory.getLogger(this.getClass());\n\n    @Scheduled(cron = \"*/2 * * * * ?\") //每2秒执行一次\n    public void job() {\n        logger.info(\"基于注解配置的定时任务，每隔俩秒执行\");\n    }\n}\n```\n>效果:\n![logo](/images/server/spring-schedule.gif) ","tags":["Spring"],"categories":["服务器"]},{"title":"Spring","url":"/2017/10/24/Web后台/Spring/学习笔记/","content":"### 轻量级(重量级)的框架 \n> 轻量级框架和重量级框架的区别是什么？很多人以为是以框架之间的耦合性强弱作为判断标准。其实不然，实际上是以启动程序需要的资源来决定。比如，EJB启动的时候，需要消耗大量的资源，内存，CPU等，所以是重量级。而Spring则不，所以是轻量级框架。就是看加载的资源 spring也不能说是轻量级的 EJB默认在应用启动的时候把所有资源和服务都加载进来而spring则是你定制服务 需要什么开什么 如果把spring的所有服务都用上的话 可以认为你是用了一个重量级的框架 实质还是看框架所需要的系统资源大小.\n\n### IOC 底层原理使用到的技术\n\n1. xml配置文件\n    `<bean id=\"user\" class=\"java.com.ecut.User\">`\n   \n2. dom4j解析xml配置文件\n\n3. 工厂设计模式\n\n4. 反射","tags":["Spring"],"categories":["服务器"]},{"title":"Git初始配置","url":"/2017/10/22/Web后台/编译构建部署版本工具/git/git初始配置/","content":"## 使用Git的前的初始配置\n\n### 1. 配置提交时的用户名与邮件名称(注:只是标识本次commit是谁提交的)\n1.1 通过命令的方式\n```sql\n$ git config --global user.name \"songshuiyang\"\n$ git config --global user.email songshiuyang@foxmail.com\n\n注: global 全局配置,在此电脑上的所有项目的git提交都会用这个用户名和邮件\n```\n1.2 通过修改配置文件的方式\n\n```sql\n文件路径: 用户目录/.gitconfig  文件\n把name email改成(新增)自己的配置即可\n[user]\n\tname = songshuiyang\n\temail = songshiuyang@foxmail.com\n```\n### 2. 配置 短命令\n2.1 通过命令的方式\n```sql\n$ git config --global alias.st status\n$ git config --global alias.ci commit\n$ git congig --global alias.co checkout\n$ git congig --global alias.br branch\n```\n2.2 通过修改配置文件的方式\n```sql\n[alias]\n    co = checkout\n    ci = commit\n    st = status\n    cm = commit -m\n    br = branch\n    bm = branch -m\n    bd = branch -D\n    cb = checkout -b\n    df = diff\n    ls = log --stat\n    lp = log -p\n    plo = pull origin\n    plode = pull origin develop\n    pho = push origin\n```\n### 3. 配置文件\n>Git的三个配置文件\n1. 版本库级别的配置文件,文件路径: `项目路径/.git/config`\n2. 全局配置文件, 文件路径: `用户目录/.gitconfig` \n3. 系统级配置文件,文件路径: `安装目录/etc目录下`\n\n优先级: 版本库级别的配置文件 >  全局配置文件  > 系统级配置文件\n\n### 4. 文件 `.git/index `\n\n实际上就是一个包括文件索引的目录树,像是一个虚拟的工作区,记录了文件名和文件的状态信息(时间戳和文件长度),文件的内容保存在`.git/objects目录下`,文件索引建立了文件和对象库中对象实体之间的对应\n\n工作区,版本区,暂存区原理图\n\n![git](/images/server/git/git-image.jpg)\n\n\n\n","tags":["git"],"categories":["server"]},{"title":"编译构建部署版本工具","url":"/2017/10/14/Web后台/编译构建部署版本工具/git/如何修改Git commit的信息/","content":"转自：\nhttp://www.cnblogs.com/shenh062326/p/git.html","tags":["git"],"categories":["server"]},{"title":"Hibernate Validator","url":"/2017/10/14/Web后台/Hibernate/Hibernate Validator/","content":"### Hibernate Validator\nHibernate Validator 是 Bean Validation 的参考实现 。Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。\n在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。\n\n#### 1. Bean Validation 中内置的 constraint\n|注解            |          作用|\n| --------       | :----: |\n| @Valid         |   被注释的元素是一个对象，需要检查此对象的所有字段值  |\n|@Valid\t        |    被注释的元素是一个对象，需要检查此对象的所有字段值\n|@Null\t |   被注释的元素必须为 null\n|@NotNull\t |   被注释的元素必须不为 null\n|@AssertTrue\t |   被注释的元素必须为 true\n|@AssertFalse\t |   被注释的元素必须为 false\n|@Min(value)\t |   被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n|@Max(value)\t |   被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n|@DecimalMin(value) |   \t被注释的元素必须是一个数字，其值必须大于等于指定的最小值\n|@DecimalMax(value) |   \t被注释的元素必须是一个数字，其值必须小于等于指定的最大值\n|@Size(max, min)\t |   被注释的元素的大小必须在指定的范围内\n|@Digits (integer, fraction) |   \t被注释的元素必须是一个数字，其值必须在可接受的范围内\n|@Past\t |   被注释的元素必须是一个过去的日期\n|@Future\t |   被注释的元素必须是一个将来的日期\n|@Pattern(value)\t |   被注释的元素必须符合指定的正则表达式\n\n#### 2. Hibernate Validator 附加的 constraint\n| 注解            |           作用|\n|------------     |:-------:|\n|@Email\t被注释的元素必须是电子邮箱地址\n|@Length(min=, max=)\t| 被注释的字符串的大小必须在指定的范围内\n|@NotEmpty\t| 被注释的字符串的必须非空\n|@Range(min=, max=)\t| 被注释的元素必须在合适的范围内\n|@NotBlank\t| 被注释的字符串的必须非空\n|@URL(protocol=,host=,    port=, regexp=, flags=)\t|被注释的字符串必须是一个有效的url\n|@CreditCardNumber | 被注释的字符串必须通过Luhn校验算法， 银行卡，信用卡等号码一般都用Luhn 计算合法性\n|@ScriptAssert (lang=, script=, alias=)\t|要有Java Scripting API 即JSR 223 (\"Scripting for the JavaTM Platform\")的实现\n|@SafeHtml(whitelistType=, additionalTags=)|classpath中要有jsoup包\n#### 举个栗子\n```java\npublic class User {  \n      \n    @NotBlank  \n    private String name;  \n      \n    //年龄要大于18岁  \n    @Min(18)  \n    private int age;  \n  \n    @Email  \n    private String email;  \n      \n    //嵌套验证  \n    @Valid  \n    private Product products;  \n      \n    ... //省略getter，setter  \n}  \n  \npublic class Product {  \n      \n    @NotBlank  \n    private String name;  \n      \n    //价格在10元-50元之间  \n    @Range(min=10,max=50)  \n    private int price;  \n      \n    ... //省略getter，setter  \n} \n```\n转自:http://blog.csdn.net/u011851478/article/details/51842157\n","tags":["Hibernate"],"categories":["server"]},{"title":"编译构建部署版本工具","url":"/2017/10/14/Web后台/编译构建部署版本工具/grandle/","content":"### Grandle\n![gradle](/images/server/gradle.gif)\n\n#### 易百教程\nhttp://www.yiibai.com/gradle/\n\n#### Gradle学习系列之一——Gradle快速入门\n\nhttp://www.cnblogs.com/CloudTeng/p/3417762.html\n\n#### android grandle\n\nhttp://www.jianshu.com/p/9df3c3b6067a","tags":["java"],"categories":["server"]},{"title":"github","url":"/2017/10/08/技术/github/","content":"### watch、star、fork 的使用\n\n#### watch\n>对于别人的项目，默认自己都处于 Not watching 的状态，当你选择 Watching，表示你以后会关注这个项目的所有动态，这个项目以后只要发生变动，如被别人提交了 pull request、被别人发起了issue等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。\n\n#### star\n\n>当你点击 star，表示你喜欢这个项目或者通俗点，可以把他理解成朋友圈的点赞吧，表示对这个项目的支持\n\n#### fork\n>当选择 fork，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步（注意）。","tags":["web"],"categories":["技术"]},{"title":"计算属性","url":"/2017/10/05/Web前端/计算属性/","content":"计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。\n\n这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：\n```html\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\n```javascript\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\n\n","tags":["vue"],"categories":["client"]},{"title":"v-model v-bind","url":"/2017/10/05/Web前端/v-model和v-bind的区别/","content":"Mustache (双大括号写法)不能在 HTML 属性中使用，应使用 v-bind 指令：\n```aidl\n<div v-bind:id=\"dynamicId\"></div>\n```\n\n这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除：\n```aidl\n<button v-bind:disabled=\"someDynamicCondition\">Button</button>\n```\n1. v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=\"表达式\"\n\n2. v-bind用于绑定属性和数据 ，其缩写为“ : ” 也就是v-bind:id  === :id  \n\n3. v-model用在表单控件上的，用于实现双向数据绑定，所以如果你用在除了表单控件以外的标签是没有任何效果的。\n\n> v-bind\n```aidl\n<!-- 绑定一个属性 -->\n<img v-bind:src=\"imageSrc\">\n<!-- 缩写 -->\n<img :src=\"imageSrc\">\n<!-- 内联字符串拼接 -->\n<img :src=\"'/path/to/images/' + fileName\">\n<!-- class 绑定 -->\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n<!-- style 绑定 -->\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n<!-- 绑定一个有属性的对象 -->\n<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n<!-- 通过 prop 修饰符绑定 DOM 属性 -->\n<div v-bind:text-content.prop=\"text\"></div>\n<!-- prop 绑定。“prop”必须在 my-component 中声明。-->\n<my-component :prop=\"someThing\"></my-component>\n<!-- 通过 $props 将父组件的 props 一起传给子组件 -->\n<child-component v-bind=\"$props\"></child-component>\n<!-- XLink -->\n<svg><a :xlink:special=\"foo\"></a></svg>\n```","tags":["vue"],"categories":["client"]},{"title":"Vue.js","url":"/2017/10/03/Web前端/Vue/","content":"### 前缀 $，实例属性与方法\n这些只是Vue的命名规则，为了缺分普通变量属性，避免我们自己声明或者添加自定义属性导致覆\n### 生命周期\nbeforecreated：el 和 data 并未初始化 \n\ncreated:完成了 data 数据的初始化，el没有\n\nbeforeMount：完成了 el 和 data 初始化 \n\nmounted ：完成挂载\n\n<!--more-->\n\n生命周期\n\n![lifecyc](/images/client/lifecycle.jpg)\n\n生命周期钩子\n\n![life](/images/client/vue Lifecycle hooks.png)\n\n钩子函数\n\n钩子函数就是指再所有函数执行前，我先执行了的函数，即 钩住 我感兴趣的函数，只要它执行，我就先执行,这个解释666\n\n### 双向绑定\n\nv-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。\n\n在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。\n\n### 数据\n \n如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：\n\n```json\ndata: {\n  newTodoText: '',\n  visitCount: 0,\n  hideCompletedTodos: false,\n  todos: [],\n  error: null\n}\n```\n### 一个对象的 v-for\n\n```html\n<div v-for=\"(value, key, index) in object\">\n  {{ index }}. {{ key }}: {{ value }}\n</div>\n```\n```angularjs\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      firstName: 'John',\n      lastName: 'Doe',\n      age: 30\n    }\n  }\n})\n```\n索引 key value\n\n````html\n<div v-for=\"(value, key, index) in object\">\n  {{ index }}. {{ key }}: {{ value }}\n</div>\n````\n\n```html\n<!-- 阻止单击事件冒泡 -->\n<a v-on:click.stop=\"doThis\"></a>\n<!-- 提交事件不再重载页面 -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n<!-- 修饰符可以串联 -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n<!-- 只有修饰符 -->\n<form v-on:submit.prevent></form>\n<!-- 添加事件侦听器时使用事件捕获模式 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n### vue模板只能有一个根对象\n```sql\n<template>\n  <h2>底部</h2>\n  <span v-text=\"msgFromFather\"></span>\n</template>\n```\n报错\n```sql\nComponent template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.\n```\n原来vue模板只能有一个根对象\n所以你想要出现正常的效果，你的用一个div来或是别的标签来包裹全部的元素\n```html\n<template>\n   <div>\n\t <h2>底部</h2>\n\t <span v-text=\"msgFromFather\"></span>\n   </div>\n</template>\n```\n\n\n\n\n\n","tags":["vue"],"categories":["client"]},{"title":"其他插件","url":"/2017/10/01/技术/其他插件/","tags":["web"],"categories":["技术"]},{"title":"嵌入网易云插件","url":"/2017/10/01/随笔/网易云/","content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=355 height=86 src=\"//music.163.com/outchain/player?type=2&id=28411368&auto=1&height=66\"></iframe>\n\n\n\n\n","tags":["web"],"categories":["随笔"]},{"title":"增加畅言功能","url":"/2017/10/01/技术/增加畅言功能/","content":"## 畅言- 专业的社会化评论系统\n>网址:https://changyan.kuaizhan.com/\n\n添加功能:\n1. 根据上面的网址注册\n2. 复制 畅言秘钥(SourceID)\n3. 复制以下代码，并粘贴到您网页源代码的```<body>与</body>```之间想要出现畅言评论框的位置。如果您的网站使用了模板，请将代码粘贴到模板代码中。\n```aidl\n<div id=\"SOHUCS\" sid=\"请将此处替换为配置SourceID的语句\"></div>\n<script charset=\"utf-8\" type=\"text/javascript\" src=\"https://changyan.sohu.com/upload/changyan.js\" ></script>\n<script type=\"text/javascript\">\nwindow.changyan.api.config({\nappid: 'cytf5fPKF',\nconf: 'prod_ee3a22e2c13174e193691fbc93e3cbc8'\n});\n</script>\n```\n效果:\n![view](/images/畅言.png)\n\n网站需要备案,不然只有15天的试用期:\n\nICP备案： 只要网站在国内不管网站大小都需要在工信部网站在线申请备案号，但提供的审核资料可能就是不真实的，因为工信部不会去实际的核实。\n工信部要求的仅仅是有备案号即视为合法网站","tags":["web"],"categories":["技术"]},{"title":"nodeJs","url":"/2017/10/01/Web前端/nodeJs/","content":"# Node.js\nNode.js 让 JavaScript 编写服务器端应用程序成为可能。它建立在 JavaScript V8（C++ 编写的） 运行时之上，所以它很快。最初，它旨在为应用程序提供服务器环境，但是开发人员开始利用它来创建工具，帮助他们本地的任务自动化。此后，一个全新基于 Node 工具（如 Grunt 和 Gulp）的生态系统，使得前端开发改头换面。\n\n要使用 Node.js 中的这些工具（或包），我们需要一种有效的方式来安装和管理它们。这就要用到node 包管理器： npm 了。它能够安装你想要的包，而且提供一个强大接口来使用它们。在使用 npm 之前，首先得在系统上安装 Node.js。\n\n## NPM（node package manager）node包管理器\n\n>将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。\n\n### package.json包描述信息\n\n如果我们的项目依赖了很多package，一个一个地安装那将是个体力活。我们可以将项目依赖的包都在package.json这个文件里声明，然后一行命令搞定\n\n```\nnpm install\n```\n\n### 安装方式\n\n本地安装：package会被下载到当前所在目录，也只能在当前目录下使用。\n\n全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。'\n\n### devDependencies和dependencies的区别\n使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如：\n\n--save-dev\n\n--save\n\n但是当安装新包的时候如何让它保持最新呢？我们可以使用 –save 标识。\n\n在 package.json 文件里面提现出来的区别就是，使用 --save-dev 安装的 插件，被写入到 devDependencies 对象里面去，而使用 --save 安装的插件，责被写入到 dependencies 对象里面去。\n\n那 package.json 文件里面的 devDependencies  和 dependencies 对象有什么区别呢？\n\ndevDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的。","tags":["npm"],"categories":["client"]},{"title":"枚举类","url":"/2017/09/29/Web后台/Java/枚举类/","content":">枚举是用来构建常量数据结构的模板，这个模板可扩展。枚举的使用增强了程序的健壮性\n## 1. 常量\n```aidl\npublic enum Color {\n     \n     RED, GREEN, BLANK, YELLOW \n \n}\n```\n\n## 2. switch \n```\npublic class B {\n \n    public static void main(String[] args) {\n \n        showColor( Color.RED );\n \n    }\n \n    static void showColor(Color color){\n        switch ( color ) {\n        case BLANK:\n            System.out.println( color );\n            break;\n        case RED :\n            System.out.println( color );\n            break;\n        default:\n            System.out.println( color );\n            break;\n        }\n         \n    }\n}\n```\n\n## 3. 自定义函数\n```aidl\npublic enum Color {\n     \n     RED(\"红色\", 1), GREEN(\"绿色\", 2), BLANK(\"白色\", 3), YELLO(\"黄色\", 4);\n     \n     \n    private String name ;\n    private int index ;\n     \n    private Color( String name , int index ){\n        this.name = name ;\n        this.index = index ;\n    }\n     \n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getIndex() {\n        return index;\n    }\n    public void setIndex(int index) {\n        this.index = index;\n    }\n     \n``` \n\n","tags":["Java"],"categories":["server"]},{"title":"Spring Assert","url":"/2017/09/29/Web后台/Spring/Assert 的学习/","content":"## Assert（当要判断一个方法传入的参数时，我们就可以使用断言。）\n>package org.springframework.util\n\n### 1. notNull(Object object) \n\n当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null；\n\n### 2. isTrue(boolean expression) / isTrue(boolean expression, String message) \n\n当 expression 不为 true 抛出异常；\n\n### 3. notEmpty(Collection collection) / notEmpty(Collection collection, String message) \n\n当集合未包含元素时抛出异常。\n\nnotEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断；\n\n### 4. hasLength(String text) / hasLength(String text, String message)  \n\n当 text 为 null 或长度为 0 时抛出异常；\n\n### 5. hasText(String text) / hasText(String text, String message)  \n\ntext 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常；\n\n### 6. isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message)  \n\n如果 obj 不能被正确造型为 clazz 指定的类将抛出异常；\n\n### 7. isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message)  \n\nsubType 必须可以按类型匹配于 superType，否则将抛出异常；","tags":["Spring"],"categories":["服务器"]},{"title":"Hibernate 问题记录","url":"/2017/09/24/Web后台/Hibernate/hibernate问题集合/","content":"### org.hibernate.MappingException: Unknown entity常见问题\n\n1. 可能原因一\n\n 检查实体类是否导入的是 javax.persistence 下的包\n \n2. 可能原因二\n\n 没有在cfg文件中加入 *.hbm.xml造成的\n \n3. hibernate版本问题,一代版本一代神\n\n  4.5 版本\n  ```\n  ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).build();\n  ```\n  5.2 版本\n  ```\n  ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build();\n  ```\n  \n  ","tags":["Hibernate"],"categories":["server"]},{"title":"Hibernate 例子","url":"/2017/09/23/Web后台/Hibernate/Hibernate/","content":"## 概述:\n>面向Java环境的对象/关系数据库映射工具,用于将面向对象模型表示的对象映射到基于SQL的关系模型的数据结构中,消除那些针对特定数据库厂商的SQL代码,并把结果集从表格式的形式转换成值对象的形式\n\n<!--more-->\n## Hibernate的数据库操作\n### 直接采用了POJO(普通的传统的Java对象)作为持久化类\n```$xslt\npackage com.hibernate.entity;\n\nimport javax.persistence.*;\n\n/**\n * @author songshuiyang\n * @title:\n * @description:\n * @date 2017/9/23 23:41\n */\n@Entity /*标明持久化类*/\n@Table(name = \"user\")\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键生成策略\n    private String id;\n\n    private String name;\n\n    private int sex;\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getSex() {\n        return sex;\n    }\n\n    public void setSex(int sex) {\n        this.sex = sex;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", sex=\" + sex +\n                '}';\n    }\n}\n\n```\nHibernate基本上是使用了JPA的标准注解(javax.persistence)\n>JPA\n 1. JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。\nSun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。\n\n2. JPA是一种规范，而Hibernate是它的一种实现。除了Hibernate，还有EclipseLink(曾经的toplink)，OpenJPA等可供选择，所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。\n\n###  配置文件 (#.properties , XML配置文件的形式)\n```aidl\n<?xml version=\"1.0\" encoding=\"GBK\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n        \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n<hibernate-configuration>\n  <session-factory>\n    <!-- 指定连接数据库所用的驱动 -->\n    <property name=\"connection.driver_class\">com.mysql.jdbc.Driver</property>\n    <!-- 指定连接数据库的url，其中hibernate是本应用连接的数据库名 -->\n    <property name=\"connection.url\">jdbc:mysql://localhost/ecut</property>\n    <!-- 指定连接数据库的用户名 -->\n    <property name=\"connection.username\">root</property>\n    <!-- 指定连接数据库的密码 -->\n    <property name=\"connection.password\">root</property>\n    <!-- 指定连接池里最大连接数 -->\n    <property name=\"hibernate.c3p0.max_size\">20</property>\n    <!-- 指定连接池里最小连接数 -->\n    <property name=\"hibernate.c3p0.min_size\">1</property>\n    <!-- 指定连接池里连接的超时时长 -->\n    <property name=\"hibernate.c3p0.timeout\">5000</property>\n    <!-- 指定连接池里最大缓存多少个Statement对象 -->\n    <property name=\"hibernate.c3p0.max_statements\">100</property>\n    <property name=\"hibernate.c3p0.idle_test_period\">3000</property>\n    <property name=\"hibernate.c3p0.acquire_increment\">2</property>\n    <property name=\"hibernate.c3p0.validate\">true</property>\n    <!-- 指定数据库方言 -->\n    <property name=\"dialect\">org.hibernate.dialect.MySQL5InnoDBDialect</property>\n    <!-- 根据需要自动创建数据表 -->\n    <property name=\"hbm2ddl.auto\">update</property><!--①-->\n    <!-- 显示Hibernate持久化操作所生成的SQL -->\n    <property name=\"show_sql\">true</property>\n    <!-- 将SQL脚本进行格式化后再输出 -->\n    <property name=\"hibernate.format_sql\">true</property>\n\n    <mapping class=\"com.hibernate.entity.User\"/>\n\n  </session-factory>\n</hibernate-configuration>\n```\n\n###  测试方法\n```aidl\npublic class UserManagerTest {\n    @Test\n    public void test1(){\n        // 实例化Configuration，\n        Configuration conf = new Configuration().configure();\n        ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build();\n        // 以Configuration实例创建SessionFactory实例\n        SessionFactory sf = conf.buildSessionFactory(serviceRegistry);\n        // 创建Session\n        Session sess = sf.openSession();\n        // 开始事务\n        Transaction tx = sess.beginTransaction();\n        // 创建消息对象\n        User user = new User();\n        // 设置消息标题和消息内容\n       user.setName(\"hibernate\");\n       user.setSex(12);\n       sess.save(user);\n        // 提交事务\n        tx.commit();\n        // 关闭Session\n        sess.close();\n        sf.close();\n\n    }\n}\n```\n\n","tags":["Hibernate"],"categories":["server"]},{"title":"Hibernate笔记","url":"/2017/09/23/Web后台/Hibernate/Hibernate笔记/","content":"## hibernate.properties \n\n> 使用 hibernate.properties 文件配置Hibernate 需要在代码里面手动添加持久化类,所以在实际开发中不使用hibernate.property 文件作为配置文件的原因\n","tags":["Hibernate"],"categories":["server"]},{"title":"Java位运算","url":"/2017/09/22/Web后台/Java/Java位运算/","content":"### 与运算符 &\nint a=129;\n\nint b=128;\n\na & b = 128\n\n解析:\n\n“a”的值是129，转换成二进制就是10000001，而“b”的值是128，转换成二进制就是10000000。根据与运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128。\n\n### 或运算 |\nint a=129;\n\nint b=128;\n\na & b = 129\n\n解析:\n\na 的值是129，转换成二进制就是10000001，而b 的值是128，转换成二进制就是10000000，根据或运算符的运算规律，只有两个位有一个是1，结果才是1，可以知道结果就是10000001，即129。\n\n### 非运算符 ~\n\n如果位为0，结果是1，如果位为1，结果是0\n\n\n### 异或运算符 ^\n\n异或运算符是用符号“^”表示的，其运算规律是：\n\n两个操作数的位中，相同则结果为0，不同则结果为1。下面看一个简单的例子。\n\nint a=15;\n\nint b=2;\n\n\na^b a 与 b 异或的结果是：13\n\n分析上面的程序段：a 的值是15，转换成二进制为1111，而b 的值是2，转换成二进制为0010，根据异或的运算规律，可以得出其结果为1101 即13。\n\n","tags":["Java"],"categories":["server"]},{"title":"Java移位运算","url":"/2017/09/22/Web后台/Java/Java移位运算/","content":"\n ``` >>      :     右移运算符 ```\n \n res = 20 >> 2; \n\n20的二进制为 0001 0100，右移2位后为 0000 0101，则结果就为 res = 5;\n\nres = -20 >> 2;\n\n-20的二进制为其正数的补码加1，即 1110 1011，右移2位后为 1111 1100，结果为 res = -6;\n\n\n ``` <<      :     左移运算符 ```\n\n << 是与>>对应的左移运算符，表示将exp1向左移动exp2位，在低位补0。其实，向左移动n位，就相当于乘以2^n。\n \n``` >>>    :     无符号右移 ```\n \nres = 20 >>> 2; 的结果与 >> 相同；\n\nres = -20 >> 2;\n\n-20的二进制为 1110 1011，右移2位，此时高位补0，即 0011 1010，结果为 res = 58;\n\n也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。","tags":["Java"],"categories":["server"]},{"title":"Java 遍历Map","url":"/2017/09/22/Web后台/Java/Java遍历Map/","content":"## Java中如何遍历Map对象的4种方法\n\n>既然java中的所有map都实现了Map接口，以下方法适用于任何map实现（HashMap, TreeMap, LinkedHashMap, Hashtable, 等等）\n\n### 方法一: 在for-each循环中使用entries来遍历\n>这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用\n````java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \nfor (Map.Entry<Integer, Integer> entry : map.entrySet()) {  \n  \n    System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());  \n  \n} \n````\n注意：for-each循环在java 5中被引入所以该方法只能应用于java 5或更高的版本中。如果你遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此在遍历前你总是应该检查空引用。\n\n### 方法二: 在for-each循环中遍历keys或values。\n>如果只需要map中的键或者值，你可以通过keySet或values来实现遍历，而不是用entrySet。\n```java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \n//遍历map中的键  \n  \nfor (Integer key : map.keySet()) {  \n  \n    System.out.println(\"Key = \" + key);  \n  \n}  \n  \n//遍历map中的值  \n  \nfor (Integer value : map.values()) {  \n  \n    System.out.println(\"Value = \" + value);  \n  \n}  \n```\n该方法比entrySet遍历在性能上稍好（快了10%），而且代码更加干净。\n\n### 方法三: 使用Iterator遍历\n>使用泛型：\n```java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \nIterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n  \n    Map.Entry<Integer, Integer> entry = entries.next();  \n  \n    System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());  \n  \n}  \n```\n>不使用泛型:\n```java\nMap map = new HashMap();  \n  \nIterator entries = map.entrySet().iterator();  \n  \nwhile (entries.hasNext()) {  \n  \n    Map.Entry entry = (Map.Entry) entries.next();  \n  \n    Integer key = (Integer)entry.getKey();  \n  \n    Integer value = (Integer)entry.getValue();  \n  \n    System.out.println(\"Key = \" + key + \", Value = \" + value);  \n  \n}  \n```\n你也可以在keySet和values上应用同样的方法。\n\n该种方式看起来冗余却有其优点所在。首先，在老版本java中这是惟一遍历map的方式。另一个好处是，你可以在遍历时调用iterator.remove()来删除entries，另两个方法则不能。根据javadoc的说明，如果在for-each遍历中尝试使用此方法，结果是不可预测的。\n\n从性能方面看，该方法类同于for-each遍历（即方法二）的性能。\n\n### 方法四: 通过键找值遍历（效率低）\n>作为方法一的替代，这个代码看上去更加干净；但实际上它相当慢且无效率。因为从键取值是耗时的操作（与方法一相比，在不同的Map实现中该方法慢了20%~200%）。如果你安装了FindBugs，它会做出检查并警告你关于哪些是低效率的遍历。所以尽量避免使用。\n```java\nMap<Integer, Integer> map = new HashMap<Integer, Integer>();  \n  \nfor (Integer key : map.keySet()) {  \n  \n    Integer value = map.get(key);  \n  \n    System.out.println(\"Key = \" + key + \", Value = \" + value);  \n  \n}  \n```\n\n## 总结\n如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)。\n\n转自：http://blog.csdn.net/tjcyjd/article/details/11111401","tags":["Java"],"categories":["server"]},{"title":"Java基础","url":"/2017/09/21/Web后台/Java/Java基础/","content":">全局变量和static修饰的局部变量\n\n默认初始化为 0 。因为全局变量和static静态局部变量存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 0x00。\n\n>Java中的switch-case语句\n\nswitch接受的参数类型有10种，分别是基本类型的byte,short,int,char，以及引用类型的String(只有JavaSE 7 和以后的版本 可以接受String类型参数),enum和byte,short,int,char的封装类Byte,Short,Integer,Character\ncase 后紧跟常量表达式，不能是变量。\n\n>Maps.newHashMap();\n\n Map<String, Object> result = new HashMap<String,Object>();\n \n \n 上面这种是java原生API写法\n 下面这种是google的guava.jar提供的写法，目的是为了简化代码。唯一的区别就是简化代码\n \n \n Map<String, Object> result = Maps.newHashMap();\n>泛型\n\n仅仅是java的一颗语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。\n\n>重载的概念\n\n\n 方法名称相同，参数个数、次序、类型不同\n 因此重载对返回值没有要求，可以相同，也可以不同\n 但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载","tags":["Java"],"categories":["server"]},{"title":"常见的编码方式","url":"/2017/09/21/Web后台/相关技术/常见的编码方式/","content":"### 计算机为什么要编码\n在计算机中所有的数据都是以0,1来存储的,那字符是怎样在计算机存储的呢,美国的科学家把一个特定的数字对应一个特定的字母进行存储和传输，比如我需要存储字母a，那么我存入一个数字97(即在计算机中存入二进制(01100001)，这个过程叫做编码(encode)，而我们在读取数据的时候，当遇到97时，我们就让计算机显示字母a，这个过程叫做解码(decode)。\n### 编码发展历史简介\n\n<!--more-->\n\n#### 第一阶段ASCII\n规则:\n\n\n1. 所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。\n\n\n2. 把所有的标点符号，英文大小写全部放在32-126范围中。\n\n\n3. 防止以后出现需要补充的情况，把128-255位这么多位置留出来，应该足够用了吧！所以设置一个字节8位二进制，把这个标准叫American Standard Code for Information Interchange(美国标准信息交换代码，简写为ASCII)，标准制定结束。\n\n实现方式:\n\n第一位始终未0，后面7位表示0-127的范围，一个数字对应一个字母或者标点符号，亦或者控制符号，即所有的ASCII码的统一形式为0xxxx xxxx。\n\n#### 第二阶段 GB2312,GBK, BIG5 Latin1, ISO-8859-1, JIS, ANSI...\n\n>计算机技术到了欧洲，欧洲人发现怎么我们的那么多符号没有编进去啊！\n所以欧洲\"砖家\"坐到了一起，开始讨论。\n发现既然美国人把第一位流出来了，那么我们就用128-255的位置好了。\n\n规则:\n\n1. 128-159之间为控制字符，160-255位文字符号，其中包括了西欧语言、希腊语、泰语、阿拉伯语、希伯来语。\n\n\n2. 刚好把美国人给的空间全部用完，世界真美好，谢谢美利坚预留的每一个位置。\n\n\n3. 砖家们决定把他们的编码名称叫做Latin1，后面由于欧洲统一制定ISO标准，所以又有了一个ISO的名称，即ISO-8859-1。\n\n实现方式:\n\n\n\n1. 0-127的所有位置不动，那么可以兼容ASCII，二进制位0xxx xxxx\n\n\n2. 128-255位置全部用完，二进制位1xxx xxxx\n由于所有的位置全部用完，而欧元符号实在指定标准之后才出现的，所以在这个码表中连欧洲人自己的货币符号都没有办法放进去。\n\n>计算机技术当然也传到了亚洲大地，比如中国。\n中国砖家们坐在一起发现，美国人搞的这个东西真的有问题，预留才128-255的空间，可是我们的汉字个数远远超出了这个数目啊，怎么办？？\n后面聪明的中国砖家们发现，只能使用2个字节了，否则真的搞不定。\n由于必须和美国原来制定的ASCII不冲突，所以指定了如下规则\n\n规则:\n\n1. 如果一个字节中第一位为0，那么这就是一个ASCII字符。\n\n\n2. 如果一个字节中第一位为1，那么这个是汉字，认定需要2个字节才表示一个编码的文字。\n把这个码表叫GB2312\n这个码表中包含汉字6763个和非汉字图形字符682个。\n还有很多的空间没有用到，索性全部预留了吧。\n\n实现方式:\n\n\n1. 0xxxxxxx：表示为ASCII字符\n\n\n2. -1xxxxxxx 1xxxxxxx：表示为汉字\n\n后面再次添加更多的字符进去，再次命名为GB18030，兼容GBK。由于汉字很多，2个字节并不能完全包括进去，所以GB18030采用2\\4位混编的形式。\n\n当然计算机也传到了日本(JIS)、韩国、台湾(BIG5)等等地方，大家全部发挥自己的聪明才智，各自实现了自己的编码。这些编码都与ASCII兼容，但是相互之间不兼容。\n\n使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为\"MBCS（Muilti-Bytes Charecter Set，多字节字符集）\"。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 windows下要转码成gb2312,gbk只需要把文本保存为ANSI编码即可。 不同ANSI编码之间互不兼容\n\n#### 第三阶段\n>随着通讯越来越多，而老美发现在自己公司需要国际化的时候，自己原来埋的这个雷真的害了自己。\n于是乎，开始研讨把世界上几乎所有文字全部放在一个码表中，而这个包罗万象的码表就叫做Unicode，即万国码。\nUnicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。\n实际上，在软件制造商的协会（unicode.org）在做这个工作时，国际标准化组织（ISO）在做同样的事情，最后大家都意识到世界上并不需要两个不同的万国码，于是大家坐在一起合并研究的成果，最后的结果就是现在的Unicode。\n\n### 各个编码及其范围\n#### ASCII\n\n编码范围00-7F，其中00-1F、FF为控制字符。其它为英文字母、数字、标点符号。\n\n#### Latin1\n\n编码范围00-FF，其中00-7F同ASCII，80-9F为控制符、9F-FF为字母和标点符号.\n\n#### CP1252\n\n微软的企业标准，补充了一些符号和欧元符号，为Latin1的超集。\n\n#### GB2312\n\n编码范围为A1A1-F7FE(剔除xx7F)，共23940个码位。其中很多区间没有用到，而汉字使用的区间为B0A1-F7FE，其他为标点符号和特殊字符。\n除常用简体汉字字符外还包括希腊字母、日文平假名及片假名字母、俄语西里尔字母等字符，未收录繁体中文汉字和一些生僻字。\n对汉字进行了分区管理，其中第一个字节为区位码，包括下面区位。\n01-09区为特殊符号。\n16-55区为一级汉字，按拼音排序。\n56-87区为二级汉字，按部首/笔画排序。\n10-15区及88-94区则未有编码。\n第二个字节为位字节，01-94总计94个。\n为什么实际选择不是01-5E，而是选择A1-F7的位置呢？\n因为英文可见字符区间为20-7F，加上128(也就是最高位为1)后得到的取件即是A1-FE\n区位码使用了0xA1-0xF7(把01-87区的区号加上0xA0)，位字节使用了0xA1-0xFE(把01-94加上 0xA0)\n\n#### GBK\n\n编码范围为8140-FEFE,兼容GB2312，仍然有部分区间没有用到。\nGBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的 汉字部首符号、竖排标点符号等字符。\nGBK对GB2312就是，你有的，我也有，你没得的，我还有！\n\n#### CP936\n\nCP936是微软指定的标准，属于企业标准，和GBK的有些许差别，绝大多数情况下可以把CP936当作GBK的别名。\n\n#### BIG5\n\nBig5是双字节编码，高字节编码范围是0x81-0xFE，低字节编码范围是0x40-0x7E和0xA1-0xFE。和GBK相比，少了低字节是0x80-0xA0的组合。0x8140-0xA0FE是保留区域，用于用户造字区。\nBig5收录的汉字只包括繁体汉字，不包括简体汉字，一些生僻的汉字也没有收录。\n\n#### CP950\n\n微软的企业标准，可以理解为是对 Big5的扩展。\n\n#### GB18030\n\n编码范围同GBK，补充了更多的字符，由于Unicode开始流行且GB18030补充的字符都比较生僻，所以实际使用上基本是GBK。\nGB18030编码是变长编码，有单字节、双字节和四字节三种方式。GB18030的单字节编码范围是0x00-0x7F，完全等同与ASCII；双字节编码的范围和GBK相同，高字节是0x81-0xFE，低字节的编 码范围是0x40-0x7E和0x80-FE；四字节编码中第一、三字节的编码范围是0x81-0xFE，二、四字节是0x30-0x39。\n\n#### Unicode\n\n中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。\n一个蛋疼的问题就是这个区间全部都是文字，中文标点没有包含在其中，中文标点散落在各个位置。详细请看http://blog.chinaunix.net/uid-12348673-id-3335307.html。\n一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，详细情况可以参考网址：http://www.cnblogs.com/sosoft/p/3456631.html\n\n#### Unicode的实现方式\n>Unicode只是进行了编码，也就是说只是一个码表，至于具体怎么实现，并没有规定。\n下面是Unicode的几种实现方法。\n##### Unicode UTF-8之间的关系\n简单来说：\nUnicode 是「字符集」\n\nUTF-8 是「编码规则」\n\n其中：\n\n字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）\n\n编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）\n\nUnicode定义了所有可以用来表示字符的数值集合（称之为Code Point）。UTF-8和UTF-16等UTF标准定义了这些数值和字符的映射关系。\n\n正如名字所示，在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分，例如，在UTF－8和ASCII中，“A”的编码都是0x41. \nUTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。\n\n##### UTF-8 (UCS Transfer Format:Unicode转做某种格式) \n\nUTF-8以字节为单位对Unicode进行编码。\n\n从Unicode到UTF-8的编码方式如下：  \n\nUnicode编码(16进制)  ║ UTF-8 字节流(二进制)  \n\n000000 - 00007F   ║ 0xxxxxxx  \n\n000080 - 0007FF   ║ 110xxxxx 10xxxxxx  \n\n000800 - 00FFFF   ║ 1110xxxx 10xxxxxx 10xxxxxx  \n\n010000 - 10FFFF   ║ 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n特点:UTF-8的特点是对不同范围的字符使用不同长度的编码\n\n##### UTF-16\n\n在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。而在辅助平面定义的字符，会以代理对（surrogate pair）的形式，以两个2字节的值来储存。\nUTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16却无法兼容于ASCII编码。\n可以认为UTF-16是下面介绍的UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的是同一的意思。但当引入辅助平面字符后，就称为UTF-16了。现在若有软件声称自己支援UCS-2编码，那其实是暗指它不能支援在UTF-16中超过2bytes的字集。对于小于0x10000的UCS码，UTF-16编码就等于UCS码。\n如果一个UTF-16文件没有指定BOM，默认应该是UTF-16BE，但是在Intel x86中却是UTF-16LE。所以在现实世界中有很多的没有指定大小尾的UTF-16却是UTF-16LE。\n\n##### UTF-32\n\n每一个Unicode码位使用恰好32位元。可以粗暴的认为UTF-32和下面要介绍的UCS-4是等同的。\n\n##### UCS-2\n\n采用2个字节，定长的表示每一个字符，所以总计可以表示2^16个字符。\n\n##### UCS-4\n\nUCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行(rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。\ngroup 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。\n将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。\n\n\n转自:http://www.cnblogs.com/jessonluo/p/4800331.html\n\n\n### 编码检测\n到底采用什么编码，如果能检测就好了。专家们也是这么想的，所以专家给每种格式和字节序规定了一些特殊的编码，\n\n这些编码在unicode 中是没有使用的，所以不用担心会冲突。\n\n这个叫做BOM（Byte Order Mark）头。意思是字节序标志头。通过它基本能确定编码格式和字节序。\n\nUTF编码　║　Byte Order Mark \n　　\nUTF-8　  ║　EF BB BF 　　\n\nUTF-16LE ║　FF FE 　　\n\nUTF-16BE ║　FE FF 　　\n\nUTF-32LE ║　FF FE 00 00 　　\n\nUTF-32BE ║　00 00 FE FF\n所以通过检测文件前面的BOM头，基本能确定编码格式和字节序。\n但是这个BOM头只是建议添加，不是强制的，所以不少软件和系统没有添加这个BOM头（所以有些软件格式中有带BOM头\n\n和NoBOM头的选择），这个时候要检测什么格式，就比较麻烦了\n当然可以检测，但是不能保证100%准确，只能通过编码范围从概率上来检查，虽然准确度还是比较高，但是不能保证\n\n100%。所以，时常看到检测错误的软件，也不奇怪了。\n\n### UTF-8 与UTF-16的区别\n\n   UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊.\n\n   于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定.\n\n   于是UTF-8和UTF-16的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用UTF-8就比UTF-16节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16就占优势了,可以节省很多空间.另外还有个容错问题,等会再讲","tags":["Java"],"categories":["server"]},{"title":"Struts2 问题总结","url":"/2017/09/19/Web后台/Struts2/Struts2 问题总结/","content":"## 上传图片出现错误\n但是，明明上传的文件格式是正确，还是出现：\n\n    Content-Type not allowed: file \"09poC_wallpapers.jpg\" \"upload_1ea6fe4e_13611ac7d7c__8000_00000012.tmp\" image/pjpeg \n\n\nfirefox 和 ie 的文件类型区别\n    Firefox：\n    \t\n    \n    image/jpeg, image/bmp, image/gif, image/png\n    \n    ie 6：\n    \t\n    \n     image/pjpeg ,image/bmp, image/gif, image/x-png\n    \n    ie 7：\n    \t\n    \n    image/pjpeg, image/bmp, image/gif, image/x-png\n    \n    ie 8：\n    \t\n    \n    image/pjpeg, image/bmp, image/gif, image/x-png\n    \n    Ie 9： \n    \t\n    \n    image/jpeg, image/bmp, image/gif, image/png \n解决方法\n\n    <param name=\"allowedTypes\">\n      image/bmp,image/png,image/gif,image/jpeg,image/jpg,\n      image/pjpeg ,image/bmp, image/gif, image/x-png,\n    </param>","tags":["struts2"],"categories":["服务器"]},{"title":"Struts2 的简单实例","url":"/2017/09/16/Web后台/Struts2/Struts2 的简单实例/","content":"## Struts2 实现流程\n1. 浏览器发送请求\n2. 到达 StrutsPrepareAndExecuteFilter ( 核心控制器 )\n3. 分发到指定 XXXAction ( 业务控制器 ) 调用业务方法\n4. 返回逻辑视图名\n5. StrutsPrepareAndExecuteFilter forward到物理视图,生成响应内容，输出响应","tags":["struts2"],"categories":["服务器"]},{"title":"web.xml中配置JSP属性","url":"/2017/09/15/Web后台/JspServlet/web.xml中配置JSP属性/","content":"## web.xml中配置JSP属性\n>为什么要在web.xml配置JSP属性\n\n如果许多JSP有着相似的属性，那么在每个JSP文件的顶部重复添加page指令是非常麻烦的工作。幸运的是，在部署描述符中可以配置通用的JSP属性。\n\n> web.xml中添加JSP属性样例\n\n    <jsp-config>  \n     \t<jsp-property-group>  \n     \t\t<url-pattern>*.jsp</url-pattern>  \n     \t\t<url-pattern>*.jspf</url-pattern>  \n     \t\t<page-encoding>UTF-8</page-encoding>  \n     \t\t<scripting-invalid>false</scripting-invalid>  \n     \t\t<include-prelude>/WEB-INF/jsp/base.jspf</include-prelude>  \n     \t\t<trim-directive-whitespaces>true</trim-directive-whitespaces>  \n     \t\t<default-content-type>text/html</default-content-type>  \n     \t\t</jsp-property-group>  \n    </jsp-config> \n\n<jsp-config>中可以包含任意数目的<jsp-property-group>标签。通过为<jsp-property-group>定义不同的<url-pattern>标签来区分不同的属性组。\n<include-prelude>标签，将告诉容器在所有属于改该属性组的JSP的头部添加文件/WEB-INF/jsp/base.jspf。\n<include-coda>标签定义了包含在组中所有JSP尾部的文件。\n\n在一个JSP组中可以同时使用这些标签多次。\n<page-encoding>与page指令的pageEncoding特性一致。\n<default-content-type>标签可以定义内容类型，默认为text/html\n<trim-directive-whitespaces>也是一个特别有用的属性，该属性告诉JSP转换器删除响应输出中的空白，只保留指令、声明、脚本和其他JSP标签创建的文本。\n<scripting-invalid>标签可以实现完全禁止JSP中的Java\n<el-ignored>的作用类似，不过它对应的是page指令中的isELIgnored特性。\n除了<url-pattern>，<jsp-property-group>中所有标签都是可选的，但在使用它们时必须按照下面的顺序添加到<jsp-property-group>中(忽略掉部希望使用的标签)：<url-pattern>、<el-ignored>、<page-encoding>、<scripting-invalid>、<is-xml>、<include-prelude>、<include-coda>、<deferred-syntax-allowed-as-literal>、<trim-directive-whitespace>、<default-content-type>、<buffer>、<error-on-undeclared-namespace>。","tags":["jsp"],"categories":["服务器"]},{"title":"Servlet","url":"/2017/09/14/Web后台/JspServlet/Servlet/","content":"## Servlet\n服务器端小程序,运行在服务器端的程序，用于处理及响应客户端的请求,自MVC规范出现之后,Servlet仅仅只作为控制器\n\n## Servlet和Jsp的区别\n1. Servlet中没有内置对象,原来JSP中的内置对象都必须有程序显式创建\n2. Servlet对于HTML标签只能使用页面输出流逐行输出，所以自MVC规范出现之后,Servlet仅仅只作为控制器\n\n<!-- more -->\n\n## @WebServlet \n\n从3.0开始配置Servlet可以使用注解的形式\n>有些人可能会遇到这种种情况，在采用注解WebServlet配置Servlet的时候，明明在配置了urlPatterns属性，部署应用程序的时候也没有出错。但是就是在浏览器发请求的时候访问不到资源，报404错误request resource is not available。捣腾了半天也不知道，到底是哪而出错了？\n Servlet3.0之后新增了注解，用于简化Servlet、Filter及Listener的声明，这样就在配置Servlet的时候多了一个选择。Servlet3.0的部署描述文件web.xml的顶层标签<web-app>有一个metadata-complete属性，该属性为true，则容器在部署时只依赖部署描述文件，忽略所有标注，如果不配置该属性，或者将其设置为false，则表示启动标注支持。当metadata-complete=\"false\"时，web.xml和注解对于Servlet的影响同时起作用，两种方法定义的url-partten都可以访问到该Servlet，但是当通过web.xml定义的url-partten访问时，注解定义的属性（初始化参数等）将失效。\n\n### 属性值\nname\tString\t指定Servlet 的 name 属性，等价于 <servlet-name>。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。\n\nvalue\tString[]\t该属性等价于 urlPatterns 属性。两个属性不能同时使用。\n\nurlPatterns\tString[]\t指定一组 Servlet 的 URL 匹配模式。等价于<url-pattern>标签。\n\nloadOnStartup\tint\t指定 Servlet 的加载顺序，等价于 <load-on-startup>标签。\n\ninitParams\tWebInitParam[]\t指定一组 Servlet 初始化参数，等价于<init-param>标签。\n\nasyncSupported\tboolean\t声明 Servlet 是否支持异步操作模式，等价于<async-supported> 标签。\n\ndescription\tString\t该 Servlet 的描述信息，等价于 <description>标签。\n\ndisplayName\tString\t该 Servlet 的显示名，通常配合工具使用，等价于 <display-name>标签。\n## 创建Servlet有俩个时机\n1. 用户请求某个Servlet，系统创建该Servlet的实例,所以Servlet第一次访问的时间是较长的，因为要初始化Servlet\n2. Web应用启动立即创建Servlet实例,即load-on-startup Servlet\n\n## Servlet 生命周期\n1. 创建实例\n2. Web容器调用Servlet的init方法，对Servlet进行初始化。\n3. 初始化后将一直存在于容器中，用于响应客户端请求,get post service用于响应用户请求\n4. 通常在Web应用关闭之时销毁Servlet，先调用Servlet的destory()方法\n\n## 使用Servlet作为表现层如有以下几个劣势\n1. 所有的Html标签都需要页面输出流完成\n2. 前端人员无法参与到页面的编写\n3. 可维护性差，页面代码不好调试\n","tags":["server"],"categories":["服务器"]},{"title":"JSP脚本中的九个内置对象","url":"/2017/09/14/Web后台/JspServlet/JSP脚本中的九个内置对象/","content":"JSP脚本中包含九个内置对象，这九个内置对象都是Servlet API接口的实例，只是JSP规范对它们进行了默认初始化（由JSP页面对应的Servlet的_jspService()方法来创建这些实例),也就是说它们已经是对象，可以直接使用\n\n    1\tpageContext\tjavax.servlet.jsp.PageContext\n    \n    2\trequest\tjavax.servlet.http.HttpServletRequest\n    \n    3\tresponse\tjavax.servlet.http.HttpServletResponse\n    \n    4\tsession\tjavax.servlet.http.HttpSession\n    \n    5\tapplication\tjavax.servlet.ServletContext\n    \n    6\tconfig\tjavax.servlet.ServletConfig\n    \n    7\tout\tjavax.servlet.jsp.JspWriter\n    \n    8\tpage\tjava.lang.Object\n    \n    9\texception\tjava.lang.Throwable\n\n<!--more-->\n### page对象\npage对象表示当前一个JSP页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。page对象在开发中几乎不用，了解一下即可\n### out对象\nout对象代表一个页面输出流，通常用于在页面上输出变量值及常量。一般在使用输出表达式的地方都可以使用out对象达到同样的效果。out是个页面输出流，负责输出页面的内容，但是用out需要编写更多的代码。<%=  %>表达式的本质就是out.write(…);\n对于页面上的某个html标签来讲\n<table><tr></tr></table>\n如果使用了out即\n\n      <%\n    \tout.println(“<table>”);\n    \tout.println(“<tr>”);\n    \tout.println(“</tr>”);\n    \tout.println(“</table>”);\n      %>\n\n### pageContext对象\npageContext对象是JSP技术中最重要的一个对象，它代表JSP页面的运行环境，这个对象不仅封装了对其它8大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。\n\n    getException方法\t\t返回exception隐式对象\n    getPage方法\t\t\t返回page隐式对象\n    getRequest方法\t\t返回request隐式对象\n    getResponse方法\t\t返回response隐式对象\n    getServletConfig方法 返回config隐式对象\n    getServletContext方法返回application隐式对象\n    getSession方法\t\t返回session隐式对象\n    getOut方法\t\t\t返回out隐式对象\n\n>pageContext 封装其它8大内置对象的意义\n\n　　如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，把pageContext传递给谁，谁就能成为一个动态web资源，那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢，在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了java代码，那么就应该想办法把java代码移除掉，我们可以开发一个自定义标签来移除jsp页面上的java代码，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个java类，在调用java类的时候就会把pageContext对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。\n\n>pageContext 作为域对象\n\npageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。\n\npageContext对象的常用方法\n\n    1 public void setAttribute(java.lang.String name,java.lang.Object value)\n    2 public java.lang.Object getAttribute(java.lang.String name)\n    3 public void removeAttribute(java.lang.String name)\n    4 public java.lang.Object findAttribute(java.lang.String name)\n\n\n\n### application 对象\n - 在整个Web应用的多个JSP、Servlet之间的共享数据。通常被定义为数据字典来使用。通常在一处实现application.setAttribute(“name”,value);来定义一个变量，在JSP中使用application.getAttribute(“name”);获取值；在Servlet中使用一个实例的ServletContext对象sc.getAttribute(“name”);获取值。\n我们可以把application理解成一个Map对象，任何JSP、Servlet都可以把某个变量放入application中保存，并指出一个属性名；而该应用的其他JSP、Servlet就可以根据该属性名来得到这个变量。由于application对象代表整个Web应用，所以只应该把Web应用的状态数据放入到application中。\n - 访问Web应用的配置参数，在web.xml中配置类似的参数，该标签是<web-app></web-app>下的子标签。即\n    \n\n    <context-param>\n       <param-name>name</param-name>\n       <param-value>value</param-value>\n    </context-param>\n    \n\n 在JSP中可以通过 application.getInitParameter(“name”);取得配置的参数，在Servlet中可以先实例个ServletContext对象即：\n final javax.servlet.ServletContext application;\n然后就可以取值了，即：\n\n    application = pageContext.getServletContext();\n    application.getInitParameter(\"name\");\n\n这里通常被用作普通java Web开发中数据库用户名，密码的获取时使用，因为在项目开发用的密码不一定和部署在服务器上的密码一致，但是把它写到这里便于修改这些有关项目的参数。 \n\n### config 对象\nconfig对象代表当前的JSP配置信息，但JSP页面通常无需配置，因此也就不存在配置信息，该对象在JSP页面用的比较少，但在Servlet中用处则相对较大，因为Servlet需要在web.xml文件中进行配置，可以指定配置参数。但是如果说要为某个JSP配置一些参数的话，也是跟配置Servlet一样需要在web.xml中配置，也就说吧JSP当成Servlet配置\n\n    <servlet>\n       <servlet-name>Configure</servlet-name>\n       <jsp-file>/getcontextparam.jsp</jsp-file>\n       <init-param>\n     <param-name>conn</param-name>\n     <param-value>connnn</param-value>\n       </init-param>\n     </servlet>\n     <servlet-mapping>\n       <servlet-name>Configure</servlet-name>\n       <url-pattern>/configure</url-pattern>\n     </servlet-mapping>\n其中这里“<jsp-file>/getcontextparam.jsp</jsp-file>”是表明把某个JSP配置成Servlet。\n在地址栏中访问时要输入http://localhost:8080/test/configure（url-pattern中内容）\n在JSP中获取参数时使用config.getInitParameter(\"conn\")即可。\n\n### exception 对象\n该实例代表其他页面的异常和错误,只有当页面是错误处理页面，即编译指令page的isErrorPage属性为true时,该对象才可以使用","tags":["jsp"],"categories":["服务器"]},{"title":"Spring mvc整合velocity","url":"/2017/09/11/Web后台/velocity/Spring mvc整合velocity/","content":"# 添加Maven依赖: #\n        <!--springmvc集成 velocity-->\n        <dependency>\n            <groupId>org.apache.velocity</groupId>\n            <artifactId>velocity</artifactId>\n            <version>1.7</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.velocity</groupId>\n            <artifactId>velocity-tools</artifactId>\n            <version>2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n<!--more-->\n# applicationContext-mvc配置文件: #\n    <!--》》》》》》》》》》》》》》》   添加velocity显示技术 》》》》》》》》》》》》》》》》》-->\n    <!-- velocity环境配置 -->\n    <bean id=\"velocityConfig\" class=\"org.springframework.web.servlet.view.velocity.VelocityConfigurer\">\n        <!-- velocity配置文件路径  或者直接用velocityProperties属性 -->\n        <property name=\"configLocation\" value=\"classpath:velocity.properties\"/>\n        <!-- velocity模板路径 -->\n        <property name=\"resourceLoaderPath\" value=\"/WEB-INF/templates/\"/>\n    </bean>\n    <!-- velocity视图解析器 -->\n    <bean id=\"velocityViewResolver\" class=\"org.springframework.web.servlet.view.velocity.VelocityLayoutViewResolver\">\n        <property name=\"order\" value=\"0\"/>\n        <property name=\"contentType\" value=\"text/html;charset=UTF-8\"/>\n        <property name=\"cache\" value=\"true\"/>\n        <property name=\"suffix\" value=\".vm\"/>\n        <property name=\"layoutUrl\" value=\"layout/layout.vm\"/>\n        <property name=\"exposeSpringMacroHelpers\" value=\"true\" /><!--是否使用spring对宏定义的支持-->\n        <property name=\"exposeSessionAttributes\" value=\"true\" /><!--是否开放request属性-->\n        <property name=\"requestContextAttribute\" value=\"request\"/><!--request属性引用名称-->\n        <property name=\"dateToolAttribute\" value=\"dateTool\"/>\n        <property name=\"numberToolAttribute\" value=\"numberTool\"/>\n    </bean>\n# velocity.properties 配置文件 #\n该文件velocity.properties 在下面的包路径可以找到 org.apache.velocity.runtime.defaults.velocity.properties\n\n\n    #设置字符集\n    #encoding\n    input.encoding  =UTF-8\n    output.encoding=UTF-8\n    contentType=text/html;charset=UTF-8\n    \n    \n    #autoreload when vm changed\n    file.resource.loader.cache=false\n    file.resource.loader.modificationCheckInterval  =1\n    velocimacro.library.autoreload=false\n# 显示文件目录结构 #\n![](/images/server/velocity-layout.png)\n\n## header.mv \n\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <meta http-equiv=\"Cache-Control\" content=\"no-store\"/>\n    <meta http-equiv=\"Pragma\" content=\"no-cache\"/>\n    <meta http-equiv=\"Expires\" content=\"3600\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" name=\"viewport\">\n\n## layout.mv ##\n    <html>\n    <head>\n    <title>$!page_title</title>\n    #parse(\"default/header.vm\")\n    </head>\n    <body>\n    \n    <div>\n    \n    $screen_content\n    \n    </div>\n    \n    </body>\n    </html>\n## velocity.mv ##\n    <html>\n    <head>\n    <title>Spring MVC and Velocity</title>\n    </head>\n    <body>\n    <h1>Spring MVC and Velocity</h1>\n    \n       Hello  ${hello}\n    \n    <hr />\n    Copyright &copy 2014 lm\n    </body>\n    </html>\n## velocity 基本语法 ##\nVelocity的基本语法：\n1、\"#\"用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#iinclude、#parse、#macro等；\n如:\n#if($info.imgs)\n<img src=\"$info.imgs\" border=0>\n#else\n<img src=\"noPhoto.jpg\">\n#end\n\n\n2、\"$\"用来标识一个对象(或理解为变量)；如\n如：$i、$msg、$TagUtil.options(...)等。\n\n\n3、\"{}\"用来明确标识Velocity变量；\n比如在页面中，页面中有一个$someonename，此时，Velocity将把someonename作为变量名，若我们程序是想在someone这 个变量的后面紧接着显示name字符，则上面的标签应该改成${someone}name。\n\n\n4、\"!\"用来强制把不存在的变量显示为空白。\n如当页面中包含$msg，如果msg对象有值，将显示msg的值，如果不存在msg对象同，则在页面中将显示$msg字符。这是我们不希望的，为了把不存 在的变量或变量值为null的对象显示为空白，则只需要在变量名前加一个“!”号即可。\n如：$!msg\n\n5、循#foreach( $info in $list) $info.someList #end，环读取集合list中的对象\n#foreach( $info in $hotL包含文件#inclue(\"模板文件名\")或#parse(\"模板文件名\")st1) \n<a href=\"/blog/list?&cid=$!info.cid\" target=\"_blank\">$!info.title</a><br>\n#end \n上面的脚本表示循环遍历hotList1集合中的对象，并输出对象的相关内容。\n\n6、包含文件#inclue(\"模板文件名\")或#parse(\"模板文件名\")\n主要用于处理具有相同内容的页面，比如每个网站的顶部或尾部内容。\n使用方法，可以参考EasyJF开源Blog及EasyJF开源论坛中的应用！\n如：#parse(\"/blog/top.html\")或#include(\"/blog/top.html\")\nparse与include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示。","tags":["Spring Mvc"],"categories":["server"]},{"title":"常用的JavaEE服务器","url":"/2017/09/10/Web后台/JavaEE服务器/常用的JavaEE服务器/","content":"# Web服务器 #\n## 1：Tomcat ##\n\t与Java结合的最好、开源、Oracle官方推荐的JSP服务器\n## 2：Jetty  ##\n\t嵌入式服务器：在应用中加入Jetty的Jar文件,即可提供Web服务，最好搭配Maven使用，采用maven jetty插件，即可通过简单的配置，执行命令即可启动web服务\n## 3：Resin ##\n\t目前最快的Jsp，Servlet运行平台，支持EJB,个人免费，商业交钱\n# Java EE服务器 #\n## 1：JBoss ##\n\t开源，全面支持各种最新的Java EE规范\n## 2：GlassFish ##\n\tOracle官方提供的JavaEE服务器\n## 3：WebLogic ##\n\t收费所以牛逼\n## 4：WebSphere ##\n\tIBM收费也是牛逼,WebSphere 是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的软件。","tags":["server"],"categories":["服务器"]},{"title":"新建博客方法","url":"/2017/09/10/随笔/新建博客方法/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n<!--more-->\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["github"],"categories":["随笔"]},{"title":"Java学习路线","url":"/2017/09/10/Web后台/Java学习路线/","content":"JAVA学习路线图\n\n此乃是java攻城狮的学习路线图，由简到繁，由易到难，一步步的学习\n\n阶段1\n\n1：学习HTML     2:学习CSS    3:Javascript    4:jquery    5:xml解析   6：Bootstrap    \n \n阶段2  \n\n7:JAVAse基础      8：mysql数据库     9：Powerdesigner   10:JDBC    11:JAVAWEB   \n    \n阶段3\n\n12:oracle         13:struts2         14:Hibernate       15:Spring\n\n阶段4\n\n16:Maven         17:SpringMVC      18:MyBatis\n\n<!--more-->\n\n![logo](/images/learn-route.png) ","tags":["java"],"categories":["server"]},{"title":"前端学习技术","url":"/2017/09/10/Web前端/前端学习技术/","content":"技术架构图:\n<!--more-->\n![logo](/images/client.jpg)","tags":["web"],"categories":["client"]},{"title":"Hexo问题总结","url":"/2017/09/09/随笔/hexo问题总结/","content":"# Hexo问题总结\n\n\n- **hexo部署后，CNAME会被自动删除，怎么办？**\n\n&nbsp;&nbsp;&nbsp;&nbsp;准确来说 CNAME 文件是放在 hexo 项目下的 source 目录，你再运行下hexo generade\n然后你再去 public 目录中看看就明白了BTW，为了达到更有说服力的验证，最好在开始前先运行下hexo clean\n这样会先删除 public 目录\n\n- **HEXO发布到Github上，README.md文件正常显示的解决**\n\n&nbsp;&nbsp;&nbsp;&nbsp;使用hexo d 发布本地编译过的代码到github上的时候，发现这个README.md文件也被解析的乱七八糟的，不是一般的github项目里面的README.md文件的显示样式，查了下，在最外层的_config.yml里面把\nskip_render: README.md\n添加这个配置，就OK啦。\n\n\n- **指定端口启动**\n\n    ` hexo server -p 4001`\n\n- **如何在markdowm中添加本地图片**\n\t\n    建议将图片统一放在 `source/images` 文件夹中。然后通过绝对路径` ![](/images/image.jpg)` 引用\n\n\n","tags":["github"],"categories":["技术"]},{"title":"第一篇博客","url":"/2017/09/09/随笔/第一篇博客/","content":"# 使用hexo+github搭建免费个人博客\n## 优势:\n1. 全是静态文件，访问速度快；\n2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；\n3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；\n4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；\n5. 博客内容可以轻松打包、转移、发布到其它平台；\n\n\n<!--more-->\n##  hexo\n\n### 简介\nHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。\n\n官网： http://hexo.io\n\ngithub: https://github.com/hexojs/hexo\n\n### 原理\n由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。\n\n\n### 注意事项 \n1. 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行\n2. hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导\n3. hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的\n4. 使用Hexo搭建博客时，需要区分『博客源代码』和『博客生成代码』\n\t1. 『博客源代码』: Hexo的源码，包括themes目录（博客模板），source目录(使用MarkDown写的博客)等\n\t2. 『博客生成代码』： 执行hexo generate或者hexo server命令生成的代码，是Hexo自动生成的，再public目录\n\n\n### 常用命令\n    hexo new \"postName\" \t #新建文章\n    hexo new page \"pageName\" #新建页面\n    hexo generate \t\t\t #生成静态页面至public目录\n    hexo server \t\t     #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n    hexo deploy \t\t\t #部署到GitHub\n    hexo help  \t\t\t\t #查看帮助\n    hexo version  \t\t\t #查看Hexo的版本\n### \n\n### hexo的文件结构\n    ├── _config.yml \n    ├── db.json\n    ├── node_modules \n    ├── package.json\n    ├── public \n    ├── scaffolds \n    ├── source #所有文章文件放在这里\n    └── themes #主题文件夹\n\n    _config.yml  站点的配置文件。\n    db.json   缓存文件\n    node_modules   安装的插件以及hexo所需的一些node.js模块。\n    package.json  应用程序信息，配置hexo运行需要的js包。\n    public  最终所见网页的所有内容\n    scaffolds   模板文件夹。当新建一个文章时，会默认包含对应模板的内容。\n    source  资源文件夹是存放用户资源的地方。所有的源文件都会被保存在_post文件夹中。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\n    themes  存放主题文件，hexo会根据主题来生成静态页面。\n\n### 图片测试\n![logo](/images/dont-run.gif) ","tags":["nodejs"],"categories":["技术"]}]