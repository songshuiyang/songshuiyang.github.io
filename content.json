{"meta":{"title":"宋水阳个人博客","subtitle":null,"description":null,"author":"songshuiyang","url":"http://www.songshuiyang.site"},"pages":[{"title":"关于","date":"2017-09-09T16:35:25.000Z","updated":"2017-09-09T16:55:32.269Z","comments":true,"path":"about/index.html","permalink":"http://www.songshuiyang.site/about/index.html","excerpt":"","text":"logo 姓名:宋水阳 学校:东华理工大学 专业:软件工程 籍贯:江西省赣州市 与其纠结无法改变的过去，不如微笑着，珍惜未来。"},{"title":"","date":"2018-07-25T07:21:50.657Z","updated":"2018-07-25T07:21:50.594Z","comments":false,"path":"categories/index.html","permalink":"http://www.songshuiyang.site/categories/index.html","excerpt":"","text":""},{"title":"","date":"2018-07-25T07:20:10.686Z","updated":"2018-07-25T07:20:10.622Z","comments":false,"path":"tags/index.html","permalink":"http://www.songshuiyang.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring系列(五三)AOP源码解析之创建AOP代理","slug":"backend/framework/spring/analysis/Spring系列(五三)AOP源码解析之创建AOP代理","date":"2019-07-31T16:00:03.000Z","updated":"2019-06-23T09:33:12.211Z","comments":true,"path":"2019/08/01/backend/framework/spring/analysis/Spring系列(五三)AOP源码解析之创建AOP代理/","link":"","permalink":"http://www.songshuiyang.site/2019/08/01/backend/framework/spring/analysis/Spring系列(五三)AOP源码解析之创建AOP代理/","excerpt":"","text":"前言 上一章节介绍了&lt;aop:aspectj-autoproxy/&gt;的解析过程，最终结果是得到AspectJAnnotationAutoProxyCreator 这个bean，这个类用于创建AOP的代理类，那么这个类到底做了什么工作来完成AOP的功能的呢？ AspectJAnnotationAutoProxyCreator 类继承关系 AspectJAnnotationAutoProxyCreator 类 1234567public class AnnotationAwareAspectJAutoProxyCreator extends AspectJAwareAdvisorAutoProxyCreator &#123; private List&lt;Pattern&gt; includePatterns; private AspectJAdvisorFactory aspectJAdvisorFactory; private BeanFactoryAspectJAdvisorsBuilder aspectJAdvisorsBuilder; 解析12345678910111213141516AspectJAwareAdvisorAutoProxyCreator (org.springframework.aop.aspectj.autoproxy) AbstractAdvisorAutoProxyCreator (org.springframework.aop.framework.autoproxy) AbstractAutoProxyCreator (org.springframework.aop.framework.autoproxy) ProxyProcessorSupport (org.springframework.aop.framework) ProxyConfig (org.springframework.aop.framework) Object (java.lang) Serializable (java.io) Ordered (org.springframework.core) BeanClassLoaderAware (org.springframework.beans.factory) Aware (org.springframework.beans.factory) AopInfrastructureBean (org.springframework.aop.framework) SmartInstantiationAwareBeanPostProcessor (org.springframework.beans.factory.config) InstantiationAwareBeanPostProcessor (org.springframework.beans.factory.config) BeanPostProcessor (org.springframework.beans.factory.config) BeanFactoryAware (org.springframework.beans.factory) Aware (org.springframework.beans.factory) AspectJAnnotationAutoProxyCreator 实现了 BeanPostProcessor接口 由AspectJAnnotationAutoProxyCreator的继承关系图可以注意到此类实现了 BeanPostProcessor接口，这个接口前面经常看见，实现了这个接口是可以在bean初始化之前和初始化之后添加一些逻辑，到这里，我们大概可以猜出代理类是怎样和目标对象联系在一起的，实现偷天换日 我们来看一下它是怎么实现 BeanPostProcessor接口的，具体实现在父类AbstractAutoProxyCreator#postProcessAfterInitialization中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Create a proxy with the configured interceptors if the bean is * identified as one to proxy by the subclass. * @see #getAdvicesAndAdvisorsForBean */@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean != null) &#123; // 根据给定的bean的class和name构建出个key，格式: beanClassName_beanName Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) &#123; // 如果它适合被代理，则需要封装指定的bean return wrapIfNecessary(bean, beanName, cacheKey); &#125; &#125; return bean;&#125;/** * Wrap the given bean if necessary, i.e. if it is eligible for being proxied. * @param bean the raw bean instance * @param beanName the name of the bean * @param cacheKey the cache key for metadata access * @return a proxy wrapping the bean, or the raw bean instance as-is */protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; // 如果已经处理过 if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123; return bean; &#125; // 无需增强 if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123; return bean; &#125; // 给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理 if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; // Create proxy if we have advice. // 核心方法 如果存在增强方法则创建代理 Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); // 如果获取到了增强则需要针对增强创建代理 if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); // 创建代理 1、获取增强方法或者增强器 2、根据获取的增强进行代理 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;&#125; 从上面的代码可以看到代理创建的雏形，主要步骤分为两步 获取增强方法或者增强器 根据获取的增强进行代理 获取增强方法或者增强器 先来看获取增强方法的实现逻辑getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); 1234567891011121314151617181920@Overrideprotected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) &#123; // 获取所有的增强以及寻找所有增强中适用于bean的增强并应用 List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName); if (advisors.isEmpty()) &#123; return DO_NOT_PROXY; &#125; return advisors.toArray();&#125;protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; // 获取所有增强器 List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); // 从所有增强器中找出适合的增强器 List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; 可以看到先是获取了所有的增强器，然后在所有增强器中找出适合的增强器并返回 获取所有增强器 当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持，在这里调用父类方法加载配置文件中的AOP声明，然后再add使用注解配置的Advisor 1234567891011@Overrideprotected List&lt;Advisor&gt; findCandidateAdvisors() &#123; // Add all the Spring advisors found according to superclass rules. // 当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持 // 在这里调用父类方法加载配置文件中的AOP声明 List&lt;Advisor&gt; advisors = super.findCandidateAdvisors(); // Build Advisors for all AspectJ aspects in the bean factory.// 获取注解配置的Advisor advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); return advisors;&#125; this.aspectJAdvisorsBuilder.buildAspectJAdvisors()方法是获取注解配置的Advisor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public List&lt;Advisor&gt; buildAspectJAdvisors() &#123; List&lt;String&gt; aspectNames = this.aspectBeanNames; if (aspectNames == null) &#123; synchronized (this) &#123; aspectNames = this.aspectBeanNames; if (aspectNames == null) &#123; List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); aspectNames = new LinkedList&lt;String&gt;(); // 获取所有的beanName String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Object.class, true, false); // 循环所有的beanName找出对应的增强方法 for (String beanName : beanNames) &#123; // 不合法的bean则略过 if (!isEligibleBean(beanName)) &#123; continue; &#125; // We must be careful not to instantiate beans eagerly as in this case they // would be cached by the Spring conainer but would not have been weaved. // 获取对应的bean的类型 Class&lt;?&gt; beanType = this.beanFactory.getType(beanName); if (beanType == null) &#123; continue; &#125; // 如果存在Aspect注解 if (this.advisorFactory.isAspect(beanType)) &#123; aspectNames.add(beanName); AspectMetadata amd = new AspectMetadata(beanType, beanName); if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) &#123; MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName); // TODO 核心 解析标记AspectJ注解中的增强方法 委托 advisorFactory.getAdvisors List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory); if (this.beanFactory.isSingleton(beanName)) &#123; this.advisorsCache.put(beanName, classAdvisors); &#125; else &#123; this.aspectFactoryCache.put(beanName, factory); &#125; advisors.addAll(classAdvisors); &#125; else &#123; // Per target or per this. if (this.beanFactory.isSingleton(beanName)) &#123; throw new IllegalArgumentException(\"Bean with name '\" + beanName + \"' is a singleton, but aspect instantiation model is not singleton\"); &#125; MetadataAwareAspectInstanceFactory factory = new PrototypeAspectInstanceFactory(this.beanFactory, beanName); this.aspectFactoryCache.put(beanName, factory); advisors.addAll(this.advisorFactory.getAdvisors(factory)); &#125; &#125; &#125; this.aspectBeanNames = aspectNames; return advisors; &#125; &#125; &#125; if (aspectNames.isEmpty()) &#123; return Collections.emptyList(); &#125; // 记录在缓存中 List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); for (String aspectName : aspectNames) &#123; List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName); if (cachedAdvisors != null) &#123; advisors.addAll(cachedAdvisors); &#125; else &#123; MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName); advisors.addAll(this.advisorFactory.getAdvisors(factory)); &#125; &#125; return advisors;&#125; 上面的逻辑可以看到先是获取所有的beanName然后遍历，找出声明AspectJ注解的类，并将结果加入到缓存中 this.advisorFactory.getAdvisors(factory);是最为重要及最为复杂的 1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) &#123; // 获取标记为AspectJ的类 Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass(); // 获取标记为AspectJ的name String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName(); // 验证 validate(aspectClass); // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator // so that it will only instantiate once. MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory = new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory); List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); for (Method method : getAdvisorMethods(aspectClass)) &#123; // TODO 普通增强器的获取 Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125; // If it's a per target aspect, emit the dummy instantiating aspect. // 如果寻找的增强器不为空而且又配置了延迟初始化那么需要在首位加入同步实例化增强器 if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) &#123; Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory); advisors.add(0, instantiationAdvisor); &#125; // Find introduction fields. // 获取DeclaredField注解 for (Field field : aspectClass.getDeclaredFields()) &#123; Advisor advisor = getDeclareParentsAdvisor(field); if (advisor != null) &#123; advisors.add(advisor); &#125; &#125; return advisors;&#125; 关注for (Method method : getAdvisorMethods(aspectClass))方法，循环切点方法，然后调用Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);获取增强 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrderInAspect, String aspectName) &#123; validate(aspectInstanceFactory.getAspectMetadata().getAspectClass()); // 切点信息的获取 AspectJExpressionPointcut expressionPointcut = getPointcut( candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass()); if (expressionPointcut == null) &#123; return null; &#125; // 根据切点信息生成增强器 return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod, this, aspectInstanceFactory, declarationOrderInAspect, aspectName);&#125; private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) &#123; // 获取方法上的注解 AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod); if (aspectJAnnotation == null) &#123; return null; &#125; // 使用AspectJExpressionPointcut实例封装获取的信息 AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]); ajexp.setExpression(aspectJAnnotation.getPointcutExpression()); ajexp.setBeanFactory(this.beanFactory); // 提取到的注解中表达式如 @Pointcut(\"execution(* *.*test*(..))\")中的execution(* *.*test*(..) return ajexp;&#125; protected static AspectJAnnotation&lt;?&gt; findAspectJAnnotationOnMethod(Method method) &#123; // 看到了熟悉的注解类 Class&lt;?&gt;[] classesToLookFor = new Class&lt;?&gt;[] &#123; Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class&#125;; for (Class&lt;?&gt; c : classesToLookFor) &#123; AspectJAnnotation&lt;?&gt; foundAnnotation = findAnnotation(method, (Class&lt;Annotation&gt;) c); if (foundAnnotation != null) &#123; return foundAnnotation; &#125; &#125; return null;&#125; 找出适合的增强器 根据获取的增强创建代理 获取了所有对应bean的增强器后，便可以进行代理的创建了，对于代理类的创建及处理，Spring委托给了ProxyFactory去处理，下面的函数主要是对ProxyFactory的初始化操作，进而对真正的创建代理做准备 12345678910111213141516171819202122232425262728293031323334353637protected Object createProxy( Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123; if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123; AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass); &#125; // 对于代理类的创建及处理，Spring委托给了ProxyFactory去处理 ProxyFactory proxyFactory = new ProxyFactory(); // 获取当前类中相关属性 proxyFactory.copyFrom(this); // 决定对于给定的bean是否应该使用targetClass而不是她的接口代理。检查ProxyTargetClass设置 if (!proxyFactory.isProxyTargetClass()) &#123; if (shouldProxyTargetClass(beanClass, beanName)) &#123; proxyFactory.setProxyTargetClass(true); &#125; else &#123; evaluateProxyInterfaces(beanClass, proxyFactory); &#125; &#125; // 将拦截器封装为增强器 Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); for (Advisor advisor : advisors) &#123; // 加入增强器 proxyFactory.addAdvisor(advisor); &#125; // 设置要代理的类 proxyFactory.setTargetSource(targetSource); // 定制dialing customizeProxyFactory(proxyFactory); // 用来控制代理工厂被配置之后是否还允许修改通知 缺省值为false（即在代理被配置之后不允许修改代理的配置） proxyFactory.setFrozen(this.freezeProxy); if (advisorsPreFiltered()) &#123; proxyFactory.setPreFiltered(true); &#125; // 创建代理 return proxyFactory.getProxy(getProxyClassLoader());&#125; 继续进入proxyFactory.getProxy(getProxyClassLoader())方法 123public Object getProxy(ClassLoader classLoader) &#123; return createAopProxy().getProxy(classLoader);&#125; 可以看到先是调用createAopProxy()创建AopProxy，由下图可以看到一个是cglib的代理，一个是jdk的代理 AopProxy 用于生成代理对象的委托类 12345public interface AopProxy &#123; Object getProxy(); Object getProxy(ClassLoader classLoader);&#125; 进入createAopProxy()方法，这里根据逻辑判断返回ObjenesisCglibAopProxy或者JdkDynamicAopProxy，如果目标对象实现了接口，默认情况下采用jdk的动态代理，也可以强制使用cglib实现aop(设置方式 &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;) 123456789101112131415161718192021222324252627282930313233343536373839protected final synchronized AopProxy createAopProxy() &#123; if (!this.active) &#123; activate(); &#125; // 创建代理 return getAopProxyFactory().createAopProxy(this);&#125; /** * 如果目标对象实现了接口，默认情况下采用jdk的动态代理，也可以强制使用cglib实现aop * 如果目标对象没有实现了接口，必须采用cglib * @param config the AOP configuration in the form of an * AdvisedSupport object * @return * @throws AopConfigException */ @Override public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; /** * optimize ：用来控制通过cglib创建的代理是否使用激进的优化策略，仅对cglib有效，一般不推荐用户使用这个设置 * proxyTargetClass ：为true时，目标类本身被代理而不是目标类的接口，那么cglib代理将被创建，设置方式 &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; * hasNoUserSuppliedProxyInterfaces: 是否存在代理接口 * */ if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass == null) &#123; throw new AopConfigException(\"TargetSource cannot determine target class: \" + \"Either an interface or a target is required for proxy creation.\"); &#125; if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; return new JdkDynamicAopProxy(config); &#125; return new ObjenesisCglibAopProxy(config); &#125; else &#123; return new JdkDynamicAopProxy(config); &#125; &#125; 调用createAopProxy()的到AopProxy之后就是调用AopProxy的getProxy(ClassLoader classLoader) 获取代理对象了 JdkDynamicAopProxy 下面看到了我们熟悉的Proxy.newProxyInstance方法 123456789@Overridepublic Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating JDK dynamic proxy: target source is \" + this.advised.getTargetSource()); &#125; Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 可以看到JdkDynamicAopProxy实现了InvocationHandler接口，那么我们可以推断这一定有一个invoke函数 1final class JdkDynamicAopProxy implements AopProxy, InvocationHandler, Serializable &#123; JdkDynamicAopProxy的invoke函数最重要的工作就是创建了一个拦截器链，并实现了拦截器链的逐一调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * Implementation of &#123;@code InvocationHandler.invoke&#125;. * &lt;p&gt;Callers will see exactly the exception thrown by the target, * unless a hook method throws an exception. */@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; MethodInvocation invocation; Object oldProxy = null; boolean setProxyContext = false; TargetSource targetSource = this.advised.targetSource; Class&lt;?&gt; targetClass = null; Object target = null; try &#123; // equals方法的处理 if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123; // The target does not implement the equals(Object) method itself. return equals(args[0]); &#125; // hash方法的处理 else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) &#123; // The target does not implement the hashCode() method itself. return hashCode(); &#125; else if (method.getDeclaringClass() == DecoratingProxy.class) &#123; // There is only getDecoratedClass() declared -&gt; dispatch to proxy config. return AopProxyUtils.ultimateTargetClass(this.advised); &#125; else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp; method.getDeclaringClass().isAssignableFrom(Advised.class)) &#123; // Service invocations on ProxyConfig with the proxy config... return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args); &#125; Object retVal; // 有时候目标对象内部的自我调用将无法实施切面中的增强则需要通过此属性暴露代理 if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; // May be null. Get as late as possible to minimize the time we \"own\" the target, // in case it comes from a pool. target = targetSource.getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; // Get the interception chain for this method. // 获取当前方法的拦截器链 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); // Check whether we have any advice. If we don't, we can fallback on direct // reflective invocation of the target, and avoid creating a MethodInvocation. if (chain.isEmpty()) &#123; // We can skip creating a MethodInvocation: just invoke the target directly // Note that the final invoker must be an InvokerInterceptor so we know it does // nothing but a reflective operation on the target, and no hot swapping or fancy proxying. Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); // 如果没有发现任何拦截器那么直接调用切点方法 retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); &#125; else &#123; // We need to create a method invocation... // 将拦截器封装在ReflectiveMethodInvocation，以便于使用其proceed进行链接表用拦截器 invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. // 执行拦截器链 retVal = invocation.proceed(); &#125; // Massage return value if necessary. Class&lt;?&gt; returnType = method.getReturnType(); if (retVal != null &amp;&amp; retVal == target &amp;&amp; returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp; !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123; // Special case: it returned \"this\" and the return type of the method // is type-compatible. Note that we can't help if the target sets // a reference to itself in another returned object. retVal = proxy; &#125; // 返回结果 else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123; throw new AopInvocationException( \"Null return value from advice does not match primitive return type for: \" + method); &#125; return retVal; &#125; finally &#123; if (target != null &amp;&amp; !targetSource.isStatic()) &#123; // Must have come from TargetSource. targetSource.releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125;&#125;@Overridepublic Object proceed() throws Throwable &#123; // We start with an index of -1 and increment early. // 执行完所有增强后执行切点方法 if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; return invokeJoinpoint(); &#125; // 获取下一个要执行的拦截器 Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; // Evaluate dynamic method matcher here: static part will already have // been evaluated and found to match. // 动态匹配 InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123; return dm.interceptor.invoke(this); &#125; else &#123; // Dynamic matching failed. // Skip this interceptor and invoke the next in the chain. // 不匹配则不执行拦截器 return proceed(); &#125; &#125; else &#123; // It's an interceptor, so we just invoke it: The pointcut will have // been evaluated statically before this object was constructed. // 普通拦截器，直接调用拦截器 将this作为参数传递以保证当前实例中调用链的执行 return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125; ObjenesisCglibAopProxy Cglib获取代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Overridepublic Object getProxy(ClassLoader classLoader) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating CGLIB proxy: target source is \" + this.advised.getTargetSource()); &#125; try &#123; Class&lt;?&gt; rootClass = this.advised.getTargetClass(); Assert.state(rootClass != null, \"Target class must be available for creating a CGLIB proxy\"); Class&lt;?&gt; proxySuperClass = rootClass; if (ClassUtils.isCglibProxyClass(rootClass)) &#123; proxySuperClass = rootClass.getSuperclass(); Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces(); for (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123; this.advised.addInterface(additionalInterface); &#125; &#125; // Validate the class, writing log messages as necessary. validateClassIfNecessary(proxySuperClass, classLoader); // Configure CGLIB Enhancer... Enhancer enhancer = createEnhancer(); if (classLoader != null) &#123; enhancer.setClassLoader(classLoader); if (classLoader instanceof SmartClassLoader &amp;&amp; ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123; enhancer.setUseCache(false); &#125; &#125; enhancer.setSuperclass(proxySuperClass); enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised)); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader)); Callback[] callbacks = getCallbacks(rootClass); Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length]; for (int x = 0; x &lt; types.length; x++) &#123; types[x] = callbacks[x].getClass(); &#125; // fixedInterceptorMap only populated at this point, after getCallbacks call above enhancer.setCallbackFilter(new ProxyCallbackFilter( this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset)); enhancer.setCallbackTypes(types); // Generate the proxy class and create a proxy instance. return createProxyClassAndInstance(enhancer, callbacks); &#125; catch (CodeGenerationException ex) &#123; throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" + this.advised.getTargetClass() + \"]: \" + \"Common causes of this problem include using a final class or a non-visible class\", ex); &#125; catch (IllegalArgumentException ex) &#123; throw new AopConfigException(\"Could not generate CGLIB subclass of class [\" + this.advised.getTargetClass() + \"]: \" + \"Common causes of this problem include using a final class or a non-visible class\", ex); &#125; catch (Throwable ex) &#123; // TargetSource.getTarget() failed throw new AopConfigException(\"Unexpected AOP exception\", ex); &#125;&#125; Cglib是一个强大的高性能代码生成包，底层通过使用一个小而快的字节码处理框架ASM，来转化字节码并生成新类 Cglib调用方法的核心逻辑在DynamicAdvisedInterceptor的intercept方法中，和jdk方式实现代理的invoke方法大同小异123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 核心逻辑 * General purpose AOP callback. Used when the target is dynamic or when the * proxy is not frozen. */private static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable &#123; private final AdvisedSupport advised; public DynamicAdvisedInterceptor(AdvisedSupport advised) &#123; this.advised = advised; &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; Object oldProxy = null; boolean setProxyContext = false; Class&lt;?&gt; targetClass = null; Object target = null; try &#123; if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true; &#125; // May be null. Get as late as possible to minimize the time we // \"own\" the target, in case it comes from a pool... target = getTarget(); if (target != null) &#123; targetClass = target.getClass(); &#125; // 获取拦截器链 List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); Object retVal; // Check whether we only have one InvokerInterceptor: that is, // no real advice, but just reflective invocation of the target. if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; // We can skip creating a MethodInvocation: just invoke the target directly. // Note that the final invoker must be an InvokerInterceptor, so we know // it does nothing but a reflective operation on the target, and no hot // swapping or fancy proxying. // 拦截器链为空直接激活原方法 Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = methodProxy.invoke(target, argsToUse); &#125; else &#123; // We need to create a method invocation... // 进入链 retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed(); &#125; retVal = processReturnType(proxy, target, method, retVal); return retVal; &#125; finally &#123; if (target != null) &#123; releaseTarget(target); &#125; if (setProxyContext) &#123; // Restore old proxy. AopContext.setCurrentProxy(oldProxy); &#125; &#125; &#125; 总结 由AspectJAnnotationAutoProxyCreator的继承关系图可以注意到此类实现了 BeanPostProcessor接口，BeanPostProcessor接口是IOC与AOP连接的桥梁 在研究源码之前可以尝试着自己想象一下解析思路，看看自己的思路和Spring是否有差别 参考 《Spring 源码深度解析》","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(五二)AOP源码解析之解析AOP自定义标签","slug":"backend/framework/spring/analysis/Spring系列(五二)AOP源码解析之解析AOP自定义标签","date":"2019-07-31T16:00:02.000Z","updated":"2019-06-23T03:00:53.340Z","comments":true,"path":"2019/08/01/backend/framework/spring/analysis/Spring系列(五二)AOP源码解析之解析AOP自定义标签/","link":"","permalink":"http://www.songshuiyang.site/2019/08/01/backend/framework/spring/analysis/Spring系列(五二)AOP源码解析之解析AOP自定义标签/","excerpt":"","text":"前言简单示例 创建切面类ServiceAspectj，这个方法用于定义切面，功能是打印方法的执行前的输入参数及输出结果 1234567891011121314151617181920212223242526@Slf4j@Aspect@Componentpublic class ServiceAspectj &#123; @Pointcut(value = \"execution(* org.springframework.iframe.service..*(..))\") public void pointcut() &#123; &#125; @Around(\"pointcut()\") public Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123; String className = pjp.getSignature().getDeclaringType().getSimpleName(); String methodName = pjp.getSignature().getName(); log.info(\"=&gt; [request method: &#123;&#125;#&#123;&#125;]\",className, methodName); log.info(\"=&gt; [request body: &#123;&#125;]\", JSONObject.toJSONString(pjp.getArgs())); Object result = pjp.proceed(); log.info(\"=&lt; [response method: &#123;&#125;#&#123;&#125;]\",className, methodName); log.info(\"=&lt; [response result: &#123;&#125; ]\", JSONObject.toJSONString(result)); return result; &#125;&#125; 需要切的方法 12345678910111213141516171819202122232425public interface UserService &#123; User findUserByName(String userName);&#125;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired User user; @Autowired private RoleService roleService; @Override public User findUserByName(String userName) &#123; User user = new User(userName,18); //Role role = roleService.findRoleByUserName(userName); user.setRole(new Role()); return user; &#125;&#125; Spring 配置文件 beans/bean.xml 添加&lt;aop:aspectj-autoproxy/&gt;配置，开启AOP开关 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;bean class=\"org.springframework.iframe.entity.User\"&gt; &lt;property name=\"userName\" value=\"shop\"/&gt; &lt;/bean&gt; &lt;!-- ComponentScanBeanDefinitionParser--&gt; &lt;context:component-scan base-package = \"org.springframework.iframe.*\"/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 测试类及测试结果 1234567@Testpublic void test1 () &#123; ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\"); UserService userService = xmlApplicationContext.getBean(UserService.class); User user1 = userService.findUserByName(\"sd\"); log.info(\"user1:&#123;&#125;\", user1);&#125; 123411:12:06,216 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request method: UserService#findUserByName]11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request body: [\"sd\"]]11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&lt; [response method: UserService#findUserByName]11:12:06,372 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&lt; [response result: &#123;\"age\":18,\"role\":&#123;&#125;,\"userName\":\"sd\"&#125; ] 从上面的例子可以看到已经实现了这个功能，那么Spring究竟是如何实现AOP的呢，以后的几个章节将介绍着一块 解析 beans/bean.xml 配置开启AOP开关 1234567891011// 默认标签&lt;bean class=\"org.springframework.iframe.entity.User\"&gt; &lt;property name=\"userName\" value=\"shop\"/&gt;&lt;/bean&gt;// 自定义标签&lt;!-- ComponentScanBeanDefinitionParser--&gt;&lt;context:component-scan base-package = \"org.springframework.iframe.*\"/&gt;// 自定义标签&lt;aop:aspectj-autoproxy/&gt; 关注上面配置文件 beans/bean.xml 中的 &lt;aop:aspectj-autoproxy/&gt;配置，之前的Spring系列(五)Document读取器BeanDefinitionDocumentReader章节就介绍了Spring的配置文件分为默认标签的解析及自定义标签的解析，我们现在这个&lt;aop:aspectj-autoproxy/&gt;配置和之前扫包的&lt;context:component-scan配置都属于自定义标签 回顾 123456789101112131415161718192021222324252627/** * Parse the elements at the root level in the document: * \"import\", \"alias\", \"bean\". * @param root the DOM root element of the document */protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // 如果是默认命名空间 xmlns=\"http://www.springframework.org/schema/beans\" if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; // 默认标签解析 如&lt;bean class=\"\"/&gt; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; // 自定义标签解析 如：&lt;context:component-scan base-package = \"*\"/&gt; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123;// 自定义标签解析 delegate.parseCustomElement(root); &#125;&#125; 进入自定义标签解析方法delegate.parseCustomElement(root); 12345678910111213141516public BeanDefinition parseCustomElement(Element ele) &#123; return parseCustomElement(ele, null);&#125;public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; // 获取xml配置文件中的命名空间http://www.springframework.org/schema/aop String namespaceUri = getNamespaceURI(ele); // 根据命名空间找到命名空间处理类AopNamespaceHandler NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; &#125; // 解析命名空间支持的标签 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 这里有个NamespaceHandler这个接口主要功能是通过Element标签找到对于的BeanDefinitionParser，找到之后然后调用BeanDefinitionParser接口的parse方法来解析 NamespaceHandler接口 命名空间处理器，我们就可以根据需求自己来处理我们设置的标签元素。 可能需要配置如&lt;aop:config /&gt;这样的标签, 在配置这个标签之前，通常我们需要在xml中引入这个aop所在的命名空间，xmlns:aop=&quot;http://www.springframework.org/schema/aop 只有通过配置aop的命名空间才会找到AOP标签的处理器{@link org.springframework.aop.config.AopNamespaceHandler}，在AOP的jar中的spring.handlers配置文件中配置了命名空间和命名空间处理器之间的关系。1http\\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler 比如我们这里是&lt;aop:aspectj-autoproxy/&gt;标签，所以得到的命名空间处理类是AopNamespaceHandler，那么是怎么得到的呢，关注this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);可以看到传入了一个namespaceUri 这里是进入到DefaultNamespaceHandlerResolver#resolve方法 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 注册handlerMappings * * Locate the &#123;@link NamespaceHandler&#125; for the supplied namespace URI * from the configured mappings. * @param namespaceUri the relevant namespace URI * @return the located &#123;@link NamespaceHandler&#125;, or &#123;@code null&#125; if none found */@Overridepublic NamespaceHandler resolve(String namespaceUri) &#123; Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; else &#123; String className = (String) handlerOrClassName; try &#123; Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123; throw new FatalBeanException(\"Class [\" + className + \"] for namespace [\" + namespaceUri + \"] does not implement the [\" + NamespaceHandler.class.getName() + \"] interface\"); &#125; // init方法 NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125; catch (ClassNotFoundException ex) &#123; throw new FatalBeanException(\"NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"] not found\", ex); &#125; catch (LinkageError err) &#123; throw new FatalBeanException(\"Invalid NamespaceHandler class [\" + className + \"] for namespace [\" + namespaceUri + \"]: problem with handler class file or dependent class\", err); &#125; &#125;&#125; 关注namespaceHandler.init();上下几行代码，这里有执行init()方法，下面的逻辑会调用，这个方法是注册标签与相应解析类对应关系的方法 AopNamespaceHandler.java 123456789101112131415161718public class AopNamespaceHandler extends NamespaceHandlerSupport &#123; /** * Register the &#123;@link BeanDefinitionParser BeanDefinitionParsers&#125; for the * '&#123;@code config&#125;', '&#123;@code spring-configured&#125;', '&#123;@code aspectj-autoproxy&#125;' * and '&#123;@code scoped-proxy&#125;' tags. */ @Override public void init() &#123; // In 2.0 XSD as well as in 2.1 XSD. registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator()); // Only in 2.0 XSD: moved to context namespace as of 2.1 registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser()); &#125;&#125; 关注registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());这行代码这里注册了标签命名与对应解析类的对应关系，并存放在Map&lt;String, BeanDefinitionParser&gt; parsers 对象中，所以现在 12345private final Map&lt;String, BeanDefinitionParser&gt; parsers = new HashMap&lt;String, BeanDefinitionParser&gt;(); protected final void registerBeanDefinitionParser(String elementName, BeanDefinitionParser parser) &#123; this.parsers.put(elementName, parser); &#125; 解析配置文件 上面的步骤已经得到了AopNamespaceHandler，然后就是进入handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); 方法开始解析 1234567891011121314151617181920212223242526/** * 先找到对应的BeanDefinitionParser 然后执行parse(element, parserContext)方法 * Parses the supplied &#123;@link Element&#125; by delegating to the &#123;@link BeanDefinitionParser&#125; that is * registered for that &#123;@link Element&#125;. */@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; return findParserForElement(element, parserContext).parse(element, parserContext);&#125;/** * 根据标签名得到相应的解析类，NamespaceHandler这里起到了一个中介的作用 * &#123;@link parsers&#125; Map&lt;String, BeanDefinitionParser&gt; 存放着所有的解析类，这个 * * Locates the &#123;@link BeanDefinitionParser&#125; from the register implementations using * the local name of the supplied &#123;@link Element&#125;. */private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123; String localName = parserContext.getDelegate().getLocalName(element); BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) &#123; parserContext.getReaderContext().fatal( \"Cannot locate BeanDefinitionParser for element [\" + localName + \"]\", element); &#125; return parser;&#125; 这里得到的是AspectJAutoProxyBeanDefinitionParser AspectJAutoProxyBeanDefinitionParser1234567891011121314151617181920212223242526272829303132333435363738class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser &#123; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 注册 AspectJAnnotationAutoProxyCreator 对应AOP的实现基本上是靠这个类来完成的 AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 对于注解中子类的处理 extendBeanDefinition(element, parserContext); return null; &#125; private void extendBeanDefinition(Element element, ParserContext parserContext) &#123; BeanDefinition beanDef = parserContext.getRegistry().getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME); if (element.hasChildNodes()) &#123; addIncludePatterns(element, parserContext, beanDef); &#125; &#125; private void addIncludePatterns(Element element, ParserContext parserContext, BeanDefinition beanDef) &#123; ManagedList&lt;TypedStringValue&gt; includePatterns = new ManagedList&lt;TypedStringValue&gt;(); NodeList childNodes = element.getChildNodes(); for (int i = 0; i &lt; childNodes.getLength(); i++) &#123; Node node = childNodes.item(i); if (node instanceof Element) &#123; Element includeElement = (Element) node; TypedStringValue valueHolder = new TypedStringValue(includeElement.getAttribute(\"name\")); valueHolder.setSource(parserContext.extractSource(includeElement)); includePatterns.add(valueHolder); &#125; &#125; if (!includePatterns.isEmpty()) &#123; includePatterns.setSource(parserContext.extractSource(element)); beanDef.getPropertyValues().add(\"includePatterns\", includePatterns); &#125; &#125;&#125; 关注parse方法 12345678@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // 注册 AspectJAnnotationAutoProxyCreator 对应AOP的实现基本上是靠这个类来完成的 AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 对于注解中子类的处理 extendBeanDefinition(element, parserContext); return null;&#125; AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);方法这里是注册了AspectJAnnotationAutoProxyCreator这个bean，RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);这里就把AnnotationAwareAspectJAutoProxyCreator.class给BeanDefinition绑定在一起了 1234567891011121314151617181920212223242526272829303132333435363738394041public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary( ParserContext parserContext, Element sourceElement) &#123; // 关键逻辑 注册或升级AutoProxyCreator定义为beanName为org.springframework.aop.config.internalAutoProxyCreator BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary( parserContext.getRegistry(), parserContext.extractSource(sourceElement)); // 对于proxy-target-class(强制使用CGLIB)以及expose-proxy属性的处理 useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement); // 注册组件并通知，便于监听器做进一步处理 registerComponentIfNecessary(beanDefinition, parserContext);&#125;// AopConfigUtils#registerAspectJAnnotationAutoProxyCreatorIfNecessary(org.springframework.beans.factory.support.BeanDefinitionRegistry, java.lang.Object)public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) &#123; return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);&#125;private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) &#123; Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); // 如果已经存在了自动代理创建器且存在的自动代理创建器与现在的不一致那么需要根据优先级来判断到底需要使用哪个 if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123; BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME); if (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123; int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName()); int requiredPriority = findPriorityForClass(cls); if (currentPriority &lt; requiredPriority) &#123; // 改变bean最重要的就是改变bean所对应的className属性 apcDefinition.setBeanClassName(cls.getName()); &#125; &#125; // 如果已经存在自动代理创建器并且与将要创建的一致，那么无需再次创建 return null; &#125; RootBeanDefinition beanDefinition = new RootBeanDefinition(cls); beanDefinition.setSource(source); beanDefinition.getPropertyValues().add(\"order\", Ordered.HIGHEST_PRECEDENCE); beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition); return beanDefinition;&#125; 处理proxy-target-class属性 123456789101112131415private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) &#123; if (sourceElement != null) &#123; // 对proxy-target-class属性的处理 JDK动态代理或者CGLIB boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE)); if (proxyTargetClass) &#123; AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); &#125; // 对expose-proxy属性的处理 boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE)); if (exposeProxy) &#123; // 强制使用的过程其实也是一个属性设置的过程 AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); &#125; &#125;&#125; 总结 在Spring中如果是用xml的方式配置Spring如果需要使用AOP功能，就需要在配置文件中添加&lt;aop:aspectj-autoproxy/&gt;属性，这个是打开AOP功能的开关，这是标签是自定义标签所以具体的解析工作是给AspectJAutoProxyBeanDefinitionParser来完成的，那么Spring是怎么知道这个&lt;aop:aspectj-autoproxy/&gt;由这个类来解析的呢，NamespaceHandler这个接口设计就发挥作用了，aop对应的命名空间处理器是AopNamespaceHandler（对应关系在aop的炸包里的META-INF/spring.handlers里设置），AopNamespaceHandler里面有配置（init方法）aspectj-autoproxy标签对应的解析类是AspectJAutoProxyBeanDefinitionParser &lt;aop:aspectj-autoproxy/&gt; 的最终结果是注册AspectJAnnotationAutoProxyCreator 这个bean，这个类用于创建AOP的代理类 参考 《Spring 源码深度解析》","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(五一)AOP切点表达式函数","slug":"backend/framework/spring/analysis/Spring系列(五一)AOP切点表达式函数","date":"2019-07-31T16:00:01.000Z","updated":"2019-06-22T03:16:27.092Z","comments":true,"path":"2019/08/01/backend/framework/spring/analysis/Spring系列(五一)AOP切点表达式函数/","link":"","permalink":"http://www.songshuiyang.site/2019/08/01/backend/framework/spring/analysis/Spring系列(五一)AOP切点表达式函数/","excerpt":"","text":"概述 Spring支持9个@ApsectJ切点表达式函数，它们用不同的方式描述目标类的连接点，根据描述对象的不同，可以将它们大致分为4种类型： 方法切点函数：通过描述目标类方法信息定义连接点； 方法入参切点函数：通过描述目标类方法入参的信息定义连接点； 目标类切点函数：通过描述目标类类型信息定义连接点； 代理类切点函数：通过描述目标类的代理类的信息定义连接点； 这4种类型的切点函数，通过下面的表格进行说明： 类别 函数 入参 说明 方法切点函数 execution() 方法匹配模式串 表示满足某一匹配模式的所有目标类方法连接点。如execution(* greetTo(..))表示所有目标类中的greetTo()方法。 @annotation() 方法注解类名 表示标注了特定注解的目标方法连接点。如@annotation(com.baobaotao.anno.NeedTest)表示任何标注了@NeedTest注解的目标类方法。 方法入参切点函数 args() 类名 通过判别目标类方法运行时入参对象的类型定义指定连接点。如args(com.baobaotao.Waiter)表示所有有且仅有一个按类型匹配于Waiter的入参的方法。 @args() 类型注解类名 通过判别目标方法的运行时入参对象的类是否标注特定注解来指定连接点。如@args(com.baobaotao.Monitorable)表示任何这样的一个目标方法：它有一个入参且入参对象的类标注@Monitorable注解。 目标类切点函数 within() 类名匹配串 表示特定域下的所有连接点。如within(com.baobaotao.service.*)表示com.baobaotao.service包中的所有连接点，也即包中所有类的所有方法，而within(com.baobaotao.service.*Service)表示在com.baobaotao.service包中，所有以Service结尾的类的所有连接点。 target() 类名 假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过target(com.baobaotao.Waiter)定义的切点，Waiter、以及Waiter实现类NaiveWaiter中所有连接点都匹配该切点。 @within() 类型注解类名 假如目标类按类型匹配于某个类A，且类A标注了特定注解，则目标类的所有连接点匹配这个切点。如@within(com.baobaotao.Monitorable)定义的切点，假如Waiter类标注了@Monitorable注解，则Waiter以及Waiter实现类NaiveWaiter类的所有连接点都匹配。 @target() 类型注解类名 目标类标注了特定注解，则目标类所有连接点匹配该切点。如@target(com.baobaotao.Monitorable)，假如NaiveWaiter标注了@Monitorable，则NaiveWaiter所有连接点匹配切点。 代理类切点函数 this() 类名 代理类按类型匹配于指定类，则被代理的目标类所有连接点匹配切点。限制连接点匹配 AOP 代理的 Bean 引用为指定类型的类 详解execution() execution() 是最常见的切点函数,语法形式为 1excution(&lt;修饰符模式&gt; ? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?) 切点复合运算 &amp;&amp; 与运算符 &amp; 是特殊运算符，在xml可以使用 &amp;&amp; Spring 提供一个等效的运算符and || 或运算符 Spring 提供一个等效的运算符or ! 非运算符 Spring 提供一个等效的运算符not 示例代码：1234567891011121314151617@Before(\"!target(com.baobaotao.NaiveWaiter) \"+ \"&amp;&amp; execution(* serveTo(..)))\")public void notServeInNaiveWaiter() &#123; System.out.println(\"--notServeInNaiveWaiter() executed!--\");&#125;@After(\"within(com.baobaotao.*) \" + \" &amp;&amp; execution(* greetTo(..)))\")public void greeToFun() &#123; System.out.println(\"--greeToFun() executed!--\");&#125;@AfterReturning(\"target(com.baobaotao.Waiter) || \"+ \" target(com.baobaotao.Seller)\")public void waiterOrSeller()&#123; System.out.println(\"--waiterOrSeller() executed!--\");&#125; 命名切点 运用命名切点，可以实现切点表达式的复用12345678910111213public class TestNamePointcut &#123; // 只能在本切面类中使用 @Pointcut(\"within(com.smart.*)\") private void inPackage()&#123;&#125; // 在切面类、子切面类中使用 @Pointcut(\"execution(* greetTo(..)))\") protected void greetTo()&#123;&#125; // 公共使用 @Pointcut(\"inPackage() and greetTo()\") public void inPkgGreetTo()&#123;&#125;&#125; 访问连接点信息JoinPoint java.lang.Object[] getArgs()：获取连接点方法运行时的入参列表； Signature getSignature() ：获取连接点的方法签名对象； java.lang.Object getTarget() ：获取连接点所在的目标对象； java.lang.Object getThis() ：获取代理对象本身； ProceedingJoinPoint （ProceedingJoinPoint继承JoinPoint子接口，它新增了两个用于执行连接点方法的方法：） java.lang.Object proceed() throws java.lang.Throwable：通过反射执行目标对象的连接点处的方法； java.lang.Object proceed(java.lang.Object[] args) throws java.lang.Throwable：通过反射执行目标对象连接点处的方法，不过使用新的入参替换原来的入参。 切点表达式例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class ExecutionAspect &#123; /** * 匹配所有目标类的public方法 */ @Before(\"execution(public * *(..))\") /** * 匹配所有以To为后缀的方法 */ @Before(\"execution(* *To(..))\") /** * 匹配Waiter接口中的所有方法 */ @Before(\"execution(* com.aop.learn.service.Writer.*(..))\") /** * 匹配Waiter接口中及其实现类的方法 */ @Before(\"execution(* com.aop.learn.service.Writer+.*(..))\") /** * 匹配 com.aop.learn.service 包下所有类的所有方法 */ @Before(\"execution(* com.aop.learn.service.*(..))\") /** * 匹配 com.aop.learn.service 包,子孙包下所有类的所有方法 */ @Before(\"execution(* com.aop.learn.service..*(..))\") /** * 匹配 包名前缀为com的任何包下类名后缀为ive的方法,方法必须以Smart为前缀 */ @Before(\"execution(* com..*.*ive.Smart*(..))\") /** * 匹配 save(String name,int age) 函数 */ @Before(\"execution(* save(String,int))\") /** * 匹配 save(String name,*) 函数 第二个参数为任意类型 */ @Before(\"execution(* save(String,*))\") /** * 匹配 save(String name,..) 函数 除第一个参数固定外,接受后面有任意个入参且入参类型不限 */ @Before(\"execution(* save(String,..))\") /** * 匹配 save(String+) 函数 String+ 表示入参类型是String的子类 */ @Before(\"execution(* save(String+))\") /** * 最详细的切入点表达式 具体到包、类名、方法名、方法返回值、参数个数及类型类型 */ @Before(\"execution(public void com.bwlu.aop.MathCalculator.add(int, int))\") /** * 最模糊的切入点表达式 */ @Before(\"execution (* *.*(..))\") /** * MathCalculator中的任意方法,任意参数列表 */ @Before(\"execution(public void com.bwlu.aop.MathCalculator.*(..))\") /** * MathCalculator中的任意方法,任意参数列表，任意返回值 */ @Before(\"execution(public * com.bwlu.aop.MathCalculator.*(..))\") /** * MathCalculator中的任意方法,任意参数列表，任意返回值，任意访问修饰符 */ @Before(\"execution( * com.bwlu.aop.MathCalculator.*(..))\") 1234567/** * 匹配Controller * @within :使用 “@within(注解类型)” 匹配所以持有指定注解类型内的方法;注解类型也必须是全限定类型名; */@Pointcut(\"@within(org.springframework.stereotype.Controller) || @within(org.springframework.web.bind.annotation.RestController)\")public void excudeService() &#123;&#125; 参考 《精通Spring+4.x++企业应用开发实战》 https://blog.csdn.net/yangshangwei/article/details/77943720","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(五十)面向切面编程AOP","slug":"backend/framework/spring/analysis/Spring系列(五十)面向切面编程AOP","date":"2019-07-31T16:00:00.000Z","updated":"2019-06-22T03:12:38.653Z","comments":true,"path":"2019/08/01/backend/framework/spring/analysis/Spring系列(五十)面向切面编程AOP/","link":"","permalink":"http://www.songshuiyang.site/2019/08/01/backend/framework/spring/analysis/Spring系列(五十)面向切面编程AOP/","excerpt":"概念什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 为什么要用Aop 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 在不改变原有方法的基础添加一些功能 , 比如: 日志记录 性能统计 安全控制 事务处理 异常处理等等","text":"概念什么是AOP 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 为什么要用Aop 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 在不改变原有方法的基础添加一些功能 , 比如: 日志记录 性能统计 安全控制 事务处理 异常处理等等 Aop 术语 连接点(JoinPoint) 程序执行到某个特定位置，如类开始初始化前，类初始化后，某个方法调用前/后，方法抛出异常后，一些具有边界性质的特定点就是连接点， Spring 仅支持方法级的连接点(方法执行前，方法完成后，抛出异常后) 切点(Pointcut) 从连接点的基础上引出的概念，是指特定的连接点，一个类有好多方法,每个方法又有多个连接点，则需要切点来限定一个小范围的连接点，在Spring中是使用类和方法作为连接点的查询条件 通知、增强处理(Advice) 就是指你所需要添加的功能及这个功能什么时候(通知)实现 , 比如一个业务方法需要实现日志功能 , 那么就需要专门在一个地方定义好需要做什么，然后定义什么时候执行(方法执行前？，方法完成后？，抛出异常？。。。) Spring 切面可应用的 5 种通知类型： Before——在方法调用之前调用通知 After——在方法完成之后调用通知，无论方法执行成功与否 After-returning——在方法执行成功之后调用通知 After-throwing——在方法抛出异常后进行通知 Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为 引入(introduction) 特殊的增强，为类添加一些属性和方法，这样即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类 切面(Aspect) 切面由切点和增强组成 , 及包括横切逻辑的定义，也包括切点的定义, 目标对象(Target) 增强逻辑的织入目标类 , 如果没有Aop,那么目标对象就要自己实现(日志记录，性能统计，安全控制，事务处理，异常处理)这些功能，那么一个方法就会变成很杂乱 织入(Weaing) 将增强添加到目标对象的具体连接点上, Spring使用动态代理织入 Aop有三种织入方式 编译期织入 类装载期织入 动态代理织入: 在运行期间为目标类添加增强生成子类的方式 Aop 实现一：JDK动态代理二：CGLib动态代理代理知识总结 Spring使用JDK动态代理和CGLib动态代理技术在运行期织入增强，要使用JDK动态代理，目标类必须实现接口，而CGLib不对目标类作任何限制，他是通过动态生成目标类子类的方式提供代理 JDK在创建代理对象时的性能高于CGLib，但生成的代理对象的运行性能却比CGLib的低，如果无需频繁的创建代理对象比较适合采用CGLib动态代理技术，反之比较适合JDK动态代理技术 AOP示例 创建切面类ServiceAspectj，这个方法用于定义切面，功能是打印方法的执行前的输入参数及输出结果 1234567891011121314151617181920212223242526@Slf4j@Aspect@Componentpublic class ServiceAspectj &#123; @Pointcut(value = \"execution(* org.springframework.iframe.service..*(..))\") public void pointcut() &#123; &#125; @Around(\"pointcut()\") public Object doAround(ProceedingJoinPoint pjp) throws Throwable &#123; String className = pjp.getSignature().getDeclaringType().getSimpleName(); String methodName = pjp.getSignature().getName(); log.info(\"=&gt; [request method: &#123;&#125;#&#123;&#125;]\",className, methodName); log.info(\"=&gt; [request body: &#123;&#125;]\", JSONObject.toJSONString(pjp.getArgs())); Object result = pjp.proceed(); log.info(\"=&lt; [response method: &#123;&#125;#&#123;&#125;]\",className, methodName); log.info(\"=&lt; [response result: &#123;&#125; ]\", JSONObject.toJSONString(result)); return result; &#125;&#125; 需要切的方法 12345678910111213141516171819202122232425public interface UserService &#123; User findUserByName(String userName);&#125;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired User user; @Autowired private RoleService roleService; @Override public User findUserByName(String userName) &#123; User user = new User(userName,18); //Role role = roleService.findRoleByUserName(userName); user.setRole(new Role()); return user; &#125;&#125; Spring 配置文件 beans/bean.xml 添加&lt;aop:aspectj-autoproxy/&gt;配置，开启AOP开关 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;bean class=\"org.springframework.iframe.entity.User\"&gt; &lt;property name=\"userName\" value=\"shop\"/&gt; &lt;/bean&gt; &lt;!-- ComponentScanBeanDefinitionParser--&gt; &lt;context:component-scan base-package = \"org.springframework.iframe.*\"/&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 测试类及测试结果 1234567@Testpublic void test1 () &#123; ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\"); UserService userService = xmlApplicationContext.getBean(UserService.class); User user1 = userService.findUserByName(\"sd\"); log.info(\"user1:&#123;&#125;\", user1);&#125; 123411:12:06,216 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request method: UserService#findUserByName]11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&gt; [request body: [\"sd\"]]11:12:06,307 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&lt; [response method: UserService#findUserByName]11:12:06,372 [INFO ] [org.springframework.iframe.aop.ServiceAspectj] - =&lt; [response result: &#123;\"age\":18,\"role\":&#123;&#125;,\"userName\":\"sd\"&#125; ] 总结 AOP的工作重心就是将增强应用与目标对象的连接点上，这里包括两部分内容： 如何通过切点和增强定位到连接点上 如何在增强中编写切面的逻辑 参考 《精通Spring+4.x++企业应用开发实战》","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(三十)ApplicationContext分析","slug":"backend/framework/spring/analysis/Spring系列(三一)ApplicationContext分析","date":"2019-07-02T14:02:46.000Z","updated":"2019-06-22T01:45:11.808Z","comments":true,"path":"2019/07/02/backend/framework/spring/analysis/Spring系列(三一)ApplicationContext分析/","link":"","permalink":"http://www.songshuiyang.site/2019/07/02/backend/framework/spring/analysis/Spring系列(三一)ApplicationContext分析/","excerpt":"","text":"前言 BeanFactory 是容器的顶级抽象，它并不适用于我们生产环境，在生产环境我们通常会选择 ApplicationContext ，相对于大多数人而言，它才是正规军，相比于 BeanFactory 这个杂牌军而言，它由如下几个区别： 继承 MessageSource，提供国际化的标准访问策略。 继承 ApplicationEventPublisher ，提供强大的事件机制。 扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源。 对 Web 应用的支持。 ApplicationContext 接口 接口代码 123456789101112131415public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123; String getId(); String getApplicationName(); String getDisplayName(); long getStartupDate(); ApplicationContext getParent(); AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;&#125; 类继承关系 BeanFactory Spring 管理 Bean 的顶层接口，我们可以认为他是一个简易版的 Spring 容器。ApplicationContext 继承 BeanFactory 的两个子类：HierarchicalBeanFactory 和 ListableBeanFactory。 HierarchicalBeanFactory 是一个具有层级关系的 BeanFactory，拥有属性 parentBeanFactory 。 ListableBeanFactory 实现了枚举方法可以列举出当前 BeanFactory 中所有的 bean 对象而不必根据 name 一个一个的获取。 ApplicationEventPublisher 用于封装事件发布功能的接口，向事件监听器（Listener）发送事件消息。 ResourceLoader Spring 加载资源的顶层接口，用于从一个源加载资源文件。ApplicationContext 继承 ResourceLoader 的子类 ResourcePatternResolver，该接口是将 location 解析为 Resource 对象的策略接口。 MessageSource 解析 message 的策略接口，用不支撑国际化等功能。 EnvironmentCapable 用于获取 Environment 的接口。 接口方法(包括父类方法) ApplicationContext 常用子类1、 WebApplicationContext 该接口只有一个 #getServletContext() 方法，用于给 Servlet 提供上下文信息。 1234567// WebApplicationContext.javapublic interface WebApplicationContext extends ApplicationContext &#123; ServletContext getServletContext(); &#125; 2、 ClassPathXmlApplicationContext ClassPathXmlApplicationContext 是我们在学习 Spring 过程中用的非常多的一个类 ClassPathXmlApplicationContext 设计的顶级接口 BeanFactory Spring 容器 Bean 的管理 MessageSource 管理 message ，实现国际化等功能 ApplicationEventPublisher 事件发布,用于封装事件发布功能的接口，向事件监听器（Listener）发送事件消息。 ResourcePatternResolver 资源加载 EnvironmentCapable 系统 Environment（profile + Properties） 相关 Lifecycle 管理生命周期 Closable 关闭，释放资源,用于关闭 ApplicationContext 销毁所有 Bean InitializingBean 自定义初始化 BeanNameAware 设置 beanName 的 Aware 接口 3、ConfigurableApplicationContext 接口 ConfigurableApplicationContext 对 ApplicationContext 接口再次进行扩展，提供了生命周期的管理功能。 总结 Spring 真的是一个非常优秀的框架，具有良好的结构设计和接口抽象，它的每一个接口职能单一，且都是具体功能到各个模块的高度抽象，且几乎每套接口都提供了一个默认的实现（defaultXXX）。 抽象类 ApplicationContext 对整套接口提供了大部分的默认实现，将其中“不易变动”的部分进行了封装，通过“组合”的方式将“容易变动”的功能委托给其他类来实现，同时利用模板方法模式将一些方法的实现开放出去由子类实现，从而实现“对扩展开放，对修改封闭”的设计原则。 参考 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(三十)IOC容器技术内幕","slug":"backend/framework/spring/analysis/Spring系列(三十)IOC容器技术内幕","date":"2019-07-02T14:02:45.000Z","updated":"2019-06-22T01:59:21.352Z","comments":true,"path":"2019/07/02/backend/framework/spring/analysis/Spring系列(三十)IOC容器技术内幕/","link":"","permalink":"http://www.songshuiyang.site/2019/07/02/backend/framework/spring/analysis/Spring系列(三十)IOC容器技术内幕/","excerpt":"","text":"前言IOC是什么 Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来： 当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示: IOC和DI Dependency Injection 即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 那么IOC和DI这两者又是什么关系呢？ IOC就是一种软件设计思想，DI是这种软件设计思想的一个实现。而Spring中的核心机制就是DI。 IOC注入形式 构造函数注入 通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。 setter 方法注入 当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中 接口注入 接口方式注入需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。 Spring支持前两种依赖注入方式 Spring 容器 该图为 ClassPathXmlApplicationContext 的类继承体系结构，虽然只有一部分，但是它基本上包含了 IoC 体系中大部分的核心类和接口。 如果将Spring容器比作一辆车，那么可以将BeanFactory看成汽车的发动机，而ApplicationContext则是一辆完整的汽车，它不但包括发动机，还包括离合器、变速器及底盘、车身、电气设备等其他组件。在ApplicationContext内，各个组件按部就班、有条不絮地完成汽车的各项功能。 内部工作机制Spring 容器启动逻辑 Spring的AbstractApplicationContext是ApplicationContext的抽象实现类，该抽象类的refresh()方法定义了Spring容器在加载配置文件后的各项处理过程，这些处理过程清新地刻画了Spring容器启动时所执行地各项操作：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // 初始化BeanFactory ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean， // 并调用其postProcessBeanFactory接口方法 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean， // 并将它们注册到容器Bean后处理器的注册表中 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 初始化消息源 初始化容器的国际化消息资源 initMessageSource(); // Initialize event multicaster for this context. // 初始化应用上下文事件广播器 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 初始化其他特殊的bean，由具体子类实现，这是个钩子方法 onRefresh(); // Check for listener beans and register them. // 注册事件监听器 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 初始化所有单实例的Bean，使用懒加载模式的bean除外，初始化Bean后将它们放到Spring容器的缓冲池中 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // 完成刷新并发布容器刷新事件 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 处理流程图 Spring容器从加载配置文件到创建一个完整Bean的作业流程及参与的角色 由上图可以得到Spring容器的构造逻辑，如下： 1、ResourceLoader从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件资源； 2、BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中； 3、容器扫描BeanDefintionRegistry中的BeanDefintion，使用Java反射机制自动识别出Bean工厂后处理器(实现BeanFactoryPostProcessor接口的Bean)，然后调用这些Bean工厂后处理对BeanDefinitionRegistry中的BeanDefinition进行加工处理。主要完成一下两项工作: 1). 对使用占位符的&lt; bean &gt;元素标签进行解析，得到最终的配置值。这意味着对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象； 2). 对BeanDefinitionRegistry中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean(实现java.beans.PropertyEditor接口的Bean)，并自动将它们注册到Spring容器的属性器注册表中(PropertyEditorRegistry)。 4、Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，并调用InstantiationStarategy着手进行Bean实例化的工作； 5、在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装。BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefintion及容器中的属性编辑器，完成Bean属性注入工作； 6、利用容器中的Bean后处理器(实现BeanPostProcessor接口的Bean)对己经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean；总结 Spring容器堪称一部设计精密的机器，其内部拥有众多的组件和装置。Spring的高明之处在于，它使用众多接口描绘除了所有的装置的协作蓝图，构建好Spring的骨架，继而通过继承体系层层推演、不断丰富，最终让Spring成为有血有肉的完整的框架。所有在查看Spring框架的源码时，有两条清晰可见的脉络： 接口层描述了容器的重要组件及组件间的协作关系 继承体系逐步实现组件的各项功能。 接口层清晰地勾勒出Spring框架地高层功能，框架脉络呼之欲出。有了接口层抽象地描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同的实现，可以说Spring完善的接口层使框架的扩展性得到了很好的保证 纵向继承体系的逐步发展，分步骤地实现框架地功能，这种实现方案保证了框架功能不会堆积在某些类身上，从而造成过重地代码逻辑负载，框架的复杂度被完美地分解开了。 Spring可以就像一个餐馆，为顾客提供各种各样的美味佳肴，那么它是怎样做出美味的饭菜呢？ Spring的设计者就是餐馆的老板，统筹规划餐馆的运作 原始食材：xml配置的bean ，高级一点的原始食材注解配置的bean，加工后的食材：Resource BeanDefinition PropertyEditor 采购员：ResourceLoader，择菜员：BeanDefinitionReader，仓库：BeanDefintionRegistry ,厨师就是将准备好的食材烹饪为菜肴其他 在Spring也可以注入List/Map 之前一直使用xml的方式进行Spring配置，对于内部元素为String的List和Map属性的注入一般为如下方式： 123456789101112131415&lt;bean id = \"testBean\" class = \"com.a.b.c.TestBean\"&gt; &lt;property name = \"fieldMap\"&gt; &lt;map&gt; &lt;entry key = \"field1\" value = \"value1\"&gt;&lt;/entry&gt; &lt;entry key = \"field2\" value = \"value2\"&gt;&lt;/entry&gt; &lt;entry key = \"field3\" value = \"value3\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name = \"fieldList\"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 如果内部元素为Bean，则将value替换为value-ref或元素即可。 当然，我们也可以使用Spring提供的schema扩展util来实现List和Map的声明、注入： 123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd\"&gt; &lt;util:list list-class=\"java.util.ArrayList\"&gt; &lt;value&gt;1&lt;/value&gt; &lt;value&gt;2&lt;/value&gt; &lt;value&gt;3&lt;/value&gt; &lt;/util:list&gt; &lt;util:map map-class=\"java.util.HashMap\"&gt; &lt;entry key=\"Key1\" value=\"1\" /&gt; &lt;entry key=\"Key2\" value=\"2\" /&gt; &lt;entry key=\"Key3\" value=\"3\" /&gt; &lt;/util:map&gt;&lt;/beans&gt; 目前多用注解的方式来注入String类型的List和Map： properties.yml12test.map = &#123;key1:'value1',key2:'value2',key3:'value3'&#125;test.list = value1,value2,value3 在目标Bean中使用@Value注解进行注入： @Value(\"#{'${test.list}'.split(',')}\") private List&lt;String&gt; testList; @Value(\"#{${test.map}}\") private Map&lt;String,String&gt; testMap; 总结参考 《精通Spring+4.x++企业应用开发实战》 https://jinnianshilongnian.iteye.com/blog/1413846 http://www.cnblogs.com/xdp-gacl/p/4249939.html https://blog.csdn.net/li_xiao_dai/article/details/80667246 https://www.cnblogs.com/xiao2/p/7706902.html http://svip.iocoder.cn/Spring/IoC-intro/","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(二三)PropertySource及Environment及Profile接口分析","slug":"backend/framework/spring/analysis/Spring系列(二三)PropertySource及Environment及Profile接口分析","date":"2019-07-01T15:01:46.000Z","updated":"2019-06-22T03:26:43.439Z","comments":true,"path":"2019/07/01/backend/framework/spring/analysis/Spring系列(二三)PropertySource及Environment及Profile接口分析/","link":"","permalink":"http://www.songshuiyang.site/2019/07/01/backend/framework/spring/analysis/Spring系列(二三)PropertySource及Environment及Profile接口分析/","excerpt":"","text":"前言 spring.profiles.active 和 @Profile 这两个我相信各位都熟悉吧，主要功能是可以实现不同环境下（开发、测试、生产）参数配置的切换。 解析 Spring 环境 &amp; 属性由四个部分组成：PropertySource、PropertyResolver、Profile 和 Environment。 PropertySource 属性源，key-value 属性对抽象，用于配置数据。 PropertyResolver 属性解析器，用于解析任何基础源的属性的接口 Profile 剖面，只有激活的剖面的组件/配置才会注册到 Spring 容器，类似于 Spring Boot 中的 profile 。 Environment Environment 对象的作用，是确定哪些配置文件（如果有）当前处于活动状态，以及默认情况下哪些配置文件（如果有）应处于活动状态。properties 在几乎所有应用程序中都发挥着重要作用，并且有多种来源：属性文件，JVM 系统属性，系统环境变量，JNDI，servlet 上下文参数，ad-hoc 属性对象，映射等。同时它继承 PropertyResolver 接口，所以与属性相关的 Environment 对象其主要是为用户提供方便的服务接口，用于配置属性源和从中属性源中解析属性。 123456789101112// Environment.javapublic interface Environment extends PropertyResolver &#123; // 返回此环境下激活的配置文件集 String[] getActiveProfiles(); // 如果未设置激活配置文件，则返回默认的激活的配置文件集 String[] getDefaultProfiles(); boolean acceptsProfiles(String... profiles);&#125; 总结参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(二一)BeanPostProcessor接口分析","slug":"backend/framework/spring/analysis/Spring系列(二一)BeanPostProcessor接口分析","date":"2019-07-01T14:01:46.000Z","updated":"2019-06-23T03:12:27.230Z","comments":true,"path":"2019/07/01/backend/framework/spring/analysis/Spring系列(二一)BeanPostProcessor接口分析/","link":"","permalink":"http://www.songshuiyang.site/2019/07/01/backend/framework/spring/analysis/Spring系列(二一)BeanPostProcessor接口分析/","excerpt":"","text":"前言 BeanPostProcessor接口 123456public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; BeanPostProcessor 可以理解为是 Spring 的一个工厂钩子（其实 Spring 提供一系列的钩子，如 Aware 、InitializingBean、DisposableBean），它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 bean 阶段对其进行定制化修改，比较常见的使用场景是处理标记接口实现类或者为当前对象提供代理实现（例如 AOP）。 #postProcessBeforeInitialization(Object bean, String beanName) 和 #postProcessAfterInitialization(Object bean, String beanName) 两个方法，都接收一个 Object 类型的 bean ，一个 String 类型的 beanName ，其中bean 是已经实例化了的 instanceBean ，能拿到这个你是不是可以对它为所欲为了？ 这两个方法是初始化 bean 的前后置处理器，他们应用 #invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)方法的前后。如下图: 解析BeanPostProcessor接口方法调用 接口的两个方法是哪里调用了呢，又回到回到doCreateBean(...) 方法，这个方法主要用于完成 bean 的创建和初始化工作，我们可以将其分为一下几个过程 createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) 方法，实例化 bean 。 populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) 方法，进行属性填充。 initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) 方法，初始化 Bean 。 还是关注initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) 方法，从下面的代码关注重点1及重点2两行，可以看到中间就夹了个invokeInitMethods(beanName, wrappedBean, mbd);方法，这个方法用于初始化bean，也就是用于激活用户自定义的初始化方法 进入invokeInitMethods(beanName, wrappedBean, mbd);方法，可以看到下面是检测当前 bean 对象是否实现了 InitializingBean接口。如果是，则会调用其 #afterPropertiesSet() 方法，进一步调整 bean 实例对象的状态。 1234567891011121314151617181920212223242526272829303132333435363738protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) throws Throwable &#123; // 检测当前 bean 对象是否实现了 InitializingBean 接口。如果是，则会调用其 #afterPropertiesSet() 方法，进一步调整 bean 实例对象的状态。 boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\"); &#125; if (System.getSecurityManager() != null) &#123; try &#123; // 调用afterPropertiesSet方法 AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; // 属性初始化的处理 ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; if (mbd != null) &#123; String initMethodName = mbd.getInitMethodName(); if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; \"afterPropertiesSet\".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; // 调用自定义初始化方法 invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125;&#125; 然后，再检查是否也指定了 init-method，如果指定了则通过反射机制调用指定的 init-method 方法。 但是如果真的让我们的业务对象来实现这个InitializingBean接口就显得不是那么的友好了，Spring 的一个核心理念就是无侵入性，但是如果我们业务类实现这个接口就显得 Spring 容器具有侵入性了。所以 Spring 还提供了另外一种实现的方式：init-method 方法 使用init-method完全可以达到和 InitializingBean 一样的效果，而且在代码中我们没有看到丝毫 Spring 侵入的现象。所以通过 init-method 我们可以使用业务对象中定义的任何方法来实现 bean 实例对象的初始化定制化，而不再受制于 InitializingBean的 #afterPropertiesSet() 方法。同时我们可以使用 &lt;beans&gt; 标签的 default-init-method 属性来统一指定初始化方法，这样就省了需要在每个 &lt;bean&gt; 标签中都设置 init-method 这样的繁琐工作了 12345678910111213141516171819202122232425262728293031323334353637protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 对特殊的bean处理 Aware、BeanClassLoaderAware、BeanFactoryAware invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; // 重点1：BeanPostProcessor前置处理 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; // 激活用户自定义的init方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; // 重点2：BeanPostProcessor后置处理 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 重点1：BeanPostProcessor前置处理 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); 12345678910111213@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 重点2：BeanPostProcessor后置处理 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); 1234567891011121314@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; // 实现 BeanPostProcessor 接口用户可以根据自己的业务需求进行响应的处理 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessAfterInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; BeanPostProcessor自动检测并注册 #getBeanPostProcessors() 方法，返回的是 BeanPostProcessor 集合，该集合里面存放就是我们自定义的 BeanPostProcessor 如果该集合中存在元素则调用相应的方法，否则就直接返回 bean 了。这也是为什么使用 BeanFactory 容器是无法输出自定义 BeanPostProcessor 里面的内容，因为在 BeanFactory#getBean(...) 方法的过程中根本就没有将我们自定义的 BeanPostProcessor 注入进来，所以要想 BeanFactory 容器 的 BeanPostProcessor 生效我们必须手动调用 #addBeanPostProcessor(BeanPostProcessor, beanPostProcessor) 方法，将定义的 BeanPostProcessor 注册到相应的 BeanFactory 中。但是 ApplicationContext 不需要手动，因为 ApplicationContext 会自动检测并完成注册。 ApplicationContext 实现自动注册的原因，在于我们构造一个 ApplicationContext 实例对象的时候会调用 #registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) 方法，将检测到的 BeanPostProcessor 注入到 ApplicationContext 容器中，同时应用到该容器创建的 bean 中。代码如下： 123456789101112131415161718192021222324252627282930313233@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开 // 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持 prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. // 子类覆盖方法做额外的处理 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean， // 并调用其postProcessBeanFactory接口方法 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean， // 并将它们注册到容器Bean后处理器的注册表中，这里只是注册，真正的调用在getBean时候 registerBeanPostProcessors(beanFactory); ... 进入registerBeanPostProcessors(beanFactory);方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 实例化并调用已经注入的 BeanPostProcessor 必须在应用中 bean 实例化之前调用 * Instantiate and invoke all registered BeanPostProcessor beans, * respecting explicit order if given. * &lt;p&gt;Must be called before any instantiation of application beans. */protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);&#125;public static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123; // 获取所有的 BeanPostProcessor 的 beanName // 这些 beanName 都已经全部加载到容器中去，但是没有实例化 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false); // Register BeanPostProcessorChecker that logs an info message when // a bean is created during BeanPostProcessor instantiation, i.e. when // a bean is not eligible for getting processed by all BeanPostProcessors. int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length; beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount)); // Separate between BeanPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;String&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;String&gt;(); for (String ppName : postProcessorNames) &#123; if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); priorityOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, register the BeanPostProcessors that implement PriorityOrdered. // 第一步，注册所有实现了 PriorityOrdered 的 BeanPostProcessor // 先排序 sortPostProcessors(beanFactory, priorityOrderedPostProcessors); registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors); // Next, register the BeanPostProcessors that implement Ordered. // 第二步，注册所有实现了 Ordered 的 BeanPostProcessor List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); for (String ppName : orderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); orderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; sortPostProcessors(beanFactory, orderedPostProcessors); // 后注册 registerBeanPostProcessors(beanFactory, orderedPostProcessors); // Now, register all regular BeanPostProcessors. // 第三步注册所有无序的 BeanPostProcessor List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;BeanPostProcessor&gt;(); for (String ppName : nonOrderedPostProcessorNames) &#123; BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); nonOrderedPostProcessors.add(pp); if (pp instanceof MergedBeanDefinitionPostProcessor) &#123; internalPostProcessors.add(pp); &#125; &#125; // 注册，无需排序 registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors); // Finally, re-register all internal BeanPostProcessors. // 最后，注册所有的 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor sortPostProcessors(beanFactory, internalPostProcessors); registerBeanPostProcessors(beanFactory, internalPostProcessors); // Re-register post-processor for detecting inner beans as ApplicationListeners, // moving it to the end of the processor chain (for picking up proxies etc). // 加入ApplicationListenerDetector（探测器） // 重新注册 BeanPostProcessor 以检测内部 bean，因为 ApplicationListeners 将其移动到处理器链的末尾 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));&#125; 注册代码如下，可以看到是存放在AbstractBeanFactory类的private final List&lt;BeanPostProcessor&gt; beanPostProcessors属性中 1234567891011121314151617181920212223/** * Register the given BeanPostProcessor beans. */private static void registerBeanPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanPostProcessor&gt; postProcessors) &#123; for (BeanPostProcessor postProcessor : postProcessors) &#123; beanFactory.addBeanPostProcessor(postProcessor); &#125;&#125;@Overridepublic void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) &#123; Assert.notNull(beanPostProcessor, \"BeanPostProcessor must not be null\"); this.beanPostProcessors.remove(beanPostProcessor); this.beanPostProcessors.add(beanPostProcessor); if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) &#123; this.hasInstantiationAwareBeanPostProcessors = true; &#125; if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) &#123; this.hasDestructionAwareBeanPostProcessors = true; &#125;&#125; 总结 Spring对对象的可扩展性主要就是依靠BeanPostProcessor来完成的，使用BeanPostProcessor可以对实例化后的bean为所欲为，添加自己的逻辑，不过一般项目开发中很少用到这个类 BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同，ApplicationContext 会自动检测所有实现了 BeanPostProcessor 接口的 bean，并完成注册，但是使用 BeanFactory 容器时则需要手动调用 AbstractBeanFactory#addBeanPostProcessor(BeanPostProcessor beanPostProcessor) 方法来完成注册 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(二二)BeanPostProcessor接口分析","slug":"backend/framework/spring/analysis/Spring系列(二二)BeanFactoryPostProcessor接口分析","date":"2019-07-01T14:01:46.000Z","updated":"2019-06-22T03:26:43.541Z","comments":true,"path":"2019/07/01/backend/framework/spring/analysis/Spring系列(二二)BeanFactoryPostProcessor接口分析/","link":"","permalink":"http://www.songshuiyang.site/2019/07/01/backend/framework/spring/analysis/Spring系列(二二)BeanFactoryPostProcessor接口分析/","excerpt":"","text":"前言 前面我们知道BeanPostProcessor是Spring 的一个工厂钩子，使用户可以对实例化后的Bean初始化之际对 Bean 进行增强处理（前、后置处理），同样在 Spring 容器启动阶段，Spring 也提供了一种容器扩展机制：BeanFactoryPostProcessor，该机制作用于容器启动阶段，允许我们在容器实例化 Bean 之前对注册到该容器的 BeanDefinition 做出修改。 BeanFactoryPostProcessor 的机制，就相当于给了我们在 Bean 实例化之前最后一次修改 BeanDefinition 的机会，我们可以利用这个机会对 BeanDefinition 来进行一些额外的操作，比如更改某些 bean 的一些属性，给某些 Bean 增加一些其他的信息等等操作。 解析BeanFactoryPostProcessor 接口定义 org.springframework.beans.factory.config.BeanFactoryPostProcessor 接口，定义如下： 12345public interface BeanFactoryPostProcessor &#123; void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;&#125; 这个方法工作于 BeanDefinition 加载完成之后，Bean实例化之前，其主要作用是对加载 BeanDefinition 进行修改 有一点需要需要注意的是在 #postProcessBeanFactory(...) 方法中千万不能进行 Bean 的实例化工作，因为这样会导致 Bean 过早实例化，会产生严重后果 我们始终需要注意的是 BeanFactoryPostProcessor 是与 BeanDefinition 打交道的，如果想要与 Bean 打交道，请使用 BeanPostProcessor 。 与 BeanPostProcessor 一样，BeanFactoryPostProcessor 同样支持排序，一个容器可以同时拥有多个 BeanFactoryPostProcessor ，这个时候如果我们比较在乎他们的顺序的话，可以实现 Ordered 接口。 BeanFactoryPostProcessor 在哪里调用 回到org.springframework.context.support.AbstractApplicationContext#refresh方法，关注invokeBeanFactoryPostProcessors(beanFactory);方法，见名知其意执行BeanFactoryPostProcessor方法 12345678910111213141516171819202122232425262728@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开 // 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持 prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. // 子类覆盖方法做额外的处理 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean， // 并调用其postProcessBeanFactory接口方法 invokeBeanFactoryPostProcessors(beanFactory); ... 进入invokeBeanFactoryPostProcessors(beanFactory);方法，这里出现了一个新的委托类PostProcessorRegistrationDelegate ，委托执行post processors任务的工具类 1234567891011121314151617/** * 实例化BeanFactoryPostProcessor实例及执行其接口方法 * * Instantiate and invoke all registered BeanFactoryPostProcessor beans, * respecting explicit order if given. * &lt;p&gt;Must be called before singleton instantiation. */protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125;&#125; 进入PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())方法 12345678910/** * Invoke the given BeanFactoryPostProcessor beans. */private static void invokeBeanFactoryPostProcessors( Collection&lt;? extends BeanFactoryPostProcessor&gt; postProcessors, ConfigurableListableBeanFactory beanFactory) &#123; for (BeanFactoryPostProcessor postProcessor : postProcessors) &#123; postProcessor.postProcessBeanFactory(beanFactory); &#125;&#125; BeanFactoryPostProcessor 子类PropertyPlaceholderConfigurer 允许我们在 XML 配置文件中使用占位符并将这些占位符所代表的资源单独配置到简单的 properties 文件中来加载 总结参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn https://blog.csdn.net/andy_zhang2007/article/details/78530137","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(二十)Aware接口分析","slug":"backend/framework/spring/analysis/Spring系列(二十)Aware接口分析","date":"2019-07-01T14:00:46.000Z","updated":"2019-06-20T15:04:27.669Z","comments":true,"path":"2019/07/01/backend/framework/spring/analysis/Spring系列(二十)Aware接口分析/","link":"","permalink":"http://www.songshuiyang.site/2019/07/01/backend/framework/spring/analysis/Spring系列(二十)Aware接口分析/","excerpt":"","text":"前言 平常开发中会经常用到下面这个工具类，用于获取对应的ApplicationContext容器，然后再根据ApplicationContext获取对应的Bean，那么ApplicationContext applicationContext是怎么被注入进去的呢？ 123456789101112131415161718192021222324252627@Componentpublic class SpringContextUtils implements ApplicationContextAware, DisposableBean&#123; private static ApplicationContext applicationContext; public static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) &#123; return applicationContext.getBean(requiredType); &#125; public static Object getBean(String beanName) &#123; return applicationContext.getBean(beanName); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; SpringContextUtils.applicationContext = applicationContext; &#125; @Override public void destroy() throws Exception &#123; applicationContext=null; &#125;&#125; 观察上面的代码可以发现此类是被 @Component修饰的Bean，此外该类还实现了ApplicationContextAware接口，此接口就一个方法，这个方法的作用是获取ApplicationContext容器，下面我们来看看Spring是怎样实现此功能的 12345public interface ApplicationContextAware extends Aware &#123; void setApplicationContext(ApplicationContext applicationContext) throws BeansException;&#125; 解析Aware接口 org.springframework.beans.factory.Aware 接口，定义如下： 123456789101112131415161718192021222324/** * * 标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。 * * Marker superinterface indicating that a bean is eligible to be * notified by the Spring container of a particular framework object * through a callback-style method. Actual method signature is * determined by individual subinterfaces, but should typically * consist of just one void-returning method that accepts a single * argument. * * &lt;p&gt;Note that merely implementing &#123;@link Aware&#125; provides no default * functionality. Rather, processing must be done explicitly, for example * in a &#123;@link org.springframework.beans.factory.config.BeanPostProcessor BeanPostProcessor&#125;. * Refer to &#123;@link org.springframework.context.support.ApplicationContextAwareProcessor&#125; * and &#123;@link org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory&#125; * for examples of processing &#123;@code *Aware&#125; interface callbacks. * * @author Chris Beams * @since 3.1 */public interface Aware &#123;&#125; Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 bean 是具有被 Spring 容器通知的能力，通知的方式是采用回调的方式。 Aware 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接收单参数的 set 方法，该 set 方法的命名方式为 set + 去掉接口名中的 Aware 后缀，即 XxxAware 接口，则方法定义为 setXxx()，例如 BeanNameAware（setBeanName），ApplicationContextAware（setApplicationContext）。 Aware接口是如何发挥作用 Aware 的子接口需要提供一个 setXxx 方法，我们知道 set 是设置属性值的方法，即 Aware 类接口的 setXxx 方法其实就是设置 xxx 属性值的。 Aware 的含义是感知的、感应的，那么在 Spring 容器中是如何实现感知并设置属性值得呢？我们可以从初始化 bean 中的激活 Aware 的方法 #invokeAwareMethods(final String beanName, final Object bean) 中看到一点点，代码如下： 回顾doCreateBean(...) 方法，这个方法主要用于完成 bean 的创建和初始化工作，我们可以将其分为一下几个过程 createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) 方法，实例化 bean 。 populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) 方法，进行属性填充。 initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) 方法，初始化 Bean 。 Aware接口是怎样发挥作用的呢，进入initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) 方法，关注invokeAwareMethods(beanName, bean);方法，见名知其意 12345678910111213141516171819protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 对特殊的bean处理 Aware、BeanClassLoaderAware、BeanFactoryAware invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; // 应用后处理器 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; 进入invokeAwareMethods(beanName, bean); 可以看到实现逻辑十分简单，首先判断该bean是否实现了Aware，然后就是根据不同的Aware子类调用不同的方法 12345678910111213141516171819/** * 实现了这些Aware接口的bean被初始化之后，可以取得一些相对应的资源 * @param beanName * @param bean */private void invokeAwareMethods(final String beanName, final Object bean) &#123; // 下面都是直接调用接口方法 if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 上面的只有三种Aware并没有我们的ApplicationContextAware，关注wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);方法，从这里可以找到答案，下面代码又出现了熟悉的BeanPostProcessor，调用了bean初始化之前的钩子方法 12345678910111213@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 进入org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization方法，可以看到主要是调用了invokeAwareInterfaces(bean);方法 1234567891011121314151617181920212223242526@Overridepublic Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException &#123; AccessControlContext acc = null; if (System.getSecurityManager() != null &amp;&amp; (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) &#123; acc = this.applicationContext.getBeanFactory().getAccessControlContext(); &#125; if (acc != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareInterfaces(bean); return null; &#125; &#125;, acc); &#125; else &#123; invokeAwareInterfaces(bean); &#125; return bean;&#125; 进入invokeAwareInterfaces(bean);方法，这里就看到了Spring对其进行了设置值((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); 12345678910111213141516171819202122private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; if (bean instanceof ResourceLoaderAware) &#123; ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); &#125; if (bean instanceof ApplicationEventPublisherAware) &#123; ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); &#125; if (bean instanceof MessageSourceAware) &#123; ((MessageSourceAware) bean).setMessageSource(this.applicationContext); &#125; if (bean instanceof ApplicationContextAware) &#123; ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); &#125; &#125;&#125; Aware主要子类 ApplicationContextAware: 加载ApplicationContext LoadTimeWeaverAware：加载Spring Bean时织入第三方模块，如AspectJ BeanClassLoaderAware：加载Spring Bean的类加载器 BootstrapContextAware：资源适配器BootstrapContext，如JCA,CCI ResourceLoaderAware：底层访问资源的加载器 BeanFactoryAware：声明BeanFactory PortletConfigAware：PortletConfig PortletContextAware：PortletContext ServletConfigAware：ServletConfig ServletContextAware：ServletContext MessageSourceAware：国际化 ApplicationEventPublisherAware：应用事件 NotificationPublisherAware：JMX通知 BeanNameAware：声明Spring Bean的名字 总结 Aware 真正的含义是感知，其实是 Spring 容器在初始化主动检测当前 bean 是否实现了 Aware 接口，如果实现了则回调其 set 方法将相应的参数设置给该 bean ，这个时候该 bean 就从 Spring 容器中取得相应的资源。 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(十一)加载Bean之AutowiredAnnotationBeanPostProcessor@Autowired注解原理","slug":"backend/framework/spring/analysis/Spring系列(十一)加载Bean之AutowiredAnnotationBeanPostProcessor@Autowired注解原理","date":"2019-06-19T14:00:46.000Z","updated":"2019-06-20T14:01:46.089Z","comments":true,"path":"2019/06/19/backend/framework/spring/analysis/Spring系列(十一)加载Bean之AutowiredAnnotationBeanPostProcessor@Autowired注解原理/","link":"","permalink":"http://www.songshuiyang.site/2019/06/19/backend/framework/spring/analysis/Spring系列(十一)加载Bean之AutowiredAnnotationBeanPostProcessor@Autowired注解原理/","excerpt":"","text":"前言 @Autowired是一个用来执行依赖注入的注解。每当一个Spring管理的bean发现有这个注解时候，它会直接注入相应的另一个Spring管理的bean。那么具体的解析是怎么实现的呢，AutowiredAnnotationBeanPostProcessor这个类就是做这个事情的 类继承关系 类成员 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware &#123; protected final Log logger = LogFactory.getLog(getClass()); private final Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes = new LinkedHashSet&lt;Class&lt;? extends Annotation&gt;&gt;(); private String requiredParameterName = \"required\"; private boolean requiredParameterValue = true; private int order = Ordered.LOWEST_PRECEDENCE - 2; private ConfigurableListableBeanFactory beanFactory; private final Set&lt;String&gt; lookupMethodsChecked = Collections.newSetFromMap(new ConcurrentHashMap&lt;String, Boolean&gt;(256)); private final Map&lt;Class&lt;?&gt;, Constructor&lt;?&gt;[]&gt; candidateConstructorsCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, Constructor&lt;?&gt;[]&gt;(256); private final Map&lt;String, InjectionMetadata&gt; injectionMetadataCache = new ConcurrentHashMap&lt;String, InjectionMetadata&gt;(256); /** * 构造函数中定义要处理的注解 * * Create a new AutowiredAnnotationBeanPostProcessor * for Spring's standard &#123;@link Autowired&#125; annotation. * &lt;p&gt;Also supports JSR-330's &#123;@link javax.inject.Inject&#125; annotation, if available. */ @SuppressWarnings(\"unchecked\") public AutowiredAnnotationBeanPostProcessor() &#123; this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try &#123; this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation&gt;) ClassUtils.forName(\"javax.inject.Inject\", AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.info(\"JSR-330 'javax.inject.Inject' annotation found and supported for autowiring\"); &#125; catch (ClassNotFoundException ex) &#123; // JSR-330 API not available - simply skip. &#125; &#125; 解析解析类是怎么注册的 第五章有介绍ComponentScanBeanDefinitionParser是&lt;context:component-scan base-package = &quot;org.springiframe.*&quot;/&gt;这个标签的实现类，我们的AutowiredAnnotationBeanPostProcessor这个类就是在这里注册的，进入registerComponents(parserContext.getReaderContext(), beanDefinitions, element);方法，关注AnnotationConfigUtils.registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Register all relevant annotation post processors in the given registry. * @param registry the registry to operate on * @param source the configuration source element (already extracted) * that this registration was triggered from. May be &#123;@code null&#125;. * @return a Set of BeanDefinitionHolders, containing all bean definitions * that have actually been registered by this call */public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); if (beanFactory != null) &#123; if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123; beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE); &#125; if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123; beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); &#125; &#125; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // 注册@Configuration`解析类 if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // 注册`@Autowired/@Value`解析类 if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // 注册`@Required`解析类 if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. // 注册@PostConstruct @PreDestroy @Resource 及JSR-250支持注解解析类 if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. // 注册JPA注解解析类 if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( \"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME)); &#125; return beanDefs;&#125; 解析类是在哪里调用的 上一章节介绍了populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw)方法，这个方法是进行属性填充，这里是完成依赖注入的关键 123456789101112131415161718192021222324252627282930...// 后处理器已经初始化boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();// 需要依赖检查boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; // PropertyValue值设置后，Spring会调用getBeanPostProcessor方法遍历Bean工厂中注册的所有BeanPostProcessor // 其中就包括AutowiredAnnotationBeanPostProcessor @Autowired注解就是在这里完成的注入 for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 对所有需要依赖检查的属性进行后处理 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; // 依赖检查。对应depends-on属性，3.0已废弃 checkDependencies(beanName, mbd, filteredPds, pvs); &#125;&#125;... 可以看到上面是循环BeanPostProcessor，然后判断是否是InstantiationAwareBeanPostProcessor实例，如果是的话就执行postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)方法，这里是调用了我们上面注册的AutowiredAnnotationBeanPostProcessor并对其接口方法进行了实现 先看InstantiationAwareBeanPostProcessor接口，这个接口主要作用在于目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置123456789101112131415161718public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor &#123; /** * 是最先执行的方法，它在目标对象实例化之前调用，该方法的返回值类型是Object，我们可以返回任何类型的值。 * 由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成的目标对象的实例(比如代理对象)。 * 如果该方法的返回值代替原本该生成的目标对象， */ Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException; /** * 在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置都是null */ boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException; /** * 对属性值进行修改(这个时候属性值还未被设置，但是我们可以修改原本该设置进去的属性值)。 */ PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException;&#125; 解析类实现依赖注入 进入postProcessPropertyValues方法，可以看到先获取了InjectionMetadata对象，InjectionMetadata对象是注入元数据,包含了目标Bean的Class对象,和注入元素(InjectionElement)集合，先是获取这个bean哪些属性及方法需要依赖注入，然后封装成InjectionMetadata对象，最后执行了其对象的metadata.inject(bean, beanName, pvs);方法完成依赖注入 postProcessPropertyValues方法 1234567891011121314151617@Overridepublic PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException &#123; // 调用下面的方法获取InjectionMetadata对象（其实InjectionElement集合） InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try &#123; // 调用注入方法 metadata.inject(bean, beanName, pvs); &#125; catch (BeanCreationException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex); &#125; return pvs;&#125; InjectionMetadata类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class InjectionMetadata &#123; private static final Log logger = LogFactory.getLog(InjectionMetadata.class); private final Class&lt;?&gt; targetClass; private final Collection&lt;InjectedElement&gt; injectedElements; private volatile Set&lt;InjectedElement&gt; checkedElements; public InjectionMetadata(Class&lt;?&gt; targetClass, Collection&lt;InjectedElement&gt; elements) &#123; this.targetClass = targetClass; this.injectedElements = elements; &#125; ... public void inject(Object target, String beanName, PropertyValues pvs) throws Throwable &#123; Collection&lt;InjectedElement&gt; elementsToIterate = (this.checkedElements != null ? this.checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) &#123; boolean debug = logger.isDebugEnabled(); for (InjectedElement element : elementsToIterate) &#123; if (debug) &#123; logger.debug(\"Processing injected element of bean '\" + beanName + \"': \" + element); &#125; // 依次循环注入 element.inject(target, beanName, pvs); &#125; &#125; &#125; public static abstract class InjectedElement &#123; protected final Member member; protected final boolean isField; protected final PropertyDescriptor pd; protected volatile Boolean skip; ... 1、获取这个bean哪些属性及方法需要依赖注入 进入InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);方法，因为需要注入的属性基本上都是不变的，所以Spring在这里做了一下缓存 12345678910111213141516171819202122232425262728293031323334/** * 获取注入元数据信息，这里做了一下缓存 * * @param beanName * @param clazz * @param pvs * @return */private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs) &#123; // Fall back to class name as cache key, for backwards compatibility with custom callers. String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()); // Quick check on the concurrent map first, with minimal locking. 先找缓存 InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; synchronized (this.injectionMetadataCache) &#123; metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; if (metadata != null) &#123; metadata.clear(pvs); &#125; try &#123; // 缓存没有，调用buildAutowiringMetadata方法构建 metadata = buildAutowiringMetadata(clazz); this.injectionMetadataCache.put(cacheKey, metadata); &#125; catch (NoClassDefFoundError err) &#123; throw new IllegalStateException(\"Failed to introspect bean class [\" + clazz.getName() + \"] for autowiring metadata: could not find class that it depends on\", err); &#125; &#125; &#125; &#125; return metadata;&#125; 如果缓存没有则调用buildAutowiringMetadata(clazz)方法进行构建，这个方法是找到哪些属性需要被自动装配，也就是查找被@Autowired、@Value、@Inject注解标记的元素，并封装为InjectionMetadata，可以看到是循环了这个类的Field及Method 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 找到哪些属性需要被自动装配，也就是查找被@Autowired、@Value、@Inject注解标记的元素，封装为InjectionMetadata * @param clazz * @return */public InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) &#123; // 存放哪些属性需要被自动装配 LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); Class&lt;?&gt; targetClass = clazz; do &#123; // 这里是循环，因为要考虑到父类的字段及方法 final LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() &#123; @Override public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException &#123; // 遍历每一个field，找到被@Autowired、@Value、@Inject标识的字段 AnnotationAttributes ann = findAutowiredAnnotation(field); if (ann != null) &#123; if (Modifier.isStatic(field.getModifiers())) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Autowired annotation is not supported on static fields: \" + field); &#125; return; &#125; boolean required = determineRequiredStatus(ann); // 创建AutowiredFieldElement currElements.add(new AutowiredFieldElement(field, required)); &#125; &#125; &#125;); ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() &#123; @Override public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException &#123; // 遍历所有的方法 Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123; return; &#125; AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123; if (Modifier.isStatic(method.getModifiers())) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Autowired annotation is not supported on static methods: \" + method); &#125; return; &#125; if (method.getParameterTypes().length == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Autowired annotation should only be used on methods with parameters: \" + method); &#125; &#125; boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); // 创建AutowiredFieldElement currElements.add(new AutowiredMethodElement(method, required, pd)); &#125; &#125; &#125;); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); &#125; while (targetClass != null &amp;&amp; targetClass != Object.class); // 将InjectedElement集合添加到新建的InjectionMetadata return new InjectionMetadata(clazz, elements);&#125; 关注AnnotationAttributes ann = findAutowiredAnnotation(field\\bridgedMethod);方法，可以看到这里是对this.autowiredAnnotationTypes进行遍历匹配，如果符合就返回 1234567891011private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) &#123; if (ao.getAnnotations().length &gt; 0) &#123; for (Class&lt;? extends Annotation&gt; type : this.autowiredAnnotationTypes) &#123; AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type); if (attributes != null) &#123; return attributes; &#125; &#125; &#125; return null;&#125; this.autowiredAnnotationTypes 属性就是构造函数构建的存放Set&lt;Class&lt;? extends Annotation&gt;&gt; autowiredAnnotationTypes集合 ，默认有@Autowired、@Value、@Inject注解的 2、执行依赖注入 上面的步骤以及获取了这个类哪些属性需要注入，现在就是需要完成依赖注入的操作 123456789101112131415161718192021222324252627282930313233@Overridepublic PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException &#123; // 调用下面的方法获取InjectionMetadata对象（其实InjectionElement集合） InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs); try &#123; // 调用注入方法 metadata.inject(bean, beanName, pvs); &#125; catch (BeanCreationException ex) &#123; throw ex; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Injection of autowired dependencies failed\", ex); &#125; return pvs;&#125;public void inject(Object target, String beanName, PropertyValues pvs) throws Throwable &#123; Collection&lt;InjectedElement&gt; elementsToIterate = (this.checkedElements != null ? this.checkedElements : this.injectedElements); if (!elementsToIterate.isEmpty()) &#123; boolean debug = logger.isDebugEnabled(); for (InjectedElement element : elementsToIterate) &#123; if (debug) &#123; logger.debug(\"Processing injected element of bean '\" + beanName + \"': \" + element); &#125; // 依次循环注入 element.inject(target, beanName, pvs); &#125; &#125;&#125; 关注element.inject(target, beanName, pvs)方法，可以看到是循环Collection&lt;InjectedElement&gt; injectedElements依次对属性进行注入，见下图可以看到Field及Method有不同的注入实现类 注入实现 AutowiredFieldElement#inject() 可以看到 ReflectionUtils.makeAccessible(field); field.set(bean, value); 这里完成了注入操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 @Override protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; Field field = (Field) this.member; Object value; if (this.cached) &#123; value = resolvedCachedArgument(beanName, this.cachedFieldValue); &#125; else &#123; DependencyDescriptor desc = new DependencyDescriptor(field, this.required); desc.setContainingClass(bean.getClass()); Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;String&gt;(1); TypeConverter typeConverter = beanFactory.getTypeConverter(); try &#123; // 这里是重中之重，获取真正的属性值。 value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter); &#125; catch (BeansException ex) &#123; throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex); &#125; synchronized (this) &#123; if (!this.cached) &#123; if (value != null || this.required) &#123; this.cachedFieldValue = desc; registerDependentBeans(beanName, autowiredBeanNames); if (autowiredBeanNames.size() == 1) &#123; String autowiredBeanName = autowiredBeanNames.iterator().next(); if (beanFactory.containsBean(autowiredBeanName)) &#123; if (beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123; this.cachedFieldValue = new ShortcutDependencyDescriptor( desc, autowiredBeanName, field.getType()); &#125; &#125; &#125; &#125; else &#123; this.cachedFieldValue = null; &#125; this.cached = true; &#125; &#125; &#125; if (value != null) &#123; // 最终赋值结束。 ReflectionUtils.makeAccessible(field); field.set(bean, value); &#125; &#125;&#125; AutowiredMethodElement#inject()可以看到ReflectionUtils.makeAccessible(method); method.invoke(bean, arguments);这里完成了注入操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495protected void inject(Object bean, String beanName, PropertyValues pvs) throws Throwable &#123; if (checkPropertySkipping(pvs)) &#123; return; &#125; Method method = (Method) this.member; Object[] arguments; if (this.cached) &#123; // Shortcut for avoiding synchronization... arguments = resolveCachedArguments(beanName); &#125; else &#123; Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); arguments = new Object[paramTypes.length]; DependencyDescriptor[] descriptors = new DependencyDescriptor[paramTypes.length]; Set&lt;String&gt; autowiredBeans = new LinkedHashSet&lt;String&gt;(paramTypes.length); TypeConverter typeConverter = beanFactory.getTypeConverter(); for (int i = 0; i &lt; arguments.length; i++) &#123; MethodParameter methodParam = new MethodParameter(method, i); DependencyDescriptor currDesc = new DependencyDescriptor(methodParam, this.required); currDesc.setContainingClass(bean.getClass()); descriptors[i] = currDesc; try &#123; Object arg = beanFactory.resolveDependency(currDesc, beanName, autowiredBeans, typeConverter); if (arg == null &amp;&amp; !this.required) &#123; arguments = null; break; &#125; arguments[i] = arg; &#125; catch (BeansException ex) &#123; throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(methodParam), ex); &#125; &#125; synchronized (this) &#123; if (!this.cached) &#123; if (arguments != null) &#123; this.cachedMethodArguments = new Object[paramTypes.length]; for (int i = 0; i &lt; arguments.length; i++) &#123; this.cachedMethodArguments[i] = descriptors[i]; &#125; registerDependentBeans(beanName, autowiredBeans); if (autowiredBeans.size() == paramTypes.length) &#123; Iterator&lt;String&gt; it = autowiredBeans.iterator(); for (int i = 0; i &lt; paramTypes.length; i++) &#123; String autowiredBeanName = it.next(); if (beanFactory.containsBean(autowiredBeanName)) &#123; if (beanFactory.isTypeMatch(autowiredBeanName, paramTypes[i])) &#123; this.cachedMethodArguments[i] = new ShortcutDependencyDescriptor( descriptors[i], autowiredBeanName, paramTypes[i]); &#125; &#125; &#125; &#125; &#125; else &#123; this.cachedMethodArguments = null; &#125; this.cached = true; &#125; &#125; &#125; if (arguments != null) &#123; try &#123; // 完成注入 ReflectionUtils.makeAccessible(method); method.invoke(bean, arguments); &#125; catch (InvocationTargetException ex)&#123; throw ex.getTargetException(); &#125; &#125; &#125; ``` * `InjectedElement#inject()`可以看到`ReflectionUtils.makeAccessible(method); field.set(target, getResourceToInject(target, requestingBeanName));`这里完成了注入操作 ```java protected void inject(Object target, String requestingBeanName, PropertyValues pvs) throws Throwable &#123; if (this.isField) &#123; Field field = (Field) this.member; ReflectionUtils.makeAccessible(field); field.set(target, getResourceToInject(target, requestingBeanName)); &#125; else &#123; if (checkPropertySkipping(pvs)) &#123; return; &#125; try &#123; Method method = (Method) this.member; ReflectionUtils.makeAccessible(method); method.invoke(target, getResourceToInject(target, requestingBeanName)); &#125; catch (InvocationTargetException ex) &#123; throw ex.getTargetException(); &#125; &#125; &#125; 总结 @Autowired和@Resource这两个注解是我们开发过程中经常使用的注解 @Autowired默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 @Resource，默认安装名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 @Autowired、@Value、@Inject 注解的实现大体逻辑是先获取哪些需要注入的属性，然后调用反射进行赋值 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(十)加载Bean之AbstractBeanFactory类createBean方法","slug":"backend/framework/spring/analysis/Spring系列(十)加载Bean之AbstractBeanFactory类createBean方法","date":"2019-06-18T14:00:46.000Z","updated":"2019-06-22T01:36:28.007Z","comments":true,"path":"2019/06/18/backend/framework/spring/analysis/Spring系列(十)加载Bean之AbstractBeanFactory类createBean方法/","link":"","permalink":"http://www.songshuiyang.site/2019/06/18/backend/framework/spring/analysis/Spring系列(十)加载Bean之AbstractBeanFactory类createBean方法/","excerpt":"","text":"前言 上一章节介绍了不同作用域下获取Bean的主体逻辑，这些作用域都调用了createBean(String beanName, RootBeanDefinition mbd, Object[] args)方法，这个是AbstractBeanFactory内定义的方法，默认实现是AbstractAutowireCapableBeanFactory，这个方法是创建bean实例的核心方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 创建bean实例的核心方法，填充bean实例 * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // 锁定class，根据设置的class属性或者根据className来解析Class Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // Prepare method overrides. // 对override属性进行标记及验证 try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 给BeanPostProcessors一个机会来返回代理来替代真正的实例 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); // 当经过前置处理后的返回结果如果不为空，那么会直接略过后续bean的创建二直接返回结果。这一特性虽然很容易被忽略，但是 // 却起着至关重要的作用，我们熟知的AOP功能就是基于这里的判断的 if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); &#125; // 核心方法创建bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); &#125; return beanInstance;&#125; Object beanInstance = doCreateBean(beanName, mbdToUse, args); 这个方法是核心方法，又是个do开头的方法 该方法接受三个方法参数 bean 的名字 已经合并了父类属性的（如果有的话）BeanDefinition 对象。 用于构造函数或者工厂方法创建 Bean 实例对象的参数。 doCreateBean(...) 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks. * &lt;p&gt;Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // Instantiate the bean. // BeanWrapper 是对 Bean 的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装 bean 的属性描述器 BeanWrapper instanceWrapper = null; // 单例模型，则从未完成的 FactoryBean 缓存中删除 if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 根据指定的bean使用对应的策略创新新的实例，如：工厂方法、构造函数自动注入、简单初始化 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; // 包装的实例对象 final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); // 包装的实例对象的类型 Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; // 判断是否有后置处理，如果有后置处理，则允许后置处理修改 BeanDefinition if (!mbd.postProcessed) &#123; try &#123; // 应用MergedBeanDefinitionPostProcessors applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. /** * 是否需要提早曝光：单例&amp;允许循环依赖&amp;当前bean正在创建中，检测循环依赖 * * Spring处理循环依赖的解决方法： * 在B中创建依赖A时是通过ObjectFactory提供的实例化方法来中断A中的属性填充，使B中持有的A仅仅是刚初始化并 * 没有填充任何属性的A，而这正初始化A的步骤还是在最开始创建A的时候进行的，但是因为A与B中A所表示的属性地址 * 是一样的，所以在A中创建好的属性填充可以通过B中的A获取，这样就解决了循环依赖的问题 */ boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); &#125; // 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂 addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; // 对bean再一次依赖引用，主要应用于SmartInstantiationAware BeanPostProcessor // 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有直接返回bean，不做任何处理 return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 对bean进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始依赖bean populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; // 调用初始化方法 比如init-method exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; // 循环依赖处理 if (earlySingletonExposure) &#123; Object earlySingletonReference = getSingleton(beanName, false); // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空 if (earlySingletonReference != null) &#123; // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强 if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; // 处理依赖 else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; // 根据scope注册bean registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); &#125; return exposedObject;&#125; 解析 doCreateBean(...) 方法，主要用于完成 bean 的创建和初始化工作，我们可以将其分为一下几个过程： createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) 方法，实例化 bean 。 populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) 方法，进行属性填充。 initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) 方法，初始化 Bean 。 1、 createBeanInstance(…) 实例化 bean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Create a new instance for the specified bean, using an appropriate instantiation strategy: * factory method, constructor autowiring, or simple instantiation. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return BeanWrapper for the new instance * @see #instantiateUsingFactoryMethod * @see #autowireConstructor * @see #instantiateBean */protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123; // Make sure bean class is actually resolved at this point. // 解析 bean ，将 bean 类名解析为 class 引用。 Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); &#125; // 如果工厂方法不为空则使用工厂方法初始化策略 if (mbd.getFactoryMethodName() != null) &#123; return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // Shortcut when re-creating the same bean... boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; // 一个类有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先更具参数锁定构造函数或对应的工厂方法 if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; // 如果已经解析过则使用解析好的构造函数方法不需要再次锁定 if (resolved) &#123; if (autowireNecessary) &#123; // 构造函数自动注入 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; // 使用默认构造函数构造 return instantiateBean(beanName, mbd); &#125; &#125; // Need to determine the constructor... // 需根据参数解析构造函数 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; // 构造函数自动注入 return autowireConstructor(beanName, mbd, ctors, args); &#125; // No special handling: simply use no-arg constructor. // 使用默认构造函数构造 return instantiateBean(beanName, mbd);&#125; createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) 方法，用于实例化 Bean 对象。它会根据不同情况，选择不同的实例化策略来完成 Bean 的初始化，主要包括 1.1 工厂方法初始化：instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) 方法。 如果存在工厂方法，则调用此工厂方法完成 bean 的初始化工作 1.2 构造函数自动注入初始化：autowireConstructor(final String beanName, final RootBeanDefinition mbd, Constructor&lt;?&gt;[] chosenCtors, final Object[] explicitArgs) 方法。 这个初始化方法，我们可以简单理解为是带有参数的构造方法，来初始化 bean 对象。 主要是因为构造函数和构造参数的不确定性，Spring 需要花大量的精力来确定构造函数和构造参数，所以比较复杂 1.3 默认构造函数初始化：instantiateBean(final String beanName, final RootBeanDefinition mbd) 方法。 它没有参数，所以不需要确认经过复杂的过来来确定构造器、构造参数 进入getInstantiationStrategy().instantiate(mbd, beanName, parent); 方法，从下面的代码可以得到默认构造函数的初始化比上面的情况更为简单，如果没有什么特殊的直接反射得到ctor.newInstance(args)实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123; // Don't override the class with CGLIB if no overrides. // 用户没有使用replace或者lookup的配置方法，那么直接使用反射的方式创建实例 if (bd.getMethodOverrides().isEmpty()) &#123; Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) &#123; constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) &#123; final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, \"Specified class is an interface\"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123; @Override public Constructor&lt;?&gt; run() throws Exception &#123; return clazz.getDeclaredConstructor((Class[]) null); &#125; &#125;); &#125; else &#123; constructorToUse = clazz.getDeclaredConstructor((Class[]) null); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; catch (Throwable ex) &#123; throw new BeanInstantiationException(clazz, \"No default constructor found\", ex); &#125; &#125; &#125; // 实例化实体类 return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // 需要将replace或者lookup这两个配置的功能（动态代理）切入进去 // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); &#125;&#125; public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException &#123; Assert.notNull(ctor, \"Constructor must not be null\"); try &#123; // 反射构造实例 ReflectionUtils.makeAccessible(ctor); return ctor.newInstance(args); &#125; catch (InstantiationException ex) &#123; throw new BeanInstantiationException(ctor, \"Is it an abstract class?\", ex); &#125; catch (IllegalAccessException ex) &#123; throw new BeanInstantiationException(ctor, \"Is the constructor accessible?\", ex); &#125; catch (IllegalArgumentException ex) &#123; throw new BeanInstantiationException(ctor, \"Illegal arguments for constructor\", ex); &#125; catch (InvocationTargetException ex) &#123; throw new BeanInstantiationException(ctor, \"Constructor threw exception\", ex.getTargetException()); &#125;&#125; 2、 populateBean(…) 进行属性填充，完成依赖注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Populate the bean instance in the given BeanWrapper with the property values * from the bean definition. * @param beanName the name of the bean * @param mbd the bean definition for the bean * @param bw BeanWrapper with bean instance */protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123; PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) &#123; if (!pvs.isEmpty()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\"); &#125; else &#123; // Skip property population phase for null instance. // 没有可填充的属性 return; &#125; &#125; // Give any InstantiationAwareBeanPostProcessors the opportunity to modify the // state of the bean before properties are set. This can be used, for example, // to support styles of field injection. boolean continueWithPropertyPopulation = true; /** * 给InstantiationAwareBeanPostProcessors最后一次机会在属性设置前来改变bean * 如：可以用来支持属性注入的类型 */ if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 返回值是否继续填充bean if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; // 终止后续的执行 if (!continueWithPropertyPopulation) &#123; return; &#125; if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; // 存入PropertyValues中 MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // Add property values based on autowire by name if applicable. // 根据名称自动注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // Add property values based on autowire by type if applicable. // 根据类型自动注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; // 后处理器已经初始化 boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); // 需要依赖检查 boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; // PropertyValue值设置后，Spring会调用getBeanPostProcessor方法遍历Bean工厂中注册的所有BeanPostProcessor // 其中就包括AutowiredAnnotationBeanPostProcessor @Autowired注解就是在这里完成的注入 for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 对所有需要依赖检查的属性进行后处理 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; // 依赖检查。对应depends-on属性，3.0已废弃 checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; // 将属性应用到bean中 之前的操作是获取所有注入属性，但是获取到的属性是以PropertyValues形式存在的，并没有 // 应用到已经实例化的bean中，下面的方法就是做这个操作的 applyPropertyValues(beanName, mbd, bw, pvs);&#125; populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) 方法，进行属性填充，这里是完成依赖注入的关键，根据上面的代码可以划分 1、获取PropertyValues pvs = mbd.getPropertyValues(); 已定义bean的属性值 比如之前配置的，下面就是userName属性 123&lt;bean class=\"org.springiframe.entity.User\"&gt; &lt;property name=\"userName\" value=\"shop\"/&gt;&lt;/bean&gt; 由下图可以看到已经获取了PropertyValues pvs属性值， 2、给InstantiationAwareBeanPostProcessors最后一次机会在属性设置前来改变bean 看代码可以看到是循环BeanPostProcessor，然后调用postProcessAfterInstantiation(Object bean, String beanName)方法 12345678910111213141516if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 返回值是否继续填充bean if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125;&#125;// 终止后续的执行if (!continueWithPropertyPopulation) &#123; return;&#125; 可以通过postProcessAfterInstantiation(Object bean, String beanName)的返回值来控制 Spring 是否继续进行属性填充。 3、判断自动注入的模式 根据名称自动注入autowireByName(beanName, mbd, bw, newPvs) TODO 根据类型自动注入autowireByType(beanName, mbd, bw, newPvs); TODO 4、依赖检查及依赖注入 @Autowired注解就是在这里完成的注入，遍历InstantiationAwareBeanPostProcessor执行postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)方法 1234567891011121314151617181920212223242526// 后处理器已经初始化boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();// 需要依赖检查boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; // PropertyValue值设置后，Spring会调用getBeanPostProcessor方法遍历Bean工厂中注册的所有BeanPostProcessor // 其中就包括AutowiredAnnotationBeanPostProcessor @Autowired注解就是在这里完成的注入 for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 对所有需要依赖检查的属性进行后处理 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; // 依赖检查。对应depends-on属性，3.0已废弃 checkDependencies(beanName, mbd, filteredPds, pvs); &#125;&#125; 关注postProcessPropertyValues方法，这里是调用的InstantiationAwareBeanPostProcessor接口的方法，这个方法完成了依赖属性的注入，这个接口又是继承BeanPostProcessor，详细说明将在下一章介绍 3、 initializeBean(…) 实例化 bean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) &#123; if (pvs == null || pvs.isEmpty()) &#123; return; &#125; MutablePropertyValues mpvs = null; List&lt;PropertyValue&gt; original; if (System.getSecurityManager() != null) &#123; if (bw instanceof BeanWrapperImpl) &#123; ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext()); &#125; &#125; if (pvs instanceof MutablePropertyValues) &#123; mpvs = (MutablePropertyValues) pvs; // 如果mpvs中的值已经被转化为对应的类型那么可以直接设置到beanwapper中 if (mpvs.isConverted()) &#123; // Shortcut: use the pre-converted values as-is. try &#123; bw.setPropertyValues(mpvs); return; &#125; catch (BeansException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Error setting property values\", ex); &#125; &#125; original = mpvs.getPropertyValueList(); &#125; else &#123; // 如果pvs并不是使用MutablePropertyValues封装的类型，那么直接使用原始的属性获取方法 original = Arrays.asList(pvs.getPropertyValues()); &#125; TypeConverter converter = getCustomTypeConverter(); if (converter == null) &#123; converter = bw; &#125; // 获取对应的解析器 BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter); // Create a deep copy, resolving any references for values. List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;PropertyValue&gt;(original.size()); boolean resolveNecessary = false; // 遍历属性，将属性转化为对应lei的对应属性的类型 for (PropertyValue pv : original) &#123; if (pv.isConverted()) &#123; deepCopy.add(pv); &#125; else &#123; String propertyName = pv.getName(); Object originalValue = pv.getValue(); // 调用 Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue); Object convertedValue = resolvedValue; boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp; !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName); if (convertible) &#123; convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter); &#125; // Possibly store converted value in merged bean definition, // in order to avoid re-conversion for every created bean instance. if (resolvedValue == originalValue) &#123; if (convertible) &#123; pv.setConvertedValue(convertedValue); &#125; deepCopy.add(pv); &#125; else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp; !((TypedStringValue) originalValue).isDynamic() &amp;&amp; !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) &#123; pv.setConvertedValue(convertedValue); deepCopy.add(pv); &#125; else &#123; resolveNecessary = true; deepCopy.add(new PropertyValue(pv, convertedValue)); &#125; &#125; &#125; if (mpvs != null &amp;&amp; !resolveNecessary) &#123; mpvs.setConverted(); &#125; // Set our (possibly massaged) deep copy. try &#123; bw.setPropertyValues(new MutablePropertyValues(deepCopy)); &#125; catch (BeansException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Error setting property values\", ex); &#125;&#125; 将属性应用到已经实例化的bean中applyPropertyValues(beanName, mbd, bw, pvs);，上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象 pvs 中，并没有应用到已经实例化的 bean 中 总结 Object beanInstance = createBean(beanName, mbdToUse, args); 这个方法是核心方法，所有的bean实例的创建，都会委托给该方法实现。 doCreateBean(...) 方法，主要用于完成 bean 的创建和初始化工作，我们可以将其分为一下几个过程： createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) 方法，实例化 bean 。 populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) 方法，进行属性填充。 initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) 方法，初始化 Bean 。 getBean 的全流程 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(九)加载Bean之不同作用域下获取Bean","slug":"backend/framework/spring/analysis/Spring系列(九)加载Bean之不同作用域下获取Bean","date":"2019-06-17T15:00:46.000Z","updated":"2019-06-18T13:21:57.110Z","comments":true,"path":"2019/06/17/backend/framework/spring/analysis/Spring系列(九)加载Bean之不同作用域下获取Bean/","link":"","permalink":"http://www.songshuiyang.site/2019/06/17/backend/framework/spring/analysis/Spring系列(九)加载Bean之不同作用域下获取Bean/","excerpt":"","text":"前言 上一章节介绍了从单例缓存中获取单例 Bean，这一章节来介绍不从缓存中获取单例Bean的过程，也就是下面的else分支的代码语句，什么时候会走到else呢，一种情况是该 Bean 的 scope 不是 singleton，另一种情况是该 Bean 的 scope 是 singleton 但是没有初始化完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138Object sharedInstance = getSingleton(beanName);// 从缓存中获取 Bean 后，若其不为 null 且 args 为空if (sharedInstance != null &amp;&amp; args == null) &#123; ... 第八章已介绍 &#125;else &#123; // 在缓存中没有 // 只有单例情况下才会尝试解决循依赖（如果存在A中有B属性，B中有A属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次创建A，造成循环依赖） // 在原型模式下如果存在循环依赖则会抛出异常。 // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. // 判断工厂中是否含有此Bean的定义，如果没有找到则父类容器里找 BeanFactory parentBeanFactory = getParentBeanFactory(); // 如果beanDefinitionMap中也就是在所有已经加载的类中不包括beanName，则尝试从parentBeanFactory中检测 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. 如果没有，查询父工厂 String nameToLookup = originalBeanName(name); // 递归到BeanFactory中寻找 递归调用getBean方法 if (args != null) &#123; // Delegation to parent with explicit args. 执行带有args参数的getbean方法 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. 如果没有参数，执行标准的getbean方法 return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; // 如果不是仅仅做类型检查则是创建bean，这里要进行记录 if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; // 将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition， // 如果指定BeanName是子Bean的话同时会合并父类的相关属性 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); // 检查给定的合并的 BeanDefinition checkMergedBeanDefinition(mbd, beanName, args); // 处理所依赖的 bean // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); // 若存在依赖则需要递归实例化依赖的bean，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖 if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; // 缓存依赖调用 registerDependentBean(dep, beanName); /** * 递归处理依赖 Bean * 每个 Bean 都不是单独工作的，它会依赖其他 Bean，其他 Bean 也会依赖它。 * 对于依赖的 Bean ，它会优先加载，所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。 */ getBean(dep); &#125; &#125; // Create bean instance. 重头戏 // 单例模式的实例化bean if (mbd.isSingleton()) &#123; // 获取实例了 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; // 在getSingleton()方法会调用 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. // 显式从单例缓存中删除 Bean 实例，因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它 destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 原型模式的实例化bean else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; // 指定的scope上实例化bean String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125;&#125; 上面的代码可以分为如下部分： 1、原型模式下循环依赖检查，如果是则抛BeanCurrentlyInCreationException异常 在前面就提过，Spring 只解决单例模式下的循环依赖，对于原型模式的循环依赖则抛异常，单例模式下Spring是通过cache的形式提早曝光创建的对象来处理循环依赖的，但原型模式下的bean都是新建的，所以无法cache 检测逻辑和单例模式一样，一个“集合”存放着正在创建的 Bean ，从该集合中进行判断即可，只不过单例模式下的“集合”为 Set ，而原型模式的则是 ThreadLocal 代码 123456789101112/** Names of beans that are currently in creation */private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation = new NamedThreadLocal&lt;Object&gt;(\"Prototype beans currently in creation\"); if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName);&#125; protected boolean isPrototypeCurrentlyInCreation(String beanName) &#123; Object curVal = this.prototypesCurrentlyInCreation.get(); return (curVal != null &amp;&amp; (curVal.equals(beanName) || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName))));&#125; 2、判断工厂中是否含有此Bean的定义，如果没有找到则父类容器里找 递归到BeanFactory中寻找 递归调用getBean方法 代码1234567891011121314151617// Check if bean definition exists in this factory.// 判断工厂中是否含有此Bean的定义，如果没有找到则父类容器里找BeanFactory parentBeanFactory = getParentBeanFactory();// 如果beanDefinitionMap中也就是在所有已经加载的类中不包括beanName，则尝试从parentBeanFactory中检测if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. 如果没有，查询父工厂 String nameToLookup = originalBeanName(name); // 递归到BeanFactory中寻找 递归调用getBean方法 if (args != null) &#123; // Delegation to parent with explicit args. 执行带有args参数的getbean方法 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. 如果没有参数，执行标准的getbean方法 return parentBeanFactory.getBean(nameToLookup, requiredType); &#125;&#125; 3、获取RootBeanDefinition，若获取的 BeanDefinition 为子 BeanDefinition，则需要合并父类的相关属性 合并得到RootBeanDefinition 代码12345// 将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition，// 如果指定BeanName是子Bean的话同时会合并父类的相关属性final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);// 检查给定的合并的 BeanDefinitioncheckMergedBeanDefinition(mbd, beanName, args); 4、处理依赖，设及到depends-on属性 适用于表面上看起来两个bean之间没有使用属性之类的强连接的bean，但是两个bean又确实存在前后依赖关系的情况，使用了depends-on的时候，依赖他人的bean是先于被依赖bean销毁的 代码1234567891011121314151617181920// 处理所依赖的 bean// Guarantee initialization of beans that the current bean depends on.String[] dependsOn = mbd.getDependsOn();// 若存在依赖则需要递归实例化依赖的bean，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; // 缓存依赖调用 registerDependentBean(dep, beanName); /** * 递归处理依赖 Bean * 每个 Bean 都不是单独工作的，它会依赖其他 Bean，其他 Bean 也会依赖它。 * 对于依赖的 Bean ，它会优先加载，所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。 */ getBean(dep); &#125;&#125; 5、单例模式的实例化bean 6、原型模式的实例化bean 7、指定的scope上实例化bean解析 1、单例模式的实例化bean 单例模式的实例化bean的动作是在getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法实现的，可以看到两个参数，一个beanName，第二个ObjectFactory的对象，可以看到是直接new了一个ObjectFactory，并重写了getObject()方法，转而调用createBean(beanName, mbd, args);方法 1234567891011121314151617181920212223// Create bean instance. 重头戏// 单例模式的实例化beanif (mbd.isSingleton()) &#123; // 获取实例了 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; // 在getSingleton()方法会调用 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. // 显式从单例缓存中删除 Bean 实例，因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它 destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);&#125; 先进入getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)方法，可以看到先是从private final Map&lt;String, Object&gt; singletonObjects对象中获取bean，如果没有获取到就是通过singletonFactory.getObject(); 来获取bean 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Return the (raw) singleton object registered under the given name, * creating and registering a new one if none registered yet. * @param beanName the name of the bean * @param singletonFactory the ObjectFactory to lazily create the singleton * with, if necessary * @return the registered singleton object */public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(beanName, \"'beanName' must not be null\"); // 全局变量需要同步 synchronized (this.singletonObjects) &#123; // 首先检查对应的bean是否已经加载过，因为singleton模式其实就是复用以创建的bean。所以这一步是必须的 Object singletonObject = this.singletonObjects.get(beanName); // 如果未空才可以进行singleton的bean的初始化 if (singletonObject == null) &#123; if (this.singletonsCurrentlyInDestruction) &#123; throw new BeanCreationNotAllowedException(beanName, \"Singleton bean creation not allowed while singletons of this factory are in destruction \" + \"(Do not request a bean from a BeanFactory in a destroy method implementation!)\"); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\"); &#125; // 记录加载状态，将当前正要创建的bean记录在缓存中，这样便可以对循环依赖进行检测 beforeSingletonCreation(beanName); boolean newSingleton = false; boolean recordSuppressedExceptions = (this.suppressedExceptions == null); if (recordSuppressedExceptions) &#123; this.suppressedExceptions = new LinkedHashSet&lt;Exception&gt;(); &#125; try &#123; // 真正获取单例 bean 的方法 singletonObject = singletonFactory.getObject(); newSingleton = true; &#125; catch (IllegalStateException ex) &#123; // Has the singleton object implicitly appeared in the meantime -&gt; // if yes, proceed with it since the exception indicates that state. singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; throw ex; &#125; &#125; catch (BeanCreationException ex) &#123; if (recordSuppressedExceptions) &#123; for (Exception suppressedException : this.suppressedExceptions) &#123; ex.addRelatedCause(suppressedException); &#125; &#125; throw ex; &#125; finally &#123; if (recordSuppressedExceptions) &#123; this.suppressedExceptions = null; &#125; // 当bean加载结束后需要移除缓存中对该bean的正在加载状态的记录 afterSingletonCreation(beanName); &#125; if (newSingleton) &#123; // 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态 addSingleton(beanName, singletonObject); &#125; &#125; return (singletonObject != NULL_OBJECT ? singletonObject : null); &#125;&#125; beforeSingletonCreation(beanName); 记录正在创建的bean，使用了一个存放beanName的 Set集合，这样便可以对循环依赖进行检测 1234567891011121314151617/** * Names of beans that are currently in creation * * 记录bean的加载状态 ，在bean开始创建前会将beanName记录在属性中，创建结束会将该beanName从该属性中移除 */private final Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap&lt;String, Boolean&gt;(16));// 记录加载状态，将当前正要创建的bean记录在缓存中，这样便可以对循环依赖进行检测beforeSingletonCreation(beanName);protected void beforeSingletonCreation(String beanName) &#123; // 记录bean的加载状态 if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125;&#125; singletonObject = singletonFactory.getObject();是真正获取单例 bean 的方法，这个方法在外面AbstractAutowireCapableBeanFactory的createBean(beanName, mbd, args);实现，代码如下可以看到主要是有两个主体方法:1、Object bean = resolveBeforeInstantiation(beanName, mbdToUse); 、2、Object beanInstance = doCreateBean(beanName, mbdToUse, args); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 创建bean实例的核心方法，填充bean实例 * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // Make sure bean class is actually resolved at this point, and // clone the bean definition in case of a dynamically resolved Class // which cannot be stored in the shared merged bean definition. // 锁定class，根据设置的class属性或者根据className来解析Class Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // Prepare method overrides. // 对override属性进行标记及验证 try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); &#125; try &#123; // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance. // 给BeanPostProcessors一个机会来返回代理来替代真正的实例 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); // 当经过前置处理后的返回结果如果不为空，那么会直接略过后续bean的创建二直接返回结果。这一特性虽然很容易被忽略，但是 // 却起着至关重要的作用，我们熟知的AOP功能就是基于这里的判断的 if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); &#125; // 创建bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); &#125; return beanInstance;&#125; 下面来讲解着两个方法 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); 这个方法是给BeanPostProcessor一个机会来返回代理来替代真正的实例，这个方法却起着至关重要的作用，我们熟知的AOP功能就是基于这里的判断的，如果不为空直接返回对应的代理类，BeanPostProcessors 接口之前也接触过一些，这个接口是定义bean初始化之和初始化之后分别调用的的方法 进入方法，可以看到主要功能是遍历List&lt;BeanPostProcessor&gt; beanPostProcessors，先执行bean初始化之前接口方法postProcessBeforeInstantiation，后执行bean初始化之后接口方法postProcessAfterInitialization123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) &#123; Object bean = null; // 如果尚未被解析 if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; // Make sure bean class is actually resolved at this point. if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; Class&lt;?&gt; targetType = determineTargetType(beanName, mbd); if (targetType != null) &#123; // 实例化前的后处理器应用 调用postProcessBeforeInstantiation，给一个子类一个修改BeanDefinition的机会 // 当经过这个方法后，bean可能已经不是我们认为的bean了，而是或许成为了一个经过处理的代理bean，可能是通过cglib生成的 bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName); if (bean != null) &#123; // 实例化后的后处理器应用 方法二 调用postProcessAfterInitialization bean = applyBeanPostProcessorsAfterInitialization(bean, beanName); &#125; &#125; &#125; mbd.beforeInstantiationResolved = (bean != null); &#125; return bean;&#125; protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); if (result != null) &#123; return result; &#125; &#125; &#125; return null;&#125; public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; // 实现 BeanPostProcessor 接口用户可以根据自己的业务需求进行响应的处理 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessAfterInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; Object beanInstance = doCreateBean(beanName, mbdToUse, args); 这个方法是创建bean的主体方法，篇幅较多所以放到下一章节 得到 Object singletonObject 之后 1、先是移除缓存中对该bean的正在加载状态的记录，与上面的beforeSingletonCreation(beanName)相对应 123456protected void afterSingletonCreation(String beanName) &#123; // 移除bean的加载状态 if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp; !this.singletonsCurrentlyInCreation.remove(beanName)) &#123; throw new IllegalStateException(\"Singleton '\" + beanName + \"' isn't currently in creation\"); &#125;&#125; 2、存放到缓存中，可以看到将结果put到Map&lt;String, Object&gt; singletonObjects对象中并记录注册过的单例bean name 放到Set&lt;String&gt; registeredSingletons集合中，然后移除Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories及Map&lt;String, Object&gt; earlySingletonObjects缓存，最终结果:Map&lt;String, Object&gt; singletonObjects 123456789101112131415161718192021if (newSingleton) &#123; // 将结果记录至缓存并删除加载bean过程中所记录的各种辅助状态 addSingleton(beanName, singletonObject); &#125; /** * 将给定的singleton对象添加到此工厂的singleton缓存中。 * * Add the given singleton object to the singleton cache of this factory. * &lt;p&gt;To be called for eager registration of singletons. * @param beanName the name of the bean * @param singletonObject the singleton object */ protected void addSingleton(String beanName, Object singletonObject) &#123; synchronized (this.singletonObjects) &#123; this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT)); this.singletonFactories.remove(beanName); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); &#125; &#125; 2、原型模式的实例化bean 上代码 12345678910111213141516// 原型模式的实例化beanelse if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; // 记录加载原型模式 bean 之前的加载状态前置处理 beforePrototypeCreation(beanName); // 直接调用createBean(beanName, mbd, args)创建新bean prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; // 删除原型模式 bean 之前的加载状态，后置处理 afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);&#125; 原型模式下的初始化过程比较简单，与单例模式下的主要区别就是没有在缓存中获取，而是直接调用createBean(beanName, mbd, args)创建新bean，并在创建前记录原型模式下正在创建 bean，使用ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation进行存放，创建完成之后就销毁，这个变量在isPrototypeCurrentlyInCreation(beanName)方法中使用，检查是否是原型模式下存在循环依赖情况 3、指定的scope上实例化bean 上代码 1234567891011121314151617181920212223242526272829else &#123; // 指定的scope上实例化bean String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125;&#125; 核心流程和原型模式一样，只不过获取 bean 实例是由 Scope#get(String name, ObjectFactory&lt;?&gt; objectFactory) 方法来实现。 指定的scope上实例化bean，分为request（HTTP请求）、session（会话）、global-session（全局会话） org.springframework.web.context.request.RequestScope 代码12345678910111213public class RequestScope extends AbstractRequestAttributesScope &#123; @Override protected int getScope() &#123; return RequestAttributes.SCOPE_REQUEST; &#125; @Override public String getConversationId() &#123; return null; &#125;&#125; org.springframework.web.context.request.SessionScope 代码12345678910111213141516171819202122232425262728293031323334353637383940public class SessionScope extends AbstractRequestAttributesScope &#123; private final int scope; public SessionScope() &#123; this.scope = RequestAttributes.SCOPE_SESSION; &#125; public SessionScope(boolean globalSession) &#123; this.scope = (globalSession ? RequestAttributes.SCOPE_GLOBAL_SESSION : RequestAttributes.SCOPE_SESSION); &#125; @Override protected int getScope() &#123; return this.scope; &#125; @Override public String getConversationId() &#123; return RequestContextHolder.currentRequestAttributes().getSessionId(); &#125; @Override public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123; Object mutex = RequestContextHolder.currentRequestAttributes().getSessionMutex(); synchronized (mutex) &#123; return super.get(name, objectFactory); &#125; &#125; @Override public Object remove(String name) &#123; Object mutex = RequestContextHolder.currentRequestAttributes().getSessionMutex(); synchronized (mutex) &#123; return super.remove(name); &#125; &#125;&#125; AbstractRequestAttributesScope是上面两个类的抽象实现类，可以看到里面的操作是通过RequestContextHolder.currentRequestAttributes();来获取当前线程属性集合，之后的操作就是对属性进行get set了，并通过子类实现getScope()方法来区分不同的scope 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public abstract class AbstractRequestAttributesScope implements Scope &#123; @Override public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123; // 获取当前线程属性集合 RequestAttributes attributes = RequestContextHolder.currentRequestAttributes(); Object scopedObject = attributes.getAttribute(name, getScope()); if (scopedObject == null) &#123; // 存放到RequestAttributes中 scopedObject = objectFactory.getObject(); attributes.setAttribute(name, scopedObject, getScope()); // Retrieve object again, registering it for implicit session attribute updates. // As a bonus, we also allow for potential decoration at the getAttribute level. Object retrievedObject = attributes.getAttribute(name, getScope()); if (retrievedObject != null) &#123; // Only proceed with retrieved object if still present (the expected case). // If it disappeared concurrently, we return our locally created instance. scopedObject = retrievedObject; &#125; &#125; // 获取到直接返回 return scopedObject; &#125; @Override public Object remove(String name) &#123; // 获取当前线程属性集合 RequestAttributes attributes = RequestContextHolder.currentRequestAttributes(); Object scopedObject = attributes.getAttribute(name, getScope()); if (scopedObject != null) &#123; // 从RequestAttributes中移除 attributes.removeAttribute(name, getScope()); return scopedObject; &#125; else &#123; return null; &#125; &#125; @Override public void registerDestructionCallback(String name, Runnable callback) &#123; RequestAttributes attributes = RequestContextHolder.currentRequestAttributes(); attributes.registerDestructionCallback(name, callback, getScope()); &#125; @Override public Object resolveContextualObject(String key) &#123; RequestAttributes attributes = RequestContextHolder.currentRequestAttributes(); return attributes.resolveReference(key); &#125; protected abstract int getScope(); &#125; 总结 单例模式的bean是通过一个HashMap缓存来实现的，原型模式下的bean都是每次新建调用的，指定scope模式下的bean是调用Scope接口的get方法来获取的 如果存在循环依赖的情况，单例模式下Spring是通过cache的形式提早曝光创建的对象来处理循环依赖的，但原型模式下的bean都是新建的，所以无法cache 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(八)加载Bean之单例缓存中获取单例 Bean","slug":"backend/framework/spring/analysis/Spring系列(八)加载Bean之单例缓存中获取单例 Bean","date":"2019-06-12T15:00:46.000Z","updated":"2019-06-18T15:22:16.133Z","comments":true,"path":"2019/06/12/backend/framework/spring/analysis/Spring系列(八)加载Bean之单例缓存中获取单例 Bean/","link":"","permalink":"http://www.songshuiyang.site/2019/06/12/backend/framework/spring/analysis/Spring系列(八)加载Bean之单例缓存中获取单例 Bean/","excerpt":"","text":"前言 平常开发中我们知道Spring的Bean默认是单例模式，也就是说此Bean只会创建一次，然后每次调用都是获取的同一个Bean，那么Spring是怎么实现的呢？ 解析 回到上一章节的的doGetBean()方法，关注Object sharedInstance = getSingleton(beanName); 方法，sharedInstance 见名知意(共享实例)，这个方法是从缓存中获取 Bean 1234567891011121314151617181920212223242526/** * 检查缓存中或者实例工厂中是否有对应的实例，为什么首先会使用这段代码呢 * * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖 * Spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactory提早曝光也就是 * 将ObjectFactory加入缓存中，一旦下个bean创建的时候需要依赖上一个bean，则直接使用ObjectFactory */// Eagerly check singleton cache for manually registered singletons.Object sharedInstance = getSingleton(beanName);// 从缓存中获取 Bean 后，若其不为 null 且 args 为空if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); &#125; else &#123; logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; /** * 为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 Bean ，并不一定使我们最终想要的 Bean * 返回对应的实例，有时候存在诸如BeanFactory的情况并不是直接返回实例本身而是返回指定方法返回的实例 比如工厂bean中定义的factory-method方法中返回的bean */ bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);&#125; 进入getSingleton(beanName)方法，总体逻辑，就是根据 beanNam 依次检测这三个 Map，若为空，从下一个，否则返回，singletonObjects -&gt; earlySingletonObjects -&gt; singletonFactories 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Cache of singleton objects: bean name --&gt; bean instance * 存放的是单例 bean 的映射 一级缓存 * */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);/** * Cache of singleton factories: bean name --&gt; ObjectFactory * 存放的是 ObjectFactory 三级缓存 * */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);/** Cache of early singleton objects: bean name --&gt; bean instance * 提前暴光的单例对象的Cache 二级缓存 * * 1、它与 &#123;@link #singletonFactories&#125; 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整。 * 2、从 &#123;@link #getSingleton(String)&#125; 方法中，我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了。 * 所以当在 bean 的创建过程中，就可以通过 getBean() 方法获取。 * 3、这个 Map 也是【循环依赖】的关键所在。 * */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);/** * 根据 beanName 依次检测这三个 Map，若为空，检测下一个，否则返回 * &#123;@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects&#125; * &#123;@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#earlySingletonObjects&#125; * &#123;@link org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonFactories&#125; * * Return the (raw) singleton object registered under the given name. * &lt;p&gt;Checks already instantiated singletons and also allows for an early * reference to a currently created singleton (resolving a circular reference). * @param beanName the name of the bean to look for * @param allowEarlyReference whether early references should be created or not * @return the registered singleton object, or &#123;@code null&#125; if none found */protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; // 从单例缓冲中加载 bean Object singletonObject = this.singletonObjects.get(beanName); /** * 缓存中的 bean 为空，且bean正在创建中 * 1、isSingletonCurrentlyInCreation 判断该 beanName 对应的 Bean 是否在创建过程中 * 查看private final Set&lt;String&gt; &#123;@link singletonsCurrentlyInCreation) 是否有，该set记录了正在创建bean的beanName */ if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; // 从 earlySingletonObjects 获取 singletonObject = this.earlySingletonObjects.get(beanName); // earlySingletonObjects 中没有，且允许提前创建 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; // 从 singletonFactories 中获取对应的 ObjectFactory ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return (singletonObject != NULL_OBJECT ? singletonObject : null);&#125; 执行完getSingleton方法之后就是判断如果从缓存里获取到了singletonObjects且没有传入参数，那么就执行getObjectForBeanInstance(sharedInstance, name, beanName, null);方法了，该方法的定义为获取给定 Bean 实例的对象，该对象要么是 Bean 实例本身，要么就是 FactoryBean 创建的 Bean 对象。从下面的方法可以看到首先判断该实例是否实现了FactoryBean接口，如果不是那么直接返回该实例，下面的方法就是获取实现了FactoryBean接口的Bean实例了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 该方法的定义为获取给定 Bean 实例的对象，该对象要么是 bean 实例本身，要么就是 FactoryBean 创建的 Bean 对象。 * * Get the object for the given bean instance, either the bean * instance itself or its created object in case of a FactoryBean. * @param beanInstance the shared bean instance * @param name name that may include factory dereference prefix * @param beanName the canonical bean name * @param mbd the merged bean definition * @return the object to expose for the bean */protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123; // 校验 beanInstance 的正确性 如果指定的name是工厂相关(以&amp;为前缀)且beanInstance又不是FactoryBean类型则验证不通过 // Don't let calling code try to dereference the factory if the bean isn't a factory. if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; // 如果 beanInstance 不为 FactoryBean 类型或者 name 也不是与工厂相关的，则直接返回 beanInstance 这个 Bean 对象 // 如果是 FactoryBean，我们则创建该 Bean // Now we have the bean instance, which may be a normal bean or a FactoryBean. // If it's a FactoryBean, we use it to create a bean instance, unless the // caller actually wants a reference to the factory. if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; // 加载FactoryBean Object object = null; if (mbd == null) &#123; // 尝试从缓存中加载bean object = getCachedObjectForFactoryBean(beanName); &#125; // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean 。从而，使用 FactoryBean 获得 Bean 对象 if (object == null) &#123; // Return bean instance from factory. // 到这里已经明确知道beanInstance一定是FactoryBean类型 FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. containsBeanDefinition 检测 beanDefinitionMap 中也就是在所有已经加载的类中 if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; // 是否是用户定义的，而不是应用程序本身定义的 boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); // 核心代码，使用 FactoryBean 获得 Bean 对象 object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; 使用 FactoryBean 获得 Bean 对象之前先来说明下FactoryBean一些概念 FactoryBean 解析 从下面代码可以看到这个接口只有三个方法，重点是getObject()方法 12345678public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; 一般情况下，Spring通过反射机制利用&lt;bean&gt;的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。 FactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。要想获取FactoryBean的实现类，就要getBean(&amp;BeanName)，在BeanName之前加上&amp;。 由上面可以知道要获取 FactoryBean 实例直接调用getObject()方法就是了，继续跟进方法object = getObjectFromFactoryBean(factory, beanName, !synthetic);，此方法可以看到这里又做了个Map&lt;String, Object&gt; factoryBeanObjectCache缓存的处理，如果有就直接get，如果没有就new然后put 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Obtain an object to expose from the given FactoryBean. * @param factory the FactoryBean instance * @param beanName the name of the bean * @param shouldPostProcess whether the bean is subject to post-processing * @return the object obtained from the FactoryBean * @throws BeanCreationException if FactoryBean object creation failed * @see org.springframework.beans.factory.FactoryBean#getObject() */protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) &#123; // 如果是单例模式且缓存中存在 if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) &#123; // 同步锁，锁住的对象都是 this.singletonObjects，主要是因为在单例模式中必须要保证全局唯一 synchronized (getSingletonMutex()) &#123; // 从缓存中获取指定的 factoryBean Object object = this.factoryBeanObjectCache.get(beanName); if (object == null) &#123; // 继续跟进，为空，则从 FactoryBean 中获取对象 object = doGetObjectFromFactoryBean(factory, beanName); // Only post-process and store if not put there already during getObject() call above // (e.g. because of circular reference processing triggered by custom getBean calls) Object alreadyThere = this.factoryBeanObjectCache.get(beanName); if (alreadyThere != null) &#123; object = alreadyThere; &#125; else &#123; if (object != null &amp;&amp; shouldPostProcess) &#123; try &#123; // 对从 FactoryBean 获取的对象进行后处理后处理器 object = postProcessObjectFromFactoryBean(object, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's singleton object failed\", ex); &#125; &#125; // 添加到 factoryBeanObjectCache 中，进行缓存 this.factoryBeanObjectCache.put(beanName, (object != null ? object : NULL_OBJECT)); &#125; &#125; return (object != NULL_OBJECT ? object : null); &#125; &#125; else &#123; // 为空，则从 FactoryBean 中获取对象 Object object = doGetObjectFromFactoryBean(factory, beanName); // 需要后续处理 if (object != null &amp;&amp; shouldPostProcess) &#123; try &#123; // 对从 FactoryBean 获取的对象进行后处理后处理器 object = postProcessObjectFromFactoryBean(object, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"Post-processing of FactoryBean's object failed\", ex); &#125; &#125; return object; &#125;&#125; getObjectFromFactoryBean(factory, beanName, !synthetic) 功能点分析 object = doGetObjectFromFactoryBean(factory, beanName); 从 FactoryBean 中获取对象 看代码，这里是直接调用了object = factory.getObject();方法，是不是很简单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 如果Bean实现了FactoryBean后，通过getBean(String BeanName) * 获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。 * * Obtain an object to expose from the given FactoryBean. * @param factory the FactoryBean instance * @param beanName the name of the bean * @return the object obtained from the FactoryBean * @throws BeanCreationException if FactoryBean object creation failed * @see org.springframework.beans.factory.FactoryBean#getObject() */private Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName) throws BeanCreationException &#123; Object object; try &#123; // 需要权限验证 if (System.getSecurityManager() != null) &#123; AccessControlContext acc = getAccessControlContext(); try &#123; object = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; return factory.getObject(); &#125; &#125;, acc); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; // 直接调用getObject方法 object = factory.getObject(); &#125; &#125; catch (FactoryBeanNotInitializedException ex) &#123; throw new BeanCurrentlyInCreationException(beanName, ex.toString()); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(beanName, \"FactoryBean threw exception on object creation\", ex); &#125; // Do not accept a null value for a FactoryBean that's not fully // initialized yet: Many FactoryBeans just return null then. if (object == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException( beanName, \"FactoryBean which is currently in creation returned null from getObject\"); &#125; return object;&#125; object = postProcessObjectFromFactoryBean(object, beanName);对从 FactoryBean 获取的对象进行后处理后处理器 看代码，直接调用BeanPostProcessor的postProcessAfterInitialization方法，执行bean初始化后的方法逻辑1234567891011121314@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; // 实现 BeanPostProcessor 接口用户可以根据自己的业务需求进行响应的处理 for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessAfterInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 我们可以利用这个特性将bean实现BeanPostProcessor接口，实际开发过程中大可以利用这个方法设计自己的业务逻辑。 1234567891011/** * 定义bean初始化之和初始化之后分别调用的的方法 * * BeanFactory钩子，允许对新建的bean进行自定义修改，eg：检查是否有标记接口或者需要代理bean如果有的话做对应的操作 */public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; 至此，从缓存中获取 Bean对象过程已经分析完毕了。 总结 Spring的单例bean是使用HashMap来实现的，用户可以通过实现FactoryBean接口定制实例化Bean的逻辑，又体现了Spring的灵活性 用户可以实现BeanPostProcessor接口进行业务定制化 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(七)加载Bean之doGetBean方法","slug":"backend/framework/spring/analysis/Spring系列(七)加载Bean之doGetBean方法","date":"2019-06-12T14:00:46.000Z","updated":"2019-06-12T15:15:34.176Z","comments":true,"path":"2019/06/12/backend/framework/spring/analysis/Spring系列(七)加载Bean之doGetBean方法/","link":"","permalink":"http://www.songshuiyang.site/2019/06/12/backend/framework/spring/analysis/Spring系列(七)加载Bean之doGetBean方法/","excerpt":"","text":"前言 经过容器初始化阶段后，应用程序中定义的 bean 信息（BeanDefinition ）已经全部加载到系统中了，当我们显示或者隐式地调用 BeanFactory#getBean(...) 方法时，则会触发加载 Bean 阶段。 在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 Bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。 下面的章节将会介绍加载Bean的过程，仓库里有货了就应该让它发挥作用 解析 调用 BeanFactory#getBean(...) 方法 123456// AbstractBeanFactory.java@Overridepublic Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125; 内部调用 doGetBean(String name, final Class&lt;T&gt; requiredType, Object[] args, boolean typeCheckOnly) 下面是代码主体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202/** * doGetBean统一入口 * * Return an instance, which may be shared or independent, of the specified bean. * @param name the name of the bean to retrieve 要获取 Bean 的名字 * @param requiredType the required type of the bean to retrieve 要获取 bean 的类型 * @param args arguments to use when creating a bean instance using explicit arguments 创建 Bean 时传递的参数。这个参数仅限于创建 Bean 时使用。 * (only applied when creating a new instance as opposed to retrieving an existing one) * @param typeCheckOnly whether the instance is obtained for a type check, 是否为类型检查。 * not for actual use * @return an instance of the bean * @throws BeansException if the bean could not be created */@SuppressWarnings(\"unchecked\")protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; /** * 提取对应的beanName， 这里传递的是 name 方法，不一定就是 beanName，可能是 aliasName * 也有可能是 FactoryBean FactoryBean会带上&amp;符号， */ final String beanName = transformedBeanName(name); Object bean; /** * 检查缓存中或者实例工厂中是否有对应的实例，为什么首先会使用这段代码呢 * * 因为在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖 * Spring创建bean的原则是不等bean创建完成就会创建bean的ObjectFactory提早曝光也就是 * 将ObjectFactory加入缓存中，一旦下个bean创建的时候需要依赖上一个bean，则直接使用ObjectFactory */ // Eagerly check singleton cache for manually registered singletons. Object sharedInstance = getSingleton(beanName); // 从缓存中获取 Bean 后，若其不为 null 且 args 为空 if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(\"Returning eagerly cached instance of singleton bean '\" + beanName + \"' that is not fully initialized yet - a consequence of a circular reference\"); &#125; else &#123; logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; /** * 为什么会有这么一段呢？因为我们从缓存中获取的 bean 是最原始的 Bean ，并不一定使我们最终想要的 Bean * 返回对应的实例，有时候存在诸如BeanFactory的情况并不是直接返回实例本身而是返回指定方法返回的实例 比如工厂bean中定义的factory-method方法中返回的bean */ bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; // 在缓存中没有 // 只有单例情况下才会尝试解决循依赖（如果存在A中有B属性，B中有A属性，那么当依赖注入的时候，就会产生当A还未创建完的时候因为对于B的创建再次创建A，造成循环依赖） // 在原型模式下如果存在循环依赖则会抛出异常。 // Fail if we're already creating this bean instance: // We're assumably within a circular reference. if (isPrototypeCurrentlyInCreation(beanName)) &#123; throw new BeanCurrentlyInCreationException(beanName); &#125; // Check if bean definition exists in this factory. // 判断工厂中是否含有此Bean的定义，如果没有找到则父类容器里找 BeanFactory parentBeanFactory = getParentBeanFactory(); // 如果beanDefinitionMap中也就是在所有已经加载的类中不包括beanName，则尝试从parentBeanFactory中检测 if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // Not found -&gt; check parent. 如果没有，查询父工厂 String nameToLookup = originalBeanName(name); // 递归到BeanFactory中寻找 递归调用getBean方法 if (args != null) &#123; // Delegation to parent with explicit args. 执行带有args参数的getbean方法 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. 如果没有参数，执行标准的getbean方法 return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; // 如果不是仅仅做类型检查则是创建bean，这里要进行记录 if (!typeCheckOnly) &#123; markBeanAsCreated(beanName); &#125; try &#123; // 将存储XML配置文件的GernericBeanDefinition 转换为RootBeanDefinition， // 如果指定BeanName是子Bean的话同时会合并父类的相关属性 final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); // 检查给定的合并的 BeanDefinition checkMergedBeanDefinition(mbd, beanName, args); // 处理所依赖的 bean // Guarantee initialization of beans that the current bean depends on. String[] dependsOn = mbd.getDependsOn(); // 若存在依赖则需要递归实例化依赖的bean，在Spring的加载顺序中，在初始化某一个bean的时候首先会初始化这个bean所对应的依赖 if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; // 缓存依赖调用 registerDependentBean(dep, beanName); /** * 递归处理依赖 Bean * 每个 Bean 都不是单独工作的，它会依赖其他 Bean，其他 Bean 也会依赖它。 * 对于依赖的 Bean ，它会优先加载，所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。 */ getBean(dep); &#125; &#125; // Create bean instance. 重头戏 // 单例模式的实例化bean if (mbd.isSingleton()) &#123; // 获取实例了 sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; // 创建bean return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; // Explicitly remove instance from singleton cache: It might have been put there // eagerly by the creation process, to allow for circular reference resolution. // Also remove any beans that received a temporary reference to the bean. // 显式从单例缓存中删除 Bean 实例，因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它 destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 原型模式的实例化bean else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; else &#123; // 指定的scope上实例化bean String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; /** * 检查需要的类型是否符合bean的实际类型 Check if required type matches the type of the actual bean instance. * 当然就一般而言，我们是不需要进行类型转换的，也就是 requiredType 为空（比如 #getBean(String name) 方法）。 * 但有，可能会存在这种情况，比如我们返回的 Bean 类型为 String ，我们在使用的时候需要将其转换为 Integer， * 那么这个时候 requiredType 就有用武之地了。当然我们一般是不需要这样做的。 */ if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123; try &#123; // 执行转换 return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); &#125; // 转换失败，抛出 BeanNotOfRequiredTypeException 异常 throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(六)装载BeanDefinition总结","slug":"backend/framework/spring/analysis/Spring系列(六)装载BeanDefinition总结","date":"2019-06-11T14:00:46.000Z","updated":"2019-06-12T15:15:34.536Z","comments":true,"path":"2019/06/11/backend/framework/spring/analysis/Spring系列(六)装载BeanDefinition总结/","link":"","permalink":"http://www.songshuiyang.site/2019/06/11/backend/framework/spring/analysis/Spring系列(六)装载BeanDefinition总结/","excerpt":"","text":"前言 调试代码 1234567public class ClassPathXmlApplicationContextTest &#123; @Test public void classPathXmlApplicationContext () &#123; ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\"); User user = xmlApplicationContext.getBean(User.class); &#125;&#125; 前面的第二节到第五节分析了 IoC BeanDefinition 装载的整个过程，这篇就这些内容做一个总结将其连贯起来。IoC 容器的初始化过程分为三步骤Resource 定位、BeanDefinition 的装载，BeanDefinition解析及注册。 Resource 定位 我们一般用外部资源来描述 Bean 对象，所以在初始化 IoC 容器的第一步就是需要定位这个外部资源。 上面的调试代码new ClassPathXmlApplicationContext(&quot;beans/bean.xml&quot;);中我们传入了配置文件的一个路径，然后Spring就是通过这个路径使用ResourceLoader来找到对应的Resource 123456789101112public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; throw new BeanDefinitionStoreException( \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\"); &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; // 通过`ResourceLoader`来用这个路径找到对应的`Resource` Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); BeanDefinition 的装载 上一步已经得到了Resource了，现在就是装载，这个过程使用XmlBeanDefinitionReader来完成解析，可以看到InputStream inputStream = encodedResource.getResource().getInputStream(); 通过Resource对象直接获取到了InputStream 1234567891011121314151617181920212223242526public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); &#125; // 通过属性来记录已经加载的资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); &#125; try &#123; // 获取输入流 InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; // 构造 InputSource ，此类不是Spring的类 InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 逻辑核心部分 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); 得到InputStream之后就是解析了，就是这个方法doLoadBeanDefinitions(inputSource, encodedResource.getResource());来获取到Document doc对象，这个是要下一步需要 BeanDefinition 解析及注册。解析 上一步已经得到了Document doc，现在就是需要将它解析得到BeanDefinition，这个工作由 BeanDefinitionDocumentReader来实现 注册 在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构，这里的IoC 容器是DefaultListableBeanFactory，在配置文件中每一个bean都对应着一个 BeanDefinition 对象，注册工作就是将BeanDefinition put到容器的map中，这个过程是通过 BeanDefinitionRegistry 接口来实现的。,DefaultListableBeanFactory实现了这个接口 12345678910111213141516171819202122232425262728// DefaultListableBeanFactory.java@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; // ...省略校验相关的代码 // 从缓存中获取指定 beanName 的 BeanDefinition BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName); // 如果已经存在 if (existingDefinition != null) &#123; // 如果存在但是不允许覆盖，抛出异常 if (!isAllowBeanDefinitionOverriding()) &#123; throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition); &#125; else &#123; // ...省略 logger 打印日志相关的代码 &#125; // 【重点】允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。 this.beanDefinitionMap.put(beanName, beanDefinition); // 如果未存在 &#125; else &#123; // ... 省略非核心的代码 // 【重点】添加到 BeanDefinition 到 beanDefinitionMap 中。 this.beanDefinitionMap.put(beanName, beanDefinition); &#125; // 重新设置 beanName 对应的缓存 if (existingDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125;&#125; 在 IoC 容器内部其实是将解析得到的 BeanDefinition 注入到一个HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。 总结 在这里需要注意的一点是这个过程并没有完成依赖注入Bean创建），Bean 创建是发生在应用第一次调用 #getBean(...) 方法，向容器索要 Bean 时。当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit = false 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。 整体时序图如下: 红框部分，就是 BeanDefinition 的解析过程 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(五)Document读取器BeanDefinitionDocumentReader","slug":"backend/framework/spring/analysis/Spring系列(五)Document读取器BeanDefinitionDocumentReader","date":"2019-06-09T08:00:46.000Z","updated":"2019-06-22T03:59:15.264Z","comments":true,"path":"2019/06/09/backend/framework/spring/analysis/Spring系列(五)Document读取器BeanDefinitionDocumentReader/","link":"","permalink":"http://www.songshuiyang.site/2019/06/09/backend/framework/spring/analysis/Spring系列(五)Document读取器BeanDefinitionDocumentReader/","excerpt":"","text":"前言 回顾上一章节的内容，在XmlBeanDefinitionReader中已经获取了Document doc，那么需要将Document doc对象解析成BeanDefinition，这里Document读取器BeanDefinitionDocumentReader就开始上场表演了 123456789101112131415161718192021222324252627/** * Register the bean definitions contained in the given DOM document. * Called by &#123;@code loadBeanDefinitions&#125;. * &lt;p&gt;Creates a new instance of the parser class and invokes * &#123;@code registerBeanDefinitions&#125; on it. * @param doc the DOM document * @param resource the resource descriptor (for context information) * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of parsing errors * @see #loadBeanDefinitions * @see #setDocumentReaderClass * @see BeanDefinitionDocumentReader#registerBeanDefinitions */public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; /** * 使用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader，在实例化BeanDefinitionDocumentReader的时候会将 * * @see DefaultBeanDefinitionDocumentReader * */ BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 记录统计前的BeanDefinition的加载个数 int countBefore = getRegistry().getBeanDefinitionCount(); // 加载并注册bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();这里获取的是DefaultBeanDefinitionDocumentReader类，此类是BeanDefinitionDocumentReader接口的唯一实现类 createReaderContext(resource) 方法将我们的上一章节XmlBeanDefinitionReader对象放在了一个新的对象XmlReaderContext中，注意下面的this指针 1234567/** * Create the &#123;@link XmlReaderContext&#125; to pass over to the document reader. */public XmlReaderContext createReaderContext(Resource resource) &#123; return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver());&#125; BeanDefinitionDocumentReader定义了读取Document 并注册为BeanDefinition功能，里面只有一个方法void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) DefaultBeanDefinitionDocumentReader 属性：可以看到我们熟悉的xml配置标签名 123456789101112131415161718192021222324public class DefaultBeanDefinitionDocumentReader implements BeanDefinitionDocumentReader &#123; public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT; public static final String NESTED_BEANS_ELEMENT = \"beans\"; public static final String ALIAS_ELEMENT = \"alias\"; public static final String NAME_ATTRIBUTE = \"name\"; public static final String ALIAS_ATTRIBUTE = \"alias\"; public static final String IMPORT_ELEMENT = \"import\"; public static final String RESOURCE_ATTRIBUTE = \"resource\"; public static final String PROFILE_ATTRIBUTE = \"profile\"; protected final Log logger = LogFactory.getLog(getClass()); private XmlReaderContext readerContext; private BeanDefinitionParserDelegate delegate; 上面可以看到里面有个BeanDefinitionParserDelegate类，这个类是BeanDefinition解析方法，里面是解析Element的各种方法，从成员变量中可以看到xml标签名及属性名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169public class BeanDefinitionParserDelegate &#123; public static final String BEANS_NAMESPACE_URI = \"http://www.springframework.org/schema/beans\"; public static final String MULTI_VALUE_ATTRIBUTE_DELIMITERS = \",; \"; /** * Value of a T/F attribute that represents true. * Anything else represents false. Case seNsItive. */ public static final String TRUE_VALUE = \"true\"; public static final String FALSE_VALUE = \"false\"; public static final String DEFAULT_VALUE = \"default\"; public static final String DESCRIPTION_ELEMENT = \"description\"; public static final String AUTOWIRE_NO_VALUE = \"no\"; public static final String AUTOWIRE_BY_NAME_VALUE = \"byName\"; public static final String AUTOWIRE_BY_TYPE_VALUE = \"byType\"; public static final String AUTOWIRE_CONSTRUCTOR_VALUE = \"constructor\"; public static final String AUTOWIRE_AUTODETECT_VALUE = \"autodetect\"; public static final String DEPENDENCY_CHECK_ALL_ATTRIBUTE_VALUE = \"all\"; public static final String DEPENDENCY_CHECK_SIMPLE_ATTRIBUTE_VALUE = \"simple\"; public static final String DEPENDENCY_CHECK_OBJECTS_ATTRIBUTE_VALUE = \"objects\"; public static final String NAME_ATTRIBUTE = \"name\"; public static final String BEAN_ELEMENT = \"bean\"; public static final String META_ELEMENT = \"meta\"; public static final String ID_ATTRIBUTE = \"id\"; public static final String PARENT_ATTRIBUTE = \"parent\"; public static final String CLASS_ATTRIBUTE = \"class\"; public static final String ABSTRACT_ATTRIBUTE = \"abstract\"; public static final String SCOPE_ATTRIBUTE = \"scope\"; private static final String SINGLETON_ATTRIBUTE = \"singleton\"; public static final String LAZY_INIT_ATTRIBUTE = \"lazy-init\"; public static final String AUTOWIRE_ATTRIBUTE = \"autowire\"; public static final String AUTOWIRE_CANDIDATE_ATTRIBUTE = \"autowire-candidate\"; public static final String PRIMARY_ATTRIBUTE = \"primary\"; public static final String DEPENDENCY_CHECK_ATTRIBUTE = \"dependency-check\"; public static final String DEPENDS_ON_ATTRIBUTE = \"depends-on\"; public static final String INIT_METHOD_ATTRIBUTE = \"init-method\"; public static final String DESTROY_METHOD_ATTRIBUTE = \"destroy-method\"; public static final String FACTORY_METHOD_ATTRIBUTE = \"factory-method\"; public static final String FACTORY_BEAN_ATTRIBUTE = \"factory-bean\"; public static final String CONSTRUCTOR_ARG_ELEMENT = \"constructor-arg\"; public static final String INDEX_ATTRIBUTE = \"index\"; public static final String TYPE_ATTRIBUTE = \"type\"; public static final String VALUE_TYPE_ATTRIBUTE = \"value-type\"; public static final String KEY_TYPE_ATTRIBUTE = \"key-type\"; public static final String PROPERTY_ELEMENT = \"property\"; public static final String REF_ATTRIBUTE = \"ref\"; public static final String VALUE_ATTRIBUTE = \"value\"; public static final String LOOKUP_METHOD_ELEMENT = \"lookup-method\"; public static final String REPLACED_METHOD_ELEMENT = \"replaced-method\"; public static final String REPLACER_ATTRIBUTE = \"replacer\"; public static final String ARG_TYPE_ELEMENT = \"arg-type\"; public static final String ARG_TYPE_MATCH_ATTRIBUTE = \"match\"; public static final String REF_ELEMENT = \"ref\"; public static final String IDREF_ELEMENT = \"idref\"; public static final String BEAN_REF_ATTRIBUTE = \"bean\"; public static final String LOCAL_REF_ATTRIBUTE = \"local\"; public static final String PARENT_REF_ATTRIBUTE = \"parent\"; public static final String VALUE_ELEMENT = \"value\"; public static final String NULL_ELEMENT = \"null\"; public static final String ARRAY_ELEMENT = \"array\"; public static final String LIST_ELEMENT = \"list\"; public static final String SET_ELEMENT = \"set\"; public static final String MAP_ELEMENT = \"map\"; public static final String ENTRY_ELEMENT = \"entry\"; public static final String KEY_ELEMENT = \"key\"; public static final String KEY_ATTRIBUTE = \"key\"; public static final String KEY_REF_ATTRIBUTE = \"key-ref\"; public static final String VALUE_REF_ATTRIBUTE = \"value-ref\"; public static final String PROPS_ELEMENT = \"props\"; public static final String PROP_ELEMENT = \"prop\"; public static final String MERGE_ATTRIBUTE = \"merge\"; public static final String QUALIFIER_ELEMENT = \"qualifier\"; public static final String QUALIFIER_ATTRIBUTE_ELEMENT = \"attribute\"; public static final String DEFAULT_LAZY_INIT_ATTRIBUTE = \"default-lazy-init\"; public static final String DEFAULT_MERGE_ATTRIBUTE = \"default-merge\"; public static final String DEFAULT_AUTOWIRE_ATTRIBUTE = \"default-autowire\"; public static final String DEFAULT_DEPENDENCY_CHECK_ATTRIBUTE = \"default-dependency-check\"; public static final String DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE = \"default-autowire-candidates\"; public static final String DEFAULT_INIT_METHOD_ATTRIBUTE = \"default-init-method\"; public static final String DEFAULT_DESTROY_METHOD_ATTRIBUTE = \"default-destroy-method\"; protected final Log logger = LogFactory.getLog(getClass()); private final XmlReaderContext readerContext; private final DocumentDefaultsDefinition defaults = new DocumentDefaultsDefinition(); private final ParseState parseState = new ParseState(); /** * Stores all used bean names so we can enforce uniqueness on a per * beans-element basis. Duplicate bean ids/names may not exist within the * same level of beans element nesting, but may be duplicated across levels. */ private final Set&lt;String&gt; usedNames = new HashSet&lt;String&gt;(); 跟进documentReader.registerBeanDefinitions(doc, createReaderContext(resource));方法，可以看到将XmlReaderContext readerContext对象放到了DefaultBeanDefinitionDocumentReader的 private XmlReaderContext readerContext;成员对象中，这个是BeanDefinitionDocumentReader与XmlBeanDefinitionReader进行互通的纽带 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * This implementation parses bean definitions according to the \"spring-beans\" XSD * (or DTD, historically). * &lt;p&gt;Opens a DOM Document; then initializes the default settings * specified at the &#123;@code &lt;beans/&gt;&#125; level; then parses the contained bean definitions. */@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); Element root = doc.getDocumentElement(); // 核心逻辑，真正的开始解析了 doRegisterBeanDefinitions(root);&#125;/** * Register each bean definition within the given root &#123;@code &lt;beans/&gt;&#125; element. */protected void doRegisterBeanDefinitions(Element root) &#123; // Any nested &lt;beans&gt; elements will cause recursion in this method. In // order to propagate and preserve &lt;beans&gt; default-* attributes correctly, // keep track of the current (parent) delegate, which may be null. Create // the new (child) delegate with a reference to the parent for fallback purposes, // then ultimately reset this.delegate back to its original (parent) reference. // this behavior emulates a stack of delegates without actually necessitating one. BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; // 检查是否定义了profile属性，如果定义了需要到环境变量中找，利用这个特性我们可以在配置文件中部署不同的环境 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; // 解析前处理，留给子类实现 preProcessXml(root); // 解析并注册BeBeanDefinitions parseBeanDefinitions(root, this.delegate); // 解析后处理，留给子类实现 postProcessXml(root); this.delegate = parent;&#125; 进入parseBeanDefinitions(root, this.delegate);方法，这里分为默认标签解析及自定义标签解析 123456789101112131415161718192021222324252627/** * Parse the elements at the root level in the document: * \"import\", \"alias\", \"bean\". * @param root the DOM root element of the document */protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; // 如果是默认命名空间 xmlns=\"http://www.springframework.org/schema/beans\" if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; // 默认标签解析 如&lt;bean class=\"\"/&gt; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; // 自定义标签解析 如：&lt;context:component-scan base-package = \"*\"/&gt; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123;// 自定义标签解析 delegate.parseCustomElement(root); &#125;&#125; delegate.isDefaultNamespace(root) 方法用于区分是使用默认标签解析还是自定义标签解析，由下面代码可以看到是获取了Node标签的命名间URI然后再与&quot;http://www.springframework.org/schema/beans&quot;字符串进行比较，可以看到如果相等的话就是默认标签了 isDefaultNamespace(root)方法 12345678public static final String BEANS_NAMESPACE_URI = \"http://www.springframework.org/schema/beans\";public boolean isDefaultNamespace(Node node) &#123; return isDefaultNamespace(getNamespaceURI(node));&#125;public boolean isDefaultNamespace(String namespaceUri) &#123; return (!StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri));&#125; 访问 http://www.springframework.org/schema/beans 得到的是beans的XSD定义文件 12345678910111213Index of /schema/beansIcon Name Last modified Size Description[PARENTDIR] Parent Directory - [TXT] spring-beans-2.0.xsd 2019-05-09 08:43 38K [TXT] spring-beans-2.5.xsd 2019-05-09 08:43 41K [TXT] spring-beans-3.0.xsd 2019-05-09 08:43 41K [TXT] spring-beans-3.1.xsd 2019-05-09 08:43 42K [TXT] spring-beans-3.2.xsd 2019-05-09 08:43 43K [TXT] spring-beans-4.0.xsd 2019-05-09 08:43 42K [TXT] spring-beans-4.1.xsd 2019-05-09 08:43 43K [TXT] spring-beans-4.2.xsd 2019-05-09 08:43 43K [TXT] spring-beans-4.3.xsd 2019-05-09 08:43 43K [TXT] spring-beans.xsd 2019-05-09 08:43 43K 默认标签解析parseDefaultElement(ele, delegate) 可以看到这些是Spring默认的一些标签 12345678910111213141516171819202122232425/** * 默认标签解析 * * @param ele * @param delegate */private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; // 解析import if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; // 解析alias else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; // 解析bean 最为复杂最为重要 else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; // 解析beans else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; 进入processBeanDefinition(ele, delegate);我们这里查看bean标签是怎么解析的，毕竟是Spring的主力军，可以看到下面的方法先是获取了BeanDefinitionHolder，这个是BeanDefinition的一个容器，在BeanDefinition内容的基础上添加了beanName及aliases属性，然后标签的解析工作是由BeanDefinitionParserDelegate类的registerBeanDefinition方法来执行的，这个类在上面的内容中简单提过一次，BeanDefinitionParserDelegate类提供了解析spring配置文件功能，对于默认空间下的元素在该类内部实现，如果是其它命名空间下的元素可以通过绑定NamespaceHandler的方式来实现,针对每个命名空间下的元素提供不同BeanDefinitionParser来实现. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Process the given bean element, parsing the bean definition * and registering it with the registry. */protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; /** * 委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析 * * bdHolder 实例已经包含我们配置文件中配置的各个属性了，例如class、name、id、alias */ BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; /** * 对解析后的bdHolder进行注册 * Register the final decorated instance. */ BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125;/** * * BeanDefinitionHolder 实例已经包含我们配置文件中配置的各个属性了， * 有beanDefinition及beanName和aliases,为注册做准备 * * Holder for a BeanDefinition with name and aliases. * Can be registered as a placeholder for an inner bean. * * &lt;p&gt;Can also be used for programmatic registration of inner bean * definitions. If you don't care about BeanNameAware and the like, * registering RootBeanDefinition or ChildBeanDefinition is good enough. * * @author Juergen Hoeller * @since 1.0.2 * @see org.springframework.beans.factory.BeanNameAware * @see org.springframework.beans.factory.support.RootBeanDefinition * @see org.springframework.beans.factory.support.ChildBeanDefinition */ public class BeanDefinitionHolder implements BeanMetadataElement &#123; private final BeanDefinition beanDefinition; private final String beanName; private final String[] aliases; 进入delegate.parseBeanDefinitionElement(ele)，可以看到一些基础代码String id = ele.getAttribute(ID_ATTRIBUTE); 获取id呀，获取name属性呀 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Parses the supplied &#123;@code &lt;bean&gt;&#125; element. May return &#123;@code null&#125; * if there were errors during parse. Errors are reported to the * &#123;@link org.springframework.beans.factory.parsing.ProblemReporter&#125;. */public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; // 获取id属性 String id = ele.getAttribute(ID_ATTRIBUTE); // 获取name属性 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); // 分割name属性 这里是实现了多个name配置的解析，可以是`,; `作为分割 List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\"); &#125; &#125; if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) &#123; if (!StringUtils.hasText(beanName)) &#123; try &#123; // 如果不存在beanName那么根据Spring中提供的命名规则为当前的bean生成对应的beanName if (containingBean != null) &#123; beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Neither XML 'id' nor 'name' specified - \" + \"using generated bean name [\" + beanName + \"]\"); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; parseBeanDefinitionElement(ele, beanName, containingBean) 这个方法构造了BeanDefinition，在这里是AbstractBeanDefinition对象，通过下面的代码可以很清晰的与&lt;bean&gt;标签的一些属性对应在一起，这些xml标签在Spring中就是转化成BeanDefinition 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Parse the bean definition itself, without regard to name or aliases. May return * &#123;@code null&#125; if problems occurred during the parsing of the bean definition. */public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; // 获取class属性 if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; // 创建用于承载属性的AbstractBeanDefinition类型的GenericBeanDefinition AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 硬编码解析默认bean的各种属性 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); // 提取description bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); // 解析元数据 parseMetaElements(ele, bd); // 解析lookup-method parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析replaced-method parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析构造函数参数 parseConstructorArgElements(ele, bd); // 解析property子元素 parsePropertyElements(ele, bd); // 解析qualifier子元素 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(\"Bean class [\" + className + \"] not found\", ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); &#125; catch (Throwable ex) &#123; error(\"Unexpected failure during bean definition parsing\", ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 回到protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)方法，在这里我们已经得到了BeanDefinitionHolder，下面就是需要将解析后的结果注册存放起来了，下面的BeanDefinitionReaderUtils.registerBeanDefinition方法就是做的这个任务 123456789101112131415161718192021222324252627282930313233343536373839/** * Process the given bean element, parsing the bean definition * and registering it with the registry. */protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; /** * 委托BeanDefinitionParserDelegate的parseBeanDefinitionElement方法进行元素解析 * * bdHolder 实例已经包含我们配置文件中配置的各个属性了，例如class、name、id、alias */ BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; /** * 对解析后的bdHolder进行注册 * Register the final decorated instance. */ BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; ``` * 进入`BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());`方法，关注`getReaderContext().getRegistry()`方法，由上面可以知道`XmlReaderContext`存放着`XmlBeanDefinitionReader`，而`XmlBeanDefinitionReader`存放着`private final BeanDefinitionRegistry registry;`我们的`beanFactory` private XmlReaderContext readerContext; ```java/** * Return the descriptor for the XML resource that this parser works on. */protected final XmlReaderContext getReaderContext() &#123; return this.readerContext;&#125; 下面的代码可以看到第二参数是看到传入了BeanDefinitionRegistry对象，下面的方法就是根据BeanDefinitionHolder信息调用BeanDefinitionRegistry类的方法注册BeanDefinition及Aliases 1234567891011121314151617181920212223/** * Register the given bean definition with the given bean factory. * @param definitionHolder the bean definition including name and aliases * @param registry the bean factory to register with * @throws BeanDefinitionStoreException if registration failed */public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; // Register bean definition under primary name. 使用beanName做唯一标识注册 String beanName = definitionHolder.getBeanName(); // 核心代码 registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. 注册所有的别名 String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; 进入核心方法registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());，关注this.beanDefinitionMap.put(beanName, beanDefinition); 可以看到将我们得到的beanDefinition存放到了一个private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap中，到这一个&lt;bean&gt;标签已经是解析完成了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; // 校验 beanName 与 beanDefinition 非空 Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); // 校验 BeanDefinition 这是注册前的最后一次校验了，主要是对 AbstractBeanDefinition 的 methodOverrides 属性进行校验。 if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Validation of bean definition failed\", ex); &#125; &#125; BeanDefinition oldBeanDefinition; // 从缓存中获取指定 beanName 的 BeanDefinition oldBeanDefinition = this.beanDefinitionMap.get(beanName); // 如果已经存在 if (oldBeanDefinition != null) &#123; // 如果存在但是不允许覆盖，抛出异常 if (!isAllowBeanDefinitionOverriding()) &#123; throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName, \"Cannot register bean definition [\" + beanDefinition + \"] for bean '\" + beanName + \"': There is already [\" + oldBeanDefinition + \"] bound.\"); &#125; // 覆盖 beanDefinition 大于 被覆盖的 beanDefinition 的 ROLE ，打印 info 日志 else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123; // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE if (this.logger.isWarnEnabled()) &#123; this.logger.warn(\"Overriding user-defined bean definition for bean '\" + beanName + \"' with a framework-generated bean definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); &#125; &#125; // 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不相同，打印 debug 日志 else if (!beanDefinition.equals(oldBeanDefinition)) &#123; if (this.logger.isInfoEnabled()) &#123; this.logger.info(\"Overriding bean definition for bean '\" + beanName + \"' with a different definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); &#125; &#125; // 其它，打印 debug 日志 else &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Overriding bean definition for bean '\" + beanName + \"' with an equivalent definition: replacing [\" + oldBeanDefinition + \"] with [\" + beanDefinition + \"]\"); &#125; &#125; // 允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。 this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; // 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制 if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) // beanDefinitionMap 为全局变量，避免并发情况 synchronized (this.beanDefinitionMap) &#123; // 添加到 BeanDefinition 到 beanDefinitionMap 中。 this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); // 添加 beanName 到 beanDefinitionNames 中 this.beanDefinitionNames = updatedDefinitions; // 从 manualSingletonNames 移除 beanName if (this.manualSingletonNames.contains(beanName)) &#123; Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; &#125; &#125; &#125; else &#123; // Still in startup registration phase // 添加到 BeanDefinition 到 beanDefinitionMap 中。 this.beanDefinitionMap.put(beanName, beanDefinition); // 添加 beanName 到 beanDefinitionNames 中 this.beanDefinitionNames.add(beanName); // 从 manualSingletonNames 移除 beanName this.manualSingletonNames.remove(beanName); &#125; this.frozenBeanDefinitionNames = null; &#125; // 重新设置 beanName 对应的缓存 if (oldBeanDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125;&#125; 自定义标签解析delegate.parseCustomElement(ele) 与默认标签解析的操作不同，它是通过调用BeanDefinitionParser接口的parse方法来解析 12345678910111213141516public BeanDefinition parseCustomElement(Element ele) &#123; return parseCustomElement(ele, null);&#125;public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; // 获取xml配置文件中的命名空间http://www.springframework.org/schema/context String namespaceUri = getNamespaceURI(ele); // 根据命名空间找到命名空间处理类 比如ContextNamespaceHandler AopNamespaceHandler NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); if (handler == null) &#123; error(\"Unable to locate Spring NamespaceHandler for XML schema namespace [\" + namespaceUri + \"]\", ele); return null; &#125; // 解析命名空间支持的标签 return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; 这里有个NamespaceHandler这个接口主要功能是通过Element标签找到对于的BeanDefinitionParser，找到之后然后调用BeanDefinitionParser接口的parse方法来解析 NamespaceHandler接口 命名空间处理器，我们就可以根据需求自己来处理我们设置的标签元素。 可能需要配置如&lt;aop:config /&gt;这样的标签, 在配置这个标签之前，通常我们需要在xml中引入这个aop所在的命名空间，xmlns:aop=&quot;http://www.springframework.org/schema/aop 只有通过配置aop的命名空间才会找到AOP标签的处理器{@link org.springframework.aop.config.AopNamespaceHandler}，在AOP的jar中的spring.handlers配置文件中配置了命名空间和命名空间处理器之间的关系。 比如我们这里是&lt;context:component-scan/&gt;标签，所以得到的命名空间处理类是ContextNamespaceHandler 123456789101112131415public class ContextNamespaceHandler extends NamespaceHandlerSupport &#123; @Override public void init() &#123; registerBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser()); registerBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser()); registerBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser()); registerBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser()); registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser()); registerBeanDefinitionParser(\"mbean-export\", new MBeanExportBeanDefinitionParser()); registerBeanDefinitionParser(\"mbean-server\", new MBeanServerBeanDefinitionParser()); &#125;&#125; 关注registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());这行代码这里注册了标签命名与对应解析类的对应关系，找到ContextNamespaceHandler之后就是调用对应解析类的对应方法了，调用ComponentScanBeanDefinitionParser的parse方法，此类实现了BeanDefinitionParser 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Parser for the &#123;@code &lt;context:component-scan/&gt;&#125; element. * * @author Mark Fisher * @author Ramnivas Laddad * @author Juergen Hoeller * @since 2.5 */public class ComponentScanBeanDefinitionParser implements BeanDefinitionParser &#123; private static final String BASE_PACKAGE_ATTRIBUTE = \"base-package\"; private static final String RESOURCE_PATTERN_ATTRIBUTE = \"resource-pattern\"; private static final String USE_DEFAULT_FILTERS_ATTRIBUTE = \"use-default-filters\"; private static final String ANNOTATION_CONFIG_ATTRIBUTE = \"annotation-config\"; private static final String NAME_GENERATOR_ATTRIBUTE = \"name-generator\"; private static final String SCOPE_RESOLVER_ATTRIBUTE = \"scope-resolver\"; private static final String SCOPED_PROXY_ATTRIBUTE = \"scoped-proxy\"; private static final String EXCLUDE_FILTER_ELEMENT = \"exclude-filter\"; private static final String INCLUDE_FILTER_ELEMENT = \"include-filter\"; private static final String FILTER_TYPE_ATTRIBUTE = \"type\"; private static final String FILTER_EXPRESSION_ATTRIBUTE = \"expression\"; @Override public BeanDefinition parse(Element element, ParserContext parserContext) &#123; String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage); // 解析base-package属性值，扫描的包可以,;分隔 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. // 构建类路径的BeanDefinition扫描器 ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); // 在指定的基础包中执行扫描 base-package = \"org.springiframe.*\" 找出该包下所有的bean注册为beanDefinition Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); // 注册组件 registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null; &#125; 进入configureScanner(parserContext, element);方法，这里是构建了ClassPathBeanDefinitionScanner对象，并解析标签元素 123456789101112131415161718192021222324252627282930313233343536373839protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) &#123; // 默认使用spring自带的注解过滤 boolean useDefaultFilters = true; // 解析`use-default-filters`，类型为boolean if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123; useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); &#125; // Delegate bean definition registration to scanner class. // 此处如果`use-default-filters`为true，则添加`@Component`、`@Service`、`@Controller`、`@Repository`、`@ManagedBean`、`@Named`添加到includeFilters的集合过滤 ClassPathBeanDefinitionScanner scanner = createScanner(parserContext.getReaderContext(), useDefaultFilters); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); // 设置`resource-pattern`属性，扫描资源的模式匹配，支持正则表达式 if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123; scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); &#125; try &#123; // 解析name-generator属性 beanName生成器 parseBeanNameGenerator(element, scanner); &#125; catch (Exception ex) &#123; parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); &#125; try &#123; // 解析scope-resolver属性和scoped-proxy属性，但两者只可存在其一 后者值为targetClass：cglib代理、interfaces：JDK代理、no：不使用代理 parseScope(element, scanner); &#125; catch (Exception ex) &#123; parserContext.getReaderContext().error(ex.getMessage(), parserContext.extractSource(element), ex.getCause()); &#125; // 解析子节点`context:include-filter`、`context:exclude-filter`主要用于对扫描class类的过滤 parseTypeFilters(element, scanner, parserContext); return scanner;&#125; 进入createScanner(parserContext.getReaderContext(), useDefaultFilters); 方法里面的registerDefaultFilters();方法，可以看到默认是注册了@Component,@ManagedBean,@Named过滤器到this.includeFilters中 1234567891011121314151617181920protected void registerDefaultFilters() &#123; this.includeFilters.add(new AnnotationTypeFilter(Component.class)); ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader(); try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(\"javax.annotation.ManagedBean\", cl)), false)); logger.debug(\"JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning\"); &#125; catch (ClassNotFoundException ex) &#123; // JSR-250 1.1 API (as included in Java EE 6) not available - simply skip. &#125; try &#123; this.includeFilters.add(new AnnotationTypeFilter( ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(\"javax.inject.Named\", cl)), false)); logger.debug(\"JSR-330 'javax.inject.Named' annotation found and supported for component scanning\"); &#125; catch (ClassNotFoundException ex) &#123; // JSR-330 API not available - simply skip. &#125;&#125; 从上面可以看到Spring支持如下三种注解 Spring自带的@Component注解及扩展@Repository、@Service、@Controller JSR-250 1.1版本中中定义的@ManagedBean注解，是Java EE 6标准规范之一，不包括在JDK中，需要在应用服务器环境使用（如Jboss） JSR-330的@Named注解 回到Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);方法，这个方法就是在指定的基础包中执行扫描基础包下的所有符合条件的class 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 在指定的基础包中执行扫描基础包下的所有符合条件的class * * Perform a scan within the specified base packages, * returning the registered bean definitions. * &lt;p&gt;This method does &lt;i&gt;not&lt;/i&gt; register an annotation config processor * but rather leaves this up to the caller. * @param basePackages the packages to check for annotated classes * @return set of beans registered if any for tooling registration purposes (never &#123;@code null&#125;) */protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; // base-package属性必须要有 Assert.notEmpty(basePackages, \"At least one base package must be specified\"); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); // 对每个基础包都进行扫描寻找并且对基础包下的所有符合条件的class注册为BeanDefinition for (String basePackage : basePackages) &#123; // 核心方法 并对得到的candidates集合进行过滤，此处便用到include-filters和exclude-filters Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; // 设置lazy-init/autowire-code默认属性，从spring配置的&lt;beans&gt;节点属性读取 postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; // 读取bean上的注解，比如`@Lazy`、`@Dependson`的值设置相应的属性 AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate); &#125; // 查看是否已注册 if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); // 默认采取cglib来做代理 definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); // 注册bean信息到工厂中 registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions;&#125; findCandidateComponents(String basePackage)方法可以看到是遍历了class文件，一个个找符合条件的class并构造成BeanDefinition对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Scan the class path for candidate components. * @param basePackage the package to check for annotated classes * @return a corresponding Set of autodetected bean definitions */public Set&lt;BeanDefinition&gt; findCandidateComponents(String basePackage) &#123; Set&lt;BeanDefinition&gt; candidates = new LinkedHashSet&lt;BeanDefinition&gt;(); try &#123; String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resolveBasePackage(basePackage) + '/' + this.resourcePattern; Resource[] resources = this.resourcePatternResolver.getResources(packageSearchPath); boolean traceEnabled = logger.isTraceEnabled(); boolean debugEnabled = logger.isDebugEnabled(); // 遍历class文件 for (Resource resource : resources) &#123; if (traceEnabled) &#123; logger.trace(\"Scanning \" + resource); &#125; if (resource.isReadable()) &#123; try &#123; MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(resource); // 这里进行匹配 if (isCandidateComponent(metadataReader)) &#123; ScannedGenericBeanDefinition sbd = new ScannedGenericBeanDefinition(metadataReader); sbd.setResource(resource); sbd.setSource(resource); if (isCandidateComponent(sbd)) &#123; if (debugEnabled) &#123; logger.debug(\"Identified candidate component class: \" + resource); &#125; candidates.add(sbd); &#125; else &#123; if (debugEnabled) &#123; logger.debug(\"Ignored because not a concrete top-level class: \" + resource); &#125; &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not matching any filter: \" + resource); &#125; &#125; &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException( \"Failed to read candidate component class: \" + resource, ex); &#125; &#125; else &#123; if (traceEnabled) &#123; logger.trace(\"Ignored because not readable: \" + resource); &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(\"I/O failure during classpath scanning\", ex); &#125; return candidates;&#125; isCandidateComponent(MetadataReader metadataReader) 方法就是进行匹配的主体方法，上面默认注册的this.includeFilters就派上作用了 123456789101112131415161718192021/** * Determine whether the given class does not match any exclude filter * and does match at least one include filter. * @param metadataReader the ASM ClassReader for the class * @return whether the class qualifies as a candidate component */protected boolean isCandidateComponent(MetadataReader metadataReader) throws IOException &#123; for (TypeFilter tf : this.excludeFilters) &#123; // 排除过滤器 if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return false; &#125; &#125; for (TypeFilter tf : this.includeFilters) &#123; // 筛选过滤器 if (tf.match(metadataReader, this.metadataReaderFactory)) &#123; return isConditionMatch(metadataReader); &#125; &#125; return false;&#125; 获得BeanDefinition之后就是通过registerBeanDefinition(definitionHolder, this.registry);注册，和之前默认标签的BeanDefinition的注册调用的是同一个方法 1234567891011121314151617181920212223/** * Register the given bean definition with the given bean factory. * @param definitionHolder the bean definition including name and aliases * @param registry the bean factory to register with * @throws BeanDefinitionStoreException if registration failed */public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; // Register bean definition under primary name. 使用beanName做唯一标识注册 String beanName = definitionHolder.getBeanName(); // 核心代码 registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. 注册所有的别名 String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; 回到registerComponents(parserContext.getReaderContext(), beanDefinitions, element);，此处的目的主要是注册多个BeanPostProcessor接口实现类，供后续Spring调用统一接口进行解析 1234567891011121314151617181920212223242526272829protected void registerComponents(XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element) &#123; Object source = readerContext.extractSource(element); // 包装为CompositeComponentDefinition对象，内置多ComponentDefinition对象 CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), source); // 将已注册的所有beanDefinitionHolder对象放到上述对象中 for (BeanDefinitionHolder beanDefHolder : beanDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(beanDefHolder)); &#125; // Register annotation config processors, if necessary. boolean annotationConfig = true; // 获取annotation-config的属性值，默认为true if (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) &#123; annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE)); &#125; if (annotationConfig) &#123; // 注册多个BeanPostProcessor接口，具体什么可自行查看，返回的是包含BeanPostProcessor接口的beanDefinitionHolder对象集合 // 我们的@Autowired注解解析类AutowiredAnnotationBeanPostProcessor就是在这里默认导入的 Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source); // 继续装入CompositeComponentDefinition对象 for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; compositeDef.addNestedComponent(new BeanComponentDefinition(processorDefinition)); &#125; &#125; readerContext.fireComponentRegistered(compositeDef);&#125; 关注registerAnnotationConfigProcessors(BeanDefinitionRegistry registry, Object source)方法，可以看到默认注册了一些我们常用注解的解析器 ConfigurationClassPostProcessor解析@Configuration注解类 AutowiredAnnotationBeanPostProcessor解析@Autowired/@Value注解 RequiredAnnotationBeanPostProcessor解析@Required注解 CommonAnnotationBeanPostProcessor解析@PostConstruct @PreDestroy @Resource注解 PersistenceAnnotationBeanPostProcessor解析JPA注解，持久层123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Register all relevant annotation post processors in the given registry. * @param registry the registry to operate on * @param source the configuration source element (already extracted) * that this registration was triggered from. May be &#123;@code null&#125;. * @return a Set of BeanDefinitionHolders, containing all bean definitions * that have actually been registered by this call */public static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); if (beanFactory != null) &#123; if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123; beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE); &#125; if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123; beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); &#125; &#125; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); // 注册@Configuration`解析类 if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // 注册`@Autowired/@Value`解析类 if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // 注册`@Required`解析类 if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. // 注册@PostConstruct @PreDestroy @Resource 及JSR-250支持注解解析类 if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. // 注册JPA注解解析类 if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); try &#123; def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( \"Cannot load optional framework class: \" + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex); &#125; def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME)); &#125; return beanDefs;&#125; 总结 回顾上一章节中XmlBeanDefinitionReader的总体功能是 XML Resource =&gt; XML Document =&gt; Bean Definition 的转化过程。由Resource得到Document对象，再由Document对象得到BeanDefinition对象，本章的BeanDefinitionDocumentReader对象就是替XmlBeanDefinitionReader完成XML Document =&gt; Bean Definition的功能 XML Document标签的解析分为默认标签的解析及自定义标签解析，默认标签的解析主要是通过BeanDefinitionParserDelegate类来实现，默认标签的解析比较固定所以直接是一个解析类就能完成，而自定义标签的实现是通过绑定NamespaceHandler的方式来实现,针对每个命名空间下的元素提供不同BeanDefinitionParser来实现，可以看到Spring考虑的十分全面 ComponentScanBeanDefinitionParser这个类是&lt;context:component-scan base-package = &quot;org.springiframe.*&quot;/&gt;这个标签的实现类，用于解析该包下所有的bean注册为beanDefinition参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(四)BeanDefinition读取器XmlBeanDefinitionReader","slug":"backend/framework/spring/analysis/Spring系列(四)BeanDefinition读取器XmlBeanDefinitionReader","date":"2019-06-09T07:00:46.000Z","updated":"2019-06-12T15:15:34.292Z","comments":true,"path":"2019/06/09/backend/framework/spring/analysis/Spring系列(四)BeanDefinition读取器XmlBeanDefinitionReader/","link":"","permalink":"http://www.songshuiyang.site/2019/06/09/backend/framework/spring/analysis/Spring系列(四)BeanDefinition读取器XmlBeanDefinitionReader/","excerpt":"","text":"前言 上一章节介绍了Resource的获取，这一章节来介绍BeanDefinitionReader功能， 它的作用是读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中； 下图是Spring容器从加载配置文件到创建一个完整Bean的作业流程及参与的角色 BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据结构：BeanDefinition 。 在 IoC 容器内部维护着一个 BeanDefinition Map 的数据结构 在配置文件中每一个 都对应着一个 BeanDefinition 对象。 向 IoC 容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口来实现的。在 IoC 容器内部其实是将第二个过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition 的。 在这里需要注意的一点是这个过程并没有完成依赖注入（Bean 创建），Bean 创建是发生在应用第一次调用 #getBean(…) 方法，向容器索要 Bean 时。 当然我们可以通过设置预处理，即对某个 Bean 设置 lazyinit = false 属性，那么这个 Bean 的依赖注入就会在容器初始化的时候完成。 解析 XmlBeanDefinitionReader的继承结构比较简单，上面就一个顶级接口及一个默认抽象实现类，还有个获取Environment的接口 BeanDefinitionReader 顶级接口，关注loadBeanDefinitions方法，这些是定义解析BeanDefinitions的方法，可以看到支持Resource资源类型的解析，还支持location指定文件路径资源的解析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * 主要定义了资源文件读取并转换为BeanDefinition的各个功能 * * Simple interface for bean definition readers. * Specifies load methods with Resource and String location parameters. * * &lt;p&gt;Concrete bean definition readers can of course add additional * load and register methods for bean definitions, specific to * their bean definition format. * * &lt;p&gt;Note that a bean definition reader does not have to implement * this interface. It only serves as suggestion for bean definition * readers that want to follow standard naming conventions. * * @author Juergen Hoeller * @since 1.1 * @see org.springframework.core.io.Resource */public interface BeanDefinitionReader &#123; /** * Return the bean factory to register the bean definitions with. * &lt;p&gt;The factory is exposed through the BeanDefinitionRegistry interface, * encapsulating the methods that are relevant for bean definition handling. */ BeanDefinitionRegistry getRegistry(); /** * Return the resource loader to use for resource locations. * Can be checked for the &lt;b&gt;ResourcePatternResolver&lt;/b&gt; interface and cast * accordingly, for loading multiple resources for a given resource pattern. * &lt;p&gt;Null suggests that absolute resource loading is not available * for this bean definition reader. * &lt;p&gt;This is mainly meant to be used for importing further resources * from within a bean definition resource, for example via the \"import\" * tag in XML bean definitions. It is recommended, however, to apply * such imports relative to the defining resource; only explicit full * resource locations will trigger absolute resource loading. * &lt;p&gt;There is also a &#123;@code loadBeanDefinitions(String)&#125; method available, * for loading bean definitions from a resource location (or location pattern). * This is a convenience to avoid explicit ResourceLoader handling. * @see #loadBeanDefinitions(String) * @see org.springframework.core.io.support.ResourcePatternResolver */ ResourceLoader getResourceLoader(); /** * Return the class loader to use for bean classes. * &lt;p&gt;&#123;@code null&#125; suggests to not load bean classes eagerly * but rather to just register bean definitions with class names, * with the corresponding Classes to be resolved later (or never). */ ClassLoader getBeanClassLoader(); /** * Return the BeanNameGenerator to use for anonymous beans * (without explicit bean name specified). */ BeanNameGenerator getBeanNameGenerator(); /** * Load bean definitions from the specified resource. * @param resource the resource descriptor * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors */ int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException; /** * Load bean definitions from the specified resources. * @param resources the resource descriptors * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors */ int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException; /** * Load bean definitions from the specified resource location. * &lt;p&gt;The location can also be a location pattern, provided that the * ResourceLoader of this bean definition reader is a ResourcePatternResolver. * @param location the resource location, to be loaded with the ResourceLoader * (or ResourcePatternResolver) of this bean definition reader * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors * @see #getResourceLoader() * @see #loadBeanDefinitions(org.springframework.core.io.Resource) * @see #loadBeanDefinitions(org.springframework.core.io.Resource[]) */ int loadBeanDefinitions(String location) throws BeanDefinitionStoreException; /** * Load bean definitions from the specified resource locations. * @param locations the resource locations, to be loaded with the ResourceLoader * (or ResourcePatternResolver) of this bean definition reader * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors */ int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;&#125; AbstractBeanDefinitionReader 抽象类是BeanDefinitionReader接口的默认抽象实现，关注private final BeanDefinitionRegistry registry;属性，上一章节介绍的DefaultListableBeanFactory类型的beanFactory就是存放在这，之后解析后的BeanDefinition也是存放在这 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * BeanDefinitionReader的抽象实现 * 对 EnvironmentCapable、BeanDefinitionReader定义的功能进行实现 * * Abstract base class for bean definition readers which implement * the &#123;@link BeanDefinitionReader&#125; interface. * * &lt;p&gt;Provides common properties like the bean factory to work on * and the class loader to use for loading bean classes. * * @author Juergen Hoeller * @author Chris Beams * @since 11.12.2003 * @see BeanDefinitionReaderUtils */public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader &#123; /** Logger available to subclasses */ protected final Log logger = LogFactory.getLog(getClass()); private final BeanDefinitionRegistry registry; private ResourceLoader resourceLoader; private ClassLoader beanClassLoader; private Environment environment; private BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator(); /** * Create a new AbstractBeanDefinitionReader for the given bean factory. * &lt;p&gt;If the passed-in bean factory does not only implement the BeanDefinitionRegistry * interface but also the ResourceLoader interface, it will be used as default * ResourceLoader as well. This will usually be the case for * &#123;@link org.springframework.context.ApplicationContext&#125; implementations. * &lt;p&gt;If given a plain BeanDefinitionRegistry, the default ResourceLoader will be a * &#123;@link org.springframework.core.io.support.PathMatchingResourcePatternResolver&#125;. * &lt;p&gt;If the passed-in bean factory also implements &#123;@link EnvironmentCapable&#125; its * environment will be used by this reader. Otherwise, the reader will initialize and * use a &#123;@link StandardEnvironment&#125;. All ApplicationContext implementations are * EnvironmentCapable, while normal BeanFactory implementations are not. * @param registry the BeanFactory to load bean definitions into, * in the form of a BeanDefinitionRegistry * @see #setResourceLoader * @see #setEnvironment */ protected AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) &#123; Assert.notNull(registry, \"BeanDefinitionRegistry must not be null\"); this.registry = registry; // Determine ResourceLoader to use. if (this.registry instanceof ResourceLoader) &#123; this.resourceLoader = (ResourceLoader) this.registry; &#125; else &#123; this.resourceLoader = new PathMatchingResourcePatternResolver(); &#125; // Inherit Environment if possible if (this.registry instanceof EnvironmentCapable) &#123; this.environment = ((EnvironmentCapable) this.registry).getEnvironment(); &#125; else &#123; this.environment = new StandardEnvironment(); &#125; &#125; XmlBeanDefinitionReader.java 可以看到就一个构造方法public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) 我们之前构造的DefaultListableBeanFactory是实现了BeanDefinitionRegistry这个接口的，这个接口定义了对 BeanDefinition 的各种增删改查方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * 用于XML bean定义的Bean定义读取器。 * * Bean definition reader for XML bean definitions. * Delegates the actual XML document reading to an implementation * of the &#123;@link BeanDefinitionDocumentReader&#125; interface. * * &lt;p&gt;Typically applied to a * &#123;@link org.springframework.beans.factory.support.DefaultListableBeanFactory&#125; * or a &#123;@link org.springframework.context.support.GenericApplicationContext&#125;. * * &lt;p&gt;This class loads a DOM document and applies the BeanDefinitionDocumentReader to it. * The document reader will register each bean definition with the given bean factory, * talking to the latter's implementation of the * &#123;@link org.springframework.beans.factory.support.BeanDefinitionRegistry&#125; interface. * * @author Juergen Hoeller * @author Rob Harrop * @author Chris Beams * @since 26.11.2003 * @see #setDocumentReaderClass * @see BeanDefinitionDocumentReader * @see DefaultBeanDefinitionDocumentReader * @see BeanDefinitionRegistry * @see org.springframework.beans.factory.support.DefaultListableBeanFactory * @see org.springframework.context.support.GenericApplicationContext */public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader &#123; /** * Indicates that the validation should be disabled. */ public static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE; /** * Indicates that the validation mode should be detected automatically. */ public static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO; /** * Indicates that DTD validation should be used. */ public static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD; /** * Indicates that XSD validation should be used. */ public static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD; /** Constants instance for this class */ private static final Constants constants = new Constants(XmlBeanDefinitionReader.class); private int validationMode = VALIDATION_AUTO; private boolean namespaceAware = false; private Class&lt;?&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.class; private ProblemReporter problemReporter = new FailFastProblemReporter(); private ReaderEventListener eventListener = new EmptyReaderEventListener(); private SourceExtractor sourceExtractor = new NullSourceExtractor(); private NamespaceHandlerResolver namespaceHandlerResolver; private DocumentLoader documentLoader = new DefaultDocumentLoader(); /** * 解析XML,SAX首先会读取xml文档上的声明，根据声明去寻找相应的DTD定义，以便对文档进行一个验证， * 默认的寻找规则即通过网络，通过网络的话有可能出现网络中断或不可用的情况，所以提供该接口来实 * 现寻找DTD声明的过程，可以把这个文件放到项目中，这样就可以避免网络出错而导致无法启动项目的情况 */ private EntityResolver entityResolver; private ErrorHandler errorHandler = new SimpleSaxErrorHandler(logger); private final XmlValidationModeDetector validationModeDetector = new XmlValidationModeDetector(); private final ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded = new NamedThreadLocal&lt;Set&lt;EncodedResource&gt;&gt;(\"XML bean definition resources currently being loaded\"); /** * Create new XmlBeanDefinitionReader for the given bean factory. * @param registry the BeanFactory to load bean definitions into, * in the form of a BeanDefinitionRegistry */ public XmlBeanDefinitionReader(BeanDefinitionRegistry registry) &#123; super(registry); &#125; 代码跟进 上一章节介绍了 Resource[] resources 的获取，得到resources之后就是调用loadBeanDefinitions(resources);方法了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Load bean definitions from the specified resource location. * &lt;p&gt;The location can also be a location pattern, provided that the * ResourceLoader of this bean definition reader is a ResourcePatternResolver. * @param location the resource location, to be loaded with the ResourceLoader * (or ResourcePatternResolver) of this bean definition reader * @param actualResources a Set to be filled with the actual Resource objects * that have been resolved during the loading process. May be &#123;@code null&#125; * to indicate that the caller is not interested in those Resource objects. * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors * @see #getResourceLoader() * @see #loadBeanDefinitions(org.springframework.core.io.Resource) * @see #loadBeanDefinitions(org.springframework.core.io.Resource[]) */public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; throw new BeanDefinitionStoreException( \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\"); &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); // 解析BeanDefinition int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\"); &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\"); &#125; return loadCount; &#125;&#125; loadBeanDefinitions(Resource resource)是XmlBeanDefinitionReader类的方法 1234567891011/** * Load bean definitions from the specified XML file. * @param resource the resource descriptor for the XML file * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors */@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; // 对参数使用EncodedResource类进行封装，对资源文件的编码进行处理，考虑到Resource可能存在编码要求的情况 return loadBeanDefinitions(new EncodedResource(resource));&#125; 再跟进loadBeanDefinitions(new EncodedResource(resource));，可以看到我们熟悉的代码InputStream inputStream = encodedResource.getResource().getInputStream(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Load bean definitions from the specified XML file. * @param encodedResource the resource descriptor for the XML file, * allowing to specify an encoding to use for parsing the file * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors */public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); &#125; // 通过属性来记录已经加载的资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); &#125; try &#123; // 获取输入流 InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; // 构造 InputSource ，此类不是Spring的类 InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 逻辑核心部分 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( \"IOException parsing XML document from \" + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125; 进入核心代码doLoadBeanDefinitions(inputSource, encodedResource.getResource());，下面的方法得到了Document doc 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Actually load bean definitions from the specified XML file. * @param inputSource the SAX InputSource to read from * @param resource the resource descriptor for the XML file * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors * @see #doLoadDocument * @see #registerBeanDefinitions */protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; // 加载XML文件得到Document Document doc = doLoadDocument(inputSource, resource); // 根据得到的Document注册Bean信息 return registerBeanDefinitions(doc, resource); &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"Line \" + ex.getLineNumber() + \" in XML document from \" + resource + \" is invalid\", ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"XML document from \" + resource + \" is invalid\", ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"Parser configuration exception parsing XML from \" + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"IOException parsing XML document from \" + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"Unexpected exception parsing XML document from \" + resource, ex); &#125;&#125; 进入doLoadDocument(inputSource, resource);方法，此方法完成了 XML Resource =&gt; XML Document 的转化过程 12345678910111213141516171819/** * Actually load the specified document using the configured DocumentLoader. * @param inputSource the SAX InputSource to read from * @param resource the resource descriptor for the XML file * @return the DOM Document * @throws Exception when thrown from the DocumentLoader * @see #setDocumentLoader * @see DocumentLoader#loadDocument */protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123; /** * 委托了DocumentLoader来加载Document，具体实现: * @see DefaultDocumentLoader#loadDocument(org.xml.sax.InputSource, org.xml.sax.EntityResolver, org.xml.sax.ErrorHandler, int, boolean) * * getValidationModeForResource方法来获取对应资源的验证模式 */ return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; getEntityResolver() 方法，返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器。 何为EntityResolver？官网这样解释：如果 SAX 应用程序需要实现自定义处理外部实体，则必须实现此接口并使用 setEntityResolver 方法向SAX 驱动器注册一个实例。也就是说，对于解析一个XML，SAX 首先读取该 XML 文档上的声明，根据声明去寻找相应的 DTD 定义，以便对文档进行一个验证。默认的寻找规则，即通过网络（实现上就是声明的DTD的URI地址）来下载相应的DTD声明，并进行认证。下载的过程是一个漫长的过程，而且当网络中断或不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。 EntityResolver 的作用是项目本身就可以提供一个如何寻找 DTD 声明的方法，即由程序来实现寻找 DTD 声明的过程，比如我们将 DTD 文件放到项目中某处，在实现时直接将此文档读取并返回给 SAX 即可。这样就避免了通过网络来寻找相应的声明。 getValidationModeForResource(resource)方法是来获取对应XML资源的验证模式，我们知道XML使用了DTD 与 XSD验证模式保证了 XML 文件的正确性 DTD 与 XSD 的区别 DTD (Document Type Definition)即文档类型 一个DTD文档包含：（1）元素的定义规则；（2）元素间关系的定义规则；（3）元素可使用的属性，可使用的实体或符号规则 .dtd文件，DTD基本语法：&lt;!ELEMENT NAME CONTENT&gt; 123456&lt;!ELEMENT 班级 (学生+)&gt;&lt;!ELEMENT 学生 (名字,年龄,介绍)&gt;&lt;!ELEMENT 名字 (#PCDATA)&gt;&lt;!ELEMENT 年龄 (#PCDATA)&gt;&lt;!ELEMENT 介绍 (#PCDATA)&gt; 使用DTD验证模式需要在XML文件的头部声明 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- 引入dtd文件，约束这个xml --&gt;&lt;!DOCTYPE 班级 SYSTEM \"myclass.dtd\"&gt;&lt;班级&gt; &lt;学生&gt; &lt;名字&gt;周小星&lt;/名字&gt; &lt;年龄&gt;23&lt;/年龄&gt; &lt;介绍&gt;学习刻苦&lt;/介绍&gt; &lt;/学生&gt;&lt;/班级&gt; XSD (XML Schema)描述了XML文档的结构，可以用一个指定的XML Schema来验证某个XML XML Schema的优点: 1) XML Schema基于XML,没有专门的语法 2) XML Schema可以象其他XML文件一样解析和处理 3) XML Schema比DTD提供了更丰富的数据类型. 4) XML Schema提供可扩充的数据模型。 5) XML Schema支持综合命名空间 6) XML Schema支持属性组 XSD定义 1234567891011121314151617&lt;?xml version=\"1.0\"?&gt; &lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"//在schema中用到的数据类型和元素来自此命名空间，并且来自此命名空间的元素以xs开头targetNamespace=\"http://www.w3school.com.cn\"//此shema定义的元素（note等）来自此命名空间xmlns=\"http://www.w3school.com.cn\"//默认的命名空间elementFormDefault=\"qualified\"&gt; &lt;xs:element name=\"note\"&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=\"to\" type=\"xs:string\"/&gt; &lt;xs:element name=\"from\" type=\"xs:string\"/&gt; &lt;xs:element name=\"heading\" type=\"xs:string\"/&gt; &lt;xs:element name=\"body\" type=\"xs:string\"/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt;&lt;/xs:schema&gt; XSD使用 1234567891011&lt;?xml version=\"1.0\"?&gt;&lt;note xmlns=\"http://www.w3school.com.cn\" //默认命名空间xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" //可用的XML SCHEMAL实例命名空间 ---&gt;可以使用schemaLocationxsi:schemaLocation=\"http://www.w3school.com.cn note.xsd\"&gt; //schemaLacation两个属性：需要使用的命名空间 ；供命名空间使用的 XML schema 的位置&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt; registerBeanDefinitions(doc, resource);这行代码完成XML Document =&gt; Bean Definition的转化过程，这里涉及到另一个类BeanDefinitionDocumentReader，所以放到下一个章节介绍 /** * Register the bean definitions contained in the given DOM document. * Called by {@code loadBeanDefinitions}. * &lt;p&gt;Creates a new instance of the parser class and invokes * {@code registerBeanDefinitions} on it. * @param doc the DOM document * @param resource the resource descriptor (for context information) * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of parsing errors * @see #loadBeanDefinitions * @see #setDocumentReaderClass * @see BeanDefinitionDocumentReader#registerBeanDefinitions */ public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException { /** * 使用DefaultBeanDefinitionDocumentReader实例化BeanDefinitionDocumentReader，在实例化BeanDefinitionDocumentReader的时候会将 * * @see DefaultBeanDefinitionDocumentReader * */ BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); // 记录统计前的BeanDefinition的加载个数 int countBefore = getRegistry().getBeanDefinitionCount(); // 加载并注册bean documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; } 总结 XmlBeanDefinitionReader的总体功能是 XML Resource =&gt; XML Document =&gt; Bean Definition 的转化过程。由Resource得到Document对象，再由Document对象得到BeanDefinition对象 参考 https://blog.csdn.net/qq_17037733/article/details/80503560 《Spring 源码深度解析》","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(三)Bean标签BeanDefinition","slug":"backend/framework/spring/analysis/Spring系列(三)Bean标签BeanDefinition","date":"2019-06-08T08:00:46.000Z","updated":"2019-06-12T15:15:34.441Z","comments":true,"path":"2019/06/08/backend/framework/spring/analysis/Spring系列(三)Bean标签BeanDefinition/","link":"","permalink":"http://www.songshuiyang.site/2019/06/08/backend/framework/spring/analysis/Spring系列(三)Bean标签BeanDefinition/","excerpt":"","text":"前言 解析 bean 标签的过程其实就是构造一个 BeanDefinition 对象的过程， 元素标签拥有的配置属性，BeanDefinition 均提供了相应的属性，与之一一对应。所以，我们有必要对 BeanDefinition 先有一个整体的认识。 BeanDefinition 的继承关系图 BeanDefinition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253/** * 配置文件&lt;bean&gt;元素标签在容器中的内部表示形式 * * A BeanDefinition describes a bean instance, which has property values, * constructor argument values, and further information supplied by * concrete implementations. * * &lt;p&gt;This is just a minimal interface: The main intention is to allow a * &#123;@link BeanFactoryPostProcessor&#125; such as &#123;@link PropertyPlaceholderConfigurer&#125; * to introspect and modify property values and other bean metadata. * * @author Juergen Hoeller * @author Rob Harrop * @since 19.03.2004 * @see ConfigurableListableBeanFactory#getBeanDefinition * @see org.springframework.beans.factory.support.RootBeanDefinition * @see org.springframework.beans.factory.support.ChildBeanDefinition */public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123; /** * Scope identifier for the standard singleton scope: \"singleton\". * &lt;p&gt;Note that extended bean factories might support further scopes. * @see #setScope */ String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; /** * Scope identifier for the standard prototype scope: \"prototype\". * &lt;p&gt;Note that extended bean factories might support further scopes. * @see #setScope */ String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; /** * Role hint indicating that a &#123;@code BeanDefinition&#125; is a major part * of the application. Typically corresponds to a user-defined bean. */ int ROLE_APPLICATION = 0; /** * Role hint indicating that a &#123;@code BeanDefinition&#125; is a supporting * part of some larger configuration, typically an outer * &#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;. * &#123;@code SUPPORT&#125; beans are considered important enough to be aware * of when looking more closely at a particular * &#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;, * but not when looking at the overall configuration of an application. */ int ROLE_SUPPORT = 1; /** * Role hint indicating that a &#123;@code BeanDefinition&#125; is providing an * entirely background role and has no relevance to the end-user. This hint is * used when registering beans that are completely part of the internal workings * of a &#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;. */ int ROLE_INFRASTRUCTURE = 2; // Modifiable attributes /** * Set the name of the parent definition of this bean definition, if any. */ void setParentName(String parentName); /** * Return the name of the parent definition of this bean definition, if any. */ String getParentName(); /** * Specify the bean class name of this bean definition. * &lt;p&gt;The class name can be modified during bean factory post-processing, * typically replacing the original class name with a parsed variant of it. * @see #setParentName * @see #setFactoryBeanName * @see #setFactoryMethodName */ void setBeanClassName(String beanClassName); /** * Return the current bean class name of this bean definition. * &lt;p&gt;Note that this does not have to be the actual class name used at runtime, in * case of a child definition overriding/inheriting the class name from its parent. * Also, this may just be the class that a factory method is called on, or it may * even be empty in case of a factory bean reference that a method is called on. * Hence, do &lt;i&gt;not&lt;/i&gt; consider this to be the definitive bean type at runtime but * rather only use it for parsing purposes at the individual bean definition level. * @see #getParentName() * @see #getFactoryBeanName() * @see #getFactoryMethodName() */ String getBeanClassName(); /** * Override the target scope of this bean, specifying a new scope name. * @see #SCOPE_SINGLETON * @see #SCOPE_PROTOTYPE */ void setScope(String scope); /** * Return the name of the current target scope for this bean, * or &#123;@code null&#125; if not known yet. */ String getScope(); /** * Set whether this bean should be lazily initialized. * &lt;p&gt;If &#123;@code false&#125;, the bean will get instantiated on startup by bean * factories that perform eager initialization of singletons. */ void setLazyInit(boolean lazyInit); /** * Return whether this bean should be lazily initialized, i.e. not * eagerly instantiated on startup. Only applicable to a singleton bean. */ boolean isLazyInit(); /** * Set the names of the beans that this bean depends on being initialized. * The bean factory will guarantee that these beans get initialized first. */ void setDependsOn(String... dependsOn); /** * Return the bean names that this bean depends on. */ String[] getDependsOn(); /** * Set whether this bean is a candidate for getting autowired into some other bean. * &lt;p&gt;Note that this flag is designed to only affect type-based autowiring. * It does not affect explicit references by name, which will get resolved even * if the specified bean is not marked as an autowire candidate. As a consequence, * autowiring by name will nevertheless inject a bean if the name matches. */ void setAutowireCandidate(boolean autowireCandidate); /** * Return whether this bean is a candidate for getting autowired into some other bean. */ boolean isAutowireCandidate(); /** * Set whether this bean is a primary autowire candidate. * &lt;p&gt;If this value is &#123;@code true&#125; for exactly one bean among multiple * matching candidates, it will serve as a tie-breaker. */ void setPrimary(boolean primary); /** * Return whether this bean is a primary autowire candidate. */ boolean isPrimary(); /** * Specify the factory bean to use, if any. * This the name of the bean to call the specified factory method on. * @see #setFactoryMethodName */ void setFactoryBeanName(String factoryBeanName); /** * Return the factory bean name, if any. */ String getFactoryBeanName(); /** * Specify a factory method, if any. This method will be invoked with * constructor arguments, or with no arguments if none are specified. * The method will be invoked on the specified factory bean, if any, * or otherwise as a static method on the local bean class. * @see #setFactoryBeanName * @see #setBeanClassName */ void setFactoryMethodName(String factoryMethodName); /** * Return a factory method, if any. */ String getFactoryMethodName(); /** * Return the constructor argument values for this bean. * &lt;p&gt;The returned instance can be modified during bean factory post-processing. * @return the ConstructorArgumentValues object (never &#123;@code null&#125;) */ ConstructorArgumentValues getConstructorArgumentValues(); /** * Return the property values to be applied to a new instance of the bean. * &lt;p&gt;The returned instance can be modified during bean factory post-processing. * @return the MutablePropertyValues object (never &#123;@code null&#125;) */ MutablePropertyValues getPropertyValues(); // Read-only attributes /** * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single, shared instance * returned on all calls. * @see #SCOPE_SINGLETON */ boolean isSingleton(); /** * Return whether this a &lt;b&gt;Prototype&lt;/b&gt;, with an independent instance * returned for each call. * @see #SCOPE_PROTOTYPE */ boolean isPrototype(); /** * Return whether this bean is \"abstract\", that is, not meant to be instantiated. */ boolean isAbstract(); /** * Get the role hint for this &#123;@code BeanDefinition&#125;. The role hint * provides the frameworks as well as tools with an indication of * the role and importance of a particular &#123;@code BeanDefinition&#125;. * @see #ROLE_APPLICATION * @see #ROLE_SUPPORT * @see #ROLE_INFRASTRUCTURE */ int getRole(); /** * Return a human-readable description of this bean definition. */ String getDescription(); /** * Return a description of the resource that this bean definition * came from (for the purpose of showing context in case of errors). */ String getResourceDescription(); /** * Return the originating BeanDefinition, or &#123;@code null&#125; if none. * Allows for retrieving the decorated bean definition, if any. * &lt;p&gt;Note that this method returns the immediate originator. Iterate through the * originator chain to find the original BeanDefinition as defined by the user. */ BeanDefinition getOriginatingBeanDefinition();&#125; BeanDefinition 的父类 BeanDefinition 继承 AttributeAccessor 和 BeanMetadataElement 接口。两个接口定义如下： AttributeAccessor 定义了与其它对象的（元数据）进行连接和访问的约定，即对属性的修改，包括获取、设置、删除。 代码如下：123456789101112131415public interface AttributeAccessor &#123; void setAttribute(String name, @Nullable Object value); @Nullable Object getAttribute(String name); @Nullable Object removeAttribute(String name); boolean hasAttribute(String name); String[] attributeNames();&#125; BeanMetadataElement Bean 元对象持有的配置元素可以通过 #getSource() 方法来获取。 * 代码如下：123456public interface BeanMetadataElement &#123; @Nullable Object getSource();&#125; BeanDefinition 的子类 常用的三个实现类有： 123org.springframework.beans.factory.support.ChildBeanDefinitionorg.springframework.beans.factory.support.RootBeanDefinitionorg.springframework.beans.factory.support.GenericBeanDefinition ChildBeanDefinition、RootBeanDefinition、GenericBeanDefinition 三者都继承 AbstractBeanDefinition 抽象类，即 AbstractBeanDefinition 对三个子类的共同的类信息进行抽象。 AbstractBeanDefinition 是BeanDefinition的抽象基类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/** * BeanDefinition的抽象基类 * * Base class for concrete, full-fledged &#123;@link BeanDefinition&#125; classes, * factoring out common properties of &#123;@link GenericBeanDefinition&#125;, * &#123;@link RootBeanDefinition&#125;, and &#123;@link ChildBeanDefinition&#125;. * * &lt;p&gt;The autowire constants match the ones defined in the * &#123;@link org.springframework.beans.factory.config.AutowireCapableBeanFactory&#125; * interface. * * @author Rod Johnson * @author Juergen Hoeller * @author Rob Harrop * @author Mark Fisher * @see GenericBeanDefinition * @see RootBeanDefinition * @see ChildBeanDefinition */@SuppressWarnings(\"serial\")public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor implements BeanDefinition, Cloneable &#123; /** * Constant for the default scope name: &#123;@code \"\"&#125;, equivalent to singleton * status unless overridden from a parent bean definition (if applicable). */ public static final String SCOPE_DEFAULT = \"\"; /** * Constant that indicates no autowiring at all. * @see #setAutowireMode */ public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO; /** * Constant that indicates autowiring bean properties by name. * @see #setAutowireMode */ public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME; /** * Constant that indicates autowiring bean properties by type. * @see #setAutowireMode */ public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE; /** * Constant that indicates autowiring a constructor. * @see #setAutowireMode */ public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR; /** * Constant that indicates determining an appropriate autowire strategy * through introspection of the bean class. * @see #setAutowireMode * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies, * use annotation-based autowiring for clearer demarcation of autowiring needs. */ @Deprecated public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT; /** * Constant that indicates no dependency check at all. * @see #setDependencyCheck */ public static final int DEPENDENCY_CHECK_NONE = 0; /** * Constant that indicates dependency checking for object references. * @see #setDependencyCheck */ public static final int DEPENDENCY_CHECK_OBJECTS = 1; /** * Constant that indicates dependency checking for \"simple\" properties. * @see #setDependencyCheck * @see org.springframework.beans.BeanUtils#isSimpleProperty */ public static final int DEPENDENCY_CHECK_SIMPLE = 2; /** * Constant that indicates dependency checking for all properties * (object references as well as \"simple\" properties). * @see #setDependencyCheck */ public static final int DEPENDENCY_CHECK_ALL = 3; /** * Constant that indicates the container should attempt to infer the * &#123;@link #setDestroyMethodName destroy method name&#125; for a bean as opposed to * explicit specification of a method name. The value &#123;@value&#125; is specifically * designed to include characters otherwise illegal in a method name, ensuring * no possibility of collisions with legitimately named methods having the same * name. * &lt;p&gt;Currently, the method names detected during destroy method inference * are \"close\" and \"shutdown\", if present on the specific bean class. */ public static final String INFER_METHOD = \"(inferred)\"; private volatile Object beanClass; /** * bean属性scope */ private String scope = SCOPE_DEFAULT; /** * 是否是抽奖 */ private boolean abstractFlag = false; /** * 是否延迟加载 */ private boolean lazyInit = false; /** * 自动注入模式，对应bean属性autowire */ private int autowireMode = AUTOWIRE_NO; /** * 依赖检查 */ private int dependencyCheck = DEPENDENCY_CHECK_NONE; /** * 用来表示一个bean的实例化依靠另一个bean先实例化，对应bean属性depend-on */ private String[] dependsOn; private boolean autowireCandidate = true; /** * 首选bean */ private boolean primary = false; private final Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = new LinkedHashMap&lt;String, AutowireCandidateQualifier&gt;(0); private boolean nonPublicAccessAllowed = true; private boolean lenientConstructorResolution = true; private String factoryBeanName; private String factoryMethodName; private ConstructorArgumentValues constructorArgumentValues; private MutablePropertyValues propertyValues; private MethodOverrides methodOverrides = new MethodOverrides(); private String initMethodName; private String destroyMethodName; private boolean enforceInitMethod = true; private boolean enforceDestroyMethod = true; private boolean synthetic = false; private int role = BeanDefinition.ROLE_APPLICATION; private String description; private Resource resource; /** * Create a new AbstractBeanDefinition with default settings. */ protected AbstractBeanDefinition() &#123; this(null, null); &#125; /** * Create a new AbstractBeanDefinition with the given * constructor argument values and property values. */ protected AbstractBeanDefinition(ConstructorArgumentValues cargs, MutablePropertyValues pvs) &#123; setConstructorArgumentValues(cargs); setPropertyValues(pvs); &#125; /** * Create a new AbstractBeanDefinition as a deep copy of the given * bean definition. * @param original the original bean definition to copy from */ protected AbstractBeanDefinition(BeanDefinition original) &#123; setParentName(original.getParentName()); setBeanClassName(original.getBeanClassName()); setScope(original.getScope()); setAbstract(original.isAbstract()); setLazyInit(original.isLazyInit()); setFactoryBeanName(original.getFactoryBeanName()); setFactoryMethodName(original.getFactoryMethodName()); setConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues())); setPropertyValues(new MutablePropertyValues(original.getPropertyValues())); setRole(original.getRole()); setSource(original.getSource()); copyAttributesFrom(original); if (original instanceof AbstractBeanDefinition) &#123; AbstractBeanDefinition originalAbd = (AbstractBeanDefinition) original; if (originalAbd.hasBeanClass()) &#123; setBeanClass(originalAbd.getBeanClass()); &#125; setAutowireMode(originalAbd.getAutowireMode()); setDependencyCheck(originalAbd.getDependencyCheck()); setDependsOn(originalAbd.getDependsOn()); setAutowireCandidate(originalAbd.isAutowireCandidate()); setPrimary(originalAbd.isPrimary()); copyQualifiersFrom(originalAbd); setNonPublicAccessAllowed(originalAbd.isNonPublicAccessAllowed()); setLenientConstructorResolution(originalAbd.isLenientConstructorResolution()); setMethodOverrides(new MethodOverrides(originalAbd.getMethodOverrides())); setInitMethodName(originalAbd.getInitMethodName()); setEnforceInitMethod(originalAbd.isEnforceInitMethod()); setDestroyMethodName(originalAbd.getDestroyMethodName()); setEnforceDestroyMethod(originalAbd.isEnforceDestroyMethod()); setSynthetic(originalAbd.isSynthetic()); setResource(originalAbd.getResource()); &#125; else &#123; setResourceDescription(original.getResourceDescription()); &#125; &#125; 如果配置文件中定义了父bean 和 子bean ，则父bean用 RootBeanDefinition 表示，子bean用 ChildBeanDefinition 表示，而没有父bean的就使用RootBeanDefinition 表示。 GenericBeanDefinition 为一站式服务类。 BeanDefinition 注册表：BeanDefinitionRegistry 将Bean 的资源文件解析成 BeanDefinition 后需要将其注入容器中，这个过程由 BeanDefinitionRegistry 来完成。 BeanDefinitionRegistry 接口 12345678910111213141516171819202122/** * 定义了对 BeanDefinition 的各种增删改查操作 * Spring bean配置信息的内存数据库，以map的形式保存 * */public interface BeanDefinitionRegistry extends AliasRegistry &#123; void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException; void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; boolean containsBeanDefinition(String beanName); String[] getBeanDefinitionNames(); int getBeanDefinitionCount(); boolean isBeanNameInUse(String beanName);&#125; 下图是 BeanDefinitionRegistry 类结构图 子类 SimpleBeanDefinitionRegistry SimpleBeanDefinitionRegistry 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 对BeanDefinitionRegistry的基本实现，提供了beanDefinitionMap Map作为BeanDefinition的容器 * 下面的方法就是对map的增删改查 * * Simple implementation of the &#123;@link BeanDefinitionRegistry&#125; interface. * Provides registry capabilities only, with no factory capabilities built in. * Can for example be used for testing bean definition readers. * * @author Juergen Hoeller * @since 2.5.2 */public class SimpleBeanDefinitionRegistry extends SimpleAliasRegistry implements BeanDefinitionRegistry &#123; /** Map of bean definition objects, keyed by bean name */ private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(64); @Override public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, \"'beanName' must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); this.beanDefinitionMap.put(beanName, beanDefinition); &#125; @Override public void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException &#123; if (this.beanDefinitionMap.remove(beanName) == null) &#123; throw new NoSuchBeanDefinitionException(beanName); &#125; &#125; @Override public BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException &#123; BeanDefinition bd = this.beanDefinitionMap.get(beanName); if (bd == null) &#123; throw new NoSuchBeanDefinitionException(beanName); &#125; return bd; &#125; @Override public boolean containsBeanDefinition(String beanName) &#123; return this.beanDefinitionMap.containsKey(beanName); &#125; @Override public String[] getBeanDefinitionNames() &#123; return StringUtils.toStringArray(this.beanDefinitionMap.keySet()); &#125; @Override public int getBeanDefinitionCount() &#123; return this.beanDefinitionMap.size(); &#125; @Override public boolean isBeanNameInUse(String beanName) &#123; return isAlias(beanName) || containsBeanDefinition(beanName); &#125;&#125; 总结 类名、scope、属性、构造函数参数列表、依赖的bean、是否是单例类、是否是懒加载等，其实就是将Bean的定义信息存储到这个BeanDefinition相应的属性中，后面对Bean的操作就直接对BeanDefinition进行 拿到这个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。 下面的章节将介绍BeanDefinition的构建 参考 《Spring 源码深度解析》 芋道源码 http://www.iocoder.cn","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(二)装载配置文件Resource","slug":"backend/framework/spring/analysis/Spring系列(二)装载配置文件Resource","date":"2019-05-12T15:00:44.000Z","updated":"2019-06-12T15:15:34.336Z","comments":true,"path":"2019/05/12/backend/framework/spring/analysis/Spring系列(二)装载配置文件Resource/","link":"","permalink":"http://www.songshuiyang.site/2019/05/12/backend/framework/spring/analysis/Spring系列(二)装载配置文件Resource/","excerpt":"","text":"前言 测试类 12345678public class ClassPathXmlApplicationContextTest &#123; @Test public void classPathXmlApplicationContext () &#123; ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\"); User user = xmlApplicationContext.getBean(User.class); &#125;&#125; 关注ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(&quot;beans/bean.xml&quot;); 这行代码可以看到是传入了一个文件的相对路径地址，我们可以猜到里面的逻辑是读取配置文件beans/bean.xml，解析并构造成需要的对象 那么Spring是怎样加载配置文件的呢，本章内容就是介绍Spring的资源加载设计及实现的一些知识，然后再通过断点调试来跟进上面这行代码是怎么实现资源加载的 在学Java SE的时候，我们学习了一个标准类 java.net.URL，该类在 Java SE 中的定位为统一资源定位器（Uniform Resource Locator） 我们知道它的实现基本只限于网络形式发布的资源的查找和定位 然而，实际上资源的定义比较广泛，除了网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等,而且它可以存在于任何场所，比如网络、文件系统、应用程序中 所以 java.net.URL 的局限性迫使 Spring 必须实现自己的资源加载策略 Jdk没有轮子那么Spring自己造 Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。 资源的定义Resource Spring 定义了一个 org.springframework.core.io.Resource 接口，Resource 接口是为了统一各种类型不同的资源而定义的，Spring 提供了若干 Resource 接口的实现类， 由子类 AbstractResource 提供统一的默认实现，这些实现类可以轻松地加载不同类型的底层资源，并提供了获取文件名、URL 地址以及资源内容的操作方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public interface Resource extends InputStreamSource &#123; /** * 资源是否存在 */ boolean exists(); /** * 资源是否可读 */ default boolean isReadable() &#123; return true; &#125; /** * 资源所代表的句柄是否被一个 stream 打开了 */ default boolean isOpen() &#123; return false; &#125; /** * 是否为 File */ default boolean isFile() &#123; return false; &#125; /** * 返回资源的 URL 的句柄 */ URL getURL() throws IOException; /** * 返回资源的 URI 的句柄 */ URI getURI() throws IOException; /** * 返回资源的 File 的句柄 */ File getFile() throws IOException; /** * 返回 ReadableByteChannel */ default ReadableByteChannel readableChannel() throws IOException &#123; return java.nio.channels.Channels.newChannel(getInputStream()); &#125; /** * 资源内容的长度 */ long contentLength() throws IOException; /** * 资源最后的修改时间 */ long lastModified() throws IOException; /** * 根据资源的相对路径创建新资源 */ Resource createRelative(String relativePath) throws IOException; /** * 资源的文件名 */ @Nullable String getFilename(); /** * 资源的描述 */ String getDescription();&#125; Resource 根据资源的不同类型提供不同子类的具体实现，如下: 抽象基类 AbstractResource 这个类是Resource 接口的默认抽象实现，如果我们想自定义Resource，继承该接口重写对应的方法就可以很方便自定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207/** * Convenience base class for &#123;@link Resource&#125; implementations, * pre-implementing typical behavior. * * &lt;p&gt;The \"exists\" method will check whether a File or InputStream can * be opened; \"isOpen\" will always return false; \"getURL\" and \"getFile\" * throw an exception; and \"toString\" will return the description. * * @author Juergen Hoeller * @since 28.12.2003 */public abstract class AbstractResource implements Resource &#123; /** * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流 * * This implementation checks whether a File can be opened, * falling back to whether an InputStream can be opened. * This will cover both directories and content resources. */ @Override public boolean exists() &#123; // Try file existence: can we find the file in the file system? 基于 File 进行判断 try &#123; return getFile().exists(); &#125; catch (IOException ex) &#123; // Fall back to stream existence: can we open the stream? 基于 InputStream 进行判断 try &#123; InputStream is = getInputStream(); is.close(); return true; &#125; catch (Throwable isEx) &#123; return false; &#125; &#125; &#125; /** * 直接返回true，表示可读 * This implementation always returns &#123;@code true&#125;. */ @Override public boolean isReadable() &#123; return true; &#125; /** * 直接返回 false，表示未被打开 * This implementation always returns &#123;@code false&#125;. */ @Override public boolean isOpen() &#123; return false; &#125; /** * 抛出 FileNotFoundException 异常，交给子类实现 * * This implementation throws a FileNotFoundException, assuming * that the resource cannot be resolved to a URL. */ @Override public URL getURL() throws IOException &#123; throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL\"); &#125; /** * 基于 getURL() 返回的 URL 构建 URI * * This implementation builds a URI based on the URL returned * by &#123;@link #getURL()&#125;. */ @Override public URI getURI() throws IOException &#123; URL url = getURL(); try &#123; return ResourceUtils.toURI(url); &#125; catch (URISyntaxException ex) &#123; throw new NestedIOException(\"Invalid URI [\" + url + \"]\", ex); &#125; &#125; /** * 直接返回false，表示不为 File * * This implementation throws a FileNotFoundException, assuming * that the resource cannot be resolved to an absolute file path. */ @Override public File getFile() throws IOException &#123; throw new FileNotFoundException(getDescription() + \" cannot be resolved to absolute file path\"); &#125; /** * 获取资源的长度 * * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断 * * This implementation reads the entire InputStream to calculate the * content length. Subclasses will almost always be able to provide * a more optimal version of this, e.g. checking a File length. * @see #getInputStream() */ @Override public long contentLength() throws IOException &#123; InputStream is = getInputStream(); Assert.state(is != null, \"Resource InputStream must not be null\"); try &#123; long size = 0; byte[] buf = new byte[255]; int read; while ((read = is.read(buf)) != -1) &#123; size += read; &#125; return size; &#125; finally &#123; try &#123; is.close(); &#125; catch (IOException ex) &#123; &#125; &#125; &#125; /** * 返回资源最后的修改时间 * * This implementation checks the timestamp of the underlying File, * if available. * @see #getFileForLastModifiedCheck() */ @Override public long lastModified() throws IOException &#123; long lastModified = getFileForLastModifiedCheck().lastModified(); if (lastModified == 0L) &#123; throw new FileNotFoundException(getDescription() + \" cannot be resolved in the file system for resolving its last-modified timestamp\"); &#125; return lastModified; &#125; /** * Determine the File to use for timestamp checking. * &lt;p&gt;The default implementation delegates to &#123;@link #getFile()&#125;. * @return the File to use for timestamp checking (never &#123;@code null&#125;) * @throws FileNotFoundException if the resource cannot be resolved as * an absolute file path, i.e. is not available in a file system * @throws IOException in case of general resolution/reading failures */ protected File getFileForLastModifiedCheck() throws IOException &#123; return getFile(); &#125; /** * 抛出 FileNotFoundException 异常，交给子类实现 * * This implementation throws a FileNotFoundException, assuming * that relative resources cannot be created for this resource. */ @Override public Resource createRelative(String relativePath) throws IOException &#123; throw new FileNotFoundException(\"Cannot create a relative resource for \" + getDescription()); &#125; /** * 获取资源名称，默认返回 null ，交给子类实现 * * This implementation always returns &#123;@code null&#125;, * assuming that this resource type does not have a filename. */ @Override public String getFilename() &#123; return null; &#125; /** * This implementation returns the description of this resource. * @see #getDescription() */ @Override public String toString() &#123; return getDescription(); &#125; /** * This implementation compares description strings. * @see #getDescription() */ @Override public boolean equals(Object obj) &#123; return (obj == this || (obj instanceof Resource &amp;&amp; ((Resource) obj).getDescription().equals(getDescription()))); &#125; /** * This implementation returns the description's hash code. * @see #getDescription() */ @Override public int hashCode() &#123; return getDescription().hashCode(); &#125; 子类解析 通过 FileSystemResource 以文件系统绝对路径的方式进行访问，对 java.io.File 类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道； 成员变量及构造方法12345678910111213141516public class FileSystemResource extends AbstractResource implements WritableResource &#123; private final File file; private final String path; public FileSystemResource(File file) &#123; Assert.notNull(file, \"File must not be null\"); this.file = file; this.path = StringUtils.cleanPath(file.getPath()); &#125; public FileSystemResource(String path) &#123; Assert.notNull(path, \"Path must not be null\"); this.file = new File(path); this.path = StringUtils.cleanPath(path); &#125; 通过 ByteArrayResource 对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。 成员变量及构造方法1234567891011121314151617public class ByteArrayResource extends AbstractResource &#123; private final byte[] byteArray; private final String description; public ByteArrayResource(byte[] byteArray) &#123; this(byteArray, \"resource loaded from byte array\"); &#125; public ByteArrayResource(byte[] byteArray, String description) &#123; if (byteArray == null) &#123; throw new IllegalArgumentException(\"Byte array must not be null\"); &#125; this.byteArray = byteArray; this.description = (description != null ? description : \"\"); &#125; 通过 UrlResource 对 java.net.URL类型资源的封装。内部委派 URL 进行具体的资源操作。 成员变量及构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UrlResource extends AbstractFileResolvingResource &#123; private final URI uri; private final URL url; private final URL cleanedUrl; public UrlResource(URI uri) throws MalformedURLException &#123; Assert.notNull(uri, \"URI must not be null\"); this.uri = uri; this.url = uri.toURL(); this.cleanedUrl = getCleanedUrl(this.url, uri.toString()); &#125; public UrlResource(URL url) &#123; Assert.notNull(url, \"URL must not be null\"); this.url = url; this.cleanedUrl = getCleanedUrl(this.url, url.toString()); this.uri = null; &#125; public UrlResource(String path) throws MalformedURLException &#123; Assert.notNull(path, \"Path must not be null\"); this.uri = null; this.url = new URL(path); this.cleanedUrl = getCleanedUrl(this.url, path); &#125; public UrlResource(String protocol, String location) throws MalformedURLException &#123; this(protocol, location, null); &#125; public UrlResource(String protocol, String location, String fragment) throws MalformedURLException &#123; try &#123; this.uri = new URI(protocol, location, fragment); this.url = this.uri.toURL(); this.cleanedUrl = getCleanedUrl(this.url, this.uri.toString()); &#125; catch (URISyntaxException ex) &#123; MalformedURLException exToThrow = new MalformedURLException(ex.getMessage()); exToThrow.initCause(ex); throw exToThrow; &#125; &#125; 通过 ClassPathResource 以类路径的方式进行访问,class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。 成员变量及构造方法123456789101112131415161718192021222324252627282930313233public class ClassPathResource extends AbstractFileResolvingResource &#123; private final String path; private ClassLoader classLoader; private Class&lt;?&gt; clazz; public ClassPathResource(String path) &#123; this(path, (ClassLoader) null); &#125; public ClassPathResource(String path, ClassLoader classLoader) &#123; Assert.notNull(path, \"Path must not be null\"); String pathToUse = StringUtils.cleanPath(path); if (pathToUse.startsWith(\"/\")) &#123; pathToUse = pathToUse.substring(1); &#125; this.path = pathToUse; this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader()); &#125; public ClassPathResource(String path, Class&lt;?&gt; clazz) &#123; Assert.notNull(path, \"Path must not be null\"); this.path = StringUtils.cleanPath(path); this.clazz = clazz; &#125; protected ClassPathResource(String path, ClassLoader classLoader, Class&lt;?&gt; clazz) &#123; this.path = StringUtils.cleanPath(path); this.classLoader = classLoader; this.clazz = clazz; &#125; 通过 InputStreamResource 将给定的 InputStream 作为一种资源的 Resource 的实现类。 成员变量及构造方法12345678910111213141516171819public class InputStreamResource extends AbstractResource &#123; private final InputStream inputStream; private final String description; private boolean read = false; public InputStreamResource(InputStream inputStream) &#123; this(inputStream, \"resource loaded through InputStream\"); &#125; public InputStreamResource(InputStream inputStream, String description) &#123; if (inputStream == null) &#123; throw new IllegalArgumentException(\"InputStream must not be null\"); &#125; this.inputStream = inputStream; this.description = (description != null ? description : \"\"); &#125; 通过 ServletContextResource 以相对于 Web 应用根目录的方式进行访问。 成员变量及构造方法12345678910111213141516171819public class ServletContextResource extends AbstractFileResolvingResource implements ContextResource &#123; private final ServletContext servletContext; private final String path; public ServletContextResource(ServletContext servletContext, String path) &#123; // check ServletContext Assert.notNull(servletContext, \"Cannot resolve ServletContextResource without ServletContext\"); this.servletContext = servletContext; // check path Assert.notNull(path, \"Path is required\"); String pathToUse = StringUtils.cleanPath(path); if (!pathToUse.startsWith(\"/\")) &#123; pathToUse = \"/\" + pathToUse; &#125; this.path = pathToUse; &#125; 示例代码 1234567891011121314@Testpublic void createFileSystemResourceByFile() throws Exception &#123; File file = new File(\"D://1.txt\"); FileSystemResource fileSystemResource = new FileSystemResource(file);&#125;@Testpublic void createFileSystemResourceByPath() throws Exception &#123; FileSystemResource fileSystemResource = new FileSystemResource(\"D://1.txt\");&#125;@Testpublic void createClassPathResourceByFile() throws Exception &#123; ClassPathResource classPathResource = new ClassPathResource(\"beans/bean.xml\");&#125; 统一资源定位 ResourceLoader 一开始就说了 Spring 将资源的定义和资源的加载区分开了，Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。 org.springframework.core.io.ResourceLoader 为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器 ,主要应用于根据给定的资源文件地址，返回对应的 Resource 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 定义资源加载器，主要应用于根据给定的资源文件地址返回对应的 Resource * * Strategy interface for loading resources (e.. class path or file system * resources). An &#123;@link org.springframework.context.ApplicationContext&#125; * is required to provide this functionality, plus extended * &#123;@link org.springframework.core.io.support.ResourcePatternResolver&#125; support. * * &lt;p&gt;&#123;@link DefaultResourceLoader&#125; is a standalone implementation that is * usable outside an ApplicationContext, also used by &#123;@link ResourceEditor&#125;. * * &lt;p&gt;Bean properties of type Resource and Resource array can be populated * from Strings when running in an ApplicationContext, using the particular * context's resource loading strategy. * * @author Juergen Hoeller * @since 10.03.2004 * @see Resource * @see org.springframework.core.io.support.ResourcePatternResolver * @see org.springframework.context.ApplicationContext * @see org.springframework.context.ResourceLoaderAware */public interface ResourceLoader &#123; /** Pseudo URL prefix for loading from the class path: \"classpath:\" */ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; /** * 据所提供资源的路径 location 返回 Resource 实例，但是它不确保该 Resource 一定存在，需要调用 Resource#exist() 方法来判断。 * 该方法支持以下模式的资源加载： * URL位置资源，如 \"file:C:/test.dat\" * ClassPath位置资源，如 \"classpath:test.dat\". * 相对路径资源，如 \"WEB-INF/test.dat\" * Return a Resource handle for the specified resource location. * &lt;p&gt;The handle should always be a reusable resource descriptor, * allowing for multiple &#123;@link Resource#getInputStream()&#125; calls. * &lt;p&gt;&lt;ul&gt; * &lt;li&gt;Must support fully qualified URLs, e.g. \"file:C:/test.dat\". * &lt;li&gt;Must support classpath pseudo-URLs, e.g. \"classpath:test.dat\". * &lt;li&gt;Should support relative file paths, e.g. \"WEB-INF/test.dat\". * (This will be implementation-specific, typically provided by an * ApplicationContext implementation.) * &lt;/ul&gt; * &lt;p&gt;Note that a Resource handle does not imply an existing resource; * you need to invoke &#123;@link Resource#exists&#125; to check for existence. * @param location the resource location * @return a corresponding Resource handle (never &#123;@code null&#125;) * @see #CLASSPATH_URL_PREFIX * @see Resource#exists() * @see Resource#getInputStream() */ Resource getResource(String location); /** * 返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用户来说，可以直接调用该方法来获取。 * * Expose the ClassLoader used by this ResourceLoader. * &lt;p&gt;Clients which need to access the ClassLoader directly can do so * in a uniform manner with the ResourceLoader, rather than relying * on the thread context ClassLoader. * @return the ClassLoader (only &#123;@code null&#125; if even the system * ClassLoader isn't accessible) * @see org.springframework.util.ClassUtils#getDefaultClassLoader() */ ClassLoader getClassLoader();&#125; ResourceLoader.java 类继承结构 子类结构 DefaultResourceLoader 与 AbstractResource 相似，org.springframework.core.io.DefaultResourceLoader 是 ResourceLoader 的默认实现。 getResource 方法 ResourceLoader 中最核心的方法为 #getResource(String location) ，它根据提供的 location 返回相应的 Resource 。而 DefaultResourceLoader 对该方法提供了核心实现（因为，它的两个子类都没有提供覆盖该方法，所以可以断定 ResourceLoader 的资源加载策略就封装在 DefaultResourceLoader 中)，12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 可以看到Resource的加载获取是有顺序的，谁先获得就先返回 * 1、首先，通过 ProtocolResolver 来加载资源，为什么要这个呢，它允许用户自定义资源加载协议， * 而不需要继承 ResourceLoader 的子类。ProtocolResolver 接口，仅有一个方法resolve，实现该方法 * 就可以自己实现资源加载， * 2、以 / 开头，返回 ClassPathContextResource 类型的资源 * 3、以 classpath: 开头，返回 ClassPathResource 类型的资源 * 4、加载URL资源文件 * 5、上一步没有找到，抛异常 ，就是返回 ClassPathContextResource 类型的资源 * @param location the resource location * @return */@Overridepublic Resource getResource(String location) &#123; Assert.notNull(location, \"Location must not be null\"); /** * 首先，通过 ProtocolResolver 来加载资源， * @see #protocolResolvers * 调用方法 &#123;@link DefaultResourceLoader#addProtocolResolver(ProtocolResolver)&#125; 即可添加 */ for (ProtocolResolver protocolResolver : this.protocolResolvers) &#123; Resource resource = protocolResolver.resolve(location, this); if (resource != null) &#123; return resource; &#125; &#125; // 其次，以 / 开头，返回 ClassPathContextResource 类型的资源 if (location.startsWith(\"/\")) &#123; return getResourceByPath(location); &#125; // 再次，以 classpath: 开头，返回 ClassPathResource 类型的资源 else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123; return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); &#125; else &#123; // 然后，根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源 try &#123; // Try to parse the location as a URL... URL url = new URL(location); return new UrlResource(url); &#125; catch (MalformedURLException ex) &#123; // No URL -&gt; resolve as resource path. 最后，返回 ClassPathContextResource 类型的资源 return getResourceByPath(location); &#125; &#125;&#125; FileSystemResourceLoader 它继承 DefaultResourceLoader ，且覆写了 #getResourceByPath(String) 方法，使之从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型 ClassRelativeResourceLoader ClassRelativeResourceLoader 扩展的功能是，可以根据给定的class 所在包或者所在包的子包下加载资源。 是 DefaultResourceLoader 的另一个子类的实现。和 FileSystemResourceLoader 类似，在实现代码的结构上类似，也是覆写 #getResourceByPath(String path) 方法，并返回其对应的 ClassRelativeContextResource 的资源类型。 ResourcePatternResolver ResourceLoader 的 Resource getResource(String location) 方法，每次只能根据 location 返回一个 Resource 。当需要加载多个资源时，我们除了多次调用 #getResource(String location) 方法外，别无他法 ResourcePatternResolver 是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回多个 Resource 实例，其定义如下： 123456789101112131415161718192021 public interface ResourcePatternResolver extends ResourceLoader &#123; String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\"; Resource[] getResources(String locationPattern) throws IOException; &#125; ``` * ResourcePatternResolver 在 ResourceLoader 的基础上增加了 #getResources(String locationPattern) 方法，以支持根据路径匹配模式返回多个 Resource 实例。 * 同时，也新增了一种新的协议前缀 \"classpath*:\"，该协议前缀由其子类负责实现。* PathMatchingResourcePatternResolver * 为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的 \"classpath*:\" 前缀外，还支持 Ant 风格的路径匹配模式（类似于 \"**/*.xml\"）。 * getResource() 该方法，直接委托给相应的 ResourceLoader 来实现。所以，如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，如果未指定 ResourceLoader 参数的情况下，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。 ```java @Override public Resource getResource(String location) &#123; return getResourceLoader().getResource(location); &#125; public ResourceLoader getResourceLoader() &#123; return this.resourceLoader; &#125; getResources() 方法，返回的资源是多个 非 “classpath*:” 开头，且路径不包含通配符，直接委托给相应的 ResourceLoader 来实现，只能加载找到的第一个文件 其他情况，调用 #findAllClassPathResources(…)、或 #findPathMatchingResources(…) 方法，返回多个 Resource 使用classpath*:与classpath:加载资源的结果是不一样的，如果有通配符的话更复杂 123456789101112131415161718192021222324252627282930313233343536373839/** * Spring可以通过指定classpath*:与classpath:前缀加路径的方式从classpath加载文件, * 如bean的定义文件.classpath*:的出现是为了从多个jar文件中加载相同的文件，.classpath:只能加载找到的第一个文件. * @param locationPattern the location pattern to resolve * @return * @throws IOException */@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, \"Location pattern must not be null\"); // 以 \"classpath*:\" 开头 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // 路径包含通配符 // a class path resource (multiple resources for same name possible) if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // 路径不包含通配符，该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。 // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; // 不以 \"classpath*:\" 开头 else &#123; // Generally only look for a pattern after a prefix here, // and on Tomcat only after the \"*/\" separator for its \"war:\" protocol. int prefixEnd = (locationPattern.startsWith(\"war:\") ? locationPattern.indexOf(\"*/\") + 1 : locationPattern.indexOf(\":\") + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; 方法讲解 findPathMatchingResources 方法 当 locationPattern 中包含了通配符，则调用该方法进行资源加载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 确定目录，获取该目录下得所有资源。在所获得的所有资源后，进行迭代匹配获取我们想要的资源。 * * Find all resources that match the given location pattern via the * Ant-style PathMatcher. Supports resources in jar files and zip files * and in the file system. * @param locationPattern the location pattern to match * @return the result as Resource array * @throws IOException in case of I/O errors * @see #doFindPathMatchingJarResources * @see #doFindPathMatchingFileResources * @see org.springframework.util.PathMatcher */protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; // 确定根路径、子路径 String rootDirPath = determineRootDir(locationPattern); String subPattern = locationPattern.substring(rootDirPath.length()); // 获取根据路径下的资源 Resource[] rootDirResources = getResources(rootDirPath); // 遍历，迭代 Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); URL rootDirURL = rootDirResource.getURL(); // bundle 资源类型 if (equinoxResolveMethod != null) &#123; if (rootDirURL.getProtocol().startsWith(\"bundle\")) &#123; rootDirURL = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirURL); rootDirResource = new UrlResource(rootDirURL); &#125; &#125; // vfs 资源类型 if (rootDirURL.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirURL, subPattern, getPathMatcher())); &#125; // jar 资源类型 else if (ResourceUtils.isJarURL(rootDirURL) || isJarResource(rootDirResource)) &#123; result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirURL, subPattern)); &#125; // 其它资源类型 else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Resolved location pattern [\" + locationPattern + \"] to resources \" + result); &#125; // 转换成 Resource 数组返回 return result.toArray(new Resource[result.size()]);&#125; findAllClassPathResources 方法 当 locationPattern 以 “classpath*:” 开头但是不包含通配符则调用此方法，该方法返回 classes 路径下和所有 jar 包中的所有相匹配的资源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Find all class location resources with the given location via the ClassLoader. * Delegates to &#123;@link #doFindAllClassPathResources(String)&#125;. * @param location the absolute path within the classpath * @return the result as Resource array * @throws IOException in case of I/O errors * @see java.lang.ClassLoader#getResources * @see #convertClassLoaderURL */protected Resource[] findAllClassPathResources(String location) throws IOException &#123; // 去除首个 / String path = location; if (path.startsWith(\"/\")) &#123; path = path.substring(1); &#125; // 真正执行加载所有 classpath 资源 Set&lt;Resource&gt; result = doFindAllClassPathResources(path); if (logger.isDebugEnabled()) &#123; logger.debug(\"Resolved classpath location [\" + location + \"] to resources \" + result); &#125; // 转换成 Resource 数组返回 return result.toArray(new Resource[result.size()]);&#125;/** * Find all class location resources with the given path via the ClassLoader. * Called by &#123;@link #findAllClassPathResources(String)&#125;. * @param path the absolute path within the classpath (never a leading slash) * @return a mutable Set of matching Resource instances * @since 4.1.1 */protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException &#123; Set&lt;Resource&gt; result = new LinkedHashSet&lt;Resource&gt;(16); ClassLoader cl = getClassLoader(); // 根据 ClassLoader 加载路径下的所有资源 Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path)); while (resourceUrls.hasMoreElements()) &#123; URL url = resourceUrls.nextElement(); // 将 URL 转换成 UrlResource result.add(convertClassLoaderURL(url)); &#125; // &lt;3&gt; 加载路径下得所有 jar 包 if (\"\".equals(path)) &#123; // The above result is likely to be incomplete, i.e. only containing file system references. // We need to have pointers to each of the jar files on the classpath as well... addAllClassLoaderJarRoots(cl, result); &#125; return result;&#125; 通过上面的分析，我们知道 #findAllClassPathResources(…) 方法，其实就是利用 ClassLoader 来加载指定路径下的资源，不论它是在 class 路径下还是在 jar 包中。如果我们传入的路径为空或者 /，则会调用 #addAllClassLoaderJarRoots(…) 方法，加载所有的 jar 包。 处理的流程图: 代码跟进 有了上面的知识储备，我们就知道一些皮毛概念了，下面的内容就是打好断点一步步调试了 关注ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(&quot;beans/bean.xml&quot;); 这行代码可以看到是传入了一个文件的相对路径地址，我们可以猜到里面的逻辑是读取配置文件beans/bean.xml，解析并构造成需要的对象 进入new ClassPathXmlApplicationContext(&quot;beans/bean.xml&quot;)构造方法，可以看到参数是支持数组形式传入的 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Create a new ClassPathXmlApplicationContext, loading the definitions * from the given XML file and automatically refreshing the context. * @param configLocation resource location * @throws BeansException if context creation failed */public ClassPathXmlApplicationContext(String configLocation) throws BeansException &#123; this(new String[] &#123;configLocation&#125;, true, null);&#125;/** * Create a new ClassPathXmlApplicationContext, loading the definitions * from the given XML files and automatically refreshing the context. * @param configLocations array of resource locations * @throws BeansException if context creation failed */public ClassPathXmlApplicationContext(String... configLocations) throws BeansException &#123; this(configLocations, true, null);&#125;/** * Create a new ClassPathXmlApplicationContext with the given parent, * loading the definitions from the given XML files. * @param configLocations array of resource locations * @param refresh whether to automatically refresh the context, * loading all bean definitions and creating all singletons. * Alternatively, call refresh manually after further configuring the context. * @param parent the parent context * @throws BeansException if context creation failed * @see #refresh() */public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); // 可以将配置文件路径以数组的方式传入 setConfigLocations(configLocations); if (refresh) &#123; // 重点 refresh(); &#125;&#125; 进入setConfigLocations方法，可以看到直接解析参数并设置到private String[] configLocations 对象中 1234567891011121314151617/** * Set the config locations for this application context. * &lt;p&gt;If not set, the implementation may use a default as appropriate. */public void setConfigLocations(String... locations) &#123; if (locations != null) &#123; Assert.noNullElements(locations, \"Config locations must not be null\"); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) &#123; // 解析给定的路径 this.configLocations[i] = resolvePath(locations[i]).trim(); &#125; &#125; else &#123; this.configLocations = null; &#125;&#125; 进入refresh()此方法是容器构建的主体方法，以后的章节也是以这个方法为主线，逐步分析Spring 容器构造的过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. // 准备刷新的上下文环境，例如对系统属性或者环境变量进行准备及验证 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. // 初始化BeanFactory，并进行XML文件读取，这一步之后ClassPathXmlApplicationContext实际上就已经包含了BeanFactory所提供的功能 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. // 进入prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开 // 对BeanFactory进行各种功能组件填充 @Qualifier @Autowired这两注解功能组件就是在这步骤中增加的支持 prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. // 子类覆盖方法做额外的处理 postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. // 调用工厂后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanFactoryPostProcessor接口的bean， // 并调用其postProcessBeanFactory接口方法 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. // 注册Bean后处理器 根据反射机制从BeanDefinitionRegistry中找出所有实现了BeanPostProcessor接口的bean， // 并将它们注册到容器Bean后处理器的注册表中，这里只是注册，真正的调用在getBean时候 registerBeanPostProcessors(beanFactory); // Initialize message source for this context. // 初始化消息源 初始化容器的国际化消息资源 initMessageSource(); // Initialize event multicaster for this context. // 初始化应用上下文事件广播器 initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. // 初始化其他特殊的bean，由具体子类实现，这是个钩子方法 onRefresh(); // Check for listener beans and register them. // 注册事件监听器 registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. // 重点：初始化所有单实例的Bean，使用懒加载模式的bean除外，初始化Bean后将它们放到Spring容器的缓冲池中 finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. // 完成刷新并发布容器刷新事件 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 在这里我们关心的是配置文件的装载，所以进入ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); ，此方法的功能是构造BeanFactory 12345678910111213141516/** * Tell the subclass to refresh the internal bean factory. * @return the fresh BeanFactory instance * @see #refreshBeanFactory() * @see #getBeanFactory() */protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; // 刷新BeanFactory 子类实现，创建DefaultListableBeanFactory refreshBeanFactory(); // 将配置文件的信息装入容器Bean定义注册表(BeanDefinitionRegistry)中，Bean未初始化 子类实现 ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory); &#125; return beanFactory;&#125; 关注refreshBeanFactory();方法 ，下面是构造了一个DefaultListableBeanFactory一个默认的BeanFactory然后就是一些赋值操作 12345678910111213141516171819202122232425262728/** * This implementation performs an actual refresh of this context's underlying * bean factory, shutting down the previous bean factory (if any) and * initializing a fresh bean factory for the next phase of the context's lifecycle. */@Overrideprotected final void refreshBeanFactory() throws BeansException &#123; if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; // 创建DefaultListableBeanFactory DefaultListableBeanFactory beanFactory = createBeanFactory(); // 为了序列化指定id，如果需要的话，让这个BeanFactory从id反序列化到BeanFactory对象 beanFactory.setSerializationId(getId()); // 定制beanFactory：设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖 customizeBeanFactory(beanFactory); // 核心方法 初始化DodumentReader，并进行XML文件读取及解析 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); &#125;&#125; 进入核心方法loadBeanDefinitions(beanFactory); 这里传入了构造的DefaultListableBeanFactory，通过下面的代码可以看到是用beanFactory构建了一个XmlBeanDefinitionReader，这里的befaultListableBeanFactory会存放在XmlBeanDefinitionReader的private final BeanDefinitionRegistry registry;属性中，我们的&lt;bean&gt;信息解析后会存放在这，XmlBeanDefinitionReader就是做这个功能 ，这个类将会在下一章节中介绍 1234567891011121314151617181920212223242526/** * Loads the bean definitions via an XmlBeanDefinitionReader. * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader * @see #initBeanDefinitionReader * @see #loadBeanDefinitions */@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. // 为指定beanFactory创建XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. // 对beanDefinitionReader进行环境变量的设置 beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. // 对BeanDefinitionReader进行初始设置，可以被子类覆盖，这里只是设置了一个validationMode值 initBeanDefinitionReader(beanDefinitionReader); // 配置文件的读取 loadBeanDefinitions(beanDefinitionReader);&#125; 我们进入loadBeanDefinitions(beanDefinitionReader);方法，这里是对配置文件的读取，下面的代码看到了我们之前传入的String[] configLocations，得到之后然后使用XmlBeanDefinitionReader解析 12345678910111213141516171819202122/** * Load the bean definitions with the given XmlBeanDefinitionReader. * &lt;p&gt;The lifecycle of the bean factory is handled by the &#123;@link #refreshBeanFactory&#125; * method; hence this method is just supposed to load and/or register bean definitions. * @param reader the XmlBeanDefinitionReader to use * @throws BeansException in case of bean registration errors * @throws IOException if the required XML document isn't found * @see #refreshBeanFactory * @see #getConfigLocations * @see #getResources * @see #getResourcePatternResolver */protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125; 继续跟进到了loadBeanDefinitions(location, null)方法，是不是看到了我们的 Resource[] resources 及 ResourceLoader，看到这里下面的逻辑就是通过ResourceLoader的getResources方法来获取Resource[]了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Load bean definitions from the specified resource location. * &lt;p&gt;The location can also be a location pattern, provided that the * ResourceLoader of this bean definition reader is a ResourcePatternResolver. * @param location the resource location, to be loaded with the ResourceLoader * (or ResourcePatternResolver) of this bean definition reader * @param actualResources a Set to be filled with the actual Resource objects * that have been resolved during the loading process. May be &#123;@code null&#125; * to indicate that the caller is not interested in those Resource objects. * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors * @see #getResourceLoader() * @see #loadBeanDefinitions(org.springframework.core.io.Resource) * @see #loadBeanDefinitions(org.springframework.core.io.Resource[]) */public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException &#123; ResourceLoader resourceLoader = getResourceLoader(); if (resourceLoader == null) &#123; throw new BeanDefinitionStoreException( \"Cannot import bean definitions from location [\" + location + \"]: no ResourceLoader available\"); &#125; if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); // 解析BeanDefinition int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Loaded \" + loadCount + \" bean definitions from location pattern [\" + location + \"]\"); &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Loaded \" + loadCount + \" bean definitions from location [\" + location + \"]\"); &#125; return loadCount; &#125;&#125; 跟进ResourceLoader resourceLoader = getResourceLoader();，因为ClassPathXmlApplicationContext实现了ResourceLoader接口，我们看下ClassPathXmlApplicationContext是怎么实现ResourceLoader接口的，下面重写getResources代码可以看到委托了ResourcePatternResolver类来操作的 getResources() 方法 1234567/** ResourcePatternResolver used by this context */private ResourcePatternResolver resourcePatternResolver;@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; return this.resourcePatternResolver.getResources(locationPattern);&#125; ResourcePatternResolver 是个接口，也是继承自ResourceLoader接口 1234567891011121314151617181920212223public interface ResourcePatternResolver extends ResourceLoader &#123; /** * Pseudo URL prefix for all matching resources from the class path: \"classpath*:\" * This differs from ResourceLoader's classpath URL prefix in that it * retrieves all matching resources for a given name (e.g. \"/beans.xml\"), * for example in the root of all deployed JAR files. * @see org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX */ String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\"; /** * Resolve the given location pattern into Resource objects. * &lt;p&gt;Overlapping resource entries that point to the same physical * resource should be avoided, as far as possible. The result should * have set semantics. * @param locationPattern the location pattern to resolve * @return the corresponding Resource objects * @throws IOException in case of I/O errors */ Resource[] getResources(String locationPattern) throws IOException;&#125; 那ResourcePatternResolver是怎么获得呢，查看resourcePatternResolver引用，可以看到在默认构造函数赋值，下面的代码可以看到直接构造了PathMatchingResourcePatternResolver，没错此类就是我们上面的已经讲解过的 12345678910 /** * Create a new AbstractApplicationContext with no parent. */ public AbstractApplicationContext() &#123; this.resourcePatternResolver = getResourcePatternResolver(); &#125; protected ResourcePatternResolver getResourcePatternResolver() &#123; return new PathMatchingResourcePatternResolver(this);&#125; 到了这里我们的beans/bean.xml配置文件已经通过ResourceLoader获取到了Resource，得到Resource之后就是需要解析了，这个之后的章节会介绍 总结 Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及其定位。使得资源与资源的定位有了一个更加清晰的界限，并且提供了合适的 Default 类，使得自定义实现更加方便和清晰。 Resource接口使资源的定义更广泛，网络形式的资源，还有以二进制形式存在的、以文件形式存在的、以字节流形式存在的等等,而且它可以存在于任何场所，比如网络、文件系统、应用程序中，我们可以选择不同Resource实现类或者自定义Resource从而定义不同的资源 参考 《Spring 源码深度解析》","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring系列(一)为什么要学习Spring","slug":"backend/framework/spring/analysis/Spring系列(一)为什么要学习Spring","date":"2019-05-11T15:02:44.000Z","updated":"2019-06-22T01:36:27.958Z","comments":true,"path":"2019/05/11/backend/framework/spring/analysis/Spring系列(一)为什么要学习Spring/","link":"","permalink":"http://www.songshuiyang.site/2019/05/11/backend/framework/spring/analysis/Spring系列(一)为什么要学习Spring/","excerpt":"","text":"Spring 的宗旨：简化开发 前言 作为一名从事JavaWeb开发方向的程序猿，Spring在项目开发中的地位是十分重要的（仅次于jdk），现在基本上的项目都有使用它，之前的日常开发中对Spring的掌握程度也只是在使用层面上，对其实现的底层不是很清楚，所以特地开此系列博文来记录自己学习Spring的一些笔记及总结 好记性不如烂笔头，Java开发设及的技术太多太杂，有些知识点没有总结记录过了许久又会忘记，所以论笔记的重要性 为什么要阅读源码 站在巨人的肩膀上看世界，看看大佬们是怎么写代码的，一些写代码的模式或者技巧是否可以运用到实际项目中 许多东西不能只停留在使用层面，更要知其所以然，提高自己知识的深度 可以融会贯通，看得越多，知识的互通性的愈发明显，比如一些设计思想，设计模式这些在其他框架也是大量的运用 面试官会问呀 下载并导入源码 源码地址 https://github.com/spring-projects/spring-framework 选择合适的版本 配置gradle环境 详情可见源码父目录下的import-into-idea.md说明文档来将源码导入到IDEA环境中，执行import-into-eclipse.bat脚本将源码可导入至eclipse环境中 导入到IDEA环境中操作步骤 进入 spring-framework 文件夹下，打开cmd，输入 gradlew :spring-oxm:compileTestJava ，spring-oxm 应该预编译，因为它使用重新打包的依赖项，被其他包依赖 排除 spring-aspects 模块 1、Exclude(Go to File-&gt;Project Structure-&gt;Modules) 2、右键unmark as sources root让idea不认为此目录是源代码文件夹，不然此模块不然在本地编译不过 执行gradlew.bat 问题记录 执行gradle命令报错 尝试更换版本，多下几个版本的gradle 执行gradle命令找错误: 找不到或无法加载主类 org.gradle.wrapper.GradleWrapperMain 检查源码目录下是否有 gradle/wrapper/gradle-wrapper.jar，如果没有从其他项目中copy一份 执行gradle命令报taskdef class jdiff.JDiffAntTask cannot be found 注释该文件的下面代码1234ant.taskdef( name: \"jdiff\", classname: \"jdiff.JDiffAntTask\", classpath: \"$&#123;jdiffHome&#125;/antjdiff.jar\") 有些类GroovyBeanDefinitionReader GroovyBeanDefinitionReader编译报错说是找不到 找到对应GroovyBeanDefinitionReader的模块是spring-beans-groovy 然后在找到build.gradle文件将compile(project(&quot;:spring-beans-groovy&quot;))依赖添加到对于报错的模块中 123456789project(\"spring-context\") &#123; description = \"Spring Context\" apply plugin: \"groovy\" dependencies &#123; compile(project(\":spring-aop\")) compile(project(\":spring-beans\")) compile(project(\":spring-beans-groovy\")) 下面的代码是已经可以在idea编译使用的源码文件 https://github.com/songshuiyang/spring-framework-4.3.10.RELEASE ，clone一下按照上面的步骤说明即可在本地调试源码 设置测试类不编译，修改文件build.gradle，不然每次点击方法在哪里调用都会冒出一堆测试类供你选择 12345678910111213141516sourceSets &#123; test &#123; java.srcDirs = ['src/排除test目录'] &#125;&#125;test &#123; systemProperty(\"java.awt.headless\", \"true\") systemProperty(\"testGroups\", project.properties.get(\"testGroups\")) scanForTestClasses = false include([\"**/*Tests.class\", \"**/*Test.class\"]) // Since we set scanForTestClasses to false, we need to filter out inner // classes with the \"$\" pattern; otherwise, using -Dtest.single=MyTests to // run MyTests by itself will fail if MyTests contains any inner classes. exclude '*'&#125; 坚持 这个世界上从来没有一蹴而就的成功，只有经过踏实的努力，点滴的积累，这样机会降临在你头上的时候你才有能力去掌握它 下面的章节将会以最基础的Spring示例代码来学习Spring 4.3.10.RELEASE，下面只有几行代码，但Spring却做了很多逻辑，所以以这几行代码为入口，开始吧 org.springiframe.entity.User.java 1234567891011121314151617181920212223public class User &#123; private String userName; private Integer age; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; beans/bean.xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.springiframe.entity.User\"&gt; &lt;property name=\"userName\" value=\"shop\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 12345678public class ClassPathXmlApplicationContextTest &#123; @Test public void classPathXmlApplicationContext () &#123; ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext(\"beans/bean.xml\"); User user = xmlApplicationContext.getBean(User.class); &#125;&#125; 上面的代码主要是做了几件事 读取配置文件beans/bean.xml 根据配置文件实例化org.springiframe.entity.User.java 实例化完成之后就可以使用该对象了 这些过程看似很简单，但跟入代码查看可以发现Spring还是做了挺多事情的 参考 http://cmsblogs.com/?cat=206 《Spring 源码深度解析》","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"并发多线程(十三)ConcurrentLinkedQueue并发容器","slug":"backend/java/concurrent1/并发多线程(十三)ConcurrentLinkedQueue并发容器","date":"2019-05-02T15:02:44.000Z","updated":"2019-05-13T14:50:08.145Z","comments":true,"path":"2019/05/02/backend/java/concurrent1/并发多线程(十三)ConcurrentLinkedQueue并发容器/","link":"","permalink":"http://www.songshuiyang.site/2019/05/02/backend/java/concurrent1/并发多线程(十三)ConcurrentLinkedQueue并发容器/","excerpt":"","text":"概述 要实现一个线程安全的队列有两种方式：阻塞和非阻塞。阻塞队列无非就是锁的应用，而非阻塞则是CAS算法的应用。下面我们就开始一个非阻塞算法的研究：CoucurrentLinkedQueue。解析 ConcurrentLinkedQueue是一个基于链接节点的无边界的线程安全队列，它采用FIFO原则对元素进行排序。采用“wait-free”算法（即CAS算法）来实现的。 CoucurrentLinkedQueue的结构由head节点和tail节点组成，每个节点由节点元素item和指向下一个节点的next引用组成，而节点与节点之间的关系就是通过该next关联起来的，从而组成一张链表的队列。节点Node为ConcurrentLinkedQueue的内部类，定义如下123456789101112131415161718192021222324252627282930313233343536373839404142434445private static class Node&lt;E&gt; &#123; /** 节点元素域 */ volatile E item; volatile Node&lt;E&gt; next; //初始化,获得item 和 next 的偏移量,为后期的CAS做准备 Node(E item) &#123; UNSAFE.putObject(this, itemOffset, item); &#125; boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; /** 偏移量 */ private static final long itemOffset; /** 下一个元素的偏移量 */ private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"item\")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"next\")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125; &#125; 总结参考 http://www.iocoder.cn/JUC/sike/ConcurrentLinkedQueue/","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"并发多线程(十二)ConcurrentHashMap并发容器","slug":"backend/java/concurrent1/并发多线程(十二)ConcurrentHashMap并发容器","date":"2019-05-02T15:01:44.000Z","updated":"2019-05-13T14:50:08.245Z","comments":true,"path":"2019/05/02/backend/java/concurrent1/并发多线程(十二)ConcurrentHashMap并发容器/","link":"","permalink":"http://www.songshuiyang.site/2019/05/02/backend/java/concurrent1/并发多线程(十二)ConcurrentHashMap并发容器/","excerpt":"","text":"概述 HashMap是我们用得非常频繁的一个集合，但是由于它是非线程安全的，在多线程环境下，put操作是有可能产生死循环的，导致CPU利用率接近100%。为了解决该问题，提供了Hashtable和Collections.synchronizedMap(hashMap)两种解决方案，但是这两种方案都是对读写加锁，独占式，一个线程在读时其他线程必须等待，吞吐量较低，性能较为低下。故而Doug Lea大神给我们提供了高性能的线程安全HashMap：ConcurrentHashMap。 解析ConcurrentHashMap的实现 ConcurrentHashMap作为Concurrent一族，其有着高效地并发操作，相比Hashtable的笨重，ConcurrentHashMap则更胜一筹了。 在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。 我们先用一个示意图来描述下其结构： 结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。 初始化1234567891011// 这构造函数里，什么都不干public ConcurrentHashMap() &#123;&#125;public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap;&#125; put 过程分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public V put(K key, V value) &#123; return putVal(key, value, false);&#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123; // key、value均不能为null if (key == null || value == null) throw new NullPointerException(); // 得到 hash 值 int hash = spread(key.hashCode()); // 用于记录相应链表的长度 int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; // 如果数组\"空\"，进行数组初始化 if (tab == null || (n = tab.length) == 0) // 初始化数组，后面会详细介绍 tab = initTable(); // 找该 hash 值对应的数组下标，得到第一个节点 f else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // 如果数组该位置为空， // 用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了 // 如果 CAS 失败，那就是有并发操作，进到下一个循环就好了 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容 else if ((fh = f.hash) == MOVED) // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了 tab = helpTransfer(tab, f); else &#123; // 到这里就是说，f 是该位置的头结点，而且不为空 V oldVal = null; // 获取数组该位置的头结点的监视器锁 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; // 头结点的 hash 值大于 0，说明是链表 // 用于累加，记录链表的长度 binCount = 1; // 遍历链表 for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; // 如果发现了\"相等\"的 key，判断是否要进行值覆盖，然后也就可以 break 了 if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; // 到了链表的最末端，将这个新值放到链表的最后面 Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; // 红黑树 Node&lt;K,V&gt; p; binCount = 2; // 调用红黑树的插值方法插入新节点 if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // binCount != 0 说明上面在做链表操作 if (binCount != 0) &#123; // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8 if (binCount &gt;= TREEIFY_THRESHOLD) // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换， // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树 // 具体源码我们就不看了，扩容部分后面说 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; // addCount(1L, binCount); return null;&#125; get 过程分析123456789101112131415161718192021222324public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; // 判断头结点是否就是我们需要的节点 if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树 else if (eh &lt; 0) // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k) return (p = e.find(h, key)) != null ? p.val : null; // 遍历链表 while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; get 方法从来都是最简单的，这里也不例外： 计算 hash 值 根据 hash 值找到数组对应位置: (n – 1) &amp; h 根据该位置处结点性质进行相应查找 总结其他 何为同步容器？可以简单地理解为通过 synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。 比如 Vector，Hashtable，以及 Collections#synchronizedSet()，Collections#synchronizedList() 等方法返回的容器。 可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 synchronized 。并发容器，使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性。 例如在 ConcurrentHashMap 中采用了一种粒度更细的加锁机制，可以称为分段锁。在这种锁机制下，允许任意数量的读线程并发地访问 map ，并且执行读操作的线程和写操作的线程也可以并发的访问 map ，同时允许一定数量的写操作线程并发地修改 map ，所以它可以在并发环境下实现更高的吞吐量。 SynchronizedMap 和 ConcurrentHashMap 有什么区别？ SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。 ConcurrentHashMap 使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】 另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。参考 http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/ http://svip.iocoder.cn/Java/Concurrent/Interview/ http://www.importnew.com/28263.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"并发多线程(十一)CompareAndSwap(CAS)","slug":"backend/java/concurrent1/并发多线程(十一)CompareAndSwap(CAS)","date":"2019-05-02T15:00:44.000Z","updated":"2019-05-13T14:50:08.298Z","comments":true,"path":"2019/05/02/backend/java/concurrent1/并发多线程(十一)CompareAndSwap(CAS)/","link":"","permalink":"http://www.songshuiyang.site/2019/05/02/backend/java/concurrent1/并发多线程(十一)CompareAndSwap(CAS)/","excerpt":"","text":"概述 CAS ，Compare And Swap ，即比较并交换。Doug Lea 大神在实现同步组件时，大量使用CAS 技术，鬼斧神工地实现了Java 多线程的并发操作。整个 AQS 同步组件、Atomic 原子类操作等等都是基 CAS 实现的 CAS分析 在 CAS 中有三个参数：内存值 V、旧的预期值 A、要更新的值 B ，当且仅当内存值 V 的值等于旧的预期值 A 时，才会将内存值V的值修改为 B ，否则就再次尝试。其伪代码如下： 123456if (this.value == A) &#123; this.value = B return true;&#125; else &#123; return false;&#125; 这样说或许有些抽象，我们来看一个例子： 1.在内存地址V当中，存储着值为10的变量。 2.此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。 3.在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。 4.线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。 5.线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。 6.这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。 7.线程1进行SWAP，把地址V的值替换为B，也就是12。 * 由于CAS操作属于乐观派，它总认为自己可以成功完成操作，当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作，这点从图中也可以看出来。基于这样的原理，CAS操作即使没有锁，同样知道其他线程对共享资源操作影响，并执行相应的处理措施。 J.U.C 下的 Atomic 类，都是通过 CAS 来实现的。下面就以 AtomicInteger 为例，来阐述 CAS 的实现。如下： 我们就以 AtomicInteger 的 #addAndGet() 方法来做说明，先看源代码： 1234567891011121314// AtomicInteger.javapublic final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta;&#125;// Unsafe.javapublic final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 关注 public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 12 对象 对象的地址 预期值 修改值public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); CPU指令对CAS的支持 或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的， 因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。 鲜为人知的指针: Unsafe类 Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务，关于Unsafe类的主要功能点如下： 内存管理，Unsafe类中存在直接操作内存的方法； 1234567891011121314151617181920212223242526// 分配内存指定大小的内存public native long allocateMemory(long bytes);// 根据给定的内存地址address设置重新分配指定大小的内存public native long reallocateMemory(long address, long bytes);// 用于释放allocateMemory和reallocateMemory申请的内存public native void freeMemory(long address);// 将指定对象的给定offset偏移量内存块中的所有字节设置为固定值public native void setMemory(Object o, long offset, long bytes, byte value);//设置给定内存地址的值public native void putAddress(long address, long x);// 获取指定内存地址的值public native long getAddress(long address);// 设置给定内存地址的long值public native void putLong(long address, long x);// 获取指定内存地址的long值public native long getLong(long address);// 设置或获取指定内存的byte值// 其他基本数据类型(long,char,float,double,short等)的操作与putByte及getByte相同public native byte getByte(long address);public native void putByte(long address, byte x); CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现 12345678//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x); public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x); public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x); CAS缺陷 CAS 虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方面： 循环时间太长 如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋 CAS 长时间地不成功，则会给 CPU 带来非常大的开销。在 J.U.C 中，有些地方就限制了 CAS 自旋的次数，例如： BlockingQueue 的 SynchronousQueue 。 只能保证一个共享变量原子操作 看了 CAS 的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用 CAS 也不错。例如读写锁中 state 的高低位。 ABA 问题 CAS 需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是 A，变成了 B，然后又变成了 A，那么在 CAS 检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于 ABA 问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加 1 ，即 A —&gt; B —&gt; A ，变成1A —&gt; 2B —&gt; 3A 。 总结： 从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。 参考 http://www.iocoder.cn/JUC/sike/CAS/ https://blog.csdn.net/mmoren/article/details/79185862","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"并发多线程(十)Condition","slug":"backend/java/concurrent1/并发多线程(十)Condition","date":"2019-05-02T14:59:44.000Z","updated":"2019-05-13T14:50:08.209Z","comments":true,"path":"2019/05/02/backend/java/concurrent1/并发多线程(十)Condition/","link":"","permalink":"http://www.songshuiyang.site/2019/05/02/backend/java/concurrent1/并发多线程(十)Condition/","excerpt":"","text":"简介 Condition 在没有 Lock 之前，我们使用 synchronized 来控制同步，配合 Object 的 #wait()、#notify() 等一系列方法可以实现等待 / 通知模式。在 Java SE 5 后，Java 提供了 Lock 接口，相对于 synchronized 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活。下图是 Condition 与 Object 的监视器方法的对比（摘自《Java并发编程的艺术》）： java.util.concurrent.locks.Condition 条件 Condition 接口，定义了一系列的方法，来对阻塞和唤醒线程： 12345678910// ========== 阻塞 ==========void await() throws InterruptedException; // 造成当前线程在接到信号或被中断之前一直处于等待状态。void awaitUninterruptibly(); // 造成当前线程在接到信号之前一直处于等待状态。【注意：该方法对中断不敏感】。long awaitNanos(long nanosTimeout) throws InterruptedException; // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。返回值表示剩余时间，如果在`nanosTimeout` 之前唤醒，那么返回值 `= nanosTimeout - 消耗时间` ，如果返回值 `&lt;= 0` ,则可以认定它已经超时了。boolean await(long time, TimeUnit unit) throws InterruptedException; // 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。boolean awaitUntil(Date deadline) throws InterruptedException; // 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。如果没有到指定时间就被通知，则返回 true ，否则表示到了指定时间，返回返回 false 。// ========== 唤醒 ==========void signal(); // 唤醒一个等待线程。该线程从等待方法返回前必须获得与Condition相关的锁。void signalAll(); // 唤醒所有等待线程。能够从等待方法返回的线程必须获得与Condition相关的锁。 Condition是个接口，基本的方法就是await()和signal()方法； Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition() 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用 Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll()。 示例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ConditionTest &#123; final Lock lock = new ReentrantLock(); // 获取的是ConditionObject final Condition condition = lock.newCondition(); public static void main(String[] args) &#123; ConditionTest conditionTest = new ConditionTest(); Consumer consumer = conditionTest.new Consumer(); Producer producer = conditionTest.new Producer(); consumer.start(); producer.start(); &#125; class Consumer extends Thread &#123; @Override public void run() &#123; try &#123; lock.lock(); System.out.println(\"消费者：我在等一个新信号\" + currentThread().getName()); condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(\"消费者：拿到一个信号\" + currentThread().getName()); lock.unlock(); &#125; &#125; &#125; class Producer extends Thread &#123; @Override public void run() &#123; try &#123; lock.lock(); System.out.println(\"生产者：我拿到了锁\" + currentThread().getName()); condition.signalAll(); System.out.println(\"生产者：我发出了一个信号\" + currentThread().getName()); &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 运行结果 1234567\"C:\\Program Files\\Java\\jdk1.7.0_80\\bin\\java\" \"-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2017.2.1\\lib\\idea_rt.jar=54974:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2017.2.1\\bin\" -Dfile.encoding=UTF-8 -classpath \"C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.7.0_80\\jre\\lib\\rt.jar;D:\\workspace-github\\jvm\\target\\production\\jvm\" com.songsy.jdk.concurrent.ConditionTest消费者：我在等一个新信号Thread-0生产者：我拿到了锁Thread-1生产者：我发出了一个信号Thread-1消费者：拿到一个信号Thread-0Process finished with exit code 0 Condition的执行方式，是当在线程Consumer中调用await方法后，线程Consumer将释放锁，并且将自己沉睡，等待唤醒，线程Producer获取到锁后，开始做事，完毕后，调用Condition的signalall方法，唤醒线程Consumer，线程Consumer恢复执行。 以上说明Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一起等待某个条件（Condition）,只有当该条件具备( signal 或者 signalAll方法被带调用)时 ，这些等待线程才会被唤醒，从而重新争夺锁。 ConditionObject 获取一个 Condition 必须要通过 Lock 的 #newCondition() 方法。该方法定义在接口 Lock 下面，返回的结果是绑定到此 Lock 实例的新 Condition 实例。Condition 为一个接口，其下仅有一个实现类 ConditionObject ，由于 Condition 的操作需要获取相关的锁，而 AQS则是同步锁的实现基础，所以 ConditionObject 则定义为 AQS 的内部类。代码如下： 123456789101112131415public class ConditionObject implements Condition, java.io.Serializable &#123; /** * 我们知道一个Condition可以在多个地方被await()，那么就需要一个FIFO的结构将这些Condition串联起来， * 然后根据需要唤醒一个或者多个（通常是所有）。所以在Condition内部就需要一个FIFO的队列。 */ /** First node of condition queue. */ private transient Node firstWaiter; // 头节点 /** Last node of condition queue. */ private transient Node lastWaiter; // 尾节点 public ConditionObject() &#123; &#125; // ... 省略内部代码&#125; 从代码中可以看出ConditionObject 拥有首节点（firstWaiter），尾节点（lastWaiter）。当前线程调用 #await()方法时，将会以当前线程构造成一个节点（Node），并将节点加入到该队列的尾部 Node 里面包含了当前线程的引用。Node 定义与 AQS 的 CLH 同步队列的节点使用的都是同一个类（AbstractQueuedSynchronized 的 Node 静态内部类）。 大体实现流程 AQS等待队列与Condition队列是两个相互独立的队列 await()就是在当前线程持有锁的基础上释放锁资源，并新建Condition节点加入到Condition的队列尾部，阻塞当前线程 signal()就是将Condition的头节点移动到AQS等待节点尾部，让其等待再次获取锁 以下是AQS队列和Condition队列的出入结点的示意图，可以通过这几张图看出线程结点在两个队列中的出入关系和条件。 一：AQS等待队列有3个Node，Condition队列有1个Node(也有可能1个都没有)，节点1执行Condition.await() 1.将head后移 2.释放节点1的锁并从AQS等待队列中移除 3.将节点1加入到Condition的等待队列中 4.更新lastWaiter为节点1 二：节点2执行signal()操作 5.将firstWaiter后移 6.将节点4移出Condition队列 7.将节点4加入到AQS的等待队列中去 8.更新AQS的等待队列的tail await 调用 Condition 的 #await() 方法，会使当前线程进入等待状态，同时会加入到 Condition 等待队列，并且同时释放锁。当从 #await() 方法结束时，当前线程一定是获取了Condition 相关联的锁。 signal 调用 ConditionObject的 #signal() 方法，将会唤醒在等待队列中等待最长时间的节点（条件队列里的首节点），在唤醒节点前，会将节点移到CLH同步队列中。 示例 生产者和消费者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ConsumerProducer &#123; private int storage; private int putCounter; private int getCounter; private Lock lock = new ReentrantLock(); private Condition putCondition = lock.newCondition(); private Condition getCondition = lock.newCondition(); public void put() throws InterruptedException &#123; try &#123; lock.lock(); if (storage &gt; 0) &#123; putCondition.await(); &#125; storage++; System.out.println(\"put =&gt; \" + ++putCounter ); getCondition.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void get() throws InterruptedException &#123; try &#123; lock.lock(); lock.lock(); if (storage &lt;= 0) &#123; getCondition.await(); &#125; storage--; System.out.println(\"get =&gt; \" + ++getCounter); putCondition.signal(); &#125; finally &#123; lock.unlock(); lock.unlock(); &#125; &#125; public class PutThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; put(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; &#125; public class GetThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; get(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; final ConsumerProducer test = new ConsumerProducer(); Thread put = test.new PutThread(); Thread get = test.new GetThread(); put.start(); get.start(); &#125;&#125; 总结： 一个线程获取锁后，通过调用 Condition 的 #await() 方法，会将当前线程先加入到条件队列中，然后释放锁，最后通过 #isOnSyncQueue(Node node) 方法，不断自检看节点是否已经在 CLH 同步队列了，如果是则尝试获取锁，否则一直挂起。 当线程调用 #signal() 方法后，程序首先检查当前线程是否获取了锁，然后通过#doSignal(Node first) 方法唤醒CLH同步队列的首节点。被唤醒的线程，将从 #await() 方法中的 while 循环中退出来，然后调用 #acquireQueued(Node node, int arg) 方法竞争同步状态。 参考 http://www.iocoder.cn/JUC/sike/Condition/ https://blog.csdn.net/coslay/article/details/45217069","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"并发多线程(九)ReadWriteLock与ReentrantReadWriteLock","slug":"backend/java/concurrent1/并发多线程(九)ReadWriteLock与ReentrantReadWriteLock","date":"2019-04-29T14:59:50.000Z","updated":"2019-05-13T14:49:13.555Z","comments":true,"path":"2019/04/29/backend/java/concurrent1/并发多线程(九)ReadWriteLock与ReentrantReadWriteLock/","link":"","permalink":"http://www.songshuiyang.site/2019/04/29/backend/java/concurrent1/并发多线程(九)ReadWriteLock与ReentrantReadWriteLock/","excerpt":"","text":"简介 重入锁 ReentrantLock 是排他锁，排他锁在同一时刻仅有一个线程可以进行访问，但是在大多数场景下，大部分时间都是提供读服务，而写服务占有的时间较少。然而，读服务不存在数据竞争问题，如果一个线程在读时禁止其他线程读势必会导致性能降低。所以就提供了读写锁。 读写锁维护着一对锁，一个读锁和一个写锁。通过分离读锁和写锁，使得并发性比一般的排他锁有了较大的提升： 在同一时间，可以允许多个读线程同时访问。 是，在写线程访问时，所有读线程和写线程都会被阻塞。 读写锁的主要特性： 公平性：支持公平性和非公平性。 重入性：支持重入。读写锁最多支持 65535 个递归写入锁和 65535 个递归读取锁。 锁降级：遵循获取写锁，再获取读锁，最后释放写锁的次序，如此写锁能够降级成为读锁。示例 ReadWriteLock ReadWriteLock也是一个接口，在它里面只定义了两个方法： 123456789101112131415public interface ReadWriteLock &#123; /** * Returns the lock used for reading. * * @return the lock used for reading. */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing. */ Lock writeLock();&#125; 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。 4.ReentrantReadWriteLock ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。 下面通过几个例子来看一下ReentrantReadWriteLock具体用法。 假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果： 12345678910111213141516171819202122232425262728public class Test &#123; private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); &#125; public synchronized void get(Thread thread) &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+\"正在进行读操作\"); &#125; System.out.println(thread.getName()+\"读操作完毕\"); &#125;&#125; 这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0读操作完毕Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1读操作完毕 而改成用读写锁的话： 12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void get(Thread thread) &#123; rwl.readLock().lock(); try &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+\"正在进行读操作\"); &#125; System.out.println(thread.getName()+\"读操作完毕\"); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125;&#125; 此时打印的结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Thread-0正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0读操作完毕Thread-1读操作完毕 说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 四.总结参考转载 https://www.cnblogs.com/dolphin0520/p/3932921.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"并发多线程(八)Reentrantlock重入锁","slug":"backend/java/concurrent1/并发多线程(八)Reentrantlock重入锁","date":"2019-04-29T14:59:48.000Z","updated":"2019-05-13T14:49:13.612Z","comments":true,"path":"2019/04/29/backend/java/concurrent1/并发多线程(八)Reentrantlock重入锁/","link":"","permalink":"http://www.songshuiyang.site/2019/04/29/backend/java/concurrent1/并发多线程(八)Reentrantlock重入锁/","excerpt":"","text":"简介 ReentrantLock，可重入锁，是一种递归无阻塞的同步机制。它可以等同于 synchronized 的使用，但是 ReentrantLock 提供了比 synchronized 更强大、灵活的锁机制，可以减少死锁发生的概率。 一个可重入的互斥锁定 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁定相同的一些基本行为和语义，但功能更强大。 示例 ReentrantLock，意思是“可重入锁”，ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。 lock()的错误使用方法 代码 12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; Lock lock = new ReentrantLock(); //注意这个地方 lock.lock(); try &#123; System.out.println(thread.getName()+\"得到了锁\"); for(int i=0;i&lt;5;i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); &#125; &#125;&#125; 各位朋友先想一下这段代码的输出结果是什么？ 1234Thread-0得到了锁Thread-1得到了锁Thread-0释放了锁Thread-1释放了锁 也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。 知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。 12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); private Lock lock = new ReentrantLock(); //注意这个地方 public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; lock.lock(); try &#123; System.out.println(thread.getName()+\"得到了锁\"); for(int i=0;i&lt;5;i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); &#125; &#125;&#125; 这样就是正确地使用Lock的方法了。 tryLock()的使用方法 代码 12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); private Lock lock = new ReentrantLock(); //注意这个地方 public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; if(lock.tryLock()) &#123; try &#123; System.out.println(thread.getName()+\"得到了锁\"); for(int i=0;i&lt;5;i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); &#125; &#125; else &#123; System.out.println(thread.getName()+\"获取锁失败\"); &#125; &#125;&#125; 输出结果： 123Thread-0得到了锁Thread-1获取锁失败Thread-0释放了锁 lockInterruptibly()响应中断的使用方法： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Test &#123; private Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; Test test = new Test(); MyThread thread1 = new MyThread(test); MyThread thread2 = new MyThread(test); thread1.start(); thread2.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread2.interrupt(); &#125; public void insert(Thread thread) throws InterruptedException&#123; lock.lockInterruptibly(); //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出 try &#123; System.out.println(thread.getName()+\"得到了锁\"); long startTime = System.currentTimeMillis(); for( ; ;) &#123; if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE) break; //插入数据 &#125; &#125; finally &#123; System.out.println(Thread.currentThread().getName()+\"执行finally\"); lock.unlock(); System.out.println(thread.getName()+\"释放了锁\"); &#125; &#125;&#125; class MyThread extends Thread &#123; private Test test = null; public MyThread(Test test) &#123; this.test = test; &#125; @Override public void run() &#123; try &#123; test.insert(Thread.currentThread()); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName()+\"被中断\"); &#125; &#125;&#125; 运行之后，发现thread2能够被正确中断 12Thread-0得到了锁Thread-1被中断 总结 与 synchronized 相比，ReentrantLock提供了更多，更加全面的功能，具备更强的扩展性。例如：时间锁等候，可中断锁等候，锁投票。 ReentrantLock 还提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，ReentrantLock 更加适合（以后会阐述Condition）。 ReentrantLock 提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而 synchronized 则一旦进入锁请求要么成功要么阻塞，所以相比 synchronized 而言，ReentrantLock会不容易产生死锁些。 ReentrantLock 支持更加灵活的同步代码块，但是使用 synchronized 时，只能在同一个 synchronized 块结构中获取和释放。注意，ReentrantLock 的锁释放一定要在 finally 中处理，否则可能会产生严重的后果。 ReentrantLock 支持中断处理，且性能较 synchronized 会好些。 参考转载 http://www.iocoder.cn/JUC/sike/ReentrantLock/","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"并发多线程(七)AbstractQueuedSynchronizer","slug":"backend/java/concurrent1/并发多线程(七)AbstractQueuedSynchronizer","date":"2019-04-29T14:59:44.000Z","updated":"2019-05-13T14:49:13.505Z","comments":true,"path":"2019/04/29/backend/java/concurrent1/并发多线程(七)AbstractQueuedSynchronizer/","link":"","permalink":"http://www.songshuiyang.site/2019/04/29/backend/java/concurrent1/并发多线程(七)AbstractQueuedSynchronizer/","excerpt":"","text":"简介 AbstractQueuedSynchronizer(AQS ) 即队列同步器。它是构建锁或者其他同步组件的基础框架（如 ReentrantLock、ReentrantReadWriteLock、Semaphore 等），它使用了一个int成员变量表示同步状态，通过内置的FIFO队列完成资源获取线程的派对工作 J.U.C 并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是 J.U.C 并发包中的核心基础组件。 优势 AQS 解决了在实现同步器时涉及当的大量细节问题，例如获取同步状态、FIFO 同步队列。基于 AQS 来构建同步器可以带来很多好处。它不仅能够极大地减少实现工作，而且也不必处理在多个位置上发生的竞争问题。 在基于 AQS 构建的同步器中，只能在一个时刻发生阻塞，从而降低上下文切换的开销，提高了吞吐量。同时在设计 AQS 时充分考虑了可伸缩性，因此 J.U.C 中，所有基于 AQS 构建的同步器均可以获得这个优势。 同步状态 AQS 的主要使用方式是继承，子类通过继承同步器，并实现它的抽象方法来管理同步状态。 AQS 使用一个 int 类型的成员变量 state 来表示同步状态： 当 state &gt; 0 时，表示已经获取了锁。 当 state = 0 时，表示释放了锁。 它提供了三个方法，来对同步状态 state 进行操作，并且 AQS 可以确保对 state 的操作是安全的： getState() setState(int newState) compareAndSetState(int expect, int update) 同步队列 AQS 通过内置的 FIFO 同步队列来完成资源获取线程的排队工作： 如果当前线程获取同步状态失败（锁）时，AQS 则会将当前线程以及等待状态等信息构造成一个节点（Node）并将其加入同步队列，同时会阻塞当前线程 当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。 同步器的开始提到了其实现依赖于一个FIFO队列，该队列就是 CLH 同步队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。 Node 是 AbstractQueuedSynchronizer 的内部静态类，Node的主要包含以下成员变量： 属性名称 描述 int waitStatus 表示节点的状态。其中包含的状态有：1. CANCELLED，值为1，由于在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待表示当前的线程被取消；2. SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，将会通知后继节点，使后继节点的线程得以运行；3. CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；4. PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行； 5. 值为0，表示当前节点在sync队列中，等待着获取锁。 Node prev 前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。 Node next 后继节点。 Node nextWaiter 存储condition队列中的后继节点。 Thread thread 入队列时的当前线程。 入列 学了数据结构的我们，CLH 队列入列是再简单不过了 tail 指向新节点。 新节点的 prev 指向当前最后的节点。 当前最后一个节点的 next 指向当前节点。 过程图如下： 实际上，入队逻辑实现的 #addWaiter(Node) 方法，需要考虑并发的情况。它通过 CAS 的方式，来保证正确的添加 Node 。代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Creates and enqueues node for current thread and given mode. * * mode 方法参数，传递获取同步状态的模式。 * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared * @return the new node */private Node addWaiter(Node mode) &#123; // 新建节点 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 记录原尾节点 Node pred = tail; // 快速尝试，添加新节点为尾节点 if (pred != null) &#123; // 设置新 Node 节点的尾节点为原尾节点 node.prev = pred; // CAS 设置新的尾节点 if (compareAndSetTail(pred, node)) &#123; // 成功，原尾节点的下一个节点为新节点 pred.next = node; return node; &#125; &#125; // 失败，多次尝试，直到成功 enq(node); return node;&#125; /** * Inserts node into queue, initializing if necessary. See picture above. * @param node the node to insert * @return node's predecessor */private Node enq(final Node node) &#123; // 死循环，多次尝试，直到成功添加为止 for (;;) &#123; // 记录原尾节点 Node t = tail; // 原尾节点不存在，创建首尾节点都为 new Node() if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 原尾节点存在，添加新节点为尾节点 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 出队 CLH 同步队列遵循 FIFO，首节点的线程释放同步状态后，将会唤醒它的下一个节点（Node.next）。而后继节点将会在获取同步状态成功时，将自己设置为首节点( head )。 这个过程非常简单，head 执行该节点并断开原首节点的 next 和当前节点的 prev 即可。注意，在这个过程是不需要使用 CAS 来保证的，因为只有一个线程，能够成功获取到同步状态。 过程图如下： setHead(Node node) 方法，实现上述的出列逻辑。代码如下：12345private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125; API说明 实现自定义同步器时，需要使用同步器提供的getState()、setState()和compareAndSetState()方法来操纵状态的变迁。 方法名称 描述 getState() 返回同步状态的当前值。 setState(int newState) 设置当前同步状态。 compareAndSetState(int expect, int update) 使用 CAS 设置当前状态，该方法能够保证状态设置的原子性。 protected boolean tryAcquire(int arg) 【可重写】排它的获取这个状态。这个方法的实现需要查询当前状态是否允许获取，然后再进行获取（使用compareAndSetState来做）状态。 protected boolean tryRelease(int arg) 【可重写】释放状态。 protected int tryAcquireShared(int arg) 【可重写】共享的模式下获取状态。 protected boolean tryReleaseShared(int arg) 【可重写】共享的模式下释放状态。 protected boolean isHeldExclusively() 【可重写】在排它模式下，状态是否被占用。 acquire(int arg) 独占式获取同步状态。如果当前线程获取同步状态成功，则由该方法返回；否则，将会进入同步队列等待。该方法将会调用可重写的 #tryAcquire(int arg) 方法； acquireInterruptibly(int arg) 与 acquire(int arg) 相同，但是该方法响应中断。当前线程为获取到同步状态而进入到同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException 异常并返回。 tryAcquireNanos(int arg, long nanos) 超时获取同步状态。如果当前线程在 nanos 时间内没有获取到同步状态，那么将会返回 false ，已经获取则返回 true 。 acquireShared(int arg) 共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态； acquireSharedInterruptibly(int arg) 共享式获取同步状态，响应中断。 tryAcquireSharedNanos(int arg, long nanosTimeout) 共享式获取同步状态，增加超时限制。 release(int arg) 独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。 releaseShared(int arg) 共享式释放同步状态。 同步状态的获取与释放 AQS 的设计模式采用的模板方法模式，子类通过继承的方式，实现它的抽象方法来管理同步状态。对于子类而言，它并没有太多的活要做，AQS 已经提供了大量的模板方法来实现同步，主要是分为三类： 独占式获取和释放同步状态 共享式获取和释放同步状态 查询同步队列中的等待线程情况。 独占式: 同一时刻，仅有一个线程持有同步状态。 共享式: 共享式与独占式的最主要区别在于，同一时刻：1、独占式只能有一个线程获取同步状态。2、共享式可以有多个线程获取同步状态。 总结： 等待队列是FIFO先进先出。 加入同步队列后，并不是立即挂起，而是再次进行获取同步状态, 到挂起之前都是在自旋（无限循环尝试），因为同步状态的变化很快，线程上下文的切换比较耗时，所以用短暂的自旋来换取时间开销，当然如果一直自旋，那么开销反而大于了线程切换。所以把自旋时间（次数）控制在一定范围有利于提高性能。 参考 http://www.iocoder.cn/JUC/sike/aqs-0-intro/ https://blog.csdn.net/u014634338/article/details/77168608","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"并发多线程(六)ThreadLocal","slug":"backend/java/concurrent1/并发多线程(六)ThreadLocal","date":"2019-04-20T14:59:44.000Z","updated":"2019-05-13T14:49:13.628Z","comments":true,"path":"2019/04/20/backend/java/concurrent1/并发多线程(六)ThreadLocal/","link":"","permalink":"http://www.songshuiyang.site/2019/04/20/backend/java/concurrent1/并发多线程(六)ThreadLocal/","excerpt":"","text":"ThreadLocal 作用在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。 如果是你，该如何实现上述功能？常规的思路如下：使用一个线程共享的Map，Map中的key为线程对象，value即为需要存储的值。那么，我们只需要通过map.get(Thread.currentThread())即可获取本线程中该变量的值。 这种方式确实可以实现我们的需求，但它有何缺点呢？——答案就是：需要同步，效率低！ 由于这个map对象需要被所有线程共享，因此需要加锁来保证线程安全性。当然我们可以使用java.util.concurrent.*包下的ConcurrentHashMap提高并发效率，但这种方法只能降低锁的粒度，不能从根本上避免同步锁。而JDK提供的ThreadLocal就能很好地解决这一问题。下面来看看ThreadLocal是如何高效地实现这一需求的。 ThreadLocal 是什么 ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 ThreadLocal 解析 ThreadLocal的内部结构图 threadLocal 从上面的结构图，我们已经窥见ThreadLocal的核心机制： 每个Thread线程内部都有一个Map。 Map里面存储线程本地对象（key）和线程的变量副本（value） 但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 Thread线程内部的Map在类中描述如下:123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal类提供如下几个核心方法： get()方法用于获取当前线程的副本变量值。 set()方法用于保存当前线程的副本变量值。 initialValue()为当前线程初始副本变量值。 remove()方法移除当前前程的副本变量值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 返回当前线程的副本变量 * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); // 返回Thread 对象中的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; // 如果没有值的话调用默认setInitialValue()方法 return setInitialValue();&#125;/** * 存放在Thread的 threadLocals * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;/** * 设置初始值 * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;// map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。protected T initialValue() &#123; return null;&#125;/** * 赋值 * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;/** * Removes the current thread's value for this thread-local * variable. If this thread-local variable is subsequently * &#123;@linkplain #get read&#125; by the current thread, its value will be * reinitialized by invoking its &#123;@link #initialValue&#125; method, * unless its value is &#123;@linkplain #set set&#125; by the current thread * in the interim. This may result in multiple invocations of the * &#123;@code initialValue&#125; method in the current thread. * * @since 1.5 */ public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; ThreadLocalMap ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现:12345678910111213141516171819202122static class ThreadLocalMap &#123; /** * 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象 * * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; // Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。 super(k); value = v; &#125; &#125;&#125; ThreadLocalMap的问题由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。 Java的四种引用方式 Java的数据类型分为两类：基本数据类型、引用数据类型。 基本数据类型的值存储在栈内存中 引用数据类型需要开辟两块存储空间，一块在堆内存中，用于存储该类型的对象；另一块在栈内存中，用于存储堆内存中该对象的引用。 Java对象的引用类型包括: 强引用，软引用，弱引用，虚引用 Java中提供这四种引用类型主要有两个目的： 第一是可以让程序员通过代码的方式决定某些对象的生命周期，随着 java.lang.ref这个包下的类的引进，程序员拥有了一点点控制你创建的对象何时释放，销毁的权利 第二是有利于JVM进行垃圾回收 强引用 强引用，就是我们最常见的普通对象引用，我们 new 出来的对象就是强引用，只要尚且存在强引用指向某一个对象，那就能表明该对象还存活，GC 不能去回收这种对象。需要回收强引用指向的对象，可以等待超出引用区域，或者是显式设置对象为 null，就可以通知让 GC 回收，当然实际的回收时间要看 GC 策略。 12345678910111213public class Main &#123; public static void main(String[] args) &#123; // 创建一个对象，new出来的对象都是分配在java堆中的 Sample sample = new Sample(); // sample这个引用就是强引用 sample = null; // 将这个引用指向空指针, // 那么上面那个刚new来的对象就没用任何其它有效的引用指向它了 // 也就说该对象对于垃圾收集器是符合条件的 // 因此在接下来某个时间点 GC进行收集动作的时候, 该对象将会被销毁，内存被释放 &#125;&#125;class Sample &#123;&#125; 也可以画个简单的图理解一下： 软引用 当内存资源充足的时候，垃圾回收器不会回收软引用对应的对象的内存空间；但当内存资源紧张时，软引用所对应的对象就会被垃圾回收器回收。 软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。 SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。 也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对 这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之 后，get()方法将返回null。 12345678910111213141516171819public class Main &#123; public static void main(String[] args) &#123; // 创建一个对象，new出来的对象都是分配在java堆中的 Sample sample = new Sample(); //sample这个引用就是强引用 // 创建一个软引用指向这个对象 那么此时就有两个引用指向Sample对象 SoftReference&lt;Sample&gt; softRef = new SoftReference&lt;Sample&gt;(sample); // 将强引用指向空指针 那么此时只有一个软引用指向Sample对象 // 注意：softRef这个引用也是强引用，它是指向SoftReference这个对象的 // 那么这个软引用在哪呢？ 可以跟一下java.lang.Reference的源码 // private T referent; 这个才是软引用， 只被jvm使用 sample = null; // 可以重新获得Sample对象，并用一个强引用指向它 sample = softRef.get(); &#125;&#125;class Sample &#123;&#125; 利用软引用解决OOM问题 下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。 示例代码123456789101112131415161718192021222324private Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;();public void addBitmapToCache(String path) &#123; // 强引用的Bitmap对象 Bitmap bitmap = BitmapFactory.decodeFile(path); // 软引用的Bitmap对象 SoftReference&lt;Bitmap&gt; softBitmap = new SoftReference&lt;Bitmap&gt;(bitmap); // 添加该对象到Map中使其缓存 imageCache.put(path, softBitmap);&#125;public Bitmap getBitmapByPath(String path) &#123; // 从缓存中取软引用的Bitmap对象 SoftReference&lt;Bitmap&gt; softBitmap = imageCache.get(path); // 判断是否存在软引用 if (softBitmap == null) &#123; return null; &#125; // 取出Bitmap对象，如果由于内存不足Bitmap被回收，将取得空 Bitmap bitmap = softBitmap.get(); return bitmap;&#125; 弱引用 弱引用会被Jvm忽略，也就说在GC进行垃圾收集的时候，如果一个对象只有弱引用指向它，那么和没有引用指向它是一样的效果，jvm都会对它就行果断的销毁，释放内存。 那么，ThreadLocalMap中的key使用弱引用的原因也是如此。当一条线程中的ThreadLocal对象使用完毕，没有强引用指向它的时候，垃圾收集器就会自动回收这个Key，从而达到节约内存的目的。1WeakReference&lt;Person&gt; wr = new WeakReference&lt;Person&gt;(new Person()); 虚引用123虚引用等于没有引用，无法通过虚引用访问其对应的对象。虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。 如何避免泄漏既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。 如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。 ThreadLocal 应用场景 Hibernate的session获取场景：每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。 12345678910111213141516171819202122private static final ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;();// 获取Sessionpublic static Session getCurrentSession()&#123; Session session = threadLocal.get(); // 判断Session是否为空，如果为空，将创建一个session，并设置到本地线程变量中 try &#123; if(session == null &amp;&amp; !session.isOpen())&#123; if(sessionFactory == null)&#123; // 创建Hibernate的SessionFactory rbuildSessionFactory(); &#125;else&#123; session = sessionFactory.openSession(); &#125; &#125; threadLocal.set(session); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return session;&#125; 总结： 每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。 ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。 适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。 参考 https://www.jianshu.com/p/98b68c97df9b https://www.jianshu.com/p/3f3620f9011d https://blog.csdn.net/rodbate/article/details/72857447 https://www.cnblogs.com/dolphin0520/p/3784171.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"并发多线程(五)ThreadPoolExecutor线程池","slug":"backend/java/concurrent1/并发多线程(五)ThreadPoolExecutor线程池","date":"2019-04-05T14:59:44.000Z","updated":"2019-05-13T14:49:13.609Z","comments":true,"path":"2019/04/05/backend/java/concurrent1/并发多线程(五)ThreadPoolExecutor线程池/","link":"","permalink":"http://www.songshuiyang.site/2019/04/05/backend/java/concurrent1/并发多线程(五)ThreadPoolExecutor线程池/","excerpt":"","text":"概述 在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。 那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的ThreadPoolExecutor类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。 Java中的ThreadPoolExecutor类 java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。 123456789101112131415public class ThreadPoolExecutor extends AbstractExecutorService &#123; ..... public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler); public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler); ...&#125; 从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。 下面解释下一下构造器中各个参数的含义： corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中； maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程； keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0； unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性： 1234567TimeUnit.DAYS; //天TimeUnit.HOURS; //小时TimeUnit.MINUTES; //分钟TimeUnit.SECONDS; //秒TimeUnit.MILLISECONDS; //毫秒TimeUnit.MICROSECONDS; //微妙TimeUnit.NANOSECONDS; //纳秒 workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。 123ArrayBlockingQueue;LinkedBlockingQueue;SynchronousQueue; threadFactory：线程工厂，主要用来创建线程； handler：表示当拒绝处理任务时的策略，有以下四种取值： 1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现： 12345678910111213141516171819202122232425public abstract class AbstractExecutorService implements ExecutorService &#123; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; &#125;; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; &#125;; public Future&lt;?&gt; submit(Runnable task) &#123;&#125;; public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; &#125;; public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; &#125;; private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, boolean timed, long nanos) throws InterruptedException, ExecutionException, TimeoutException &#123; &#125;; public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException &#123; &#125;; public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; &#125;; public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException &#123; &#125;; public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException &#123; &#125;;&#125; AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。我们接着看ExecutorService接口的实现： 12345678910111213141516171819202122public interface ExecutorService extends Executor &#123; void shutdown(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现： Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的； 123public interface Executor &#123; void execute(Runnable command);&#125; 在ThreadPoolExecutor类中有几个非常重要的方法： 1234execute()submit()shutdown()shutdownNow() 方法讲解 execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。 submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。 shutdown()和shutdownNow()是用来关闭线程池的。 还有很多其他的方法，比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。 深入剖析线程池实现原理 在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：123456789101112131.线程池状态2.任务的执行3.线程池中的线程初始化4.任务缓存队列及排队策略5.任务拒绝策略6.线程池的关闭7.线程池容量的动态调整 1.线程池状态 在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：123456789101112volatile int runState;static final int RUNNING = 0;static final int SHUTDOWN = 1;static final int STOP = 2;static final int TERMINATED = 3;runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；下面的几个static final变量表示runState可能的几个取值。当创建线程池后，初始时，线程池处于RUNNING状态；如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。 2.任务的执行 在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量： 1234567891011121314151617181920212223private final BlockingQueue&lt;Runnable&gt; workQueue; // 任务缓存队列，用来存放等待执行的任务private final ReentrantLock mainLock = new ReentrantLock(); // 线程池的主要状态锁，对线程池状态（比如线程池大小runState等）的改变都要使用这个锁private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 用来存放工作集 private volatile long keepAliveTime; // 线程存活时间 private volatile boolean allowCoreThreadTimeOut; // 是否允许为核心线程设置存活时间private volatile int corePoolSize; // 核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）private volatile int maximumPoolSize; // 线程池最大的线程数 private volatile int poolSize; // 线程池中当前的线程数 private volatile RejectedExecutionHandler handler; // 任务拒绝策略 private volatile ThreadFactory threadFactory; // 线程工厂，用来创建线程 private int largestPoolSize; // 用来记录线程池中曾经出现过的最大线程数 private long completedTaskCount; // 用来记录已经执行完毕的任务个数 每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。 corePoolSize这个就是线程池的大小。举个简单的例子： - 假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。 因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做； 当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待； 如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来； 然后就将任务也分配给这4个临时工人做； 如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。 当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。 这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。 也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。 不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。 largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。 在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Executes the given task sometime in the future. The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;. * * @param command the task to execute * @throws RejectedExecutionException at discretion of * &#123;@code RejectedExecutionHandler&#125;, if the task * cannot be accepted for execution * @throws NullPointerException if &#123;@code command&#125; is null */public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ int c = ctl.get(); // 1.如果当前线程数量小于corePoolSize，则创建并启动线程。 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; // 2.步骤1失败，则尝试进入阻塞队列， if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 入队列成功，检查线程池状态，如果状态部署RUNNING而且remove成功，则拒绝任务 int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 3. 步骤1和2失败，尝试将线程池的数量有corePoolSize扩充至maxPoolSize，如果失败，则拒绝任务 else if (!addWorker(command, false)) reject(command);&#125; 任务提交给线程池之后的处理策略 如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务； 如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。3.线程池中的线程初始化 默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到： prestartCoreThread()：初始化一个核心线程； prestartAllCoreThreads()：初始化所有核心线程 4.任务缓存队列及排队策略 在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。workQueue的类型为BlockingQueue，通常可以取下面三种类型： 1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小； 2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE； 3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。 5.任务拒绝策略 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：1234ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 6.线程池的关闭 ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中： shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务 shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务7.线程池容量的动态调整 ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()， setCorePoolSize：设置核心池大小 setMaximumPoolSize：设置线程池最大能创建的线程数目大小 当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。 使用示例ThreadPoolExecutor 使用示例123456789101112131415161718192021222324252627282930313233343536public class ThreadPoolExecutorTest &#123; public static void main(String[] args) &#123; ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); for (int i = 0; i &lt; 15; i++) &#123; MyTask myTask = new MyTask(i); executor.execute(myTask); System.out.println( \"线程池中线程数目：\" + executor.getPoolSize() + \"，队列中等待执行的任务数目：\" + executor.getQueue().size() + \"，已执行玩别的任务数目：\" + executor.getCompletedTaskCount()); &#125; executor.shutdown(); &#125;&#125;class MyTask implements Runnable &#123; private int taskNum; public MyTask(int num) &#123; this.taskNum = num; &#125; @Override public void run() &#123; System.out.println(\"正在执行task \" + taskNum); try &#123; Thread.currentThread().sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"task \" + taskNum + \"执行完毕\"); &#125;&#125; 输出结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 0线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 2正在执行task 1线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0正在执行task 3线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0正在执行task 4线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 10线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 11线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 12正在执行task 13线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 14task 1执行完毕task 0执行完毕task 4执行完毕task 2执行完毕正在执行task 7task 3执行完毕正在执行task 6正在执行task 5正在执行task 8正在执行task 9task 12执行完毕task 14执行完毕task 10执行完毕task 11执行完毕task 13执行完毕task 7执行完毕task 5执行完毕task 8执行完毕task 6执行完毕task 9执行完毕Process finished with exit code 0 从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。 Executors提供四种线程池的创建实现 将线程放入线程池的两种方法 1、ExecutorService 类中的 submit(Runnable task) submit(Callable task) 2、Executor 接口中的execute(Runnable command) newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池的规模不存在限制。 缓存线程池，缓存的线程默认存活60秒。线程的核心池corePoolSize大小为0，核心池最大为Integer.MAX_VALUE,阻塞队列使用的是SynchronousQueue。是一个直接提交的阻塞队列， 他总会迫使线程池增加新的线程去执行新的任务。在没有任务执行时，当线程的空闲时间超过keepAliveTime（60秒），则工作线程将会终止被回收，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销。如果同时又大量任务被提交，而且任务执行的时间不是特别快，那么线程池便会新增出等量的线程池处理任务，这很可能会很快耗尽系统的资源。 构造ThreadPoolExecutor 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 示例代码 1234567891011121314151617181920212223242526272829303132public class NewCachedThreadPoolTest &#123; public static void main(String[] args) &#123; ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; try &#123; Thread.sleep(index * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 1- 在未来某个时间执行给定的命令。 // 该命令可能在新的线程、已入池的线程或者正调用的线程中执行，这由 Executor 实现决定。 cachedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(index); &#125; &#125;); // 2- 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。 // 该 Future 的 get 方法在成功完成时将会返回给定的结果 cachedThreadPool.submit(new Runnable() &#123; @Override public void run() &#123; System.out.println(index); &#125; &#125;); &#125; cachedThreadPool.shutdown(); &#125;&#125; newFixedThreadPool 创建一个固定长度线程池，可控制线程最大并发数，超出的线程会在队列中等待。 构造ThreadPoolExecutor12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newScheduledThreadPool 创建一个固定长度线程池，支持定时及周期性任务执行。 构造ThreadPoolExecutor12345678910public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;...public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 构造ThreadPoolExecutor 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。 虽然jdk提供了以上线程池的创建实现，但在实际项目中不推荐使用，在阿里巴巴编码规范插件中是这么提示的：线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors各个方法的弊端： 1）newCachedThreadPool和newScheduledThreadPool: 主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。 2）newFixedThreadPool和newSingleThreadExecutor: 主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。 正确使用例子： 1234567891011121314151617181920212223242526272829303132333435Positive example 1： //org.apache.commons.lang3.concurrent.BasicThreadFactory ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(1, new BasicThreadFactory.Builder().namingPattern(\"example-schedule-pool-%d\").daemon(true).build()); Positive example 2： ThreadFactory namedThreadFactory = new ThreadFactoryBuilder() .setNameFormat(\"demo-pool-%d\").build(); //Common Thread Pool ExecutorService pool = new ThreadPoolExecutor(5, 200, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy()); pool.execute(()-&gt; System.out.println(Thread.currentThread().getName())); pool.shutdown();//gracefully shutdown Positive example 3： &lt;bean id=\"userThreadPool\" class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\"&gt; &lt;property name=\"corePoolSize\" value=\"10\" /&gt; &lt;property name=\"maxPoolSize\" value=\"100\" /&gt; &lt;property name=\"queueCapacity\" value=\"2000\" /&gt; &lt;property name=\"threadFactory\" value= threadFactory /&gt; &lt;property name=\"rejectedExecutionHandler\"&gt; &lt;ref local=\"rejectedExecutionHandler\" /&gt; &lt;/property&gt; &lt;/bean&gt; //in code userThreadPool.execute(thread); 总结 为什么要用线程池，因为每次new Thread新建对象性能差，使用线程池可以重用存在的线程，减少对象创建、消亡的开销，性能佳。 相比普通线程的执行，使用线程池可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，同时还提供了定时执行、定期执行、单线程、并发数控制等功能。 其他 Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？一般说来，大家认为线程池的大小经验值应该这样设置：（其中 N 为CPU的个数） 如果是 CPU 密集型应用，则线程池大小设置为 N+1，因为 CPU 密集型任务使得 CPU 使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。 如果是 IO 密集型应用，则线程池大小设置为 2N+1，IO密 集型任务 CPU 使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用 CPU 时间。 如果是混合型应用，那么分别创建线程池，可以将任务分成 IO 密集型和 CPU 密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。 参考转载 https://www.cnblogs.com/dolphin0520/p/3932921.html https://blog.csdn.net/tanghui270270/article/details/80595961 https://www.cnblogs.com/superfj/p/7544971.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"并发多线程(四)Lock同步锁","slug":"backend/java/concurrent1/并发多线程(四)Lock同步锁","date":"2019-04-04T14:59:44.000Z","updated":"2019-05-13T14:49:13.663Z","comments":true,"path":"2019/04/04/backend/java/concurrent1/并发多线程(四)Lock同步锁/","link":"","permalink":"http://www.songshuiyang.site/2019/04/04/backend/java/concurrent1/并发多线程(四)Lock同步锁/","excerpt":"","text":"概述 在上上篇文章中我们讲到了如何使用关键字synchronized来实现同步访问。本文我们继续来探讨这个问题，从Java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。 也许有朋友会问，既然都可以通过synchronized来实现同步访问了，那么为什么还需要提供Lock？这个问题将在下面进行阐述。本文先从synchronized的缺陷讲起，然后再讲述java.util.concurrent.locks包下常用的有哪些类和接口，最后讨论以下一些关于锁的概念方面的东西 一：synchronized的缺陷 synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？在上面一篇文章中，我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况： 1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有； 2）线程执行发生异常，此时JVM会让线程自动释放锁。 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。 再举个例子：当有多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作会发生冲突现象，但是读操作和读操作不会发生冲突现象。但是采用synchronized关键字来实现同步的话，就会导致一个问题：如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过Lock就可以办到。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。 二.java.util.concurrent.locks包下常用的类 下面我们就来探讨一下java.util.concurrent.locks包中常用的类和接口。 1.Lock 首先要说明的就是Lock，通过查看Lock的源码可知，Lock是一个接口： 12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 下面来逐个讲述Lock接口中每个方法的使用，lock()、tryLock()、tryLock(long time, TimeUnit unit)和lockInterruptibly()是用来获取锁的。unLock()方法是用来释放锁的。newCondition()这个方法暂且不在此讲述，会在后面的线程协作一文中讲述。 在Lock中声明了四个方法来获取锁，那么这四个方法有何区别呢？ lock() 首先lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的： 123456789Lock lock = ...;lock.lock();try&#123; //处理任务&#125;catch(Exception ex)&#123; &#125;finally&#123; lock.unlock(); //释放锁&#125; tryLock() tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。 tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。 所以，一般情况下通过tryLock来获取锁时是这样使用的： 123456789101112Lock lock = ...;if(lock.tryLock()) &#123; try&#123; //处理任务 &#125;catch(Exception ex)&#123; &#125;finally&#123; lock.unlock(); //释放锁 &#125; &#125;else &#123; //如果不能获取锁，则直接做其他事情&#125; lockInterruptibly() lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。 由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。 因此lockInterruptibly()一般的使用形式如下： 123456789public void method() throws InterruptedException &#123; lock.lockInterruptibly(); try &#123; //..... &#125; finally &#123; lock.unlock(); &#125; &#125; 注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。因为本身在前面的文章中讲过单独调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有进行等待的情况下，是可以响应中断的。 而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 2.ReentrantLock ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。 lock()的错误使用方法 代码 12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; Lock lock = new ReentrantLock(); //注意这个地方 lock.lock(); try &#123; System.out.println(thread.getName()+\"得到了锁\"); for(int i=0;i&lt;5;i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); &#125; &#125;&#125; 各位朋友先想一下这段代码的输出结果是什么？ 1234Thread-0得到了锁Thread-1得到了锁Thread-0释放了锁Thread-1释放了锁 也许有朋友会问，怎么会输出这个结果？第二个线程怎么会在第一个线程释放锁之前得到了锁？原因在于，在insert方法中的lock变量是局部变量，每个线程执行该方法时都会保存一个副本，那么理所当然每个线程执行到lock.lock()处获取的是不同的锁，所以就不会发生冲突。 知道了原因改起来就比较容易了，只需要将lock声明为类的属性即可。 12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); private Lock lock = new ReentrantLock(); //注意这个地方 public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; lock.lock(); try &#123; System.out.println(thread.getName()+\"得到了锁\"); for(int i=0;i&lt;5;i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); &#125; &#125;&#125; 这样就是正确地使用Lock的方法了。 tryLock()的使用方法 代码 12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); private Lock lock = new ReentrantLock(); //注意这个地方 public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; if(lock.tryLock()) &#123; try &#123; System.out.println(thread.getName()+\"得到了锁\"); for(int i=0;i&lt;5;i++) &#123; arrayList.add(i); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception &#125;finally &#123; System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); &#125; &#125; else &#123; System.out.println(thread.getName()+\"获取锁失败\"); &#125; &#125;&#125; 输出结果： 123Thread-0得到了锁Thread-1获取锁失败Thread-0释放了锁 lockInterruptibly()响应中断的使用方法： 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Test &#123; private Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; Test test = new Test(); MyThread thread1 = new MyThread(test); MyThread thread2 = new MyThread(test); thread1.start(); thread2.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread2.interrupt(); &#125; public void insert(Thread thread) throws InterruptedException&#123; lock.lockInterruptibly(); //注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出 try &#123; System.out.println(thread.getName()+\"得到了锁\"); long startTime = System.currentTimeMillis(); for( ; ;) &#123; if(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE) break; //插入数据 &#125; &#125; finally &#123; System.out.println(Thread.currentThread().getName()+\"执行finally\"); lock.unlock(); System.out.println(thread.getName()+\"释放了锁\"); &#125; &#125;&#125; class MyThread extends Thread &#123; private Test test = null; public MyThread(Test test) &#123; this.test = test; &#125; @Override public void run() &#123; try &#123; test.insert(Thread.currentThread()); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName()+\"被中断\"); &#125; &#125;&#125; 运行之后，发现thread2能够被正确中断 12Thread-0得到了锁Thread-1被中断 3.ReadWriteLock ReadWriteLock也是一个接口，在它里面只定义了两个方法： 123456789101112131415public interface ReadWriteLock &#123; /** * Returns the lock used for reading. * * @return the lock used for reading. */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing. */ Lock writeLock();&#125; 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock实现了ReadWriteLock接口。 4.ReentrantReadWriteLock ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。 下面通过几个例子来看一下ReentrantReadWriteLock具体用法。 假如有多个线程要同时进行读操作的话，先看一下synchronized达到的效果： 12345678910111213141516171819202122232425262728public class Test &#123; private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); &#125; public synchronized void get(Thread thread) &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+\"正在进行读操作\"); &#125; System.out.println(thread.getName()+\"读操作完毕\"); &#125;&#125; 这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0读操作完毕Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1读操作完毕 而改成用读写锁的话： 12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void get(Thread thread) &#123; rwl.readLock().lock(); try &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+\"正在进行读操作\"); &#125; System.out.println(thread.getName()+\"读操作完毕\"); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125;&#125; 此时打印的结果为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Thread-0正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0正在进行读操作Thread-1正在进行读操作Thread-0读操作完毕Thread-1读操作完毕 说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 三.锁的相关概念介绍1.可重入锁 如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。 看下面这段代码就明白了： 123456789class MyClass &#123; public synchronized void method1() &#123; method2(); &#125; public synchronized void method2() &#123; &#125;&#125; 上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。 而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。 2.可中断锁 可中断锁：顾名思义，就是可以相应中断的锁。 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。 如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。 在前面演示lockInterruptibly()的用法时已经体现了Lock的可中断性。 3.公平锁 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。*而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。 4.读写锁 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。 ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。 四.总结 1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 6）在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 参考转载 https://www.cnblogs.com/dolphin0520/p/3932921.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"并发多线程(三)volatile关键字","slug":"backend/java/concurrent1/并发多线程(三)volatile关键字","date":"2019-04-01T14:59:44.000Z","updated":"2019-05-13T14:49:13.547Z","comments":true,"path":"2019/04/01/backend/java/concurrent1/并发多线程(三)volatile关键字/","link":"","permalink":"http://www.songshuiyang.site/2019/04/01/backend/java/concurrent1/并发多线程(三)volatile关键字/","excerpt":"","text":"剖析volatile关键字1. volatile关键字的两层语义 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 2. volatile保证原子性吗? 从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 i++ 的操作实际上分为三个步骤 1、读 int temp = i; 2、改 i = i + 1 3、写 i = temp 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 把上面的代码改成以下任何一种都可以达到效果： 采用synchronized： 1234567891011121314151617181920212223public class Test &#123; public int inc = 0; public synchronized void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 采用Lock1234567891011121314151617181920212223242526272829public class Test &#123; public int inc = 0; Lock lock = new ReentrantLock(); public void increase() &#123; lock.lock(); try &#123; inc++; &#125; finally&#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 3.volatile能保证有序性吗？ 在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 4.volatile的原理和实现机制 前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。 下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： * 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； * 2）它会强制将对缓存的修改操作立即写入主存； * 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 为什么代码会重排序？ 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件： 在单线程环境下不能改变程序运行的结果。 存在数据依赖关系的不允许重排序5.volatile 使用场景 只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全： （1）对变量的写操作不依赖于当前值。 （2）该变量没有包含在具有其他变量的不变式中。 状态标志 实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。 123456789101112volatile boolean shutdownRequested; ... // 其他线程调用，通知需要结束，并改变状态public void shutdown() &#123; shutdownRequested = true; &#125; public void doWork() &#123; while (!shutdownRequested) &#123; // do stuff &#125;&#125; 很可能会从循环外部调用 shutdown() 方法 —— 即在另一个线程中 —— 因此，需要执行某种同步来确保正确实现 shutdownRequested 变量的可见性。（可能会从 JMX 侦听程序、GUI 事件线程中的操作侦听程序、通过 RMI 、通过一个 Web 服务等调用）。然而，使用 synchronized 块编写循环要比使用清单 2 所示的 volatile 状态标志编写麻烦很多。由于 volatile 简化了编码，并且状态标志并不依赖于程序内任何其他状态，因此此处非常适合使用 volatile。 这种类型的状态标记的一个公共特性是：通常只有一种状态转换；shutdownRequested 标志从 false 转换为 true，然后程序停止。这种模式可以扩展到来回转换的状态标志，但是只有在转换周期不被察觉的情况下才能扩展（从 false 到 true，再转换到 false）。此外，还需要某些原子状态转换机制，例如原子变量。 总结其他 Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。 volatile 和 synchronized 的区别？ volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile 仅能使用在变量级别。synchronized 则可以使用在变量、方法、和类级别的。 volatile 仅能实现变量的修改可见性，不能保证原子性。而synchronized 则可以保证变量的修改可见性和原子性。 volatile 不会造成线程的阻塞。synchronized 可能会造成线程的阻塞。 volatile 标记的变量不会被编译器优化。synchronized标记的变量可以被编译器优化。 参考转载 https://www.cnblogs.com/dolphin0520/p/3920373.html https://blog.csdn.net/y874961524/article/details/82934831","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"并发多线程(二)synchronized关键字","slug":"backend/java/concurrent1/并发多线程(二)synchronized关键字","date":"2019-04-01T13:59:44.000Z","updated":"2019-05-13T14:49:13.566Z","comments":true,"path":"2019/04/01/backend/java/concurrent1/并发多线程(二)synchronized关键字/","link":"","permalink":"http://www.songshuiyang.site/2019/04/01/backend/java/concurrent1/并发多线程(二)synchronized关键字/","excerpt":"","text":"Synchronized 关键字使用、底层原理、JDK1.6 之后的底层优化以及 和ReenTrantLock 的对比 说一说自己对于 synchronized 关键字的了解 synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。 另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 synchronized关键字最主要的三种使用方式 修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！ 下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。 面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！” 双重校验锁实现对象单例（线程安全） 1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; //先判断对象是否已经实例过，没有实例化过才进入加锁代码 if (uniqueInstance == null) &#123; //类对象加锁 synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。 uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 synchronized 关键字底层原理synchronized 关键字底层原理属于 JVM 层面。 ① synchronized 同步语句块的情况 1234567public class SynchronizedDemo &#123; public void method() &#123; synchronized (this) &#123; System.out.println(\"synchronized 代码块\"); &#125; &#125;&#125; 通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行javap -c -s -v -l SynchronizedDemo.class。 synchronized 关键字原理 从上面我们可以看出： synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 对象被创建在堆中。并且对象在内存中的存储布局方式可以分为3块区域：对象头、实例数据、对齐填充。对于对象头来说，主要是包括俩部分信息: * 1、自身运行时的数据，比如：如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。（此部分内容被称之为Mark Word） * 2、另一部分是类型指针：JVM通过这个指针来确定这个对象是哪个类的实例。 ② synchronized 修饰方法的的情况 12345public class SynchronizedDemo2 &#123; public synchronized void method() &#123; System.out.println(\"synchronized 方法\"); &#125;&#125; synchronized 关键字原理 synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 JDK 1.6锁优化1、自旋锁 由来 线程的阻塞和唤醒，需要 CPU 从用户态转为核心态。频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时，我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间。为了这一段很短的时间，频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。 定义 所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。 怎么等待呢？执行一段无意义的循环即可（自旋）。 自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。 所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。 自旋锁在 JDK 1.4.2 中引入，默认关闭，但是可以使用-XX:+UseSpinning 开开启。 在 JDK1.6 中默认开启。同时自旋的默认次数为 10 次，可以通过参数 -XX:PreBlockSpin 来调整。 如果通过参数 -XX:PreBlockSpin 来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为 10 ，但是系统很多线程都是等你刚刚退出的时候，就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是 JDK 1.6 引入自适应的自旋锁，让虚拟机会变得越来越聪明。 适应自旋锁 JDK 1.6 引入了更加聪明的自旋锁，即自适应自旋锁。 线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。 反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。 2、锁消除 由来 为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制。但是，在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。 定义 锁消除的依据是逃逸分析的数据支持。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些 JDK 的内置 API 时，如 StringBuffer、Vector、HashTable 等，这个时候会存在隐性的加锁操作。比如 StringBuffer 的 #append(..)方法，Vector 的 add(…) 方法： 1234567public void vectorTest()&#123; Vector&lt;String&gt; vector = new Vector&lt;String&gt;(); for (int i = 0 ; i &lt; 10 ; i++)&#123; vector.add(i + \"\"); &#125; System.out.println(vector);&#125; 在运行这段代码时，JVM 可以明显检测到变量 vector 没有逃逸出方法 #vectorTest() 之外，所以 JVM 可以大胆地将 vector 内部的加锁操作消除。 3、锁粗化 由来 我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小：仅在共享数据的实际作用域中才进行同步。这样做的目的，是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。 在大多数的情况下，上述观点是正确的，LZ 也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。 定义 锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。 如上面实例：vector 每次 add 的时候都需要加锁操作，JVM 检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到 for 循环之外。 4、锁升级 锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。它们会随着竞争的激烈而逐渐升级。注意，锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 4.1 重量级锁重量级锁通过对象内部的监视器（Monitor）实现。 其中，Monitor 的本质是，依赖于底层操作系统的 Mutex Lock 实现。操作系统实现线程之间的切换，需要从用户态到内核态的切换，切换成本非常高。 4.1 轻量级锁引入轻量级锁的主要目的，是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 当关闭偏向锁功能或者多个线程竞争偏向锁，导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁其步骤如下： 获取锁 判断当前对象是否处于无锁状态？若是，则 JVM 首先将在当前线程的栈帧中，建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word的 拷贝（官方把这份拷贝加了一个 Displaced 前缀，即 Displaced Mark Word）；否则，执行步骤（3）； JVM 利用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指正。如果成功，表示竞争到锁，则将锁标志位变成 00（表示此对象处于轻量级锁状态），执行同步操作；如果失败，则执行步骤（3）； 判断当前对象的 Mark Word 是否指向当前线程的栈帧？如果是，则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则，只能说明该锁对象已经被其他线程抢占了，当前线程便尝试使用自旋来获取锁。若自旋后没有获得锁，此时轻量级锁会升级为重量级锁，锁标志位变成 10，当前线程会被阻塞。 释放锁 轻量级锁的释放也是通过 CAS 操作来进行的，主要步骤如下： 取出在获取轻量级锁保存在 Displaced Mark Word 中 数据。 使用 CAS 操作将取出的数据替换当前对象的 Mark Word 中。如果成功，则说明释放锁成功；否则，执行（3）。 无论（2）是否释放成功，都会唤醒被挂起的线程，重新争夺锁，访问同步代码块。 下图是争夺锁导致的锁膨胀的流程图：其中，绿框的 0 指的是无偏向锁，01 指的是无锁状态。 注意事项: 对于轻量级锁，其性能提升的依据是：“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”。如果打破这个依据则除了互斥的开销外，还有额外的 CAS 操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢。 4.1 偏向锁4.1参考转载 https://github.com/Snailclimb/JavaGuide/edit/master/docs/java/synchronized.md http://www.iocoder.cn/JUC/sike/synchronized/","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"并发多线程(一)Thread的创建及使用","slug":"backend/java/concurrent1/并发多线程(一)Thread的创建及使用","date":"2019-04-01T12:59:44.000Z","updated":"2019-05-13T14:49:13.467Z","comments":true,"path":"2019/04/01/backend/java/concurrent1/并发多线程(一)Thread的创建及使用/","link":"","permalink":"http://www.songshuiyang.site/2019/04/01/backend/java/concurrent1/并发多线程(一)Thread的创建及使用/","excerpt":"","text":"1. 线程创建及使用1.1 继承Thread类创建线程类 实现最简单，如果要访问当前线程，则无需使用 Thread.currentThread()直接使用this即可得到当前线程 不能再继承其他父类，因为线程类已经继承了Thread类 Thread类继承Runnable类12345678910111213141516public class ThreadTest &#123; public static void main(String[] args) &#123; CustomThread customThread = new CustomThread(); customThread.start(); &#125;&#125;class CustomThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"CustomThread doing\"); &#125;&#125; 1.2 实现Runnable类创建线程类 线程类只是实现了Runnable类，还可以继承其他类 访问线程需要使用 Thread.currentThread()访问当前线程1234567891011121314151617public class RunnableTest &#123; public static void main(String[] args) &#123; // CustomRunnable对象作为Thread构造参数 Thread thread = new Thread(new CustomRunnable()); thread.start(); &#125;&#125;class CustomRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"CustomRunnable doing\"); &#125;&#125; 1.3 使用Callable和Future创建线程 线程类只是实现了Runnable类，还可以继承其他类 访问线程需要使用 Thread.currentThread()访问当前线程 可以得到线程方法体的结果，得到call()方法返回值 可以得到执行异常1234567891011121314151617181920212223242526272829303132public class CallableTest &#123; public static void main(String[] args) &#123; CustomCallable customCallable = new CustomCallable(); // 使用Callable方式创建线程，需要FutureTask类的支持，用于接收运算结果，可以使用泛型指定返回值的类型 FutureTask&lt;Integer&gt; futureTask = new FutureTask(customCallable); new Thread(futureTask).start(); int sum = 0; // 接收运算结果，只有当该线程执行完毕后才会获取到运算结果，等同于闭锁的效果 try &#123; sum = futureTask.get(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(\"sum is \" + sum); &#125;&#125;class CustomCallable implements Callable &#123; @Override public Object call() throws Exception &#123; // 计算1-100的和 int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; return sum; &#125;&#125; 2. 线程的生命周期 线程从创建到最终的消亡，要经历若干个状态。一般来说，线程包括以下这几个状态：创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、消亡（dead）。 当需要新起一个线程来执行某个子任务时，就创建了一个线程。但是线程创建之后，不会立即进入就绪状态，因为线程的运行需要一些条件（比如内存资源，在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的，所以需要为线程分配一定的内存空间），只有线程运行需要的所有条件满足了，才进入就绪状态。 线程上下文切换，线程的上下文切换实际上就是 存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行，上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。 虽然多线程可以使得任务执行的效率得到提升，但是由于在线程切换时同样会带来一定的开销代价，并且多个线程会导致系统资源占用的增加，所以在进行多线程编程时要注意这些因素。 3. 控制线程3.1 join线程 让一个线程等待另一个线程完成的方法，当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到加入的join()线程执行完为止 3.2 sleep睡眠线程 sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。 3.3 yield线程让步 调用yield方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。 3.4 setPriority() 改变线程优先级 优先级高的线程获得较多的执行机会 总结 Java 线程是重量级的，每个线程默认使用 1024KB 的内存，所以一个 Java 进程是无法开启大量线程的 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。 从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。 为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？ 一个很明显的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。 由于 wait，notify 和 notifyAll 方法都是锁级别的操作，所以把它们定义在 Object 类中，因为锁属于对象。 参考转载 https://www.cnblogs.com/dolphin0520/p/3920357.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM堆转储文件分析EclipseMemoryAnalyzer","slug":"backend/java/jvm1/JVM堆转储文件分析EclipseMemoryAnalyzer","date":"2019-03-26T14:59:44.000Z","updated":"2019-05-22T13:04:29.316Z","comments":true,"path":"2019/03/26/backend/java/jvm1/JVM堆转储文件分析EclipseMemoryAnalyzer/","link":"","permalink":"http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM堆转储文件分析EclipseMemoryAnalyzer/","excerpt":"","text":"简介 Eclipse Memory Analyzer 它是一个功能丰富的 JAVA 堆转储文件分析工具，可以帮助你发现内存漏洞和减少内存消耗 简称MAT 下载安装 下载链接: https://www.eclipse.org/mat/downloads.php 解压后直接打开MemoryAnalyzer.exe 使用EclipseMemoryAnalyzer1、获取Heap Dump 堆转储文件什么是Heap Dump文件 Heap Dump 是一个 Java 进程在某个时间点上的内存快照。 Heap Dump 是有着多种格式的。 不过总体上Heap Dump 在触发快照的时候都保存了 java 对象和类的信息。通常在写 Heap Dump 文件前会触发一次 FullGC，所以 Heap Dump 文件中保存的是 FullGC 后留下的对象信息。 Memory Analyzer 可以用来处理 HPROF 二进制 Heap Dump 文件、 IBM 系统 dump 文件（经过处理后）、以及来自各个平台上的 IBM portable Heap Dumps (PHD)文件。 一般在 Heap Dump 文件中可以获取到（ 这仍然取决于 Heap Dump 文件的类型） 如下信息： 对象信息：类、成员变量、直接量以及引用值； 类信息： 类加载器、 名称、 超类、 静态成员； Garbage Collections Roots： JVM 可达的对象； 线程栈以及本地变量： 获取快照时的线程栈信息， 以及局部变量的详细信息。 MAT根据这个文件可以分析出内存泄露和高内存消耗地点。 获取Heap Dump文件 这可是一个相当便捷的参数了，因为当你需要分析Java内存使用情况时，往往是在OOM(OutOfMemoryError)发生时。那么通过在你的启动脚本中，为Java命令添加以下参数，就可以得到一份内存信息了 Java –Xmx1024m …. -XX:+HeapDumpOnOutOfMemoryError …… 使用JDK工具获取，jmap –dump:format=b,file=heap.bin PID 使用基本的GUI工具，如jconsol, Eclipse memory analyzer等 2、使用EclipseMemoryAnalyzer 得到Heap Dump 堆转储文件之后，就可以使用这个工具直接打开了 2.1 Overview 在右侧窗口上方的位置可以看到 heapDump 的 size，以及类、对象和类加载器的数量。 右侧窗口中最醒目的饼图直观地显示了 dump 中最大的几个对象。鼠标光标划过饼图中代表某个对象的区块时可以在左侧 Inspector 窗口中看到对象的细节，在区块上点击鼠标左键可以通过菜单项钻取到关于其对应的对象更多的细节。 我们可以看到占用很大一部分内存的有几个深色的饼区，这些就可以当做我们稍后着重看的地方 2.2 Histogram 列出内存中的对象，对象的个数以及大小。 Shallow Heap 对象自身占用的内存大小，不包括它引用的对象 Retained Heap 是该对象自己的shallow size，加上从该对象能直接或间接访问到对象的shallow size之和 换句话说，Retained size是该对象被GC之后所能回收到内存的总和。 并且排除被GC Roots直接或者间接引用的对象 Shallow Heap 与 Retained Heap A对象的 Retained Heap = A对象的 Shallow Heap + C对象的 Shallow Heap 这里不包含 D 对象的 Shallow Heap因为 D对象被Root根对象所引用。 B对象的 Retained Heap = B对象的 Shallow Heap。 鼠标右键 List Object Incomming Reference（呼入 被谁依赖） 指的是引用当前对象的外部对象， Outgoing Reference（外向的 依赖谁） 指的是当前对象引用的外部对象 Paths to GC Roots 从当前对象到GC roots的路径，这个路径解释了为什么当前对象还能存活，对分析内存泄露很有帮助，这个查询只能针对单个对象使用 Merge Shortest Paths to GC roots 从GC roots到一个或一组对象的公共路径 Merge shortest Paths to GC roots 和Path to GC roots 这两个查询都有很多选项 意思是在查询到GC root的路径时，是包含所有引用，还是排除一些类型的引用（如软引用、弱引用、虚引用） 从GC角度说，一个对象无法被GC，一定是因为有强引用存在，其它引用类型在GC需要的情况下都是可以被GC掉的，所以可以使用 exclude all phantom/weak/soft etc. references 只查看GC路径上的强引用 需要注意的是，Paths to GC roots是针对单个对象的，故在Histogram视图无法使用，因为Histogram视图是针对类的，只能使用Merge shortest Paths to GC roots查询2.3 Dominator Tree 可以列出那个线程，以及线程下面的那些对象占用的空间。 Dominator Tree 展示了 Heap Dump 中最大的几个对象。 如果 dominator tree 中对象的父节点被移除的话那么， 那么相应对象及其后代节点也面临被回收的状态。 2.4 Top consumers 通过图形列出最大的object。 2.5 Leak Suspects Leak Suspects 是MAT帮我们分析的可能有内存泄露嫌疑的地方，可以体现出哪些对象被保持在内存中，以及为什么它们没有被垃圾回收 2.6 Thread Overview 在分析内存Dump的MAT中还可以看到线程栈信息，这本身就是一个强大的功能，类似于jstack命令的效果 Thread视图的入口，在工具栏上： 在Thread Overview视图可以看到：线程对象/线程栈信息、线程名、Shallow Heap、Retained Heap、类加载器、是否Daemon线程等信息 在分析内存Dump的MAT中还可以看到线程栈信息，这本身就是一个强大的功能，类似于jstack命令的效果 而且还能结合内存Dump分析，看到线程栈帧中的本地变量，在左下方的对象属性区域还能看到本地变量的属性，真的很方便 123456789public class TestThreadOverview &#123; private String str1 = \"str1\"; private String str2 = \"str2\"; public static void main(String[] args) &#123; TestThreadOverview test = new TestThreadOverview(); String local_str = \"local_str\"; LockSupport.park(); &#125;&#125; 在上面代码的Heap Dump分析中，可以看到线程调用栈的信息，以及main线程的 本地变量TestThreadOverview 和 字符串local_str 的信息 上图中第一个框起来的部分是 new TestThreadOverview()对象（代码第6行），TestThreadOverview对象有两个属性str1、str2 第二个框起来的部分是main方法中的字符串变量local_str（代码第8行） 结合左侧的对象属性区域，可以更方便的看清线程中对象的具体情况 其他 分析较大的dump文件（根据经验2G以上的dump文件就需要使用以下介绍的方法，不然mat会出现oom）需要调整虚拟机参数找个64位的系统在MemoryAnalyzer.ini设置-Xmx2g MAT提供了一个很贴心的功能，将报告的内容压缩打包到一个zip文件，并放在原始堆转储文件的目录下，一般命名为“xxx_Leak_Suspects.zip”，xxx是dump文件的名字，如果需要和同事一起分析这个内存问题的话，只需要把这个小小的zip包发给他就可以了，不需要把整个堆文件发给他。并且整个报告是一个HTML格式的文件，用浏览器就可以轻松打开 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/cc907566076/article/details/79108782 https://www.cnblogs.com/ldq2016/p/6632174.html https://www.cnblogs.com/trust-freedom/p/6744948.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM虚拟机性能监控与故障处理工具","slug":"backend/java/jvm1/JVM虚拟机性能监控与故障处理工具","date":"2019-03-26T13:59:44.000Z","updated":"2019-03-26T12:32:55.245Z","comments":true,"path":"2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/","link":"","permalink":"http://www.songshuiyang.site/2019/03/26/backend/java/jvm1/JVM虚拟机性能监控与故障处理工具/","excerpt":"","text":"JDK的命令行工具jcmd 综合工具 jcmd -l 列出当前运行的所有虚拟机 1235362 sun.tools.jcmd.JCmd -l1236 /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --httpPort=9080 --debug=5 --handlerCountMax=100 --handlerCountMaxIdle=207167 org.apache.catalina.startup.Bootstrap start jcmd [pid] VM.uptime 查看虚拟机启动时间VM.uptime jcmd [pid] Thread.print 打印线程栈信息Thread.print jcmd [pid] GC.class_histogram 查看系统中类统计信息GC.class_histogram jcmd [pid] GC.heap_dump [filepath&amp;name] 导出堆信息GC.heap_dump 这个命令功能和 jmap -dump 功能一样 jcmd [pid] VM.system_properties 获取系统Properties内容VM.system_properties jcmd [pid] VM.flags 获取启动参数VM.flags jcmd [pid] PerfCounter.print 获取所有性能相关数据PerfCounter.printjps 虚拟机进程状况工具 jps（JVM Process Status Tool）可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。虽然功能比较单一，但它是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier,PID）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。 命令格式，其中[option]、[hostid]参数也可以不写。 1234567jps [options] [hostid]option参数 •-l : 输出主类全名或jar路径 •-q : 只输出LVMID •-m : 输出JVM启动时传递给main()的参数 •-v : 输出JVM启动时显示指定的JVM参数 示例 123456789$ jps -l15232 org.gradle.launcher.daemon.bootstrap.GradleDaemon3104 sun.tools.jps.Jps6784 org.jetbrains.idea.maven.server.RemoteMavenServer8916 org.jetbrains.jps.cmdline.Launcher159768936 org.jetbrains.jps.cmdline.Launcher11580 com.songsy.iframe.Application jinfo 配置信息工具 jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令 命令格式 123456jinfo [option] [args] LVMIDoption参数 •-flag : 输出指定args参数的值 •-flags : 不需要args参数，输出所有JVM参数的值 •-sysprops : 输出系统属性，等同于System.getProperties() 示例 12345678$ jinfo -flags 11580Attaching to process ID 11580, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.121-b13Non-default VM flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:CICompilerCount=3 -XX:InitialHeapSize=134217728 -XX:+ManagementServer -XX:MaxHeapSize=2118123520 -XX:MaxNewSize=705691648 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=44564480 -XX:OldSize=89653248 -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGCCommand line: -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:58771,suspend=y,server=n -XX:TieredStopAtLevel=1 -Xverify:none -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=58770 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true -javaagent:C:\\Users\\asua\\.IntelliJIdea2017.2\\system\\groovyHotSwap\\gragent.jar -Dfile.encoding=UTF-8 jstat：虚拟机统计信息监视工具 jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 命令格式 12345678910111213jstat [option] LVMID [interval] [count]参数 •[option] : 操作参数 •LVMID : 本地虚拟机进程ID •[interval] : 连续输出的时间间隔 •[count] : 连续输出的次数 对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的;如果是远程虚拟机进程，那VMID的格式应当是：protocol://lvmid@hostname:port/servername参数interval和count代表查询间隔(单位毫秒)和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20 选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及作用请参考表4-3中的描述。 option参数详解 jstat -class监视类装载、卸载数量、总空间以及耗费的时间 12345678910$ jstat -class 11580Loaded Bytes Unloaded Bytes Time 7107 13135.3 0 0.0 6.84•Loaded : 加载class的数量•Bytes : class字节大小•Unloaded : 未加载class的数量•Bytes : 未加载class的字节大小•Time : 加载时间 jstat -compiler输出JIT编译过的方法数量耗时等12345678910$ jstat -compiler 11580Compiled Failed Invalid Time FailedType FailedMethod 4079 3 0 1.62 1 org/springframework/beans/CachedIntrospectionResults &lt;init&gt;•Compiled : 编译数量•Failed : 编译失败数量•Invalid : 无效数量•Time : 编译耗时•FailedType : 失败类型•FailedMethod : 失败方法的全限定名 jstat -gc 垃圾回收堆的行为统计12345678910111213141516171819$ jstat -gc 11580 S0C S1C S0U S1U EC EU OC OU MC MU CCSC CCSU YGC YGCT FGC FGCT GCT39424.0 29696.0 0.0 0.0 414208.0 353447.8 118272.0 46473.8 35072.0 34285.7 4608.0 4457.1 9 0.233 2 0.149 0.382•S0C : survivor0区的总容量•S1C : survivor1区的总容量•S0U : survivor0区已使用的容量•S1C : survivor1区已使用的容量•EC : Eden区的总容量•EU : Eden区已使用的容量•OC : Old区的总容量•OU : Old区已使用的容量•PC 当前perm的容量 (KB)•PU perm的使用 (KB)•YGC : 新生代垃圾回收次数•YGCT : 新生代垃圾回收时间•FGC : 老年代垃圾回收次数•FGCT : 老年代垃圾回收时间•GCT : 垃圾回收总消耗时间 jstat -gccapacity同-gc，不过还会输出Java堆各区域使用到的最大、最小空间123456789101112$ jstat -gccapacity 11580 NGCMN NGCMX NGC S0C S1C EC OGCMN OGCMX OGC OC MCMN MCMX MC CCSMN CCSMX CCSC YGC FGC 43520.0 689152.0 689152.0 39424.0 29696.0 414208.0 87552.0 1379328.0 118272.0 118272.0 0.0 1079296.0 35072.0 0.0 1048576.0 4608.0 9 2 •NGCMN : 新生代占用的最小空间•NGCMX : 新生代占用的最大空间•OGCMN : 老年代占用的最小空间•OGCMX : 老年代占用的最大空间•OGC：当前年老代的容量 (KB)•OC：当前年老代的空间 (KB)•PGCMN : perm占用的最小空间•PGCMX : perm占用的最大空间 jstat -gcutil 同-gc，不过输出的是已使用空间占总空间的百分比12S0 S1 E O M CCS YGC YGCT FGC FGCT GCT0.00 0.00 85.33 39.29 97.76 96.73 9 0.233 2 0.149 0.382 jstat -gccause 垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因123456$ jstat -gccause 11580 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT LGCC GCC 0.00 0.00 85.33 39.29 97.76 96.73 9 0.233 2 0.149 0.382 Allocation Failure No GC•LGCC：最近垃圾回收的原因•GCC：当前垃圾回收的原因 jstat -gcnew 统计新生代的行为123$ jstat -gcnew 11580 S0C S1C S0U S1U TT MTT DSS EC EU YGC YGCT39424.0 29696.0 0.0 0.0 2 15 39424.0 414208.0 353447.8 9 0.233 jstat -gcnewcapacity 新生代与其相应的内存空间的统计123456789$ jstat -gcnewcapacity 11580 NGCMN NGCMX NGC S0CMX S0C S1CMX S1C ECMX EC YGC FGC 43520.0 689152.0 689152.0 229376.0 39424.0 229376.0 29696.0 688128.0 414208.0 9 2•NGC:当前年轻代的容量 (KB)•S0CMX:最大的S0空间 (KB)•S0C:当前S0空间 (KB)•ECMX:最大eden空间 (KB)•EC:当前eden空间 (KB) jmap：Java内存映像工具 jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。 如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如加-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。 jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。和jinfo命令一样，jmap有不少功能在Windows平台下都是受限的，除了生成dump文件的-dump选项和用于查看每个类的实例、空间占用统计的-histo选项在所有操作系统都提供之外，其余选项都只能在Linux/Solaris下使用。 命令格式 123456789jmap [option] LVMIDoption参数 •dump : 生成堆转储快照，格式为:-dump:[live, ] format=b,file=&lt;filename&gt;,其中live子参数说明是否只dump出存活的对象。 •finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象 •heap : 显示Java堆详细信息 •histo : 显示堆中对象的统计信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况 •permstat : to print permanent generation statistics •F : 当-dump没有响应时，强制生成dump快照 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$ jmap -heap 28920Attaching to process ID 28920, please wait... Debugger attached successfully. Server compiler detected. JVM version is 24.71-b01 using thread-local object allocation. Parallel GC with 4 thread(s) //GC 方式 Heap Configuration: //堆内存初始化配置 MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40) MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70) MaxHeapSize = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小 NewSize = 1310720 (1.25MB) //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小 MaxNewSize = 17592186044415 MB //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小 OldSize = 5439488 (5.1875MB) //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小 NewRatio = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率 SurvivorRatio = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 PermSize = 21757952 (20.75MB) //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小 MaxPermSize = 85983232 (82.0MB) //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小 G1HeapRegionSize = 0 (0.0MB) Heap Usage: //堆内存使用情况 PS Young Generation Eden Space: //Eden区内存分布 capacity = 33030144 (31.5MB) //Eden区总容量 used = 1524040 (1.4534378051757812MB)//Eden区已使用 free = 31506104 (30.04656219482422MB)//Eden区剩余容量 4.614088270399305% used //Eden区使用比率 From Space: //其中一个Survivor区的内存分布 capacity = 5242880 (5.0MB) used = 0 (0.0MB) free = 5242880 (5.0MB) 0.0% used To Space: //另一个Survivor区的内存分布 capacity = 5242880 (5.0MB) used = 0 (0.0MB) free = 5242880 (5.0MB) 0.0% used PS Old Generation //当前的Old区内存分布 capacity = 86507520 (82.5MB) used = 0 (0.0MB) free = 86507520 (82.5MB) 0.0% used PS Perm Generation //当前的 “永生代” 内存分布 capacity = 22020096 (21.0MB) used = 2496528 (2.3808746337890625MB) free = 19523568 (18.619125366210938MB) 11.337498256138392% used interned Strings occupying 43720 bytes. jmap -histo:live 28920 | more 打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）1234567891011121314151617181920212223num #instances #bytes class name---------------------------------------------- 1: 83613 12012248 &lt;constMethodKlass&gt; 2: 23868 11450280 [B 3: 83613 10716064 &lt;methodKlass&gt; 4: 76287 10412128 [C 5: 8227 9021176 &lt;constantPoolKlass&gt; 6: 8227 5830256 &lt;instanceKlassKlass&gt; 7: 7031 5156480 &lt;constantPoolCacheKlass&gt; 8: 73627 1767048 java.lang.String 9: 2260 1348848 &lt;methodDataKlass&gt; 10: 8856 849296 java.lang.Class class name是对象类型，说明如下：B byteC charD doubleF floatI intJ longZ boolean[ 数组，如[I表示int[][L+类名 其他对象 jhat：虚拟机堆转储快照分析工具 jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。 不过实事求是地说，在实际工作中，除非手上真的没有别的工具可用，否则一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器。二是用于分析的机器一般也是服务器，由于加载dump快照文件需要比生成dump更大的内存，所以一般在64位JDK、大内存的服务器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。 命令格式 12345678910 jhat [option] [dumpfile]参数 •-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt; •-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt; •-port port-number 设置 jhat HTTP server 的端口号. 默认值 7000.&gt; •-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt; •-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt; •-debug int 设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt; •-version 启动后只显示版本信息就退出&gt; •-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx. 示例 12345678910111213 ~ jhat eclipse.bin Reading from eclipse.bin...Dump file created Mon Oct 31 19:32:57 CST 2016Snapshot read, resolving...Resolving 185857 objects...Chasing references, expect 37 dots.....................................Eliminating duplicate references.....................................Snapshot resolved.Started HTTP server on port 7000Server is ready.屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost:7000/就可以看到分析结果.分析结果默认是以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的“Heap Histogram”（与jmap -histo功能一样）与OQL页签的功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似SQL的语法对内存中的对象进行查询统计. jstack：Java堆栈跟踪工具 jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。 命令格式123456jstack [option] LVMIDoption参数 •-F : 当正常输出请求不被响应时，强制输出线程堆栈 •-l : 除堆栈外，显示关于锁的附加信息 •-m : 如果调用到本地方法的话，可以显示C/C++的堆栈 JDK的可视化工具参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/wade-luffy/p/6017137.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM内存模型与线程(一)Java内存模型","slug":"backend/java/jvm1/JVM内存模型与线程(一)Java内存模型","date":"2019-03-21T13:59:44.000Z","updated":"2019-03-25T13:02:01.131Z","comments":true,"path":"2019/03/21/backend/java/jvm1/JVM内存模型与线程(一)Java内存模型/","link":"","permalink":"http://www.songshuiyang.site/2019/03/21/backend/java/jvm1/JVM内存模型与线程(一)Java内存模型/","excerpt":"","text":"解析 在说Java内存模型之前，我们先说一下Java的内存结构，也就是运行时的数据区域，这一块前面的章节已经介绍过了，很多人容易把内存结构跟内存模型搞混，内存结构就是下图中内存空间这些东西，而Java内存模型，完全是另外的一个东西。 Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景下就不许针对不同的平台来编写程序。 1. 主内存与工作内存 Java内存模型的主要目的是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。注意一下，此处的变量并不包括局部变量与方法参数，因为它们是线程私有的，不会被共享，自然也不会存在竞争，此处的变量应该是实例字段、静态字段和构成数组对象的元素。 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量和主内存副本拷贝（注意这里绝不会是整个对象的拷贝，试想一个10M的对象，在每个用到这个对象的工作内存中有一个10M的拷贝，内存还受得了？也就是一些在线程中用到的对象中的字段罢了），线程对变量所有的操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成 2. 内存间交互操作 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面体积的每一种操作都是原子的、不可再分的 1、lock（锁定）：作用于主内存中的变量，它把一个变量标识为一条线程独占的状态 2、unlock（解锁）：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 3、read（读取）：作用于主内存中的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用 4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 5、use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，没当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作 6、assign（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作 7、store（存储）：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用 8、write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中 Java内存模型还规定了在执行上述8种基本操作时必须满足以下规则： 1、不允许read和load、store和write操作之一单独出现 2、不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了滞后必须把该变化同步回主内存 3、不允许一个线程无原因地把数据从线程的工作内存同步回主内存中 4、一个新的变量只能从主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量 5、一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁 6、如果对同一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值 7、如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁定的变量 8、对一个变量执行unlock操作之前，必须先把此变量同步回主内存中 3. 对于volatile型变量的特殊规则 关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制。 一个变量被定义为volatile后，它将具备两种特性： 1、保证此变量对所有线程的”可见性”，所谓”可见性”是指当一条线程修改了这个变量的值，新值对于其它线程来说都是可以立即得知的，而普通变量不能做到这一点，普通变量的值在在线程间传递均需要通过主内存来完成，关于volatile关键字的操作请参见volatile关键字使用举例，再强调一遍，volatile只保证了可见性，并不保证基于volatile变量的运算在并罚下是安全的 2、使用volatile变量的第二个语义是禁止指令重排序优化，普通变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 总结一下Java内存模型对volatile变量定义的特殊规则： 1、在工作内存中，每次使用某个变量的时候都必须线从主内存刷新最新的值，用于保证能看见其他线程对该变量所做的修改之后的值 2、在工作内存中，每次修改完某个变量后都必须立刻同步回主内存中，用于保证其他线程能够看见自己对该变量所做的修改 3、volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同 4. 原子性、可见性与有序性 1、原子性（Atomicity） 由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store、write，大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大的原子性保证，Java内存模型还提供了lock和unlock，尽管虚拟机没有把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—-synchronized关键字 2、可见性（Visibility） 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。volatile其实已经详细写了这一点，其实synchronized关键字也是可以实现可见性的，synchronized的可见性是由”对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。 3、有序性（Ordering） Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无须的。前半句是指”线程内表现为穿行的语义”，后半句是指”指令重排序”和”工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入 5. 先行发生原则 如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完成，那么有一些操作将变得很繁琐，但是我们在编写Java代码时并未感觉到这一点，这是因为Java语言中有一个”先行发生（happens-before）”原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则就判断出并发环境下两个操作之间是否可能存在冲突的问题。 所谓先行发生原则是指Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，那么操作A产生的影响能够被操作b观察到，”影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。Java内存模型下有一些天然的，不需要任何同步协助器就已经存在的先行发生关系： 1、程序次序规则：在一个线程内，按照控制流顺序，控制流前面的操作先行发生于控制流后面的操作，说”控制流”是因为还要考虑到分支、循环结构 2、管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作 3、volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作 4、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作 5、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测 6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 7、对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始 8、传递新：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A必然先行发生于操作C 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html https://baijiahao.baidu.com/s?id=1595082600371869908&amp;wfr=spider&amp;for=pc http://www.importnew.com/28456.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"字节码执行(二)基于栈的字节码解释器执行过程","slug":"backend/java/jvm1/JVM字节码执行(二)基于栈的字节码解释器执行过程","date":"2019-03-19T14:59:44.000Z","updated":"2019-03-25T13:02:01.181Z","comments":true,"path":"2019/03/19/backend/java/jvm1/JVM字节码执行(二)基于栈的字节码解释器执行过程/","link":"","permalink":"http://www.songshuiyang.site/2019/03/19/backend/java/jvm1/JVM字节码执行(二)基于栈的字节码解释器执行过程/","excerpt":"","text":"解析 根据一个代码实例来介绍虚拟机中解释器的执行过程 123456public int calculate()&#123; int a = 100; int b = 200; int c = 300; return (a + b) * c; &#125; 由上面的代码可以看出，该方法的逻辑很简单，就是进行简单的四则运算加减乘除，我们编译代码后使用javap -verbose命令查看字节码指令，具体字节码代码如下所示: 12345678910111213141516171819202122public int calculate(); Code: Stack=2, Locals=4, Args_size=1 0: bipush 100 2: istore_1 3: sipush 200 6: istore_2 7: sipush 300 10: istore_3 11: iload_1 12: iload_2 13: iadd 14: iload_3 15: imul 16: ireturn LineNumberTable: line 3: 0 line 4: 3 line 5: 7 line 6: 11 &#125; 根据字节码可以看出，这段代码需要深度为2的操作数栈（Stack=2）和4个Slot的局部变量空间（Locals=4）。下面，使用7张图片来描述上面的字节码代码执行过程中的代码、操作数栈和局部变量表的变化情况。 上图展示了执行偏移地址为0的指令的情况，bipush指令的作用是将单字节的整型常量值（-128~127）推入操作数栈顶，后跟一个参数，指明推送的常量值，这里是100。 上图则是执行偏移地址为2的指令，istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量Slot中。后面四条指令（3、6、7、10）都是做同样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。后面四条指令的图就不重复画了。 上面展示了执行偏移地址为11的指令，iload_1指令的作用是将局部变量第1个Slot中的整型值复制到操作数栈顶。 上图为执行偏移地址12的指令，iload_2指令的执行过程与iload_1类似，把第2个Slot的整型值入栈。 上图展示了执行偏移地址为13的指令情况，iadd指令的作用是将操作数栈中前两个栈顶元素出栈，做整型加法，然后把结果重新入栈。在iadd指令执行完毕后，栈中原有的100和200出栈，它们相加后的和300重新入栈。 上图为执行偏移地址为14的指令的情况，iload_3指令把存放在第3个局部变量Slot中的300入栈到操作数栈中。这时操作数栈为两个整数300,。 下一条偏移地址为15的指令imul是将操作数栈中前两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，这里和iadd指令执行过程完全类似，所以就不重复画图了。 上图是最后一条指令也就是偏移地址为16的指令的执行过程，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给此方法的调用者。到此为止，该方法执行结束。 注：上面的执行过程只是一种概念模型，虚拟机最终会对执行过程做出一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述。不过从这段程序的执行过程也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都是以操作数栈的出栈和入栈为信息交换途径。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/azhegps/article/details/54092466","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"字节码执行(一)运行时栈帧结构","slug":"backend/java/jvm1/JVM字节码执行(一)运行时栈帧结构","date":"2019-03-19T13:59:44.000Z","updated":"2019-03-25T13:02:01.173Z","comments":true,"path":"2019/03/19/backend/java/jvm1/JVM字节码执行(一)运行时栈帧结构/","link":"","permalink":"http://www.songshuiyang.site/2019/03/19/backend/java/jvm1/JVM字节码执行(一)运行时栈帧结构/","excerpt":"","text":"概述 前几章介绍了Class类的文件结构及类的加载，有了原材料及已经运送过来了，那么就要生产产品了，那么字节码的执行就在生产产品 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。 一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧的概念结构如下图所示： 运行时栈帧结构1. 局部变量表 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。 在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。 局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。 2. 操作数栈 操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。 当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。 另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠过程如下图： 3. 动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。 4. 方法返回地址 当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。 无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。 5. 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。 方法调用 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。 解析 如前所述，所有的方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可变的。也就是说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用成为解析。 JAVA中符号“编译器可知、运行期不可变”的方法包括：静态方法、私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这就决定了他们都不可能通过继承或别的方式重写其版本。因此都适合在类的加载阶段进行解析。 JAVA虚拟机里面提供了5条方法调用字节码指令。分别如下： 123456789invokestatic:调用静态方法invokespecial:调用实例构造器&lt;init&gt;方法、私有方法和父类方法（super(),super.method()）。invokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、final方法都是非虚方法)。invokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象。invokedynamic:现在运行时期动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条指令，分派逻辑都是固化在虚拟机里面的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 只要能被invokestatic和invokespecial指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载阶段就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法（还包括使用final修饰的方法，虽然final方法使用invokevirtual指令调用，因为final方法注定不会被重写，也就是无法被覆盖，也就无需对其进行多态选择）。 解析调用一定是一个静态的过程，在编译期间就可以完全确定，在类装载的解析阶段就会把涉及的符号引用全部转化为可确定的直接引用，不会延迟到运行期去完成。而分派调用可能是静态的也可能是动态的，根据分派一句的宗量数可分为单分派和多分派。因此分派可分为：静态单分派、静态多分派、动态单分派、动态多分派。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/xtayfjpk/article/details/41924283 https://www.cnblogs.com/chenyangyao/p/5305352.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"类加载机制(二)类加载器","slug":"backend/java/jvm1/JVM类加载机制(二)类加载器","date":"2019-03-18T13:59:44.000Z","updated":"2019-05-13T14:49:13.680Z","comments":true,"path":"2019/03/18/backend/java/jvm1/JVM类加载机制(二)类加载器/","link":"","permalink":"http://www.songshuiyang.site/2019/03/18/backend/java/jvm1/JVM类加载机制(二)类加载器/","excerpt":"","text":"解析1. 类加载器 虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类， 3种类加载器： 启动类加载器(Bootstrap ClassLoader)：负责加载JRE的核心类库（JAVA_HOME\\lib）目录中的类包，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。启动类加载器是无法被Java程序直接引用的。 扩展类加载器(Extension ClassLoader)：负责加载JRE扩展目录 （JAVA_HOME\\lib\\ext） 目录中的类包，或通过java.ext.dirs系统变量指定路径中的类库。开发者可以直接使用扩展类加载器。 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 例子： 寻找类加载器 123456789package com.neo.classloader;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader loader = Thread.currentThread().getContextClassLoader(); System.out.println(loader); System.out.println(loader.getParent()); System.out.println(loader.getParent().getParent()); &#125;&#125; 结果123sun.misc.Launcher$AppClassLoader@64fef26asun.misc.Launcher$ExtClassLoader@1ddd40f3null 从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 在执行非置信代码之前，自动验证数字签名。 动态地创建符合用户特定需要的定制化构建类。 从特定的场所取得java class，例如数据库中和网络中。 2. 自定义类加载器 通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.neo.classloader;import java.io.*;public class MyClassLoader extends ClassLoader &#123; private String root; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String className) &#123; String fileName = root + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getRoot() &#123; return root; &#125; public void setRoot(String root) &#123; this.root = root; &#125; public static void main(String[] args) &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot(\"E:\\\\temp\"); Class&lt;?&gt; testClass = null; try &#123; testClass = classLoader.loadClass(\"com.neo.classloader.Test2\"); Object object = testClass.newInstance(); System.out.println(object.getClass().getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3. 类的加载 类加载有三种方式 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别 Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 双亲委派模型 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 双亲委派机制: 1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行，如果一个人编写了一个恶意的基础类(java.lang.String)并装载到JVM中，将会引起多么可怕的后果，有了这个机制(java.lang.String)永远是由启动类加载器来加载参考转载 周志明版 《深入理解Java虚拟机》 http://www.importnew.com/25295.html https://www.cnblogs.com/ityouknow/p/5603287.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"类加载机制(一)类加载时机及过程","slug":"backend/java/jvm1/JVM类加载机制(一)类加载时机及过程","date":"2019-03-16T03:59:44.000Z","updated":"2019-03-25T13:02:01.194Z","comments":true,"path":"2019/03/16/backend/java/jvm1/JVM类加载机制(一)类加载时机及过程/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/java/jvm1/JVM类加载机制(一)类加载时机及过程/","excerpt":"","text":"什么是类的加载 虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口 类的生命周期 如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。下面我们就分别来看一下这五个过程。 1. 加载 加载的过程： 1、通过一个类的全限定名来获取其定义的二进制字节流。 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 加载.class文件的方式: 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件，比如java.lang.reflect.Proxy 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是Java堆中，在hotspot中它是存放在方法区中），这样便可以通过该对象访问方法区中的这些数据。 2. 验证 验证是为了确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。3. 准备 准备是为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行 4. 解析 解析是把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。5. 初始化 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。 在Java中对类变量进行初始值设定有两种方式： 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 JVM初始化步骤 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下五种(有且只有)： 1、Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 2、创建类的实例，也就是new的方式或者访问某个类或接口的静态变量，或者对该静态变量赋值，以及调用一个类的静态方法 3、使用java.lang.reflect包的方法对类进行反射调用的时候（如Class.forName(“com.shengsiyuan.Test”)） 4、初始化某个类的子类，如果父类没有初始化则其父类也会被初始化 5、当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 被动引用 通过子类引用父类的静态字段，不会导致子类初始化 通过数组定义来引用类，不会触发此类的初始化 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发 6.结束 在如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止总结 研究类加载全过程有助于连接JVM运行过程 深入了解java动态性（热部署，动态加载），提高程序的灵活性 参考转载 周志明版 《深入理解Java虚拟机》 http://www.importnew.com/25295.html https://www.cnblogs.com/ityouknow/p/5603287.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM类文件结构(三)字节码指令","slug":"backend/java/jvm1/JVM类文件结构(三)字节码指令","date":"2019-03-16T02:59:44.000Z","updated":"2019-03-19T14:43:16.758Z","comments":true,"path":"2019/03/16/backend/java/jvm1/JVM类文件结构(三)字节码指令/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/java/jvm1/JVM类文件结构(三)字节码指令/","excerpt":"","text":"解析 Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。由于JAVA虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码 伪代码执行模型 加载、存储指令12341）iload、iload&lt;n&gt;、lload、lload&lt;n&gt;、fload、fload&lt;n&gt;、dload、dload&lt;n&gt;、aload、aload&lt;n&gt;：将一个局部变量加载到操作数栈。2）istore、istore&lt;n&gt;、lstore、lstore&lt;n&gt;、fstore、fstore&lt;n&gt;、dstore、dstore&lt;n&gt;、astore、astore&lt;n&gt;：将一个数值从操作数栈存储到局部变量表。3）bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconstm1、iconst&lt;i&gt;、lconst&lt;l&gt;、fconst&lt;f&gt;、dconst_&lt;d&gt;：将一个常量加载到操作数栈。4）wide：扩充局部变量表的访问索引的指令。 示例： 代码 12345678910public static int methodE()&#123; int e = 100; int c = 300; int d = 300000; e++; ++e; --e; e--; return c + d + e;&#125; 对应的字节码 123456789101112131415161718192021222324252627282930public static int methodE(); Signature: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=0 0: bipush 100 2: istore_0 3: sipush 300 6: istore_1 7: ldc #5 // int 300000 9: istore_2 10: iinc 0, 1 13: iinc 0, 1 16: iinc 0, -1 19: iinc 0, -1 22: iload_1 23: iload_2 24: iadd 25: iload_0 26: iadd 27: ireturn LineNumberTable: line 40: 0 line 41: 3 line 42: 7 line 43: 10 line 44: 13 line 45: 16 line 46: 19 line 47: 22 运算指令1234567891011121）iadd、ladd、fadd、dadd：加法指令。2）isub、lsub、fsub、dsub：减法指令。3）imul、lmul、fmul、dmul：乘法指令。4）idiv、ldiv、fdiv、ddiv：除法指令。5）irem、lrem、frem、drem：求余指令。6）ineg、lneg、fneg、dneg：取反指令。7）ishl、ishr、iushr、lshl、lshr、lushr：位移指令。8）ior、lor：按位或指令。9）iand、land：按位与指令。10）ixor、lxor：按位异或指令。11）iinc：局部变量自增指令。12）dcmpg、dcmpl、fcmpg、fcmpl、lcmp：比较指令。 示例参照上例 类型转换指令121）int类型到long、float或者double类型，long类型到float、double类型，float类型到double类型：宽化类型转换（虚拟机直接支持）。2）i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f：窄化类型转换（显式指令）。 示例： 代码 12345678910public static void methodK()&#123; int i = 97; short i2s = (short) i; char i2c = (char) i; long i2l = i; float i2f = i; double i2d = i; float l2f = i2l; double l2d = i2l;&#125; 对应的字节码 123456789101112131415161718192021222324252627282930313233343536373839public static void methodK();Signature: ()Vflags: ACC_PUBLIC, ACC_STATICCode: stack=2, locals=11, args_size=0 0: bipush 97 2: istore_0 3: iload_0 4: i2s 5: istore_1 6: iload_0 7: i2c 8: istore_2 9: iload_0 10: i2l 11: lstore_3 12: iload_0 13: i2f 14: fstore 5 16: iload_0 17: i2d 18: dstore 6 20: lload_3 21: l2f 22: fstore 8 24: lload_3 25: l2d 26: dstore 9 28: return LineNumberTable: line 100: 0 line 101: 3 line 102: 6 line 103: 9 line 104: 12 line 105: 16 line 106: 20 line 107: 24 line 108: 28 对象创建与访问指令12345671）new ：创建类实例的指令。2）newarray、anewarray、multianewarray：创建数组的指令。3）getstatic、putstatic、getfield、putfield：访问类字段（类变量）和实例字段（实例变量）的指令。4）baload、caload、saload、iaload、laload、faload、daload、aaload：把一个数组元素加载到操作数栈的指令。5）bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore：把一个操作数栈的值存储到数组元素中的指令。6）arraylength：取数组长度的指令。7）instanceof、checkcast：检查类实例类型的指令。 示例： 代码 12345public static void methodJ()&#123; new SimpleMethodExecuteProcess(); System.out.println(SimpleMethodExecuteProcess.i);&#125; 对应的字节码 1234567891011121314151617public static void methodJ();Signature: ()Vflags: ACC_PUBLIC, ACC_STATICCode: stack=2, locals=0, args_size=0 0: new #9 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess 3: dup 4: invokespecial #10 // Method \"&lt;init&gt;\":()V 7: pop 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: getstatic #11 // Field i:I 14: invokevirtual #12 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 91: 0 line 93: 8 line 94: 17 操作数栈管理指令1231）pop、pop2：将操作数栈的栈顶一个或两个元素出栈。2）dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。3）swap：将栈最顶端两个数值互换 示例： 代码 123public static void main(String[] args) &#123; heavyMethod();&#125; 对应的字节码 1234567891011public static void main(java.lang.String[]); Signature: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=1, args_size=1 0: invokestatic #23 // Method heavyMethod:()I 3: pop 4: return LineNumberTable: line 115: 0 line 116: 4 控制转移指令1231）ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。2）tableswitch、lookupswitch：复合条件分支。3）goto、goto_w、jsr、jsr_w、ret：无条件分支。 示例： 代码 12345678910public static void methodG()&#123; if(i == 0)&#123; System.out.println(System.currentTimeMillis()); &#125; while(i &lt; 1)&#123; System.out.println(System.currentTimeMillis()); i++; &#125;&#125; 对应的字节码 1234567891011121314151617181920212223242526272829303132public static void methodG(); Signature: ()V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=0, args_size=0 0: getstatic #6 // Field i:I 3: ifne 15 6: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 9: invokestatic #7 // Method java/lang/System.currentTimeMillis:()J 12: invokevirtual #8 // Method java/io/PrintStream.println:(J)V 15: getstatic #6 // Field i:I 18: iconst_1 19: if_icmpge 42 22: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 25: invokestatic #7 // Method java/lang/System.currentTimeMillis:()J 28: invokevirtual #8 // Method java/io/PrintStream.println:(J)V 31: getstatic #6 // Field i:I 34: iconst_1 35: iadd 36: putstatic #6 // Field i:I 39: goto 15 42: return LineNumberTable: line 62: 0 line 63: 6 line 66: 15 line 67: 22 line 68: 31 line 70: 42 StackMapTable: number_of_entries = 2 frame_type = 15 /* same */ frame_type = 26 /* same */ 异常处理指令1athrow ：显式抛出异常指令。 示例： 代码 12345678public static void methodH()&#123; try &#123; throw new NullPointerException(\"nothing ...\"); // do nothing ... &#125; catch (Throwable t)&#123; // do nothing ... &#125;&#125; 对应的字节码 12345678910111213141516171819202122public static void methodH();Signature: ()Vflags: ACC_PUBLIC, ACC_STATICCode: stack=3, locals=1, args_size=0 0: new #9 // class java/lang/NullPointerException 3: dup 4: ldc #10 // String nothing ... 6: invokespecial #11 // Method java/lang/NullPointerException.\"&lt;init&gt;\":(Ljava/lang/String;)V 9: athrow 10: astore_0 11: return Exception table: from to target type 0 10 10 Class java/lang/Throwable LineNumberTable: line 77: 0 line 79: 10 line 82: 11 StackMapTable: number_of_entries = 1 frame_type = 74 /* same_locals_1_stack_item */ stack = [ class java/lang/Throwable ] 同步指令 1monitorenter、monitorexit：支持synchronized语句块语义的指令。 示例： 代码 12345public void methodI()&#123; synchronized (Integer.class)&#123; // do nothing ... &#125;&#125; 对应的字节码 123456789101112131415161718192021222324252627282930313233public void methodI();Signature: ()Vflags: ACC_PUBLICCode: stack=2, locals=3, args_size=1 0: ldc_w #13 // class java/lang/Integer 3: dup 4: astore_1 5: monitorenter 6: aload_1 7: monitorexit 8: goto 16 11: astore_2 12: aload_1 13: monitorexit 14: aload_2 15: athrow 16: return Exception table: from to target type 6 8 11 any 11 14 11 any LineNumberTable: line 88: 0 line 90: 6 line 91: 16 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 11 locals = [ class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4 synchronized 修饰方法的语义解析：可以直接从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法，不需要解析出monitorenter、monitorexit同步指令。 123456789101112131415public static synchronized void methodL()&#123; int i = 97;&#125; public static synchronized void methodL(); Signature: ()V flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED Code: stack=1, locals=1, args_size=0 0: bipush 97 2: istore_0 3: return LineNumberTable: line 120: 0 line 121: 3 方法调用和返回指令 1234561）invokestatic：调用静态方法。2）invokespecial：调用实例构造器&lt;init&gt;方法、私有方法和父类方法。3）invokevirtual：调用所有的虚方法。非虚方法以外的都是虚方法，非虚方法包括使用invokestatic、invokespecial调用的方法和被final修饰的方法。4）invokeinterface：调用接口方法，运行时再确定一个实现此接口的对象。5）invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。ireturn（返回值是boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn：方法返回指令。 示例： 代码 123456789101112131415public static int heavyMethod()&#123; int a = 200; int b = 100; int c = methodC(methodA(methodA(a, b), b), methodB(a, b)); methodD(); methodE(); methodF(); methodG(); methodH(); new SimpleMethodExecuteProcess().methodI(); methodJ(); methodK(); methodL(); return c;&#125; 对应的字节码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static int heavyMethod();Signature: ()Iflags: ACC_PUBLIC, ACC_STATICCode: stack=3, locals=3, args_size=0 0: sipush 200 3: istore_0 4: bipush 100 6: istore_1 7: iload_0 8: iload_1 9: invokestatic #17 // Method methodA:(II)I 12: iload_1 13: invokestatic #17 // Method methodA:(II)I 16: iload_0 17: iload_1 18: invokestatic #18 // Method methodB:(II)I 21: invokestatic #19 // Method methodC:(II)I 24: istore_2 25: invokestatic #20 // Method methodD:()V 28: invokestatic #21 // Method methodE:()I 31: pop 32: invokestatic #22 // Method methodF:()D 35: pop2 36: invokestatic #23 // Method methodG:()V 39: invokestatic #24 // Method methodH:()V 42: new #14 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess 45: dup 46: invokespecial #15 // Method \"&lt;init&gt;\":()V 49: invokevirtual #25 // Method methodI:()V 52: invokestatic #26 // Method methodJ:()V 55: invokestatic #27 // Method methodK:()V 58: invokestatic #28 // Method methodL:()V 61: iload_2 62: ireturn LineNumberTable: line 128: 0 line 129: 4 line 130: 7 line 131: 25 line 132: 28 line 133: 32 line 134: 36 line 135: 39 line 136: 42 line 137: 52 line 138: 55 line 139: 58 line 140: 61 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.51cto.com/damon188/2131035","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM类文件结构(二)Code属性","slug":"backend/java/jvm1/JVM类文件结构(二)Code属性","date":"2019-03-16T01:59:44.000Z","updated":"2019-03-19T14:43:16.497Z","comments":true,"path":"2019/03/16/backend/java/jvm1/JVM类文件结构(二)Code属性/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/java/jvm1/JVM类文件结构(二)Code属性/","excerpt":"","text":"解析 Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据 Java虚拟机执行字节码是基于栈的体系结构 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/yxwkf/p/5222589.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM类文件结构(一)Class类文件结构","slug":"backend/java/jvm1/JVM类文件结构(一)Class类文件结构","date":"2019-03-16T00:59:44.000Z","updated":"2019-03-19T14:43:16.634Z","comments":true,"path":"2019/03/16/backend/java/jvm1/JVM类文件结构(一)Class类文件结构/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/java/jvm1/JVM类文件结构(一)Class类文件结构/","excerpt":"","text":"解析 不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器直接生成)。 Class文件是一组以8位字节为基础单位的二进制流。各个数据项严格按顺序排列，没有不论什么分隔符。 Class文件格式採用一种类似于C语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。 无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。 image 使用以下的类进行说明： 123456789package com.test;public class Test &#123; private int m; public int getM()&#123; return m + 1; &#125;&#125; javap -verbose 执行后的可视byteCode（只存在两种数据类型：无符号数字与表）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Classfile /D:/workspace-github/jvm/target/production/jvm/com/songsy/Test.class Last modified 2019-3-16; size 361 bytes MD5 checksum bb8e54060828e4bf1f709c2f4434dca8 Compiled from \"Test.java\"public class com.songsy.Test minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#18 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #3.#19 // com/songsy/Test.m:I #3 = Class #20 // com/songsy/Test #4 = Class #21 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/songsy/Test; #14 = Utf8 getM #15 = Utf8 ()I #16 = Utf8 SourceFile #17 = Utf8 Test.java #18 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #19 = NameAndType #5:#6 // m:I #20 = Utf8 com/songsy/Test #21 = Utf8 java/lang/Object&#123; public com.songsy.Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 7: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/songsy/Test; public int getM(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 11: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/songsy/Test;&#125;SourceFile: \"Test.java\" 编译后的class文件例如以下： 1. 魔数与Class版本 每一个class文件的头4个字节称为魔数，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。非常多文件存储标准中都使用魔数来进行身份识别。譬如图片格式gif、jpeg等。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，由于文件拓展格式能够任意修改。Class文件的魔数为：0xCAFEBABE（咖啡宝贝？）。这个魔数似乎也预示着日后JAVA这个商标名称的出现。 第五六个字节是次版本（Minor Version）。第7和第8个字节是主版本（Major Version）。 高版本号的JDK能够向下兼容曾经版本号的Class文件，可是无法执行以后版本号的Class文件，即使文件格式并未发生变化，虚拟机也必须拒绝执行超过其版本号号的Class文件。 2. 常量池 紧接着版本之后就是常量池，常量池能够理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之中的一个。同一时候也是在Class文件里第一个出现的表类型数据项目 常量池中主要存放两大类常量 字面量和符号引用。字面量如文本字符串、声明为final的常量值等 符号引用包含三类常量：类和接口的全限定名、字段的名称和描写叙述符、方法的名称和描写叙述符。 3. 访问标志 在常量池结束之后，紧接着的两个字节代表訪问标志。用于识别一些类或者接口层次的訪问信息。包括：这个类是Class类还是接口；是否定义为public类型，是否被声明为final，具体的标志位及其含义例如以下表所看到的。 依据上面的表格，測试类的訪问标志0x0021= 0x0001 | 0x0020 =ACC_PUBLIC | ACC_SUPER 4. 类索引、父类索引和接口索引集合 Class文件里由这3项数据来确定这个类的继承关系 this_class：类索引，用于确定这个类的全限定名，占2字节 super_class：父类索引。用于确定这个类父类的全限定名（Java语言不同意多重继承，故父类索引仅仅有一个。除了java.lang.Object类之外全部类都有父类，故除了java.lang.Object类之外，全部类该字段值都不为0），占2字节 interfaces_count：接口索引计数器。占2字节。接口索引计数器。占2字节。 interfaces：接口索引集合，一组u2类型数据的集合。用来描写叙述这个类实现了哪些接口。这些被实现的接口将按implements语句（假设该类本身为接口，则为extends语句）后的接口顺序从左至右排列在接口的索引集合中 this_class、super_class与interfaces中保存的索引值均指向常量池中一个CONSTANT_Class_info类型的常量。通过这个常量中保存的索引值能够找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串this_class的值为0x0001，即常量池中第一个常量，super_class的值为0x0003，即常量池中的第三个常量，interfaces_counts的值为0x0000，故接口索引集合大小为0 5. 字段表集合 字段表用于描写叙述接口或者类中声明的变量，包含类级变量和实例级变量(是否是static)。但不包含在方法内部声明的局部变量。 fields_count：字段表计数器。即字段表集合中的字段表数据个数。占2字节，其值为0x0001，即仅仅有一个字段表数据。也就是測试类中仅仅包括一个变量（不算方法内部变量） 字段表集合，一组字段表类型数据的集合。字段表用于描写叙述接口或类中声明的变量。包含类级别（static）和实例级别变量，不包含在方法内部声明的变量 6. 方法表集合 methods_count：方法表计数器，即方法表集合中的方法表数据个数。占2字节，其值为0x0002，即測试类中有2个方法(还自己主动添加了一个构造函数） methods：方法表集合，一组方法表类型数据的集合。方法表结构和字段表结构一样： 7. 属性表集合 在Class文件、属性表、方法表中都能够包括自己的属性表集合。用于描写叙述某些场景的专有信息 与Class文件里其他数据项对长度、顺序、格式的严格要求不同，属性表集合不要求当中包括的属性表具有严格的顺序，而且仅仅要属性的名称不与已有的属性名称反复。不论什么人实现的编译器可以向属性表中写入自定义的属性信息。虚拟机在执行时会忽略不能识别的属性，为了能正确解析Class文件 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/yxwkf/p/5222589.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(五)GC分析","slug":"backend/java/jvm1/JVM垃圾回收(五)GC分析","date":"2019-03-11T15:59:44.000Z","updated":"2019-03-26T13:58:09.171Z","comments":true,"path":"2019/03/11/backend/java/jvm1/JVM垃圾回收(五)GC分析/","link":"","permalink":"http://www.songshuiyang.site/2019/03/11/backend/java/jvm1/JVM垃圾回收(五)GC分析/","excerpt":"","text":"GC日志查看 可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。GC的日志是以替换的方式(&gt;)写入的，而不是追加(&gt;&gt;)，如果下次写入到同一个文件中的话，以前的GC内容会被清空。 对应的参数列表 123456-XX:+PrintGC 输出GC日志-XX:+PrintGCDetails 输出GC的详细日志-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息-Xloggc:../logs/gc.log 日志文件的输出路径 示例 -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs 新生代回收日志 12342014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K-&gt;2K(948864K), 0.0059180 secs] 2186589K-&gt;1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]``` ```sql2014-07-18T16:02:17.606+0800（当前时间戳）: 611.633（时间戳）: [GC（表示Young GC） 611.633: [DefNew（单线程Serial年轻代GC）: 843458K（年轻代垃圾回收前的大小）-&gt;2K（年轻代回收后的大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）] 2186589K（整个堆回收前的大小）-&gt;1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）] 老年代回收的日志如下：12014-07-18T16:19:16.794+0800: 1630.821: [GC 1630.821: [DefNew: 1005567K-&gt;111679K(1005568K), 0.9152360 secs]1631.736: [Tenured:2573912K-&gt;1340650K(2574068K), 1.8511050 secs] 3122548K-&gt;1340650K(3579636K), [Perm : 17882K-&gt;17882K(21248K)], 2.7854350 secs] [Times: user=2.57 sys=0.22, real=2.79 secs] # 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/qlqwjy/p/7929414.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(四)常用参数","slug":"backend/java/jvm1/JVM垃圾回收(四)常用参数","date":"2019-03-11T13:59:44.000Z","updated":"2019-03-26T11:02:02.723Z","comments":true,"path":"2019/03/11/backend/java/jvm1/JVM垃圾回收(四)常用参数/","link":"","permalink":"http://www.songshuiyang.site/2019/03/11/backend/java/jvm1/JVM垃圾回收(四)常用参数/","excerpt":"","text":"JVM参数的含义 参数名称 含义 默认值 备注 -Xms 初始堆大小starting 物理内存的1/64(&lt;1GB) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. -Xmx 最大堆大小max 物理内存的1/4(&lt;1GB) 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 -Xmn 年轻代大小(1.4or lator)new 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 物理内存的1/64 -XX:MaxPermSize 设置持久代最大值 物理内存的1/4 -Xss 每个线程的堆栈大小 JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:””-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。 -XX:ThreadStackSize Thread Stack Size -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置 -XX:SurvivorRatio Eden区与Survivor区的大小比值 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 -XX:LargePageSizeInBytes 内存页的大小不可设置过大， 会影响Perm的大小 =128m -XX:+UseFastAccessorMethods 原始类型的快速优化 -XX:+DisableExplicitGC 关闭System.gc() 这个参数需要严格的测试 -XX:MaxTenuringThreshold 垃圾最大年龄 如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效 -XX:+AggressiveOpts 加快编译 -XX:+UseBiasedLocking 锁机制的性能改善 -Xnoclassgc 禁用垃圾回收 -XX:SoftRefLRUPolicyMSPerMB 每兆堆空闲空间中SoftReference的存活时间 1s -XX:PretenureSizeThreshold 对象超过多大是直接在旧生代分配 0 单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. -XX:TLABWasteTargetPercent TLAB占eden区的百分比 1% -XX:+CollectGen0First FullGC时是否先YGC false 并行收集器相关参数 参数名称 含义 默认值 备注 -XX:+UseParallelGC Full GC采用parallel MSC(此项待验证) 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) -XX:+UseParNewGC 设置年轻代为并行收集 可与CMS收集同时使用JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 -XX:ParallelGCThreads 并行收集器的线程数 此值最好配置与处理器数目相等 同样适用于CMS -XX:+UseParallelOldGC 年老代垃圾收集方式为并行收集(Parallel Compacting) 这个是JAVA 6出现的参数选项 -XX:MaxGCPauseMillis 每次年轻代垃圾回收的最长时间(最大暂停时间) 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. -XX:+UseAdaptiveSizePolicy 自动选择年轻代区大小和相应的Survivor区比例 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. -XX:GCTimeRatio 设置垃圾回收时间占程序运行时间的百分比 公式为1/(1+n) -XX:+ScavengeBeforeFullGC Full GC前调用YGC true Do young generation GC prior to a full GC. (Introduced in 1.4.1.) CMS相关参数 参数名称 含义 默认值 备注 -XX:+UseConcMarkSweepGC 使用CMS内存收集 -XX:+AggressiveHeap 试图是使用大量的物理内存长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升） -XX:CMSFullGCsBeforeCompaction 多少次后进行内存压缩 由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理. -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX+UseCMSCompactAtFullCollection 在FULL GC的时候， 对年老代的压缩 CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片 -XX:+UseCMSInitiatingOccupancyOnly 使用手动定义初始化定义开始CMS收集 禁止hostspot自行触发CMS GC -XX:CMSInitiatingOccupancyFraction=70 使用cms作为垃圾回收使用70％后开始CMS收集 92 为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式 -XX:CMSInitiatingPermOccupancyFraction 设置Perm Gen使用到达多少比率时触发 92 -XX:+CMSIncrementalMode 设置为增量模式 用于单CPU情况 -XX:+CMSClassUnloadingEnabled 辅助参数 参数名称 含义 默认值 备注 -XX:+PrintGC 输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143 secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] -XX:+PrintGCDetails 输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime 打印垃圾回收期间程序暂停的时间.可与上面混合使用 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] -XX:+PrintGCApplicationConcurrentTime 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 输出形式:Total time for which application threads were stopped: 0.0468229 seconds -XX:+PrintHeapAtGC 打印GC前后的详细堆栈信息 -Xloggc:filename 把相关日志信息记录到文件以便分析，与上面几个配合使用 -XX:+PrintClassHistogram garbage collects before printing the histogram. -XX:+PrintTLAB 查看TLAB空间的使用情况 XX:+PrintTenuringDistribution 查看每次minor GC后新的存活周期的阈值 Desired survivor size 1048576 bytes, new threshold 7 (max 15)new threshold 7即标识新的存活周期的阈值为7。 备注 -X 开头参数的是非标准，不是所有虚拟机都支持，-XX更流氓，不保证其稳定性 参考转载 周志明版 《深入理解Java虚拟机》 http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(三)内存分配及回收策略","slug":"backend/java/jvm1/JVM垃圾回收(三)内存分配及回收策略","date":"2019-03-10T14:59:44.000Z","updated":"2019-03-26T13:00:18.022Z","comments":true,"path":"2019/03/10/backend/java/jvm1/JVM垃圾回收(三)内存分配及回收策略/","link":"","permalink":"http://www.songshuiyang.site/2019/03/10/backend/java/jvm1/JVM垃圾回收(三)内存分配及回收策略/","excerpt":"","text":"概述 Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。 对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 TLAB: 首先讲讲什么是TLAB。内存分配的动作，可以按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。这么做的目的之一，也是为了并发创建一个对象时，保证创建对象的线程安全性。TLAB比较小，直接在TLAB上分配内存的方式称为快速分配方式，而TLAB大小不够，导致内存被分配在Eden区的内存分配方式称为慢速分配方式。 接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。由于条件因素，只能在Client模式下测试，因此CMS和G1并未提及。解析 1. 对象优先在Eden分配 所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。 新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。 老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。这时会把存活的对象转移进Survivor区。 Minor GC 新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。 Major GC 老年代GC，指发生在老年代的GC。 Full GC 包括前两个 举例说明 下面的代码来看一下jvm具体是怎样分配的，下面的代码注释有详细解释 1234567891011121314151617181920212223242526272829303132333435/** * VM参数： * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC * 参数解析： * * 初始堆大小为20兆，不可扩展，年轻代大小为10兆剩下的10兆分配给老年代，PrintGCDetails打印内存回收日志，SurvivorRatio标识 eden与Survivor比例为8:1 * * \"eden space 8192K from space 1024K to space 1024K\" 新生代总可用空间为9216KB (一个Eden区 + 一个Survivor区) * @author songsy * @date 2019/3/11 18:37 */public class Jvm1 &#123; private static final int _1KB = 1024; private static final int _1MB = 1024 * _1KB; public static void testAllocation() &#123; byte [] allocation1,allocation2, allocation3,allocation4,allocation5; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; /** * 执行到下一步出现一次Minor GC，因为发现Eden已经被占用了6Mb，剩余空间装不下4Mb， * 执行gc的时候发现已有3*2Mb的对象无法放入Survivor（只有1mb）空间，所以只好通过 * 分配担保机制提前转移到老年代去 */ allocation4 = new byte[4 * _1MB]; /** * Gc结束，4Mb的allocation4对象将分配在Eden区，老年代占用6Mb */ &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125;``` * 输出日志 [GC[DefNew: 7485K-&gt;526K(9216K), 0.0076710 secs] 7485K-&gt;6671K(19456K), 0.0077381 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]Heapdef new generation total 9216K, used 4952K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)eden space 8192K, 54% used [0x00000000f9a00000, 0x00000000f9e526c8, 0x00000000fa200000)from space 1024K, 51% used [0x00000000fa300000, 0x00000000fa383bd8, 0x00000000fa400000)to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)tenured generation total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)compacting perm gen total 21248K, used 2950K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 13% used [0x00000000fae00000, 0x00000000fb0e1918, 0x00000000fb0e1a00, 0x00000000fc2c0000)No shared spaces configured. 1234567891011121314151617181920212223242526272829### 2. 大对象直接进入老年代* 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）。* 虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。* 举例说明 ```java /** * 测试大对象直接进入老年代 * * VM参数： * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC * -XX:PretenureSizeThreshold=3145728 可选 * * @author songsy * @date 2019/3/11 18:37 */ public class Jvm2 &#123; private static final int _1KB = 1024; private static final int _1MB = 1024 * _1KB; public static void testAllocation() &#123; byte [] allocation1; // 直接分配在老年代 allocation1 = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testAllocation(); &#125; &#125; 没设置PretenureSizeThreshold，可以看到新生代def new generation total 9216K, used 5773K，老年代tenured generation total 10240K, used 0K 12345678910Heap def new generation total 9216K, used 5773K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 70% used [0x00000000f9a00000, 0x00000000f9fa3668, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) to space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) tenured generation total 10240K, used 0K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 0% used [0x00000000fa400000, 0x00000000fa400000, 0x00000000fa400200, 0x00000000fae00000) compacting perm gen total 21248K, used 3237K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 15% used [0x00000000fae00000, 0x00000000fb129600, 0x00000000fb129600, 0x00000000fc2c0000)No shared spaces configured. * 设置了PretenureSizeThreshold结果，可以看到新生代`def new generation total 9216K, used 1671K` ,老年代`tenured generation total 10240K, used 4096K` 12345678910Heap def new generation total 9216K, used 1671K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 20% used [0x00000000f9a00000, 0x00000000f9ba1c08, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) to space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) tenured generation total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000) compacting perm gen total 21248K, used 2938K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 13% used [0x00000000fae00000, 0x00000000fb0de9e0, 0x00000000fb0dea00, 0x00000000fc2c0000)No shared spaces configured. 3. 长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象放在新生代，那些对象放在老年代中 为了能做到这一点，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 举例说明 1234567891011121314151617181920212223242526272829/** * 测试长期存活的对象进入老年代 * * VM参数： * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC * -XX:MaxTenuringThreshold=1 可选 * * @author songsy * @date 2019/3/11 18:37 */public class Jvm3 &#123; private static final int _1KB = 1024; private static final int _1MB = 1024 * _1KB; public static void testAllocation() &#123; byte [] allocation1,allocation2, allocation3; allocation1 = new byte[_1MB / 4]; allocation2 = new byte[4 * _1MB]; allocation3 = new byte[4 * _1MB]; // 虽然此处赋值为null，但未进行Gc空间仍被占用，下一行代码会执行minor GC allocation3 = null; // 将MaxTenuringThreshold设为1，可以看出第二次Minor GC时，年轻代已经被清空，allocation1对象因为年龄符合MaxTenuringThreshold设置的值，因此进入老年代。 allocation3 = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125; 4. 动态对象年龄判定 为了能更好的适应不同程序的内存状态，虚拟机并不是永远的要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代的 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 5. 空间分配担保 内存分配是在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。 Parallel Scavenge收集器与其他收集器在空间分配担保上有一点差别, 正常是在Minor GC前进行检查, 而Parallel Scavenge收集器在Minor GC后也会进行检查。 另外当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/v123411739/article/details/78941793","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(二)垃圾回收器","slug":"backend/java/jvm1/JVM垃圾回收(二)垃圾回收器","date":"2019-03-10T13:59:50.000Z","updated":"2019-03-26T13:22:03.471Z","comments":true,"path":"2019/03/10/backend/java/jvm1/JVM垃圾回收(二)垃圾回收器/","link":"","permalink":"http://www.songshuiyang.site/2019/03/10/backend/java/jvm1/JVM垃圾回收(二)垃圾回收器/","excerpt":"","text":"概述 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的回收器可能会有很大差异，一般是提供参数供用户根据自己的应用特点和要求组合各个年代所使用的回收器 这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图3-5所示，上半部分是新生代的回收器，下半部分是老年代的回收器 1. Serial 收集器 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。 大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。 新生代采用复制算法，老年代采用标记-整理算法。 虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。 但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。 2. Serial Old 收集器 Serial收集器的老年代版本，它同样是一个单线程收集器。 它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。 3. ParNew 收集器 ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。 新生代采用复制算法，老年代采用标记-整理算法。 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。 并行和并发概念补充： 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。 4. Parallel Old收集器 Parallel Scavenge收集器的老年代版本。 使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。 5. Parallel Scavenge收集器 Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。 1234567-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行-XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 新生代采用复制算法，老年代采用标记-整理算法。 6. CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对CPU资源敏感 无法处理浮动垃圾 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生7. G1收集器 G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点 G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。 G1收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html https://blog.csdn.net/qq_34337272/article/details/82177383","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(一)垃圾回收算法","slug":"backend/java/jvm1/JVM垃圾回收(一)垃圾回收算法","date":"2019-03-10T13:59:44.000Z","updated":"2019-04-23T12:04:15.397Z","comments":true,"path":"2019/03/10/backend/java/jvm1/JVM垃圾回收(一)垃圾回收算法/","link":"","permalink":"http://www.songshuiyang.site/2019/03/10/backend/java/jvm1/JVM垃圾回收(一)垃圾回收算法/","excerpt":"","text":"概述 猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。 而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。 判断对象是否存活的算法 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧） 1. 引用计数法 给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。 一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。 2. 可达性分析算法 通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。 image 上图中每个对象都存在引用链与GCRoots相连，表明对象还在，不能回收。有图中三个对象虽然互相引用，但是没有链接与GCRoots相连，则可判断它们是可回收的对象。 什么对象可以为GCRoots， 虚拟机栈中本地变量表引用的对象，局部变量 方法区中的类静态变量引用的对象及常量引用的对象 本地方法栈中JNI引用的对象 彻底死亡条件： 条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。 条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。 引用 强引用Object o = new Object() 软引用SoftReference 定义了软引用对象之后，GC可达的算法就切断与此对象的连接，那么下次垃圾回收的时候就会优化回收此对象 弱引用 虚引用 垃圾回收算法1. 标记-清除算法 该算法是最基础的收集算法，算法分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象 之所以说它是最基础的算法是因为后续的算法都是基于这种思路并对其不足进行改进而得到的 缺点 效率不足 会产生大量不连续的内存碎片，碎片过多的话再分配一个较大对象时就无容身之地从而不得不提前触发另一次垃圾收集 2. 复制算法 为了解决效率问题，此算法把内存划分为相等大小的两个区域，每一只使用其中一个，回收过程中将存活的对象全部复制到另一个区域中，清空原区域。在年轻代中eden区和两个survivor区就是使用了此种算法。这种算法只复制存活的对象，成本较低，而且不会出现内存碎片问题 现在的商业虚拟机都采用这种算法来回收新生代 缺点 费内存，需要2倍的内存空间 3. 标记-整理算法 该算法标记阶段和标记-清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。效率比“标记-清理”算法低，但不会产生内存碎片。 4. 分代收集算法 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/aspirant/p/8662690.html http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM内存溢出异常(一)OutOfMemoryError","slug":"backend/java/jvm1/JVM内存溢出异常(一)OutOfMemoryError","date":"2019-03-04T05:59:44.000Z","updated":"2019-03-25T13:02:01.134Z","comments":true,"path":"2019/03/04/backend/java/jvm1/JVM内存溢出异常(一)OutOfMemoryError/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/java/jvm1/JVM内存溢出异常(一)OutOfMemoryError/","excerpt":"","text":"在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有可能发生OutOfMemoryError（OOM）异常的可能，下面将介绍这些运行时区域出现OOM的场景及解决方法 Java堆溢出 Java堆用于存储对象实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制之后就会产生内存溢出异常 测试代码 12345678910111213141516171819/** * Java堆内存异常测试 * * VM参数： * -Xms20M -Xmx20M -XX:+HeapDumpOnOutOfMemoryError * 堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展 * @author songsy * @date 2019/3/22 18:37 */public class Jvm4 &#123; public static void main(String[] args) &#123; List&lt;Jvm4&gt; list = new ArrayList&lt;&gt;(); while (true) &#123; list.add(new Jvm4()); &#125; &#125;&#125; 输出结果 1234567891011java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid17684.hprof ...Heap dump file created [29356301 bytes in 0.114 secs]Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:2245) at java.util.Arrays.copyOf(Arrays.java:2219) at java.util.ArrayList.grow(ArrayList.java:242) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:216) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:208) at java.util.ArrayList.add(ArrayList.java:440) at com.songsy.Jvm4.main(Jvm4.java:24) 我们可以在vm参数中配置-XX:+HeapDumpOnOutOfMemoryError参数，配置完成之后如果程序发生了OutOfMemoryError后会生成堆转储快照文件java_pid17684.hprof 通过JProfiler打开此文件，发现都是com.songsy.Jvm4.main对象，原因是因为虚拟机限制了堆的最大空间(-Xmx20M)。当准备创建的对象需要的内存已经超过虚拟机堆所剩的空间。虚拟机会尝试通过full GC来回收内存，如果不行的话，就会抛出OutOfMemoryError 虚拟机栈和本地方法栈溢出 由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。 关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常： 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。 测试代码： 1234567891011121314151617181920212223242526/** * 测试 StackOverflowError异常 * VM Args：-Xss128k * @author songsy * @date 2019/3/22 16:31 */public class JavaVMStackSOF &#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; public static void main(String[] args) throws Throwable &#123; JavaVMStackSOF oom = new JavaVMStackSOF(); try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; // 抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。 System.out.println(\"stack length:\" + oom.stackLength); throw e; &#125; &#125;&#125; 输出结果 12345stack length:11424Exception in thread \"main\" java.lang.StackOverflowError at com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:13) at com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:14) at com.songsy.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:14) 测试代码2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285/** * 测试 StackOverflowError异常 * VM Args：-Xss128k * @author songsy * @date 2019/3/22 17:15 */public class JavaVMStackSOF1 &#123; private int stackLength = 1; public void stackLeak() &#123; stackLength++; stackLeak(); &#125; public static void main(String[] args) &#123; JavaVMStackSOF1 oom = new JavaVMStackSOF1(); long e0 = 1; long e1 = 1; long e2 = 1; long e3 = 1; long e4 = 1; long e5 = 1; long e6 = 1; long e7 = 1; long e8 = 1; long e9 = 1; long q0 = 1; long q1 = 1; long q2 = 1; long q3 = 1; long q4 = 1; long q5 = 1; long q6 = 1; long q7 = 1; long q8 = 1; long q9 = 1; long r0 = 1; long r1 = 1; long r2 = 1; long r3 = 1; long r4 = 1; long r5 = 1; long r6 = 1; long r7 = 1; long r8 = 1; long r9 = 1; long t0 = 1; long t1 = 1; long t2 = 1; long t3 = 1; long t4 = 1; long t5 = 1; long t6 = 1; long t7 = 1; long t8 = 1; long t9 = 1; long y0 = 1; long y1 = 1; long y2 = 1; long y3 = 1; long y4 = 1; long y5 = 1; long y6 = 1; long y7 = 1; long y8 = 1; long y9 = 1; long u0 = 1; long u1 = 1; long u2 = 1; long u3 = 1; long u4 = 1; long u5 = 1; long u6 = 1; long u7 = 1; long u8 = 1; long u9 = 1; long i0 = 1; long i1 = 1; long i2 = 1; long i3 = 1; long i4 = 1; long i5 = 1; long i6 = 1; long i7 = 1; long i8 = 1; long i9 = 1; long o0 = 1; long o1 = 1; long o2 = 1; long o3 = 1; long o4 = 1; long o5 = 1; long o6 = 1; long o7 = 1; long o8 = 1; long o9 = 1; long p0 = 1; long p1 = 1; long p2 = 1; long p3 = 1; long p4 = 1; long p5 = 1; long p6 = 1; long p7 = 1; long p8 = 1; long p9 = 1; long a0 = 1; long a1 = 1; long a2 = 1; long a3 = 1; long a4 = 1; long a5 = 1; long a6 = 1; long a7 = 1; long a8 = 1; long a9 = 1; long s0 = 1; long s1 = 1; long s2 = 1; long s3 = 1; long s4 = 1; long s5 = 1; long s6 = 1; long s7 = 1; long s8 = 1; long s9 = 1; long d0 = 1; long d1 = 1; long d2 = 1; long d3 = 1; long d4 = 1; long d5 = 1; long d6 = 1; long d7 = 1; long d8 = 1; long d9 = 1; long f0 = 1; long f1 = 1; long f2 = 1; long f3 = 1; long f4 = 1; long f5 = 1; long f6 = 1; long f7 = 1; long f8 = 1; long f9 = 1; long g0 = 1; long g1 = 1; long g2 = 1; long g3 = 1; long g4 = 1; long g5 = 1; long g6 = 1; long g7 = 1; long g8 = 1; long g9 = 1; long h0 = 1; long h1 = 1; long h2 = 1; long h3 = 1; long h4 = 1; long h5 = 1; long h6 = 1; long h7 = 1; long h8 = 1; long h9 = 1; long j0 = 1; long j1 = 1; long j2 = 1; long j3 = 1; long j4 = 1; long j5 = 1; long j6 = 1; long j7 = 1; long j8 = 1; long j9 = 1; long k0 = 1; long k1 = 1; long k2 = 1; long k3 = 1; long k4 = 1; long k5 = 1; long k6 = 1; long k7 = 1; long k8 = 1; long k9 = 1; long l0 = 1; long l1 = 1; long l2 = 1; long l3 = 1; long l4 = 1; long l5 = 1; long l6 = 1; long l7 = 1; long l8 = 1; long l9 = 1; long z0 = 1; long z1 = 1; long z2 = 1; long z3 = 1; long z4 = 1; long z5 = 1; long z6 = 1; long z7 = 1; long z8 = 1; long z9 = 1; long c0 = 1; long c1 = 1; long c2 = 1; long c3 = 1; long c4 = 1; long c5 = 1; long c6 = 1; long c7 = 1; long c8 = 1; long c9 = 1; long v0 = 1; long v1 = 1; long v2 = 1; long v3 = 1; long v4 = 1; long v5 = 1; long v6 = 1; long v7 = 1; long v8 = 1; long v9 = 1; long b0 = 1; long b1 = 1; long b2 = 1; long b3 = 1; long b4 = 1; long b5 = 1; long b6 = 1; long b7 = 1; long b8 = 1; long b9 = 1; long n0 = 1; long n1 = 1; long n2 = 1; long n3 = 1; long n4 = 1; long n5 = 1; long n6 = 1; long n7 = 1; long n8 = 1; long n9 = 1; long m0 = 1; long m1 = 1; long m2 = 1; long m3 = 1; long m4 = 1; long m5 = 1; long m6 = 1; long m7 = 1; long m8 = 1; long m9 = 1; long qq0 = 1; long qq1 = 1; long qq2 = 1; long qq3 = 1; long qq4 = 1; long qq5 = 1; long qq6 = 1; long qq7 = 1; long qq8 = 1; long qq9 = 1; long ww0 = 1; long ww1 = 1; long ww2 = 1; long ww3 = 1; long ww4 = 1; long ww5 = 1; long ww6 = 1; long ww7 = 1; long ww8 = 1; long ww9 = 1; try &#123; oom.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println(\"stack length:\" + oom.stackLength); throw e; &#125; &#125;&#125; 实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。 如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常，如代码清单2-5所示。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。 其实原因不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。 方法区和运行时常量池溢出 由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。 String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量，如代码清单2-6所示。 测试代码 123456789101112131415161718/** * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M * @author songsy * @date 2019/3/22 17:31 */public class RuntimeConstantPoolOOM &#123; public static void main(String[] args) &#123; // 使用List保持着常量池引用，避免Full GC回收常量池行为 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); // 10MB的PermSize在integer范围内足够产生OOM了 int i = 0; while (true) &#123; list.add(String.valueOf(i++).intern()); System.out.println(String.valueOf(i++).intern()); &#125; &#125;&#125; 输出结果 123Exception in thread \"main\" java.lang.OutOfMemoryError: PermGen space at java.lang.String.intern(Native Method) at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18) 从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。在代码清单2-8中，笔者借助CGLib直接操作字节码运行时生成了大量的动态类。 值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中：当前的很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。另外，JVM上的动态语言（例如Groovy等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与代码清单2-8相似的溢出场景。 代码清单2-8 借助CGLib使方法区出现内存溢出异常 1234567891011121314151617181920212223242526/** * VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M * @author songsy * @date 2019/3/22 17:45 */public class JavaMethodAreaOOM &#123; public static void main(String[] args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125; static class OOMObject &#123; &#125;&#125; 输出结果 12345Caused by: java.lang.OutOfMemoryError: PermGen space at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) at java.lang.ClassLoader.defineClass(ClassLoader.java:616) ... 8 more 方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。 本机直接内存溢出 直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。 特点 本机直接内存的分配不会受到Java 堆大小的限制，受到本机总内存大小限制 直接内存也可以由 -XX:MaxDirectMemorySize 指定 直接内存申请空间耗费更高的性能 直接内存IO读写的性能要优于普通的堆内存 当我们的需要频繁访问大的内存而不是申请和释放空间时，通过使用直接内存可以提高性能。 直接内存溢出测试，测试代码如下，运行时添加参数-Xmx20M -XX:MaxDirectMemorySize=10M 设置降低直接内存的空间来加快异常的抛出 测试代码： 12345678910111213141516171819/** * 本机直接内存溢出 * VM args:-Xmx20M -XX:MaxDirectMemorySize=10M * @author songsy * @date 2019/3/22 18:08 */public class DirectMemoryOOM &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception &#123; Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 输出结果 123Exception in thread \"main\" java.lang.OutOfMemoryError at sun.misc.Unsafe.allocateMemory(Native Method) at com.songsy.DirectMemoryOOM.main(DirectMemoryOOM.java:22) 由DirectMemory导致的内存溢出，一个明显的特征就是再Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接的使用了NIO，那就可以考虑检查一下是不是这方面的原因。 内存溢出及内存泄漏1、内存溢出 out of memory 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出 1.1 方法区溢出 out of memory: PermGen space1.2 本机直接内存溢出2、内存泄露 memory leak 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光 memory leak会最终会导致out of memory！ 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 3、引起内存溢出的原因 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体； 使用的第三方软件中的BUG； 启动参数内存值设定的过小； 4、内存溢出的解决方案 修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。) 检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。 对代码进行走查和分析，找出可能发生内存溢出的位置。 其他 java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -Xmx3550m：设置JVM最大可用内存为3550M。 -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/Sharley/p/5285045.html https://blog.csdn.net/u012552052/article/details/44204735 https://blog.csdn.net/sells2012/article/details/18656263","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(六)方法区","slug":"backend/java/jvm1/JVM运行时数据区域(六)方法区","date":"2019-03-04T05:59:44.000Z","updated":"2019-04-23T12:04:15.416Z","comments":true,"path":"2019/03/04/backend/java/jvm1/JVM运行时数据区域(六)方法区/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/java/jvm1/JVM运行时数据区域(六)方法区/","excerpt":"","text":"概述 方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。 对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。 Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。 运行时常量池 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常* 量池中。 运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常 1. String 类和常量池 直接使用双引号声明出来的 String 对象会直接存储在常量池中。 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。 123456789101112131415161718192021// 第一种方式是在常量池中拿对象String str1 = \"abcd\";// 第二种方式是直接在堆内存空间创建一个新的对象。 String str2 = new String(\"abcd\");System.out.println(str1==str2);//false``` #### 2. 8种基本类型的包装类和常量池* Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。* 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。```javaInteger i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);// 输出trueInteger i11 = 333;Integer i22 = 333;System.out.println(i11 == i22);// 输出falseDouble i3 = 1.2;Double i4 = 1.2;System.out.println(i3 == i4);// 输出false 备注 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。 JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。 JDK1.7 就开始“去永久代”的工作了。 1.7把字符串常量池从永久代中剥离出来，存放在堆空间中。 参考转载 周志明版 《深入理解Java虚拟机》","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(五)堆","slug":"backend/java/jvm1/JVM运行时数据区域(五)堆","date":"2019-03-04T04:59:44.000Z","updated":"2019-03-26T12:52:09.802Z","comments":true,"path":"2019/03/04/backend/java/jvm1/JVM运行时数据区域(五)堆/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/java/jvm1/JVM运行时数据区域(五)堆/","excerpt":"","text":"概述 堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。 对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。 根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。 解析 所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代和永久代， 1. 新生代 新创建的对象都是用新生代分配内存 新生代又被进一步划分为Eden和Survivor区，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区，而Survivor由FromSpace和ToSpace组成。 Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。 ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。 ServivorTo：保留了一次MinorGC过程中的幸存者。 MinorGC的过程：MinorGC采用复制算法。首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果ServicorTo不够位置了就放到老年区）；然后，清空Eden和ServicorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom区。 新生代分为Eden、FromSpace、ToSpace是为了尽量让对象在新生代MinorGC，如果到了老年代之后MajorGC执行时间长 2. 老年代 老年代用于存放经过多次Minor GC之后依然存活的对象。 老年代的对象比较稳定，所以MajorGC不会频繁执行。在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。 MajorGC采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。 当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。 3. 永久代 指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域. 它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。 空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制. 采用元空间而不用永久代的几点原因： 1、为了解决永久代的OOM问题，元数据和class对象存在永久代中，容易出现性能问题和内存溢出。 2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出（因为堆空间有限，此消彼长）。 3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。 4、Oracle 可能会将HotSpot 与 JRockit 合二为一。 -Xmx20M -XX:MaxHeapSize简写，表示设置堆容量的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免堆自动扩展，减少程序运行时的垃圾回收次数，从而提供性能。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/Sharley/p/5285045.html https://www.cnblogs.com/ygj0930/p/6522828.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(四)本地方法栈","slug":"backend/java/jvm1/JVM运行时数据区域(四)本地方法栈","date":"2019-03-04T03:59:44.000Z","updated":"2019-03-19T14:43:16.791Z","comments":true,"path":"2019/03/04/backend/java/jvm1/JVM运行时数据区域(四)本地方法栈/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/java/jvm1/JVM运行时数据区域(四)本地方法栈/","excerpt":"","text":"概述 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。 解析Native Method 简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数 例如 Object.java 类下就有很多Native Method 1public final native Class&lt;?&gt; getClass(); 本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。 为什么要使用Native Method 与java环境外交互：有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。 与操作系统交互：JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun’s Java： Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/qq_28885149/article/details/52672475","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(三)Java虚拟机栈","slug":"backend/java/jvm1/JVM运行时数据区域(三)Java虚拟机栈","date":"2019-03-04T02:59:44.000Z","updated":"2019-04-23T12:04:15.410Z","comments":true,"path":"2019/03/04/backend/java/jvm1/JVM运行时数据区域(三)Java虚拟机栈/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/java/jvm1/JVM运行时数据区域(三)Java虚拟机栈/","excerpt":"","text":"何为虚拟机栈 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。 解析 执行引擎运行的所有字节码指令只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示： 栈帧数据结构 每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中 我们先来理解一下虚拟机是如何执行一个方法的，这样我们才能理解为什么栈帧需要这些部分，这些部分分别提供了什么功能。首先我们的方法被编译成了字节码，并生成了可执行的命令。通过程序计数器，虚拟机会一行一行的执行命令，直到进入一个新的方法入口，对应虚拟机栈也就是新的栈帧入栈，当前栈帧改变，又或者遇到返回指令或出现异常结束了方法，对应虚拟机也就是出栈。 1、局部变量表 是一片逻辑连续的内存空间，最小单位是Slot，用来存放方法参数和方法内部定义的局部变量 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 2、操作数栈 每个栈帧都包含一个被叫做操作数栈的后进先出的栈。叫操作栈，或者操作数栈。 栈桢刚创建时，里面的操作数栈是空的。 Java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据、实例的字段等数据入栈。 同时也有指令来支持出栈操作。 向其他方法传参的参数，也存在操作数栈中。 其他方法返回的结果，返回时存在操作数栈中。 3、动态链接 一个方法调用另一个方法，或者一个类使用另一个类的成员变量时，总得知道被调用者的名字吧？(你可以不认识它本身，但调用它就需要知道他的名字)。符号引用就相当于名字，这些被调用者的名字就存放在Java字节码文件里。名字是知道了，但是Java真正运行起来的时候，真的能靠这个名字（符号引用）就能找到相应的类和方法吗？需要解析成相应的直接引用，利用直接引用来准确地找到。 举个例子，就相当于我在0X0300H这个地址存入了一个数526，为了方便编程，我把这个给这个地址起了个别名叫A, 以后我编程的时候(运行之前)可以用别名A来暗示访问这个空间的数据，但其实程序运行起来后，实质上还是去寻找0X0300H这片空间来获取526这个数据的。 这样的符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。 4、方法返回地址 返回一个值给调用它的方法，方法正常完成发生在一个方法执行过程 中遇到了方法返回的字节码指令（§2.11.8）的时候，使用哪种返回指令取决于方法返回值的数 据类型（如果有返回值的话）。 5、附加信息参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/ychenfeng/article/details/77247807 https://blog.csdn.net/u014296316/article/details/82668670","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(二)程序计数器","slug":"backend/java/jvm1/JVM运行时数据区域(二)程序计数器","date":"2019-03-04T01:59:44.000Z","updated":"2019-03-19T14:43:16.603Z","comments":true,"path":"2019/03/04/backend/java/jvm1/JVM运行时数据区域(二)程序计数器/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/java/jvm1/JVM运行时数据区域(二)程序计数器/","excerpt":"","text":"概述程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 特点 线程私有的 是java虚拟机规范里面， 唯一 一个 没有规定任何 OutOfMemoryError 情况的区域 生命周期随着线程，线程启动而产生，线程结束而消亡 作用 程序计数器，可以看做是当前线程执行的字节码的 行号指示器 ，这句话；要理解这句话，需要先知道字节码文件长什么样子，看下面的代码 12345678// java 文件被翻译为字节码的时候，字节码大概类似于下面的样子public void haha()&#123;// 原来的 haha 方法内部的 java 代码，被翻译为下面的类似于汇编语言的指令 0 xxxx .... 2 xxxx .... 4 xx ... 5 xxx ...&#125; 上面左边的 0、2、4、5 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的 理解了程序计数器，就好理解它的这些特点了；我们都知道，Java是支持多线程的，当CPU执行权从 A 线程，转移到 B 线程的时候，JVM就要暂时挂起线程 A ，去执行线程 B ；当线程 A 再次得到CPU执行权的时候，又会挂起B线程，继续执行 A 线程 ； 我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？ 答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）； 那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，程序计数器的内存空间是线程私有的 ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！ 那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被创建； 程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域； 当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 ； 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/youngyouth/article/details/79868299","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(一)介绍","slug":"backend/java/jvm1/JVM运行时数据区域(一)介绍","date":"2019-03-04T00:59:44.000Z","updated":"2019-04-23T12:04:15.403Z","comments":true,"path":"2019/03/04/backend/java/jvm1/JVM运行时数据区域(一)介绍/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/java/jvm1/JVM运行时数据区域(一)介绍/","excerpt":"","text":"前言 Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图 1.7版本 Java 虚拟机的内存结构分为两部分 线程共享的（数据） 方法区 Java 堆 直接内存(非运行时数据区的一部分) 线程私有的（指令） 虚拟机栈 本地方法栈 程序计数器 1.8版本 1.8同1.7比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。 运行时数据区域 程序计数器：指向当前线程正在执行的字节码指令。线程私有的。 虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈 本地方法栈：调用本地native的内存模型 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据 堆（Heap）：Java对象存储的地方 参考转载 周志明版 《深入理解Java虚拟机》 https://segmentfault.com/a/1190000014395186","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor","date":"2019-03-03T12:59:44.000Z","updated":"2019-03-16T01:52:02.026Z","comments":true,"path":"2019/03/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor/","link":"","permalink":"http://www.songshuiyang.site/2019/03/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor/","excerpt":"","text":"1.1 前言 RequestResponseBodyMethodProcessor 的作用是处理被@RequestBody注解的参数，和@ResponseBody注解的返回值 查看RequestResponseBodyMethodProcessor继承关系，可以看到它是同时继承了HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler，所以就是说它同时具有参数对象解析及结果对象解析的功能，野心很大 2.1 解析 RequestResponseBodyMethodProcessor.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/** * 处理被@RequestBody注解的参数，和@ResponseBody注解的返回值 * * Resolves method arguments annotated with &#123;@code @RequestBody&#125; and handles return * values from methods annotated with &#123;@code @ResponseBody&#125; by reading and writing * to the body of the request or response with an &#123;@link HttpMessageConverter&#125;. * * &lt;p&gt;An &#123;@code @RequestBody&#125; method argument is also validated if it is annotated * with &#123;@code @javax.validation.Valid&#125;. In case of validation failure, * &#123;@link MethodArgumentNotValidException&#125; is raised and results in an HTTP 400 * response status code if &#123;@link DefaultHandlerExceptionResolver&#125; is configured. * * @author Arjen Poutsma * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 */public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor &#123; /** * Basic constructor with converters only. Suitable for resolving * &#123;@code @RequestBody&#125;. For handling &#123;@code @ResponseBody&#125; consider also * providing a &#123;@code ContentNegotiationManager&#125;. */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super(converters); &#125; /** * Basic constructor with converters and &#123;@code ContentNegotiationManager&#125;. * Suitable for resolving &#123;@code @RequestBody&#125; and handling * &#123;@code @ResponseBody&#125; without &#123;@code Request~&#125; or * &#123;@code ResponseBodyAdvice&#125;. */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, ContentNegotiationManager manager) &#123; super(converters, manager); &#125; /** * Complete constructor for resolving &#123;@code @RequestBody&#125; method arguments. * For handling &#123;@code @ResponseBody&#125; consider also providing a * &#123;@code ContentNegotiationManager&#125;. * @since 4.2 */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, List&lt;Object&gt; requestResponseBodyAdvice) &#123; super(converters, null, requestResponseBodyAdvice); &#125; /** * Complete constructor for resolving &#123;@code @RequestBody&#125; and handling * &#123;@code @ResponseBody&#125;. */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, ContentNegotiationManager manager, List&lt;Object&gt; requestResponseBodyAdvice) &#123; super(converters, manager, requestResponseBodyAdvice); &#125; /** * 检测参数是否使用了@RequestBody注解 * * @param parameter the method parameter to check * @return */ @Override public boolean supportsParameter(MethodParameter parameter) &#123; return parameter.hasParameterAnnotation(RequestBody.class); &#125; /** * 检测返回结果是否使用了@ResponseBody注解 * * @param returnType the method return type to check * @return */ @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class)); &#125; /** * 处理被@RequestBody注解的参数 * * Throws MethodArgumentNotValidException if validation fails. * @throws HttpMessageNotReadableException if &#123;@link RequestBody#required()&#125; * is &#123;@code true&#125; and there is no body content or if there is no suitable * converter to read the content with. */ @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; parameter = parameter.nestedIfOptional(); Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) &#123; validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); &#125; &#125; mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); return adaptArgumentIfNecessary(arg, parameter); &#125; /** * * @param webRequest the current request * @param parameter the method parameter descriptor (may be &#123;@code null&#125;) * @param paramType the type of the argument value to be created * @param &lt;T&gt; * @return * @throws IOException * @throws HttpMediaTypeNotSupportedException * @throws HttpMessageNotReadableException */ @Override protected &lt;T&gt; Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter, Type paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123; HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class); ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest); Object arg = readWithMessageConverters(inputMessage, parameter, paramType); if (arg == null) &#123; if (checkRequired(parameter)) &#123; throw new HttpMessageNotReadableException(\"Required request body is missing: \" + parameter.getMethod().toGenericString()); &#125; &#125; return arg; &#125; /** * 检查RequestBody注解是否required * @param parameter * @return */ protected boolean checkRequired(MethodParameter parameter) &#123; return (parameter.getParameterAnnotation(RequestBody.class).required() &amp;&amp; !parameter.isOptional()); &#125; /** * 处理@ResponseBody注解的返回值 * * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws IOException * @throws HttpMediaTypeNotAcceptableException * @throws HttpMessageNotWritableException */ @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; mavContainer.setRequestHandled(true); ServletServerHttpRequest inputMessage = createInputMessage(webRequest); ServletServerHttpResponse outputMessage = createOutputMessage(webRequest); // Try even with null return value. ResponseBodyAdvice could get involved. writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage); &#125;&#125; 2.1.1 处理被@RequestBody注解的参数解析 参数解析需要关注此类是怎么实现的HandlerMethodArgumentResolver接口的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface HandlerMethodArgumentResolver &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method parameter&#125; is * supported by this resolver. * @param parameter the method parameter to check * @return &#123;@code true&#125; if this resolver supports the supplied parameter; * &#123;@code false&#125; otherwise */ boolean supportsParameter(MethodParameter parameter); /** * 根据request解析方法参数值 * * Resolves a method parameter into an argument value from a given request. * A &#123;@link ModelAndViewContainer&#125; provides access to the model for the * request. A &#123;@link WebDataBinderFactory&#125; provides a way to create * a &#123;@link WebDataBinder&#125; instance when needed for data binding and * type conversion purposes. * @param parameter the method parameter to resolve. This parameter must * have previously been passed to &#123;@link #supportsParameter&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @param binderFactory a factory for creating &#123;@link WebDataBinder&#125; instances * @return the resolved argument value, or &#123;@code null&#125; * @throws Exception in case of errors with the preparation of argument values */ Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;&#125;``` * 查看`boolean supportsParameter(MethodParameter parameter);`方法的实现，实现很简单就是判断是否使用了@RequestBody注解```java /** * 检测参数是否使用了@RequestBody注解 * * @param parameter the method parameter to check * @return */ @Override public boolean supportsParameter(MethodParameter parameter) &#123; return parameter.hasParameterAnnotation(RequestBody.class); &#125; 查看public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) 方法的实现 123456789101112131415161718192021222324252627/** * 处理被@RequestBody注解的参数 * * Throws MethodArgumentNotValidException if validation fails. * @throws HttpMessageNotReadableException if &#123;@link RequestBody#required()&#125; * is &#123;@code true&#125; and there is no body content or if there is no suitable * converter to read the content with. */@Overridepublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; parameter = parameter.nestedIfOptional(); // 主体逻辑 Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) &#123; // 校验参数是否正确 @Valid注解开启 validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); &#125; &#125; mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); return adaptArgumentIfNecessary(arg, parameter);&#125; 进入Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); 12345678910111213141516@Overrideprotected &lt;T&gt; Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter, Type paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123; HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class); ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest); // 主体逻辑 Object arg = readWithMessageConverters(inputMessage, parameter, paramType); if (arg == null) &#123; if (checkRequired(parameter)) &#123; throw new HttpMessageNotReadableException(\"Required request body is missing: \" + parameter.getMethod().toGenericString()); &#125; &#125; return arg;&#125; 继续进入Object arg = readWithMessageConverters(inputMessage, parameter, paramType); ，可以看到是遍历 this.messageConverters 选择适合的消息处理器来处理参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Create the method argument value of the expected parameter type by reading * from the given HttpInputMessage. * @param &lt;T&gt; the expected type of the argument value to be created * @param inputMessage the HTTP input message representing the current request * @param parameter the method parameter descriptor (may be &#123;@code null&#125;) * @param targetType the target type, not necessarily the same as the method * parameter type, e.g. for &#123;@code HttpEntity&lt;String&gt;&#125;. * @return the created method argument value * @throws IOException if the reading from the request fails * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found */@SuppressWarnings(\"unchecked\")protected &lt;T&gt; Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123; MediaType contentType; boolean noContentType = false; try &#123; contentType = inputMessage.getHeaders().getContentType(); &#125; catch (InvalidMediaTypeException ex) &#123; throw new HttpMediaTypeNotSupportedException(ex.getMessage()); &#125; if (contentType == null) &#123; noContentType = true; contentType = MediaType.APPLICATION_OCTET_STREAM; &#125; Class&lt;?&gt; contextClass = (parameter != null ? parameter.getContainingClass() : null); Class&lt;T&gt; targetClass = (targetType instanceof Class ? (Class&lt;T&gt;) targetType : null); if (targetClass == null) &#123; ResolvableType resolvableType = (parameter != null ? ResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType)); targetClass = (Class&lt;T&gt;) resolvableType.resolve(); &#125; HttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod(); Object body = NO_VALUE; try &#123; inputMessage = new EmptyBodyCheckingHttpInputMessage(inputMessage); // 遍历 this.messageConverters 选择适合的消息处理器来处理参数 for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123; Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(); if (converter instanceof GenericHttpMessageConverter) &#123; GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter; // 判断是否适合处理参数 if (genericConverter.canRead(targetType, contextClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = genericConverter.read(targetType, contextClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125; else if (targetClass != null) &#123; if (converter.canRead(targetClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw new HttpMessageNotReadableException(\"I/O error while reading input message\", ex); &#125; if (body == NO_VALUE) &#123; if (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) || (noContentType &amp;&amp; inputMessage.getBody() == null)) &#123; return null; &#125; throw new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes); &#125; return body;&#125; 查看this.messageConverters有哪些呢？见下图 下图是主要MessageConverter的功能介绍 2.1.2 处理被@ResponseBody注解的返回值解析 返回值解析需要关注此类是怎样实现HandlerMethodArgumentResolver接口的方法的 1234567891011121314151617181920212223242526272829303132public interface HandlerMethodReturnValueHandler &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method return type&#125; is * supported by this handler. * @param returnType the method return type to check * @return &#123;@code true&#125; if this handler supports the supplied return type; * &#123;@code false&#125; otherwise */ boolean supportsReturnType(MethodParameter returnType); /** * 处理结果集 * * Handle the given return value by adding attributes to the model and * setting a view or setting the * &#123;@link ModelAndViewContainer#setRequestHandled&#125; flag to &#123;@code true&#125; * to indicate the response has been handled directly. * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws Exception if the return value handling results in an error */ void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;&#125; 查看boolean supportsReturnType(MethodParameter returnType);的方法的实现，实现也很简单就是判断是否使用了@ResponseBody注解 1234567891011/** * 检测返回结果是否使用了@ResponseBody注解 * * @param returnType the method return type to check * @return */@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class));&#125; 查看public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)的实现 123456789101112131415161718192021222324/** * 处理@ResponseBody注解的返回值 * * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws IOException * @throws HttpMediaTypeNotAcceptableException * @throws HttpMessageNotWritableException */@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; mavContainer.setRequestHandled(true); ServletServerHttpRequest inputMessage = createInputMessage(webRequest); ServletServerHttpResponse outputMessage = createOutputMessage(webRequest); // Try even with null return value. ResponseBodyAdvice could get involved. writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);&#125; 3.1 总结 我们知道，Http请求和响应报文本质上都是一串字符串，当请求报文来到java世界，它会被封装成为一个ServletInputStream的输入流，供我们读取报文。响应报文则是通过一个ServletOutputStream的输出流，来输出响应报文，我们得到输入输出流之后需要把它转成我们的java实体类对象，这个是怎样转换的呢，就是通过我们的HttpMessageConverter消息转换器来实现的 下图是HttpMessageConverter的工作流程图 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://my.oschina.net/lichhao/blog/172562","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(八)RequestMappingHanlderAdapter","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(八)RequestMappingHanlderAdapter","date":"2019-03-03T03:59:44.000Z","updated":"2019-03-10T01:44:49.412Z","comments":true,"path":"2019/03/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(八)RequestMappingHanlderAdapter/","link":"","permalink":"http://www.songshuiyang.site/2019/03/03/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(八)RequestMappingHanlderAdapter/","excerpt":"","text":"1.1 前言 RequestMappingHanlderAdapter是 HanlderAdapter 中最复杂的也是最常用的处理适配器，他的作用是根据HanlderMapping找到的Handler调用我们Controller 里的方法 既然是调用方法我们推测它的工作应该主要设及3步， 1、方法参数绑定，2、方法执行，3、返回结果处理 ， 方法执行的流程已经在代码里写好了，重点是参数绑定及结果处理，各个方法参数类型不同个数不同，想想就复杂，下面来看人家是怎么做的 2.1 RequestMappingHanlderAdapter初始化解析 查看RequestMappingHanlderAdapter的继承关系 RequestMappingHandlerAdapter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * An &#123;@link AbstractHandlerMethodAdapter&#125; that supports &#123;@link HandlerMethod&#125;s * with their method argument and return type signature, as defined via * &#123;@code @RequestMapping&#125;. * * &lt;p&gt;Support for custom argument and return value types can be added via * &#123;@link #setCustomArgumentResolvers&#125; and &#123;@link #setCustomReturnValueHandlers&#125;. * Or alternatively, to re-configure all argument and return value types, * use &#123;@link #setArgumentResolvers&#125; and &#123;@link #setReturnValueHandlers&#125;. * * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 * @see HandlerMethodArgumentResolver * @see HandlerMethodReturnValueHandler */public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; private List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers; // 用于给处理器方法和注释了@ModelAttribute的方法设置参数 private HandlerMethodArgumentResolverComposite argumentResolvers; // 用于添加了@initBinder的方法设置参数 private HandlerMethodArgumentResolverComposite initBinderArgumentResolvers; private List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers; // 用于将处理器的返回值处理为ModelAndView类型 private HandlerMethodReturnValueHandlerComposite returnValueHandlers; private List&lt;ModelAndViewResolver&gt; modelAndViewResolvers; private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager(); private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters; private List&lt;Object&gt; requestResponseBodyAdvice = new ArrayList&lt;Object&gt;(); private WebBindingInitializer webBindingInitializer; private AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(\"MvcAsync\"); private Long asyncRequestTimeout; private CallableProcessingInterceptor[] callableInterceptors = new CallableProcessingInterceptor[0]; private DeferredResultProcessingInterceptor[] deferredResultInterceptors = new DeferredResultProcessingInterceptor[0]; private boolean ignoreDefaultModelOnRedirect = false; private int cacheSecondsForSessionAttributeHandlers = 0; private boolean synchronizeOnSession = false; private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore(); private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); private ConfigurableBeanFactory beanFactory; private final Map&lt;Class&lt;?&gt;, SessionAttributesHandler&gt; sessionAttributesHandlerCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, SessionAttributesHandler&gt;(64); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; initBinderCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache = new LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;(); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; modelAttributeCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache = new LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;(); public RequestMappingHandlerAdapter() &#123; StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(); stringHttpMessageConverter.setWriteAcceptCharset(false); // see SPR-7316 this.messageConverters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(4); this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(stringHttpMessageConverter); this.messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;()); this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); &#125; 可以看到实现了InitializingBean接口，这个方法注册了this.argumentResolvers this.initBinderArgumentResolvers this.returnValueHandlers 123456789101112131415161718@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBody advice beans initControllerAdviceCache(); if (this.argumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.initBinderArgumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125;&#125; 例如getDefaultArgumentResolvers方法，可以看到是直接写死了有那些默认的参数解析组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Return the list of argument resolvers to use including built-in resolvers * and custom resolvers provided via &#123;@link #setCustomArgumentResolvers&#125;. */private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;HandlerMethodArgumentResolver&gt;(); // Annotation-based argument resolution resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.PathVariableMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(false)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.SessionAttributeMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestAttributeMethodArgumentResolver()); // Type-based argument resolution resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletResponseMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.UriComponentsBuilderMethodArgumentResolver()); // Custom arguments if (getCustomArgumentResolvers() != null) &#123; resolvers.addAll(getCustomArgumentResolvers()); &#125; // Catch-all resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(true)); return resolvers;&#125; 2.2 处理解析 RequestMappingHanlderAdapter 处理请求入口方法是handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod)，进入该方法 12345678910111213141516171819202122232425262728293031@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; checkRequest(request); // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // 具体执行请求的处理 // No synchronization on session demanded at all... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125; 关注mav = invokeHandlerMethod(request, response, handlerMethod);方法，进入该方法之后可以看到该方法主要是一些参数准备及组装各种处理单元，先备兵粮 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Invoke the &#123;@link RequestMapping&#125; handler method preparing a &#123;@link ModelAndView&#125; * if view resolution is required. * @since 4.2 * @see #createInvocableHandlerMethod(HandlerMethod) */protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; // 创建WebDataBinder，WebDataBinder用于参数绑定，将符合条件的注释了@InitBinder的方法找出来 WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); // 用来处理Model，在处理器具体处理之前对Model进行初始化，在处理完请求之后对Model参数进行更新 ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); // 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成 org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // ModelAndViewContainer承载着整个请求过程中数据的传递工作 ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Found concurrent result value [\" + result + \"]\"); &#125; invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; // 执行方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125; 这个方法重点关注ServletInvocableHandlerMethod此对象，该类继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成 123456// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);invocableMethod.setDataBinderFactory(binderFactory);invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); 查看上面代码可以看到这里设置了参数解析器 结果解析器 等等 ServletInvocableHandlerMethod 解析 先查看ServletInvocableHandlerMethod的继承关系，此类的继承关系有三层 顶层HandlerMethod类，该类封装了方法调用相关信息，比如是属于哪个bean下的的，那个Method，方法的参数MethodParameter[]等等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 封装了方法调用相关信息,子类还提供调用,参数准备和返回值处理的职责 * * Encapsulates information about a handler method consisting of a * &#123;@linkplain #getMethod() method&#125; and a &#123;@linkplain #getBean() bean&#125;. * Provides convenient access to method parameters, the method return value, * method annotations, etc. * * &lt;p&gt;The class may be created with a bean instance or with a bean name * (e.g. lazy-init bean, prototype bean). Use &#123;@link #createWithResolvedBean()&#125; * to obtain a &#123;@code HandlerMethod&#125; instance with a bean instance resolved * through the associated &#123;@link BeanFactory&#125;. * * @author Arjen Poutsma * @author Rossen Stoyanchev * @author Juergen Hoeller * @author Sam Brannen * @since 3.1 */public class HandlerMethod &#123; /** Logger that is available to subclasses */ protected final Log logger = LogFactory.getLog(getClass()); private final Object bean; private final BeanFactory beanFactory; private final Class&lt;?&gt; beanType; private final Method method; private final Method bridgedMethod; /** * 方法的参数 */ private final MethodParameter[] parameters; private HttpStatus responseStatus; private String responseStatusReason; private HandlerMethod resolvedFromHandlerMethod; ... InvocableHandlerMethod 类 HandlerMethod类的基础上添加了方法调用功能及注册了参数解析组件 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 在 HandlerMethod类的基础上添加了方法调用功能及注册了参数解析组件 * * Provides a method for invoking the handler method for a given request after resolving its * method argument values through registered &#123;@link HandlerMethodArgumentResolver&#125;s. * * &lt;p&gt;Argument resolution often requires a &#123;@link WebDataBinder&#125; for data binding or for type * conversion. Use the &#123;@link #setDataBinderFactory(WebDataBinderFactory)&#125; property to supply * a binder factory to pass to argument resolvers. * * &lt;p&gt;Use &#123;@link #setHandlerMethodArgumentResolvers&#125; to customize the list of argument resolvers. * * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 */public class InvocableHandlerMethod extends HandlerMethod &#123; /** * 用于参数解析器ArgumentResolver */ private WebDataBinderFactory dataBinderFactory; /** * 解析参数 */ private org.springframework.web.method.support.HandlerMethodArgumentResolverComposite argumentResolvers = new org.springframework.web.method.support.HandlerMethodArgumentResolverComposite(); /** * 用来获取参数名 */ private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); /** * Create an instance from a &#123;@code HandlerMethod&#125;. */ public InvocableHandlerMethod(HandlerMethod handlerMethod) &#123; super(handlerMethod); &#125; ... 得到ServletInvocableHandlerMethod 对象之后进入到ServletInvocableHandlerMethod 类的invocableMethod.invokeAndHandle(webRequest, mavContainer); 方法，可以说这个方法是RequestMappingHandlerAdapter的核心方法，可以看到Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 是执行了方法体，得到returnValue 之后就是调用this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);该方法处理结果对象 123456789101112131415161718192021222324252627282930313233343536/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler&#125;s. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); try &#123; this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(getReturnValueHandlingErrorMessage(\"Error handling return value\", returnValue), ex); &#125; throw ex; &#125;&#125; 进入Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 方法，可以看到该方法很简单，先是得到方法参数Object[] args，然后执行Object returnValue = doInvoke(args); 该方法得到结果 1234567891011121314151617181920212223242526272829/** * Invoke the method after resolving its argument values in the context of the given request. * &lt;p&gt;Argument values are commonly resolved through &#123;@link HandlerMethodArgumentResolver&#125;s. * The &#123;@code providedArgs&#125; parameter however may supply argument values to be used directly, * i.e. without argument resolution. Examples of provided argument values include a * &#123;@link WebDataBinder&#125;, a &#123;@link SessionStatus&#125;, or a thrown exception instance. * Provided argument values are checked before argument resolvers. * @param request the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type, not resolved * @return the raw value returned by the invoked method * @exception Exception raised if no suitable argument resolver can be found, * or if the method raised an exception */public Object invokeForRequest(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"' with arguments \" + Arrays.toString(args)); &#125; Object returnValue = doInvoke(args); if (logger.isTraceEnabled()) &#123; logger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"] returned [\" + returnValue + \"]\"); &#125; return returnValue;&#125; 2.1.1 方法参数绑定 方法参数的绑定需要关注Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); 这行代码，先进入该方法，可以看到该方法有两种解析形式 1： providedArgs 2：argumentResolvers 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 根据当前请求获取方法的请求参数 * Get the method argument values for the current request. * 两种解析形式 1： providedArgs 2：argumentResolvers 在RequestMappingHandlerAdapter中只有argumentResolvers解析 * */private Object[] getMethodArgumentValues(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 获取方法的参数，在HanderMethod中 MethodParameter[] parameters = getMethodParameters(); // 用于保存解析出参数的值 Object[] args = new Object[parameters.length]; // 遍历每一个参数进行解析 for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; // 给Parameter设置参数名解析器 parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); // 如果相应类型的参数已经在providedArgs中提供了，则直接设置到parameter args[i] = resolveProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; if (this.argumentResolvers.supportsParameter(parameter)) &#123; try &#123; // 使用argumentResolvers解析参数 args[i] = this.argumentResolvers.resolveArgument( parameter, mavContainer, request, this.dataBinderFactory); continue; &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(getArgumentResolutionErrorMessage(\"Failed to resolve\", i), ex); &#125; throw ex; &#125; &#125; // 解析不出来，抛异常 if (args[i] == null) &#123; throw new IllegalStateException(\"Could not resolve method parameter at index \" + parameter.getParameterIndex() + \" in \" + parameter.getMethod().toGenericString() + \": \" + getArgumentResolutionErrorMessage(\"No suitable resolver for\", i)); &#125; &#125; return args;&#125; 在RequestMappingHandlerAdapter中只有argumentResolvers解析，因为invocableMethod.invokeAndHandle(webRequest, mavContainer); 只传了两个参数，到了Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 方法之后也是没有传入providedArgs的 argumentResolvers 存放在HandlerMethodArgumentResolverComposite 类中，所有的ArgumentResolver都存放在List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers中，也可以看到该类也做了一个argumentResolverCacheCache处理，也是为了性能 12345678910111213141516171819202122232425262728/** * HandlerMethodArgumentResolver 的仓库 * * Resolves method parameters by delegating to a list of registered &#123;@link HandlerMethodArgumentResolver&#125;s. * Previously resolved method parameters are cached for faster lookups. * * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 */public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver &#123; protected final Log logger = LogFactory.getLog(getClass()); private final List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = new LinkedList&lt;HandlerMethodArgumentResolver&gt;(); private final Map&lt;MethodParameter, HandlerMethodArgumentResolver&gt; argumentResolverCache = new ConcurrentHashMap&lt;MethodParameter, HandlerMethodArgumentResolver&gt;(256); /** * Add the given &#123;@link HandlerMethodArgumentResolver&#125;. */ public HandlerMethodArgumentResolverComposite addResolver(HandlerMethodArgumentResolver resolver) &#123; this.argumentResolvers.add(resolver); return this; &#125; 通过调试可以看到有下面这些argumentResolvers，看类名称是不是很熟悉，就是我们平常使用的@RequestBody @RequestParam 是一一对应的，还是专人做专事，可以得出不同的参数是有不同的参数解析组件来专门处理的 下面来看主要XXXArgumentResolver的作用 123456789101112131415161. SessionAttributeMethodArgumentResolver 针对 被 @SessionAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_SESSION) 2. RequestParamMethodArgumentResolver 针对被 @RequestParam 注解修饰, 但类型不是 Map, 或类型是 Map, 并且 @RequestParam 中指定 name, 一般通过 MultipartHttpServletRequest | HttpServletRequest 获取数据3. RequestHeaderMethodArgumentResolver 针对 参数被 RequestHeader 注解, 并且 参数不是 Map 类型, 数据通过 HttpServletRequest.getHeaderValues(name) 获取4. RequestAttributeMethodArgumentResolver 针对 被 @RequestAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_REQUEST)5. PathVariableMethodArgumentResolver 解决被注解 @PathVariable 注释的参数 &lt;- 这个注解对应的是 uri 中的数据, 在解析 URI 中已经进行解析好了 &lt;- 在 RequestMappingInfoHandlerMapping.handleMatch -&gt; getPathMatcher().extractUriTemplateVariables6. MatrixVariableMethodArgumentResolver 针对被 @MatrixVariable 注解修饰的参数起作用, 从 HttpServletRequest 中获取去除 ; 的 URI Template Variables 获取数据7. ExpressionValueMethodArgumentResolver 针对被 @Value 修饰, 返回 ExpressionValueNamedValueInfo8. ServletCookieValueMethodArgumentResolver 针对被 @CookieValue 修饰, 通过 HttpServletRequest.getCookies 获取对应数据 然后进入HandlerMethodArgumentResolverComposite类的args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); 方法，可以看到逻辑十分简单，就是遍历this.argumentResolvers 然后做了个缓存处理，得到HandlerMethodArgumentResolver之后就是调用resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);方法了，该方法是参数解析的主体方法 12345678910111213141516171819202122232425262728293031323334353637/** * 迭代注册过的 HandlerMethodArgumentResolver, 然后找到对应的ArgumentResolver * Iterate over registered &#123;@link HandlerMethodArgumentResolver&#125;s and invoke the one that supports it. * @throws IllegalStateException if no suitable &#123;@link HandlerMethodArgumentResolver&#125; is found. */@Overridepublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter); if (resolver == null) &#123; throw new IllegalArgumentException(\"Unknown parameter type [\" + parameter.getParameterType().getName() + \"]\"); &#125; return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);&#125;/** * 先从缓存里取，没有的再遍历，注意这里是先来先得的 * Find a registered &#123;@link HandlerMethodArgumentResolver&#125; that supports the given method parameter. */private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123; HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter); if (result == null) &#123; for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(\"Testing if argument resolver [\" + methodArgumentResolver + \"] supports [\" + parameter.getGenericParameterType() + \"]\"); &#125; if (methodArgumentResolver.supportsParameter(parameter)) &#123; result = methodArgumentResolver; this.argumentResolverCache.put(parameter, result); break; &#125; &#125; &#125; return result;&#125; 再来回顾HandlerMethodArgumentResolver接口，该接口就两个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 方法参数解析器 * * Strategy interface for resolving method parameters into argument values in * the context of a given request. * * @author Arjen Poutsma * @since 3.1 * @see HandlerMethodReturnValueHandler */public interface HandlerMethodArgumentResolver &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method parameter&#125; is * supported by this resolver. * @param parameter the method parameter to check * @return &#123;@code true&#125; if this resolver supports the supplied parameter; * &#123;@code false&#125; otherwise */ boolean supportsParameter(MethodParameter parameter); /** * 根据request解析方法参数值 * * Resolves a method parameter into an argument value from a given request. * A &#123;@link ModelAndViewContainer&#125; provides access to the model for the * request. A &#123;@link WebDataBinderFactory&#125; provides a way to create * a &#123;@link WebDataBinder&#125; instance when needed for data binding and * type conversion purposes. * @param parameter the method parameter to resolve. This parameter must * have previously been passed to &#123;@link #supportsParameter&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @param binderFactory a factory for creating &#123;@link WebDataBinder&#125; instances * @return the resolved argument value, or &#123;@code null&#125; * @throws Exception in case of errors with the preparation of argument values */ Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;&#125; HandlerMethodArgumentResolver的 resolveArgument 的解析将在之后的章节介绍 2.2.2 方法执行 回到InvocableHandlerMethod类的invokeForRequest 方法，上一小节介绍了方法参数绑定的主体逻辑(Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);)，这一小节介绍Object returnValue = doInvoke(args);，该行代码是方法执行的主体方法 123456789101112131415public Object invokeForRequest(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"' with arguments \" + Arrays.toString(args)); &#125; Object returnValue = doInvoke(args); if (logger.isTraceEnabled()) &#123; logger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"] returned [\" + returnValue + \"]\"); &#125; return returnValue;&#125; 进入Object returnValue = doInvoke(args); 方法，可以看到调用了getBridgedMethod().invoke(getBean(), args); 来执行方法，getBridgedMethod() 得到的是private final Method bridgedMethod，百度了一下这个桥接方法的用途是为了和jdk1.5之前的字节码兼容. 因为范型是在jdk1.5之后才引入的. 在jdk1.5之前例如集合的操作都是没有范型支持的, 所以生成的字节码中参数都是用Object接收的, 所以也可以往集合中放入任意类型的对象, 集合类型的校验也被拖到运行期. 1234567891011121314151617181920212223242526272829303132/** * Invoke the handler method with the given argument values. */protected Object doInvoke(Object... args) throws Exception &#123; // 强制将他变为可调用 即使是private方法 ReflectionUtils.makeAccessible(getBridgedMethod()); try &#123; return getBridgedMethod().invoke(getBean(), args); &#125; catch (IllegalArgumentException ex) &#123; assertTargetBean(getBridgedMethod(), getBean(), args); String text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\"); throw new IllegalStateException(getInvocationErrorMessage(text, args), ex); &#125; catch (InvocationTargetException ex) &#123; // Unwrap for HandlerExceptionResolvers ... Throwable targetException = ex.getTargetException(); if (targetException instanceof RuntimeException) &#123; throw (RuntimeException) targetException; &#125; else if (targetException instanceof Error) &#123; throw (Error) targetException; &#125; else if (targetException instanceof Exception) &#123; throw (Exception) targetException; &#125; else &#123; String text = getInvocationErrorMessage(\"Failed to invoke handler method\", args); throw new IllegalStateException(text, targetException); &#125; &#125;&#125; 在此方法执行完成 2.2.3 返回结果处理 方法执行完成之后就对返回结果的处理了，回到ServletInvocableHandlerMethod类，现在方法体已经执行了，就是对结果对象的处理了 1234567891011121314151617181920212223242526272829303132333435/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler&#125;s. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); try &#123; this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(getReturnValueHandlingErrorMessage(\"Error handling return value\", returnValue), ex); &#125; throw ex; &#125;&#125; 查看上面的代码可以看到this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest); 这行代码作用是对结果对象的处理，查看returnValueHandlers 对象（private HandlerMethodReturnValueHandlerComposite returnValueHandlers;）可以看到和我们之前的参数绑定的处理是相似的，HandlerMethodReturnValueHandlerComposite存放了各种结果处理组件 HandlerMethodReturnValueHandlerComposite.java 123456789101112131415/** * Handles method return values by delegating to a list of registered &#123;@link HandlerMethodReturnValueHandler&#125;s. * Previously resolved return types are cached for faster lookups. * * @author Rossen Stoyanchev * @since 3.1 */public class HandlerMethodReturnValueHandlerComposite implements AsyncHandlerMethodReturnValueHandler &#123; protected final Log logger = LogFactory.getLog(getClass()); // 结果处理组件 private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;HandlerMethodReturnValueHandler&gt;(); HandlerMethodReturnValueHandler.java 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 结果对象处理 * * Strategy interface to handle the value returned from the invocation of a * handler method . * * @author Arjen Poutsma * @since 3.1 * @see HandlerMethodArgumentResolver */public interface HandlerMethodReturnValueHandler &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method return type&#125; is * supported by this handler. * @param returnType the method return type to check * @return &#123;@code true&#125; if this handler supports the supplied return type; * &#123;@code false&#125; otherwise */ boolean supportsReturnType(MethodParameter returnType); /** * 处理结果集 * * Handle the given return value by adding attributes to the model and * setting a view or setting the * &#123;@link ModelAndViewContainer#setRequestHandled&#125; flag to &#123;@code true&#125; * to indicate the response has been handled directly. * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws Exception if the return value handling results in an error */ void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;&#125; 进入handleReturnValue方法，可以看到和之前方法参数绑定处理是一样的套路的 12345678910111213141516171819202122232425262728/** * 迭代注册过的 HandlerMethodReturnValueHandler, 然后找到对应的ReturnValueHandler * Iterate over registered &#123;@link HandlerMethodReturnValueHandler&#125;s and invoke the one that supports it. * @throws IllegalStateException if no suitable &#123;@link HandlerMethodReturnValueHandler&#125; is found. */@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName()); &#125; handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125; private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) &#123; boolean isAsyncValue = isAsyncReturnValue(value, returnType); for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123; if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123; continue; &#125; if (handler.supportsReturnType(returnType)) &#123; return handler; &#125; &#125; return null; &#125; 如下图可以看到有如下this.returnValueHandlers 3.1 总结 RequestMappingHanlderAdapter 的功能主要是 1、方法参数绑定，2、方法执行，3、返回结果处理 HandlerMethodArgumentResolver 的方法参数绑定处理是针对于不同的方法参数有专门的ArgumentResolver 专人做专事，专业 HandlerMethodReturnValueHandler 的返回结果处理也是和参数处理那样是针对于不同的返回对象有专门的ReturnValueHandler 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(七)处理适配器HanlderAdapter","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(七)处理适配器HanlderAdapter","date":"2019-02-28T13:59:44.000Z","updated":"2019-03-03T03:19:43.261Z","comments":true,"path":"2019/02/28/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(七)处理适配器HanlderAdapter/","link":"","permalink":"http://www.songshuiyang.site/2019/02/28/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(七)处理适配器HanlderAdapter/","excerpt":"","text":"1.1 前言 前几章介绍了HandlerMapping处理流程， HandlerMapping负责根据request请求找到对应的Handler处理器及Interceptor拦截器，的到处理器Handler之后，Spring MVC 又根据该Handler 找出对应的 HandlerAdapter，这一章节来介绍HandlerAdapter，HandlerAdapter是具体使用Handler 来干活的 下面还是方法体doDispatch(HttpServletRequest request, HttpServletResponse response) 的处理代码，可以看到得到Handler处理器之后就是遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter，找到之后就是mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 调用真正的处理方法了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否是文件上传请求 Multipart，有则将请求转换为 Multipart 请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中 mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理 last-modified 请求头 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 执行相应拦截器Interceptor的preHandle if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 执行实际的处理程序，执行Controller里的方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 2.1 处理适配器HanlderAdapter解析2.1.1 HanlderAdapter 解析 先看HanlderAdapter 这个接口有哪些方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Handler 处理适配器, 适配不同的 Handler * * MVC framework SPI, allowing parameterization of the core MVC workflow. * * &lt;p&gt;Interface that must be implemented for each handler type to handle a request. * This interface is used to allow the &#123;@link DispatcherServlet&#125; to be indefinitely * extensible. The &#123;@code DispatcherServlet&#125; accesses all installed handlers through * this interface, meaning that it does not contain code specific to any handler type. * * &lt;p&gt;Note that a handler can be of type &#123;@code Object&#125;. This is to enable * handlers from other frameworks to be integrated with this framework without * custom coding, as well as to allow for annotation-driven handler objects that * do not obey any specific Java interface. * * &lt;p&gt;This interface is not intended for application developers. It is available * to handlers who want to develop their own web workflow. * * &lt;p&gt;Note: &#123;@code HandlerAdapter&#125; implementors may implement the &#123;@link * org.springframework.core.Ordered&#125; interface to be able to specify a sorting * order (and thus a priority) for getting applied by the &#123;@code DispatcherServlet&#125;. * Non-Ordered instances get treated as lowest priority. * * @author Rod Johnson * @author Juergen Hoeller * @see org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter * @see org.springframework.web.servlet.handler.SimpleServletHandlerAdapter */public interface HandlerAdapter &#123; /** * 检测 HandlerAdapter 是否支持这个 handler * * Given a handler instance, return whether or not this &#123;@code HandlerAdapter&#125; * can support it. Typical HandlerAdapters will base the decision on the handler * type. HandlerAdapters will usually only support one handler type each. * &lt;p&gt;A typical implementation: * &lt;p&gt;&#123;@code * return (handler instanceof MyHandler); * &#125; * @param handler handler object to check * @return whether or not this object can use the given handler */ boolean supports(Object handler); /** * 处理 HttpServletRequest 的入口方法 * * Use the given handler to handle this request. * The workflow that is required may vary widely. * @param request current HTTP request * @param response current HTTP response * @param handler handler to use. This object must have previously been passed * to the &#123;@code supports&#125; method of this interface, which must have * returned &#123;@code true&#125;. * @throws Exception in case of errors * @return ModelAndView object with the name of the view and the required * model data, or &#123;@code null&#125; if the request has been handled directly */ ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * 获取Http 请求中的lastModifiedTime * * Same contract as for HttpServlet's &#123;@code getLastModified&#125; method. * Can simply return -1 if there's no support in the handler class. * @param request current HTTP request * @param handler handler to use * @return the lastModified value for the given handler * @see javax.servlet.http.HttpServlet#getLastModified * @see org.springframework.web.servlet.mvc.LastModified#getLastModified */ long getLastModified(HttpServletRequest request, Object handler);&#125; 下图是HanlderAdapter涉及子类的继承关系，看方法名是不是很熟悉，没错和前几章的HandlerMapping是差不多是一一对应的 image 查看这些类可以看到除了RequestMappingHandlerAdapter 的实现比较复杂之外，其他的HandlerAdapter都是调用Handler里固定的方法，比如下图的SimpleControllerHandlerAdapter 1234567891011121314151617181920212223public class SimpleControllerHandlerAdapter implements HandlerAdapter &#123; @Override public boolean supports(Object handler) &#123; return (handler instanceof Controller); &#125; @Override public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return ((Controller) handler).handleRequest(request, response); &#125; @Override public long getLastModified(HttpServletRequest request, Object handler) &#123; if (handler instanceof LastModified) &#123; return ((LastModified) handler).getLastModified(request); &#125; return -1L; &#125;&#125; 查看AbstractHandlerMethodAdapter可以看到内容也很少，HandlerAdapter 接口的实现都转发到自己的抽象方法里去了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * Abstract base class for &#123;@link HandlerAdapter&#125; implementations that support * handlers of type &#123;@link HandlerMethod&#125;. * * @author Arjen Poutsma * @since 3.1 */public abstract class AbstractHandlerMethodAdapter extends WebContentGenerator implements HandlerAdapter, Ordered &#123; private int order = Ordered.LOWEST_PRECEDENCE; public AbstractHandlerMethodAdapter() &#123; // no restriction of HTTP methods by default super(false); &#125; /** * Specify the order value for this HandlerAdapter bean. * &lt;p&gt;Default value is &#123;@code Integer.MAX_VALUE&#125;, meaning that it's non-ordered. * @see org.springframework.core.Ordered#getOrder() */ public void setOrder(int order) &#123; this.order = order; &#125; @Override public int getOrder() &#123; return this.order; &#125; /** * 先判断是否是HandlerMethod，然后转向抽象方法supportsInternal * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. * @param handler the handler instance to check * @return whether or not this adapter can adapt the given handler */ @Override public final boolean supports(Object handler) &#123; return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler)); &#125; /** * Given a handler method, return whether or not this adapter can support it. * @param handlerMethod the handler method to check * @return whether or not this adapter can adapt the given method */ protected abstract boolean supportsInternal(HandlerMethod handlerMethod); /** * 转向抽象方法 handleInternal() * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. */ @Override public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler); &#125; /** * Use the given handler method to handle the request. * @param request current HTTP request * @param response current HTTP response * @param handlerMethod handler method to use. This object must have previously been passed to the * &#123;@link #supportsInternal(HandlerMethod)&#125; this interface, which must have returned &#123;@code true&#125;. * @return ModelAndView object with the name of the view and the required model data, * or &#123;@code null&#125; if the request has been handled directly * @throws Exception in case of errors */ protected abstract ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception; /** * 转向抽象方法 getLastModifiedInternal() * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. */ @Override public final long getLastModified(HttpServletRequest request, Object handler) &#123; return getLastModifiedInternal(request, (HandlerMethod) handler); &#125; /** * Same contract as for &#123;@link javax.servlet.http.HttpServlet#getLastModified(HttpServletRequest)&#125;. * @param request current HTTP request * @param handlerMethod handler method to use * @return the lastModified value for the given handler */ protected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);&#125; 2.1.2 各个 HandlerAdapter作用AnnotationMethodHandlerAdapterAnnotationMethodHandlerAdapter主要是适配注解类处理器，注解类处理器就是我们经常使用的@Controller的这类处理器，不过该类已经被@Deprecated 标记了（@deprecated as of Spring 3.2, in favor of`） HttpRequestHandlerAdapterHttpRequestHandlerAdapter 主要是适配静态资源处理器，静态资源处理器就是实现了HttpRequestHandler接口的处理器，这类处理器的作用是处理通过SpringMVC来访问的静态资源的请求。 SimpleControllerHandlerAdapterSimpleControllerHandlerAdapter 是Controller处理适配器，适配实现了Controller接口或Controller接口子类的处理器，比如我们经常自己写的Controller来继承MultiActionController SimpleServletHandlerAdapterSimpleServletHandlerAdapter是Servlet处理适配器,适配实现了Servlet接口或Servlet的子类的处理器，我们不仅可以在web.xml里面配置Servlet，其实也可以用SpringMVC来配置Servlet，不过这个适配器很少用到，而且SpringMVC默认的适配器没有他，默认的是前面的三种。 2.1.3 HandlerAdapter 注册过程 HandlerAdapter 注册过程 和 HandlerMapping 的注册过程是一样的，回到DispatcherServlet 类中onRefresh 方法 1234567891011121314151617181920/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 进入initHandlerAdapters(context); 从下面代码也可以看到也是通过扫描HandlerAdapter类 bean的形式来注册HandlerAdapter 1234567891011121314151617181920212223242526272829303132333435363738/** * Initialize the HandlerAdapters used by this class. * &lt;p&gt;If no HandlerAdapter beans are defined in the BeanFactory for this namespace, * we default to SimpleControllerHandlerAdapter. */private void initHandlerAdapters(ApplicationContext context) &#123; this.handlerAdapters = null; if (this.detectAllHandlerAdapters) &#123; // 加载所有实现了HandlerAdapter接口的bean // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts. Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerAdapters = new ArrayList&lt;HandlerAdapter&gt;(matchingBeans.values()); // We keep HandlerAdapters in sorted order. AnnotationAwareOrderComparator.sort(this.handlerAdapters); &#125; &#125; else &#123; try &#123; HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class); this.handlerAdapters = Collections.singletonList(ha); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we'll add a default HandlerAdapter later. &#125; &#125; // Ensure we have at least some HandlerAdapters, by registering // default HandlerAdapters if no other adapters are found. if (this.handlerAdapters == null) &#123; this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class); if (logger.isDebugEnabled()) &#123; logger.debug(\"No HandlerAdapters found in servlet '\" + getServletName() + \"': using default\"); &#125; &#125;&#125; 3.1 总结 HanlderAdapter 从字面上的意思就是处理适配器，他的作用就是根据用户的请求调用具体的方法，根据HandlerMapping传过来Hanler与注册好的HandlerAdapter一一匹配，如果找到了其中一种HandlerAdapter是支持传过来的controller类型，那么该HandlerAdapter会调用自己的handle方法 不同的HanlderAdapter可以适应不同的request需求 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.jianshu.com/p/3d6df6b725e4 https://blog.csdn.net/weixin_38399962/article/details/85288660","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程","date":"2019-02-27T13:59:44.000Z","updated":"2019-03-03T02:27:39.710Z","comments":true,"path":"2019/02/27/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程/","link":"","permalink":"http://www.songshuiyang.site/2019/02/27/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程/","excerpt":"","text":"1.1 前言 上一章节介绍了 RequestMappingHandlerMapping 这个 HandlerMapping 的加载过程，这一章节来介绍RequestMappingHandlerMapping实现流程 2.1 找到与请求对应的 Handler 解析 还是回到这个方法doDispatch(HttpServletRequest request, HttpServletResponse response) ，下面的代码是发挥RequestMappingHandlerMapping作用的地方 12345678910HandlerExecutionChain mappedHandler = null;...// Determine handler for the current request.// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中mappedHandler = getHandler(processedRequest);if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return;&#125; 还是进入 getHandler方法，这里会遍历到我们的RequestMappingHandlerMapping 这个HandlerMapping，通过HandlerExecutionChain handler = hm.getHandler(request); 得到HandlerExecutionChain 12345678910111213141516protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; // 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; // 注意这里是找到第一个就直接返回 return handler; &#125; &#125; return null;&#125; 进入hm.getHandler(request); 会跳到我们的AbstractHandlerMapping 类中，RequestMappingHandlerMapping 继承该类，由下面代码可以看到这里这里获取了 handler 及 Interceptor 并封装为HandlerExecutionChain 返回调用者 1234567891011121314151617181920212223242526272829303132/** * Look up a handler for the given request, falling back to the default * handler if no specific one is found. * @param request current HTTP request * @return the corresponding handler instance, or the default handler * @see #getHandlerInternal */@Overridepublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 在这里获取 处理器handler，模板方法实现， RequestMappingHandlerMapping 跳到 AbstractHandlerMethodMapping Object handler = getHandlerInternal(request); if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // Bean name or resolved handler? if (handler instanceof String) &#123; String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); &#125; // 获取 拦截器Interceptor HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); if (CorsUtils.isCorsRequest(request)) &#123; CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request); CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig); executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain;&#125; 关注Object handler = getHandlerInternal(request); 这里是获取handler的地方，这时又会跳到AbstractHandlerMethodMapping 类中，这样跳来跳去可以看到封装的特性及使用模板方法提高了扩展性 1234567891011121314151617181920212223242526272829/** * Look up a handler method for the given request. */@Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; // 获取请求url路径 localhost:8080/pub/account/list &gt;&gt;&gt; /pub/account/list String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); if (logger.isDebugEnabled()) &#123; logger.debug(\"Looking up handler method for path \" + lookupPath); &#125; // mappingRegistry添加读锁，其他线程只能读不能写 this.mappingRegistry.acquireReadLock(); try &#123; // 根据request获取对应的HandlerMethod HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); if (logger.isDebugEnabled()) &#123; if (handlerMethod != null) &#123; logger.debug(\"Returning handler method [\" + handlerMethod + \"]\"); &#125; else &#123; logger.debug(\"Did not find handler method for [\" + lookupPath + \"]\"); &#125; &#125; return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); &#125; finally &#123; this.mappingRegistry.releaseReadLock(); &#125;&#125; 关注 HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); 这行代码，进入该方法，可以看到这个方法的作用是得到HandlerMethod 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 查找当前request请求 最为匹配的处理方法HandlerMethod，如果有多个匹配结果，则选择最佳匹配结果 * Look up the best-matching handler method for the current request. * If multiple matches are found, the best match is selected. * @param lookupPath mapping lookup path within the current servlet mapping * @param request the current request * @return the best-matching handler method, or &#123;@code null&#125; if no match * @see #handleMatch(Object, String, HttpServletRequest) * @see #handleNoMatch(Set, String, HttpServletRequest) */protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123; List&lt;Match&gt; matches = new ArrayList&lt;Match&gt;(); // 根据URL来获取,springMVC会在初始化的时候建立URL和相应RequestMappingInfo的映射。如果不是restful接口，这里就可以直接获取到了， lookupPath: /pub/account/list List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath); if (directPathMatches != null) &#123; // 匹配校验 addMatchingMappings(directPathMatches, matches, request); &#125; if (matches.isEmpty()) &#123; // 全盘扫描 // No choice but to go through all mappings... addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request); &#125; // 得到匹配结果 if (!matches.isEmpty()) &#123; Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); Collections.sort(matches, comparator); if (logger.isTraceEnabled()) &#123; logger.trace(\"Found \" + matches.size() + \" matching mapping(s) for [\" + lookupPath + \"] : \" + matches); &#125; Match bestMatch = matches.get(0); if (matches.size() &gt; 1) &#123; if (CorsUtils.isPreFlightRequest(request)) &#123; return PREFLIGHT_AMBIGUOUS_MATCH; &#125; Match secondBestMatch = matches.get(1); // 如果最佳匹配 第二佳匹配都是同一个则报错 if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.handlerMethod.getMethod(); Method m2 = secondBestMatch.handlerMethod.getMethod(); throw new IllegalStateException(\"Ambiguous handler methods mapped for HTTP path '\" + request.getRequestURL() + \"': &#123;\" + m1 + \", \" + m2 + \"&#125;\"); &#125; &#125; // 设置HttpServletRequest值 handleMatch(bestMatch.mapping, lookupPath, request); return bestMatch.handlerMethod; &#125; else &#123; // 没有找到匹配，返回null return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request); &#125;&#125; 查看这行代码可以看到是通过url来获取this.mappingRegistry.getMappingsByUrl(lookupPath);，进入该方法，可以看到this.urlLookup是MappingRegistry类中的一个Map,直接通过 url为key得到值 123456789101112131415161718192021222324class MappingRegistry &#123; private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = new HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;(); private final Map&lt;T, HandlerMethod&gt; mappingLookup = new LinkedHashMap&lt;T, HandlerMethod&gt;(); private final MultiValueMap&lt;String, T&gt; urlLookup = new LinkedMultiValueMap&lt;String, T&gt;(); private final Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = new ConcurrentHashMap&lt;String, List&lt;HandlerMethod&gt;&gt;(); private final Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup = new ConcurrentHashMap&lt;HandlerMethod, CorsConfiguration&gt;(); private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); ... */ public List&lt;T&gt; getMappingsByUrl(String urlPath) &#123; // MultiValueMap&lt;String, T&gt; urlLookup 就是个map return this.urlLookup.get(urlPath); &#125; 下图是this.urlLookup.get(urlPath) 的到的结果，返回的是个list image 返回到lookupHandlerMethod(String lookupPath, HttpServletRequest request) 方法，这里使用了Match做了匹配处理，得到最佳Match bestMatch 对象，最后返回HandlerMethod，在此终于得到了HandlerMethod 3.1 总结 RequestMappingHandlerMapping 的主要功能就是通过 reqeust 获取 HandlerExecutionChain 的 HandlerMethod、Interceptor。 下图是RequestMappingHandlerMapping工作流程图，可以看到RequestMappingHandlerMapping 一个类的实现分了4层，HandlerMapping 接口定义顶级方法，两个抽象类又分两次封装，由上而下，逐渐细分功能 image 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程","date":"2019-02-26T12:59:44.000Z","updated":"2019-02-26T12:19:01.597Z","comments":true,"path":"2019/02/26/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程/","link":"","permalink":"http://www.songshuiyang.site/2019/02/26/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程/","excerpt":"","text":"1.1 前言 上一章节介绍了请求映射处理组件HandlerMapping的主体处理流程，根据request url 获取对应的处理器Handler，这一章节来详细介绍我们平常最多使用的RequestMappingHandlerMapping的加载，这个HandlerMapping 是怎样加载基于@Controller,@RequestMapping 实现的Controller 2.1 解析 接下来我们关注RequestMappingHandlerMapping这个HandlerMapping，因为这个是我们开发过程中最为常用的HandlerMapping，那么它是怎样实现HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; 这个方法，先看一下RequestMappingHandlerMapping的继承关系 image 2.1.1 RequestMappingHandlerMapping 加载过程 有上图可以看到RequestMappingHandlerMapping 的父类AbstractHandlerMethodMapping 实现了InitializingBean 接口，InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类， 在初始化bean的时候都会执行该方法。 1234567891011121314public interface InitializingBean &#123; /** * Invoked by a BeanFactory after it has set all bean properties supplied * (and satisfied BeanFactoryAware and ApplicationContextAware). * &lt;p&gt;This method allows the bean instance to perform initialization only * possible when all bean properties have been set and to throw an * exception in the event of misconfiguration. * @throws Exception in the event of misconfiguration (such * as failure to set an essential property) or if initialization fails. */ void afterPropertiesSet() throws Exception;&#125; 查看AbstractHandlerMethodMapping类 afterPropertiesSet()的实现 1234567/** * Detects handler methods at initialization. */@Overridepublic void afterPropertiesSet() &#123; initHandlerMethods();&#125; 又抽象了一个方法，通过方法名可以得到是初始化HandlerMethods，进入initHandlerMethods(); 方法，这个方法是扫描ApplicationContext 所有的bean，如果发现了该bean是Handler，并把它注册为handler methods 1234567891011121314151617181920212223242526272829303132333435363738/** * Scan beans in the ApplicationContext, detect and register handler methods. * @see #isHandler(Class) * @see #getMappingForMethod(Method, Class) * @see #handlerMethodsInitialized(Map) */protected void initHandlerMethods() &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Looking for request mappings in application context: \" + getApplicationContext()); &#125; // 首先拿到容器的所有的beanName数组 String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) : getApplicationContext().getBeanNamesForType(Object.class)); for (String beanName : beanNames) &#123; if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123; // 得到bean类型 Class&lt;?&gt; beanType = null; try &#123; beanType = getApplicationContext().getType(beanName); &#125; catch (Throwable ex) &#123; // An unresolvable bean type, probably from a lazy bean - let's ignore it. if (logger.isDebugEnabled()) &#123; logger.debug(\"Could not resolve target class for bean with name '\" + beanName + \"'\", ex); &#125; &#125; // 检查bean所在的类是否有Controller注解及RequestMapping注解 if (beanType != null &amp;&amp; isHandler(beanType)) &#123; // 负责将Handler保存到Map里 detectHandlerMethods(beanName); &#125; &#125; &#125; // 对Handler进行一些初始化，是一个模板方法 handlerMethodsInitialized(getHandlerMethods());&#125; String[] beanNames 示例 iamge 进入isHandler(beanType)方法，，此方法由RequestMappingHandlerMapping实现， 此方法检查bean所在的类是否有Controller注解及RequestMapping注解，可以看到此方法的实现是在RequestMappingHandlerMapping里，是不是看到了我们熟悉的两个注解 12345678910/** * 检查bean所在的类是否有Controller注解及RequestMapping注解 * &#123;@inheritDoc&#125; * Expects a handler to have a type-level @&#123;@link Controller&#125; annotation. */@Overrideprotected boolean isHandler(Class&lt;?&gt; beanType) &#123; return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) || AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));&#125; 如果该bean有 Controller注解及RequestMapping注解，则执行detectHandlerMethods(beanName);方法，下面举个例子，我们有一个UserController里面有五个方法，下面来看是怎么处理这个类的 12345678910111213141516171819202122232425262728293031323334@RestController@RequestMapping(\"/pub/account\")public class UserController &#123; @Autowired private UserService userService; @GetMapping(\"/list\") public List&lt;User&gt; findAll() &#123; return userService.findAll(); &#125; @GetMapping(\"/view\") public User view() &#123; return userService.findById(1); &#125; @GetMapping(\"/&#123;id&#125;\") public User view(@PathVariable(\"id\") Integer id) &#123; return userService.findById(id); &#125; @PostMapping(\"/\") public void updateUser(@RequestBody User user) &#123; User user1 = userService.findById(user.getId()); user1.setUsername(\"update\"); userService.saveSelective(user1); &#125; @DeleteMapping(\"/&#123;id&#125;\") public void deleteUser(@PathVariable(\"id\") Integer id) &#123; userService.logicDeleteOne(id); &#125;&#125; 进入detectHandlerMethods(beanName);方法，可以看到Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods 获取到了我们五个方法，Map&lt;Method, T&gt; methods 以Method为key，RequestMappingInfo为value image 1234567891011121314151617181920212223242526272829303132333435/** * Look for handler methods in a handler. * @param handler the bean name of a handler or a handler instance */protected void detectHandlerMethods(final Object handler) &#123; // 获取Handler的类型 Class&lt;?&gt; handlerType = (handler instanceof String ? getApplicationContext().getType((String) handler) : handler.getClass()); final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType); // 这里获取 RequestMapping方法，会过滤掉普通方法 Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, new MethodIntrospector.MetadataLookup&lt;T&gt;() &#123; @Override public T inspect(Method method) &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Invalid mapping on handler class [\" + userType.getName() + \"]: \" + method, ex); &#125; &#125; &#125;); if (logger.isDebugEnabled()) &#123; logger.debug(methods.size() + \" request handler methods found on \" + userType + \": \" + methods); &#125; for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123; Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType); T mapping = entry.getValue(); // 注册 mappingRegistry registerHandlerMethod(handler, invocableMethod, mapping); &#125;&#125; 进入getMappingForMethod(method, userType) ，此方法在RequestMappingHandlerMapping实现，这里解析分两步解析，一个是方法method解析，另一个是方法所在类handlerType的解析，然后拼接成一个RequestMappingInfo，可以看到也是对RequestMapping注解的解析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 没有使用 &#123;@code @RequestMapping&#125; 注解会返回null * Uses method and type-level @&#123;@link RequestMapping&#125; annotations to create * the RequestMappingInfo. * @return the created RequestMappingInfo, or &#123;@code null&#125; if the method * does not have a &#123;@code @RequestMapping&#125; annotation. * @see #getCustomMethodCondition(Method) * @see #getCustomTypeCondition(Class) */@Overrideprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) &#123; // 解析method的@RequestMapping RequestMappingInfo info = createRequestMappingInfo(method); if (info != null) &#123; // 解析Class的@RequestMapping RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType); if (typeInfo != null) &#123; // 合并两个RequestMappingInfo 比如url拼接 info = typeInfo.combine(info); &#125; &#125; // 不是RequestMapping方法返回null return info;&#125;private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) &#123; // 拿到注解 RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class); RequestCondition&lt;?&gt; condition = (element instanceof Class ? getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element)); return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);&#125;protected RequestMappingInfo createRequestMappingInfo( RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition) &#123; // 用@RequestMapping的属性生成RequestMappingInfo return RequestMappingInfo .paths(resolveEmbeddedValuesInPatterns(requestMapping.path())) .methods(requestMapping.method()) .params(requestMapping.params()) .headers(requestMapping.headers()) .consumes(requestMapping.consumes()) .produces(requestMapping.produces()) .mappingName(requestMapping.name()) .customCondition(customCondition) .options(this.config) .build();&#125; RequestMappingInfo.java 对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。 12345678910111213141516171819public final class RequestMappingInfo implements RequestCondition&lt;RequestMappingInfo&gt; &#123; private final String name; private final PatternsRequestCondition patternsCondition; private final RequestMethodsRequestCondition methodsCondition; private final ParamsRequestCondition paramsCondition; private final HeadersRequestCondition headersCondition; private final ConsumesRequestCondition consumesCondition; private final ProducesRequestCondition producesCondition; private final RequestConditionHolder customConditionHolder; ... 返回到detectHandlerMethods方法 123456789101112131415161718192021222324252627282930protected void detectHandlerMethods(final Object handler) &#123; // 获取Handler的类型 Class&lt;?&gt; handlerType = (handler instanceof String ? getApplicationContext().getType((String) handler) : handler.getClass()); final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType); // 这里获取 RequestMapping方法，会过滤掉普通方法 Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, new MethodIntrospector.MetadataLookup&lt;T&gt;() &#123; @Override public T inspect(Method method) &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Invalid mapping on handler class [\" + userType.getName() + \"]: \" + method, ex); &#125; &#125; &#125;); if (logger.isDebugEnabled()) &#123; logger.debug(methods.size() + \" request handler methods found on \" + userType + \": \" + methods); &#125; for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123; Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType); T mapping = entry.getValue(); // 注册 mappingRegistry registerHandlerMethod(handler, invocableMethod, mapping); &#125;&#125; 得到Map&lt;Method, T&gt; methods方法之后，就是把这些信息保存起来，registerHandlerMethod(handler, invocableMethod, mapping); 这行代码就是做的这个功能 123456789101112131415161718192021222324252627282930313233343536373839404142protected void registerHandlerMethod(Object handler, Method method, T mapping) &#123; this.mappingRegistry.register(mapping, handler, method);&#125; public void register(T mapping, Object handler, Method method) &#123; // 加锁 this.readWriteLock.writeLock().lock(); try &#123; // 创建HandlerMethod HandlerMethod handlerMethod = createHandlerMethod(handler, method); assertUniqueMethodMapping(handlerMethod, mapping); if (logger.isInfoEnabled()) &#123; logger.info(\"Mapped \\\"\" + mapping + \"\\\" onto \" + handlerMethod); &#125; this.mappingLookup.put(mapping, handlerMethod); List&lt;String&gt; directUrls = getDirectUrls(mapping); for (String url : directUrls) &#123; this.urlLookup.add(url, mapping); &#125; String name = null; if (getNamingStrategy() != null) &#123; name = getNamingStrategy().getName(handlerMethod, mapping); addMappingName(name, handlerMethod); &#125; CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping); if (corsConfig != null) &#123; this.corsLookup.put(handlerMethod, corsConfig); &#125; /** * private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = new HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;(); * key: RequestMappingInfo */ this.registry.put(mapping, new MappingRegistration&lt;T&gt;(mapping, handlerMethod, directUrls, name)); &#125; finally &#123; this.readWriteLock.writeLock().unlock(); &#125;&#125; 查看private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry 对象，见下图key值是RequestMappingInfo value是MappingRegistration image MappingRegistration.java 1234567891011private static class MappingRegistration&lt;T&gt; &#123; private final T mapping; private final HandlerMethod handlerMethod; private final List&lt;String&gt; directUrls; private final String mappingName; ... 3.1 总结 Spring Mvc提供了各种各样的抽象，你能感受到面向对象的魅力。 RequestMappingInfo 这个类是对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。 HandlerMethod这个类封装了处理器实例（Controller Bean）和 处理方法实例（Method）以及方法参数数组（MethodParameter[]） MethodParameter 这个类从2.0就有了，它封装了方法某个参数的相关信息及行为，如该参数的索引，该参数所属方法实例或构造器实例，该参数的类型等。 HandlerMapping 该接口的实现类用来定义请求和处理器之前的映射关系，其中只定义了一个方法getHandler。 AbstractHandlerMethodMapping 这是HandlerMapping的一个基本实现类，该类定义了请求与HandlerMethod实例的映射关系。 RequestMappingInfoHandlerMapping这个是AbstractHandlerMethodMapping的实现类，他维护了一个RequestMappingInfo和HandlerMethod的Map属性。 RequestMappingHandlerMapping 这个是RequestMappingInfoHandlerMapping的子类，它将@RequestMapping注解转化为RequestMappingInfo实例，并为父类使用。也就是我们处理@RequestMapping的终点。 InitializingBean 这个接口定义了其实现Bean在容器完成属性设置后可以执行自定义初始化操作，我们的AbstractHandlerMethodMapping便实现了这个接口，并且定义了一组自定义操作，就是用来检测处理我们的@RequestMapping注解。 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.cnblogs.com/taotingkai/p/8438360.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(四)请求映射处理组件HandlerMapping","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping","date":"2019-02-25T12:59:44.000Z","updated":"2019-03-03T02:27:39.715Z","comments":true,"path":"2019/02/25/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping/","link":"","permalink":"http://www.songshuiyang.site/2019/02/25/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping/","excerpt":"","text":"1.1 前言 上一章节介绍了Spring Mvc执行一个普通请求的整体流程，这一章节介绍其请求映射处理组件HandlerMapping 的作用 HandlerMapping负责根据request请求找到对应的Handler处理器及Interceptor拦截器,并将它们封装在HandlerExecutionChain对象内，返回给中央调度器 2.1 请求映射处理组件HandlerMapping 解析2.1.1 HandlerMapping 解析 先来回顾核心方法体doDispatch(HttpServletRequest request, HttpServletResponse response)，查看HandlerMapping 对应的处理逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否有 Multipart，有则将请求转换为 Multipart 请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中 mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理 last-modified 请求头 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 执行实际的处理程序 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 遍历拦截器，执行它们的 postHandle() 方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion // 遍历拦截器，执行它们的 afterCompletion() 方法 if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 下面是请求映射处理组件HandlerMapping 主要的处理代码 12345678910HandlerExecutionChain mappedHandler = null;...// Determine handler for the current request.// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中mappedHandler = getHandler(processedRequest);if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return;&#125; 继续在doDispatch方法中mappedHandler = getHandler(processedRequest); 这行代码打好断点，进入该方法 12345678910111213141516171819202122/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; // 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; // 注意这里是找到第一个就直接返回 return handler; &#125; &#125; return null;&#125; this.handlerMappings 12/** List of HandlerMappings used by this servlet */private List&lt;HandlerMapping&gt; handlerMappings; 可以看到是遍历了this.handlerMappings这个对象，这个对象是个list，HandlerMapping的初始化处理在第二章有其介绍， 在调试过程中，我们可以看到，默认加载的是如下图所示的的HandlerMapping， 下面来介绍这三种常用的HandlerMapping的作用 RequestMappingHandlerMapping是三个中最常用的handlerMapping，使用注解方式最为方便快捷，SpringMvc项目开发都是采用这种形式，配合@RequestMapping()相关注释就可以完成开发 12345678910111213141516171819&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;&lt;mvc:annotation-driven /&gt; &lt;!-- 访问静态资源 --&gt;&lt;mvc:default-servlet-handler /&gt; &lt;!-- 配置扫描的包 --&gt;&lt;context:component-scan base-package=\"com.songsy.*\" /&gt; @RestController@RequestMapping(\"/hello\")public class HelloController &#123; protected final Log logger = LogFactory.getLog(this.getClass()); @RequestMapping(\"/index\") public String index()&#123; return \"test\"; &#125;&#125; SimpleUrlHandlerMapping SimpleUrlHandlerMapping的Controller处理类需要实现Controller接口，并注册成Bean就可以完成配置，处理逻辑写在handleRequest方法体内 12345678910111213141516171819&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/simpleUrlHandlerMapping.do\"&gt;welcomeController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;/** * @author Rob Harrop */public class WelcomeController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) &#123; return new ModelAndView(\"welcomeView\"); &#125;&#125; BeanNameUrlHandlerMapping需要配置 &lt;bean id=&quot;/index&quot; class=&quot;com.alipay.web.TestController&quot; /&gt;，注意在bean的id中要加上斜杆，Controller方面的测试代码跟前面的SimpleUrlHandlerMapping一样，实现Controller，重写handlerRequest()方法即可。 2.1.2 HandlerMapping 注册过程 回到DispatcherServlet 类中onRefresh 方法 1234567891011121314151617181920/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 进入initHandlerMappings(context);方法，这里实现了HandlerMappings的注册过程， BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); 可以看到用了Spring的工具类 beansOfTypeIncludingAncestors 返回给定类型或子类型的所有bean 1234567891011121314151617181920212223242526272829303132333435363738/** * Initialize the HandlerMappings used by this class. * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace, * we default to BeanNameUrlHandlerMapping. */private void initHandlerMappings(ApplicationContext context) &#123; this.handlerMappings = null; if (this.detectAllHandlerMappings) &#123; // Find all HandlerMappings in the ApplicationContext, including ancestor contexts. // 在ApplicationContext bean中找到所有HandlerMappings Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values()); // We keep HandlerMappings in sorted order. AnnotationAwareOrderComparator.sort(this.handlerMappings); &#125; &#125; else &#123; try &#123; HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); this.handlerMappings = Collections.singletonList(hm); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we'll add a default HandlerMapping later. &#125; &#125; // Ensure we have at least one HandlerMapping, by registering // a default HandlerMapping if no other mappings are found. if (this.handlerMappings == null) &#123; this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); if (logger.isDebugEnabled()) &#123; logger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\"); &#125; &#125;&#125; 下一章节来跟进RequestMappingHandlerMapping这个HandlerMapping 的具体实现 3.1 总结 HandlerMapping我们知道他的作用是根据request找到对应的Handler，Handler具体表现形式可以为类，也可以为方法，上面的三种常用的HandlerMapping有其介绍，我们平常使用@RequestMapping注解来标识一个方法，这个注解的作用就是将这个方法注册为Handler 为什么需要要多种HandlerMapping呢，当然是为了其可扩展性，实现HandlerMapping接口就可以实现自定义Handler的获取，从而实现定制化 Spring Mvc 大量使用了模版方法模式，父类定义流程，子类实现，而这些口子都是所谓的模板方法，可以自由指定，从而保证了灵活性，良好的抽象设计，是整个框架变得非常灵活 Spring Mvc 核心类中所有的变量声明，几乎都以接口的形式给出，并没有绑定在具体的实现类上 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.jianshu.com/p/e4f1c9326223 https://blog.csdn.net/gaoshan12345678910/article/details/81778587 https://blog.csdn.net/lang_programmer/article/details/71598042","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(三)核心分发器DispatcherServlet处理流程","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程","date":"2019-01-28T12:59:44.000Z","updated":"2019-03-03T02:27:39.701Z","comments":true,"path":"2019/01/28/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程/","link":"","permalink":"http://www.songshuiyang.site/2019/01/28/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程/","excerpt":"","text":"1.1 前言上一章节介绍了DispatcherServlet的初始化过程，这一章节介绍核心分发器DispatcherServlet是怎样处理请求的 2.1 DispatcherServlet 处理请求过程 既然DispatcherServlet本身是Servlet，我们就要专注于它的service、doGet、doPost等相关方法，在FrameworkServlet里可以看到service、doGet、doPost这些方法的重载实现，可以看到都是流转到processRequest(request, response);这个方法中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Override the parent class implementation in order to intercept PATCH requests. */@Overrideprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123; processRequest(request, response); &#125; else &#123; super.service(request, response); &#125;&#125;/** * Delegate GET requests to processRequest/doService. * &lt;p&gt;Will also be invoked by HttpServlet's default implementation of &#123;@code doHead&#125;, * with a &#123;@code NoBodyResponse&#125; that just captures the content length. * @see #doService * @see #doHead */@Overrideprotected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125;/** * Delegate POST requests to &#123;@link #processRequest&#125;. * @see #doService */@Overrideprotected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125;/** * Delegate PUT requests to &#123;@link #processRequest&#125;. * @see #doService */@Overrideprotected final void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125;/** * Delegate DELETE requests to &#123;@link #processRequest&#125;. * @see #doService */@Overrideprotected final void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125; 根据service方法，我们一步步找到一个方法链service –&gt; processRequest –&gt; doService –&gt; doDispatch，我们最终将目光定位在doDispatch，因为从它的方法体就可以看出它是整个SpringMVC的核心方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否有 Multipart，有则将请求转换为 Multipart 请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中 mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理 last-modified 请求头 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 执行实际的处理程序 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 遍历拦截器，执行它们的 postHandle() 方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion // 遍历拦截器，执行它们的 afterCompletion() 方法 if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 说它是核心一点也不为过，从上述代码的中文注释可以看出，它包含了解析请求，执行相关拦截器，执行handle方法，这行代码是真正执行我们controller的方法mv = ha.handle(processedRequest, response, mappedHandler.getHandler());，那SpringMvc是怎样找到我们的方法的呢，下一章节将介绍 3.1 总结 Spring Mvc 的处理方式是先在顶层设计好整体结构，然后将具体的处理交给不同的组件具体去实现 DispatcherServlet中的doDispatch方法完成了具体的请求处理，下面是主要流程 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecutionChain 对象中 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter 执行相应拦截器Interceptor的preHandle方法 HandlerAdapter 执行Hander，由Hander 执行实际的处理程序，执行Controller里的方法 调用processDispatchResult处理结果 执行相应拦截器Interceptor的postHandle方法 下面是流程图 下面的章节将详细介绍这些流程 1、请求映射处理组件HandlerMapping处理 2、HandlerAdapter处理 3、Interceptor的preHandle方法处理 4、Hander 执行实际的处理程序，执行Controller里的方法 5、调用processDispatchResult处理结果 6、Interceptor的postHandle`方法处理4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html https://blog.csdn.net/lang_programmer/article/details/71598042","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(二)核心分发器DispatcherServlet初始化","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化","date":"2019-01-23T12:59:44.000Z","updated":"2019-03-10T01:44:49.407Z","comments":true,"path":"2019/01/23/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化/","link":"","permalink":"http://www.songshuiyang.site/2019/01/23/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化/","excerpt":"","text":"1.1 前言我们都知道DispatcherServlet是所谓前端控制器，是整个Spring Mvc的入口，但是这个前端控制器里面又有很多箱子，每一个箱子都有其独有的功能，当我们翻开一个箱子之后看看里面有什么的时候，又会发现箱子里面装着又一个箱子，所以我们需要一个个的探究这些箱子。 2.1 DispatcherServlet 初始化过程2.1.1 配置 DispatcherServlet 首先，Tomcat每次启动时都会加载并解析/WEB-INF/web.xml文件，所以可以先从web.xml找突破口，主要代码如下 12345678910111213141516&lt;servlet &gt; &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt; &lt;!-- servlet类 --&gt; &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化参数 --&gt; &lt;init-param &gt; &lt;param-name &gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value &gt;classpath:/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动时加载 --&gt; &lt;load-on-startup &gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping &gt; &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt; &lt;url-pattern &gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 可以看到 DispatcherServlet 本身就是个Servlet，那么看看DispatcherServlet做了什么呢，我们先看下DispatcherServlet的继承关系，重点关注HttpServletBean 和FrameworkServlet 这两个类 12345GenericServlet (javax.servlet) HttpServlet (javax.servlet.http) HttpServletBean (org.springframework.web.servlet) FrameworkServlet (org.springframework.web.servlet) DispatcherServlet (org.springframework.web.servlet) 通过上图可以看到 DispatcherServlet 实现了Spring 的ApplicationContextAware、EnvironmentCapable、 EnvironmentAware这些Spring中的接口，XXXAware在Spring中表示对XXX可以感知，通俗点可以说在某个类中想使用Spring的一些东西，就可以实现XXXAware接口告诉Spring我要这个东西，比如ApplicationContextAware，该接口只有一个方法就是setApplicationContext(ApplicationContext applicationContext), 通过该方法可以得到ApplicationContext，Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。实现XXXCapable接口表示可以得到某种能力，实现EnvironmentCapable接口说明可以得到Environment的能力，也就是可以提供Environment1234567@Overridepublic void setApplicationContext(ApplicationContext applicationContext) &#123; if (this.webApplicationContext == null &amp;&amp; applicationContext instanceof WebApplicationContext) &#123; this.webApplicationContext = (WebApplicationContext) applicationContext; this.webApplicationContextInjected = true; &#125;&#125; 1234567@Override public ConfigurableEnvironment getEnvironment() &#123; if (this.environment == null) &#123; this.environment = createEnvironment(); &#125; return this.environment; &#125; HttpServletBean 覆写了GenericServlet 的init方法，此方法是第一次访问该DispatcherServlet的时候就会执行，对初始化过程做了一些处理，HttpServletBean 这个类的作用主要做一些初始化的工作，将web.xml中配置的参数设置到Servlet中。比如servlet标签的子标签init-param标签中配置的参数(classpath:/spring-mvc.xml)。 12345678910111213141516171819202122232425262728293031323334@Overridepublic final void init() throws ServletException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Initializing servlet '\" + getServletName() + \"'\"); &#125; // 构造过程中会使用ServletConfig对象找出web.xml配置文件中的配置参数并设置到ServletConfigPropertyValues内部 // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) &#123; try &#123; // 使用BeanWrapper构造DispatcherServlet BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); // 设置DispatcherServlet属性 bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; if (logger.isErrorEnabled()) &#123; logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); &#125; throw ex; &#125; &#125; // 让子类去做一些事情，这种在父类定义在子类实现的方式叫做模版方法模式 // Let subclasses do whatever initialization they like initServletBean(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\"); &#125;&#125; 关注initServletBean()方法，该方法的实现在FrameworkServlet 类里，这个类的作用是将Servlet与Spring容器上下文关联。其实也就是初始化FrameworkServlet的属性webApplicationContext 1234567891011121314151617181920212223242526272829303132/** * Overridden method of &#123;@link HttpServletBean&#125;, invoked after any bean properties * have been set. Creates this servlet's WebApplicationContext. */@Overrideprotected final void initServletBean() throws ServletException &#123; getServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\"); if (this.logger.isInfoEnabled()) &#123; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\"); &#125; long startTime = System.currentTimeMillis(); try &#123; // 初始化 WebApplicationContext (即SpringMVC的IOC容器) this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); &#125; catch (ServletException ex) &#123; this.logger.error(\"Context initialization failed\", ex); throw ex; &#125; catch (RuntimeException ex) &#123; this.logger.error(\"Context initialization failed\", ex); throw ex; &#125; if (this.logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" + elapsedTime + \" ms\"); &#125;&#125; 进入this.webApplicationContext = initWebApplicationContext();方法，这个方法的作用是先得到根上下文rootContext 然后创建webApplicationContext并设置根上下文（将 Spring 的容器设为 SpringMVC 容器的父容器），最后就是发布这个 WebApplicationContext 容器到 ServletContext 中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Initialize and publish the WebApplicationContext for this servlet. * &lt;p&gt;Delegates to &#123;@link #createWebApplicationContext&#125; for actual creation * of the context. Can be overridden in subclasses. * @return the WebApplicationContext instance * @see #FrameworkServlet(WebApplicationContext) * @see #setContextClass * @see #setContextConfigLocation */protected WebApplicationContext initWebApplicationContext() &#123; // 获取ContextLoaderListener 初始化并注册在 ServletContext 中的根容器，即 Spring 的容器 WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent // 将 Spring 的容器设为 SpringMVC 容器的父容器 cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id // 如果 WebApplicationContext 为空，则进行查找，能找到说明上下文已经在别处初始化。 wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 如果 WebApplicationContext 仍为空，则以 Spring 的容器为父上下文建立一个新的，并设置根上下文为父上下文 wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. // 模版方法，由 DispatcherServlet 实现 onRefresh(wac); &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. // 发布这个 WebApplicationContext 容器到 ServletContext 中 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() + \"' as ServletContext attribute with name [\" + attrName + \"]\"); &#125; &#125; return wac;&#125; 这里的根上下文是web.xml中配置的ContextLoaderListener监听器中根据contextConfigLocation路径生成的上下文。比如这段配置文件中根据classpath:springConfig/applicationContext.xml下的xml文件生成的根上下文。ContextLoaderListener 实现了ServletContextListener，当配置了listener之后启动web容器就会执行它实现的方法，使用ServletContextListener接口，开发者能够在客户端请求提供服务之前向ServletContext中添加任意的对象，ServletContext在web容器运行期间都是可见的 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springConfig/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; onRefresh(wac); 由 DispatcherServlet 实现，这里的操作就是Spring Mvc自身的初始化过程 1234567891011121314151617181920212223242526272829/** * This implementation calls &#123;@link #initStrategies&#125;. */@Overrideprotected void onRefresh(ApplicationContext context) &#123; // initStrategies方法内部会初始化各个策略接口的实现类。 initStrategies(context);&#125;/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 2.1.1 DispatcherServlet 默认加载bean DispatcherServlet 初始化的时候会默认加载一些组件，代码如下，可以看到是在static代码块中读取一个配置文件并把它注册为Properties defaultStrategies对象 1234567891011121314151617181920/** * Name of the class path resource (relative to the DispatcherServlet class) * that defines DispatcherServlet's default strategy names. */private static final String DEFAULT_STRATEGIES_PATH = \"DispatcherServlet.properties\";... static &#123; // Load default strategy implementations from properties file. // This is currently strictly internal and not meant to be customized // by application developers. try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage()); &#125; &#125; 查看DispatcherServlet.properties文件，该文件在Spring web mvc 包下 123456789101112131415161718192021222324# Default implementation classes for DispatcherServlet&apos;s strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager 从如上配置可以看出DispatcherServlet 配置的是一些类的全限定名，那它是在哪里调用的呢，还是回到之前的onRefresh(wac); 的initStrategies(ApplicationContext context)方法 12345678910111213141516protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 进入initHandlerMappings(context); 方法 12345678910111213141516171819202122232425262728293031323334private void initHandlerMappings(ApplicationContext context) &#123; this.handlerMappings = null; if (this.detectAllHandlerMappings) &#123; // Find all HandlerMappings in the ApplicationContext, including ancestor contexts. // 在ApplicationContext bean中找到所有HandlerMappings， beansOfTypeIncludingAncestors 返回给定类型或子类型的所有bean Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values()); // We keep HandlerMappings in sorted order. AnnotationAwareOrderComparator.sort(this.handlerMappings); &#125; &#125; else &#123; try &#123; HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); this.handlerMappings = Collections.singletonList(hm); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we'll add a default HandlerMapping later. &#125; &#125; // Ensure we have at least one HandlerMapping, by registering // a default HandlerMapping if no other mappings are found. if (this.handlerMappings == null) &#123; // 在这里将设置 this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); if (logger.isDebugEnabled()) &#123; logger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\"); &#125; &#125;&#125; 关注this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); 这行代码，可以看到this.handlerMappings 在这里赋值，继续进入该方法 1234567891011121314151617181920212223242526272829protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123; String key = strategyInterface.getName(); String value = defaultStrategies.getProperty(key); if (value != null) &#123; String[] classNames = StringUtils.commaDelimitedListToStringArray(value); List&lt;T&gt; strategies = new ArrayList&lt;T&gt;(classNames.length); for (String className : classNames) &#123; try &#123; Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader()); Object strategy = createDefaultStrategy(context, clazz); strategies.add((T) strategy); &#125; catch (ClassNotFoundException ex) &#123; throw new BeanInitializationException( \"Could not find DispatcherServlet's default strategy class [\" + className + \"] for interface [\" + key + \"]\", ex); &#125; catch (LinkageError err) &#123; throw new BeanInitializationException( \"Error loading DispatcherServlet's default strategy class [\" + className + \"] for interface [\" + key + \"]: problem with class file or dependent class\", err); &#125; &#125; return strategies; &#125; else &#123; return new LinkedList&lt;T&gt;(); &#125;&#125; 从可以看到String value = defaultStrategies.getProperty(key); 这里使用了我们的配置对象，createDefaultStrategy 方法就是根据Class对象来创建bean 123protected Object createDefaultStrategy(ApplicationContext context, Class&lt;?&gt; clazz) &#123; return context.getAutowireCapableBeanFactory().createBean(clazz);&#125; 3.1 总结 HttpServletBean 主要做一些初始化的工作，将web.xml中配置的参数设置到Servlet中。比如servlet标签的子标签init-param标签中配置的参数。 FrameworkServlet 将Servlet与Spring容器上下文关联。其实也就是初始化FrameworkServlet的属性webApplicationContext，这个属性代表SpringMVC上下文，它有个父类上下文，既web.xml中配置的ContextLoaderListener监听器初始化的容器上下文。 DispatcherServlet 初始化各个功能的实现类。比如异常处理、视图处理、请求映射处理等。 DispatcherServlet会自动注册一些特殊的Bean，无需我们注册，如果我们注册了，默认的将不会注册。 因此BeanNameUrlHandlerMapping、SimpleControllerHandlerAdapter是不需要注册的，DispatcherServlet默认会注册这两个Bean。 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html https://blog.csdn.net/lang_programmer/article/details/71598042","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(一)Spring Mvc介绍","slug":"backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(一)Spring Mvc介绍","date":"2019-01-23T11:59:44.000Z","updated":"2019-02-26T12:02:32.502Z","comments":true,"path":"2019/01/23/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(一)Spring Mvc介绍/","link":"","permalink":"http://www.songshuiyang.site/2019/01/23/backend/framework/spring/spring-mvc/analysis/Spring Mvc源码(一)Spring Mvc介绍/","excerpt":"","text":"1.1 什么是Spring Mvc 在JavaEE体系结构中一个应用可以划分为四个层次，从上到下分别是应用层、Web层、业务层、持久层，现在的项目大都是按照这种结构来开发，我们这一系列介绍的是Web层的处理框架Spring Mvc Spring Web Mvc是一种基于Java的轻量级Web框架，使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。 2.1 为什么要使用Spring Mvc2.1.1 没有使用Spring Mvc会怎么样在Web开发模式中，主要有两个开发模式，称为模式一（Mode I）和模式二（Mode II）. 模式二是因为受不了模式一的缺点而进化出来的，而Spring Mvc则是模式二的进化版本，下面是两种模式的介绍： 模式一（Mode I）指的就是在开发中将显示层、控制层、数据层的操作统一交给JSP或者JavaBean来进行处理！ 优点 开发速度贼快，适合炒鸡简单的应用 缺点 程序的可读性差、复用性低、代码复杂！什么jsp代码、html代码都往上面写，这肯定很难阅读，很难重用！ 要求开发者不仅要掌握 Java ，还要有高超的前端水平 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试 模式二（Mode II）中所有的开发都是以Servlet为主体展开的，由Servlet接收所有的客户端请求，然后根据请求调用相对应的JavaBean，并所有的显示结果交给JSP完成！，也就是俗称的MVC设计模式 优点 相比模式一，耦合度降低了，添加了Servlet来协调视图处理及业务数据处理 缺点 需要定义大量的Servlet来处理应用 MVC设计模式 模型层（Mode）：模型是什么呢？ 模型就是数据，就是 dao,bean 显示层（View）：视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 控制层（Controller）：控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。 很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合， 模式二（Mode II）就很完美吗，不不不，还可以进行优化，所以有了Web Mvc框架 常见的Web Mvc框架有Sturts及主角Spring Mvc 2.1.2 对比其他WEB框架有那些优势 使用简单，对于开发人员来说实现一个功能肯定是实现越简单越好，Spring Mvc配合一系列注解即可完成Web应用的开发，尤其是在SpringBoot上的体现越明显 性能上Spring会稍微比Struts快。Spring mvc是基于方法的设计，而Sturts是基于类，每次发一次请求都会实例一个action，每个action都会被注入属性，而Spring基于方法，粒度更细，但要小心把握像在Servlet控制数据一样。 易于和Spring容器集成，毕竟是自己家里人 3.1 使用Spring Mvc4.1 总结 框架本身就是为了找到一个平衡，用哪个合适，就用哪个 5.1 参考 官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.cnblogs.com/wmyskxz/p/8848461.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Mybatis源码(二十二)使用拦截器Interceptor完成分页","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页","date":"2018-12-22T12:56:00.000Z","updated":"2018-12-22T14:06:52.725Z","comments":true,"path":"2018/12/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页/","link":"","permalink":"http://www.songshuiyang.site/2018/12/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页/","excerpt":"","text":"前言只要有列表就会有分页功能，利用Mybatis拦截器Interceptor可以十分方便的完成分页功能 思路在执行查询sql之前的时候只要添加limit关键字，即可完成分页，除了分页之外需要count(*)获取数据总数，然后通过页码得到页数 实现 Page.java 分页对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189public class Page&lt;T&gt; &#123; private int end; // 当前页尾条记录位置 private int limit; // 每页记录数 private int page; // 当前页 private long total; // 总记录数 private String sortName; // 排序列 private String sortOrder; // 排序方式 private Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); // 请求参数 private List&lt;String&gt; columns = Lists.newArrayList(); // 查询出来的参数 private List&lt;T&gt; rows = new ArrayList&lt;&gt;(); // 记录 /** * 限制分页长度 * limit：0 不限制大小 * @param limit */ public Page(int limit) &#123; this.limit = limit; &#125; public Page(HttpServletRequest request) &#123; String param = null; String value = null; param = \"pageIndex\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.page = Integer.parseInt(value); &#125; else &#123; this.page = 1; &#125; param = \"limit\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.limit = Integer.parseInt(value); if (this.limit &gt; 15) &#123; this.limit = 15; &#125; &#125; else &#123; this.limit = 15; &#125; param = \"sortName\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.sortName = CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, value); &#125; param = \"sortOrder\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.sortOrder = value; &#125; else &#123; this.sortOrder = \"asc\"; &#125; Map&lt;String, String[]&gt; paramMap = request.getParameterMap(); for (String key : paramMap.keySet()) &#123; if (key.startsWith(\"s_\")) &#123; String vkey = key.substring(2); String[] _params = paramMap.get(key); if (_params.length &gt; 0 &amp;&amp; StringUtils.isNotEmpty(_params[0])) &#123; getParams().put(vkey, StringUtils.join(_params, \"&gt;\").trim()); &#125; &#125; &#125; &#125; /** * 当前页首条记录位置 * * @return */ public int getStart() &#123; if (page == 0) &#123; return 0; &#125; return (page - 1) * limit; &#125; /** * 总页数 * * @return */ public int getTotalPage() &#123; if (limit == 0) &#123; return 0; &#125; return (int) Math.ceil(total / Double.valueOf(limit)); &#125; /** * 必须和数据库字段一致 * * @param sortName */ public void setSortName(String sortName) &#123; this.sortName = sortName; &#125; /** * 设置默认排序方式 * * @param sortName 需要排序的表字段，数据库字段 * @param sortOrder */ public void sortDefault(String sortName, String sortOrder) &#123; if (org.apache.commons.lang3.StringUtils.isEmpty(getSortName()) || org.apache.commons.lang3.StringUtils.isEmpty(getSortOrder())) &#123; setSortName(sortName); setSortOrder(sortOrder); &#125; &#125; public String getSortName() &#123; return sortName; &#125; public String getSortOrder() &#123; return sortOrder; &#125; public void setSortOrder(String sortOrder) &#123; this.sortOrder = sortOrder; &#125; public Map&lt;String, Object&gt; getParams() &#123; return params; &#125; public void setParams(Map&lt;String, Object&gt; params) &#123; this.params = params; &#125; public void setParams(String key, Object value) &#123; Assert.notNull(key, \"key must be not null\"); Assert.notNull(value, \"value must be not null \"); this.params.put(key, value); &#125; public List&lt;T&gt; getRows() &#123; return rows; &#125; public void setRows(List&lt;T&gt; rows) &#123; this.rows = rows; &#125; public List&lt;String&gt; getColumns() &#123; return columns; &#125; public void setColumns(List&lt;String&gt; columns) &#123; this.columns = columns; &#125; public int getEnd() &#123; return end; &#125; public void setEnd(int end) &#123; this.end = end; &#125; public int getLimit() &#123; return limit; &#125; public void setLimit(int limit) &#123; this.limit = limit; &#125; public int getPage() &#123; return page; &#125; public void setPage(int page) &#123; this.page = page; &#125; public long getTotal() &#123; return total; &#125; public void setTotal(long total) &#123; this.total = total; &#125;&#125; PageInterceptor.java 拦截器，此类intercept 方法是完成分页实现方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/** * mybatis拦截器，实现接口分页，拦截Executor接口的query方法 */@Component@Intercepts(&#123; @Signature(type = Executor.class, method = \"query\", args = &#123; MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class &#125;) &#125;)public class PageInterceptor implements Interceptor &#123; private static Logger logger = LoggerFactory.getLogger(PageInterceptor.class); static int MAPPED_STATEMENT_INDEX = 0; static int PARAMETER_INDEX = 1; static int ROWBOUNDS_INDEX = 2; static int RESULT_HANDLER_INDEX = 3; // 需要拦截的ID(正则匹配) private static final String DEFAULT_PAGE_SQL_ID = \".*Page$\"; /** * setProperties方法是用于在Mybatis配置文件中指定一些属性的。 * @param properties */ @Override public void setProperties(Properties properties) &#123; &#125; /** * 拦截器用于封装目标对象 * 在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象 * @param o * @return */ @Override public Object plugin(Object o) &#123; if (Executor.class.isAssignableFrom(o.getClass())) &#123; // 在这里返回新的 PageExecutor，用于装饰原Executor return Plugin.wrap(new PageExecutor((Executor) o), this); &#125; return Plugin.wrap(o, this); &#125; /** * 在这里完成分页及排序操作得到 新的BoundSql 然后执行查询 * @param invocation * @return * @throws Throwable */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; final Object[] queryArgs = invocation.getArgs(); // MappedStatement对象对应Mapper配置文件中的一个select/update/insert/delete节点，主要描述的是一条SQL语句 final MappedStatement mappedStatement = (MappedStatement) queryArgs[MAPPED_STATEMENT_INDEX]; // 获取查询参数 final Object parameterObject = queryArgs[PARAMETER_INDEX]; BoundSql boundSql = mappedStatement.getBoundSql(parameterObject); // 拦截以Page结尾的查询方法 if (mappedStatement.getId().matches(DEFAULT_PAGE_SQL_ID)) &#123; if (parameterObject == null) &#123; throw new NullPointerException(\"parameterObject is null!\"); &#125; else &#123; // 如果查询参数是Page对象 if (parameterObject instanceof Page&lt;?&gt;) &#123; Page&lt;?&gt; page = (Page&lt;?&gt;) parameterObject; // 执行总记录数查询 setTotalRecord(page, mappedStatement, boundSql); // 拼接排序sql String orderSql = getOrderSql(boundSql.getSql(), page); // 拼接分页sql String pageSql = getPageSql(orderSql, page); logger.debug(\"page sql : &#123;&#125; \", pageSql); BoundSql newBoundSql = copyFromBoundSql(mappedStatement, boundSql, pageSql); MappedStatement newMappedStatement = copyFromMappedStatement(mappedStatement, new BoundSqlSqlSource(newBoundSql)); queryArgs[ROWBOUNDS_INDEX] = new RowBounds(RowBounds.NO_ROW_OFFSET, RowBounds.NO_ROW_LIMIT); queryArgs[MAPPED_STATEMENT_INDEX] = newMappedStatement; &#125; &#125; &#125; return invocation.proceed(); &#125; /** * 得到新的 BoundSql * @param ms * @param boundSql * @param sql * @return */ public static BoundSql copyFromBoundSql(MappedStatement ms, BoundSql boundSql, String sql) &#123; BoundSql newBoundSql = new BoundSql(ms.getConfiguration(), sql, boundSql.getParameterMappings(), boundSql.getParameterObject()); for (ParameterMapping mapping : boundSql.getParameterMappings()) &#123; String prop = mapping.getProperty(); if (boundSql.hasAdditionalParameter(prop)) &#123; newBoundSql.setAdditionalParameter(prop, boundSql.getAdditionalParameter(prop)); &#125; &#125; return newBoundSql; &#125; /** * 得到新的 MappedStatement * @param ms * @param newSqlSource * @return */ private static MappedStatement copyFromMappedStatement(MappedStatement ms, SqlSource newSqlSource) &#123; MappedStatement.Builder builder = new MappedStatement.Builder(ms.getConfiguration(), ms.getId(), newSqlSource, ms.getSqlCommandType()); builder.resource(ms.getResource()); builder.fetchSize(ms.getFetchSize()); builder.statementType(ms.getStatementType()); builder.keyGenerator(ms.getKeyGenerator()); String[] keyProperties = ms.getKeyProperties(); builder.keyProperty(keyProperties == null ? null : keyProperties[0]); builder.timeout(ms.getTimeout()); builder.parameterMap(ms.getParameterMap()); builder.resultMaps(ms.getResultMaps()); builder.resultSetType(ms.getResultSetType()); builder.cache(ms.getCache()); builder.flushCacheRequired(ms.isFlushCacheRequired()); builder.useCache(ms.isUseCache()); return builder.build(); &#125; public static class BoundSqlSqlSource implements SqlSource &#123; BoundSql boundSql; public BoundSqlSqlSource(BoundSql boundSql) &#123; this.boundSql = boundSql; &#125; public BoundSql getBoundSql(Object parameterObject) &#123; return boundSql; &#125; &#125; /** * 查询数据总数 * @param page * @param mappedStatement * @param boundSql */ private void setTotalRecord(Page&lt;?&gt; page, MappedStatement mappedStatement, BoundSql boundSql) throws Throwable &#123; String sql = getCountSql(boundSql.getSql()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); BoundSql countBoundSql = new BoundSql(mappedStatement.getConfiguration(), sql, parameterMappings, page); ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, page, countBoundSql); Connection con = mappedStatement.getConfiguration().getEnvironment().getDataSource().getConnection(); PreparedStatement stmt = null; ResultSet rs = null; try &#123; int total = 0; stmt = con.prepareStatement(sql); parameterHandler.setParameters(stmt); rs = stmt.executeQuery(); if (rs.next()) &#123; total = rs.getInt(1); &#125; page.setTotal(total); logger.debug(\"page count sql : &#123;&#125;\", sql); logger.debug(\"page count total : &#123;&#125;\", total); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.close(rs, stmt); JdbcUtils.close(con); &#125; &#125; /** * 得到统计总数sql * @param sql * @return */ private String getCountSql(String sql) &#123; int index = sql.indexOf(\"from\") == -1 ? sql.indexOf(\"FROM\") : sql.indexOf(\"from\"); return \"select count(*) \" + sql.substring(index); &#125; /** * 得到分页sql * @param sql * @param page * @return */ private String getPageSql(String sql, Page&lt;?&gt; page) &#123; if (page != null &amp;&amp; page.getLimit() &gt; 0) &#123; StringBuilder pageSql = getMySQLPageSql(sql, page); return pageSql.toString(); &#125; else &#123; return sql; &#125; &#125; /** * 得到排序sql * @param sql * @param page * @return */ private String getOrderSql(String sql, Page&lt;?&gt; page) &#123; if (org.apache.commons.lang3.StringUtils.isNotEmpty(page.getSortName())) &#123; StringBuilder pageSql = new StringBuilder(100); pageSql.append(sql); if ((page.getSortName().indexOf(\"_\") == -1)) &#123; page.setSortName(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, page.getSortName())); &#125; if ((\"asc\".equalsIgnoreCase(page.getSortOrder()) || \"desc\".equalsIgnoreCase(page.getSortOrder()))) &#123; pageSql.append(\" order by \" + page.getSortName() + \" \" + page.getSortOrder()); &#125; return pageSql.toString(); &#125; else &#123; return sql; &#125; &#125; /** * 得到mysql 分页语句 * @param sql * @param page * @return */ public StringBuilder getMySQLPageSql(String sql, Page page) &#123; StringBuilder pageSql = new StringBuilder(100); pageSql.append(sql); pageSql.append(\" limit \" + page.getStart() + \",\" + page.getLimit()); return pageSql; &#125;&#125; PageExecutor.java 用于装饰之前的Executor用于将结果赋值到Page对象的rows属性中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class PageExecutor implements Executor &#123; private static Logger logger = LoggerFactory.getLogger(PageExecutor.class); private final Executor executor; public PageExecutor(Executor executor) &#123; this.executor = executor; &#125; @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException &#123; final List&lt;E&gt; rows = executor.query(ms, parameter, rowBounds, resultHandler); if (parameter != null &amp;&amp; parameter instanceof Page&lt;?&gt;) &#123; Page&lt;E&gt; page = (Page&lt;E&gt;) parameter; doCache(ms, page, parameter, rowBounds); // 将结果赋值到Page对象的rows属性 page.setRows(rows); &#125; return rows; &#125; @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; final List&lt;E&gt; rows = executor.query(ms, parameter, rowBounds, resultHandler); if (parameter != null &amp;&amp; parameter instanceof Page&lt;?&gt;) &#123; Page&lt;E&gt; page = (Page&lt;E&gt;) parameter; doCache(ms, page, parameter, rowBounds); // 将结果赋值到Page对象的rows属性 page.setRows(rows); &#125; return rows; &#125; private &lt;E&gt; void doCache(MappedStatement ms, Page&lt;E&gt; result, Object parameter, RowBounds rowBounds) &#123; final Cache cache = ms.getCache(); if (executor.getClass().isAssignableFrom(CachingExecutor.class) &amp;&amp; cache != null) &#123; BoundSql boundSql = ms.getBoundSql(parameter); final CacheKey cacheKey = createCacheKey(ms, parameter, rowBounds, boundSql); if (logger.isDebugEnabled()) &#123; logger.debug(\"cache executor the cache's kye is \" + cacheKey); &#125; cache.putObject(cacheKey, result); &#125; &#125; @Override public void setExecutorWrapper(Executor executor) &#123; executor.setExecutorWrapper(executor); &#125; @Override public int update(MappedStatement ms, Object parameter) throws SQLException &#123; return executor.update(ms, parameter); &#125; @Override public List&lt;BatchResult&gt; flushStatements() throws SQLException &#123; return executor.flushStatements(); &#125; @Override public void commit(boolean required) throws SQLException &#123; executor.commit(required); &#125; @Override public void rollback(boolean required) throws SQLException &#123; executor.rollback(required); &#125; @Override public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123; return executor.createCacheKey(ms, parameterObject, rowBounds, boundSql); &#125; @Override public boolean isCached(MappedStatement ms, CacheKey key) &#123; return executor.isCached(ms, key); &#125; @Override public void clearLocalCache() &#123; executor.clearLocalCache(); &#125; @Override public void deferLoad(MappedStatement mappedStatement, MetaObject metaObject, String s, CacheKey cacheKey, Class&lt;?&gt; aClass) &#123; executor.deferLoad(mappedStatement, metaObject, s, cacheKey, aClass); &#125; @Override public Transaction getTransaction() &#123; return executor.getTransaction(); &#125; @Override public void close(boolean forceRollback) &#123; executor.close(forceRollback); &#125; @Override public boolean isClosed() &#123; return executor.isClosed(); &#125; @Override public &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二十三)Mybatis中#{}和${}","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}","date":"2018-12-22T10:12:00.000Z","updated":"2018-12-22T14:07:43.420Z","comments":true,"path":"2018/12/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}/","link":"","permalink":"http://www.songshuiyang.site/2018/12/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}/","excerpt":"","text":"前言Mybatis的Sql语句传参有两种方式：#{}和${} #{}是预编译处理 Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； 使用#{}可以有效的防止SQL注入，提高系统安全。 如：order by #{sortName}#，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;, ${}是字符串替换 Mybatis在处理${}时，就是把${}替换成变量的值。 如果是在SQL语句中插入一个不改变的字符串。比如，像ORDER BY，你可以这样来使用：ORDER BY ${columnName} 举个栗子 现在通过一个例子来分析其两者的区别 测试类 1234567891011121314151617181920/** * 测试 $ 和 # * @throws Exception */@Testpublic void selectByUsernameAndPasswordTest() throws Exception &#123; // 读取配置文件 File file = new File(\"src/test/java/resources/mybatis-config.xml\"); InputStream inputStream = new FileInputStream(file); // 构建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 得到Mapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername(\"songsy\"); user.setPassword(\"root\"); System.out.println(mapper.selectByUsernameAndPassword(user));&#125; Mapper.xml 配置文件1234567SELECT *FROM sys_userWHERE username = $&#123;username&#125;AND password = #&#123;password&#125; 执行mapper方法，打好断点，进入到Executor的query方法，关注BoundSql boundSql = ms.getBoundSql(parameterObject); 这行，BoundSql对象存放了处理完成之后的sql 1234567 @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; BoundSql boundSql = ms.getBoundSql(parameterObject);//query时传入一个cachekey参数 CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); &#125; 如下图所示，${username} 已经替换成了 songsy ， #{password} 替换成了 ? image 栗子剖析 Mybatis是怎样完成上面的替换解析过程呢，进入BoundSql boundSql = ms.getBoundSql(parameterObject); 方法，可以看到其实就是调用sqlSource.getBoundSql 12345678910111213141516171819 public BoundSql getBoundSql(Object parameterObject) &#123;// 其实就是调用sqlSource.getBoundSql BoundSql boundSql = sqlSource.getBoundSql(parameterObject); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings == null || parameterMappings.isEmpty()) &#123; boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject); &#125; // check for nested result maps in parameter mappings (issue #30) for (ParameterMapping pm : boundSql.getParameterMappings()) &#123; String rmId = pm.getResultMapId(); if (rmId != null) &#123; ResultMap rm = configuration.getResultMap(rmId); if (rm != null) &#123; hasNestedResultMaps |= rm.hasNestedResultMaps(); &#125; &#125; &#125; return boundSql; &#125; 进入sqlSource.getBoundSql(parameterObject); ，因为sql不是静态sql所以进入DynamicSqlSource 类的getBoundSql方法，这里传入了我们的user查询对象 12345678910111213141516171819202122232425262728293031323334/** * 动态SQL源码 * @author Clinton Begin */public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 下面的语句是动态sql的处理，循环执行SqlNode.apply方法，进入 rootSqlNode.apply(context);方法 123DynamicContext context = new DynamicContext(configuration, parameterObject);// 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数rootSqlNode.apply(context); 进入rootSqlNode.apply(context); 之后来到了MixedSqlNode类，这里依次调用list里每个元素的apply，如下图所示 image 执行sqlNode.apply(context);方法这里进入到TextSqlNode的apply方法，这里又调用了GenericTokenParser类的parser.parse(text)方法 1234567891011121314151617181920212223242526272829public class TextSqlNode implements SqlNode &#123; private String text; private Pattern injectionFilter; public TextSqlNode(String text) &#123; this(text, null); &#125; public TextSqlNode(String text, Pattern injectionFilter) &#123; this.text = text; this.injectionFilter = injectionFilter; &#125; //判断是否是动态sql public boolean isDynamic() &#123; DynamicCheckerTokenParser checker = new DynamicCheckerTokenParser(); GenericTokenParser parser = createParser(checker); parser.parse(text); return checker.isDynamic(); &#125; @Override public boolean apply(DynamicContext context) &#123; GenericTokenParser parser = createParser(new BindingTokenParser(context, injectionFilter)); context.appendSql(parser.parse(text)); return true; &#125; ... 进入 GenericTokenParser类的parser.parse(text)方法，可以看到这个类是处理#{}和${}参数的主要方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 普通记号解析器，处理#&#123;&#125;和$&#123;&#125;参数 * @author Clinton Begin */public class GenericTokenParser &#123; // 有一个开始和结束记号 private final String openToken; private final String closeToken; // 记号处理器 private final TokenHandler handler; public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) &#123; this.openToken = openToken; this.closeToken = closeToken; this.handler = handler; &#125; public String parse(String text) &#123; StringBuilder builder = new StringBuilder(); if (text != null &amp;&amp; text.length() &gt; 0) &#123; char[] src = text.toCharArray(); int offset = 0; int start = text.indexOf(openToken, offset); // #&#123;favouriteSection,jdbcType=VARCHAR&#125; // 这里是循环解析参数，参考GenericTokenParserTest,比如可以解析$&#123;first_name&#125; $&#123;initial&#125; $&#123;last_name&#125; reporting.这样的字符串,里面有3个 $&#123;&#125; while (start &gt; -1) &#123; // 判断一下 $&#123; 前面是否是反斜杠，这个逻辑在老版的mybatis中（如3.1.0）是没有的 if (start &gt; 0 &amp;&amp; src[start - 1] == '\\\\') &#123; // the variable is escaped. remove the backslash. // 新版已经没有调用substring了，改为调用如下的offset方式，提高了效率 // issue #760 builder.append(src, offset, start - offset - 1).append(openToken); offset = start + openToken.length(); &#125; else &#123; int end = text.indexOf(closeToken, start); if (end == -1) &#123; builder.append(src, offset, src.length - offset); offset = src.length; &#125; else &#123; builder.append(src, offset, start - offset); offset = start + openToken.length(); String content = new String(src, offset, end - offset); // 得到一对大括号里的字符串后，调用handler.handleToken,比如替换变量 $&#123;username&#125;这种功能 builder.append(handler.handleToken(content)); offset = end + closeToken.length(); &#125; &#125; start = text.indexOf(openToken, offset); &#125; if (offset &lt; src.length) &#123; builder.append(src, offset, src.length - offset); &#125; &#125; return builder.toString(); &#125;&#125; 执行完builder.append(handler.handleToken(content)); 这行代码之后就可以看到${username} 已经替换成songsy了 image 到现在已经完成了${username} 的处理，回到 DynamicSqlSource 类中，现在是处理#{password} 这些参数了 123456789101112131415161718192021222324252627282930public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#&#123;password&#125;都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 下图是处理完动态sql节点及${username}之后的结果 处理完${username} 节点之后现在就是处理#{password} 节点了，解析完了就把那些参数#{password}都替换成?了，也就是最基本的JDBC的SQL写法 12345// 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#&#123;password&#125;都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); 进入sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());方法，之后又是进入 GenericTokenParser类的parser.parse(text)方法，只不过handleToken方法执行的是下面的代码 1234567@Override public String handleToken(String content) &#123; // 先构建参数映射 parameterMappings.add(buildParameterMapping(content)); // 如何替换很简单，永远是一个问号，但是参数的信息要记录在parameterMappings里面供后续使用 return \"?\"; &#125; 最后拼接成的结果如下 1234567SELECT *FROM sys_userWHERE username = songsyAND password = ? 总结 #{}在一定程度上可以防止SQL的注入 ${}一般用在动态表名，动态字段，设置排序字段上 参考https://www.jianshu.com/p/a9cb929b533e","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二十一)拦截器Interceptor原理探究","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究","date":"2018-12-21T12:56:00.000Z","updated":"2018-12-22T14:02:27.290Z","comments":true,"path":"2018/12/21/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究/","link":"","permalink":"http://www.songshuiyang.site/2018/12/21/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究/","excerpt":"","text":"前言 MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用，拦截后用户可以完成一些额外的定制操作，比如实现分页，这一章节来介绍拦截器的一些基本知识及实现原理，下一章节将介绍如何用拦截器实现查询分页功能 默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： 12345678// 拦截执行器的方法Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)// 拦截参数的处理ParameterHandler (getParameterObject, setParameters)// 拦截结果集的处理ResultSetHandler (handleResultSets, handleOutputParameters)// 拦截Sql语法构建的处理StatementHandler (prepare, parameterize, batch, update, query) 拦截器的使用 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。 123456789101112131415// ExamplePlugin.java@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125; xml 配置 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 上面的插件将会拦截在 Executor 实例中所有的名为update 且参数为(MappedStatement.class,Object.class)的方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。 拦截器原理探究 拦截器定义 首先我们看下MyBatis拦截器的接口定义 Interceptor.java 12345678910111213141516/** * 拦截器 * @author Clinton Begin */public interface Interceptor &#123; // 在这里完成拦截操作 Object intercept(Invocation invocation) throws Throwable; // 用于封装目标对象，我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象 Object plugin(Object target); // 用于在Mybatis配置文件中指定一些属性的。 void setProperties(Properties properties);&#125; Signature注解用于定义拦截方法，规则为：type这个类下方法名为method且参数为args的方法 1234567891011121314/** * 就是定义哪些类，方法，参数需要被拦截 * @author Clinton Begin */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Signature &#123; Class&lt;?&gt; type(); String method(); Class&lt;?&gt;[] args();&#125; 当定义拦截器类之后就是要让Mybatis知道有哪些拦截器了，那Mybatis是怎么知道有哪些拦截器呢，通过以上章节可以知道Spring集成Mybatis有两种方法，一种是通过xml配置的方式，另一种是通过注解的方式，下面来介绍这两种方式是怎样获取定义好的拦截器的 通过xml配置的方式 先是在 mybatis-config.xml 定义好哪些拦截器 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 定义好之后那么Mybatis就会解析pluginElement 然后将会添加到Configuration 对象的InterceptorChain对象中，这样拦截器就解析完成了 123456789101112private void pluginElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; String interceptor = child.getStringAttribute(\"interceptor\"); Properties properties = child.getChildrenAsProperties(); Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance(); interceptorInstance.setProperties(properties); //调用InterceptorChain.addInterceptor configuration.addInterceptor(interceptorInstance); &#125; &#125;&#125; 看看InterceptorChain类，内部就是一个拦截器的List，可以定义多个拦截器 123456789101112131415161718192021222324252627 /** * 拦截器链 * @author Clinton Begin */public class InterceptorChain &#123; // 内部就是一个拦截器的List，可以定义多个拦截器 private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;(); public Object pluginAll(Object target) &#123; // 循环调用每个Interceptor.plugin方法 for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target); &#125; return target; &#125; public void addInterceptor(Interceptor interceptor) &#123; interceptors.add(interceptor); &#125; public List&lt;Interceptor&gt; getInterceptors() &#123; return Collections.unmodifiableList(interceptors); &#125;&#125; 通过注解的方式 通过注解的方式获取拦截器需要准备环境，查看第十九章 在拦截器那个类添加@Component 让拦截器类注册成Spring bean，这样此拦截器将会自动装配到Mybatis中 123456789101112131415@Component@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125; 那么是怎么实现拦截器的自动装配到Mybatis中，可以查看org.mybatis.spring.boot.autoconfigure 包下的MybatisAutoConfiguration 类，查看其构造方法，关注this.interceptors = interceptorsProvider.getIfAvailable(); 方法，这里实现了查找实现了Interceptor接口的的类，这个方法是Spring的方法，所以之前需要将拦截器类注册成Bean，这样Spring才能找到对应的拦截器 1234567891011public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider, ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider, ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123; this.properties = properties; this.interceptors = interceptorsProvider.getIfAvailable(); this.resourceLoader = resourceLoader; this.databaseIdProvider = databaseIdProvider.getIfAvailable(); this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();&#125; 现在来看SqlSessionFactory注册为Bean的过程，得到interceptors之后就需要将其添加到万能类Configuration中， 查看SqlSessionFactoryBean的buildSqlSessionFactory 方法，下面的代码就是此操作的实现 12345678if (!isEmpty(this.plugins)) &#123; for (Interceptor plugin : this.plugins) &#123; configuration.addInterceptor(plugin); if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"Registered plugin: '\" + plugin + \"'\"); &#125; &#125; &#125; 拦截器是如何拦截的 以下4个方法都是Configuration的方法。这些方法在MyBatis的新增，删除，修改，查询这些操作中都会被执行到，执行的先后顺序是Executor，ParameterHandler，ResultSetHandler，StatementHandler(其中ParameterHandler和ResultSetHandler的创建是在创建StatementHandler（3个可用的实现类CallableStatementHandler,PreparedStatementHandler,SimpleStatementHandler）的时候，其构造函数调用的（这3个实现类的构造函数其实都调用了父类BaseStatementHandler的构造函数）。 123456789101112131415161718192021222324252627282930313233343536public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql); parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler); return parameterHandler;&#125;public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) &#123; ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds); resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler); return resultSetHandler;&#125;public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123; StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql); statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); return statementHandler;&#125;public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) &#123; executorType = executorType == null ? defaultExecutorType : executorType; executorType = executorType == null ? ExecutorType.SIMPLE : executorType; Executor executor; if (ExecutorType.BATCH == executorType) &#123; executor = new BatchExecutor(this, transaction); &#125; else if (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction); &#125; if (cacheEnabled) &#123; executor = new CachingExecutor(executor, autoCommit); &#125; executor = (Executor) interceptorChain.pluginAll(executor); return executor;&#125; 这4个方法实例化了对应的对象之后，都会调用interceptorChain的pluginAll方法，InterceptorChain的pluginAll刚才已经介绍过了，就是遍历所有的拦截器，然后调用各个拦截器的plugin方法。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象 1234567public Object pluginAll(Object target) &#123; // 循环调用每个Interceptor.plugin方法 for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target); &#125; return target; &#125; 回到之前的拦截器类，这里查看plugin方法Plugin.wrap(target, this);，这里执行了Plugin类的wrap(target, this) 方法，返回了一个新的对象。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象 1234567891011121314@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125; 进入Plugin类，可以看到这里用了动态代理模式来实现拦截器的拦截操作Plugin.wrap(target, this);返回的是一个动态代理对象，当其动态代理对象执行方法的时候就会执行本Plugin类的invoke方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 插件,用的代理模式 * @author Clinton Begin */public class Plugin implements InvocationHandler &#123; private Object target; private Interceptor interceptor; private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap; private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123; this.target = target; this.interceptor = interceptor; this.signatureMap = signatureMap; &#125; public static Object wrap(Object target, Interceptor interceptor) &#123; // 取得签名Map Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor); // 取得要改变行为的类(ParameterHandler|ResultSetHandler|StatementHandler|Executor) Class&lt;?&gt; type = target.getClass(); // 取得接口 Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap); // 产生代理 if (interfaces.length &gt; 0) &#123; return Proxy.newProxyInstance( type.getClassLoader(), interfaces, new Plugin(target, interceptor, signatureMap)); &#125; return target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; // 看看如何拦截 Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); // 看哪些方法需要拦截 if (methods != null &amp;&amp; methods.contains(method)) &#123; // 调用Interceptor.intercept，也即插入了我们自己的逻辑 return interceptor.intercept(new Invocation(target, method, args)); &#125; // 最后还是执行原来逻辑 return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125; &#125; // 取得签名Map private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123; // 取Intercepts注解，例子可参见ExamplePlugin.java Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class); // issue #251 // 必须得有Intercepts注解，没有报错 if (interceptsAnnotation == null) &#123; throw new PluginException(\"No @Intercepts annotation was found in interceptor \" + interceptor.getClass().getName()); &#125; // value是数组型，Signature的数组 Signature[] sigs = interceptsAnnotation.value(); // 每个class里有多个Method需要被拦截,所以这么定义 Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(); for (Signature sig : sigs) &#123; Set&lt;Method&gt; methods = signatureMap.get(sig.type()); if (methods == null) &#123; methods = new HashSet&lt;Method&gt;(); signatureMap.put(sig.type(), methods); &#125; try &#123; Method method = sig.type().getMethod(sig.method(), sig.args()); methods.add(method); &#125; catch (NoSuchMethodException e) &#123; throw new PluginException(\"Could not find method on \" + sig.type() + \" named \" + sig.method() + \". Cause: \" + e, e); &#125; &#125; return signatureMap; &#125; // 取得接口 private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123; Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;(); while (type != null) &#123; for (Class&lt;?&gt; c : type.getInterfaces()) &#123; //貌似只能拦截ParameterHandler|ResultSetHandler|StatementHandler|Executor //拦截其他的无效 //当然我们可以覆盖Plugin.wrap方法，达到拦截其他类的功能 if (signatureMap.containsKey(c)) &#123; interfaces.add(c); &#125; &#125; type = type.getSuperclass(); &#125; return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]); &#125;&#125; 查看invoke方法,从而调用了我们之前定义的interceptor.intercept();的方法，这里是实现拦截的核心，interceptor.intercept(new Invocation(target, method, args)); 这里插入了我们自己的逻辑 12345678910111213141516@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; // 看看如何拦截 Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); // 看哪些方法需要拦截 if (methods != null &amp;&amp; methods.contains(method)) &#123; // 调用Interceptor.intercept，也即插入了我们自己的逻辑 return interceptor.intercept(new Invocation(target, method, args)); &#125; // 最后还是执行原来逻辑 return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125;&#125; 回到之前的节点，在构建Executor的时候，executor = (Executor) interceptorChain.pluginAll(executor);这里返回的是 Plugin.wrap(target, this);一个动态代理对象 1234567891011121314151617public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) &#123; executorType = executorType == null ? defaultExecutorType : executorType; executorType = executorType == null ? ExecutorType.SIMPLE : executorType; Executor executor; if (ExecutorType.BATCH == executorType) &#123; executor = new BatchExecutor(this, transaction); &#125; else if (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction); &#125; if (cacheEnabled) &#123; executor = new CachingExecutor(executor, autoCommit); &#125; executor = (Executor) interceptorChain.pluginAll(executor); return executor;&#125; 所以当SqlSession执行Executor的方法时候，这里Executor是个动态代理之后的Executor，当执行Executor的方法的时候就会执行动态代理的invoke方法，在invoke方法执行我们额外的代码 在此拦截器的任务才真正完成 参考官网：http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins https://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二十)Spring Mybatis集成之事务管理","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十)Spring Mybatis集成之事务管理","date":"2018-12-18T15:56:00.000Z","updated":"2018-12-20T14:07:39.013Z","comments":true,"path":"2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十)Spring Mybatis集成之事务管理/","link":"","permalink":"http://www.songshuiyang.site/2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二十)Spring Mybatis集成之事务管理/","excerpt":"","text":"前言使用 MyBatis-Spring 的主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而 不是给 MyBatis 创建一个新的特定的事务管理器,MyBatis-Spring 利用了存在于 Spring 中的 DataSourceTransactionManager。 如何集成 Spring的事务管理 配置 DataSourceTransactionManager Bean 1234&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 要注意, 为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的 是同一个数据源,否则事务管理器就无法工作了。 一旦 Spring 的 DataSourceTransactionManager 配置好了,你可以在 Spring 中你可以使用@Transactional 注解来完成事物操作。在事务处理期间,一个单独的 SqlSession 对象（线程级别）将会被创建 和使用。当事务完成时,这个 SqlSession 会以合适的方式提交或回滚。相反如果没有开启事物那么SqlSession 对象就是方法级别的了，每次调用Mapper里的方法都会返回一个新的SqlSession 来处理，下面来看其内部是怎么实现的 事务实现解析 与Spring集成以后，Spring提供了一个全局唯一的SqlSessionTemplate 来完成DefailtSqlSession的功能 进入SqlSessionTemplate 可以看到里面有个SqlSession 属性，看属性名可以看出这里又用了动态代理，为什么又要代理呢？下面来看看 12// SqlSession代理private final SqlSession sqlSessionProxy; 观察其构造方法，这里形成SqlSession代理类，再来看动态代理类SqlSessionInterceptor做了什么 123456789101112131415public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\"); notNull(executorType, \"Property 'executorType' is required\"); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; // 形成SqlSession代理类 this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor()); &#125; 进入SqlSessionInterceptor类，这个SqlSession代理类的出现是为了让Spring 来管理SqlSession 的，从而实现事物管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession * Proxy needed to route MyBatis method calls to the proper SqlSession got * from Spring's Transaction Manager * It also unwraps exceptions thrown by &#123;@code Method#invoke(Object, Object...)&#125; to * pass a &#123;@code PersistenceException&#125; to the &#123;@code PersistenceExceptionTranslator&#125;. */private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 获取SqlSession(这个SqlSession才是真正使用的，它不是线程安全的) SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; // 调用真实SqlSession的方法 Object result = method.invoke(sqlSession, args); // 判断一下当前的sqlSession是否被Spring托管 if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() // 没有使用事务 sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125;&#125; 进入getSqlSession()方法，这里是获取SqlSession 的方法 1234567891011121314151617181920public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED); // 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); SqlSession session = sessionHolder(executorType, holder); if (session != null) &#123; return session; &#125; // 如果找不到，则根据执行类型构造一个新的sqlSession LOGGER.debug(() -&gt; \"Creating a new SqlSession\"); session = sessionFactory.openSession(executorType); registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session); return session;&#125; 关注TransactionSynchronizationManager 内部成员，这里使用TreadLocal记录事务的一些属性，用于应用扩展同步器的使用，在事务的开启，挂起，提交等各个点上回调应用的逻辑 1234567891011121314151617181920212223 // 应用代码随事务的声明周期绑定的对象private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal&lt;&gt;(\"Transactional resources\"); // synchronizations-使用的同步器，用于应用扩展private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations = new NamedThreadLocal&lt;&gt;(\"Transaction synchronizations\"); // 事务的名称private static final ThreadLocal&lt;String&gt; currentTransactionName = new NamedThreadLocal&lt;&gt;(\"Current transaction name\"); // 事务是否是只读private static final ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly = new NamedThreadLocal&lt;&gt;(\"Current transaction read-only status\"); // 事务的隔离界别private static final ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel = new NamedThreadLocal&lt;&gt;(\"Current transaction isolation level\"); // 事务是否开启private static final ThreadLocal&lt;Boolean&gt; actualTransactionActive = new NamedThreadLocal&lt;&gt;(\"Actual transaction active\"); 回到SqlSessionInterceptor 类invoke方法，这里有个if判断if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) { 来判断是否开启了Spring事务，如果该Session未被Spring托管则自动commit 12345678public static boolean isSqlSessionTransactional(SqlSession session, SqlSessionFactory sessionFactory) &#123; notNull(session, NO_SQL_SESSION_SPECIFIED); notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); return (holder != null) &amp;&amp; (holder.getSqlSession() == session);&#125; 关注invoke方法的finally块的 closeSqlSession()方法，如果是开启了事务则没有执行session.close(); 123456finally &#123; if (sqlSession != null) &#123; // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; 1234567891011121314public static void closeSqlSession(SqlSession session, SqlSessionFactory sessionFactory) &#123; notNull(session, NO_SQL_SESSION_SPECIFIED); notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); if ((holder != null) &amp;&amp; (holder.getSqlSession() == session)) &#123; LOGGER.debug(() -&gt; \"Releasing transactional SqlSession [\" + session + \"]\"); // 如果是开启了事务 SqlSession是没有被close的，所以方法体内使用的是一个SqlSession，当然一级缓存是生效的 holder.released(); &#125; else &#123; LOGGER.debug(() -&gt; \"Closing non transactional SqlSession [\" + session + \"]\"); session.close(); &#125;&#125; 总结 通过上述代码可以得出如果开启了事务，同一事务中同一个sqlSessionFactory创建的唯一sqlSession，一个事务中使用的是同一个sqlSession，为什么要用同一个sqlSession呢，是为了使用同一个connection (JDBC) 如果没有开启事务，调用一次mapper里的方法将会新建一个sqlSession来执行方法 参考http://www.mybatis.org/spring/zh/factorybean.html https://www.cnblogs.com/daxin/p/3544188.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析","date":"2018-12-18T13:56:00.000Z","updated":"2019-02-17T04:48:00.774Z","comments":true,"path":"2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析/","link":"","permalink":"http://www.songshuiyang.site/2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析/","excerpt":"","text":"前言Mybatis与Spring的集成实现有两种方式，一种是通过XML配置，另一种是通过注解的信息进行配置，上一章节介绍了通过XML的方式来集成，这一章节来介绍如何通过注解的形式来在Spring Boot环境中集成Mybatis 环境准备 基于MyBatis-Spring-Boot-Starter 快速在Spring Boot环境中集成Mybatis，使用注解解决一切问题 基于Spring Boot环境中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置类中添加注解 1@MapperScan(\"com.songsy.iframe.mapper\") 添加配置（选填） 1234567mybatis: type-aliases-package: com.songsy.iframe.model type-handlers-package: com.songsy.iframe.typehandler configuration: map-underscore-to-camel-case: true default-fetch-size: 100 default-statement-timeout: 30 以上完成之后就可以使用Mybatis了 原理解析 打开mybatis-spring-boot-starter 源码可以看到是个空壳子 image 打开里面的pom.xml文件，可以看到其依赖，里面已经帮我们导入了mybatis及mybatis-spring的包 123456789101112131415161718192021222324252627282930&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/parent&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;name&gt;mybatis-spring-boot-starter&lt;/name&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 关注mybatis-spring-boot-autoconfigure 包，这里完成了其自动配置的功能，可以看到里面就只有几个类 image MybatisProperties.java是属性配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)public class MybatisProperties &#123; public static final String MYBATIS_PREFIX = \"mybatis\"; /** * Location of MyBatis xml config file. */ private String configLocation; /** * Locations of MyBatis mapper files. */ private String[] mapperLocations; /** * Packages to search type aliases. (Package delimiters are \",; \\t\\n\") */ private String typeAliasesPackage; /** * Packages to search for type handlers. (Package delimiters are \",; \\t\\n\") */ private String typeHandlersPackage; /** * Indicates whether perform presence check of the MyBatis xml config file. */ private boolean checkConfigLocation = false; /** * Execution mode for &#123;@link org.mybatis.spring.SqlSessionTemplate&#125;. */ private ExecutorType executorType; /** * Externalized properties for MyBatis configuration. */ private Properties configurationProperties; /** * A Configuration object for customize default settings. If &#123;@link #configLocation&#125; * is specified, this property is not used. */ @NestedConfigurationProperty private Configuration configuration; ... MybatisAutoConfiguration 是完成自动配置的主要实现类，可以看到这里定义了SqlSessionFactory及SqlSessionTemplate Bean，这里完成了之前使用xml配置bean的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/** * &#123;@link EnableAutoConfiguration Auto-Configuration&#125; for Mybatis. Contributes a * &#123;@link SqlSessionFactory&#125; and a &#123;@link SqlSessionTemplate&#125;. * * If &#123;@link org.mybatis.spring.annotation.MapperScan&#125; is used, or a * configuration file is specified as a property, those will be considered, * otherwise this auto-configuration will attempt to register mappers based on * the interface definitions in or under the root auto-configuration package. * * @author Eddú Meléndez * @author Josh Long * @author Kazuki Shimizu * @author Eduardo Macarrón */@org.springframework.context.annotation.Configuration@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)@ConditionalOnBean(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration &#123; private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class); private final MybatisProperties properties; private final Interceptor[] interceptors; private final ResourceLoader resourceLoader; private final DatabaseIdProvider databaseIdProvider; private final List&lt;ConfigurationCustomizer&gt; configurationCustomizers; public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider, ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider, ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123; this.properties = properties; this.interceptors = interceptorsProvider.getIfAvailable(); this.resourceLoader = resourceLoader; this.databaseIdProvider = databaseIdProvider.getIfAvailable(); this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable(); &#125; @PostConstruct public void checkConfigFileExists() &#123; if (this.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(this.properties.getConfigLocation())) &#123; Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation()); Assert.state(resource.exists(), \"Cannot find config location: \" + resource + \" (please add config file or check your Mybatis configuration)\"); &#125; &#125; @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) &#123; factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); &#125; Configuration configuration = this.properties.getConfiguration(); if (configuration == null &amp;&amp; !StringUtils.hasText(this.properties.getConfigLocation())) &#123; configuration = new Configuration(); &#125; if (configuration != null &amp;&amp; !CollectionUtils.isEmpty(this.configurationCustomizers)) &#123; for (ConfigurationCustomizer customizer : this.configurationCustomizers) &#123; customizer.customize(configuration); &#125; &#125; factory.setConfiguration(configuration); if (this.properties.getConfigurationProperties() != null) &#123; factory.setConfigurationProperties(this.properties.getConfigurationProperties()); &#125; if (!ObjectUtils.isEmpty(this.interceptors)) &#123; factory.setPlugins(this.interceptors); &#125; if (this.databaseIdProvider != null) &#123; factory.setDatabaseIdProvider(this.databaseIdProvider); &#125; if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123; factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); &#125; if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123; factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); &#125; if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123; factory.setMapperLocations(this.properties.resolveMapperLocations()); &#125; return factory.getObject(); &#125; @Bean @ConditionalOnMissingBean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; ExecutorType executorType = this.properties.getExecutorType(); if (executorType != null) &#123; return new SqlSessionTemplate(sqlSessionFactory, executorType); &#125; else &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; &#125; /** * This will just scan the same base package as Spring Boot does. If you want * more power, you can explicitly use * &#123;@link org.mybatis.spring.annotation.MapperScan&#125; but this will get typed * mappers working correctly, out-of-the-box, similar to using Spring Data JPA * repositories. */ public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123; private BeanFactory beanFactory; private ResourceLoader resourceLoader; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; logger.debug(\"Searching for mappers annotated with @Mapper\"); ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); try &#123; if (this.resourceLoader != null) &#123; scanner.setResourceLoader(this.resourceLoader); &#125; List&lt;String&gt; packages = AutoConfigurationPackages.get(this.beanFactory); if (logger.isDebugEnabled()) &#123; for (String pkg : packages) &#123; logger.debug(\"Using auto-configuration base package '&#123;&#125;'\", pkg); &#125; &#125; scanner.setAnnotationClass(Mapper.class); scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(packages)); &#125; catch (IllegalStateException ex) &#123; logger.debug(\"Could not determine auto-configuration package, automatic mapper scanning disabled.\", ex); &#125; &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; this.beanFactory = beanFactory; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; &#125; /** * &#123;@link org.mybatis.spring.annotation.MapperScan&#125; ultimately ends up * creating instances of &#123;@link MapperFactoryBean&#125;. If * &#123;@link org.mybatis.spring.annotation.MapperScan&#125; is used then this * auto-configuration is not needed. If it is _not_ used, however, then this * will bring in a bean registrar and automatically register components based * on the same component-scanning path as Spring Boot itself. */ @org.springframework.context.annotation.Configuration @Import(&#123; AutoConfiguredMapperScannerRegistrar.class &#125;) @ConditionalOnMissingBean(MapperFactoryBean.class) public static class MapperScannerRegistrarNotFoundConfiguration &#123; @PostConstruct public void afterPropertiesSet() &#123; logger.debug(\"No &#123;&#125; found.\", MapperFactoryBean.class.getName()); &#125; &#125;&#125; 通过注解配置来集成Spring、Mybatis 的方式可以看到是通过这个注解@MapperScan来实现的，查看注解可以看到通过@Import(MapperScannerRegistrar.class)把实例加入springIOC容器中 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(MapperScannerRegistrar.class) // 通过导入的方式实现把实例加入springIOC容器中@Repeatable(MapperScans.class)// 被此注解修饰的注解是可以重复的。注解的参数是可重复注解的存储容器注解类型。@Repeatable括号内的就相当于用来保存该注解内容的容器。public @interface MapperScan &#123; 查看MapperScannerRegistrar类，可以看到实现了 ImportBeanDefinitionRegistrar接口，重写了registerBeanDefinitions方法， 由于实现了该接口让该类成为了拥有注册bean的能力 image 进入registerBeanDefinitions方法 123456789@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 拿到注解信息，内部实现是 LinkedHashMap AnnotationAttributes mapperScanAttrs = AnnotationAttributes .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); if (mapperScanAttrs != null) &#123; registerBeanDefinitions(mapperScanAttrs, registry); &#125;&#125; 进入第二个registerBeanDefinitions方法，可以看到又出现了ClassPathMapperScanner这个类，果不其然，还是调用了scanner.doScan(StringUtils.toStringArray(basePackages)); 这个方法完成了Mapper的注册 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) &#123; // 获得spring的注册器registry ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); // this check is needed in Spring 3.1 if (resourceLoader != null) &#123; scanner.setResourceLoader(resourceLoader); &#125; Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(\"annotationClass\"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; Class&lt;?&gt; markerInterface = annoAttrs.getClass(\"markerInterface\"); if (!Class.class.equals(markerInterface)) &#123; scanner.setMarkerInterface(markerInterface); &#125; Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(\"nameGenerator\"); if (!BeanNameGenerator.class.equals(generatorClass)) &#123; scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass)); &#125; Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(\"factoryBean\"); if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123; scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass)); &#125; scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(\"sqlSessionTemplateRef\")); scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(\"sqlSessionFactoryRef\")); List&lt;String&gt; basePackages = new ArrayList&lt;&gt;(); // 如果配置了包路径则将入进去 basePackages.addAll( Arrays.stream(annoAttrs.getStringArray(\"value\")) .filter(StringUtils::hasText) .collect(Collectors.toList())); // 与上面功能一致 basePackages.addAll( Arrays.stream(annoAttrs.getStringArray(\"basePackages\")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getClassArray(\"basePackageClasses\")) .map(ClassUtils::getPackageName) .collect(Collectors.toList())); scanner.registerFilters(); // 开始扫描包 scanner.doScan(StringUtils.toStringArray(basePackages));&#125; 总结 使用注解的方式集成Mybatis比xml配置的方式更为简洁，在Spring Boot项目中就是以这种方式来配置的 mybatis-spring-boot-autoconfigure 帮助我们完成了以下功能1234自动检测现有的DataSource。将创建并注册的一个实例的SqlSessionFactory传递一个数据源作为使用输入SqlSessionFactoryBean的。将创建并注册SqlSessionTemplate的实例从SqlSessionFactory中获取。自动扫描映射器，将它们链接到SqlSessionTemplate并将它们注册到Spring上下文，以便将它们注入到bean中。 参考http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析","date":"2018-12-18T12:56:00.000Z","updated":"2019-06-08T12:11:44.295Z","comments":true,"path":"2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析/","link":"","permalink":"http://www.songshuiyang.site/2018/12/18/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析/","excerpt":"","text":"前言在实际项目开发中，Mybatis一般都是与Spring集成配合使用的，Mybatis与Spring集成需要另一个项目https://github.com/mybatis/spring，该项目提供了Mybatis与Spring的集成实现，Mybatis与Spring的集成实现有两种方式，一种是通过XML配置，另一种是通过注解的信息进行配置，这一章节来介绍如何通过XML的方式来在Spring中集成Mybatis及实现原理 开始集成 在Spring环境中集成MyBatis 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;31-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 添加xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 数据库连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver.encryption&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url.encryption&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;user.encryption&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password.encryption&#125;\"/&gt; &lt;property name=\"initialSize\" value=\"1\"/&gt; &lt;property name=\"minIdle\" value=\"1\"/&gt; &lt;property name=\"maxActive\" value=\"20\"/&gt; &lt;property name=\"maxWait\" value=\"60000\"/&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt; &lt;property name=\"validationQuery\" value=\"SELECT 1 FROM DUAL\"/&gt; &lt;property name=\"testWhileIdle\" value=\"true\"/&gt; &lt;property name=\"testOnBorrow\" value=\"false\"/&gt; &lt;property name=\"testOnReturn\" value=\"false\"/&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\"/&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\"/&gt; &lt;property name=\"filters\" value=\"stat,wall,log4j\"/&gt; &lt;property name=\"connectionProperties\"&gt; &lt;value&gt;clientEncoding=UTF-8&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.songsy.admin.entity\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt;&lt;/bean&gt;&lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;property name=\"basePackage\" value=\"com.songsy.admin.dao\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 实现解析dataSource 配置数据源 在Spring框架中有如下3种获得DataSource对象的方法: 从JNDI获得DataSource 从第三方的连接池获得DataSource 使用DriverManagerDataSource获得DataSource 用户可以根据需要选择不同的数据源配置 使用 SqlSessionFactoryBean 来创建SqlSession工厂 在基本的 MyBatis 中,session 工厂可以使用 SqlSessionFactoryBuilder 来创建。而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代。 SqlSessionFactoryBean.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean.class); private Resource configLocation; private Configuration configuration; private Resource[] mapperLocations; private DataSource dataSource; private TransactionFactory transactionFactory; private Properties configurationProperties; private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); private SqlSessionFactory sqlSessionFactory; //EnvironmentAware requires spring 3.1 private String environment = SqlSessionFactoryBean.class.getSimpleName(); private boolean failFast; private Interceptor[] plugins; private TypeHandler&lt;?&gt;[] typeHandlers; private String typeHandlersPackage; private Class&lt;?&gt;[] typeAliases; private String typeAliasesPackage; private Class&lt;?&gt; typeAliasesSuperType; //issue #19. No default provider. private DatabaseIdProvider databaseIdProvider; private Class&lt;? extends VFS&gt; vfs; private Cache cache; private ObjectFactory objectFactory; private ObjectWrapperFactory objectWrapperFactory; @Override public void afterPropertiesSet() throws Exception &#123; notNull(dataSource, \"Property 'dataSource' is required\"); notNull(sqlSessionFactoryBuilder, \"Property 'sqlSessionFactoryBuilder' is required\"); state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null), \"Property 'configuration' and 'configLocation' can not specified with together\"); this.sqlSessionFactory = buildSqlSessionFactory(); &#125; ... 要注意 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口,这就说明了由 Spring 最终创建的 bean 不是 SqlSessionFactoryBean 本身, 。 而是工厂类的 getObject()返回的方法的结果。这种情况下,Spring 将会在应用启动时为你 创建 SqlSessionFactory 对象,然后将它以 SqlSessionFactory 为名来存储。在 Java 中, 相同的代码是: 12SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();SqlSessionFactory sessionFactory = factoryBean.getObject(); 关注afterPropertiesSet 方法，这个方法将在Spring将所有的属性被初始化后调用，只需要实现InitializingBean接口就行，里面的buildSqlSessionFactory(); 方法，此方法是构建SqlSessionFactory的主体方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128protected SqlSessionFactory buildSqlSessionFactory() throws IOException &#123; Configuration configuration; XMLConfigBuilder xmlConfigBuilder = null; if (this.configuration != null) &#123; configuration = this.configuration; if (configuration.getVariables() == null) &#123; configuration.setVariables(this.configurationProperties); &#125; else if (this.configurationProperties != null) &#123; configuration.getVariables().putAll(this.configurationProperties); &#125; &#125; else if (this.configLocation != null) &#123; // 解析Mybatis配置文件 xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties); configuration = xmlConfigBuilder.getConfiguration(); &#125; else &#123; LOGGER.debug(() -&gt; \"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration\"); configuration = new Configuration(); if (this.configurationProperties != null) &#123; configuration.setVariables(this.configurationProperties); &#125; &#125; if (this.objectFactory != null) &#123; configuration.setObjectFactory(this.objectFactory); &#125; if (this.objectWrapperFactory != null) &#123; configuration.setObjectWrapperFactory(this.objectWrapperFactory); &#125; if (this.vfs != null) &#123; configuration.setVfsImpl(this.vfs); &#125; // 基于包名注册别名 if (hasLength(this.typeAliasesPackage)) &#123; String[] typeAliasPackageArray = tokenizeToStringArray(this.typeAliasesPackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); for (String packageToScan : typeAliasPackageArray) &#123; configuration.getTypeAliasRegistry().registerAliases(packageToScan, typeAliasesSuperType == null ? Object.class : typeAliasesSuperType); LOGGER.debug(() -&gt; \"Scanned package: '\" + packageToScan + \"' for aliases\"); &#125; &#125; // 注册别名 if (!isEmpty(this.typeAliases)) &#123; for (Class&lt;?&gt; typeAlias : this.typeAliases) &#123; configuration.getTypeAliasRegistry().registerAlias(typeAlias); LOGGER.debug(() -&gt; \"Registered type alias: '\" + typeAlias + \"'\"); &#125; &#125; // 添加插件 if (!isEmpty(this.plugins)) &#123; for (Interceptor plugin : this.plugins) &#123; configuration.addInterceptor(plugin); LOGGER.debug(() -&gt; \"Registered plugin: '\" + plugin + \"'\"); &#125; &#125; // 基于包名注册类型处理器 if (hasLength(this.typeHandlersPackage)) &#123; String[] typeHandlersPackageArray = tokenizeToStringArray(this.typeHandlersPackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); for (String packageToScan : typeHandlersPackageArray) &#123; configuration.getTypeHandlerRegistry().register(packageToScan); LOGGER.debug(() -&gt; \"Scanned package: '\" + packageToScan + \"' for type handlers\"); &#125; &#125; // 添加类型处理器 if (!isEmpty(this.typeHandlers)) &#123; for (TypeHandler&lt;?&gt; typeHandler : this.typeHandlers) &#123; configuration.getTypeHandlerRegistry().register(typeHandler); LOGGER.debug(() -&gt; \"Registered type handler: '\" + typeHandler + \"'\"); &#125; &#125; if (this.databaseIdProvider != null) &#123;//fix #64 set databaseId before parse mapper xmls try &#123; configuration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource)); &#125; catch (SQLException e) &#123; throw new NestedIOException(\"Failed getting a databaseId\", e); &#125; &#125; if (this.cache != null) &#123; configuration.addCache(this.cache); &#125; if (xmlConfigBuilder != null) &#123; try &#123; xmlConfigBuilder.parse(); LOGGER.debug(() -&gt; \"Parsed configuration file: '\" + this.configLocation + \"'\"); &#125; catch (Exception ex) &#123; throw new NestedIOException(\"Failed to parse config resource: \" + this.configLocation, ex); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; if (this.transactionFactory == null) &#123; this.transactionFactory = new SpringManagedTransactionFactory(); &#125; configuration.setEnvironment(new Environment(this.environment, this.transactionFactory, this.dataSource)); // 解析Mapper if (!isEmpty(this.mapperLocations)) &#123; for (Resource mapperLocation : this.mapperLocations) &#123; if (mapperLocation == null) &#123; continue; &#125; try &#123; XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(), configuration, mapperLocation.toString(), configuration.getSqlFragments()); xmlMapperBuilder.parse(); &#125; catch (Exception e) &#123; throw new NestedIOException(\"Failed to parse mapping resource: '\" + mapperLocation + \"'\", e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; LOGGER.debug(() -&gt; \"Parsed mapper file: '\" + mapperLocation + \"'\"); &#125; &#125; else &#123; LOGGER.debug(() -&gt; \"Property 'mapperLocations' was not specified or no matching resources found\"); &#125; return this.sqlSessionFactoryBuilder.build(configuration);&#125; 如下配置可以看到设置了数据源dataSource，指定了Mybatis的配置文件mybatis-config.xml，配置了别名包路径typeAliasesPackage，及Mapper文件的路径 1234567&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.songsy.admin.entity\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt;&lt;/bean&gt; basePackage 属性是让你为映射器接口文件设置基本的包路径。 你可以使用分号或逗号 作为分隔符设置多于一个的包路径。每个映射器将会在指定的包路径中递归地被搜索到。 SqlSessionFactory 有一个单独的必须属性,就是 JDBC 的 DataSource。这可以是任意 的 DataSource,其配置应该和其它 Spring 数据库连接是一样的。 要注意这个配置文件不需要是一个完整的 MyBatis 配置。确切地说,任意环境,数据源 和 MyBatis 的事务管理器都会被忽略。SqlSessionFactoryBean 会创建它自己的,使用这些 值定制 MyBatis 的 Environment 时是需要的。 使用 MapperScannerConfigurer 来扫描Mapper 使用MapperScannerConfigurer来注册所有的映射器，它将会查找类路径下的映射器并自动将它们创建成MapperFactoryBean，把SqlSession或者SqlSessionFactory注入进去 image MapperScannerConfigurer实现了 BeanDefinitionRegistryPostProcessor接口，如果实现了该接口，那么说明在Spring Application初始化的时候将会调用下面的方法 1234567891011121314151617181920@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; // 处理PropertyResourceConfigurers 加载属性配置问题 processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.registerFilters(); scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));&#125; 从上面代码可以看到是通过ClassPathMapperScanner 这个类来实现解析的，重点关注scanner.scan() 方法，进入该方法，因为ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner 所以这里调用的是ClassPathBeanDefinitionScanner这个类的scan()方法，可以看到第二行doScan(basePackages); 这个方法是ClassPathMapperScanner 的本地方法，该方法重载了ClassPathBeanDefinitionScanner的doScan方法 123456789101112public int scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); doScan(basePackages); // Register annotation config processors, if necessary. if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);&#125; 进入doScan(basePackages); 返回到ClassPathMapperScanner 这个类，这里是实现MapperScan的核心方法，可以看到通过Spring 的ClassPathBeanDefinitionScanner 类来生成BeanDefinitionHolder，这里是一个接口一个BeanDefinitionHolder 12345678910111213@Overridepublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; // 通过Spring 的ClassPathBeanDefinitionScanner 类来生成BeanDefinitionHolder Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; \"No MyBatis mapper was found in '\" + Arrays.toString(basePackages) + \"' package. Please check your configuration.\"); &#125; else &#123; // 在这里完成对Spring Bean的属性配置 processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions;&#125; 进入processBeanDefinitions(beanDefinitions); 方法，关注definition.setBeanClass(this.mapperFactoryBean.getClass());这一行，可以看到这里设置了Mapper类的Bean，实际的源头Bean是MapperFactoryBean 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; \"Creating MapperFactoryBean with name '\" + holder.getBeanName() + \"' and '\" + beanClassName + \"' mapperInterface\"); // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59 // 设置了Mapper类的Bean，实际的源头Bean是MapperFactoryBean，Mapper是由该bean生成 definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add(\"addToConfig\", this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; definition.getPropertyValues().add(\"sqlSessionFactory\", new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add(\"sqlSessionFactory\", this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\"); &#125; definition.getPropertyValues().add(\"sqlSessionTemplate\", new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\"); &#125; definition.getPropertyValues().add(\"sqlSessionTemplate\", this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; \"Enabling autowire by type for MapperFactoryBean with name '\" + holder.getBeanName() + \"'.\"); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; &#125;&#125; MapperScannerConfigurer不需要指定SqlSessionFactory 或SqlSessionTemplate,MapperScannerConfigurer 将会创建 MapperFactoryBean之后自动装配，如果你使用了一个以上的 DataSource ,那么自动装配可能会失效 。这种情况下你可以使用 SqlSessionFactoryBeanName 或 SqlSessionTemplateBeanName 属性来设置正确的 Bean 名 称来使用 下面来看一下MapperFactoryBean，可以看到getObject()方法调用的是 SqlSessionDaoSupport类中 SqlSessionTemplate 类的getMapper(this.mapperInterface);方法，该Bean将会在这里返回了Mapper接口的动态代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123; private Class&lt;T&gt; mapperInterface; private boolean addToConfig = true; public MapperFactoryBean() &#123; //intentionally empty &#125; public MapperFactoryBean(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; /** * &#123;@inheritDoc&#125; */ @Override protected void checkDaoConfig() &#123; super.checkDaoConfig(); notNull(this.mapperInterface, \"Property 'mapperInterface' is required\"); Configuration configuration = getSqlSession().getConfiguration(); if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123; try &#123; configuration.addMapper(this.mapperInterface); &#125; catch (Exception e) &#123; logger.error(\"Error while adding the mapper '\" + this.mapperInterface + \"' to configuration.\", e); throw new IllegalArgumentException(e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; &#125; /** * &#123;@inheritDoc&#125; */ @Override public T getObject() throws Exception &#123; return getSqlSession().getMapper(this.mapperInterface); &#125; /** * &#123;@inheritDoc&#125; */ @Override public Class&lt;T&gt; getObjectType() &#123; return this.mapperInterface; &#125; /** * &#123;@inheritDoc&#125; */ @Override public boolean isSingleton() &#123; return true; &#125; //------------- mutators -------------- /** * Sets the mapper interface of the MyBatis mapper * * @param mapperInterface class of the interface */ public void setMapperInterface(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; /** * Return the mapper interface of the MyBatis mapper * * @return class of the interface */ public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; /** * If addToConfig is false the mapper will not be added to MyBatis. This means * it must have been included in mybatis-config.xml. * &lt;p&gt; * If it is true, the mapper will be added to MyBatis in the case it is not already * registered. * &lt;p&gt; * By default addToConfig is true. * * @param addToConfig a flag that whether add mapper to MyBatis or not */ public void setAddToConfig(boolean addToConfig) &#123; this.addToConfig = addToConfig; &#125; /** * Return the flag for addition into MyBatis config. * * @return true if the mapper will be added to MyBatis in the case it is not already * registered. */ public boolean isAddToConfig() &#123; return addToConfig; &#125;&#125; MapperFactoryBean 创建的代理类实现了 UserMapper 接口,并且注入到应用程序中。 因为代理创建在运行时环境中(Runtime,译者注),那么指定的映射器必须是一个接口,而不是一个具体的实现类 SqlSessionTemplate 是MyBatis-Spring的核心。这个类负责管理MyBatis的SqlSession,调用MyBatis的SQL方法。SqlSessionTemplate是线程安全的，可以被多个DAO所共享使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class SqlSessionTemplate implements SqlSession, DisposableBean &#123; private final SqlSessionFactory sqlSessionFactory; private final ExecutorType executorType; // SqlSession代理 private final SqlSession sqlSessionProxy; private final PersistenceExceptionTranslator exceptionTranslator; /** * Constructs a Spring managed SqlSession with the &#123;@code SqlSessionFactory&#125; * provided as an argument. * * @param sqlSessionFactory a factory of SqlSession */ public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; this(sqlSessionFactory, sqlSessionFactory.getConfiguration().getDefaultExecutorType()); &#125; /** * Constructs a Spring managed SqlSession with the &#123;@code SqlSessionFactory&#125; * provided as an argument and the given &#123;@code ExecutorType&#125; * &#123;@code ExecutorType&#125; cannot be changed once the &#123;@code SqlSessionTemplate&#125; * is constructed. * * @param sqlSessionFactory a factory of SqlSession * @param executorType an executor type on session */ public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType) &#123; this(sqlSessionFactory, executorType, new MyBatisExceptionTranslator( sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), true)); &#125; /** * Constructs a Spring managed &#123;@code SqlSession&#125; with the given * &#123;@code SqlSessionFactory&#125; and &#123;@code ExecutorType&#125;. * A custom &#123;@code SQLExceptionTranslator&#125; can be provided as an * argument so any &#123;@code PersistenceException&#125; thrown by MyBatis * can be custom translated to a &#123;@code RuntimeException&#125; * The &#123;@code SQLExceptionTranslator&#125; can also be null and thus no * exception translation will be done and MyBatis exceptions will be * thrown * * @param sqlSessionFactory a factory of SqlSession * @param executorType an executor type on session * @param exceptionTranslator a translator of exception */ public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\"); notNull(executorType, \"Property 'executorType' is required\"); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; // 形成SqlSession代理类 this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor()); &#125; /** * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession * Proxy needed to route MyBatis method calls to the proper SqlSession got * from Spring's Transaction Manager * It also unwraps exceptions thrown by &#123;@code Method#invoke(Object, Object...)&#125; to * pass a &#123;@code PersistenceException&#125; to the &#123;@code PersistenceExceptionTranslator&#125;. */ private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 每次新生成一个SqlSession，一次调用一个SqlSession SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; Object result = method.invoke(sqlSession, args); // 判断是否事务 if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() // 没有使用事务 sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; // 关闭SqlSession closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125; &#125; ... SqlSessionTemplate 自动装配实现 TODO 总结 SqlSessionFactory 为什么能被Spring Ioc容器管理的原因是因为FactoryBean这个接口，这是个支持泛型的接口，Spring 将会在应用启动时为你 创建SqlSessionFactory对象,然后将它以 SqlSessionFactory为名来存储。当把这个bean注入到Spring中去了以后，IOC容器中的其他类型就可以拿到SqlSession实例了，就可以进行相关的SQL执行任务了。 当SqlSessionFactory 被Spring管理之后，如果单纯的使用Mybatis的话，是使用session.getMapper(UserMapper.class)来获取mapper的，但是现在在Spring环境中一般都是通过如下形式来调用的 12@Autowireprivate UserMapper userMapper; 所以Spring Mybatis 通过MapperScannerConfigurer 来将各个UserMapper RoleMapper...注册成为Spring bean (MapperFactoryBean)，由MapperFactoryBean来生成Mapper的代理类对象 参考http://www.mybatis.org/spring/zh/factorybean.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十七)结果映射DefaultResultSetHandler","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十七)结果映射DefaultResultSetHandler","date":"2018-12-09T02:52:00.000Z","updated":"2018-12-09T03:08:38.880Z","comments":true,"path":"2018/12/09/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十七)结果映射DefaultResultSetHandler/","link":"","permalink":"http://www.songshuiyang.site/2018/12/09/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十七)结果映射DefaultResultSetHandler/","excerpt":"","text":"前言上一章节介绍了Mybatis的参数绑定处理，本章将介绍Mybatis的结果映射过程，有执行就应该有结果，那Mybaits是怎样处理Jdbc返回的结果，并将结果映射成我们需要的对象呢？ 结果映射解析原生Jdbc结果映射 还是老套路，在介绍Mybatis结果映射处理之前先来看一下原生Jdbc结果映射是怎样处理的，可以看到通过迭代resultSet并根据列名来获取的值1234567resultSet=statement.executeQuery(sql);while (resultSet.next())&#123; String loginName=resultSet.getString(\"loginName\"); String userName=resultSet.getString(\"userName\"); String password=resultSet.getString(\"password\"); int sex=resultSet.getInt(\"sex\");&#125; Mybatis结果映射解析下面还是通过一个示例来介绍 测试用例 123456789101112// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);User user = new User();user.setUsername(\"admin\");System.out.println(userMapper1.selectSelective(user)); xml 配置 1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 还是打入断点进入SimpleExecutor 的 doQuery 方法 12345678910111213141516@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 新建一个StatementHandler // 这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); // StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 上一章节已经完成了stmt = prepareStatement(handler, ms.getStatementLog());操作，这一章节来处理return handler.&lt;E&gt;query(stmt, resultHandler); 进入该方法之后转到 RoutingStatementHandler 之后又转入 PreparedStatementHandler 进入query 方法，如下如可以看到又出现了Jdbc代码ps.execute(); 123456@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; ps.execute(); return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; execute 完成之后就是处理结果集了resultSetHandler.&lt;E&gt; handleResultSets(ps)， 进入该方法之后进入到DefaultResultSetHandler 类的handleResultSets 方法，以下代码可以知道数据结果都是存放在multipleResults 里面 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 处理ResultSets 并返回结果集 * @param stmt * @return * @throws SQLException */@Overridepublic List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123; ErrorContext.instance().activity(\"handling results\").object(mappedStatement.getId()); // 存放所有数据 final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;(); int resultSetCount = 0; ResultSetWrapper rsw = getFirstResultSet(stmt); // 由MappedStatement 获取ResultMap List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps(); // 一般resultMaps里只有一个元素 int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) &#123; ResultMap resultMap = resultMaps.get(resultSetCount); // 处理结果集 handleResultSet(rsw, resultMap, multipleResults, null); rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; &#125; String[] resultSets = mappedStatement.getResulSets(); if (resultSets != null) &#123; while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) &#123; ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]); if (parentMapping != null) &#123; String nestedResultMapId = parentMapping.getNestedResultMapId(); ResultMap resultMap = configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, null, parentMapping); &#125; rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; &#125; &#125; return collapseSingleResultList(multipleResults);&#125; 继续跳入handleResultSet(rsw, resultMap, multipleResults, null); ，可以看到这行代码multipleResults.add(defaultResultHandler.getResultList()); 将结果赋值到了multipleResults，下面的方法对resultHandler 进行了判断，我们现在是没有指定ResultHandler所以这里该值为null，将跳入默认的ResultHandler 处理类 12345678910111213141516171819202122232425// 处理结果集private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123; try &#123; if (parentMapping != null) &#123; handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping); &#125; else &#123; if (resultHandler == null) &#123; // 如果没有resultHandler // 新建DefaultResultHandler DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory); // 调用自己的handleRowValues handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null); // 得到记录的list multipleResults.add(defaultResultHandler.getResultList()); &#125; else &#123; //如果有resultHandler handleRowValues(rsw, resultMap, resultHandler, rowBounds, null); &#125; &#125; &#125; finally &#123; //最后别忘了关闭结果集，这个居然出bug了 // issue #228 (close resultsets) closeResultSet(rsw.getResultSet()); &#125;&#125; 跳入handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);，这里有个是否有嵌套的结果集判读，当然如果是有的话肯定要特殊处理的 12345678910private void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; // 是否有嵌套的结果集 if (resultMap.hasNestedResultMaps()) &#123; ensureNoRowBounds(); checkResultHandler(); handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping); &#125; else &#123; handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping); &#125;&#125; 我们现在这没有嵌套，所以else进入handleRowValuesForSimpleResultMap 方法，可以看到这里是一行一行的处理结果，ResultSetWrapper 是对ResultSet的包装 123456789101112131415161718192021/** * 见方法名知 ResultMap根据处理行数据 * @param rsw * @param resultMap * @param resultHandler 结果存放在这，里面是一个List&lt;Object&gt; * @param rowBounds * @param parentMapping * @throws SQLException */private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; DefaultResultContext resultContext = new DefaultResultContext(); skipRows(rsw.getResultSet(), rowBounds); // 一行一行赋值 rsw.getResultSet().next() Jdbc while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) &#123; ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null); // 获取一行数据 Object rowValue = getRowValue(rsw, discriminatedResultMap); storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet()); &#125;&#125; 重点关注Object rowValue = getRowValue(rsw, discriminatedResultMap); 这里的处理，这里是处理一行的数据 12345678910111213141516171819202122// 核心，取得一行的值private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap) throws SQLException &#123; // 实例化ResultLoaderMap(延迟加载器) final ResultLoaderMap lazyLoader = new ResultLoaderMap(); // 调用自己的createResultObject,内部就是new一个对象(如果是简单类型，new完也把值赋进去) Object resultObject = createResultObject(rsw, resultMap, lazyLoader, null); if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123; // 一般不是简单类型不会有typehandler,这个if会进来 final MetaObject metaObject = configuration.newMetaObject(resultObject); boolean foundValues = !resultMap.getConstructorResultMappings().isEmpty(); if (shouldApplyAutomaticMappings(resultMap, false)) &#123; // 自动映射咯 // 这里把每个列的值都赋到相应的字段里去了 foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, null) || foundValues; &#125; foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, null) || foundValues; foundValues = lazyLoader.size() &gt; 0 || foundValues; resultObject = foundValues ? resultObject : null; return resultObject; &#125; return resultObject;&#125; 跳入applyAutomaticMappings 方法，可以看到这里是结果映射的核心代码，巧妙的用TypeHandler取得结果，根据columnName从ResultSet取值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 自动映射 * @param rsw 对 ResultSet 的包装 * @param resultMap ResultMap * @param metaObject 返回的对象 * @param columnPrefix * @return * @throws SQLException */private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException &#123; // 得到表列名list final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix); boolean foundValues = false; // 一列一列数据循环赋值 for (String columnName : unmappedColumnNames) &#123; String propertyName = columnName; if (columnPrefix != null &amp;&amp; !columnPrefix.isEmpty()) &#123; // When columnPrefix is specified, // ignore columns without the prefix. if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) &#123; propertyName = columnName.substring(columnPrefix.length()); &#125; else &#123; continue; &#125; &#125; final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase()); if (property != null &amp;&amp; metaObject.hasSetter(property)) &#123; final Class&lt;?&gt; propertyType = metaObject.getSetterType(property); if (typeHandlerRegistry.hasTypeHandler(propertyType)) &#123; // 根据实体类字段类型获取对应的TypeHandler final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName); // 巧妙的用TypeHandler取得结果，根据columnName从ResultSet取值 final Object value = typeHandler.getResult(rsw.getResultSet(), columnName); // issue #377, call setter on nulls if (value != null || configuration.isCallSettersOnNulls()) &#123; if (value != null || !propertyType.isPrimitive()) &#123; // 然后巧妙的用反射来设置到对象 metaObject.setValue(property, value); &#125; foundValues = true; &#125; &#125; &#125; &#125; return foundValues;&#125; 又出现了TypeHandler，下面的方法出现了Jdbc代码return rs.getString(columnName); 12345678public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; 在此Mybatis结果映射处理完成 总结 Mybatis的参数绑定和结果映射最终处理都是通过不同的TypeHandler来处理的，Mybatis也支持自定义TypeHandler 但一般情况Mybatis提供的就可以应付常见需求了","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十六)参数绑定DefaultParameterHandler","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十六)参数绑定DefaultParameterHandler","date":"2018-12-09T01:17:00.000Z","updated":"2018-12-09T02:11:19.314Z","comments":true,"path":"2018/12/09/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十六)参数绑定DefaultParameterHandler/","link":"","permalink":"http://www.songshuiyang.site/2018/12/09/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十六)参数绑定DefaultParameterHandler/","excerpt":"","text":"前言Mybatis 一个重要功能是参数的自动绑定，Mybatis是怎样帮我们做好Jdbc的参数绑定的呢，这一章节来介绍Mybatis的参数绑定 参数绑定解析原生Jdbc参数绑定 在介绍Mybatis参数绑定之前先来看一下原生Jdbc参数绑定是怎样处理的，从下面的Jdbc代码可以看到，是通过下标顺序来设置参数值的，一个问号一个参数 12345String sql = \"insert into user(sno,name,age)values(?,?,?)\";//定义一个要执行的SQL语句PreparedStatement ps = connection.prepareStatement(sql);ps.setString(1,student.getSno());//设置SQL语句的第一个参数ps.setString(2,student.getName());//设置SQL语句的第二个参数ps.setInt(3,student.getAge());//设置SQL语句的第三个参数 Mybatis参数绑定解析下面通过一个示例来介绍 测试用例，下面的代码是通过User对象来查找对应的数据，user设置了两个属性值id 和 admin 12345678910111213// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);User user = new User();user.setId(1);user.setUsername(\"admin\");System.out.println(userMapper1.selectSelective(user)); xml 配置 1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 从第十五章可以知道，由传入的参数对象配合SqlSource 完成了动态Sql的处理， 下面是得到的结果 SELECT * FROM sys_user WHERE id = ? AND username = ?，这里得到了Jdbc的代码，现在要Mybatis要处理的就是这两个问号? image 还是打入断点进入SimpleExecutor 的 doQuery 方法，在这里可以看到这里新建了一个 StatementHandler 这个是SQL语句的执行器，在由来调度sql的参数绑定，sql执行，sql结果映射，现在重点关注stmt = prepareStatement(handler, ms.getStatementLog()); 这一行，看方法名称就大概知道这里是sql之前预备处理 12345678910111213141516@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 新建一个StatementHandler // 这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); // StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 进入stmt = prepareStatement(handler, ms.getStatementLog()); 方法，这里主要是对Connection 和 sql参数 进行了设置，继续跳入handler.parameterize(stmt); 123456789private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123; Statement stmt; Connection connection = getConnection(statementLog); // 调用StatementHandler.prepare 设置Connection stmt = handler.prepare(connection); // 调用StatementHandler.parameterize 设置参数 handler.parameterize(stmt); return stmt;&#125; 进入handler.parameterize(stmt);方法之后，转到 RoutingStatementHandler 之后又转入 PreparedStatementHandler，一系列的转发之后进入DefaultParameterHandler 类的setParameters 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class DefaultParameterHandler implements ParameterHandler &#123; private final TypeHandlerRegistry typeHandlerRegistry; private final MappedStatement mappedStatement; // 参数对象 private final Object parameterObject; // BoundSql private BoundSql boundSql; // 万能Configuration private Configuration configuration; public DefaultParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; this.mappedStatement = mappedStatement; this.configuration = mappedStatement.getConfiguration(); this.typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry(); this.parameterObject = parameterObject; this.boundSql = boundSql; &#125; @Override public Object getParameterObject() &#123; return parameterObject; &#125; // 设置参数 @Override public void setParameters(PreparedStatement ps) throws SQLException &#123; ErrorContext.instance().activity(\"setting parameters\").object(mappedStatement.getParameterMap().getId()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings != null) &#123; // 循环设参数 for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; // 如果不是OUT，才设进去 Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params // 若有额外的参数, 设为额外的参数 value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; // 若参数为null，直接设null value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; // 若参数有相应的TypeHandler，直接设object value = parameterObject; &#125; else &#123; // 除此以外，MetaObject.getValue反射取得值设进去 MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); &#125; // 类型处理器 TypeHandler typeHandler = parameterMapping.getTypeHandler(); JdbcType jdbcType = parameterMapping.getJdbcType(); if (value == null &amp;&amp; jdbcType == null) &#123; // 不同类型的set方法不同，所以委派给子类的setParameter方法 jdbcType = configuration.getJdbcTypeForNull(); &#125; // 用在类型处理器进行赋值 typeHandler.setParameter(ps, i + 1, value, jdbcType); &#125; &#125; &#125; &#125;&#125; 进入setParameters 方法之后，可以看到通过我们之前的BoundSql 得到 ParamterMappings对象，如下图可以知道是两个属性，然后下面的操作就是依次赋值了，不过这里有个特殊的地方，也是Mybatis参数绑定高明之处，就是赋值的操作是通过TypeHandler 来赋值的 image 继续跳入typeHandler.setParameter(ps, i + 1, value, jdbcType); 来到 IntegerTypeHandler的 setNonNullParameter方法，有没有看到曙光ps.setInt(i, parameter); ,在这里做了Jdbc的参数绑定操作 1234567891011121314151617public class IntegerTypeHandler extends BaseTypeHandler&lt;Integer&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType) throws SQLException &#123; ps.setInt(i, parameter); &#125;``` * 同理第二个参数是字符类型，所以跳到`StringTypeHandler````javapublic class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; 在此完成Mybatis参数绑定 总结 Mybatis的参数绑定是通过循环 ParamterMappings对象来依次对对象赋值的，具体赋值工作是对应的TypeHandler 来处理的，当然不同类型有不同的处理类","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十五)动态Sql实现之BoundSql","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十五)动态Sql实现之BoundSql","date":"2018-12-08T05:52:00.000Z","updated":"2018-12-08T06:00:22.990Z","comments":true,"path":"2018/12/08/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十五)动态Sql实现之BoundSql/","link":"","permalink":"http://www.songshuiyang.site/2018/12/08/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十五)动态Sql实现之BoundSql/","excerpt":"","text":"前言上一章节介绍了SqlSource ，这一章节来介绍 BoundSql，BoundSql 由 SqlSource 生产，BoundSql 存放了动态sql处理后的private String sql;,动态内容处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数 BoundSql 介绍 下面是 BoundSql 的源码，里面又对其变量的介绍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 绑定的SQL,是从SqlSource而来，将动态内容都处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数 * * An actual SQL String got form an &#123;@link SqlSource&#125; after having processed any dynamic content. * The SQL may have SQL placeholders \"?\" and an list (ordered) of an parameter mappings * with the additional information for each parameter (at least the property name of the input object to read * the value from). * &lt;/br&gt; * Can also have additional parameters that are created by the dynamic language (for loops, bind...). * @author Clinton Begin */public class BoundSql &#123; // 处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数 private String sql; // 参数映射对象 private List&lt;ParameterMapping&gt; parameterMappings; // 外面传入的sql参数 private Object parameterObject; // 额外参数？ private Map&lt;String, Object&gt; additionalParameters; // 参数元数据 private MetaObject metaParameters; public BoundSql(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings, Object parameterObject) &#123; this.sql = sql; this.parameterMappings = parameterMappings; this.parameterObject = parameterObject; this.additionalParameters = new HashMap&lt;String, Object&gt;(); this.metaParameters = configuration.newMetaObject(additionalParameters); &#125; public String getSql() &#123; return sql; &#125; public List&lt;ParameterMapping&gt; getParameterMappings() &#123; return parameterMappings; &#125; public Object getParameterObject() &#123; return parameterObject; &#125; public boolean hasAdditionalParameter(String name) &#123; return metaParameters.hasGetter(name); &#125; public void setAdditionalParameter(String name, Object value) &#123; metaParameters.setValue(name, value); &#125; public Object getAdditionalParameter(String name) &#123; return metaParameters.getValue(name); &#125;&#125; BoundSql 构造 BoundSql 由 SqlSource 生产，SqlSource 有四个实现类，但最常用的是 DynamicSqlSource，下面是其源码，可以看到只有一个方法public BoundSql getBoundSql(Object parameterObject) 12345678910111213141516171819202122232425262728293031323334/** * 动态SQL源码 * @author Clinton Begin */public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 下面通过一个例子来解析 BoundSql 的构造 xml 配置文件1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试用例，user对象给id和username赋值了对象 12345678910111213// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);User user = new User();user.setId(1);user.setUsername(\"admin\");System.out.println(userMapper1.selectSelective(user)); 打好断点进入到 CachingExecutor 的query方法，第一行可以看到 BoundSql 是由MappedStatement 的方法得到的，getBoundSql 方法只传入了参数对象，在这里是User对象 1234567 @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; BoundSql boundSql = ms.getBoundSql(parameterObject);//query时传入一个cachekey参数 CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); &#125; 进入ms.getBoundSql(parameterObject); 方法，重点关注 BoundSql boundSql = sqlSource.getBoundSql(parameterObject);，没错在这里出现了我们的SqlSource对象 1234567891011121314151617181920 public BoundSql getBoundSql(Object parameterObject) &#123;//其实就是调用sqlSource.getBoundSql BoundSql boundSql = sqlSource.getBoundSql(parameterObject); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings == null || parameterMappings.isEmpty()) &#123; boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject); &#125; // check for nested result maps in parameter mappings (issue #30) for (ParameterMapping pm : boundSql.getParameterMappings()) &#123; String rmId = pm.getResultMapId(); if (rmId != null) &#123; ResultMap rm = configuration.getResultMap(rmId); if (rm != null) &#123; hasNestedResultMaps |= rm.hasNestedResultMaps(); &#125; &#125; &#125; return boundSql; &#125; 进入sqlSource.getBoundSql(parameterObject) 方法，这个方法是DynamicSqlSource 的唯一方法，当然SqlSource作用就是得到绑定后的BoundSql对象 12345678910111213141516171819202122232425262728293031323334/** * 动态SQL源码 * @author Clinton Begin */public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 先看rootSqlNode.apply(context); 这行代码，打开断点进入会发现这里依次调用list里每个元素的apply方法，这里是实现动态SQL的关键，如果有嵌套的话也会嵌套执行里面的apply方法 image 静态sqlNode 的apply方法就是直接 appendSql 123456789101112131415public class StaticTextSqlNode implements SqlNode &#123; private String text; public StaticTextSqlNode(String text) &#123; this.text = text; &#125; @Override public boolean apply(DynamicContext context) &#123; //将文本加入context context.appendSql(text); return true; &#125;&#125; if SQL节点的apply方法 会做一个判断，如果 test=&quot;id != null&quot; 这个表达式为true就会 contents.apply(context); 添加到DynamicContext中，DynamicContext 内部成员 StringBuilder sqlBuilder 来存放解析后的sql 1234567891011121314151617181920212223242526/** * if SQL节点 * */public class IfSqlNode implements SqlNode &#123; private ExpressionEvaluator evaluator; private String test; private SqlNode contents; public IfSqlNode(SqlNode contents, String test) &#123; this.test = test; this.contents = contents; this.evaluator = new ExpressionEvaluator(); &#125; @Override public boolean apply(DynamicContext context) &#123; // 如果满足条件，则apply，并返回true if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125; rootSqlNode.apply(context); 处理完成之后就会得到拼接后的sql如下图所示，可以看到这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数 image SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); 这个方法是解析完了就把那些参数都替换成?，也就是最基本的JDBC的SQL写法，这个方法在以后章节将介绍 最终的到的结果(BoundSql)如下图所示 image 总结 BoundSql 由 SqlSource 构造而成，最终得到的是JDBC的SQL，而实现动态Sql的关键是 各个SqlNode的 apply方法 通过源码可以看到Mybatis动态sql设计巧妙，分工明确","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十四)动态Sql实现之SqlSource","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十四)动态Sql实现之SqlSource","date":"2018-12-08T03:52:00.000Z","updated":"2018-12-08T04:36:31.695Z","comments":true,"path":"2018/12/08/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十四)动态Sql实现之SqlSource/","link":"","permalink":"http://www.songshuiyang.site/2018/12/08/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十四)动态Sql实现之SqlSource/","excerpt":"","text":"前言从本章开始将介绍Mybatis是怎样实现动态sql的，介绍动态sql实现之前先介绍几个重要对象SqlSource，SqlNode ，BoundSql ,本章开始介绍SqlSource对象， 前面第九章及第十章介绍了SqlSource的构造过程，在xml配置的select update节点的sql将会构造成 SqlSource，其 SqlSource 由一组SqlNode组成，现在来看一下SqlSource能做什么 SqlSource 分析 查看SqlSource 是个接口，但他只有一个方法就是BoundSql getBoundSql(Object parameterObject); ，方法参数是sql的参数，然后根据参数来构造成BoundSql，所以他的作用是根据参数对象生产BoundSql，那么BoundSql有什么用呢，下一章节将介绍其作用 12345public interface SqlSource &#123; BoundSql getBoundSql(Object parameterObject);&#125; 下图可以看到SqlSource 其实现类，主要有4种类型 image DynamicSqlSource:处理动态sql语句。 RawSqlSource：处理静态sql语句，其内部装饰StaticSqlSource。 StaticSqlSource：处理静态sql，无论是静态sql，还是动态sql，最终的处理结果，都是静态sql。 ProviderSqlSource:处理注解Annotation形式的sql。 VelocitySqlSource:只是Mybatis的一个测试类 举个栗子，下面是一个动态sql的xml 1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 那么解析成SqlSource将会是下面的样子，SqlSource 是存放在MappedStatement对象的，可以看到SqlSource是一堆嵌套的SqlNode组成 image 总结 有图有栗子来理解SqlSource 就很形象了，有了SqlSource就相当于生产商品有基本原材料了，当然原材料(SqlNode)种类有很多，Mybatis会根据用户的需求(**Mapper.xml) 来采购不同的原材料","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十三)基于Mapper的二级缓存","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十三)基于Mapper的二级缓存","date":"2018-12-07T13:49:00.000Z","updated":"2018-12-08T02:48:43.703Z","comments":true,"path":"2018/12/07/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十三)基于Mapper的二级缓存/","link":"","permalink":"http://www.songshuiyang.site/2018/12/07/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十三)基于Mapper的二级缓存/","excerpt":"","text":"前言mybatis的二级缓存主要是在Executor对象上来做文章，当mybatis发现你在mybatis.xml配置文件中设置了cacheEnabled=true时，mybatis在创建sqlsession时创建Executor对象，同时会对Executor加上装饰者【CacheExecutor】。CacheExecutor对于查询请求，会判断application级别的二级缓存是否有缓存结果，如果有查询结果则直接返回，如果没有再交给查询器Executor实现类，也就是【SimpleExecutor】来执行查询。再就是缓存结果，返回给用户。 二级缓存的使用 配置 mybatis-config.xml1234&lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 配置Mapper xml文件，加上&lt;cache/&gt;1&lt;cache/&gt; 测试代码 12345678910111213// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession1 = sqlSessionFactory.openSession();SqlSession sqlSession2 = sqlSessionFactory.openSession();UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);// 测试二级缓存System.out.println(userMapper1.selectByPrimaryKey(1));System.out.println(userMapper2.selectByPrimaryKey(1)); 打好断点进入，这里是二级缓存的处理，从下面可以看到缓存是存放在MappedStatement 对象中的，所以说二级缓存是基于Mapper的，这是与多个SqlSession能够共享缓存的关键 1234567891011121314151617181920public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; Cache cache = ms.getCache(); // 默认情况下是没有开启缓存的(二级缓存).要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: &lt;cache/&gt; // 简单的说，就是先查CacheKey，查不到再委托给实际的执行器去查 if (cache != null) &#123; flushCacheIfRequired(ms); if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123; ensureNoOutParams(ms, parameterObject, boundSql); @SuppressWarnings(\"unchecked\") List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key); if (list == null) &#123; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116 &#125; return list; &#125; &#125; return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125; 可以看到缓存放在tcm 变量上，打开 TransactionalCacheManager 类 123456789101112131415161718192021222324252627282930313233343536373839404142public class TransactionalCacheManager &#123; //管理了许多TransactionalCache private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;(); public void clear(Cache cache) &#123; getTransactionalCache(cache).clear(); &#125; //得到某个TransactionalCache的值 public Object getObject(Cache cache, CacheKey key) &#123; return getTransactionalCache(cache).getObject(key); &#125; public void putObject(Cache cache, CacheKey key, Object value) &#123; getTransactionalCache(cache).putObject(key, value); &#125; //提交时全部提交 public void commit() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.commit(); &#125; &#125; //回滚时全部回滚 public void rollback() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.rollback(); &#125; &#125; private TransactionalCache getTransactionalCache(Cache cache) &#123; TransactionalCache txCache = transactionalCaches.get(cache); if (txCache == null) &#123; txCache = new TransactionalCache(cache); transactionalCaches.put(cache, txCache); &#125; return txCache; &#125;&#125; 二级缓存过期策略 映射语句文件中的所有 select 语句将会被缓存。 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。 二级缓存配置所有的这些属性都可以通过缓存元素的属性来修改。比如:123456789101112131415&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt;``` * 这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。可用的收回策略有: 默认的是 LRU。```xmlLRU – 最近最少使用的:移除最长时间不被使用的对象。FIFO – 先进先出:按对象进入缓存的顺序来移除它们。SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。 size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。 readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。 二级缓存设计 image 总结 mybatis的二级缓存主要是在Executor对象上来做文章，当mybatis发现你在mybatis.xml配置文件中设置了cacheEnabled=true时，mybatis在创建sqlsession时创建Executor对象，同时会对Executor加上装饰者【CacheExecutor】。CacheExecutor对于查询请求，会判断application级别的二级缓存是否有缓存结果，如果有查询结果则直接返回，如果没有再交给查询器Executor实现类，也就是【SimpleExecutor】来执行查询。再就是缓存结果，返回给用户。 避免使用二级缓存，如果出现联合查询语句，如果其中一张表发生了变化，就会出现脏数据的问题，因为缓存节点是根据namespace 参考： http://www.mybatis.org/mybatis-3/zh","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十二)基于SqlSession的一级缓存","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十二)基于SqlSession的一级缓存","date":"2018-12-06T13:49:00.000Z","updated":"2018-12-06T15:00:28.368Z","comments":true,"path":"2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十二)基于SqlSession的一级缓存/","link":"","permalink":"http://www.songshuiyang.site/2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十二)基于SqlSession的一级缓存/","excerpt":"","text":"前言MyBatis提供了一级缓存、二级缓存 这两种缓存机制，能够很好地处理和维护缓存，以提高系统的性能。本章的内容是介绍MyBatis的一级缓存，深入源码，解析MyBatis一级缓存的实现原理，二级缓存将在下一章介绍 一级缓存的使用 下面来通过代码来实践一级缓存，看看第二次查询是否使用了缓存 1234567891011// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(\"第一次查询: \"+userMapper.selectByPrimaryKey(1));System.out.println(\"第二次查询: \"+userMapper.selectByPrimaryKey(1)); 上面的代码是用SqlSession获取了UserMapper，然后用UserMapper 进行了两次查询，打好断点进入MapperProxy 的invoke 方法 12345678910111213141516@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法 // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行 if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; // 这里优化了，去缓存中找MapperMethod final MapperMethod mapperMethod = cachedMapperMethod(method); //执行 return mapperMethod.execute(sqlSession, args);&#125; 进入mapperMethod.execute(sqlSession, args) 之后跳呀跳进入BaseExecutor 的 query 方法，这个看到会创建一个CacheKey 123456789 @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; // 得到绑定sql BoundSql boundSql = ms.getBoundSql(parameter); // 创建缓存Key CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); // 查询 return query(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125; 下面来看一下这个key是怎么生成的 12345678910111213141516171819202122232425262728293031323334353637383940//创建缓存Key@Overridepublic CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123; if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; CacheKey cacheKey = new CacheKey(); // MyBatis 对于其 Key 的生成采取规则为：[mappedStementId + offset + limit + SQL + queryParams + environment]生成一个哈希码 cacheKey.update(ms.getId()); cacheKey.update(Integer.valueOf(rowBounds.getOffset())); cacheKey.update(Integer.valueOf(rowBounds.getLimit())); cacheKey.update(boundSql.getSql()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic // 模仿DefaultParameterHandler的逻辑,不再重复，请参考DefaultParameterHandler for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; value = parameterObject; &#125; else &#123; MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); &#125; cacheKey.update(value); &#125; &#125; if (configuration.getEnvironment() != null) &#123; // issue #176 cacheKey.update(configuration.getEnvironment().getId()); &#125; return cacheKey;&#125; 得到CacheKey 之后 跳入return query(ms, parameter, rowBounds, resultHandler, key, boundSql); 在这里对一级缓存进行了处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445@SuppressWarnings(\"unchecked\")@Overridepublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId()); //如果已经关闭，报错 if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; //先清局部缓存，再查询.但仅查询堆栈为0，才清。为了处理递归调用 if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123; clearLocalCache(); &#125; List&lt;E&gt; list; try &#123; //加一,这样递归调用到上面的时候就不会再清局部缓存了 queryStack++; //先根据cachekey从localCache去查 list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) &#123; //若查到localCache缓存，处理localOutputParameterCache handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); &#125; else &#123; //从数据库查 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); &#125; &#125; finally &#123; //清空堆栈 queryStack--; &#125; if (queryStack == 0) &#123; //延迟加载队列中所有元素 for (DeferredLoad deferredLoad : deferredLoads) &#123; deferredLoad.load(); &#125; // issue #601 //清空延迟加载队列 deferredLoads.clear(); if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // issue #482 //如果是STATEMENT，清本地缓存 clearLocalCache(); &#125; &#125; return list;&#125; 重点是下面几行代码，可以看到先根据cachekey从localCache去查，如果有就返回缓存里的数据，没有就从数据库里查 123456789// 先根据cachekey从localCache去查list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;if (list != null) &#123; // 若查到localCache缓存，处理localOutputParameterCache handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);&#125; else &#123; // 从数据库查 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125; 下面来看localCache 的本体PerpetualCache, 从下面的代码就可以看见其内部实现就是Map&lt;Object, Object&gt; cache 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 永久缓存 * 一旦存入就一直保持 * @author Clinton Begin */public class PerpetualCache implements Cache &#123; // 每个永久缓存有一个ID来识别 private String id; // 内部就是一个HashMap,所有方法基本就是直接调用HashMap的方法 private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); public PerpetualCache(String id) &#123; this.id = id; &#125; @Override public String getId() &#123; return id; &#125; @Override public int getSize() &#123; return cache.size(); &#125; @Override public void putObject(Object key, Object value) &#123; cache.put(key, value); &#125; @Override public Object getObject(Object key) &#123; return cache.get(key); &#125; @Override public Object removeObject(Object key) &#123; return cache.remove(key); &#125; @Override public void clear() &#123; cache.clear(); &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return null; &#125; @Override public boolean equals(Object o) &#123; //只要id相等就认为两个cache相同 if (getId() == null) &#123; throw new CacheException(\"Cache instances require an ID.\"); &#125; if (this == o) &#123; return true; &#125; if (!(o instanceof Cache)) &#123; return false; &#125; Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); &#125; @Override public int hashCode() &#123; if (getId() == null) &#123; throw new CacheException(\"Cache instances require an ID.\"); &#125; return getId().hashCode(); &#125;&#125; 现在回到主线，因为第一次查询一级缓存是没有数据的，所以继续执行queryFromDatabase，从下面的方法可以看到在这里实现了缓存的加入操作localCache.putObject(key, list); 12345678910111213141516171819// 从数据库查private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; List&lt;E&gt; list; // 先向缓存中放入占位符 localCache.putObject(key, EXECUTION_PLACEHOLDER); try &#123; list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); &#125; finally &#123; // 最后删除占位符 localCache.removeObject(key); &#125; // 加入缓存 localCache.putObject(key, list); // 如果是存储过程，OUT参数也加入缓存 if (ms.getStatementType() == StatementType.CALLABLE) &#123; localOutputParameterCache.putObject(key, parameter); &#125; return list;&#125; 一级缓存的生命周期有多长 MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 iamge 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用； 123456789101112131415161718192021@Overridepublic void close(boolean forceRollback) &#123; try &#123; try &#123; rollback(forceRollback); &#125; finally &#123; if (transaction != null) &#123; transaction.close(); &#125; &#125; &#125; catch (SQLException e) &#123; // Ignore. There's nothing that can be done at this point. log.warn(\"Unexpected exception on closing transaction. Cause: \" + e); &#125; finally &#123; transaction = null; deferredLoads = null; localCache = null; localOutputParameterCache = null; closed = true; &#125;&#125; 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用； 1234567@Overridepublic void clearLocalCache() &#123; if (!closed) &#123; localCache.clear(); localOutputParameterCache.clear(); &#125;&#125; SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用； 1234567891011// SqlSession.update/insert/delete会调用此方法@Overridepublic int update(MappedStatement ms, Object parameter) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity(\"executing an update\").object(ms.getId()); if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; //先清局部缓存，再更新，如何更新交由子类，模板方法模式 clearLocalCache(); return doUpdate(ms, parameter);&#125; 缓存分析为什么要使用一级缓存使用缓存是为了提高查询效率，减少资源消费，如果我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同 所以为了解决这一问题，减少资源的浪费，MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了 如下图所示，MyBatis会在一次会话的表示—-一个SqlSession对象中创建一个本地缓存(local cache)，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。 image 一级缓存查询时序图 image CacheKey的定义 Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。 现在最核心的问题出现了：怎样来确定一次查询的特征值？ MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询 123451. 传入的statementId，对于MyBatis而言，你要使用它，必须需要一个statementId，它代表着你将执行什么样的Sql；2. MyBatis自身提供的分页功能是通过RowBounds来实现的，它通过rowBounds.offset和rowBounds.limit来过滤查询出来的结果集，这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页；3. 由于MyBatis底层还是依赖于JDBC实现的，那么，对于两次完全一模一样的查询，MyBatis要保证对于底层JDBC而言，也是完全一致的查询才行。而对于JDBC而言，两次查询，只要传入给JDBC的SQL语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。 下面是创建CacheKey的代码 12345678910111213141516171819202122232425262728293031323334353637383940//创建缓存Key@Overridepublic CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123; if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; CacheKey cacheKey = new CacheKey(); // MyBatis 对于其 Key 的生成采取规则为：[mappedStementId + offset + limit + SQL + queryParams + environment]生成一个哈希码 cacheKey.update(ms.getId()); cacheKey.update(Integer.valueOf(rowBounds.getOffset())); cacheKey.update(Integer.valueOf(rowBounds.getLimit())); cacheKey.update(boundSql.getSql()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic // 模仿DefaultParameterHandler的逻辑,不再重复，请参考DefaultParameterHandler for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; value = parameterObject; &#125; else &#123; MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); &#125; cacheKey.update(value); &#125; &#125; if (configuration.getEnvironment() != null) &#123; // issue #176 cacheKey.update(configuration.getEnvironment().getId()); &#125; return cacheKey;&#125; 总结 如果缓存中有数据就不用从数据库中获取，大大提高系统性能。 一级缓存的作用级别是Session级别的，因为一个Session中存放一个Executor。而一级缓存放在Executor。 参考：https://blog.csdn.net/chenyao1994/article/details/79233725","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十一)MapperXML映射文件OGNL表达式","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十一)MapperXML映射文件OGNL表达式","date":"2018-12-06T10:40:00.000Z","updated":"2018-12-06T12:43:45.110Z","comments":true,"path":"2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十一)MapperXML映射文件OGNL表达式/","link":"","permalink":"http://www.songshuiyang.site/2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十一)MapperXML映射文件OGNL表达式/","excerpt":"","text":"基本介绍OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。 Struts2框架使用OGNL作为默认的表达式语言 OGNL是一种比EL强大很多倍的语言，支持对象方法调用，支持静态方法和字段访问，支持赋值操作等等。xwork提供了OGNL表达式。其jar包为ognl-x.x.x.jar。 MyBatis常用OGNL表达式123456789101112131415•e1 or e2•e1 and e2•e1 == e2,e1 eq e2•e1 != e2,e1 neq e2•e1 lt e2：小于•e1 lte e2：小于等于，其他gt（大于）,gte（大于等于）•e1 in e2•e1 not in e2•e1 + e2,e1 * e2,e1/e2,e1 - e2,e1%e2•!e,not e：非，求反•e.method(args)调用对象方法•e.property对象属性值•e1[ e2 ]按索引取值，List,数组和Map•@class@method(args)调用类的静态方法•@class@field调用类的静态字段值 MyBatis中可以使用OGNL的地方有两处 动态SQL表达式中 ${param}参数中 上面这两处地方在MyBatis中处理的时候都是使用OGNL处理的。 下面通过举例来说明这两种情况的用法。 动态SQL表达式中 下面代码中test的值会使用OGNL计算结果。12345678&lt;select id=\"xxx\" ...&gt; select id,name,... from country &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; name like concat('%', #&#123;name&#125;, '%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 通用 like 查询及的value值会使用OGNL计算123456789&lt;select id=\"xxx\" ...&gt; select id,name,... from country &lt;bind name=\"nameLike\" value=\"'%' + name + '%'\"/&gt; &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; name like #&#123;nameLike&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 通用Mapper中支持一种UUID的主键1&lt;bind name=\"username_bind\" value='@java.util.UUID@randomUUID().toString().replace(\"-\", \"\")' /&gt; ${param}参数中1234567891011121314&lt;select id=\"xxx\" ...&gt; select id,name,... from country &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; name like '$&#123;'%' + name + '%'&#125;' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这里注意写的是$&#123;'%' + name + '%'&#125; ，而不是%$&#123;name&#125;% ，这两种方式的结果一样，但是处理过程不一样。 在MyBatis中处理$&#123;&#125;的时候，只是使用OGNL计算这个结果值，然后替换SQL中对应的$&#123;xxx&#125; ，OGNL处理的只是$&#123;这里的表达式&#125;。 这里表达式可以是OGNL支持的所有表达式，可以写的很复杂，可以调用静态方法返回值，也可以调用静态的属性值。 参考： https://www.jb51.net/article/116160.htm","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十)MapperXML映射文件构建SqlNode","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十)MapperXML映射文件构建SqlNode","date":"2018-12-06T02:40:00.000Z","updated":"2018-12-06T12:28:47.867Z","comments":true,"path":"2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十)MapperXML映射文件构建SqlNode/","link":"","permalink":"http://www.songshuiyang.site/2018/12/06/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(十)MapperXML映射文件构建SqlNode/","excerpt":"","text":"前言上一章节介绍了SqlSource的构造过程，SqlSource 由一堆SqlNode构成，本章来介绍SqlNode的构造，如下图可以看到SqlNode的主要成员 image 源码解析SqlNode 还是回到 parseScriptNode 方法，关注List&lt;SqlNode&gt; contents = parseDynamicTags(context); 这个方法会把 select|insert|update|delete 这些标签的sql解析成一堆SqlNode, 包括静态SqlNode 和动态SqlNode(可见上图) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public SqlSource parseScriptNode() &#123; // 获取SqlNode List List&lt;SqlNode&gt; contents = parseDynamicTags(context); MixedSqlNode rootSqlNode = new MixedSqlNode(contents); SqlSource sqlSource = null; if (isDynamic) &#123; sqlSource = new DynamicSqlSource(configuration, rootSqlNode); &#125; else &#123; sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); &#125; return sqlSource;&#125;List&lt;SqlNode&gt; parseDynamicTags(XNode node) &#123; // 一行一个SqlNode List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;(); NodeList children = node.getNode().getChildNodes(); for (int i = 0; i &lt; children.getLength(); i++) &#123; XNode child = node.newXNode(children.item(i)); // 如果节点类型CDATA或者是文本，构造一个TextSqlNode或StaticTextSqlNode if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123; String data = child.getStringBody(\"\"); TextSqlNode textSqlNode = new TextSqlNode(data); if (textSqlNode.isDynamic()) &#123; contents.add(textSqlNode); isDynamic = true; &#125; else &#123; contents.add(new StaticTextSqlNode(data)); &#125; &#125; else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; // 如果是xml标签 trim|where|set... String nodeName = child.getNode().getNodeName(); // 得到动态sql标签处理类 trim|where|set... NodeHandler handler = nodeHandlers(nodeName); if (handler == null) &#123; throw new BuilderException(\"Unknown element &lt;\" + nodeName + \"&gt; in SQL statement.\"); &#125; // 解析动态结点 handler.handleNode(child, contents); isDynamic = true; &#125; &#125; return contents;&#125;NodeHandler nodeHandlers(String nodeName) &#123; Map&lt;String, NodeHandler&gt; map = new HashMap&lt;String, NodeHandler&gt;(); map.put(\"trim\", new TrimHandler()); map.put(\"where\", new WhereHandler()); map.put(\"set\", new SetHandler()); map.put(\"foreach\", new ForEachHandler()); map.put(\"if\", new IfHandler()); map.put(\"choose\", new ChooseHandler()); map.put(\"when\", new IfHandler()); map.put(\"otherwise\", new OtherwiseHandler()); map.put(\"bind\", new BindHandler()); return map.get(nodeName);&#125; SqlNode 是 Mybatis 实现动态sql的核心，下面来看看一些常用节点的的处理，IfSqlNode 节点 12345678910111213141516171819202122232425/** * if SQL节点 * @author Clinton Begin */public class IfSqlNode implements SqlNode &#123; private ExpressionEvaluator evaluator; private String test; private SqlNode contents; public IfSqlNode(SqlNode contents, String test) &#123; this.test = test; this.contents = contents; this.evaluator = new ExpressionEvaluator(); &#125; @Override public boolean apply(DynamicContext context) &#123; // 如果满足条件，则apply，并返回true if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125; ForEachSqlNode 节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * foreach SQL节点 * @author Clinton Begin */public class ForEachSqlNode implements SqlNode &#123; public static final String ITEM_PREFIX = \"__frch_\"; private ExpressionEvaluator evaluator; private String collectionExpression; private SqlNode contents; private String open; private String close; private String separator; private String item; private String index; private Configuration configuration; public ForEachSqlNode(Configuration configuration, SqlNode contents, String collectionExpression, String index, String item, String open, String close, String separator) &#123; this.evaluator = new ExpressionEvaluator(); this.collectionExpression = collectionExpression; this.contents = contents; this.open = open; this.close = close; this.separator = separator; this.index = index; this.item = item; this.configuration = configuration; &#125; @Override public boolean apply(DynamicContext context) &#123; Map&lt;String, Object&gt; bindings = context.getBindings(); //解析collectionExpression-&gt;iterable,核心用的ognl final Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings); if (!iterable.iterator().hasNext()) &#123; return true; &#125; boolean first = true; //加上( applyOpen(context); int i = 0; for (Object o : iterable) &#123; DynamicContext oldContext = context; if (first) &#123; context = new PrefixedContext(context, \"\"); &#125; else if (separator != null) &#123; context = new PrefixedContext(context, separator); &#125; else &#123; context = new PrefixedContext(context, \"\"); &#125; int uniqueNumber = context.getUniqueNumber(); // Issue #709 if (o instanceof Map.Entry) &#123; @SuppressWarnings(\"unchecked\") Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o; applyIndex(context, mapEntry.getKey(), uniqueNumber); applyItem(context, mapEntry.getValue(), uniqueNumber); &#125; else &#123; //索引 applyIndex(context, i, uniqueNumber); //加上一个元素 applyItem(context, o, uniqueNumber); &#125; contents.apply(new FilteredDynamicContext(configuration, context, index, item, uniqueNumber)); if (first) &#123; first = !((PrefixedContext) context).isPrefixApplied(); &#125; context = oldContext; i++; &#125; //加上) applyClose(context); return true; &#125; ... MixedSqlNode 这个Node比较特殊，获得的SqlNode会以list放在 MixedSqlNode中 123456789101112131415161718192021/** * 混合SQL节点 * @author Clinton Begin */public class MixedSqlNode implements SqlNode &#123; // 组合模式，拥有一个SqlNode的List private List&lt;SqlNode&gt; contents; public MixedSqlNode(List&lt;SqlNode&gt; contents) &#123; this.contents = contents; &#125; @Override public boolean apply(DynamicContext context) &#123; // 依次调用list里每个元素的apply for (SqlNode sqlNode : contents) &#123; sqlNode.apply(context); &#125; return true; &#125;&#125; selectByPrimaryKey 解析成果，见下图 123456&lt;select id=\"selectByPrimaryKey\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.Integer\" &gt; select &lt;include refid=\"Base_Column_List\" /&gt; from sys_role where id = #&#123;id,jdbcType=INTEGER&#125;&lt;/select&gt; image updateByPrimaryKeySelective 解析成果，见下图123456789101112131415161718192021222324252627282930313233343536&lt;update id=\"updateByPrimaryKeySelective\" parameterType=\"org.apache.songsy.entity.Role\" &gt; update sys_role &lt;set &gt; &lt;if test=\"roleName != null\" &gt; role_name = #&#123;roleName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"roleCode != null\" &gt; role_code = #&#123;roleCode,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"roleDescribe != null\" &gt; role_describe = #&#123;roleDescribe,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"createdDate != null\" &gt; created_date = #&#123;createdDate,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test=\"createdBy != null\" &gt; created_by = #&#123;createdBy,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"lastModifiedDate != null\" &gt; last_modified_date = #&#123;lastModifiedDate,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test=\"lastModifiedBy != null\" &gt; last_modified_by = #&#123;lastModifiedBy,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"remarks != null\" &gt; remarks = #&#123;remarks,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"status != null\" &gt; status = #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=\"enable != null\" &gt; enable = #&#123;enable,jdbcType=BIT&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125;&lt;/update&gt; image 总结","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(九)MapperXML映射文件构建SqlSource","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(九)MapperXML映射文件构建SqlSource","date":"2018-12-01T02:40:00.000Z","updated":"2018-12-08T04:00:11.584Z","comments":true,"path":"2018/12/01/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(九)MapperXML映射文件构建SqlSource/","link":"","permalink":"http://www.songshuiyang.site/2018/12/01/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(九)MapperXML映射文件构建SqlSource/","excerpt":"","text":"前言上一章节介绍了select|insert|update|delete 这些sql标签会解析成MappedStatement对象，MappedStatement 对象的重点属性是SqlSource，本章来介绍SqlSource的构造过程，其最终执行的sql字符串就是由SqlSource提供的。 源码解析SqlSource 类下图可以看到其实现类，主要有4种类型 image DynamicSqlSource:处理动态sql语句。 RawSqlSource：处理静态sql语句，其内部装饰StaticSqlSource。 StaticSqlSource：处理静态sql，无论是静态sql，还是动态sql，最终的处理结果，都是静态sql。 ProviderSqlSource:处理注解Annotation形式的sql。 VelocitySqlSource:只是Mybatis的一个测试类 DynamicSqlSource和StaticSqlSource的最大区别在于：StaticSqlSource的String sql，可以直接获取使用，而DynamicSqlSource的String sql需要逐一根据条件解析并拼接出最终的sql，方能使用。 Mybatis解析sql的时机Mybatis对于用户在XXMapper.xml文件中配置的sql解析主要分为2个时机 静态sql：程序启动的时候解析 动态sql：用户进行查询等sql相关操作的时候解析 什么是静态sql，动态sql？ 如果select|insert|update|delete标签体内包含XML标签或者select|insert|update|delete标签体内的sql文本中包含${}参数占位符则为动态sql，否则为静态sql。 如下面的2个sql中，第一个为动态sql，第二个为静态sql 1234567891011&lt;select id=\"selectUser\" parameterType=\"com.fit.bean.User\" resultType=\"com.fit.bean.User\" useCache=\"true\"&gt; select id, name from tab_user where id = $&#123;id&#125; &lt;if test=\"name!=null and name!=''\"&gt; and name=#&#123;name&#125; &lt;/if&gt; and 1 = 1&lt;/select&gt; &lt;select id=\"selectUserById\" parameterType=\"int\" resultType=\"com.fit.bean.User\" useCache=\"true\"&gt; select id, name from tab_user where id = #&#123;id&#125;&lt;/select&gt; 进入 parseStatementNode 方法，关注SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);这一行，打好断点进入langDriver.createSqlSource(configuration, context, parameterTypeClass); 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public void parseStatementNode() &#123; String id = context.getStringAttribute(\"id\"); String databaseId = context.getStringAttribute(\"databaseId\"); //如果databaseId不匹配，退出 if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123; return; &#125; //暗示驱动程序每次批量返回的结果行数 Integer fetchSize = context.getIntAttribute(\"fetchSize\"); //超时时间 Integer timeout = context.getIntAttribute(\"timeout\"); //引用外部 parameterMap,已废弃 String parameterMap = context.getStringAttribute(\"parameterMap\"); //参数类型 String parameterType = context.getStringAttribute(\"parameterType\"); Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType); //引用外部的 resultMap(高级功能) String resultMap = context.getStringAttribute(\"resultMap\"); //结果类型 String resultType = context.getStringAttribute(\"resultType\"); //脚本语言,mybatis3.2的新功能 String lang = context.getStringAttribute(\"lang\"); //得到语言驱动 LanguageDriver langDriver = getLanguageDriver(lang); Class&lt;?&gt; resultTypeClass = resolveClass(resultType); //结果集类型，FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE 中的一种 String resultSetType = context.getStringAttribute(\"resultSetType\"); //语句类型, STATEMENT|PREPARED|CALLABLE 的一种 StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString())); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); //获取命令类型(select|insert|update|delete) String nodeName = context.getNode().getNodeName(); SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH)); boolean isSelect = sqlCommandType == SqlCommandType.SELECT; boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect); //是否要缓存select结果 boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect); //仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 //这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false); // Include Fragments before parsing //解析之前先解析&lt;include&gt;SQL片段 XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant); includeParser.applyIncludes(context.getNode()); // Parse selectKey after includes and remove them. //解析之前先解析&lt;selectKey&gt; processSelectKeyNodes(id, parameterTypeClass, langDriver); // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed) //解析成SqlSource，一般是DynamicSqlSource SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass); String resultSets = context.getStringAttribute(\"resultSets\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyProperty = context.getStringAttribute(\"keyProperty\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyColumn = context.getStringAttribute(\"keyColumn\"); KeyGenerator keyGenerator; String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); if (configuration.hasKeyGenerator(keyStatementId)) &#123; keyGenerator = configuration.getKeyGenerator(keyStatementId); &#125; else &#123; keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\", configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? new Jdbc3KeyGenerator() : new NoKeyGenerator(); &#125; //又去调助手类 builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets); &#125; 进入langDriver.createSqlSource方法后默认是进入 XMLLanguageDriver类 createSqlSource 方法，可以看到又调用了XMLScriptBuilder 类的builder.parseScriptNode() 方法 1234567891011121314151617181920212223242526272829303132333435public class XMLLanguageDriver implements LanguageDriver &#123; @Override public ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; //返回默认的参数处理器 return new DefaultParameterHandler(mappedStatement, parameterObject, boundSql); &#125; @Override public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) &#123; //用XML脚本构建器解析 XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType); return builder.parseScriptNode(); &#125; //注解方式构建mapper @Override public SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType) &#123; // issue #3 if (script.startsWith(\"&lt;script&gt;\")) &#123; XPathParser parser = new XPathParser(script, false, configuration.getVariables(), new XMLMapperEntityResolver()); return createSqlSource(configuration, parser.evalNode(\"/script\"), parameterType); &#125; else &#123; // issue #127 script = PropertyParser.parse(script, configuration.getVariables()); TextSqlNode textSqlNode = new TextSqlNode(script); //一种是动态，一种是原始 if (textSqlNode.isDynamic()) &#123; return new DynamicSqlSource(configuration, textSqlNode); &#125; else &#123; return new RawSqlSource(configuration, script, parameterType); &#125; &#125; &#125;&#125; 进入XMLScriptBuilder类 根据 isDynamic 变量来返回 DynamicSqlSource 对象和 RawSqlSource 对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224public class XMLScriptBuilder extends BaseBuilder &#123; private XNode context; private boolean isDynamic; private Class&lt;?&gt; parameterType; public XMLScriptBuilder(Configuration configuration, XNode context) &#123; this(configuration, context, null); &#125; public XMLScriptBuilder(Configuration configuration, XNode context, Class&lt;?&gt; parameterType) &#123; super(configuration); this.context = context; this.parameterType = parameterType; &#125; public SqlSource parseScriptNode() &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(context); MixedSqlNode rootSqlNode = new MixedSqlNode(contents); SqlSource sqlSource = null; if (isDynamic) &#123; sqlSource = new DynamicSqlSource(configuration, rootSqlNode); &#125; else &#123; sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); &#125; return sqlSource; &#125; List&lt;SqlNode&gt; parseDynamicTags(XNode node) &#123; // 一行一个SqlNode List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;(); NodeList children = node.getNode().getChildNodes(); for (int i = 0; i &lt; children.getLength(); i++) &#123; XNode child = node.newXNode(children.item(i)); // 如果节点类型CDATA或者是文本，构造一个TextSqlNode或StaticTextSqlNode if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123; String data = child.getStringBody(\"\"); TextSqlNode textSqlNode = new TextSqlNode(data); if (textSqlNode.isDynamic()) &#123; contents.add(textSqlNode); isDynamic = true; &#125; else &#123; contents.add(new StaticTextSqlNode(data)); &#125; &#125; else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; // 如果是xml标签 trim|where|set... String nodeName = child.getNode().getNodeName(); // 得到动态sql标签处理类 trim|where|set... NodeHandler handler = nodeHandlers(nodeName); if (handler == null) &#123; throw new BuilderException(\"Unknown element &lt;\" + nodeName + \"&gt; in SQL statement.\"); &#125; // 解析动态结点 handler.handleNode(child, contents); isDynamic = true; &#125; &#125; return contents; &#125; NodeHandler nodeHandlers(String nodeName) &#123; Map&lt;String, NodeHandler&gt; map = new HashMap&lt;String, NodeHandler&gt;(); map.put(\"trim\", new TrimHandler()); map.put(\"where\", new WhereHandler()); map.put(\"set\", new SetHandler()); map.put(\"foreach\", new ForEachHandler()); map.put(\"if\", new IfHandler()); map.put(\"choose\", new ChooseHandler()); map.put(\"when\", new IfHandler()); map.put(\"otherwise\", new OtherwiseHandler()); map.put(\"bind\", new BindHandler()); return map.get(nodeName); &#125; private interface NodeHandler &#123; void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents); &#125; private class BindHandler implements NodeHandler &#123; public BindHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; final String name = nodeToHandle.getStringAttribute(\"name\"); final String expression = nodeToHandle.getStringAttribute(\"value\"); final VarDeclSqlNode node = new VarDeclSqlNode(name, expression); targetContents.add(node); &#125; &#125; private class TrimHandler implements NodeHandler &#123; public TrimHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); String prefix = nodeToHandle.getStringAttribute(\"prefix\"); String prefixOverrides = nodeToHandle.getStringAttribute(\"prefixOverrides\"); String suffix = nodeToHandle.getStringAttribute(\"suffix\"); String suffixOverrides = nodeToHandle.getStringAttribute(\"suffixOverrides\"); TrimSqlNode trim = new TrimSqlNode(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides); targetContents.add(trim); &#125; &#125; private class WhereHandler implements NodeHandler &#123; public WhereHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); WhereSqlNode where = new WhereSqlNode(configuration, mixedSqlNode); targetContents.add(where); &#125; &#125; private class SetHandler implements NodeHandler &#123; public SetHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); SetSqlNode set = new SetSqlNode(configuration, mixedSqlNode); targetContents.add(set); &#125; &#125; private class ForEachHandler implements NodeHandler &#123; public ForEachHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); String collection = nodeToHandle.getStringAttribute(\"collection\"); String item = nodeToHandle.getStringAttribute(\"item\"); String index = nodeToHandle.getStringAttribute(\"index\"); String open = nodeToHandle.getStringAttribute(\"open\"); String close = nodeToHandle.getStringAttribute(\"close\"); String separator = nodeToHandle.getStringAttribute(\"separator\"); ForEachSqlNode forEachSqlNode = new ForEachSqlNode(configuration, mixedSqlNode, collection, index, item, open, close, separator); targetContents.add(forEachSqlNode); &#125; &#125; private class IfHandler implements NodeHandler &#123; public IfHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); String test = nodeToHandle.getStringAttribute(\"test\"); IfSqlNode ifSqlNode = new IfSqlNode(mixedSqlNode, test); targetContents.add(ifSqlNode); &#125; &#125; private class OtherwiseHandler implements NodeHandler &#123; public OtherwiseHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); targetContents.add(mixedSqlNode); &#125; &#125; private class ChooseHandler implements NodeHandler &#123; public ChooseHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; whenSqlNodes = new ArrayList&lt;SqlNode&gt;(); List&lt;SqlNode&gt; otherwiseSqlNodes = new ArrayList&lt;SqlNode&gt;(); handleWhenOtherwiseNodes(nodeToHandle, whenSqlNodes, otherwiseSqlNodes); SqlNode defaultSqlNode = getDefaultSqlNode(otherwiseSqlNodes); ChooseSqlNode chooseSqlNode = new ChooseSqlNode(whenSqlNodes, defaultSqlNode); targetContents.add(chooseSqlNode); &#125; private void handleWhenOtherwiseNodes(XNode chooseSqlNode, List&lt;SqlNode&gt; ifSqlNodes, List&lt;SqlNode&gt; defaultSqlNodes) &#123; List&lt;XNode&gt; children = chooseSqlNode.getChildren(); for (XNode child : children) &#123; String nodeName = child.getNode().getNodeName(); NodeHandler handler = nodeHandlers(nodeName); if (handler instanceof IfHandler) &#123; handler.handleNode(child, ifSqlNodes); &#125; else if (handler instanceof OtherwiseHandler) &#123; handler.handleNode(child, defaultSqlNodes); &#125; &#125; &#125; private SqlNode getDefaultSqlNode(List&lt;SqlNode&gt; defaultSqlNodes) &#123; SqlNode defaultSqlNode = null; if (defaultSqlNodes.size() == 1) &#123; defaultSqlNode = defaultSqlNodes.get(0); &#125; else if (defaultSqlNodes.size() &gt; 1) &#123; throw new BuilderException(\"Too many default (otherwise) elements in choose statement.\"); &#125; return defaultSqlNode; &#125; &#125;&#125; 重点是这个方法List&lt;SqlNode&gt; parseDynamicTags(XNode node) ，下面几行代码是处理动态sql的操作 12345678// 得到动态sql标签处理类 trim|where|set...NodeHandler handler = nodeHandlers(nodeName);if (handler == null) &#123; throw new BuilderException(\"Unknown element &lt;\" + nodeName + \"&gt; in SQL statement.\");&#125;// 解析动态结点handler.handleNode(child, contents);isDynamic = true; 通过 nodeHandlers (nodeName) 方法来获取相应的处理类 12345678910111213NodeHandler nodeHandlers(String nodeName) &#123; Map&lt;String, NodeHandler&gt; map = new HashMap&lt;String, NodeHandler&gt;(); map.put(\"trim\", new TrimHandler()); map.put(\"where\", new WhereHandler()); map.put(\"set\", new SetHandler()); map.put(\"foreach\", new ForEachHandler()); map.put(\"if\", new IfHandler()); map.put(\"choose\", new ChooseHandler()); map.put(\"when\", new IfHandler()); map.put(\"otherwise\", new OtherwiseHandler()); map.put(\"bind\", new BindHandler()); return map.get(nodeName);&#125; 各个Handler 处理类是 XMLScriptBuilder 的子类，实际上会转到各个SqlNode 处理类 总结 解析mapper文件中的每个&lt;select/&gt;,&lt;insert/&gt;,&lt;update/&gt;,&lt;delete/&gt;节点内的SQL字符串(其中可能包含动态SQL部分,诸如&lt;if/&gt;,&lt;where/&gt;等)是这个XMLScriptBuilder类","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(八)MapperXML映射文件构建MappedStatement","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(八)MapperXML映射文件构建MappedStatement","date":"2018-11-27T14:00:44.000Z","updated":"2018-12-01T13:55:55.263Z","comments":true,"path":"2018/11/27/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(八)MapperXML映射文件构建MappedStatement/","link":"","permalink":"http://www.songshuiyang.site/2018/11/27/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(八)MapperXML映射文件构建MappedStatement/","excerpt":"","text":"前言上一章节介绍了ResultMap标签的解析过程，这一章节来介绍select|insert|update|delete 这些sql标签的解析，这些节点会构造成MappedStatement类对象 源码解析 还是从 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 作为入口找到 configurationElement(XNode context) 方法，如下所示，按照步骤节点一步步解析，最后才是处理select|insert|update|delete节点 123456789101112131415161718192021222324private void configurationElement(XNode context) &#123; try &#123; //1.配置namespace String namespace = context.getStringAttribute(\"namespace\"); if (namespace.equals(\"\")) &#123; throw new BuilderException(\"Mapper's namespace cannot be empty\"); &#125; builderAssistant.setCurrentNamespace(namespace); //2.配置cache-ref cacheRefElement(context.evalNode(\"cache-ref\")); //3.配置cache cacheElement(context.evalNode(\"cache\")); //4.配置parameterMap(已经废弃,老式风格的参数映射) parameterMapElement(context.evalNodes(\"/mapper/parameterMap\")); //5.配置resultMap(高级功能) resultMapElements(context.evalNodes(\"/mapper/resultMap\")); //6.配置sql(定义可重用的 SQL 代码段) sqlElement(context.evalNodes(\"/mapper/sql\")); //7.配置select|insert|update|delete TODO buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e); &#125;&#125; 打好断点进入 buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); 方法，可以看到是一个或的匹配，匹配所有的select|insert|update|delete 这些标签 123456789101112131415161718192021222324//7.配置select|insert|update|deleteprivate void buildStatementFromContext(List&lt;XNode&gt; list) &#123; //调用7.1构建语句 if (configuration.getDatabaseId() != null) &#123; buildStatementFromContext(list, configuration.getDatabaseId()); &#125; buildStatementFromContext(list, null);&#125;// 7.1构建语句private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123; for (XNode context : list) &#123; // 构建所有语句,一个mapper下可以有很多select // 语句比较复杂，核心都在这里面，所以调用XMLStatementBuilder final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId); try &#123; // 核心XMLStatementBuilder.parseStatementNode statementParser.parseStatementNode(); &#125; catch (IncompleteElementException e) &#123; // 如果出现SQL语句不完整，把它记下来，塞到configuration去 configuration.addIncompleteStatement(statementParser); &#125; &#125;&#125; 可以看到又涉及到了一个XMLStatementBuilder.java 来对这些标签进行解析，进入statementParser.parseStatementNode(); 方法，可以看到xml标签的一些属性解析，最后是builderAssistant.addMappedStatement(...) 方法将构建好的MappedStatement对象添加到Configuration这个大佬身上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 //解析语句(select|insert|update|delete)//&lt;select// id=\"selectPerson\"// parameterType=\"int\"// parameterMap=\"deprecated\"// resultType=\"hashmap\"// resultMap=\"personResultMap\"// flushCache=\"false\"// useCache=\"true\"// timeout=\"10000\"// fetchSize=\"256\"// statementType=\"PREPARED\"// resultSetType=\"FORWARD_ONLY\"&gt;// SELECT * FROM PERSON WHERE ID = #&#123;id&#125;//&lt;/select&gt; public void parseStatementNode() &#123; String id = context.getStringAttribute(\"id\"); String databaseId = context.getStringAttribute(\"databaseId\"); //如果databaseId不匹配，退出 if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123; return; &#125; //暗示驱动程序每次批量返回的结果行数 Integer fetchSize = context.getIntAttribute(\"fetchSize\"); //超时时间 Integer timeout = context.getIntAttribute(\"timeout\"); //引用外部 parameterMap,已废弃 String parameterMap = context.getStringAttribute(\"parameterMap\"); //参数类型 String parameterType = context.getStringAttribute(\"parameterType\"); Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType); //引用外部的 resultMap(高级功能) String resultMap = context.getStringAttribute(\"resultMap\"); //结果类型 String resultType = context.getStringAttribute(\"resultType\"); //脚本语言,mybatis3.2的新功能 String lang = context.getStringAttribute(\"lang\"); //得到语言驱动 LanguageDriver langDriver = getLanguageDriver(lang); Class&lt;?&gt; resultTypeClass = resolveClass(resultType); //结果集类型，FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE 中的一种 String resultSetType = context.getStringAttribute(\"resultSetType\"); //语句类型, STATEMENT|PREPARED|CALLABLE 的一种 StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString())); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); //获取命令类型(select|insert|update|delete) String nodeName = context.getNode().getNodeName(); SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH)); boolean isSelect = sqlCommandType == SqlCommandType.SELECT; boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect); //是否要缓存select结果 boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect); //仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 //这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false); // Include Fragments before parsing //解析之前先解析&lt;include&gt;SQL片段 XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant); includeParser.applyIncludes(context.getNode()); // Parse selectKey after includes and remove them. //解析之前先解析&lt;selectKey&gt; processSelectKeyNodes(id, parameterTypeClass, langDriver); // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed) //解析成SqlSource，一般是DynamicSqlSource SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass); String resultSets = context.getStringAttribute(\"resultSets\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyProperty = context.getStringAttribute(\"keyProperty\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyColumn = context.getStringAttribute(\"keyColumn\"); KeyGenerator keyGenerator; String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); if (configuration.hasKeyGenerator(keyStatementId)) &#123; keyGenerator = configuration.getKeyGenerator(keyStatementId); &#125; else &#123; keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\", configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? new Jdbc3KeyGenerator() : new NoKeyGenerator(); &#125; //又去调助手类 builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets); &#125; MappedStatement类在Mybatis框架中用于表示XML文件中一个sql语句节点，即一个或者标签。Mybatis框架在初始化阶段会对XML配置文件进行读取，将其中的sql语句节点对象化为一个个MappedStatement对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public final class MappedStatement &#123; // xml文件位置 private String resource; private Configuration configuration; // 节点中的id属性加要命名空间比如 org.apache.songsy.mapper.RoleMapper.selectByPrimaryKey private String id; private Integer fetchSize; private Integer timeout; private StatementType statementType; private ResultSetType resultSetType; // SQL源码，实现动态sql private SqlSource sqlSource; private Cache cache; private ParameterMap parameterMap; private List&lt;ResultMap&gt; resultMaps; private boolean flushCacheRequired; private boolean useCache; private boolean resultOrdered; private SqlCommandType sqlCommandType; private KeyGenerator keyGenerator; private String[] keyProperties; private String[] keyColumns; private boolean hasNestedResultMaps; private String databaseId; private Log statementLog; private LanguageDriver lang; private String[] resultSets; MappedStatement() &#123; // constructor disabled &#125; //静态内部类，建造者模式 public static class Builder &#123; private MappedStatement mappedStatement = new MappedStatement(); public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) &#123; mappedStatement.configuration = configuration; mappedStatement.id = id; mappedStatement.sqlSource = sqlSource; mappedStatement.statementType = StatementType.PREPARED; mappedStatement.parameterMap = new ParameterMap.Builder(configuration, \"defaultParameterMap\", null, new ArrayList&lt;ParameterMapping&gt;()).build(); mappedStatement.resultMaps = new ArrayList&lt;ResultMap&gt;(); mappedStatement.timeout = configuration.getDefaultStatementTimeout(); mappedStatement.sqlCommandType = sqlCommandType; mappedStatement.keyGenerator = configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType) ? new Jdbc3KeyGenerator() : new NoKeyGenerator(); String logId = id; if (configuration.getLogPrefix() != null) &#123; logId = configuration.getLogPrefix() + id; &#125; mappedStatement.statementLog = LogFactory.getLog(logId); mappedStatement.lang = configuration.getDefaultScriptingLanuageInstance(); &#125; ... MappedStatement.java 在哪里会调用呢，可以回顾一些第六章节使用MapperProxy来执行方法，下面是方法 // 核心selectList @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) { try { // 根据statement id找到对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来查询结果,注意这里传入的ResultHandler是null return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); } catch (Exception e) { throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); } finally { ErrorContext.instance().reset(); } }","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(七)MapperXML映射文件解析ResultMap","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(七)MapperXML映射文件解析ResultMap","date":"2018-11-26T14:00:44.000Z","updated":"2018-11-27T14:01:48.097Z","comments":true,"path":"2018/11/26/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(七)MapperXML映射文件解析ResultMap/","link":"","permalink":"http://www.songshuiyang.site/2018/11/26/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(七)MapperXML映射文件解析ResultMap/","excerpt":"","text":"前言MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单，第三章节已经介绍了Mapper XML 文件解析的整体过程，这一章节来介绍Mapper 映射文件下 select|insert|update|delete 这些节点的解析 源码解析 从 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 作为入口找到 configurationElement(XNode context) 方法，如下所示，按照步骤节点一步步解析，最后才是处理select|insert|update|delete节点 123456789101112131415161718192021222324private void configurationElement(XNode context) &#123; try &#123; //1.配置namespace String namespace = context.getStringAttribute(\"namespace\"); if (namespace.equals(\"\")) &#123; throw new BuilderException(\"Mapper's namespace cannot be empty\"); &#125; builderAssistant.setCurrentNamespace(namespace); //2.配置cache-ref cacheRefElement(context.evalNode(\"cache-ref\")); //3.配置cache cacheElement(context.evalNode(\"cache\")); //4.配置parameterMap(已经废弃,老式风格的参数映射) parameterMapElement(context.evalNodes(\"/mapper/parameterMap\")); //5.配置resultMap(高级功能) resultMapElements(context.evalNodes(\"/mapper/resultMap\")); //6.配置sql(定义可重用的 SQL 代码段) sqlElement(context.evalNodes(\"/mapper/sql\")); //7.配置select|insert|update|delete TODO buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e); &#125;&#125; 配置resultMap 解析，进入 resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); 方法 123456789private void resultMapElements(List&lt;XNode&gt; list) throws Exception &#123; for (XNode resultMapNode : list) &#123; try &#123; // 循环遍历resultMap节点 resultMapElement(resultMapNode); &#125; catch (IncompleteElementException e) &#123; // ignore, it will be retried &#125; &#125; 进入 resultMapElement(resultMapNode); 方法, 这里就是构造ResultMap的主要方法了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception &#123;//错误上下文//取得标示符 (\"resultMap[userResultMap]\")// &lt;resultMap id=\"userResultMap\" type=\"User\"&gt;// &lt;id property=\"id\" column=\"user_id\" /&gt;// &lt;result property=\"username\" column=\"username\"/&gt;// &lt;result property=\"password\" column=\"password\"/&gt;// &lt;/resultMap&gt; ErrorContext.instance().activity(\"processing \" + resultMapNode.getValueBasedIdentifier()); String id = resultMapNode.getStringAttribute(\"id\", resultMapNode.getValueBasedIdentifier()); String type = resultMapNode.getStringAttribute(\"type\", resultMapNode.getStringAttribute(\"ofType\", resultMapNode.getStringAttribute(\"resultType\", resultMapNode.getStringAttribute(\"javaType\")))); String extend = resultMapNode.getStringAttribute(\"extends\"); //autoMapping Boolean autoMapping = resultMapNode.getBooleanAttribute(\"autoMapping\"); Class&lt;?&gt; typeClass = resolveClass(type); Discriminator discriminator = null; List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;ResultMapping&gt;(); resultMappings.addAll(additionalResultMappings); // 遍历resultMap 的子节点 List&lt;XNode&gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) &#123; if (\"constructor\".equals(resultChild.getName())) &#123; //解析result map的constructor processConstructorElement(resultChild, typeClass, resultMappings); &#125; else if (\"discriminator\".equals(resultChild.getName())) &#123; //解析result map的discriminator discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); &#125; else &#123; List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;(); if (\"id\".equals(resultChild.getName())) &#123; flags.add(ResultFlag.ID); &#125; // 调5.1.1 buildResultMappingFromContext,得到ResultMapping resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); &#125; &#125; // 最后再调ResultMapResolver得到ResultMap ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try &#123; return resultMapResolver.resolve(); &#125; catch (IncompleteElementException e) &#123; configuration.addIncompleteResultMap(resultMapResolver); throw e; &#125; &#125; 下面来看看ResultMap 这个类，可以看到一层套一层 12345678910111213141516171819202122232425262728293031323334353637public class ResultMap &#123; private String id; private Class&lt;?&gt; type; private List&lt;ResultMapping&gt; resultMappings; private List&lt;ResultMapping&gt; idResultMappings; private List&lt;ResultMapping&gt; constructorResultMappings; private List&lt;ResultMapping&gt; propertyResultMappings; private Set&lt;String&gt; mappedColumns; private Discriminator discriminator; private boolean hasNestedResultMaps; private boolean hasNestedQueries; private Boolean autoMapping; private ResultMap() &#123; &#125; // 静态内部类，建造者模式 public static class Builder &#123; private ResultMap resultMap = new ResultMap(); public Builder(Configuration configuration, String id, Class&lt;?&gt; type, List&lt;ResultMapping&gt; resultMappings) &#123; this(configuration, id, type, resultMappings, null); &#125; public Builder(Configuration configuration, String id, Class&lt;?&gt; type, List&lt;ResultMapping&gt; resultMappings, Boolean autoMapping) &#123; resultMap.id = id; resultMap.type = type; resultMap.resultMappings = resultMappings; resultMap.autoMapping = autoMapping; &#125; public Builder discriminator(Discriminator discriminator) &#123; resultMap.discriminator = discriminator; return this; &#125; ... ResultMap 由多个 ResultMapping.java 构造成，下面看看这个类，和我们的mapper文件是一一对应的 12345&lt;resultMap id=\"BaseResultMap\" type=\"com.songsy.imybatis.test.entity.User\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"username\" property=\"username\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"password\" property=\"password\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"nickname\" property=\"nickname\" jdbcType=\"VARCHAR\"/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ResultMapping &#123; private Configuration configuration; private String property; private String column; private Class&lt;?&gt; javaType; private JdbcType jdbcType; private TypeHandler&lt;?&gt; typeHandler; private String nestedResultMapId; private String nestedQueryId; private Set&lt;String&gt; notNullColumns; private String columnPrefix; private List&lt;ResultFlag&gt; flags; private List&lt;ResultMapping&gt; composites; private String resultSet; private String foreignColumn; private boolean lazy; ResultMapping() &#123; &#125; // 静态内部类，建造者模式 public static class Builder &#123; private ResultMapping resultMapping = new ResultMapping(); public Builder(Configuration configuration, String property, String column, TypeHandler&lt;?&gt; typeHandler) &#123; this(configuration, property); resultMapping.column = column; resultMapping.typeHandler = typeHandler; &#125; public Builder(Configuration configuration, String property, String column, Class&lt;?&gt; javaType) &#123; this(configuration, property); resultMapping.column = column; resultMapping.javaType = javaType; &#125; public Builder(Configuration configuration, String property) &#123; resultMapping.configuration = configuration; resultMapping.property = property; resultMapping.flags = new ArrayList&lt;ResultFlag&gt;(); resultMapping.composites = new ArrayList&lt;ResultMapping&gt;(); resultMapping.lazy = configuration.isLazyLoadingEnabled(); &#125; public Builder javaType(Class&lt;?&gt; javaType) &#123; resultMapping.javaType = javaType; return this; &#125; public Builder jdbcType(JdbcType jdbcType) &#123; resultMapping.jdbcType = jdbcType; return this; &#125; public Builder nestedResultMapId(String nestedResultMapId) &#123; resultMapping.nestedResultMapId = nestedResultMapId; return this; &#125; .... 总结 Mybatis最强大的元素，它可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中。 当返回类型直接是一个ResultMap的时候也是非常有用的，这主要用在进行复杂联合查询上，因为进行简单查询是没有什么必要的，可以使用ResultType来处理","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(六)使用MapperProxy来执行方法","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(六)使用MapperProxy来执行方法","date":"2018-11-23T06:10:44.000Z","updated":"2018-12-09T03:05:34.090Z","comments":true,"path":"2018/11/23/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(六)使用MapperProxy来执行方法/","link":"","permalink":"http://www.songshuiyang.site/2018/11/23/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(六)使用MapperProxy来执行方法/","excerpt":"","text":"前言上一章节通过SqlSession来获取Mapper的代理类MapperProxy， 有了代理类之后就可以执行里面的方法了 MapperProxy 执行方法 MapperProxy 继承 InvocationHandler 实现了动态代理，只要是调用的Mapper接口的方法都会进入到 里面的invoke 方法中，具体解释如下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 映射器代理，代理模式 * @author Clinton Begin * @author Eduardo Macarron */public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; // 使用了缓存 private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法 // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行 if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; // 这里优化了，去缓存中找MapperMethod final MapperMethod mapperMethod = cachedMapperMethod(method); // 真正的方法执行 return mapperMethod.execute(sqlSession, args); &#125; // 去缓存中找MapperMethod private MapperMethod cachedMapperMethod(Method method) &#123; MapperMethod mapperMethod = methodCache.get(method); if (mapperMethod == null) &#123; // 找不到才去new mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()); methodCache.put(method, mapperMethod); &#125; return mapperMethod; &#125;&#125; 接下来关注这一行mapperMethod.execute(sqlSession, args); 这里是重头戏，我们打开 MapperMethod 这个类，重点关注execute 方法，可以看到在这里进行了一些路由转发(insert|update|delete|select，分别调用SqlSession的4大类方法，又回到了SqlSession中), 还有就是对查询参数的一些处理封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 映射器方法 * @author Clinton Begin * @author Eduardo Macarron * @author Lasse Voss */public class MapperMethod &#123; private final SqlCommand command; private final MethodSignature method; public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123; this.command = new SqlCommand(config, mapperInterface, method); this.method = new MethodSignature(config, method); &#125; //执行 public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; //可以看到执行时就是4种情况，insert|update|delete|select，分别调用SqlSession的4大类方法 if (SqlCommandType.INSERT == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); &#125; else if (SqlCommandType.DELETE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); &#125; else if (SqlCommandType.SELECT == command.getType()) &#123; if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; //如果有结果处理器 executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; //如果结果有多条记录 result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; //如果结果是map result = executeForMap(sqlSession, args); &#125; else &#123; //否则就是一条记录 Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); &#125; &#125; else &#123; throw new BindingException(\"Unknown execution method for: \" + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException(\"Mapper method '\" + command.getName() + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\"); &#125; return result; &#125; ... 放不下 现在来执行一条查询，根据断点一步步发掘 12UserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); 一大堆if判断进入到这里 12Object param = method.convertArgsToSqlCommandParam(args);result = sqlSession.selectOne(command.getName(), param); 进入 sqlSession.selectOne(command.getName(), param); 方法 12345678910111213@Overridepublic &lt;T&gt; T selectOne(String statement, Object parameter) &#123; // Popular vote was to return null on 0 results and throw exception on too many. // 转而去调用selectList,很简单的，如果得到0条则返回null，得到1条则返回1条，得到多条报TooManyResultsException错 List&lt;T&gt; list = this.&lt;T&gt;selectList(statement, parameter); if (list.size() == 1) &#123; return list.get(0); &#125; else if (list.size() &gt; 1) &#123; throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size()); &#125; else &#123; return null; &#125;&#125; selectOne 调用的是 selectList 方法，在这里可以看到 MappedStatement 及 Executor 1234567891011121314// 核心selectList@Overridepublic &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; // 根据statement id找到对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来查询结果,注意这里传入的ResultHandler是null return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 查看 MappedStatement 这里可以看到我们的sql image 继续跳入 executor.query 方法，这里面跳到 CachingExecutor 执行，这里面使用了装饰器模式，里面有个private Executor delegate;，装饰SimpleExecutor , 在SimpleExecutor基础的上添加了二级缓存的功能 123456789101112131415161718192021@Overridepublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; Cache cache = ms.getCache(); // 默认情况下是没有开启缓存的(二级缓存).要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: &lt;cache/&gt; // 简单的说，就是先查CacheKey，查不到再委托给实际的执行器去查 if (cache != null) &#123; flushCacheIfRequired(ms); if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123; ensureNoOutParams(ms, parameterObject, boundSql); @SuppressWarnings(\"unchecked\") List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key); if (list == null) &#123; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116 &#125; return list; &#125; &#125; return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125; 因为二级缓存是需要配置开启的，所以继续跳入 delegate.&lt;E&gt; query 方法，进入到BaseExecutor 方法，在这里可以看到一级缓存的处理 12345678910111213141516171819202122232425262728293031323334353637383940414243public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId()); // 如果已经关闭，报错 if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; // 先清局部缓存，再查询.但仅查询堆栈为0，才清。为了处理递归调用 if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123; clearLocalCache(); &#125; List&lt;E&gt; list; try &#123; // 加一,这样递归调用到上面的时候就不会再清局部缓存了 queryStack++; // 先根据cachekey从localCache去查 list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) &#123; // 若查到localCache缓存，处理localOutputParameterCache handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); &#125; else &#123; // 从数据库查 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); &#125; &#125; finally &#123; // 清空堆栈 queryStack--; &#125; if (queryStack == 0) &#123; // 延迟加载队列中所有元素 for (DeferredLoad deferredLoad : deferredLoads) &#123; deferredLoad.load(); &#125; // issue #601 // 清空延迟加载队列 deferredLoads.clear(); if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // issue #482 // 如果是STATEMENT，清本地缓存 clearLocalCache(); &#125; &#125; return list;&#125; 继续跳入queryFromDatabase() 方法，从数据库查， 跳入到SimpleExecutor类 12345678910111213141516@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 新建一个StatementHandler // 这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); //StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 继续跳入 doQuery()方法 1234567891011121314151617//select@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); //新建一个StatementHandler //这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); //准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); //StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 继续跳入 handler.query(), 这里又从SimpleExecutor类 跳入 PreparedStatementHandler 类中，终于在这里看到了我们的JDBC的代码，并通过 ResultSetHandler 类来处理我们的结果 123456@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; ps.execute(); return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; 时序图 image 总结 可以看到一个方法的执行涉及到一大堆类，为什么要那么多类的，就是为了解耦，高内聚，低耦合，每个类都有其独有的功能，就像工厂流水线一样，一个部门做一个部门的事，专人做专事，这样也方便以后添加功能","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(五)通过SqlSession来获取Mapper的代理类","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(五)通过SqlSession来获取MapperProxy","date":"2018-11-23T02:10:44.000Z","updated":"2018-11-24T03:08:39.809Z","comments":true,"path":"2018/11/23/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(五)通过SqlSession来获取MapperProxy/","link":"","permalink":"http://www.songshuiyang.site/2018/11/23/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(五)通过SqlSession来获取MapperProxy/","excerpt":"","text":"前言有了SqlSession 这个类之后，就可以通过sqlSession.getMapper(UserMapper.class);来获取UserMapper了12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); 获取Mapper 查看代码又可以发现 Configuration 这个类的影子，哪里都有它的影子，当然因为Mapper的映射关系数据存在这里 12345@Overridepublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; // 最后会去调用MapperRegistry.getMapper return configuration.&lt;T&gt;getMapper(type, this);&#125; 继续跟进 configuration.&lt;T&gt;getMapper(type, this); 方法，进入到Configuration 类中，可以发现是MapperRegistry 类维护了Mapper的映射关系 123public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession);&#125; 继续跟进mapperRegistry.getMapper(type, sqlSession); 方法，进入到 MapperRegistry 类中，可以看到里面的映射关系就是用Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers 一个Map来存放，Key是 Class对象，Value就是MapperProxyFactory 是Mapper代理类的生成工厂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 映射器注册机 * @author Clinton Begin * @author Eduardo Macarron * @author Lasse Voss */public class MapperRegistry &#123; private Configuration config; // 将已经添加的映射都放入HashMap private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;(); public MapperRegistry(Configuration config) &#123; this.config = config; &#125; @SuppressWarnings(\"unchecked\") // 返回代理类 public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\"); &#125; try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e); &#125; &#125; public &lt;T&gt; boolean hasMapper(Class&lt;T&gt; type) &#123; return knownMappers.containsKey(type); &#125; // 看一下如何添加一个映射 public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123; // mapper必须是接口！才会添加 if (type.isInterface()) &#123; if (hasMapper(type)) &#123; // 如果重复添加了，报错 throw new BindingException(\"Type \" + type + \" is already known to the MapperRegistry.\"); &#125; boolean loadCompleted = false; try &#123; knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type)); // It's important that the type is added before the parser is run // otherwise the binding may automatically be attempted by the // mapper parser. If the type is already known, it won't try. MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type); parser.parse(); loadCompleted = true; &#125; finally &#123; // 如果加载过程中出现异常需要再将这个mapper从mybatis中删除,这种方式比较丑陋吧，难道是不得已而为之？ if (!loadCompleted) &#123; knownMappers.remove(type); &#125; &#125; &#125; &#125; /** * @since 3.2.2 */ public Collection&lt;Class&lt;?&gt;&gt; getMappers() &#123; return Collections.unmodifiableCollection(knownMappers.keySet()); &#125; /** * @since 3.2.2 */ public void addMappers(String packageName, Class&lt;?&gt; superType) &#123; // 查找包下所有是superType的类 ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses(); for (Class&lt;?&gt; mapperClass : mapperSet) &#123; addMapper(mapperClass); &#125; &#125; /** * @since 3.2.2 */ // 查找包下所有类 public void addMappers(String packageName) &#123; addMappers(packageName, Object.class); &#125; &#125; 查看该类可以发现 knownMappers 是通过 addMapper()方法来添加的，那么addMapper()是哪里调用的呢，大家还记得之前的XMLConfigBuilder这个类吗，就是这里来解析mapper节点的 123&lt;mappers&gt; &lt;mapper resource=\"resources/mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt; 回到XMLConfigBuilder类可以找到这个方法mapperElement，可以发现是通过 configuration.addMappers(mapperPackage); 及configuration.addMapper(mapperInterface); 来添加mapper映射的1234567891011121314151617181920212223242526272829303132333435363738private void mapperElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; if (\"package\".equals(child.getName())) &#123; //10.4自动扫描包下所有映射器 String mapperPackage = child.getStringAttribute(\"name\"); configuration.addMappers(mapperPackage); &#125; else &#123; String resource = child.getStringAttribute(\"resource\"); String url = child.getStringAttribute(\"url\"); String mapperClass = child.getStringAttribute(\"class\"); if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123; //10.1使用类路径 ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); //映射器比较复杂，调用XMLMapperBuilder //注意在for循环里每个mapper都重新new一个XMLMapperBuilder，来解析 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123; //10.2使用绝对url路径 ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); //映射器比较复杂，调用XMLMapperBuilder XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123; //10.3使用java类名 Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); //直接把这个映射加入配置 configuration.addMapper(mapperInterface); &#125; else &#123; throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\"); &#125; &#125; &#125; &#125;&#125; 回归主线，在 MapperRegistry 类的 getMapper 方法，可以发现是通过mapperProxyFactory.newInstance(sqlSession); 是通过Mapper代理类工厂来获取Mapper的 123456789101112// 返回代理类public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\"); &#125; try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e); &#125;&#125; 继续跟进 mapperProxyFactory.newInstance(sqlSession) 进入到 MapperProxyFactory类中，没错就是在这里生成代理Mapper的，是用JDK自带的动态代理生成映射器 123456789101112131415161718192021222324252627282930313233/** * 映射器代理工厂 * @author Lasse Voss */public class MapperProxyFactory&lt;T&gt; &#123; private final Class&lt;T&gt; mapperInterface; private Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings(\"unchecked\") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; // 用JDK自带的动态代理生成映射器 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125; 看一下MapperProxy.java 的真面目，这就是真正的实现类，重点是 mapperMethod.execute(sqlSession, args); 这一句，这是真正的执行者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 映射器代理，代理模式 * @author Clinton Begin * @author Eduardo Macarron */public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法 // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行 if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; // 这里优化了，去缓存中找MapperMethod final MapperMethod mapperMethod = cachedMapperMethod(method); // 真正的执行方法 return mapperMethod.execute(sqlSession, args); &#125; // 去缓存中找MapperMethod private MapperMethod cachedMapperMethod(Method method) &#123; MapperMethod mapperMethod = methodCache.get(method); if (mapperMethod == null) &#123; // 找不到才去new mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()); methodCache.put(method, mapperMethod); &#125; return mapperMethod; &#125;&#125; 时序图 image 总结 Mapper接口的实现类是Mybatis生成的代理类MapperProxy.java，所有接口的代理类是通过MapperProxyFactory.java 方法来生成的，这里可以看到Mybatis的高明之处就是所有Mapper接口的代理类都是通过MapperProxy.java来实现 因为是Mapper接口，所以Mybatis代理类的实现运用的是JDK的动态代理","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(四)构建SqlSession","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(四)构建SqlSession","date":"2018-11-22T08:10:44.000Z","updated":"2018-11-24T03:08:39.812Z","comments":true,"path":"2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(四)构建SqlSession/","link":"","permalink":"http://www.songshuiyang.site/2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(四)构建SqlSession/","excerpt":"","text":"前言有了SqlSessionFactory会话工厂 这个类之后，就可以通过sqlSessionFactory.openSession();来生成SqlSession了12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); SqlSession 简介Sqlsession对应着一次数据库会话。由于数据库会话不是永久的，因此Sqlsession的生命周期也不应该是永久的，相反，在你每次访问数据库时都需要创建它（当然并不是说在Sqlsession里只能执行一次sql，你可以执行多次，当一旦关闭了Sqlsession就需要重新创建它）。创建Sqlsession的地方只有一个，那就是SqlsessionFactory的openSession方法 构建 SqlSession SqlSession.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/** * 这是MyBatis主要的一个类，用来执行SQL，获取映射器，管理事务 * The primary Java interface for working with MyBatis. * Through this interface you can execute commands, get mappers and manage transactions. * * @author Clinton Begin */public interface SqlSession extends Closeable &#123; // 语句执行方法 // 这些方法被用来执行SELECT，INSERT，UPDATE和DELETE语句。 /** * Retrieve a single row mapped from the statement key * 获取一条记录 * @param &lt;T&gt; the returned object type * @param statement * @return Mapped object */ &lt;T&gt; T selectOne(String statement); /** * Retrieve a single row mapped from the statement key and parameter. * 获取一条记录 * @param &lt;T&gt; the returned object type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Mapped object */ &lt;T&gt; T selectOne(String statement, Object parameter); /** * Retrieve a list of mapped objects from the statement key and parameter. * 获取多条记录 * @param &lt;E&gt; the returned list element type * @param statement Unique identifier matching the statement to use. * @return List of mapped object */ &lt;E&gt; List&lt;E&gt; selectList(String statement); /** * Retrieve a list of mapped objects from the statement key and parameter. * 获取多条记录 * @param &lt;E&gt; the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter); /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * 获取多条记录,加上分页 * @param &lt;E&gt; the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds Bounds to limit object retrieval * @return List of mapped object */ &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap(\"selectAuthors\",\"id\") * 获取多条记录,并存入Map * @param &lt;K&gt; the returned Map keys type * @param &lt;V&gt; the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * 获取多条记录,并存入Map * @param &lt;K&gt; the returned Map keys type * @param &lt;V&gt; the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * 获取多条记录,加上分页,并存入Map * @param &lt;K&gt; the returned Map keys type * @param &lt;V&gt; the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds Bounds to limit object retrieval * @return Map containing key pair data. */ &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds); /** * Retrieve a single row mapped from the statement key and parameter * using a &#123;@code ResultHandler&#125;. * 获取一条记录,并转交给ResultHandler处理 * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, Object parameter, ResultHandler handler); /** * Retrieve a single row mapped from the statement * using a &#123;@code ResultHandler&#125;. * 获取一条记录,并转交给ResultHandler处理 * @param statement Unique identifier matching the statement to use. * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, ResultHandler handler); /** * Retrieve a single row mapped from the statement key and parameter * using a &#123;@code ResultHandler&#125; and &#123;@code RowBounds&#125; * 获取一条记录,加上分页,并转交给ResultHandler处理 * @param statement Unique identifier matching the statement to use. * @param rowBounds RowBound instance to limit the query results * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler); /** * Execute an insert statement. * 插入记录 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the insert. */ int insert(String statement); /** * Execute an insert statement with the given parameter object. Any generated * autoincrement values or selectKey entries will modify the given parameter * object properties. Only the number of rows affected will be returned. * 插入记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the insert. */ int insert(String statement, Object parameter); /** * Execute an update statement. The number of rows affected will be returned. * 更新记录 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the update. */ int update(String statement); /** * Execute an update statement. The number of rows affected will be returned. * 更新记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the update. */ int update(String statement, Object parameter); /** * Execute a delete statement. The number of rows affected will be returned. * 删除记录 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the delete. */ int delete(String statement); /** * Execute a delete statement. The number of rows affected will be returned. * 删除记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the delete. */ int delete(String statement, Object parameter); //以下是事务控制方法,commit,rollback /** * Flushes batch statements and commits database connection. * Note that database connection will not be committed if no updates/deletes/inserts were called. * To force the commit call &#123;@link SqlSession#commit(boolean)&#125; */ void commit(); /** * Flushes batch statements and commits database connection. * @param force forces connection commit */ void commit(boolean force); /** * Discards pending batch statements and rolls database connection back. * Note that database connection will not be rolled back if no updates/deletes/inserts were called. * To force the rollback call &#123;@link SqlSession#rollback(boolean)&#125; */ void rollback(); /** * Discards pending batch statements and rolls database connection back. * Note that database connection will not be rolled back if no updates/deletes/inserts were called. * @param force forces connection rollback */ void rollback(boolean force); /** * Flushes batch statements. * 刷新批处理语句,返回批处理结果 * @return BatchResult list of updated records * @since 3.0.6 */ List&lt;BatchResult&gt; flushStatements(); /** * Closes the session * 关闭Session */ @Override void close(); /** * Clears local session cache * 清理Session缓存 */ void clearCache(); /** * Retrieves current configuration * 得到配置 * @return Configuration */ Configuration getConfiguration(); /** * Retrieves a mapper. * 得到映射器 * 这个巧妙的使用了泛型，使得类型安全 * 到了MyBatis 3，还可以用注解,这样xml都不用写了 * @param &lt;T&gt; the mapper type * @param type Mapper interface class * @return a mapper bound to this SqlSession */ &lt;T&gt; T getMapper(Class&lt;T&gt; type); /** * Retrieves inner database connection * 得到数据库连接 * @return Connection */ Connection getConnection();&#125; DefaultSqlSession.java 是 SqlSession.java 接口的默认实现，从DefaultSqlSessionFactory构建的是DefaultSqlSession, 查看DefaultSqlSession.java类成员又可以发现Configuration的影子，Executor成员是MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/** * 默认SqlSession * @author Clinton Begin */public class DefaultSqlSession implements SqlSession &#123; private Configuration configuration; private Executor executor; private boolean autoCommit; private boolean dirty; public DefaultSqlSession(Configuration configuration, Executor executor, boolean autoCommit) &#123; this.configuration = configuration; this.executor = executor; this.dirty = false; this.autoCommit = autoCommit; &#125; public DefaultSqlSession(Configuration configuration, Executor executor) &#123; this(configuration, executor, false); &#125; @Override public &lt;T&gt; T selectOne(String statement) &#123; return this.&lt;T&gt;selectOne(statement, null); &#125; // 核心selectOne @Override public &lt;T&gt; T selectOne(String statement, Object parameter) &#123; // Popular vote was to return null on 0 results and throw exception on too many. // 转而去调用selectList,很简单的，如果得到0条则返回null，得到1条则返回1条，得到多条报TooManyResultsException错 List&lt;T&gt; list = this.&lt;T&gt;selectList(statement, parameter); if (list.size() == 1) &#123; return list.get(0); &#125; else if (list.size() &gt; 1) &#123; throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size()); &#125; else &#123; return null; &#125; &#125; @Override public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey) &#123; return this.selectMap(statement, null, mapKey, RowBounds.DEFAULT); &#125; @Override public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey) &#123; return this.selectMap(statement, parameter, mapKey, RowBounds.DEFAULT); &#125; // 核心selectMap @Override public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) &#123; //转而去调用selectList final List&lt;?&gt; list = selectList(statement, parameter, rowBounds); final DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = new DefaultMapResultHandler&lt;K, V&gt;(mapKey, configuration.getObjectFactory(), configuration.getObjectWrapperFactory()); final DefaultResultContext context = new DefaultResultContext(); for (Object o : list) &#123; // 循环用DefaultMapResultHandler处理每条记录 context.nextResultObject(o); mapResultHandler.handleResult(context); &#125; // 注意这个DefaultMapResultHandler里面存了所有已处理的记录(内部实现可能就是一个Map)，最后再返回一个Map return mapResultHandler.getMappedResults(); &#125; @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement) &#123; return this.selectList(statement, null); &#125; @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.selectList(statement, parameter, RowBounds.DEFAULT); &#125; // 核心selectList @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; // 根据statement id找到对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来查询结果,注意这里传入的ResultHandler是null return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public void select(String statement, Object parameter, ResultHandler handler) &#123; select(statement, parameter, RowBounds.DEFAULT, handler); &#125; @Override public void select(String statement, ResultHandler handler) &#123; select(statement, null, RowBounds.DEFAULT, handler); &#125; //核心select,带有ResultHandler，和selectList代码差不多的，区别就一个ResultHandler @Override public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); executor.query(ms, wrapCollection(parameter), rowBounds, handler); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public int insert(String statement) &#123; return insert(statement, null); &#125; @Override public int insert(String statement, Object parameter) &#123; //insert也是调用update return update(statement, parameter); &#125; @Override public int update(String statement) &#123; return update(statement, null); &#125; // 核心update @Override public int update(String statement, Object parameter) &#123; try &#123; // 每次要更新之前，dirty标志设为true dirty = true; MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来update结果 return executor.update(ms, wrapCollection(parameter)); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error updating database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public int delete(String statement) &#123; //delete也是调用update return update(statement, null); &#125; @Override public int delete(String statement, Object parameter) &#123; return update(statement, parameter); &#125; @Override public void commit() &#123; commit(false); &#125; // 核心commit @Override public void commit(boolean force) &#123; try &#123; // 转而用执行器来commit executor.commit(isCommitOrRollbackRequired(force)); // 每次commit之后，dirty标志设为false dirty = false; &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error committing transaction. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public void rollback() &#123; rollback(false); &#125; // 核心rollback @Override public void rollback(boolean force) &#123; try &#123; // 转而用执行器来rollback executor.rollback(isCommitOrRollbackRequired(force)); // 每次rollback之后，dirty标志设为false dirty = false; &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error rolling back transaction. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; // 核心flushStatements @Override public List&lt;BatchResult&gt; flushStatements() &#123; try &#123; // 转而用执行器来flushStatements return executor.flushStatements(); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error flushing statements. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; // 核心close @Override public void close() &#123; try &#123; // 转而用执行器来close executor.close(isCommitOrRollbackRequired(false)); // 每次close之后，dirty标志设为false dirty = false; &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public Configuration getConfiguration() &#123; return configuration; &#125; @Override public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; // 最后会去调用MapperRegistry.getMapper return configuration.&lt;T&gt;getMapper(type, this); &#125; @Override public Connection getConnection() &#123; try &#123; return executor.getTransaction().getConnection(); &#125; catch (SQLException e) &#123; throw ExceptionFactory.wrapException(\"Error getting a new connection. Cause: \" + e, e); &#125; &#125; // 核心clearCache @Override public void clearCache() &#123; // 转而用执行器来clearLocalCache executor.clearLocalCache(); &#125; // 检查是否需要强制commit或rollback private boolean isCommitOrRollbackRequired(boolean force) &#123; return (!autoCommit &amp;&amp; dirty) || force; &#125; // 把参数包装成Collection private Object wrapCollection(final Object object) &#123; if (object instanceof Collection) &#123; // 参数若是Collection型，做collection标记 StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;(); map.put(\"collection\", object); if (object instanceof List) &#123; // 参数若是List型，做list标记 map.put(\"list\", object); &#125; return map; &#125; else if (object != null &amp;&amp; object.getClass().isArray()) &#123; // 参数若是数组型，，做array标记 StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;(); map.put(\"array\", object); return map; &#125; // 参数若不是集合型，直接返回原来值 return object; &#125; // 严格的Map，如果找不到对应的key，直接抛BindingException例外，而不是返回null public static class StrictMap&lt;V&gt; extends HashMap&lt;String, V&gt; &#123; private static final long serialVersionUID = -5741767162221585340L; @Override public V get(Object key) &#123; if (!super.containsKey(key)) &#123; throw new BindingException(\"Parameter '\" + key + \"' not found. Available parameters are \" + this.keySet()); &#125; return super.get(key); &#125; &#125;&#125; 时序图 iamge 总结 通过源码可以看到SqlSession就像是公司的前台人员，正在干活的是 Executor ，人家来找公司谈合作，首先先和前台人员联系，然后再通过前台将人指到真正的实施者","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(三)构建SqlSessionFactory会话工厂","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(三)构建SqlSessionFactory会话工厂","date":"2018-11-22T06:10:44.000Z","updated":"2018-11-24T03:08:39.807Z","comments":true,"path":"2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(三)构建SqlSessionFactory会话工厂/","link":"","permalink":"http://www.songshuiyang.site/2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(三)构建SqlSessionFactory会话工厂/","excerpt":"","text":"前言有了Mybatis整体脉络概念之后，现在就是来构建 SqlSessionFactory会话工厂 这个类了12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); SqlSessionFactory 简介SqlSessionFactory 是Mybatis的关键对象， 是创建SqlSession的工厂，工厂模式，SqlSessionFactory 由 SqlSessionFactoryBuilder 构建，每一个MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心 logo SqlSessionFactory是个接口，它有两个实现类 DefaultSqlSessionFactory.java, SqlSessionManager.java ，Mybatis使用的是DefaultSqlSessionFactory.java 来作为其默认实现1234567891011public interface SqlSessionFactory &#123; SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration();&#125; 构建 SqlSessionFactory SqlSessionFactory 是通过SqlSessionFactoryBuilder.java 来构建的，build方法传入了一个配置文件的输入流 打开SqlSessionFactoryBuilder.java类，可以发现都是build的重载方法，主要有有俩种配置文件的输入方式，一个是Reader ，另一个是通过InputStream，可以看到里面是通过XMLConfigBuilder.java来解析xml文件的， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class SqlSessionFactoryBuilder &#123; public SqlSessionFactory build(Reader reader) &#123; return build(reader, null, null); &#125; public SqlSessionFactory build(Reader reader, String environment) &#123; return build(reader, environment, null); &#125; public SqlSessionFactory build(Reader reader, Properties properties) &#123; return build(reader, null, properties); &#125; // 第4种方法是最常用的，它使用了一个参照了XML文档或更特定的SqlMapConfig.xml文件的Reader实例。 public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; // 委托XMLConfigBuilder来解析xml文件，并构建 XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; //以下3个方法都是调用下面第8种方法 public SqlSessionFactory build(InputStream inputStream) &#123; return build(inputStream, null, null); &#125; public SqlSessionFactory build(InputStream inputStream, String environment) &#123; return build(inputStream, environment, null); &#125; public SqlSessionFactory build(InputStream inputStream, Properties properties) &#123; return build(inputStream, null, properties); &#125; // 第8种方法和第4种方法差不多，Reader换成了InputStream // 可选的参数是environment和properties。Environment决定加载哪种环境(开发环境/生产环境)，包括数据源和事务管理器。 // 如果使用properties，那么就会加载那些properties（属性配置文件），那些属性可以用$&#123;propName&#125;语法形式多次用在配置文件中。和Spring很像，一个思想？ public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123; try &#123; // 委托XMLConfigBuilder来解析xml文件 XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; inputStream.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; //最后一个build方法使用了一个Configuration作为参数,并返回DefaultSqlSessionFactory public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;&#125; 打开XMLConfigBuilder.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * XML配置构建器，建造者模式,继承BaseBuilder * @author Clinton Begin */public class XMLConfigBuilder extends BaseBuilder &#123; // 是否已解析，XPath解析器 private boolean parsed; // XPath解析器 private XPathParser parser; // 环境 private String environment; // 以下3个一组 public XMLConfigBuilder(Reader reader) &#123; this(reader, null, null); &#125; public XMLConfigBuilder(Reader reader, String environment) &#123; this(reader, environment, null); &#125; // 构造函数，转换成XPathParser再去调用构造函数 public XMLConfigBuilder(Reader reader, String environment, Properties props) &#123; // 构造一个需要验证，XMLMapperEntityResolver的XPathParser this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props); &#125; // 以下3个一组 public XMLConfigBuilder(InputStream inputStream) &#123; this(inputStream, null, null); &#125; public XMLConfigBuilder(InputStream inputStream, String environment) &#123; this(inputStream, environment, null); &#125; public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123; this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props); &#125; // 上面6个构造函数最后都合流到这个函数，传入XPathParser private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; // 首先调用父类初始化Configuration super(new Configuration()); // 错误上下文设置成SQL Mapper Configuration(XML文件配置),以便后面出错了报错用 ErrorContext.instance().resource(\"SQL Mapper Configuration\"); // 将Properties全部设置到Configuration里面去 this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; &#125; // 解析配置 public Configuration parse() &#123; // 如果已经解析过了，报错 if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true;// &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; // &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" // \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; // &lt;configuration&gt; // &lt;environments default=\"development\"&gt; // &lt;environment id=\"development\"&gt; // &lt;transactionManager type=\"JDBC\"/&gt; // &lt;dataSource type=\"POOLED\"&gt; // &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; // &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; // &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; // &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; // &lt;/dataSource&gt; // &lt;/environment&gt; // &lt;/environments&gt; // &lt;mappers&gt; // &lt;mapper resource=\"org/mybatis/ex ample/BlogMapper.xml\"/&gt; // &lt;/mappers&gt; // &lt;/configuration&gt; // 根节点是configuration parseConfiguration(parser.evalNode(\"/configuration\")); return configuration; &#125; // 解析配置 private void parseConfiguration(XNode root) &#123; try &#123; // 分步骤解析 //issue #117 read properties first //1.properties propertiesElement(root.evalNode(\"properties\")); // 2.类型别名 typeAliasesElement(root.evalNode(\"typeAliases\")); // 3.插件 pluginElement(root.evalNode(\"plugins\")); // 4.对象工厂 objectFactoryElement(root.evalNode(\"objectFactory\")); // 5.对象包装工厂 objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); // 6.设置 settingsElement(root.evalNode(\"settings\")); // read it after objectFactory and objectWrapperFactory issue #631 // 7.环境 environmentsElement(root.evalNode(\"environments\")); // 8.databaseIdProvider databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); // 9.类型处理器 typeHandlerElement(root.evalNode(\"typeHandlers\")); // 10.映射器 mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125; ..... 未完 XMLMapperBuilder.java 这个类是解析sql映射文件的 ，下面是核心代码， 可以看到Mybatis是将select|insert|update|delete这些都作为一个单独的节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 // 解析 public void parse() &#123; // 如果没有加载过再加载，防止重复加载 if (!configuration.isResourceLoaded(resource)) &#123; // 解析mapper节点 configurationElement(parser.evalNode(\"/mapper\")); // 标记一下，已经加载过了 configuration.addLoadedResource(resource); // 绑定映射器到namespace bindMapperForNamespace(); &#125; parsePendingResultMaps(); parsePendingChacheRefs(); parsePendingStatements(); &#125; public XNode getSqlFragment(String refid) &#123; return sqlFragments.get(refid); &#125; //配置mapper元素// &lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt;// &lt;select id=\"selectBlog\" parameterType=\"int\" resultType=\"Blog\"&gt;// select * from Blog where id = #&#123;id&#125;// &lt;/select&gt;// &lt;/mapper&gt; private void configurationElement(XNode context) &#123; try &#123; //1.配置namespace String namespace = context.getStringAttribute(\"namespace\"); if (namespace.equals(\"\")) &#123; throw new BuilderException(\"Mapper's namespace cannot be empty\"); &#125; builderAssistant.setCurrentNamespace(namespace); //2.配置cache-ref cacheRefElement(context.evalNode(\"cache-ref\")); //3.配置cache cacheElement(context.evalNode(\"cache\")); //4.配置parameterMap(已经废弃,老式风格的参数映射) parameterMapElement(context.evalNodes(\"/mapper/parameterMap\")); //5.配置resultMap(高级功能) resultMapElements(context.evalNodes(\"/mapper/resultMap\")); //6.配置sql(定义可重用的 SQL 代码段) sqlElement(context.evalNodes(\"/mapper/sql\")); //7.配置select|insert|update|delete TODO buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e); &#125; &#125; DefaultSqlSessionFactory.java 是构造SqlSession的默认实现，可以看到实现都是通过configuration该对象来获取配置信息，从而构造SqlSession 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 默认实现的SqlSessionFactory * @author Clinton Begin */public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private final Configuration configuration; public DefaultSqlSessionFactory(Configuration configuration) &#123; this.configuration = configuration; &#125; // 最终都会调用2种方法：openSessionFromDataSource,openSessionFromConnection // 以下6个方法都会调用openSessionFromDataSource @Override public SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false); &#125; @Override public SqlSession openSession(boolean autoCommit) &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, autoCommit); &#125; @Override public SqlSession openSession(ExecutorType execType) &#123; return openSessionFromDataSource(execType, null, false); &#125; @Override public SqlSession openSession(TransactionIsolationLevel level) &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), level, false); &#125; @Override public SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level) &#123; return openSessionFromDataSource(execType, level, false); &#125; @Override public SqlSession openSession(ExecutorType execType, boolean autoCommit) &#123; return openSessionFromDataSource(execType, null, autoCommit); &#125; //以下2个方法都会调用openSessionFromConnection @Override public SqlSession openSession(Connection connection) &#123; return openSessionFromConnection(configuration.getDefaultExecutorType(), connection); &#125; @Override public SqlSession openSession(ExecutorType execType, Connection connection) &#123; return openSessionFromConnection(execType, connection); &#125; @Override public Configuration getConfiguration() &#123; return configuration; &#125; private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; try &#123; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); // 通过事务工厂来产生一个事务 tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); // 生成一个执行器(事务包含在执行器里) final Executor executor = configuration.newExecutor(tx, execType); // 然后产生一个DefaultSqlSession return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; // 如果打开事务出错，则关闭它 closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException(\"Error opening session. Cause: \" + e, e); &#125; finally &#123; //最后清空错误上下文 ErrorContext.instance().reset(); &#125; &#125; private SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) &#123; try &#123; boolean autoCommit; try &#123; autoCommit = connection.getAutoCommit(); &#125; catch (SQLException e) &#123; // Failover to true, as most poor drivers // or databases won't support transactions autoCommit = true; &#125; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); final Transaction tx = transactionFactory.newTransaction(connection); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error opening session. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; private TransactionFactory getTransactionFactoryFromEnvironment(Environment environment) &#123; // 如果没有配置事务工厂，则返回托管事务工厂 if (environment == null || environment.getTransactionFactory() == null) &#123; return new ManagedTransactionFactory(); &#125; return environment.getTransactionFactory(); &#125; private void closeTransaction(Transaction tx) &#123; if (tx != null) &#123; try &#123; tx.close(); &#125; catch (SQLException ignore) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125;&#125; 时序图 iamge 总结 涉及到两种设计模式：工厂模式(SqlSessionFactory.java)及建造者模式(XMLConfigBuilder.java)，通过命名可以发现其设计思想，学习大佬的命名规范 SqlSessionFactory接口的默认实现是DefaultSqlSessionFactory.java DefaultSqlSessionFactory只有一个成员变量 Configuration ，所以构建SqlSessionFactory其实就是解析xml文件，构建Configuration的过程，Configuration是Mybatis的大头，所有的配置信息都存在里面 通过其运行流程可以看到每个类都有其独有的用途，各司其职，有生产SqlSession的类，又解析xml的类，有生产SqlSessionFactory的类，各个模块相互配合","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二)Mybatis框架架构","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二)Mybatis框架架构","date":"2018-11-22T03:10:44.000Z","updated":"2018-11-26T13:58:30.434Z","comments":true,"path":"2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二)Mybatis框架架构/","link":"","permalink":"http://www.songshuiyang.site/2018/11/22/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(二)Mybatis框架架构/","excerpt":"","text":"引言本文主要讲解Mybatis的整体程序设计，理清楚框架的主要脉络，这样才能对源码有个整体的了解，先主干后分支，如果没有这些概念那么直接看源码的话肯定会很吃力的 整体设计整体架构图 logo 运作流程(1)、加载配置并初始化Mybatis配置包括两种配置，一种是Mybatis自身的框架配置，另一种是sql映射配置，Mybatis自身的框架配置有两种方式可以配置， 一处是配置文件，另一处是通过Java注解进行配置， 比如说Spring Boot项目整合Mybatis都是通过Java代码的方式来进行配置 初始化是初始化框架基本配置，然后解析sql映射文件，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。 (2)、接收调用请求通过接口来接收调用请求，真实企业环境一般都是通过接口的方式来进行调用，通过该接口将请求传递给下层的请求处理层进行处理。 传统Mybatis工作模式，是创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。 image 接口工作模式，MyBatis 将配置文件中的每一个 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟 节点中的 节点项对应，即 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。 image (3)、处理操作请求处理操作包括参数映射，sql解析，sql执行操作 (4)、返回请求结果将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。 MyBatis的主要的核心部件 logo 类名 描述 SqlSession 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能 Executor MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。 ParameterHandler 负责对用户传递的参数转换成JDBC Statement 所需要的参数 ResultSetHandler 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合 TypeHandler 负责java数据类型和jdbc数据类型之间的映射和转换 MappedStatement MappedStatement维护了一条select update delete insert节点的封装 SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中并返回 BoundSql 表示动态生成的SQL语句以及相应的参数信息 Configuration MyBatis所有的配置信息都维持在Configuration对象之中。 参考： https://blog.csdn.net/luanlouis/article/details/40422941 http://chenjc-it.iteye.com/blog/1460990","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(一)本地编译Mybatis的源码","slug":"backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(一)本地编译Mybatis的源码","date":"2018-11-21T07:59:44.000Z","updated":"2018-11-26T14:06:30.201Z","comments":true,"path":"2018/11/21/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(一)本地编译Mybatis的源码/","link":"","permalink":"http://www.songshuiyang.site/2018/11/21/backend/framework/mybatis/sourceCodeAnalysis/Mybatis源码(一)本地编译Mybatis的源码/","excerpt":"","text":"引言在开发过程中，对于Mybatis框架一直都是在使用阶段，对于其底层实现的细节不是十分清楚，所以利用空余时间学习Mybatis的源码，学习其设计思想，看看大佬是怎样设计一个框架的，提升自己的代码能力 下载源码 地址 网站 中文官网 http://www.mybatis.org/mybatis-3/zh/index.html 源码地址 https://github.com/mybatis/mybatis-3 下载完源码包后使用maven进行编译 mvn clean install 可以发现会报error 查看pom.xml 发现又一个父级依赖 12345&lt;parent&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-parent&lt;/artifactId&gt; &lt;version&gt;33-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 所以需要把这些依赖下载下来 12345// 下载代码git clone https://github.com/mybatis/parent.git// 编译代码mvn clean install 父级依赖完成之后更改Mybatis的源码，注意版本号需要一致 123456&lt;parent&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-parent&lt;/artifactId&gt; &lt;version&gt;33-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; 解决部分插件版本问题 告诉我们部分插件没有指定的相应的版本号，出于工程的稳定性考虑需要对使用的插件指定其版本号，并给出了合适的版本号，如图红色方框中的文字。我们只要在mybatisg工程的pom.xml文件中找到相对应的插件处添加$NUM 标签即可， $NUM代表具体的版本号。到这我们再执行mvn clean install 指令就可以将mybatis工程构建成功了。 源码基本结构打开源码可以发现如下目录，通过包名就可以大概知道其模块功能 image 解析以下章节将从下面的示例代码来一步步解析Mybatis的源码，分析其实现过程12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactory会话工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 构建SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 通过SqlSession来获取MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1));~ 参考：https://blog.csdn.net/yums467/article/details/52801288","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"SpringBoot配置Mybatis多数据源","slug":"backend/framework/mybatis/SpringBoot配置Mybatis多数据源","date":"2018-11-09T02:59:44.000Z","updated":"2018-11-13T11:59:09.617Z","comments":true,"path":"2018/11/09/backend/framework/mybatis/SpringBoot配置Mybatis多数据源/","link":"","permalink":"http://www.songshuiyang.site/2018/11/09/backend/framework/mybatis/SpringBoot配置Mybatis多数据源/","excerpt":"","text":"背景同一个项目数据操作有时会涉及到多个数据库，所以需要在后台配置多个数据源，通过特定的设置选择指定的数据库 目的可以配置多个数据源，项目默认使用master数据源，当有新的数据源需求时，可以通过注解的形式动态切换数据源 实现源码: https://github.com/songshuiyang/iframe application.yml 配置数据源1234567891011121314151617181920212223242526272829spring: application: name: iframe# 主数据库master: datasource: use-jndi: false jndi-name: jdbc/datasource url: jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false username: root password: root driver-class: com.mysql.jdbc.Driver initial-size: 0 min-idle: 10 max-active: 100 max-wait: 20000# 从数据库slave: datasource: use-jndi: false jndi-name: jdbc/datasource url: jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false username: root password: root driver-class: com.mysql.jdbc.Driver initial-size: 0 min-idle: 10 max-active: 100 max-wait: 20000 Config.java 解析数据源配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 继承TransactionManagementConfigurer可以自定义事务管理器 * @author songsy * @Date 2018/11/7 17:09 */@Configuration@EnableTransactionManagementpublic class Config implements TransactionManagementConfigurer &#123; private static final Logger logger = LoggerFactory.getLogger(Config.class); @Autowired Environment env; /** * 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器 * * @return */ @Override public PlatformTransactionManager annotationDrivenTransactionManager() &#123; return transactionManager(); &#125; /** * 数据源 * * @return */ @Bean(name = \"dataSource\") public DynamicDataSource dataSource() &#123; Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); for (String prefix : DATA_SOURCE_PREFIX) &#123; targetDataSources.put(prefix, createDataSource(prefix)); &#125; DynamicDataSource dynamicDataSource = new DynamicDataSource(); dynamicDataSource.setTargetDataSources(targetDataSources); dynamicDataSource.setDefaultTargetDataSource(targetDataSources.get(MASTER_DATA_SOURCE_PREFIX)); return dynamicDataSource; &#125; /** * 创建事务管理器 * * @return */ @Bean public PlatformTransactionManager transactionManager() &#123; DataSourceTransactionManager txManager = new DataSourceTransactionManager(); txManager.setDataSource(dataSource()); return txManager; &#125; /** * 创建数据源 * * @param prefix * @return */ private DataSource createDataSource(String prefix) &#123; // 是否使用数据源 boolean useJndi = env.getProperty(prefix + \".\" + \"datasource.use-jndi\", Boolean.class, false); // 数据源名称 String jndiName = env.getProperty(prefix + \".\" + \"datasource.jndi-name\", \"\"); // 数据库链接 String url = env.getProperty(prefix + \".\" + \"datasource.url\", \"\"); String username = env.getProperty(prefix + \".\" + \"datasource.username\", \"\"); String password = env.getProperty(prefix + \".\" + \"datasource.password\", \"\"); String driverClass = env.getProperty(prefix + \".\" + \"datasource.driver-class\", \"\"); // 数据源默认初始链接数 int initialSize = env.getProperty(prefix + \".\" + \"datasource.initial-size\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_INIT_SIZE); // 数据源最大连接数 int maxActive = env.getProperty(prefix + \".\" + \"datasource.max-active\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_MAX_ACTIVE); // 数据源最小连接数 int minIdle = env.getProperty(prefix + \".\" + \"datasource.min-idle\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_MIN_IDLE); // 配置获取连接等待超时的时间 int maxWait = env.getProperty(prefix + \".\" + \"datasource.max-wait\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_MAX_WAIT); if (useJndi) &#123; try &#123; logger.debug(\"get datasource from jndi - [&#123;&#125;].\", jndiName); Context context = new InitialContext(); DataSource dataSource = (DataSource) context.lookup(jndiName); return dataSource; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; else &#123; logger.debug(\"create druid datasource.\"); logger.debug(\"url - &#123;&#125;.\", url); logger.debug(\"username - &#123;&#125;.\", username); logger.debug(\"password - &#123;&#125;.\", password); logger.debug(\"driverClass - &#123;&#125;.\", driverClass); logger.debug(\"initialSize - &#123;&#125;.\", initialSize); logger.debug(\"maxActive - &#123;&#125;.\", maxActive); logger.debug(\"minIdle - &#123;&#125;.\", minIdle); try &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(url); datasource.setDriverClassName(driverClass); datasource.setUsername(username); datasource.setPassword(password); datasource.setInitialSize(initialSize); datasource.setMaxActive(maxActive); datasource.setMinIdle(minIdle); datasource.setMaxWait(maxWait); datasource.setFilters(\"stat,slf4j\"); datasource.setProxyFilters(getDruidFilters()); return datasource; &#125; catch (Exception e) &#123; &#125; &#125; return null; &#125; public List&lt;Filter&gt; getDruidFilters() &#123; Slf4jLogFilter slf4jLogFilter = new Slf4jLogFilter(); slf4jLogFilter.setDataSourceLogEnabled(false); slf4jLogFilter.setStatementLogEnabled(false); slf4jLogFilter.setStatementExecutableSqlLogEnable(true); slf4jLogFilter.setResultSetLogEnabled(false); slf4jLogFilter.setResultSetCloseAfterLogEnabled(false); slf4jLogFilter.setConnectionLogEnabled(false); List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); filters.add(new StatFilter()); filters.add(slf4jLogFilter); return filters; &#125;&#125; 新增 @BindingDataSources 注解，通过该注解实现数据源切换 123456789101112/** * 绑定数据源注解 * @author songsy * @Date 2018/11/7 17:33 */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface BindingDataSources &#123; String value() default \"master\";&#125; 新增 DynamicDataSource.java 实现切换数据源 123456789101112/** * 继承AbstractRoutingDataSource实现determineCurrentLookupKey方法，该方法可以实现数据库的动态切换 * @author songsy * @Date 2018/11/7 17:17 */public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DynamicDataSourceHolder.getDataSource(); &#125;&#125; 新增 DynamicDataSourceHolder.java 保存当前线程绑定的数据源信息1234567891011121314151617181920212223/** * 保存当前线程绑定的数据源信息 * @author songsy * @Date 2018/11/7 17:18 */public class DynamicDataSourceHolder &#123; private static final ThreadLocal&lt;String&gt; dataSourceHolder = new ThreadLocal&lt;&gt;(); public static void setDataSource(String dataSource) &#123; Assert.notNull(dataSource, \"dataSource cannot be null\"); dataSourceHolder.set(dataSource); &#125; public static String getDataSource() &#123; return dataSourceHolder.get(); &#125; public static void removeDataSource() &#123; dataSourceHolder.remove(); &#125;&#125; 通过 DynamicDataSourceAspect.java AOP切面来获取数据源注解信息并设置到 private static final ThreadLocal&lt;String&gt; dataSourceHolder = new ThreadLocal&lt;&gt;(); 变量中，那么determineCurrentLookupKey 方法就可以根据当前线程数据源key值去动态切换数据源 1234567891011121314151617181920212223242526272829303132/** * 配置数据源切面 * @author songsy * @Date 2018/11/7 17:35 */@Aspect@Order(-1)// 保证该AOP在@Transactional之前执行@Componentpublic class DynamicDataSourceAspect &#123; private final static Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class); @Pointcut(\"@annotation(com.songsy.iframe.core.persistence.datasource.annotation.BindingDataSources)\") public void pointcut() &#123; &#125; @Before(\"pointcut() &amp;&amp; @annotation(bindingDataSources)\") public void setDynamicDataSource(JoinPoint point, BindingDataSources bindingDataSources) &#123; Object target = point.getTarget(); Method method = ((MethodSignature) point.getSignature()).getMethod(); logger.debug(\"切换数据源: 类名 - &#123;&#125;\", target.getClass().getCanonicalName()); logger.debug(\"切换数据源: 方法名 - &#123;&#125;\", method.getName()); String key = bindingDataSources.value(); DynamicDataSourceHolder.setDataSource(key); logger.debug(\"切换数据源：[&#123;&#125;] 数据源切换成功.\", DynamicDataSourceHolder.getDataSource()); &#125; @After(\"pointcut()\") public void clearDynamicDataSource(JoinPoint point) &#123; DynamicDataSourceHolder.removeDataSource(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Mybatis通用增删改查实现","slug":"backend/framework/mybatis/Mybatis通用增删改查实现","date":"2018-11-04T03:06:44.000Z","updated":"2018-11-04T03:20:40.217Z","comments":true,"path":"2018/11/04/backend/framework/mybatis/Mybatis通用增删改查实现/","link":"","permalink":"http://www.songshuiyang.site/2018/11/04/backend/framework/mybatis/Mybatis通用增删改查实现/","excerpt":"","text":"iframe 一个基于Mybtais的通用增删改查功能的工具包，mapper接口只要继承相应的接口，实体类添加几个注解即可面向对象操作数据 iframe 基于Spring boot, Gradle, mybatis3实现，代码已通过测试 代码： https://github.com/songshuiyang/iframe 为什么有这个开发需求： 1、在实际整合了Mybatis的项目开发过程中经常会遇到变更数据库字段的情况，如果表结构发生了变化就需要重新修改mapper对应的xml文件，每次修改都要同步更新xml文件。 2、在普通的mapper接口中发现普通的增删改查这些方法每一个mapper接口都有，通过对比可以发现方法除了实体类属性不一样之外，其他的都一样(如下所示)，而且mapper文件也有大量增删改查的sql1234567891011int deleteByPrimaryKey(E id);int insert(T record);int insertSelective(T record);T selectByPrimaryKey(E id);int updateByPrimaryKeySelective(T record);int updateByPrimaryKey(T id); Mybatis 和 Hibernate 优缺点对比 现在开源项目中持久层框架用到最多的基本就是 MyBatis 和 Hibernate Mybatis优点 Mybatis入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验 可以进行更为细致的SQL优化，可以减少查询字段缺点 虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。 Hibernate优点 不需要编写的SQL语句(不需要编辑JDBC)，只需要操作相应的对象就可以了，就可以能够存储、更新、删除、加载对象，可以提高生产效率 使用Hibernate，移植性好缺点 由于对持久层封装过于完整，导致开发人员无法对SQL进行优化，无法灵活使用JDBC的原生SQL，Hibernate封装了JDBC，所以没有JDBC直接访问数据库效率高。要使用数据库的特定优化机制的时候，不适合用Hibernate 开发目的对比Mybatis 和 Hibernate 优缺点，可以发现他们之间的优缺点可以互补，为何不取其精华, 去其糟粕, 双剑合并呢, 所以初步想法是在Mybatis的基础框架上, 扩展一下其面向对象操作的功能。 使用方法准备 在自己的项目中导入 com.songsy.iframe.core.persistence.provider 包下的所有文件。 默认数据库各张表都有如下字段, 如果不符合项目需要即可修改对应的源码 1234567`created_date` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',`created_by` varchar(32) DEFAULT NULL COMMENT '创建人',`last_modified_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后修改时间',`last_modified_by` varchar(32) DEFAULT NULL COMMENT '最后修改人',`version` bigint(20) DEFAULT NULL COMMENT '版本',`remarks` varchar(255) DEFAULT NULL COMMENT '备注',`enable` bit(1) DEFAULT b'1' COMMENT '是否启用', mybatis版本在3.0以上，需要使用其新特性 使用 实体类继承BaseEntity.class类获得公共属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 实体类基类 * @author songshuiyang * @date 2018/10/28 10:13 */@Getter@Setterpublic class BaseEntity&lt;ID&gt; implements Serializable &#123; private static final long serialVersionUID = -3873745966284869947L; /** * 主键 */ @Id(type = Integer.class) @GeneratedValue(strategy = GenerationType.CUSTOM) private ID id; /** * 创建人 */ private String createdBy; /** * 创建时间 */ private Date createdDate; /** * 最后修改人 */ private String lastModifiedBy; /** * 最后修改时间 */ private Date lastModifiedDate; /** * 备注 */ private String remarks; /** * 乐观锁字段 */ @Version private Long version; /** * 逻辑删除标识 */ @Deleted private boolean enable = true; @Override public int hashCode() &#123; return this.id != null ? this.id.hashCode() : null; &#125; @Override public boolean equals(Object obj) &#123; if (!(obj instanceof BaseEntity)) &#123; return false; &#125; BaseEntity i = (BaseEntity) obj; if (i.getId() == null || this.getId() == null) &#123; return false; &#125; if (this.getId().equals(i.getId())) &#123; return true; &#125; return false; &#125;&#125; 实体类加上对应的注解 1234567891011121314151617181920212223242526272829303132/** * 用户 * @author songshuiyang * @date 2017/11/28 21:36 */@Data@Entity@Table(name = \"sys_user\")@EqualsAndHashCode(callSuper = false)public class User extends BaseEntity&lt;Integer&gt; &#123; private String username; private String password; private String nickname; private Integer sex; private Integer age; private String phone; private String email; private String address; private String salt; @Column(name = \"head_portrait\") private String headPortrait;&#125; 注解是参照Jpa的注解来定制的，详情可见com.songsy.iframe.core.persistence.provider.annotation 注解 作用 @Entity 修饰实体类，指明该类将映射到指定的数据表 @Table 当实体类与映射的数据库表名不同名时需要使用 @Table 注解，该注解与 @Entity 注解并列使用，使用其 name 属性指明数据库的表名, 不填写name属性则默认是类名的转化成_格式的表名 @Column 当实体类属性名与数据库字段名不一致时, 可用该注解标识实体类对应在数据库的字段名 @Id 标识该属性为主键 @GeneratedValue 标注主键的生成策略，通过其 strategy 属性标识生成策略 @Transient 标注此注解后在操作数据表的时候将会忽略该属性 @Version 标识乐观锁字段 @Deleted 逻辑删除标识 mapper接口继承BaseCurdMapper.java ，Mapper层增加其通用增删改查方法, &lt;User,Integer&gt;：第一个是实体类类型，第二个标识主键类型12345678/** * 用户 * @author songshuiyang * @date 2017/11/28 20:12 */public interface UserMapper extends BaseCurdMapper&lt;User,Integer&gt; &#123;&#125; 增加的方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 查询所有数据 * @return */List&lt;T&gt; findAll();/** * 根据id查询记录 * @return */T findById(Object id);/** * 插入记录 * @param entity * @return */int insert(T entity);/** * 更新记录 * @param entity * @return */int update(T entity);/** * 更新记录(null值记录也更新) * @param entity * @return */int updateNull(T entity);/** * 根据id物理删除记录 * @param id * @return */int deleteOne (Object id);/** * 根据id逻辑删除记录 * @param id * @return */int logicDeleteOne (Object id); service接口继承BaseService.java ，Service层增加其通用增删改查方法1234567/** * @author songshuiyang * @date 2018/10/28 10:13 */public interface UserService extends BaseService&lt;User, Integer&gt; &#123;&#125; 增加的方法：1234567891011121314151617181920/** * @author songsy * @Date 2018/10/31 18:06 */public interface BaseService &lt;T extends BaseEntity, ID extends Serializable&gt;&#123; List&lt;T&gt; findAll(); T findById(ID id); T saveSelective(T entity); T saveSelective(T entity, Boolean hasId); int updateNull(T entity); int deleteOne (ID id); int logicDeleteOne (ID id);&#125; service实现类继承AbstractBaseService.java ，重写getRepository()方法12345678910111213141516/** * @author songshuiyang * @date 2018/10/28 10:13 */@Servicepublic class UserServiceImpl extends AbstractBaseService&lt;User, Integer&gt; implements UserService &#123; @Autowired private UserMapper userMapper; @Override public BaseCurdMapper&lt;User, Integer&gt; getRepository() &#123; return userMapper; &#125;&#125; AbstractBaseService.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 抽象service基类 * * @author songsy * @Date 2018/131 17:17 */@Slf4jpublic abstract class AbstractBaseService&lt;T extends BaseEntity, ID extends Serializable&gt; &#123; public abstract BaseCurdMapper&lt;T, ID&gt; getRepository(); public List&lt;T&gt; findAll() &#123; return getRepository().findAll(); &#125; public T findById(ID id) &#123; return getRepository().findById(id); &#125; public int updateNull(T entity) &#123; return getRepository().updateNull(entity); &#125; public int deleteOne(ID id) &#123; return getRepository().deleteOne(id); &#125; public int logicDeleteOne(ID id) &#123; return getRepository().logicDeleteOne(id); &#125; /** * 通用插入更新方法 * * @param entity * @return */ @Transactional public T saveSelective(T entity) &#123; return saveSelective(entity, false); &#125; @Transactional public T saveSelective(T entity, Boolean hasId) &#123; if (hasId) &#123; // 之前已经生成了id insertSelective(entity); &#125; else if (!StringUtils.isEmpty(entity.getId())) &#123; updateSelective(entity); // 插入数据库之后 实体类乐观锁字段自增 entity.setVersion(entity.getVersion() + 1); &#125; else &#123; Class idClass = ReflectionUtils.getPrimarykeyClassType(entity.getClass()); // 如果主键是字符类型，则采用32位随机字符作为主键 if (idClass.equals(String.class)) &#123; entity.setId(IDGeneratorUtils.generateID()); &#125; else &#123; // 默认主键由数据库自动生成（主要是自动增长型） &#125; insertSelective(entity); &#125; return entity; &#125; private void insertSelective(T entity) &#123; entity.setCreatedDate(new Date()); entity.setLastModifiedDate(new Date()); entity.setVersion(new Long(1)); // 设置当前登录人// if (null == entity.getCreatedBy()) &#123;// entity.setCreatedBy(\"\");// &#125;// if (null == entity.getLastModifiedBy()) &#123;// entity.setLastModifiedBy(\"\");// &#125; getRepository().insert(entity); &#125; private void updateSelective(T entity) &#123; if (entity.getVersion() == null) &#123; throw new VersionException(); &#125; entity.setLastModifiedDate(new Date()); // 设置当前登录人// if (null == entity.getLastModifiedBy()) &#123;// entity.setLastModifiedBy(\"\");// &#125; Integer flag = getRepository().update(entity); if (flag == 0) &#123; throw new UpdateException(); &#125; &#125;&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author songsy * @Date 2018/10/31 18:00 */public class UserServiceTest extends BaseTest &#123; @Autowired UserService userService; @Test public void findAll () &#123; userService.findAll(); &#125; @Test public void insertUser () &#123; User user = new User(); user.setUsername(\"songsy\"); user.setAddress(\"广东深圳\"); user.setAge(88); user.setEmail(\"1459074711@qq.com\"); user.setHeadPortrait(\"头像\"); user.setNickname(\"宋某\"); user.setPassword(\"root\"); user.setSex(1); userService.saveSelective(user); &#125; @Test public void updateUser1 () &#123; User user = new User(); user.setId(48); user.setUsername(\"songsy\"); user.setAddress(\"广东深圳\"); user.setAge(88); user.setEmail(\"1459074711@qq.com\"); user.setHeadPortrait(\"头像\"); user.setNickname(\"宋某某\"); user.setPassword(\"root\"); user.setSex(1); user.setVersion(1l); userService.saveSelective(user); &#125; @Test public void updateUser2 () &#123; User user = userService.findAll().get(0); User userDb = new User(); userDb.setId(user.getId()); userDb.setVersion(user.getVersion()); userDb.setUsername(\"测试乐观锁111\"); userService.saveSelective(userDb); &#125; @Test public void updateNull () &#123; User user = userService.findById(50); User userDb = new User(); userDb.setId(user.getId()); userDb.setVersion(user.getVersion()); userDb.setUsername(\"测试updateNull\"); userService.updateNull(userDb); &#125; @Test public void deleteOne () &#123; userService.deleteOne(48); &#125; @Test public void logicDeleteOne () &#123; userService.logicDeleteOne(49); &#125;&#125; 使用总结 如果增加或者修改了数据库字段，只要修改对应的实体类文件即可，配合注解的使用可以十分方便完成修改，对于增删改查的操作代码再也不用一个个去修改xml文件了 不用在每一个mapper接口, Mybatis xml文件添加一些重复的代码 在service层即可完成通用增删改查方法，使用Mybatis也可以像Hibernate 那样用对象来更新数据库了 实现解析 详细实现可见com.songsy.iframe.core.persistence.provider 按步骤解析： 使用Spring Aop收集实体类信息及缓存起来，每次调用继承了BaseCurdMapper.java的Mapper接口就会触发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.songsy.iframe.core.persistence.provider.aspect;import com.google.common.collect.Maps;import com.songsy.iframe.core.persistence.provider.exception.ParameterizedTypeException;import com.songsy.iframe.core.persistence.provider.mapper.BaseCurdMapper;import com.songsy.iframe.core.persistence.provider.threadlocal.EntityProperty;import com.songsy.iframe.core.persistence.provider.threadlocal.EntityThreadLocal;import com.songsy.iframe.core.persistence.provider.utils.ReflectionUtils;import org.apache.ibatis.binding.MapperProxy;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Proxy;import java.lang.reflect.Type;import java.util.Map;/** * BaseCurdMapper接口AOP，用于获取实体类属性 * * @author songshuiyang * @date 2018/10/30 21:44 */@Aspect@Componentpublic class BaseCurdMapperAspect &#123; private final static Logger logger = LoggerFactory.getLogger(BaseCurdMapperAspect.class); /** * 缓存实体类属性 * key: 实体类类型 * value: 实体类属性对象 */ private static Map&lt;String, EntityProperty&gt; entityPropertyMap = Maps.newHashMap(); /** * 定义切点 * Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象， * 当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。 */ @Pointcut(\"this(com.songsy.iframe.core.persistence.provider.mapper.BaseCurdMapper)\") public void pointcut() &#123; &#125; /** * 前置增强：获取BaseCurdMapper接口 泛型属性，并设置到ThreadLocal中 * @param point */ @Before(\"pointcut()\") public void before(JoinPoint point) &#123; Class entityClass = null; Class entityIdClass = null; Object target= point.getTarget(); // 是否继承 BaseCurdMapper 接口 if (BaseCurdMapper.class.isAssignableFrom(target.getClass())) &#123; // 获取Mybatis代理类对象 MapperProxy mapperProxy = (MapperProxy) Proxy.getInvocationHandler(target); Class mapperInterface = (Class) ReflectionUtils.getFieldValue(mapperProxy, \"mapperInterface\"); // 获取接口泛型对象 ParameterizedType parameterizedType = (ParameterizedType) mapperInterface.getGenericInterfaces()[0]; Type[] types = parameterizedType.getActualTypeArguments(); if (types.length != 2) &#123; logger.error(\"parameterizedType type length error\"); throw new ParameterizedTypeException(parameterizedType.getTypeName()); &#125; try &#123; entityClass = Class.forName(types[0].getTypeName()); entityIdClass = Class.forName(types[1].getTypeName()); // 如果不存在则加入到entityPropertyMap缓存中 if (!entityPropertyMap.containsKey(entityClass.getName())) &#123; EntityProperty entityProperty = new EntityProperty(entityClass, entityIdClass); entityPropertyMap.put(entityClass.getTypeName(),entityProperty); &#125; &#125; catch (ClassNotFoundException e) &#123; logger.error(e.getMessage()); &#125; &#125; // 设置ThreadLocal if (null != entityClass) &#123; EntityThreadLocal.set(entityPropertyMap.get(entityClass.getName())); &#125; &#125; /** * 后置增强：清除 threadLocal 防止内存泄漏 * @param point */ @After(\"pointcut()\") public void after(JoinPoint point) &#123; EntityThreadLocal.remove(); &#125;&#125; 使用ThreadLocal 获取当前访问线程实体类信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。 * 每次调用mapper接口方法的时候，先把实体类的信息存放在ThreadLocal中 * @author songshuiyang * @date 2018/10/30 21:27 */public class EntityThreadLocal &#123; private static ThreadLocal&lt;EntityProperty&gt; threadLocal = new ThreadLocal&lt;&gt;(); /** * 获取当前线程的实体类属性 * @return */ public static EntityProperty get () &#123; if (null == threadLocal) &#123; initialValue(); &#125; return threadLocal.get(); &#125; /** * 设置当前线程的实体类属性 * @param entityProperty */ public static void set(EntityProperty entityProperty) &#123; if (entityProperty != null) &#123; threadLocal.set(entityProperty); &#125; &#125; /** * 清除 threadLocal */ public static void remove() &#123; threadLocal.remove(); &#125; /** * 默认初始化Object.class */ private static void initialValue() &#123; EntityProperty entityProperty = new EntityProperty(); entityProperty.setEntityClass(Object.class); entityProperty.setIdClass(null); threadLocal.set(entityProperty); &#125;&#125; 使用Mybatis3的@SelectProvider、@InsertProvider, @UpdateProvider,@DeleteProvider，使用注解来配置Mapper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 通用增删改查Mapper * @author songshuiyang * @date 2018/10/28 11:22 */public interface CurdMapper&lt;T extends BaseEntity, ID extends Serializable&gt; &#123; /** * 查询所有数据 * @return */ @SelectProvider(type=MybatisProvider.class,method = MybatisProvider.FIND_ALL) List&lt;T&gt; findAll(); /** * 根据id查询记录 * @return */ @SelectProvider(type=MybatisProvider.class, method = MybatisProvider.FIND_BY_ID) T findById(Object id); /** * 插入记录 * @param entity * @return */ @InsertProvider(type=MybatisProvider.class, method = MybatisProvider.INSERT) int insert(T entity); /** * 更新记录 * @param entity * @return */ @UpdateProvider(type=MybatisProvider.class, method = MybatisProvider.UPDATE) int update(T entity); /** * 更新记录(null值记录也更新) * @param entity * @return */ @UpdateProvider(type=MybatisProvider.class, method = MybatisProvider.UPDATE_NULL) int updateNull(T entity); /** * 根据id物理删除记录 * @param id * @return */ @DeleteProvider(type=MybatisProvider.class, method = MybatisProvider.DELETE_ONE) int deleteOne (Object id); /** * 根据id逻辑删除记录 * @param id * @return */ @DeleteProvider(type=MybatisProvider.class, method = MybatisProvider.LOGIC_DELETE_ONE) int logicDeleteOne (Object id); /** * 分页查询 * @param page * @return */ @SelectProvider(type=MybatisProvider.class,method = MybatisProvider.FIND_AUTO_BY_PAGE) List&lt;T&gt; findAutoByPage(Page&lt;T&gt; page);&#125; 通用增删改查实现类，在这里实现sql的拼接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package com.songsy.iframe.core.persistence.provider;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import com.songsy.iframe.core.persistence.provider.annotation.Version;import com.songsy.iframe.core.persistence.provider.entity.ColumnEntity;import com.songsy.iframe.core.persistence.provider.entity.TableEntity;import com.songsy.iframe.core.persistence.provider.utils.MybatisTableUtils;import com.songsy.iframe.core.persistence.provider.utils.PageUtils;import com.songsy.iframe.core.persistence.provider.utils.ReflectionUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.Field;import java.text.ParseException;import java.util.List;import java.util.Map;import java.util.Set;/** * 通用增删改查实现方法 * @author songshuiyang * @date 2018/10/28 11:34 */public class CrudProvider &#123; private static Logger logger = LoggerFactory.getLogger(CrudProvider.class); public static final String FIND_ALL = \"findAll\"; public static final String FIND_BY_ID = \"findById\"; public static final String INSERT = \"insert\"; public static final String UPDATE = \"update\"; public static final String UPDATE_NULL = \"updateNull\"; public static final String DELETE_ONE = \"deleteOne\"; public static final String LOGIC_DELETE_ONE =\"logicDeleteOne\"; public static final String FIND_AUTO_BY_PAGE = \"findAutoByPage\"; /** * 查询所有数据 * @return */ public String findAll() &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); String sql = \"SELECT * FROM \" + tableEntity.getTableName(); return sql; &#125; /** * 根据id查询记录 * @param id * @return */ public String findById (Object id) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); StringBuilder sb = new StringBuilder(\"SELECT \"); sb.append(\" * \"); sb.append(\"FROM\"); sb.append(\" \").append(tableEntity.getTableName()).append(\" \"); sb.append(\" WHERE \").append(tableEntity.getIdColumnEntity().getColumnName()).append(\"=\").append(id); return sb.toString(); &#125; /** * 插入记录 * @param entity */ public String insert (Object entity) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); List&lt;ColumnEntity&gt; columnEntities = tableEntity.getColumnEntities(); List&lt;String&gt; fieldNames = Lists.newArrayList(); List&lt;String&gt; columnNames = Lists.newArrayList(); for (ColumnEntity columnEntity : columnEntities) &#123; Object value = ReflectionUtils.getFieldValue(entity, columnEntity.getFieldName()); // 字段为null不插入 if (value != null) &#123; columnNames.add(columnEntity.getColumnName()); fieldNames.add(\"#&#123;\" + columnEntity.getFieldName() + \"&#125;\"); &#125; &#125; StringBuilder sb = new StringBuilder(\"INSERT INTO \"); sb.append(tableEntity.getTableName()); sb.append(\" (\"); sb.append(StringUtils.join(columnNames, \",\")); sb.append(\") \"); sb.append(\" VALUES(\"); sb.append(StringUtils.join(fieldNames, \",\")); sb.append(\")\"); String sql = sb.toString(); return sql; &#125; /** * 更新记录 * 字段属性为null不更新 * @param entity */ public String update (Object entity) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); List&lt;ColumnEntity&gt; columnEntities = tableEntity.getColumnEntities(); ColumnEntity versionColumnEntity = null; List&lt;String&gt; updateColumns = Lists.newArrayList(); for (ColumnEntity columnEntity : columnEntities) &#123; // 乐观锁处理 更新后version字段加一 Field field = columnEntity.getField(); Version version = field.getAnnotation(Version.class); &#123; if (version != null) &#123; versionColumnEntity = columnEntity; updateColumns.add(columnEntity.getColumnName() + \" = \" + columnEntity.getFieldName() + \" + 1\"); continue; &#125; &#125; Object value = ReflectionUtils.getFieldValue(entity, columnEntity.getFieldName()); if (value != null) &#123; updateColumns.add(columnEntity.getColumnName() + \" = \" + \"#&#123;\" + columnEntity.getFieldName() + \"&#125;\"); &#125; &#125; StringBuilder sb = new StringBuilder(\"UPDATE \"); sb.append(tableEntity.getTableName()); sb.append(\" SET \"); sb.append(StringUtils.join(updateColumns, \",\")); sb.append(\" WHERE \"); sb.append(tableEntity.getIdColumnEntity().getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + tableEntity.getIdColumnEntity().getFieldName() + \"&#125;\"); sb.append(\" and \"); sb.append(versionColumnEntity.getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + versionColumnEntity.getFieldName() + \"&#125;\"); String sql = sb.toString(); return sql; &#125; /** * 更新记录 * 字段属性为null 也会更新为null * @param entity */ public String updateNull (Object entity) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); List&lt;ColumnEntity&gt; columnEntities = tableEntity.getColumnEntities(); ColumnEntity versionColumnEntity = null; List&lt;String&gt; updateColumns = Lists.newArrayList(); for (ColumnEntity columnEntity : columnEntities) &#123; // 乐观锁处理 更新后version字段加一 Field field = columnEntity.getField(); Version version = field.getAnnotation(Version.class); &#123; if (version != null) &#123; versionColumnEntity = columnEntity; updateColumns.add(columnEntity.getColumnName() + \" = \" + columnEntity.getFieldName() + \" + 1\"); continue; &#125; &#125; updateColumns.add(columnEntity.getColumnName() + \" = \" + \"#&#123;\" + columnEntity.getFieldName() + \"&#125;\"); &#125; StringBuilder sb = new StringBuilder(\"UPDATE \"); sb.append(tableEntity.getTableName()); sb.append(\" SET \"); sb.append(StringUtils.join(updateColumns, \",\")); sb.append(\" WHERE \"); sb.append(tableEntity.getIdColumnEntity().getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + tableEntity.getIdColumnEntity().getFieldName() + \"&#125;\"); sb.append(\" and \"); sb.append(versionColumnEntity.getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + versionColumnEntity.getFieldName() + \"&#125;\"); String sql = sb.toString(); return sql; &#125; /** * 根据id物理删除记录 * @param id * @return */ public String deleteOne(Object id) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); String sql = \"DELETE FROM \" + tableEntity.getTableName() + \" WHERE \" + tableEntity.getIdColumnEntity().getColumnName() + \" = #&#123;id&#125;\"; return sql; &#125; /** * 根据id逻辑删除记录 * @param id * @return */ public String logicDeleteOne(Object id) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); String sql = \"UPDATE \" + tableEntity.getTableName() + \" SET \" + tableEntity.getDeleteColunmEntity().getColumnName() + \" = 0 \" + \"WHERE \" + tableEntity.getIdColumnEntity().getColumnName() + \" = #&#123;id&#125;\"; return sql; &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Markdown语法","slug":"backend/Markdown语法","date":"2018-10-31T17:07:12.000Z","updated":"2019-05-26T02:51:32.294Z","comments":true,"path":"2018/11/01/backend/Markdown语法/","link":"","permalink":"http://www.songshuiyang.site/2018/11/01/backend/Markdown语法/","excerpt":"","text":"图片1![logo](/images/server/mybatis/mybatis-framework.png) logo 表格:123| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 | a b c 居中 左对齐 右对齐 全部左对齐 123| a | b | c ||:-------|:------------- | :----------|| 左对齐 | 左对齐 | 左对齐 | a b c 左对齐 左对齐 左对齐","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"工具类-guava工具包","slug":"backend/java/utils/工具类-guava工具包","date":"2018-10-31T07:11:12.000Z","updated":"2019-05-04T03:16:45.747Z","comments":true,"path":"2018/10/31/backend/java/utils/工具类-guava工具包/","link":"","permalink":"http://www.songshuiyang.site/2018/10/31/backend/java/utils/工具类-guava工具包/","excerpt":"","text":"驼峰字符和下划线字符相互转换工具类导入Maven12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt;&lt;/dependency&gt; 示例：12345678910111213141516import org.junit.Test;import com.google.common.base.CaseFormat;public class GuavaTester &#123; @Test public void test() &#123; System.out.println(CaseFormat.LOWER_HYPHEN.to(CaseFormat.LOWER_CAMEL, \"test-data\"));//testData System.out.println(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, \"test_data\"));//testData System.out.println(CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, \"test_data\"));//TestData System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, \"testdata\"));//testdata System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, \"TestData\"));//test_data System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, \"testData\"));//test-data &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"SpringBoot Maven中parent问题","slug":"backend/framework/spring/spring-cloud/SpringBootMaven中parent问题","date":"2018-10-30T08:07:12.000Z","updated":"2018-10-31T13:59:45.129Z","comments":true,"path":"2018/10/30/backend/framework/spring/spring-cloud/SpringBootMaven中parent问题/","link":"","permalink":"http://www.songshuiyang.site/2018/10/30/backend/framework/spring/spring-cloud/SpringBootMaven中parent问题/","excerpt":"","text":"集成Spring boot时，官方示例中，都是让我们继承一个spring的 spring-boot-starter-parent 这个parent： 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 但是，一般情况下，在我们自己的项目中，会定义一下自己的 parent 项目，这种情况下，上面的这种做法就行不通了。那么，该如何来做呢？其实，在spring的官网也给出了变通的方法的，在我们自己 parent 项目中，加下下面的声明： 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 请注意，它的 type 是 pom，scope 是 import，这种类型的 dependency 只能在 dependencyManagement 标签中声明，然后，把我们项目中的 子项目 中，parent 的声明，修改为我们自己项目的 parent 项目就可以了，比如，我的是：12345&lt;parent&gt; &lt;groupId&gt;com.songsy&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 详见： http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-maven-without-a-parent参考： https://blog.csdn.net/rainbow702/article/details/55046298","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"网关服务Zuul","slug":"backend/framework/spring/spring-cloud/网关服务Zuul","date":"2018-10-23T12:07:12.000Z","updated":"2018-10-23T13:25:14.276Z","comments":true,"path":"2018/10/23/backend/framework/spring/spring-cloud/网关服务Zuul/","link":"","permalink":"http://www.songshuiyang.site/2018/10/23/backend/framework/spring/spring-cloud/网关服务Zuul/","excerpt":"","text":"Zuul 简介Zuul是什么 Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器 为什么要用Zuul在分布式架构中，对外提供的服务，在无网关的情况下，API接口直接暴露给服务调用方，当调用方增多，不同业务调用方各不相同，势必需要添加定制化访问权限、校验等逻辑。当添加API网关后，再第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。Zuul就是提供负载均衡、反向代理、权限认证的这么一个API gateway。 微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关 logo Zuul 提供什么功能Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能： 身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求 审查与监控： 动态路由：动态将请求路由到不同后端集群 压力测试：逐渐增加指向集群的流量，以了解性能 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求 静态响应处理：边缘位置进行响应，避免转发到内部集群 多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化 Spring Cloud对Zuul进行了整合和增强。目前，Zuul使用的默认是Apache的HTTP Client，也可以使用Rest Client，可以设置ribbon.restclient.enabled=true. 简单示例 路由配置 application.yml12345678910111213141516171819202122server: port: 9001spring: application: name: zuul-gatewayeureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9011/eureka/zuul: routes: baidu-url: #传统路由方式 path: /baidu/** url: http://www.baidu.com/ provider: #面向服务的路由 path: /provider/** serviceId: eureka-provider consumer: #面向服务的路由 path: /consumer/** serviceId: eureka-consumer 请求过滤 AccessFilter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 请求过滤 * @author songshuiyang * @date 2018/10/23 20:50 */public class AccessFilter extends ZuulFilter&#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 定义过滤器的类型，决定过滤器在请求的那个生命周期中执行 * @return */ @Override public String filterType() &#123; // 代表会在请求被路由之前被执行 return \"pre\"; &#125; /** * 定义过滤器的顺序 * @return */ @Override public int filterOrder() &#123; return 0; &#125; /** * 判断过滤器是否需要被执行 * @return */ @Override public boolean shouldFilter() &#123; return false; &#125; /** * 过滤器的具体实现 * @return */ @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); logger.info(\"send &#123;&#125; request to &#123;&#125;\", request.getMethod(), request.getRequestURL().toString()); Object accessToken = request.getParameter(\"accessToken\"); if (accessToken == null) &#123; logger.error(\"access check failed\"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); return null; &#125; logger.error(\"access check passs\"); return null; &#125;&#125;Zuul的过滤器之间没有直接的相互通信，他们之间通过一个RequestContext的静态类来进行数据传递的。RequestContext类中有ThreadLocal变量来记录每个Request所需要传递的数据。Zuul的过滤器是由Groovy写成，这些过滤器文件被放在Zuul Server上的特定目录下面，Zuul会定期轮询这些目录，修改过的过滤器会动态的加载到Zuul Server中以便过滤请求使用。下面有几种标准的过滤器类型：Zuul大部分功能都是通过过滤器来实现的。Zuul中定义了四种标准过滤器类型，这些过滤器类型对应于请求的典型生命周期。(1) PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。(2) ROUTING：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。(3) POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。(4) ERROR：在其他阶段发生错误时执行该过滤器。 其他 当我们为Spring Cloud Zuul构建的API网关服务引入Spring Cloud Eureka之后，它会为Eureka中的每个服务都自动创建一个默认路由规则，这些默认规则的path会使用ServiceId配置的服务名作为请求前缀 动态加载动态路由todo 动态过滤器todo","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"注册中心Consul","slug":"backend/framework/spring/spring-cloud/注册中心Consul","date":"2018-10-22T08:07:12.000Z","updated":"2018-10-22T13:00:12.554Z","comments":true,"path":"2018/10/22/backend/framework/spring/spring-cloud/注册中心Consul/","link":"","permalink":"http://www.songshuiyang.site/2018/10/22/backend/framework/spring/spring-cloud/注册中心Consul/","excerpt":"","text":"Consul 介绍 Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较 为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。 Consul 的优势 使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft。 支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持。 支持健康检查。 etcd 不提供此功能。 支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。 官方提供 web 管理界面, etcd 无此功能。 综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究。Consul 角色 client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。 server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 server 数量推荐为 3 个或是 5 个。 Consul 工作原理 logo 1、当 Producer 启动的时候，会向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port 2、Consul 接收到 Producer 的注册后，每隔10s（默认）会向 Producer 发送一个健康检查的请求，检验Producer是否健康 3、当 Consumer 发送 GET 方式请求 /api/address 到 Producer 时，会先从 Consul 中拿到一个存储服务 IP 和 Port 的临时表，从表中拿到 Producer 的 IP 和 Port 后再发送 GET 方式请求 /api/address 4、该临时表每隔10s会更新，只包含有通过了健康检查的 Producer Consul 模式 CLIENT：表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。 SERVER：表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。 SERVER-LEADER：中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。 其它信息：其它信息包括它们之间的通信方式，还有一些协议信息，算法。它们是用于保证节点之间的数据同步，实时性要求等等一系列集群问题的解决。这些有兴趣的自己看看官方文档。 参考：http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"服务容错保护Hystrix","slug":"backend/framework/spring/spring-cloud/服务容错保护Hystrix","date":"2018-10-17T13:07:12.000Z","updated":"2018-10-23T12:17:05.942Z","comments":true,"path":"2018/10/17/backend/framework/spring/spring-cloud/服务容错保护Hystrix/","link":"","permalink":"http://www.songshuiyang.site/2018/10/17/backend/framework/spring/spring-cloud/服务容错保护Hystrix/","excerpt":"","text":"Hystrix 简介Hystrix是什么Hystrix对应的中文名字是“豪猪”，豪猪周身长满了刺，能保护自己不受天敌的伤害，代表了一种防御机制，这与hystrix本身的功能不谋而合，因此Netflix团队将该框架命名为Hystrix，并使用了对应的卡通形象做作为logo。 为什么要使用在一个分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，这个就是Hystrix需要做的事情。 提供哪些功能Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"声明式服务调用Feign","slug":"backend/framework/spring/spring-cloud/声明式服务调用Feign","date":"2018-10-17T13:07:12.000Z","updated":"2018-10-22T14:55:42.724Z","comments":true,"path":"2018/10/17/backend/framework/spring/spring-cloud/声明式服务调用Feign/","link":"","permalink":"http://www.songshuiyang.site/2018/10/17/backend/framework/spring/spring-cloud/声明式服务调用Feign/","excerpt":"","text":"Feign 简介是什么Feign是一个声明式的Web Service客户端，整合了Spring Cloud Ribbon与Spring Cloud Hystrix 为什么要使用 只需创建一个接口并用注解的方式来配置它，即可完成服务提供方的接口绑定 在使用过程中与Spring Mvc完美衔接 整合了Spring Cloud Ribbon，可实现负载均衡，实现服务高可用 整合了Spring Cloud Hystrix，可实现服务断路及服务降级 简单例子 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; PersonService.java 123456789101112131415/** * name 为服务提供者 application-name，fallback 指定服务接口的断路器实现方法，自带Ribbon负债均衡及重试机制 * @author songshuiyang * @date 2018/10/22 21:53 */@FeignClient(name = \"eureka-provider\", fallback = PersonHystrixFallback.class)public interface PersonService &#123; @RequestMapping(\"getPersonName\") String getPersonName(); @RequestMapping(\"getPerson\") Person getPerson();&#125; PersonHystrixFallback.java123456789101112131415161718/** * Hystrix服务降级 每一个服务接口的断路器实现就是实现类中重写函数的实现 * @author songshuiyang * @date 2018/10/22 22:26 */@Componentpublic class PersonHystrixFallback implements PersonService &#123; @Override public String getPersonName() &#123; return \"HystrixFallbackService ERROR\"; &#125; @Override public Person getPerson() &#123; return new Person(0,\"HystrixFallbackService ERROR\",88); &#125;&#125; FeignAppliacation.java 123456789101112/** * @author songshuiyang * @date 2018/10/22 21:50 */@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class FeignAppliacation &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignAppliacation.class,args); &#125;&#125; application.yml 1234567891011121314151617server: port: 9031spring: application: name: feign-consumereureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9011/eureka/ribbon: ConnectTimeout: 500 ReadTimeout: 5000feign: hystrix: enabled: true","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"负载均衡Ribbon","slug":"backend/framework/spring/spring-cloud/负载均衡Ribbon","date":"2018-10-16T14:07:12.000Z","updated":"2019-02-17T04:48:00.787Z","comments":true,"path":"2018/10/16/backend/framework/spring/spring-cloud/负载均衡Ribbon/","link":"","permalink":"http://www.songshuiyang.site/2018/10/16/backend/framework/spring/spring-cloud/负载均衡Ribbon/","excerpt":"","text":"什么是Spring Cloud Ribbon 一个基于HTTP和TCP的客户端负载均衡工具 简单示例1、集成ribbon1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 2、消费方 消费方调用方法12345678910111213141516171819202122@Configuration@RestControllerpublic class DemoController &#123; /** * 主要用来调用REST服务，本身并不具备调用分布式服务的能力，但通过LoadBalanced注解开启客户端负债均衡 * @return */ @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125; @RequestMapping(value = \"/router\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public String router() &#123; RestTemplate restTpl = getRestTemplate(); // 根据应用名称调用服务 String json = restTpl.getForObject(\"http://eureka-provider/person/1\", String.class); return json; &#125;&#125; 消费方配置文件1234567891011server: port: 9050spring: application: name: eureka-consumereureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9020/eureka/ 3、服务方 服务提供方法, 这里就是简单模拟了一下根据personId获取人员信息，并返回对应服务的端口1234567@RequestMapping(value = \"/person/&#123;personId&#125;\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public Person findPerson(@PathVariable(\"personId\") Integer personId, HttpServletRequest request) &#123; Person person = new Person(personId, \"songsy\", 18); person.setName(person.getName() + \"端口：\" + IpConfigurationUtils.getPort()); return person; &#125; 配置文件123456789spring: application: name: eureka-providereureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9020/eureka/ 3.1 服务方1 以9011端口启动123public static void main(String[] args) &#123; new SpringApplicationBuilder(Slave1ProviderApplication.class).properties(\"server.port=9011\").run(args);&#125; 3.2 服务方2 以9023端口启动123public static void main(String[] args) &#123; new SpringApplicationBuilder(Slave1ProviderApplication.class).properties(\"server.port=9023\").run(args);&#125; 4、测试结果连续访问 http://localhost:9050/router 会得到不同的结果， 可以看到已经实现了负载均衡123&#123;\"id\":1,\"name\":\"songsy端口：9023\",\"age\":18&#125;&#123;\"id\":1,\"name\":\"songsy端口：9011\",\"age\":18&#125; 二：RestTemplate 使用 GET 请求 提供 getForObject()、 getForEntity() POST 请求 提供 postForObject()、 postForObject()、postForLocation() PUT 请求 提供 put(), put() 函数没有返回内容 DELETE 请求 提供 delete() 三：源码分析 Ribbon实现客户端负债均衡是通过@LoadBalanced注解来开启的 @LoadBalanced 注解 123456789101112/*** 使用 LoadBalancerClient 该类来配置 * Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient * @author Spencer Gibb */@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Qualifierpublic @interface LoadBalanced &#123;&#125; LoadBalancerClient.java 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Represents a client side load balancer * @author Spencer Gibb */public interface LoadBalancerClient extends ServiceInstanceChooser &#123; /** * 根据挑选出来服务实例执行请求 * execute request using a ServiceInstance from the LoadBalancer for the specified * service * @param serviceId the service id to look up the LoadBalancer * @param request allows implementations to execute pre and post actions such as * incrementing metrics * @return the result of the LoadBalancerRequest callback on the selected * ServiceInstance */ &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException; /** * 根据服务实例执行请求 * execute request using a ServiceInstance from the LoadBalancer for the specified * service * @param serviceId the service id to look up the LoadBalancer * @param serviceInstance the service to execute the request to * @param request allows implementations to execute pre and post actions such as * incrementing metrics * @return the result of the LoadBalancerRequest callback on the selected * ServiceInstance */ &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException; /** * 将 http://myservice/path/to/service 构建一个真实的host:port形式的url * Create a proper URI with a real host and port for systems to utilize. * Some systems use a URI with the logical serivce name as the host, * such as http://myservice/path/to/service. This will replace the * service name with the host:port from the ServiceInstance. * @param instance * @param original a URI with the host as a logical service name * @return a reconstructed URI */ URI reconstructURI(ServiceInstance instance, URI original);&#125; ServiceInstanceChooser.java12345678910public interface ServiceInstanceChooser &#123; /** * 根据传入的服务实例名serviceId，从负债均衡中挑选一个对应服务的实例 * Choose a ServiceInstance from the LoadBalancer for the specified service * @param serviceId the service id to look up the LoadBalancer * @return a ServiceInstance that matches the serviceId */ ServiceInstance choose(String serviceId);&#125; 主要负载均衡策略1、简单轮询负载均衡（RoundRobin）以轮询的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。 2、随机负载均衡 （Random）随机选择状态为UP的Server 3、加权响应时间负载均衡 （WeightedResponseTime）根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。 4、区域感知轮询负载均衡（ZoneAvoidanceRule）复合判断server所在区域的性能和server的可用性选择server","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"服务治理Eureka","slug":"backend/framework/spring/spring-cloud/服务治理Eureka","date":"2018-10-15T14:07:12.000Z","updated":"2018-10-16T14:20:15.267Z","comments":true,"path":"2018/10/15/backend/framework/spring/spring-cloud/服务治理Eureka/","link":"","permalink":"http://www.songshuiyang.site/2018/10/15/backend/framework/spring/spring-cloud/服务治理Eureka/","excerpt":"","text":"Spring Cloud Netflix简介SpringCloud是一个基于SpringBoot实现的云应用开发工具，它为基于JVM的云应用开发中的配置故那里、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了简单的开发方式。 SpringCloud下包含了多个工程，其中的Spring Cloud Netflix提供了一系列搭建微服务基础架构的功能组件。 Netflix的部分组件及功能特性如下： Eureka（服务注册与发现框架）：一个基于REST风格的服务组件，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移 Hystrix（服务容错组件）：容错管理工具，旨在通过控制服务和第三方库的节点，从而对延迟和故障提供强大的容村能力 Zuul（服务网关）：边缘服务工具，提供动态路由、监控、贪心、安全等边缘服务 Ribbon（客户端负载均衡器）：提供客户端负载均衡算法，将Netflix的中间层服务连接起来 Feign（声明式HTTP客户端）：可以创建声明式、模板化的HTTP客户端，进行微服务调用 什么是 EurekaEureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。 https://github.com/songshuiyang/eureka-parent/blob/master/doc/images/eureka1.png 服务发现服务发现就像聊天室一个,每个用户来的时候去服务器上注册,这样他的好友们就能看到你,你同时也将获取好友的上线列表.在微服务中,服务就相当于聊天室的用户,而服务注册中心就像聊天室服务器一样。 目前服务发现的解决方案有Eureka,Consul,Etcd,Zookeeper,SmartStack,等等 Eureka Client通过HTTP(或者TCP,UDP)去Eureka Server册和获取服务列表,为了高可用一般会有多个 Eureka Server组成集群.Eureka会移除那些心跳检查未到达的服务.","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"Springboot构建微服务","slug":"backend/framework/spring/spring-cloud/Springboot构建微服务","date":"2018-10-15T13:07:12.000Z","updated":"2018-10-15T14:19:52.882Z","comments":true,"path":"2018/10/15/backend/framework/spring/spring-cloud/Springboot构建微服务/","link":"","permalink":"http://www.songshuiyang.site/2018/10/15/backend/framework/spring/spring-cloud/Springboot构建微服务/","excerpt":"","text":"什么是Spring-bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程(习惯优于配置)。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 核心功能 独立运行的Spring项目,可以以jar包的形式独立运行, 运行一个Spring boot项目只要通过 java -jar xx.jar 内嵌Tomcat, Jetty, Undertow 无需以war包形式部署项目 提供starter简化Maven配置 自动配置Bean, 极大的减少了我们要使用的配置 优点 快速构建项目 对主流开发框架的无配置集成 项目可独立运行 提供运行时的应用监控 Starter POMs Spring Boot 通过starter依赖为项目的依赖管理提供帮助.starter依赖起始就是特殊的maven依赖,利用了传递依赖解析,把常用库聚合在一起,组成了几个为特定功能而定制的依赖. 所有的starters遵循一个相似的命名模式：spring-boot-starter-，在这里是一种特殊类型的应用程序。eg: 名称 描述 spring-boot-starter 对自动配置、日志记录和YAML支持，核心starter spring-boot-starter-thymeleaf 对Thymeleaf模板引擎的支持，Spring mvc的集成 spring-boot-starter-web 对web支持，包括RESTful，使用tomcat作为默认容器 spring-boot-starter-data-jpa 对jpa支持 不同环境不同配置文件 针对各环境新建不同的配置文件 application-dev.properties、application-test.properties、application-prod.properties , 在这三个文件均都设置不同的server.port属性，如：dev环境设置为8080，test环境设置为9090，prod环境设置为80 application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置 采用命令行的形式 12345执行java -jar xxx.jar，可以观察到服务端口被设置为8080，也就是默认的开发环境（dev）执行java -jar xxx.jar --spring.profiles.active=test，可以观察到服务端口被设置为9090，也就是测试环境的配置（test）执行java -jar xxx.jar --spring.profiles.active=prod，可以观察到服务端口被设置为80，也就是生产环境的配置（prod） 数据文件的加载顺序 在命令行中传入的参数 SPRING_APPLICATION_JSON: 以JSON格式配置在系统环境变量中的内容 java:comp/env 的JNDI属性 Java的系统属性，可以通过System.getProperties() 操作系统的环境变量 通过 random.* 配置的随机属性 位当前jar之外，针对不同{profile}环境的配置文件内容, application-{profile}.yml 位当前jar之内，针对不同{profile}环境的配置文件内容, application-{profile}.yml 位当前jar之外，application.yml 位当前jar之内，application.yml","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"spring-data-jpa","slug":"backend/framework/spring/spring-data/spring-data-jpa","date":"2018-09-10T11:01:44.000Z","updated":"2018-10-15T12:32:16.771Z","comments":true,"path":"2018/09/10/backend/framework/spring/spring-data/spring-data-jpa/","link":"","permalink":"http://www.songshuiyang.site/2018/09/10/backend/framework/spring/spring-data/spring-data-jpa/","excerpt":"","text":"logo logo logo","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"jpa","slug":"jpa","permalink":"http://www.songshuiyang.site/tags/jpa/"}]},{"title":"工具类-BigDecimal","slug":"backend/java/utils/工具类-BigDecimal","date":"2018-09-05T01:24:12.000Z","updated":"2019-05-04T03:16:45.544Z","comments":true,"path":"2018/09/05/backend/java/utils/工具类-BigDecimal/","link":"","permalink":"http://www.songshuiyang.site/2018/09/05/backend/java/utils/工具类-BigDecimal/","excerpt":"","text":"构造函数 参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。 当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。 运算 减乘除其实最终都返回的是一个新的BigDecimal对象，因为BigInteger与BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以a.add(b);虽然做了加法操作，但是a并没有保存加操作后的值，正确的用法应该是a=a.add(b); 精度1234567891011121314151617BigDecimal.setScale() 方法用于格式化小数点setScale(1) 表示保留一位小数，默认用四舍五入方式setScale(1,BigDecimal.ROUND_DOWN) 直接删除多余的小数位，2.31变成2.3、2.35会变成2.3setScale(1,BigDecimal.ROUND_UP) 进位处理，2.31变成2.4 2.35变成2.4 setScale(1,BigDecimal.ROUND_CEILING) 如果为正数，则舍入行为与 ROUND_UP 相同，反之舍入行为与 ROUND_DOWN 相同setScale(1,BigDecimal.ROUND_FLOOR) 如果为正数，则舍入行为与 ROUND_DOWN 相同，反之舍入行为与 ROUND_UP 相同setScale(1,BigDecimal.ROUND_HALF_UP) 四舍五入，2.35变成2.4setScale(1,BigDecimal.ROUND_HALF_DOWN) 四舍五入，2.35变成2.3(如果是5则向下舍)，2.36变成2.4setScale(1,BigDecimal.ROUND_HALF_EVEN) 银行家舍入法 如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同 如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。如 1.15&gt;1.2 1.25&gt;1.2 异常处理foo.divide(bar)); 报异常1java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result。 原因： 1234567891011121314151617原来JAVA中如果用BigDecimal做除法的时候一定要在divide方法中传递第二个参数，定义精确到小数点后几位，否则在不整除的情况下，结果是无限循环小数时，就会抛出以上异常。解决方法：foo.divide(bar, 2, BigDecimal.ROUND_HALF_UP);注意这个divide方法有两个重载的方法，一个是传两个参数的，一个是传三个参数的：两个参数的方法：@param divisor value by which this &#123;@code BigDecimal&#125; is to be divided. 传入除数@param roundingMode rounding mode to apply. 传入round的模式三个参数的方法：@param divisor value by which this &#123;@code BigDecimal&#125; is to be divided. 传入除数@param scale scale of the &#123;@code BigDecimal&#125; quotient to be returned. 传入精度@param roundingMode rounding mode to apply. 传入round的模式","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"在SELECT 的读取锁定主要分为两种方式","slug":"backend/database/在SELECT 的读取锁定主要分为两种方式","date":"2018-08-01T15:15:12.000Z","updated":"2018-08-01T15:42:41.234Z","comments":true,"path":"2018/08/01/backend/database/在SELECT 的读取锁定主要分为两种方式/","link":"","permalink":"http://www.songshuiyang.site/2018/08/01/backend/database/在SELECT 的读取锁定主要分为两种方式/","excerpt":"","text":"在SELECT 的读取锁定主要分为两种方式： SELECT … LOCK IN SHARE MODE SELECT … FOR UPDATE 这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。 而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。 简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT … UPDATE。 悲观锁介绍 悲观锁是对数据被的修改持悲观态度（认为数据在被修改的时候一定会存在并发问题），因此在整个数据处理过程中将数据锁定。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在应用层中实现了加锁机制，也无法保证外部系统不会修改数据）。 使用场景举例商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。如果不采用锁，那么操作方法如下：123456//1.查询出商品信息select status from t_goods where id=1;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2; 上面这种场景在高并发访问的情况下很可能会出现问题。前面已经提到，只有当goods status为1时才能对该商品下单，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步Update操作的时候，有可能出现其他人先一步对商品下单把goods status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。 使用悲观锁来实现在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出goods信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。要使用悲观锁，我们必须关闭mysql数据库的自动提交属性。 123456789101112set autocommit=0; //设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work; 注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。 上面的第一步我们执行了一次查询操作：select status from t_goods where id=1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 注：需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 相同数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。拿上面的实例来说，当我执行select status from t_goods where id=1 for update;后。我在另外的事务中如果再次执行select status from t_goods where id=1 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from t_goods where id=1;则能正常查询出数据，不会受第一个事务的影响。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"db","slug":"db","permalink":"http://www.songshuiyang.site/tags/db/"}]},{"title":"Java基础-null != a 与 a != null 区别","slug":"backend/java/basicKnowledge/Java基础-null判断","date":"2018-08-01T12:09:12.000Z","updated":"2019-05-04T03:16:45.412Z","comments":true,"path":"2018/08/01/backend/java/basicKnowledge/Java基础-null判断/","link":"","permalink":"http://www.songshuiyang.site/2018/08/01/backend/java/basicKnowledge/Java基础-null判断/","excerpt":"","text":"在其他人的项目中经常会看到 null ! = a 这种写法, 但平常使用的是都是 a != null 这种写法 原因：功能上是没有区别的，企业里大多是时候是推荐第一种的，是因为能够防止程序员书写遗漏等号导致错误。比如：null != a 这样少了“！”也会报错。而a ！=null少了”！”就不会报错了。程序员有时候容易把 == 误写为 = ，如果把常量放前面 5 = i ，会编译错误，而写成i=5就不会报错了，所以这样写能发现这种笔误bug。 总结 所以在实际项目中，细节很重要，一个小小的问题有可能导致一系列的问题。 多阅读其他人的代码，借鉴其他人的思想及技巧。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"高可用","slug":"backend/server/JavaEE服务器/高可用","date":"2018-07-31T16:24:12.000Z","updated":"2018-07-31T16:42:07.619Z","comments":true,"path":"2018/08/01/backend/server/JavaEE服务器/高可用/","link":"","permalink":"http://www.songshuiyang.site/2018/08/01/backend/server/JavaEE服务器/高可用/","excerpt":"","text":"一、什么是高可用 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。 假设系统一直能够提供服务，我们说系统的可用性是100%。 如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。 很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。 百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过www.baidu.com 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度最高的褒奖。 如何保障系统的高可用我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。 保证系统高可用，架构设计的核心准则是：冗余。 有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。 接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。 分层高可用架构实践下面的图是常见的互联网分层架构 logo 【客户端层】到【反向代理层】的高可用， 是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。 自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。 【反向代理层-&gt;站点层】的高可用 【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。 自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。 【站点层-&gt;服务层】的高可用 【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。 自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。 【服务层&gt;数据库层】的高可用 大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。 参考： https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959728&amp;idx=1&amp;sn=933227840ec8cdc35d3a33ae3fe97ec5&amp;chksm=bd2d046c8a5a8d7a13551124af36bedf68f7a6e31f6f32828678d2adb108b86b7e08c678f22f&amp;scene=21#wechat_redirect","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java基础-Integer 类型与 int 的==比较","slug":"backend/java/basicKnowledge/Java基础-Integer 类型与 int 的==比较","date":"2018-07-25T03:24:12.000Z","updated":"2019-05-04T03:16:45.625Z","comments":true,"path":"2018/07/25/backend/java/basicKnowledge/Java基础-Integer 类型与 int 的==比较/","link":"","permalink":"http://www.songshuiyang.site/2018/07/25/backend/java/basicKnowledge/Java基础-Integer 类型与 int 的==比较/","excerpt":"","text":"先上题123456789101112131415161718package com.lizi.basic;public class IntegerDemo &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; int c = 3; System.out.println(a == b); System.out.println(a == c); Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 分析思路 基本类型 基本数据类类型存的是数值本身 引用类型 引用类型变量在内存放的是数据的引用 基本类型通过 == 比较的是他们的值大小，而引用类型比较的是他们的引用地址 Integer 用 == 比较的时候往往非常容易出错123456789Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;System.out.println(f1 == f2);System.out.println(f3 == f4);// 当我们给一个Integer赋予一个int类型的时候会调用Integer的静态方法valueOf。Integer f1 = Integer.valueOf(100); Integer f2 = Integer.valueOf(100); Integer f3 = Integer.valueOf(150); Integer f4 = Integer.valueOf(150); 思考：那么Integer.valueOf()返回的Integer是不是是重新new Integer(num);来创建的呢？如果是这样的话，那么== 比较返回都是false，因为他们引用的堆地址不一样 具体来看看Integer.valueOf的源码 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在IntegerCache中cache数组初始化如下，存入了-128 - 127的值1234cache = new Integer[(high - low) + 1];int j = low;for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); 从上面我们可以知道给Interger 赋予的int数值在-128 - 127的时候，直接从cache中获取，这些cache引用对Integer对象地址是不变的，但是不在这个范围内的数字，则new Integer(i) 这个地址是新的地址，不可能一样的 Integer 与 int1234567891011121314Integer a = new Integer(3);Integer b = 3;int c = 3;System.out.println(a == b);System.out.println(a == c);a == b分析Integer b = 3; 自动调用Integer.valueOf(3) 返回一个Integer的对象。 这个对象存放到cache中的而 Integer a = new Integer(3);这里创建了一个新的对象Integer 所以 a == b 返回的是falsea == c 分析一个Integer 与 int比较，先将Integer转换成int类型，再做值比较，所以返回的是true 最后答案1234567891011121314151617public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; int c = 3; System.out.println(a == b); System.out.println(a == c); Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125; false true true false","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"基于 CentOS 搭建 Jenkins 自动化部署服务","slug":"backend/server/centos/基于 CentOS 搭建 Jenkins服务","date":"2018-07-20T12:48:12.000Z","updated":"2018-07-21T04:05:39.268Z","comments":true,"path":"2018/07/20/backend/server/centos/基于 CentOS 搭建 Jenkins服务/","link":"","permalink":"http://www.songshuiyang.site/2018/07/20/backend/server/centos/基于 CentOS 搭建 Jenkins服务/","excerpt":"","text":"需求： 使用 Jenkins 完成 git + Maven项目 + Tomcat 自动化部署 一： 环境准备1. Jenkins环境准备1.1 安装 jenkins-2.7.3123wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpmrpm -ivh jenkins-2.7.3-1.1.noarch.rpm 1.2 配置启动12345678910111213141516171819202122232425262728291. 修改配置文件，默认端口为8080，如果不冲突则不需要修改 vim /etc/sysconfig/jenkins JENKINS_PORT=\"9080\"2. 配置JDK,启动服务如果报Java路径错误, 需要到vim /etc/profile 查看java路径 修改Jenkins启动配置文件，指定java安装路径。 /usr/local/jdk1.8.0_181/bin/java vim /etc/init.d/jenkins 在candidates中第一行添加java路径，如下： candidates=\" /usr/local/jdk1.8.0_181/bin/java /etc/alternatives/java /usr/lib/jvm/java-1.6.0/bin/java /usr/lib/jvm/jre-1.6.0/bin/java /usr/lib/jvm/java-1.7.0/bin/java /usr/lib/jvm/jre-1.7.0/bin/java /usr/lib/jvm/java-1.8.0/bin/java /usr/lib/jvm/jre-1.8.0/bin/java /usr/bin/java \" 3. 修改jenkins用户 为\"root\"用户4. 启动jenkins服务service jenkins restart5. 启动完成之后即可通过ip 端口进行访问 logo 2. Git 环境准备1234567安装git[root@iZwz9fjhnq78zfjphj8hi4Z bin]# yum –y install git查看是否安装成功[root@iZwz9fjhnq78zfjphj8hi4Z bin]# git --versiongit version 1.8.3.1 3. Maven 环境准备3.1 安装1234567cd /usr/localwget http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gztar zxf apache-maven-3.5.4-bin.tar.gzmv apache-maven-3.5.4 /usr/local/maven-3.5.4 3.2 配置环境变量1234567891011vi /etc/profile然后还需要 配置环境变量。#在适当的位置添加export M2_HOME=/usr/local/maven-3.5.4export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/bin保存退出后运行下面的命令使配置生效，或者重启服务器生效。source /etc/profile验证版本mvn -v 3.3 更换库源 阿里maven库123456789101112（1）找到 apache-maven-3.5.2\\conf 目录中的 settings.xml 文件（2）修改maven 本地仓库地址, 首先在D:\\Program Files创建文件夹MavenRepository ； 找到settings.xml 文件中 &lt;localRepository&gt; &lt;/localRepository&gt;打开注释修改如下： &lt;localRepository&gt;D:\\Program Files\\MavenRepository&lt;/localRepository&gt;（3）添加阿里源 ，找到 &lt;mirrors&gt; &lt;/ mirrors&gt;标签，在标签内部 添加内容如下： &lt;mirror&gt; &lt;id&gt;AliMaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 4. 使用Jenkins4.1 配置工具环境配置上面的环境都准备好了之后，先配置一下 参数(系统管理-&gt; 全局工具配置) git不用配置使用默认 logo logo logo 4.2 创建一个任务1.点击创建任务，如果在创建项目时候，没有“创建一个Maven 项目”的选项。你需要安装Maven项目插件：Maven Integration plugin 。 logo 2.配置源码管理，jenkins会自动拉取代码放到/var/lib/jenkins/workspace/任务名 路径下 logo 3.配置Maven构建，构建完后会自动打包 logo 4.编写shell脚本，maven构建完成之后就是把打好的包放在tomcat下了并启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#!/bin/bash#引入了系统环境变量，这样系统环境变量里面没有export声明的也可以用source /etc/profiletomcat_home=/usr/local/tomcat-8.0.48SHUTDOWN=$tomcat_home/bin/shutdown.shSTARTTOMCAT=$tomcat_home/bin/startup.shecho \"停止tomcat服务 /usr/local/tomcat8.0.48/bin/shutdown.sh\"#/usr/local/tomcat8.0.48/bin/shutdown.shecho \"关闭$tomcat_home\"$SHUTDOWNpidlist=`ps -ef |grep tomcat |grep -v \"grep\"|awk '&#123;print $2&#125;'`kill -9 $pidlistecho \"开始删除文件夹 usr/local/tomcat8.0.48/webapps/blogsys-parent\"rm -rf $tomcat_home/webapps/blogsys-parentecho \"开始删除文件 /usr/local/tomcat8.0.48/webapps/blogsys-parent.war\"rm -rf $tomcat_home/webapps/blogsys-parent.warecho \"开始拷贝文件 blogsys-parent.war 拷贝文件目录：/var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target &gt;&gt; /usr/local/tomcat8.0.48/webapps\"cp -ar /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target/blogsys-parent.war $tomcat_home/webapps/blogsys-parent.warecho \"查找文件\"find $tomcat_home/webapps/ -name blogsys-parent.warecho \"启动$tomcat_home\"$STARTTOMCATecho \"延时5秒\"sleep 5echo \"关闭$tomcat_home\"$SHUTDOWNpidlist=`ps -ef |grep tomcat |grep -v \"grep\"|awk '&#123;print $2&#125;'`kill -9 $pidlistecho \"延时5秒重新启动\"sleep 5# 脚本中功能是复制替换某两个配置文件，然后关闭tomcat，重启Tomcat。但是，Tomcat只是启动了一下，就关闭了，并没有启动Tomcat的进程。在网上查了资料，需要在执行脚本之前加入：export BUILD_ID=XXXXXXexport BUILD_ID=dontKillMeecho \"启动$tomcat_home\"$STARTTOMCATecho \"延时10秒\"sleep 10echo \"打印日志开始-》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》\"tail -2000 $&#123;tomcat_home&#125;/logs/catalina.out``` ##### 启动任务可以看到日志输出```bashStarted by user songshuiyangBuilding in workspace /var/lib/jenkins/workspace/blogsys-parent &gt; git rev-parse --is-inside-work-tree # timeout=10Fetching changes from the remote Git repository &gt; git config remote.origin.url https://gitee.com/songshuiyang/blogsys-parent.git # timeout=10Fetching upstream changes from https://gitee.com/songshuiyang/blogsys-parent.git &gt; git --version # timeout=10using GIT_ASKPASS to set credentials 码云账号 &gt; git fetch --tags --progress https://gitee.com/songshuiyang/blogsys-parent.git +refs/heads/*:refs/remotes/origin/* &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10 &gt; git rev-parse refs/remotes/origin/origin/master^&#123;commit&#125; # timeout=10Checking out Revision 926c54ff215417d928b32201b50e2c2cb40b6ba8 (refs/remotes/origin/master) &gt; git config core.sparsecheckout # timeout=10 &gt; git checkout -f 926c54ff215417d928b32201b50e2c2cb40b6ba8Commit message: \"优化 修复pom问题\" &gt; git rev-list --no-walk 926c54ff215417d928b32201b50e2c2cb40b6ba8 # timeout=10Parsing POMsEstablished TCP socket on 40447[blogsys-parent] $ /usr/local/jdk1.8.0_181/bin/java -cp /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven35-agent-1.12-alpha-1.jar:/usr/local/maven-3.5.4/boot/plexus-classworlds-2.5.2.jar:/usr/local/maven-3.5.4/conf/logging jenkins.maven3.agent.Maven35Main /usr/local/maven-3.5.4 /var/cache/jenkins/war/WEB-INF/lib/remoting-3.23.jar /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven35-interceptor-1.12-alpha-1.jar /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven3-interceptor-commons-1.12-alpha-1.jar 40447&lt;===[JENKINS REMOTING CAPACITY]===&gt;channel startedExecuting Maven: -B -f /var/lib/jenkins/workspace/blogsys-parent/pom.xml clean install -Dmaven.test.skip=true[INFO] Scanning for projects...[WARNING] [WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-admin:war:0.0.1-SNAPSHOT[WARNING] 'dependencies.dependency.systemPath' for json:json:jar should not point at files within the project directory, $&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib/json.jar will be unresolvable by dependent projects @ line 25, column 19[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: com.fasterxml.jackson.core:jackson-databind:jar -&gt; version $&#123;jackson-databind.version&#125; vs 2.7.4 @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 244, column 21[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 383, column 21[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 407, column 21[WARNING] [WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-core:jar:0.0.1-SNAPSHOT[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 383, column 21[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 407, column 21[WARNING] [WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-parent:pom:0.0.1-SNAPSHOT[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: com.fasterxml.jackson.core:jackson-databind:jar -&gt; version $&#123;jackson-databind.version&#125; vs 2.7.4 @ line 244, column 21[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ line 383, column 21[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ line 407, column 21[WARNING] [WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.[WARNING] [WARNING] For this reason, future Maven versions might no longer support building such malformed projects.[WARNING] [INFO] ------------------------------------------------------------------------[INFO] Reactor Build Order:[INFO] [INFO] blogsys-parent [pom][INFO] blogsys-admin [war][INFO] blogsys-core [jar][INFO] [INFO] ----------------------&lt; com.ecut:blogsys-parent &gt;-----------------------[INFO] Building blogsys-parent 0.0.1-SNAPSHOT [1/3][INFO] --------------------------------[ pom ]---------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ blogsys-parent ---[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ blogsys-parent ---[INFO] Installing /var/lib/jenkins/workspace/blogsys-parent/pom.xml to /root/.m2/repository/com/ecut/blogsys-parent/0.0.1-SNAPSHOT/blogsys-parent-0.0.1-SNAPSHOT.pom[WARNING] Attempt to (de-)serialize anonymous class hudson.maven.reporters.MavenArtifactArchiver$2; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/[WARNING] Attempt to (de-)serialize anonymous class hudson.maven.reporters.MavenFingerprinter$1; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/[INFO] [INFO] -----------------------&lt; com.ecut:blogsys-admin &gt;-----------------------[INFO] Building blogsys-admin 0.0.1-SNAPSHOT [2/3][INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ blogsys-admin ---[INFO] Deleting /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ blogsys-admin ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Copying 32 resources[INFO] [INFO] --- maven-compiler-plugin:2.3.2:compile (default-compile) @ blogsys-admin ---[INFO] Compiling 164 source files to /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target/classes[WARNING] /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/src/main/java/com/ecut/core/shiro/SecurityUtils.java:[8,15] BASE64Encoder is internal proprietary API and may be removed in a future release[WARNING] /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/src/main/java/com/ecut/core/utils/elven/encryption/DesEncryptUtils.java:[8,15] BASE64Decoder is internal proprietary API and may be removed in a future release.....","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.songshuiyang.site/tags/jenkins/"}]},{"title":"Java集合-HashSet","slug":"backend/java/collection/Java集合-HashSet","date":"2018-07-08T06:24:12.000Z","updated":"2019-05-04T03:16:45.473Z","comments":true,"path":"2018/07/08/backend/java/collection/Java集合-HashSet/","link":"","permalink":"http://www.songshuiyang.site/2018/07/08/backend/java/collection/Java集合-HashSet/","excerpt":"","text":"HashSet源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; static final long serialVersionUID = -5024744406713321676L; // 底层使用HashMap来保存HashSet中所有元素。 private transient HashMap&lt;E,Object&gt; map; // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。 private static final Object PRESENT = new Object(); /** * 默认的无参构造器，构造一个空的HashSet。 * * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 */ public HashSet() &#123; map = new HashMap&lt;E,Object&gt;(); &#125; /** * 构造一个包含指定collection中的元素的新set。 * * 实际底层使用默认的加载因子0.75和足以包含指定 * collection中所有元素的初始容量来创建一个HashMap。 * @param c 其中的元素将存放在此set中的collection。 */ public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; /** * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 * * 实际底层以相应的参数构造一个空的HashMap。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 */ public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 以指定的initialCapacity构造一个空的HashSet。 * * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 * @param initialCapacity 初始容量。 */ public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; /** * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 * * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 * @param dummy 标记。 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 * * 底层实际调用底层HashMap的keySet来返回所有的key。 * 可见HashSet中的元素，只是存放在了底层HashMap的key上， * value使用一个static final的Object对象标识。 * @return 对此set中元素进行迭代的Iterator。 */ public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; /** * 返回此set中的元素的数量（set的容量）。 * * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 * @return 此set中的元素的数量（set的容量）。 */ public int size() &#123; return map.size(); &#125; /** * 如果此set不包含任何元素，则返回true。 * * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 * @return 如果此set不包含任何元素，则返回true。 */ public boolean isEmpty() &#123; return map.isEmpty(); &#125; /** * 如果此set包含指定元素，则返回true。 * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) * 的e元素时，返回true。 * * 底层实际调用HashMap的containsKey判断是否包含指定key。 * @param o 在此set中的存在已得到测试的元素。 * @return 如果此set包含指定元素，则返回true。 */ public boolean contains(Object o) &#123; return map.containsKey(o); &#125; /** * 如果此set中尚未包含指定元素，则添加指定元素。 * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) * 的元素e2，则向此set 添加指定的元素e。 * 如果此set已包含该元素，则该调用不更改set并返回false。 * * 底层实际将将该元素作为key放入HashMap。 * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 * @param e 将添加到此set中的元素。 * @return 如果此set尚未包含指定元素，则返回true。 */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; /** * 如果指定元素存在于此set中，则将其移除。 * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， * 则将其移除。如果此set已包含该元素，则返回true * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 * * 底层实际调用HashMap的remove方法删除指定Entry。 * @param o 如果存在于此set中则需要将其移除的对象。 * @return 如果set包含指定元素，则返回true。 */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; /** * 从此set中移除所有元素。此调用返回后，该set将为空。 * * 底层实际调用HashMap的clear方法清空Entry中所有元素。 */ public void clear() &#123; map.clear(); &#125; /** * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 * HashSet保证元素不重复HashSet使用HashMap进行存放数据123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 重新计算一下大小 // 获取要插入元素在 哈希桶中的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果这个位置没有Node tab[i] = newNode(hash, key, value, null); // 直接创建一个新的Node else &#123; // 说明此时在对应的索引位置已经有对象了 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断原对象与插入的对象的key是否一样 else if (p instanceof TreeNode) // 如果 你定位到的元素是一个TreeNode(Node的一个子类，也是HashMap的一个内部类) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 那么就插入一TreeNode节点 定位到这个hash桶了 但是这里面是链表（没有进行过树化） else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; //说明原对象与插入的对象的key相同 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //将新插入的entry的value覆盖掉原来的entry的value afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 修改次数+1 和fastRemove()有关也和并发修改有关 if (++size &gt; threshold) // 如果大于了阙值 需要扩容的大小 resize(); // 重新设置hash桶的大小，也有可能进行树化，见后面代码 afterNodeInsertion(evict); return null;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java集合-HashMap","slug":"backend/java/collection/Java集合-HashMap","date":"2018-06-07T11:21:12.000Z","updated":"2019-05-04T03:16:45.301Z","comments":true,"path":"2018/06/07/backend/java/collection/Java集合-HashMap/","link":"","permalink":"http://www.songshuiyang.site/2018/06/07/backend/java/collection/Java集合-HashMap/","excerpt":"","text":"什么是HashMapHashMap分为俩个词理解，一个是Hash，另一个是Map Hash: 散列将一个任意长度通过某种hash函数算法转化成一个固定的值 Map：可以理解为地图点的位置 我们如果想要找到地图上的某个点，就需要通过经纬度来定位，Hash就是这个值，我们可以通过这个值，找到我们所要的位置 HashMap 简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap源码笔记HashMap 常量定义12345678910111213141516171819202122232425262728293031323334353637383940414243/** * The default initial capacity - MUST be a power of two. * 默认初始容量，为16个 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. * 最大容量： 1073741824 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The load factor used when none specified in constructor. * 加载因子，当容量达到3/4的时候进行容量扩容, 不是满的时候再扩容 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * .由链表转换成树的阈值TREEIFY_THRESHOLD 一个桶中bin（箱子）的存储方式由链表转换成树的阈值。即当桶中bin的数量超过TREEIFY_THRESHOLD时使用树来代替链表。默认值是8 */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * 当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 */ static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * 当桶中的bin被树化时最小的hash表容量。（如果没有达到这个阈值，即hash表容量小于MIN_TREEIFY_CAPACITY，当桶中bin的数量太多时会执行resize扩容操作）这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。 */static final int MIN_TREEIFY_CAPACITY = 64; putVal方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 重新计算一下大小 // 获取要插入元素在 哈希桶中的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果这个位置没有Node tab[i] = newNode(hash, key, value, null); // 直接创建一个新的Node else &#123; // 说明此时在对应的索引位置已经有对象了 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断原对象与插入的对象的key是否一样 else if (p instanceof TreeNode) // 如果 你定位到的元素是一个TreeNode(Node的一个子类，也是HashMap的一个内部类) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 那么就插入一TreeNode节点 定位到这个hash桶了 但是这里面是链表（没有进行过树化） else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; //说明原对象与插入的对象的key相同 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //将新插入的entry的value覆盖掉原来的entry的value afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 修改次数+1 和fastRemove()有关也和并发修改有关 if (++size &gt; threshold) // 如果大于了阙值 需要扩容的大小 resize(); // 重新设置hash桶的大小，也有可能进行树化，见后面代码 afterNodeInsertion(evict); return null;&#125; Java中的hashCode和equals关于hashCode hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里“ 再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。 以下对hashCode的解读摘自其他博客：123456789101.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有例如内存中有这样的位置0 1 2 3 4 5 6 7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。但如果用hashcode那就会使效率提高很多。我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。那么。重写了equals()，为什么还要重写hashCode()呢？想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 关于equalsequals和== ==用于比较引用和比较基本数据类型时具有不同的功能：比较基本数据类型，如果两个值相同，则结果为true而在比较引用时，如果引用指向内存中的同一对象，结果为true; equals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。 HashMap的实现原理HashMap概述HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 logo 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 logo 其中Java源码如下：12345678910111213/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; ……&#125; 可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。 HashMap实现存储和读取存储1234567891011121314151617181920212223242526public V put(K key, V value) &#123; // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; // 如果发现已有该键值，则存储新的值，并返回原始值 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null;&#125; 根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。 根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。 通过这种方式就可以高效的解决HashMap的冲突问题。 读取12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 HashMap的resize当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.751000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 总结 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。 转载参考：http://www.cnblogs.com/yuanblog/p/4441017.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Nginx 笔记","slug":"backend/server/centos/Nginx 笔记","date":"2018-06-05T13:48:12.000Z","updated":"2018-06-06T13:06:57.964Z","comments":true,"path":"2018/06/05/backend/server/centos/Nginx 笔记/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/server/centos/Nginx 笔记/","excerpt":"","text":"一. 为什么使用NginxNginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性: 作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型. 作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。 Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。基础功能 二. 基础功能 处理静态文件，索引文件以及自动索引； 反向代理加速(无缓存)，简单的负载均衡和容错； FastCGI，简单的负载均衡和容错； 模块化的结构。过滤器包括gzipping, byte ranges, chunked responses, 以及 SSI-filter 。在SSI过滤器中，到同一个 proxy 或者 FastCGI 的多个子请求并发处理；SSL 和 TLS SNI 支持；","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.songshuiyang.site/tags/nginx/"}]},{"title":"基于 CentOS 搭建 Nginx 服务","slug":"backend/server/centos/基于 CentOS 搭建 Nginx服务","date":"2018-06-05T13:48:12.000Z","updated":"2018-06-06T13:06:57.969Z","comments":true,"path":"2018/06/05/backend/server/centos/基于 CentOS 搭建 Nginx服务/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/server/centos/基于 CentOS 搭建 Nginx服务/","excerpt":"1.安装使用Nginx1.1 yum安装1yum install nginx 1.2 提供目录权限12345678提供目录权限: 我需要访问的目录是 /var/ftp, 用户是root, 所以修改如下配置:[root@S205 conf.d]# cat /etc/nginx/nginx.conf |grep useruser root;否则会出现这样的错误:[root@S205 conf.d]# tail /var/log/nginx/error.log 2017/10/13 16:51:09 [error] 13383#0: *1 open() \"/home/data\" failed (13: Permission denied), client: 192.168.50.20, server: _, request: \"GET /data HTTP/1.1\", host: \"192.168.10.205:8080\"","text":"1.安装使用Nginx1.1 yum安装1yum install nginx 1.2 提供目录权限12345678提供目录权限: 我需要访问的目录是 /var/ftp, 用户是root, 所以修改如下配置:[root@S205 conf.d]# cat /etc/nginx/nginx.conf |grep useruser root;否则会出现这样的错误:[root@S205 conf.d]# tail /var/log/nginx/error.log 2017/10/13 16:51:09 [error] 13383#0: *1 open() \"/home/data\" failed (13: Permission denied), client: 192.168.50.20, server: _, request: \"GET /data HTTP/1.1\", host: \"192.168.10.205:8080\" 2.Nginx 命令2.1 启动重启123456[root@S205 conf.d]# systemctl enable nginx[root@S205 conf.d]# systemctl restart nginx[root@S205 conf.d]# vi /etc/nginx/nginx.conf 2.23.Nginx 启用对文件目录的http访问解决以ftp路径形式的图片，在谷歌浏览器上不能正常访问的问题，所以使用http的形式访问文件 3.1 配置如下：采用： http://ip/uploadfile/文件路径的形式访问 或者 直接 http://ip/文件路径的形式访问12345678910111213141516171819202122232425262728server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/ftp/pub; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; autoindex on; autoindex_localtime on; &#125; location /uploadfile &#123; alias /var/ftp/pub; autoindex on; autoindex_localtime on; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 3.2 autoindex 和 autoindex_localtime 生成目录索引1234autoindex on; #自动显示目录autoindex_exact_size off; #改为off后，显示出文件的大概大小，单位是kB或者MB或者GB；即人性化方式显示文件大小否则以byte显示autoindex_localtime on; #显示的文件时间为文件的服务器时间；即按服务器时间显示limit_rate_after 10m; #10m之后下载速度为10k 参考:http://blog.licess.com/nginx-autoindex/ 3.2 解决目录列表文件名乱码问题12345678910111213141516171819202122232425262728vi /etc/nginx/nginx.conf 加上 charset utf-8,gbk即可解决;user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8,gbk;&#125; 4.Nginx 配置反向代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#user nobody;worker_processes 1;#error_log logs/error.log;error_log logs/error.log notice;#error_log logs/error.log info;#error_log /usr/local/etcinx/logs/error.log warn;#pid logsinx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; #tcp_nopush on; #keepalive_timeout 0; sendfile on; keepalive_timeout 65; gzip on; gzip_min_length 1k; gzip_comp_level 3; gzip_buffers 4 16k; gzip_vary on; server &#123; listen 80; server_name localhost 192.168.0.252 songshuiyang.com; location / &#123; proxy_pass http://127.0.0.1:4080; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 100m; &#125; location /uploadfile &#123; alias /var/ftp/pub ; &#125; location /webapp &#123; proxy_pass http://127.0.0.1:8068; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location /admin-webapp &#123; alias html/test-admin-webapp; &#125; location = /favicon.ico &#123; alias /var/ftp/pub/favicon.ico; &#125; &#125;&#125;# include servers/*; 5.Nginx 简单的负载均衡的示例12345678910111213141516http &#123; upstream myproject &#123; server 127.0.0.1:8000 weight=3; server 127.0.0.1:8001; server 127.0.0.1:8002; server 127.0.0.1:8003;&#125;server &#123; listen 80; server_name www.domain.com; location / &#123; proxy_pass http://myproject; &#125; &#125;&#125; 本文参考： http://www.bubuko.com/infodetail-2349571.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.songshuiyang.site/tags/nginx/"}]},{"title":"Shiro记事","slug":"backend/framework/Shiro/Shiro记事","date":"2018-06-05T12:48:12.000Z","updated":"2018-06-06T13:06:57.950Z","comments":true,"path":"2018/06/05/backend/framework/Shiro/Shiro记事/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/framework/Shiro/Shiro记事/","excerpt":"","text":"Shiro内置了默认的拦截器配置Shiro使得多个角色可以访问同一URL在Shiro配置中，如果对某一URL作如下配置： /a.jsp = roles[&quot;role1, role2&quot;] 其效果等效于hasAllRoles，即要求所有角色都满足才可访问。 但在实际中，可能只需满足任一角色即可访问。在这种情况下，需要自己重载RolesAuthorizationFilter的isAccessAllowed，实现或的关系。具体实现如下：123456789101112131415161718192021222324252627import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class AnyOfRolesAuthorizationFilter extends RolesAuthorizationFilter &#123; @Override public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException &#123; final Subject subject = getSubject(request, response); final String[] rolesArray = (String[]) mappedValue; if (rolesArray == null || rolesArray.length == 0) &#123; //no roles specified, so nothing to check - allow access. return true; &#125; for (String roleName : rolesArray) &#123; if (subject.hasRole(roleName)) &#123; return true; &#125; &#125; return false; &#125;&#125; 相应地，在INI文件中作如下配置：123456[main]...anyofroles = com.your.package.AnyOfRolesAuthorizationFilter[urls].../path/to/some/url = anyofroles[\"role1,role2\"]","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"http://www.songshuiyang.site/tags/shiro/"}]},{"title":"基于 CentOS 搭建 FTP 文件服务","slug":"backend/server/centos/基于 CentOS 搭建 FTP 文件服务","date":"2018-06-05T12:48:12.000Z","updated":"2018-06-06T13:06:57.967Z","comments":true,"path":"2018/06/05/backend/server/centos/基于 CentOS 搭建 FTP 文件服务/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/server/centos/基于 CentOS 搭建 FTP 文件服务/","excerpt":"1.安装并启动 FTP 服务1.1 使用 yum 安装 vsftpd12# yum默认都是安装最新版的软件yum install -y vsftpd 1.2 启动 vsftpd1234567安装完成后，启动 FTP 服务：service vsftpd start启动后，可以看到系统已经监听了 21 端口：netstat -nltp | grep 21此时，访问 ftp://主机ip 可浏览机器上的 /var/ftp目录了。","text":"1.安装并启动 FTP 服务1.1 使用 yum 安装 vsftpd12# yum默认都是安装最新版的软件yum install -y vsftpd 1.2 启动 vsftpd1234567安装完成后，启动 FTP 服务：service vsftpd start启动后，可以看到系统已经监听了 21 端口：netstat -nltp | grep 21此时，访问 ftp://主机ip 可浏览机器上的 /var/ftp目录了。 2.配置 FTP 权限2.1 了解 VSFTP 配置12345vsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件：vsftpd.conf 为主要配置文件ftpusers 配置禁止访问 FTP 服务器的用户列表user_list 配置用户访问控制 2.1 创建 FTP 用户1234创建一个用户 ftpuseruseradd ftpuser为用户 ftpuser 设置密码echo \"password\" | passwd ftpuser --stdin 2.2 限制该用户仅能通过 FTP 访问12限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：usermod -s /sbin/nologin ftpuser 命令笔记:123456789101112用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的crontab档。也需手动更改使用者的at工作档。采用NIS server须在server上更动相关的NIS设定。-c&lt;备注&gt;：修改用户帐号的备注文字；-d&lt;登入目录&gt;：修改用户登入时的目录；-e&lt;有效期限&gt;：修改帐号的有效期限；-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号；-g&lt;群组&gt;：修改用户所属的群组；-G&lt;群组&gt;；修改用户所属的附加群组；-l&lt;帐号名称&gt;：修改用户帐号名称；-L：锁定用户密码，使密码无效；-s&lt;shell&gt;：修改用户登入后所使用的shell；-u&lt;uid&gt;：修改用户ID；-U:解除密码锁定。 2.3 创建登录欢迎文件1echo \"Welcome to use FTP service.\" &gt; /var/ftp/welcome.txt 2.4 配置权限12345设置访问权限chmod a-w /var/ftp &amp;&amp; chmod 777 -R /var/ftp/pub设置为用户的主目录：usermod -d /var/ftp ftpuser 命令笔记:123456789101112131415161718192021222324252627282930313233343536权限范围的表示法如下：u User，即文件或目录的拥有者；g Group，即文件或目录的所属群组；o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；a All，即全部的用户，包含拥有者，所属群组以及其他用户；r 读取权限，数字代号为“4”;w 写入权限，数字代号为“2”；x 执行或切换权限，数字代号为“1”；- 不具任何权限，数字代号为“0”；s 特殊功能说明：变更文件或目录的权限。-c或——changes：效果类似“-v”参数，但仅回报更改的部分；-f或--quiet或——silent：不显示错误信息；-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；-v或——verbose：显示指令执行过程；--reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；&lt;权限范围&gt;+&lt;权限设置&gt;：开启权限范围的文件或目录的该选项权限设置；&lt;权限范围&gt;-&lt;权限设置&gt;：关闭权限范围的文件或目录的该选项权限设置；&lt;权限范围&gt;=&lt;权限设置&gt;：指定权限范围的文件或目录的该选项权限设置；Linux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內！例：rwx rw- r--r=读取属性 //值＝4w=写入属性 //值＝2x=执行属性 //值＝1chmod u+x,g+w f01 //为文件f01设置自己可以执行，组员可以写入的权限chmod u=rwx,g=rw,o=r f01chmod 764 f01chmod a+x f01 //对文件f01的u,g,o都设置可执行属性文件的属主和属组属性设置chown user:market f01 //把文件f01给uesr，添加到market组ll -d f1 查看目录f1的属性 2.5 备注一： 以上配置是匿名用户可以通过ftp://主机ip 即可访问文件，但不能上传文件，所以需要添加一个ftpuser用户ftp上传操作，这样做有俩个好处 访问文件可以通过一个ftp绝对路径访问(也可以通过nginx代理通过http的形式访问)，不需要输入用户名及密码 上传修改文件只能通过该(ftpuser)用户才能进行操作，保证了其安全性 二： 阻止匿名访问和切换根目录1234567891011匿名访问和切换根目录都会给服务器带来安全风险，我们把这两个功能关闭。编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：vi /etc/vsftpd/vsftpd.conf # 禁用匿名用户 12 YES 改为NOanonymous_enable=NO# 禁止切换根目录 101 行 删除#chroot_local_user=YES编辑完成后保存配置，重新启动 FTP 服务service vsftpd restart 本文参考： https://www.baidu.com/link?url=3FcSvP44zFbo33EoJBucNlE1ZKKkncTuckfxuvNFJhCPvQuZmlebtZRzRAW3-W0SH8Ep8dShtJ8NSjWlozkrPa&amp;wd=&amp;eqid=edc2684700001d70000000065b17479b","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"http://www.songshuiyang.site/tags/ftp/"}]},{"title":"使用微软提供的Office Online实现Office文档的在线查看,编辑等功能","slug":"backend/other/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能","date":"2018-05-08T12:54:12.000Z","updated":"2018-05-08T15:07:08.195Z","comments":true,"path":"2018/05/08/backend/other/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能/","link":"","permalink":"http://www.songshuiyang.site/2018/05/08/backend/other/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能/","excerpt":"","text":"使用微软提供的Office Online实现Office文档的在线查看,编辑使用微软提供的Office Online平台只需要一个网址即可在线查看Xls,doc,PPT等文档 在线预览http://view.officeapps.live.com/op/view.aspx?src=要查看的文档地址 在线编辑在线编辑需要登录https://www.office.com并从onedrive中打开或新建文档也可以来自在线模板(下面的Excel来自Excel Online模板，编辑后的文件会保存到你的onedrive中)在线编辑Xls文档(部分功能不支持,但已经够用)","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"freemaker模板框架","slug":"backend/framework/freemarker/freemaker模板框架","date":"2018-04-14T15:35:12.000Z","updated":"2018-04-14T15:46:52.508Z","comments":true,"path":"2018/04/14/backend/framework/freemarker/freemaker模板框架/","link":"","permalink":"http://www.songshuiyang.site/2018/04/14/backend/framework/freemarker/freemaker模板框架/","excerpt":"","text":"freemaker 语法笔记 if 条件 1234567&lt;#if entity.columnName == 'id' &gt; &lt;#elseif entity.columnName == 'id' &gt; &lt;#else&gt; &lt;/#if&gt; list 遍历元素 12345678910111213141516171819202122232425262728293031323334353637383940414243441. 遍历要想在Freemarker中遍历list,必须通过使用list指令,即&lt;#list sequence as item&gt;…&lt;/#list&gt;sequence是集合(collection)的表达式，item是循环变量的名字，不能是表达式。&lt;#list userList as user&gt; …&lt;/#list&gt;List指令还隐含了两个循环变量： item_index:当前迭代项在所有迭代项中的位置，是数字值。 item_has_next:用于判断当前迭代项是否是所有迭代项中的最后一项。 注意：在使用上述两个循环变量时，一定要将item换成你自己定义的循环变量名,item其实就是前缀罢了。 &lt;#--Freemarker遍历list并应用list隐含变量item_index--&gt; item_index使用： &lt;#list userList as user&gt; 第$&#123;user_index+1&#125;个用户 用户名：$&#123;user.userName&#125; 密 码：$&#123;user.userPassword&#125; 年 龄: $&#123;user.age&#125; &lt;/#list&gt; &lt;#--Freemarker遍历list并应用list隐含变量item_has_next--&gt; item_has_next,size使用： &lt;#list userList as user&gt; 用户名：$&#123;user.userName&#125; 密 码：$&#123;user.userPassword&#125; 年 龄: $&#123;user.age&#125; &lt;#if !user_has_next&gt; 共有$&#123;userList?size&#125;最后一个用户是:$&#123;user.userName&#125; &lt;/#if&gt; &lt;/#list&gt;2. 排序sort升序排序函数 sort对序列(sequence)进行排序，要求序列中的变量必须是：字符串（按首字母排序）,数字，日期值。 &lt;#list list?sort as l&gt;…&lt;/#list&gt;sort_by函数 sort_by有一个参数,该参数用于指定想要排序的子变量，排序是按照变量对应的值进行排序,如： &lt;#list userList?sort_by(“age”) as user&gt;…&lt;/#list&gt; age是User对象的属性，排序是按age的值进行的。reverse降序排序函数 &lt;#list list? reverse as l&gt;…&lt;/#list&gt;。reverse使用同sort相同。reverse还可以同sort_by一起使用 如：想让用户按年龄降序排序，那么可以这个样写&lt;#list userList?sort_by(“age”)?reverse as user&gt;…&lt;/#list&gt;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Spring 集成Redis","slug":"backend/framework/cache/Redis","date":"2018-04-08T14:02:12.000Z","updated":"2018-04-09T14:07:01.475Z","comments":true,"path":"2018/04/08/backend/framework/cache/Redis/","link":"","permalink":"http://www.songshuiyang.site/2018/04/08/backend/framework/cache/Redis/","excerpt":"一：Redis1. 什么是RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 官网: https://redis.io/ 中文教程网: http://www.redis.net.cn/tutorial/3501.html 2. 基本介绍Redis 简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。","text":"一：Redis1. 什么是RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 官网: https://redis.io/ 中文教程网: http://www.redis.net.cn/tutorial/3501.html 2. 基本介绍Redis 简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。 3. 安装3.1 windows环境下载地址: https://github.com/MicrosoftArchive/redis/releases 3.1.1 修改配置文件12345redis.windows.conf 文件 配置密码 # requirepass foobaredrequirepass shuiyang 3.1.2 常用命令1234567redis服务安装成windows服务: redis-server --service-install redis.windows.conf开启服务：redis-server --service-start停止服务：redis-server --service-stop卸载服务：redis-server --service-uninstall 3.1.3 Redis可视化管理工具 RedisStudio，百度云连接：http://pan.baidu.com/s/1gfIbLar 密码：mpne Redis Desktop Manager https://redisdesktop.com/download 3.2 Linux环境下载地址：http://www.redis.net.cn/download/，下载最新文档版本。 3.2.1 安装1234$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz$ tar xzf redis-2.8.17.tar.gz$ cd redis-2.8.17$ make make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli 3.2.1 启动服务下面启动redis服务. 1$ ./redis-server 注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 1./redis-server redis.conf redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。 3.2.1 测试客户端程序启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如： 12345$ ./redis-cliredis&gt; set foo barOKredis&gt; get foo\"bar\" 4. 与Spring 集成4.1 导入maven1234567891011&lt;!--redis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4.2 新建 redis-config.properties1234567891011121314# Redis settingsredis.host=127.0.0.1redis.port=6379redis.pass=shuiyangredis.dbIndex=0redis.expiration=3000#最大空闲数redis.maxIdle=300#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotalredis.maxActive=600#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。redis.maxWait=1000#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个redis.testOnBorrow=true 4.3 新建 applicationContext-redis.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd\"&gt; &lt;!-- 启用缓存注解开关 --&gt; &lt;cache:annotation-driven cache-manager=\"cacheManager\"/&gt; &lt;!-- 配置JedisPoolConfig实例 --&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\" /&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.maxActive&#125;\" /&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.maxWait&#125;\" /&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.testOnBorrow&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 配置JedisConnectionFactory --&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"hostName\" value=\"$&#123;redis.host&#125;\" /&gt; &lt;property name=\"port\" value=\"$&#123;redis.port&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;redis.pass&#125;\" /&gt; &lt;property name=\"database\" value=\"$&#123;redis.dbIndex&#125;\" /&gt; &lt;property name=\"poolConfig\" ref=\"poolConfig\" /&gt; &lt;/bean&gt; &lt;!-- 配置RedisTemplate --&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 配置RedisCacheManager --&gt; &lt;bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"&gt; &lt;constructor-arg name=\"redisOperations\" ref=\"redisTemplate\" /&gt; &lt;property name=\"defaultExpiration\" value=\"$&#123;redis.expiration&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 配置RedisCacheManager --&gt; &lt;bean id=\"cacheManager\" class=\"org.springframework.cache.support.SimpleCacheManager\"&gt; &lt;property name=\"caches\"&gt; &lt;set&gt; &lt;!-- 这里可以配置多个redis --&gt; &lt;bean class=\"com.ecut.core.config.RedisCache\"&gt; &lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt; &lt;property name=\"name\" value=\"articlesDetail\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.ecut.core.config.RedisCache\"&gt; &lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt; &lt;property name=\"name\" value=\"getHotArticlesInCache\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.ecut.core.config.RedisCache\"&gt; &lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt; &lt;property name=\"name\" value=\"articlesList\"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.4 引入 applicationContext-redis.xml redis-config.properties1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt; &lt;!--使标注Spring注解的类生效--&gt; &lt;context:component-scan base-package=\"com.ecut\"/&gt; &lt;!-- 将多个配置文件读取到容器中，交给Spring管理 --&gt; &lt;bean id=\"propertyConfigurer\" class=\"com.ecut.core.spring.PropertyPlaceholderConfigurerFilter\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;!-- 这里支持多种寻址方式：classpath和file --&gt; &lt;value&gt;classpath:project.properties&lt;/value&gt; &lt;!-- 推荐使用file的方式引入，这样可以将配置和代码分离 --&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:redis-config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;import resource=\"applicationContext-dao.xml\"/&gt; &lt;import resource=\"applicationContext-shiro.xml\"/&gt; &lt;!--encache redis选择一种缓存--&gt; &lt;!--&lt;import resource=\"applicationContext-encache.xml\"/&gt;--&gt; &lt;import resource=\"applicationContext-redis.xml\"/&gt;&lt;/beans&gt; 4.5 新建 RedisCache.java Cache接口实现类 Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.ecut.core.config;import java.io.Serializable;import org.apache.commons.lang3.SerializationUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cache.Cache;import org.springframework.cache.support.SimpleValueWrapper;import org.springframework.dao.DataAccessException;import org.springframework.data.redis.connection.RedisConnection;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.RedisTemplate;import java.io.Serializable;/** * Cache接口实现类 * * Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。 在上面配置中可知，每个实现类都会注入一个redisTemplate实例，我们就可以通过redisTemplate来操作redis * @author songshuiyang * @date 2018/4/9 20:38 */public class RedisCache implements Cache &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private RedisTemplate&lt;String, Object&gt; redisTemplate; private String name; @Override public void clear() &#123; logger.info(\"----------------------------RedisCache 緩存清理-------------------------\"); redisTemplate.execute(new RedisCallback&lt;String&gt;() &#123; @Override public String doInRedis(RedisConnection connection) throws DataAccessException &#123; connection.flushDb(); return \"ok\"; &#125; &#125;); &#125; @Override public void evict(Object key) &#123; logger.info(\"----------------------------RedisCache 緩存刪除-------------------------\"); final String keyf=key.toString(); redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(RedisConnection connection) throws DataAccessException &#123; return connection.del(keyf.getBytes()); &#125; &#125;); &#125; @Override public ValueWrapper get(Object key) &#123; logger.info(\"----------------------------RedisCache 缓存获取-------------------------\"); final String keyf = key.toString(); Object object = null; object = redisTemplate.execute(new RedisCallback&lt;Object&gt;() &#123; @Override public Object doInRedis(RedisConnection connection) throws DataAccessException &#123; byte[] key = keyf.getBytes(); byte[] value = connection.get(key); if (value == null) &#123; logger.info(\"----------------------------RedisCache 缓存不存在-------------------------\"); return null; &#125; return SerializationUtils.deserialize(value); &#125; &#125;); ValueWrapper obj=(object != null ? new SimpleValueWrapper(object) : null); logger.info(\"----------------------------RedisCache 获取到内容-------------------------\"); return obj; &#125; @Override public void put(Object key, Object value) &#123; System.out.println(\"-------加入缓存------\"); System.out.println(\"key----:\"+key); System.out.println(\"key----:\"+value); final String keyString = key.toString(); final Object valuef = value; final long liveTime = 86400; redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(RedisConnection connection) throws DataAccessException &#123; byte[] keyb = keyString.getBytes(); byte[] valueb = SerializationUtils.serialize((Serializable) valuef); connection.set(keyb, valueb); if (liveTime &gt; 0) &#123; connection.expire(keyb, liveTime); &#125; return 1L; &#125; &#125;); &#125; @Override public &lt;T&gt; T get(Object arg0, Class&lt;T&gt; arg1) &#123; // TODO Auto-generated method stub return null; &#125; @Override public String getName() &#123; return this.name; &#125; @Override public Object getNativeCache() &#123; return this.redisTemplate; &#125; @Override public ValueWrapper putIfAbsent(Object arg0, Object arg1) &#123; // TODO Auto-generated method stub return null; &#125; public RedisTemplate&lt;String, Object&gt; getRedisTemplate() &#123; return redisTemplate; &#125; public void setRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 4.6 完成以上的配置之后就可以使用 Spring Cache注解来使用缓存了首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 @Cacheable 12345678910111213141516171819202122232425262728表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定key的生成规则。@Cacheable 支持如下几个参数： value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中 key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId， 一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， 本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等 condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1' @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\") public User findById(String userId) &#123; return (User) new User(\"1\", \"mengdee\"); &#125; // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\" @Cacheable(value=\"UserCache\", condition=\"#userId.length() &lt; 12\") public boolean isReserved(String userId) &#123; System.out.println(\"UserCache:\"+userId); return false; &#125; @CachePut 1与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。 @CacheEvict 1234567891011121314151617181920与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。@CacheEvict 支持如下几个参数： value：缓存位置名称，不能为空，同上 key：缓存的key，默认为空，同上 condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL allEntries：true表示清除value中的全部缓存，默认为false //清除掉UserCache中某个指定key的缓存 @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\") public void removeUser(User user) &#123; System.out.println(\"UserCache\"+user.getUserId()); &#125; //清除掉UserCache中全部的缓存 @CacheEvict(value=\"UserCache\", allEntries=true) public final void setReservedUsers(String[] reservedUsers) &#123; System.out.println(\"UserCache deleteall\"); &#125; @Caching 1234如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。@Caching(evict = &#123; @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") &#125;)public Book importBooks(String deposit, Date date) @CacheConfig 12345678与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。@CacheConfig(\"books\")public class BookRepositoryImpl implements BookRepository &#123; @Cacheable public Book findBook(ISBN isbn) &#123;...&#125;&#125; 遇到的问题： spring+redis报错org.springframework.core.serializer.support.DeserializingConverter.(Ljava/lang/ClassLoader;)V 123456789101112这个问题的原因大概就是spring-data-redis.jar包版本不对 ，下面版本可以正常启动 &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; Spring Cache 注解问题，使用redis缓存会出现类型转化的问题 ,还未解决 参考：https://www.cnblogs.com/panter/p/6801210.htmlhttp://www.redis.net.cn/tutorial/3503.htmlhttps://www.cnblogs.com/hello-daocaoren/p/7891907.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"微信公众号实现输入兑换码自动发红包功能","slug":"backend/business/payment/微信公众号开通发红包功能","date":"2018-04-03T14:15:12.000Z","updated":"2018-04-03T15:59:05.984Z","comments":true,"path":"2018/04/03/backend/business/payment/微信公众号开通发红包功能/","link":"","permalink":"http://www.songshuiyang.site/2018/04/03/backend/business/payment/微信公众号开通发红包功能/","excerpt":"前言 公司积分抽奖活动有红包奖项(虽然基本上都是这个奖)，但是用户兑奖的过程十分麻烦: 需要先联系公司客服，然后加客服微信，加完之后客服发一个微信红包作为兑换。所以决定简化这个兑奖过程，能不能将这个兑奖的过程改为由用户自己兑换，不用联系公司客服也能兑奖。 初步想法 公司有微信公众号，可以通过微信公众号进行发红包操作，一方面可以实现发送红包的功能，另一方面也可以推广公司的微信公众号。初步想法是用户在微信公众号里输入一个兑换码，然后微信自动发送一个红包给用户，用户只要点一下红包，红包就进用户自己口袋了 业务流程如果用户抽奖中了红包奖励，系统弹出一个提示框，里面有公司的微信公众号二维码图片（微信公众平台可以获取），及兑奖的兑换码，提示用户关注微信公众号，在公众号里面输入兑换码就可以获取红包","text":"前言 公司积分抽奖活动有红包奖项(虽然基本上都是这个奖)，但是用户兑奖的过程十分麻烦: 需要先联系公司客服，然后加客服微信，加完之后客服发一个微信红包作为兑换。所以决定简化这个兑奖过程，能不能将这个兑奖的过程改为由用户自己兑换，不用联系公司客服也能兑奖。 初步想法 公司有微信公众号，可以通过微信公众号进行发红包操作，一方面可以实现发送红包的功能，另一方面也可以推广公司的微信公众号。初步想法是用户在微信公众号里输入一个兑换码，然后微信自动发送一个红包给用户，用户只要点一下红包，红包就进用户自己口袋了 业务流程如果用户抽奖中了红包奖励，系统弹出一个提示框，里面有公司的微信公众号二维码图片（微信公众平台可以获取），及兑奖的兑换码，提示用户关注微信公众号，在公众号里面输入兑换码就可以获取红包 准备1、先介绍几个平台 I.微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。 平台入口：http://mp.weixin.qq.com。 II.微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。 平台入口：http://pay.weixin.qq.com III. 红包接口地址： https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&amp;index=3 2、 在微信公众平台获取公众号二维码图片（提供了多种尺寸大小），该二维码是提供给用户扫描， 及公众账号appid 3、 在微信商户平台上下载证书（账户中心 - 账户设置 - API安全 - API证书（下载zip压缩包格式即可，无须解压），获取 商户号（账户中心 - 账户设置 - 商户信息 - 基本账户信息 - 微信支付商户号），API密钥（账户中心 - 账户设置 - API安全 - API密钥 - 设置密钥（密钥为32位，需要自行重新设置，记录并保存好，实在没记住也可以更改） 这些参数 4、 开通红包功能，以及充值红包金额，红包金额与充值交易金额是区分开来的，所以需要单独充值，发放现金红包将扣除商户的可用余额，请注意，可用余额并不是微信支付交易额，需要预先充值，确保可用余额充足。查看可用余额、充值、提现请登录微信支付商户平台，进入“资金管理”菜单，进行操作 5、 介绍1234567891011121314151617181920现金红包简介微信红包，2014年春节一经推出即受到广大用户好评，引发全民抢红包热潮。现将微信红包打造成“现金红包”，成为一款定向资金发放的营销工具，供商户使用。申请红包条件1、T+0 结算商户需满足两个条件：1、入驻满90天，2、截止今日往回推30天内连续正常交易。2、其余结算周期的商户无限制，可立即前往【商户平台】-&gt;【产品中心】申请开通。发放方式介绍商户发放现金红包有3种发放方式：1）接口发放商户根据文档”【商户平台】现金红包API文档V2“进行开发，一次调用可以给一个指定用户发送一个指定金额的红包，满足多元化的运营需求；2）通过上传openid文件发放收集要发送红包对象的openid，将openid编辑成txt文件，登录微信支付商户平台，使用上传文件功能发放。一份文件对应一个红包模板，便于管理；为了防止商户手误重复操作发送红包，创建的同一个文件只能上传一次。若需要重复发放则需要修改文件名称或重新创建。3）配置营销规则“满额送”发放配置的规则不可使用红包模版进行发放，商户须在【产品中心】-【现金红包】-【前往功能】中创建红包后配置自助规则：用户使用微信支付发生交易满足一定条件，立送现金红包。税务和发票问题商户给用户发红包，微信支付按照商户指定红包金额扣除完全对等的充值资金，资金最终进入用户零钱。微信支付并未从中收取资金作为营收，所以不予开具发票。发放现金红包请商户遵照国家法律依法纳税，在商户充值之前，我们默认商户已经合法上税，商户使用本功能的行为若涉及纳税或代扣代缴税款的义务，由商户自行承担该义务，我们不会替商户缴纳税款 。 程序实现1、用户抽奖中了红包奖励, 生成一笔抽奖记录，同时生成一笔红包记录，所以需要新建一个红包记录表(表结构如下图)，一开始生成的记录中红包状态是 0-未发放的状态，同时生成兑换码。 兑换码规则： 10位大写字母：3位固定字母开头 + 7位随机字母（大写字母是为了防止【数字0 与字母o O】【 1与字母l】混淆导致用户兑换不了奖， 3位固定字母是为了防止恶意用户无限次输入兑换码导致老是触发红包处理程序，如果不是以这个三个字母开头的文字，统一回复欢迎关注本微信公众号） 1234567891011121314151617181920DROP TABLE IF EXISTS `ge_lottery_redpack_record`;CREATE TABLE `ge_lottery_redpack_record` ( `id` varchar(32) NOT NULL, `created_by` varchar(32) NOT NULL, `created_date` datetime NOT NULL, `last_modified_by` varchar(32) NOT NULL, `last_modified_date` datetime NOT NULL, `remarks` varchar(255) DEFAULT NULL, `version` int(11) DEFAULT NULL, `locked` bit(1) DEFAULT b'0', `enable` bit(1) DEFAULT b'0', `fd_lottery_record_id` varchar(32) DEFAULT NULL COMMENT '中奖纪录id 作为外键', `fd_status` int(11) DEFAULT NULL COMMENT '红包状态 0:未发放 1：已发放待领取 2：发放失败 3：已领取 4：未领取已退款', `fd_redpack_send_date` datetime DEFAULT NULL COMMENT '红包发送时间(非微信)', `fd_redpack_order_id` varchar(32) DEFAULT NULL COMMENT '微信红包订单单号', `fd_redpack_openid` varchar(32) DEFAULT NULL COMMENT '微信红包订单用户在wxappid下的openid', `fd_redeem_code` varchar(32) DEFAULT NULL COMMENT '兑换码', `fd_redpack_price` decimal(19,4) DEFAULT NULL COMMENT '红包金额', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖红包纪录表'; 2、用户得到兑换码之后，就是在微信公众号里输入兑换码，当用户输入兑换码之后，用户信息会发到我们自己服务器后台中, 这里用户触发的是文本事件，我们需要的是三个参数 (1) 用户微信OpenID（用户在本微信公众号的唯一标识） (2) 用户发的兑换码 (3) HttpServletRequest（用于获取用户ip，发红包接口入参需要） 1234567891011// 文本事件if (WechatBindUtil.MESSAGE_TEXT.equals(msgType)) &#123; String content = map.get(\"Content\").trim(); // 如果输入的文本是是以RED开头的, 执行发红包操作 if (content.startsWith(\"RED\")) &#123; String resultContent = lotteryRedpackRecordService.sendRedpackByRedeemCode(fromUserName,content,req); message = WechatBindUtil.initText(toUserName, fromUserName, resultContent); &#125; else &#123; message = WechatBindUtil.initText(toUserName, fromUserName, \"欢迎关注本微信公众号\"); &#125;&#125; 3、如果输入的文本是是以RED开头的, 执行发红包操作, 首先是查询红包记录表有没有该兑换码且红包状态为未发放，如果有的话调用微信发红包接口，同时更改红包状态，记录红包发送时间，微信红包订单单号，微信红包订单用户在wxappid下的openid，没有的话给出提示，实现如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 根据兑换码发送微信红包 * @param openid * @param redeemCode * @return */public String sendRedpackByRedeemCode (String openid, String redeemCode, HttpServletRequest request) &#123; Page&lt;LotteryRedpackRecord&gt; page = new Page&lt;&gt;(0); page.setParams(\"fdRedeemCode\",redeemCode); List&lt;LotteryRedpackRecord&gt; redpackRecords = findAutoByPage(page); if (redpackRecords.size() != 0) &#123; LotteryRedpackRecord oldRecord = redpackRecords.get(0); // 调用微信红包查询接口, 先更新红包纪录状态 updateRedpackState(oldRecord.getId()); // 更新完成之后获取新的红包纪录 LotteryRedpackRecord record = findById(oldRecord.getId()); Integer fdStatus = record.getFdStatus(); if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.未发放.getIndex())) &#123; RedpackDTO redpackDTO = new RedpackDTO(); // 以红包纪录id作为 微信红包接口请求的商品订单号 截取28位 String mchBillNo = record.getId(); mchBillNo= mchBillNo.substring(0,28); redpackDTO.setMchBillNo(mchBillNo); // 指定哪一个微信用户 redpackDTO.setReOpenid(openid); // 红包价格 redpackDTO.setTotalAmount(record.getFdRedpackPrice()); // 调用接口的机器Ip地址 String clientIp = WxUtils.getRemoteIp(request); redpackDTO.setClientIp(clientIp); Map&lt;String,String&gt; sendredpackResult = weixinPayService.sendredpack(redpackDTO); // 更新红包纪录表 LotteryRedpackRecord lotteryRedpackRecord = findById(record.getId()); lotteryRedpackRecord.setFdRedpackOpenid(openid); if (sendredpackResult.get(\"status\").equals(\"success\")) &#123; lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex()); // 红包订单的微信单号-微信服务器上红包纪录的唯一标识 String redpackOrderId = sendredpackResult.get(\"sendListid\"); lotteryRedpackRecord.setFdRedpackOrderId(redpackOrderId); lotteryRedpackRecord.setFdRedpackSendDate(new Date()); // 更新抽奖纪录表, 变为已兑换 LotteryRecord lotteryRecord = lotteryRecordService.findById(record.getFdLotteryRecordId()); lotteryRecord.setFdStatus(R.LotteryRecordItem.FdStatus.已兑换.getIndex()); lotteryRecordService.saveSelective(lotteryRecord); saveSelective(lotteryRedpackRecord); &#125; else &#123; lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex()); lotteryRedpackRecord.setRemarks(sendredpackResult.get(\"message\")); saveSelective(lotteryRedpackRecord); return \"红包发送失败, 请及时联系对应的客服!\"; &#125; &#125; else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex())) &#123; return \"该兑换码对应的红包已发送! 请注意查收\"; &#125; else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex())) &#123; return \"红包发送失败, 请及时联系对应的客服!\"; &#125; else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已领取.getIndex())) &#123; return \"该兑换码对应的红包已领取\"; &#125; else &#123; return \"该兑换码对应的红包已过时, 请及时联系对应的客服\"; &#125; &#125; else &#123; return \"该兑换码无效, 请输入正确的兑换码!\"; &#125; return \"红包已发送请注意查收! 注: 24小时后未领取该红包失效\";&#125; 4、调用微信红包接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 微信公众号发红包接口 * @param redpackDTO * @return */public Map&lt;String,String&gt; sendredpack(RedpackDTO redpackDTO) &#123; Map&lt;String,String&gt; resultMap = Maps.newHashMap(); Map&lt;String,String&gt; wxResultMap = Maps.newHashMap(); // 请求参数 Map&lt;String, String&gt; reqData = Maps.newHashMap(); logger.info(\"---------------------&gt;&gt;&gt; 开始发送红包start\", redpackDTO); try &#123; // 随机字符串 reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr()); // 商户订单号 reqData.put(\"mch_billno\",redpackDTO.getMchBillNo()); // 商户号 reqData.put(\"mch_id\", WxPcPayConfigImpl.MCH_ID); // 公众账号appid reqData.put(\"wxappid\", WxPcPayConfigImpl.SENDREDPACK_WX_APPID); // 商户名称 reqData.put(\"send_name\", WxPcPayConfigImpl.SENDREDPACK_SEND_NAME); // 用户openid reqData.put(\"re_openid\",redpackDTO.getReOpenid()); // 付款金额 reqData.put(\"total_amount\", AmountUtils.transAmountToCent(redpackDTO.getTotalAmount())); // 红包发放总人数 reqData.put(\"total_num\", WxPcPayConfigImpl.SENDREDPACK_TOTAL_NUM); // 红包祝福语 reqData.put(\"wishing\", WxPcPayConfigImpl.SENDREDPACK_WISHING); // Ip地址 reqData.put(\"client_ip\", redpackDTO.getClientIp()); // 活动名称 reqData.put(\"act_name\", WxPcPayConfigImpl.SENDREDPACK_ACT_NAME); //备注 reqData.put(\"remark\", WxPcPayConfigImpl.SENDREDPACK_REMARK); // 生成签名 reqData.put(\"sign\", WXPayUtil.generateSignature(reqData, WxPcPayConfigImpl.API_KEY, WXPayConstants.SignType.MD5 )); String respXml = wxpay.requestWithCert(WxPcPayConfigImpl.SENDREDPACK_URL,reqData , 10000, 10000); wxResultMap = WXPayUtil.xmlToMap(respXml); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包异常\"); resultMap.put(\"message\", e.getMessage()); resultMap.put(\"status\", \"failed\"); &#125; // 通信标识结果 String returnCode = wxResultMap.get(\"return_code\"); if (\"SUCCESS\".equals(returnCode)) &#123; String resultCode = wxResultMap.get(\"result_code\"); // 业务处理结果 if (\"SUCCESS\".equals(resultCode)) &#123; logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包成功\"); // 红包订单的微信单号 String sendListid = wxResultMap.get(\"send_listid\"); resultMap.put(\"sendListid\",sendListid); resultMap.put(\"message\",\"操作成功\"); resultMap.put(\"status\", \"success\"); &#125; else &#123; logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包失败, 原因: \" + wxResultMap.get(\"err_code_des\")); String errCodeDes = wxResultMap.get(\"err_code_des\"); resultMap.put(\"message\",errCodeDes); resultMap.put(\"status\", \"failed\"); return resultMap; &#125; &#125; else &#123; String returnMsg = wxResultMap.get(\"return_msg\"); logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包失败, 原因: \" + returnMsg); resultMap.put(\"message\", returnMsg); resultMap.put(\"status\", \"failed\"); return resultMap; &#125; return resultMap;&#125; 总结及注意事项1.红包是以分为单位，必须大于100分，小于20000分之间，这个很重要,不要一不小心把公司的钱都转出去了 2.需要对请求参数进行加签操作，wxpay里面封装了方法 3.现金红包接口请求是需要证书的，因为是出账，不像充值是属于进账不用证书， 需要调用requestWithCert 这个请求接口 1234567891011/** * 需要证书的请求 * @param strUrl String * @param reqData 向wxpay post的请求数据 Map * @param connectTimeoutMs 超时时间，单位是毫秒 * @param readTimeoutMs 超时时间，单位是毫秒 * @return API返回数据 * @throws Exception */public String requestWithCert(String strUrl, Map&lt;String, String&gt; reqData, int connectTimeoutMs, int readTimeoutMs) throws Exception &#123; 4.由于红包发出去了不知道用户有没有领取，所以可以用一个定时任务或者一个按钮调用微信红包状态查询接口，以更新红包的最新状态 5.可以借助第三方平台，如摇摇啦应用平台，借助这些平台可以不用开发接口，只要配置好参数就可以使用了，但唯一的缺点是要钱","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"Docelver接口管理平台","slug":"backend/testwork/Docelver接口管理平台","date":"2018-04-03T12:07:12.000Z","updated":"2018-06-06T13:06:57.972Z","comments":true,"path":"2018/04/03/backend/testwork/Docelver接口管理平台/","link":"","permalink":"http://www.songshuiyang.site/2018/04/03/backend/testwork/Docelver接口管理平台/","excerpt":"","text":"前言在项目开发过程中，开发一个功能模块，需要前后端开发进行接口定义并形成文档，如果使用doc这些文档去维护接口，多会出现纰漏，特别是在多人开发的项目中，缺点尤为明显，所以需要一个像代码版本控制（git svn）类型的平台去维护这些文档，方便开发人员进行接口维护，前后端开发人员联调接口，测试人员编写测试用例 市场上常用的接口管理平台1. Rap 阿里出品官网地址： http://rapapi.org/org/index.do 官网介绍： RAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效率。我们的口号：提高效率，回家吃晚饭！ 使用体验： RAP的应用范围非常明确，是一个面向开发人员自测和联调的工具性平台，它更适合以开发为核心对接口进行维护 2. DOClever官网地址： http://www.doclever.cn/controller/index/index.html 可以对接口信息进行编辑管理，支持get,post,put,delete,patch 五种方法，支持 https 和 https 协议，并且支持 query，body，json，raw，rest，formdata 的参数可视化编辑。同时对 json 可以进行无限层次可视化编辑。并且，状态码，代码注入，markdown 文档等附加功能应有尽有。 接口调试运行，可以对参数进行加密，从md5 到 aes 一应俱全，返回参数与模型实时分析对比，给出不一致的地方，找出接口可能出现的问题。如果你不想手写文档，那么试试接口的数据生成功能，可以对接口运行的数据一键生成文档信息。 mock 的无缝整合，DOClever 自己就是一个 mock 服务器，当你把接口的开发状态设置成已完成，本地 mock 便会自动请求真实接口数据，否则返回事先定义好的 mock 数据。 支持 postman，rap，swagger 的导入，方便你做无缝迁移，同时也支持 html 文件的导出，方便你离线浏览！ 项目版本和接口快照功能并行，你可以为一个项目定义 1.0，1.1，1.2 版本，并且可以自由的在不同版本间切换回滚，再也不怕接口信息的遗失，同时接口也有快照功能，当你接口开发到一半或者接口需求变更的时候，可以随时查看之前编辑的接口信息。 自动化测试功能，目前市面上类似平台的接口自动化测试大部分都是伪自动化，对于一个复杂的场景，比如获取验证码，登陆，获取订单列表，获取某个特定订单详情这样一个上下文关联的一系列操作无能为力。而 DOClever 独创的自动化测试功能，只需要你编写极少量的 javascript 代码便可以在网页里完成这样一系列操作，同时，DOClever 还提供了后台定时批量执行测试用例并把结果发送到团队成员邮箱的功能，你可以及时获取接口的运行状态。 团队协作功能，很多类似的平台这样的功能是收费的，但是 DOClever 觉得好东西需要共享出来，你可以新建一个团队，并且把团队内的成员都拉进来，给他们分组，给他们分配相关的项目以及权限，发布团队公告等等。 DOClever 开源免费，支持内网部署，很多公司考虑到数据的安全性，不愿意把接口放到公网上，没有关系，DOClever 给出一个方便快捷的解决方案，你可以把平台放到自己的内网上，完全不需要连接外网，同时功能一样也不少，即便是对于产品的升级，DOClever 也提供了很便捷的升级方案！","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.songshuiyang.site/tags/测试/"}]},{"title":"高并发","slug":"backend/server/JavaEE服务器/高并发","date":"2018-04-01T12:50:44.000Z","updated":"2019-06-20T15:18:42.336Z","comments":true,"path":"2018/04/01/backend/server/JavaEE服务器/高并发/","link":"","permalink":"http://www.songshuiyang.site/2018/04/01/backend/server/JavaEE服务器/高并发/","excerpt":"","text":"一、什么是高并发 通常指通过设计保证系统能够同时并行处理很多请求。 高并发相关常用的一些指标 参数 定义 响应时间 系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。 吞吐量 单位时间内处理的请求数量。 QPS 每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。 并发用户数 同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。 二、如何提升系统的并发能力 互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。 垂直扩展提升单机处理能力。垂直扩展的方式又有两种： 增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G，带宽； 提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间； 水平扩展下面的图是常见的互联网分层架构 logo 常见互联网分布式架构（1）客户端层：典型调用方是浏览器browser或者手机应用APP （2）反向代理层：系统入口，反向代理 （3）站点应用层：实现核心应用逻辑，返回html或者json （4）服务层：如果实现了服务化，就有这一层 （5）数据-缓存层：缓存加速访问存储 （6）数据-数据库层：数据库固化数据存储 各分层水平扩展架构实践 反向代理层的水平扩展: 配置多个服务器数量 反向代理层的水平扩展，是通过“DNS轮询”实现的：dns-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。 当nginx成为瓶颈的时候，只要增加服务器数量，新增nginx服务的部署，增加一个外网ip，就能扩展反向代理层的性能，做到理论上的无限高并发。 站点层的水平扩展: 配置多个web服务 站点层的水平扩展，是通过“nginx”实现的。通过修改nginx.conf，可以设置多个web后端。 当web后端成为瓶颈的时候，新增web服务的部署，在nginx配置中配置上新的web后端，就能扩展站点层的性能，做到理论上的无限高并发。 服务层的水平扩展 1.服务层的水平扩展，是通过“服务连接池”实现的。 站点层通过RPC-client调用下游的服务层RPC-server时，RPC-client中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在RPC-client处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。 2.动静分离，页面静态化，CDN加速 3.不要频繁的new对象,对于在整个应用中只需要存在一个实例的类使用单例模式 数据层的水平扩展：缓存，数据库 在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。 三、如何处理高并发线程安全问题Java进程加锁乐观锁与悲观锁乐观锁乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。 悲观锁悲观锁，指数据被外界修改持保守态度(悲观),在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 。数据库中实现是对数据记录进行操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。 一个例子：select * from 表 where .. for update; 悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。 乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。 参考: https://blog.csdn.net/DreamWeaver_zhou/article/details/78587580","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"算法(一)Java经典算法","slug":"backend/java/algorithm/算法(一)Java经典算法","date":"2018-03-31T16:24:12.000Z","updated":"2019-05-04T03:03:54.293Z","comments":true,"path":"2018/04/01/backend/java/algorithm/算法(一)Java经典算法/","link":"","permalink":"http://www.songshuiyang.site/2018/04/01/backend/java/algorithm/算法(一)Java经典算法/","excerpt":"","text":"排序算法冒泡排序123456789101112public void bubbleSort(int []a)&#123; int len=a.length; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len-i-1;j++)&#123;//注意第二重循环的条件 if(a[j]&gt;a[j+1])&#123; int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125;&#125; 选择排序123456789101112131415public void selectSort(int[]a)&#123; int len=a.length; for(int i=0;i&lt;len;i++)&#123;//循环次数 int value=a[i]; int position=i; for(int j=i+1;j&lt;len;j++)&#123;//找到最小的值和位置 if(a[j]&lt;value)&#123; value=a[j]; position=j; &#125; &#125; a[position]=a[i];//进行交换 a[i]=value; &#125;&#125; 查找算法二分查找1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Scanner;/* * 二分查找 */public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr=&#123;5,3,6,1,9,8,2,4,7&#125;; //先打印输出原始数组数据 System.out.println(\"原始数组数据如下：\"); for (int n : arr) &#123; System.out.print(n+\" \"); &#125; System.out.println(); //首先对数组进行排序，这里用冒泡排序 for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; //遍历输出排序好的数组 System.out.println(\"经过冒泡排序后的数组：\"); for(int n:arr)&#123; System.out.print(n+\" \"); &#125; System.out.println();//换行 Scanner input=new Scanner(System.in); System.out.println(\"请输入你要查找的数：\"); int num=input.nextInt(); int result=binarySearch(arr, num); if(result==-1)&#123; System.out.println(\"你要查找的数不存在……\"); &#125; else&#123; System.out.println(\"你要查找的数存在，在数组中的位置是：\"+result); &#125; &#125; //二分查找算法 public static int binarySearch(int[] arr,int num)&#123; int low=0; int upper=arr.length-1; while(low&lt;=upper)&#123; int mid=(upper+low)/2; if(arr[mid]&lt;num)&#123; low=mid+1; &#125; else if(arr[mid]&gt;num)&#123; upper=mid-1; &#125; else return mid; &#125; return -1; &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Windows批处理(cmd/bat)常用命令","slug":"backend/windows bat","date":"2018-03-24T07:54:12.000Z","updated":"2018-03-24T08:07:37.530Z","comments":true,"path":"2018/03/24/backend/windows bat/","link":"","permalink":"http://www.songshuiyang.site/2018/03/24/backend/windows bat/","excerpt":"需求在使用hexo写博客的时候, hexo d 老是不能把代码push上去，网上找了好多方法都不能解决, 只能自己手动把public文件下生成的文件自己敲git命令push上传, 每次写博客的时候都要执行这种操作, 次数多了会感觉厌烦, 所有想windows不是有批处理脚本吗, 所以自己查阅了一些资料, 写了一个草鸡简单的脚本 auto.bat1234567891011121314151617181920# 文件上传commitgit add -Agit commit -m \"auto commit\"git pushecho copy filexcopy D:\\workspace\\hexo-log-bak\\hexo-log-bak\\public\\*.* D:\\workspace\\hexo-log-upload\\songshuiyang.github.io /s /yecho 提交songshuiyang.github.io 文件cd ../../hexo-log-upload\\songshuiyang.github.iogit add -Agit commit -m \"auto commit\"git pushcd ../../hexo-log-bak/hexo-log-bak","text":"需求在使用hexo写博客的时候, hexo d 老是不能把代码push上去，网上找了好多方法都不能解决, 只能自己手动把public文件下生成的文件自己敲git命令push上传, 每次写博客的时候都要执行这种操作, 次数多了会感觉厌烦, 所有想windows不是有批处理脚本吗, 所以自己查阅了一些资料, 写了一个草鸡简单的脚本 auto.bat1234567891011121314151617181920# 文件上传commitgit add -Agit commit -m \"auto commit\"git pushecho copy filexcopy D:\\workspace\\hexo-log-bak\\hexo-log-bak\\public\\*.* D:\\workspace\\hexo-log-upload\\songshuiyang.github.io /s /yecho 提交songshuiyang.github.io 文件cd ../../hexo-log-upload\\songshuiyang.github.iogit add -Agit commit -m \"auto commit\"git pushcd ../../hexo-log-bak/hexo-log-bak 批处理文件批处理文件（batch file）包含一系列 DOS命令，通常用于自动执行重复性任务。用户只需双击批处理文件便可执行任务，而无需重复输入相同指令。编写批处理文件非常简单，但难点在于确保一切按顺序执行。编写严谨的批处理文件可以极大程度地节省时间，在应对重复性工作时尤其有效。 在Windows中善用批处理可以简化很多重复工作 常用DOS命令123456789101112131415161718192021222324252627282930313233343536373839404142文件夹管理 cd 显示当前目录名或改变当前目录。 md 创建目录。 rd 删除一个目录。 dir 显示目录中的文件和子目录列表。 tree 以图形显示驱动器或路径的文件夹结构。 path 为可执行文件显示或设置一个搜索路径。 xcopy 复制文件和目录树。文件管理 type 显示文本文件的内容。 copy 将一份或多份文件复制到另一个位置。 del 删除一个或数个文件。 move 移动文件并重命名文件和目录。(Windows XP Home Edition中没有) ren 重命名文件。 replace 替换文件。 attrib 显示或更改文件属性。 find 搜索字符串。 fc 比较两个文件或两个文件集并显示它们之间的不同网络命令 ping 进行网络连接测试、名称解析 ftp 文件传输 net 网络命令集及用户管理 telnet 远程登陆 ipconfig显示、修改TCP/IP设置 msg 给用户发送消息 arp 显示、修改局域网的IP地址-物理地址映射列表 系统管理 at 安排在特定日期和时间运行命令和程序 shutdown立即或定时关机或重启 tskill 结束进程 taskkill结束进程(比tskill高级，但WinXPHome版中无该命令) tasklist显示进程列表(Windows XP Home Edition中没有) sc 系统服务设置与控制 reg 注册表控制台工具 powercfg控制系统上的电源设置 例子","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"Spring 集成Encache","slug":"backend/framework/cache/Encache","date":"2018-03-24T03:41:12.000Z","updated":"2018-04-08T15:02:40.632Z","comments":true,"path":"2018/03/24/backend/framework/cache/Encache/","link":"","permalink":"http://www.songshuiyang.site/2018/03/24/backend/framework/cache/Encache/","excerpt":"一：Encache1. 什么是EncacheEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。 官网: http://www.ehcache.org/ 2. 基本介绍Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 Ehcache最初是由Greg Luck于2003年开始开发。2009年,该项目被Terracotta购买。软件仍然是开源,但一些新的主要功能(例如，快速可重启性之间的一致性的)只能在商业产品中使用，例如Enterprise EHCache and BigMemory。维基媒体Foundationannounced目前使用的就是Ehcache技术。","text":"一：Encache1. 什么是EncacheEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。 官网: http://www.ehcache.org/ 2. 基本介绍Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 Ehcache最初是由Greg Luck于2003年开始开发。2009年,该项目被Terracotta购买。软件仍然是开源,但一些新的主要功能(例如，快速可重启性之间的一致性的)只能在商业产品中使用，例如Enterprise EHCache and BigMemory。维基媒体Foundationannounced目前使用的就是Ehcache技术。 3. 特点主要的特性有： 快速 简单 多种缓存策略 缓存数据有两级：内存和磁盘，因此无需担心容量问题 缓存数据会在虚拟机重启的过程中写入磁盘 可以通过RMI、可插入API等方式进行分布式缓存 具有缓存和缓存管理器的侦听接口 支持多缓存管理器实例，以及一个实例的多个缓存区域 提供Hibernate的缓存实现 ehcache与redis的区别1.redis的数据结构比较丰富，有key-value、hash、set等；ehcache比较简单，只有key-value 2.ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。redis是通过socket访问到缓存服务，效率ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 二: Encache与Spring 集成1. 前言Spring自身并没有实现缓存解决方案，但是对缓存管理功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。 Spring Cache是作用在方法上的（不能理解为只注解在方法上），其核心思想是：当我们在调用一个缓存方法时会把该方法参数和返回结果作为一个键值存放在缓存中，等到下次利用同样的参数调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。所以在使用Spring Cache的时候我们要保证我们的缓存的方法对于相同的方法参数要有相同的返回结果。 2. 开始集成 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt; 编写ehcache.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"&gt; &lt;!-- 磁盘缓存位置 在Windows的缓存目录为：C:\\Users\\登录用户~1\\AppData\\Local\\Temp\\ Linux：/tmp --&gt; &lt;diskStore path=\"java.io.tmpdir/ehcache\"/&gt; &lt;!--name：缓存名称。--&gt; &lt;!--maxElementsInMemory：缓存最大个数。--&gt; &lt;!--eternal：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。--&gt; &lt;!--timeToIdleSeconds：置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。--&gt; &lt;!--timeToLiveSeconds：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。--&gt; &lt;!--maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。--&gt; &lt;!--overflowToDisk：内存不足时，是否启用磁盘缓存。--&gt; &lt;!--diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。--&gt; &lt;!--maxElementsOnDisk：硬盘最大缓存个数。--&gt; &lt;!--diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。--&gt; &lt;!--diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。--&gt; &lt;!--memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。--&gt; &lt;!--clearOnFlush：内存数量最大时是否清除。--&gt; &lt;!--@Cacheable(value = \"users\", condition = \"#user.getId() &lt;= 2\")--&gt; &lt;!--@CachePut(value = \"users\", key = \"#user.getId()\")--&gt; &lt;!--@CacheEvict(value = \"users\", allEntries = true)--&gt; &lt;!-- 默认缓存 --&gt; &lt;defaultCache maxEntriesLocalHeap=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" maxEntriesLocalDisk=\"10000000\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;persistence strategy=\"localTempSwap\"/&gt; &lt;/defaultCache&gt; &lt;!-- 博客文章详情缓存 --&gt; &lt;cache name=\"articlesDetail\" maxElementsInMemory=\"1000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" overflowToDisk=\"false\" memoryStoreEvictionPolicy=\"LRU\"/&gt; &lt;!-- hotArticles缓存 --&gt; &lt;cache name=\"articlesDetail\" maxElementsInMemory=\"1000\" eternal=\"true\" overflowToDisk=\"false\" memoryStoreEvictionPolicy=\"LRU\"/&gt;&lt;/ehcache&gt; 在需要缓存的地方加上缓存注解 12345678910111213141516171819202122/** * 第一次执行会缓存文章,以id作为key, 第二次会直接取缓存的数据(需要在缓存有效期,过期会重新查询数据库) * @param id * @return */@Override@Cacheable(value = \"articlesDetail\", key = \"#id\")public BlogArticles selectByPrimaryKey(Integer id) &#123; return getMappser().selectByPrimaryKey(id);&#125;/** * 保存文章，同时删除record.getId()该已存的缓存数据 * @param record * @return */@Override@CacheEvict(value = \"articlesDetail\", key = \"#record.getId()\")public int updateByPrimaryKeySelective(BlogArticles record) &#123; setCurrentOperator(record); return getMappser().updateByPrimaryKeySelective(record);&#125; 3. 注解讲解首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 @Cacheable 12345678910111213141516171819202122232425262728表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定key的生成规则。@Cacheable 支持如下几个参数： value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中 key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId， 一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， 本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等 condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1' @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\") public User findById(String userId) &#123; return (User) new User(\"1\", \"mengdee\"); &#125; // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\" @Cacheable(value=\"UserCache\", condition=\"#userId.length() &lt; 12\") public boolean isReserved(String userId) &#123; System.out.println(\"UserCache:\"+userId); return false; &#125; @CachePut 1与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。 @CacheEvict 1234567891011121314151617181920与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。@CacheEvict 支持如下几个参数： value：缓存位置名称，不能为空，同上 key：缓存的key，默认为空，同上 condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL allEntries：true表示清除value中的全部缓存，默认为false //清除掉UserCache中某个指定key的缓存 @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\") public void removeUser(User user) &#123; System.out.println(\"UserCache\"+user.getUserId()); &#125; //清除掉UserCache中全部的缓存 @CacheEvict(value=\"UserCache\", allEntries=true) public final void setReservedUsers(String[] reservedUsers) &#123; System.out.println(\"UserCache deleteall\"); &#125; @Caching 1234如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。@Caching(evict = &#123; @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") &#125;)public Book importBooks(String deposit, Date date) @CacheConfig 12345678与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。@CacheConfig(\"books\")public class BookRepositoryImpl implements BookRepository &#123; @Cacheable public Book findBook(ISBN isbn) &#123;...&#125;&#125; 4. 创建Cache工具类, 方便对cache进行管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ecut.core.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cache.Cache;import org.springframework.cache.CacheManager;/** * 缓存工具类 * @author songshuiyang * @date 2018/3/24 12:16 */public class CacheUtils &#123; private final static Logger logger = LoggerFactory.getLogger(CacheUtils.class); private static CacheManager cacheManager = (CacheManager) SpringContextUtils.getBean(\"cacheManager\"); /** * 获取缓存 * @param cacheName 缓存名 * @param key 键 * @return Object */ public static Object get(String cacheName, Object key) &#123; Cache cache = cacheManager.getCache(cacheName); if (cache != null) &#123; //这里需要判断是否null if(cache.get(key) != null)&#123; return cache.get(key).get(); &#125; &#125; return null; &#125; /** * 添加缓存 * 存在则更新 * @param cacheName 缓存名 * @param key 键 * @param value 值 */ public static void put(String cacheName, Object key, Object value) &#123; Cache cache = cacheManager.getCache(cacheName); if(cache != null)&#123; cache.put(key, value); &#125; &#125; /** * 清除缓存 * @param cacheName 缓存名 * @param key 键 */ public static void remove(String cacheName, Object key) &#123; Cache cache = cacheManager.getCache(cacheName); if (cache != null) &#123; cache.evict(key); &#125;else&#123; logger.warn(\"this key is not in Cache\"); &#125; &#125;&#125;&#125; 参考：https://blog.csdn.net/vbirdbest/article/details/72763048http://www.cnblogs.com/jingmoxukong/p/5975994.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"hover.css","slug":"frontend/hover","date":"2018-03-20T12:52:12.000Z","updated":"2018-03-20T15:08:21.018Z","comments":true,"path":"2018/03/20/frontend/hover/","link":"","permalink":"http://www.songshuiyang.site/2018/03/20/frontend/hover/","excerpt":"","text":"Hover.cssA collection of CSS3 powered hover effects to be applied to links, buttons, logos, SVG, featured images and so on. Easily apply to your own elements, modify or just use for inspiration. Available in CSS, Sass, and LESS. 官网地址: http://ianlunn.github.io/Hover/ 演示地址: http://wow.techbrood.com/fiddle/852","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.songshuiyang.site/tags/css/"}]},{"title":"Linux 命令笔记","slug":"backend/server/Linux/linux笔记","date":"2018-03-08T09:30:44.000Z","updated":"2018-07-08T07:02:02.887Z","comments":true,"path":"2018/03/08/backend/server/Linux/linux笔记/","link":"","permalink":"http://www.songshuiyang.site/2018/03/08/backend/server/Linux/linux笔记/","excerpt":"","text":"出现问题 bash: service: command not found, 解决方法：1yum install initscripts 查看端口12345678910111213141516# 查看80端口占用情况lsof -i tcp:80# 列出所有端口netstat -ntlp# 查看端口状态netstat -lnp|grep 88 #88请换为你的apache需要的端口，如：80# SSH执行以上命令，可以查看到88端口正在被哪个进程使用。如下图，进程号为 1777 。# 查看进程的详细信息ps 1777# 杀掉进程kill -9 1777 #杀掉编号为1777的进程（请根据实际情况输入）","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"Docker笔记","slug":"backend/server/Linux/Docker笔记","date":"2018-03-08T06:30:44.000Z","updated":"2018-03-10T02:17:01.895Z","comments":true,"path":"2018/03/08/backend/server/Linux/Docker笔记/","link":"","permalink":"http://www.songshuiyang.site/2018/03/08/backend/server/Linux/Docker笔记/","excerpt":"什么是DockerDocker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了。作为一名 Java 程序员，我们是时候一起把 Docker 学起来了！ 1.传统虚拟化技术的体系架构： mechine.png 可见，我们在宿主机的操作系统上，可安装了多个虚拟机，而在每个虚拟机中，通过虚拟化技术，实现了一个虚拟操作系统，随后，就可以在该虚拟操作系统上，安装自己所需的应用程序了。这一切看似非常简单，但其中的技术细节是相当高深莫测的，大神级人物都不一定说得清楚。","text":"什么是DockerDocker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了。作为一名 Java 程序员，我们是时候一起把 Docker 学起来了！ 1.传统虚拟化技术的体系架构： mechine.png 可见，我们在宿主机的操作系统上，可安装了多个虚拟机，而在每个虚拟机中，通过虚拟化技术，实现了一个虚拟操作系统，随后，就可以在该虚拟操作系统上，安装自己所需的应用程序了。这一切看似非常简单，但其中的技术细节是相当高深莫测的，大神级人物都不一定说得清楚。 凡是使用过虚拟机的同学，应该都知道，启动虚拟机就像启动一台计算机，初始化过程是相当慢的，我们需要等很久，才能看到登录界面。一旦虚拟机启动以后，就可以与宿主机建立网络连接，确保虚拟机与宿主机之间是互联互通的。不同的虚拟机之间却是相互隔离的，也就是说，彼此并不知道对方的存在，但每个虚拟机占用的都是宿主机的硬件与网络资源。 2.Docker 技术的体系架构 mechine.png 可见，在宿主机的操作系统上，有一个 Docker 服务在运行（或者称为“Docker 引擎”），在此服务上，我们可开启多个 Docker 容器，而每个 Docker 容器中可运行自己所需的应用程序，Docker 容器之间也是相互隔离的，同样地，都是占用的宿主机的硬件与网络资源。、 Docker 容器相对于虚拟机而言，除了在技术实现上完全不一样以外，启动速度较虚拟机而言有本质的飞跃，启动一个容器只在眨眼瞬间。不管是虚拟机还是 Docker 容器，它们都是为了隔离应用程序的运行环境，节省我们的硬件资源，为我们开发人员提供福利。 3.Docker 的 Logo: logo.png 很明显，这是一只鲸鱼，它托着许多集装箱。我们可以把宿主机可当做这只鲸鱼，把相互隔离的容器可看成集装箱，每个集装箱中都包含自己的应用程序。这 Logo 简直的太形象了！ 4.Docker的应用场景123451. Web 应用的自动化打包和发布。2. 自动化测试和持续集成、发布。3. 在服务型环境中部署和调整数据库或其他的后台应用。 5.Docker 的优点123456781、简化程序：Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。2、避免选择恐惧症：如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。3、节省开支：一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。 Docker 术语 术语 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 Docker 容器(Container) 容器是独立运行的一个或一组应用。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Docker 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 使用Docker前先配置 Docker国内镜像或者使用registry-mirrors配置加速由于国内访问直接访问Docker hub网速比较慢，拉取镜像的时间就会比较长。一般我们会使用镜像加速或者直接从国内的一些平台镜像仓库上拉取。 123456789101112131415161718192021222324方法一： 网易镜像中心：https://c.163.com/hub#/m/home/ 拉取镜像的命令是： docker pull 镜像名字 所以我们可以按照给出的镜像名字或者命令直接拉取。eg: docker pull hub.c.163.com/library/tomcat:latest方法二： daocloud镜像市场：https://hub.daocloud.io/如果说还是想从dockerhub上拉取，那么使用加速器修改docker的registry-mirrors。这里使用的是DaoCloud的加速器。 首先在http://www.daocloud.io/进行注册登录。然后点击加速器，得到如下脚本 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://24524c4f.m.daocloud.io Copy 该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。 也可以自己手动修改 /etc/docker/daemon.json&#123; \"registry-mirrors\": [\"http://ef017c13.m.daocloud.io\"], \"live-restore\": true&#125;最后重启docker service docker restart 安装 Docker1.前提条件1234使用 yum 安装（CentOS 7下）Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本 2.安装1yum -y install docker 3.启动服务1service docker start 4.测试运行 hello-world1docker run hello-world Docker中使用CentOS7镜像1.启动容器服务1systemctl start docker.service 2.下载CentOS7 镜像12345678910111213141516[root@JD docker]# docker pull centos:7.3.1611Trying to pull repository docker.io/library/centos ... 7.3.1611: Pulling from docker.io/library/centos版本: https://hub.docker.com/_/centos/ 可以在这个网站上选择自己想要的版本 latest, centos7, 7 (docker/Dockerfile) centos6, 6 (docker/Dockerfile) centos7.4.1708, 7.4.1708 (docker/Dockerfile) centos7.3.1611, 7.3.1611 (docker/Dockerfile) centos7.2.1511, 7.2.1511 (docker/Dockerfile) centos7.1.1503, 7.1.1503 (docker/Dockerfile) centos7.0.1406, 7.0.1406 (docker/Dockerfile) centos6.9, 6.9 (docker/Dockerfile) centos6.8, 6.8 (docker/Dockerfile) centos6.7, 6.7 (docker/Dockerfile) centos6.6, 6.6 (docker/Dockerfile) 3.下载成功之后查看本地所有的镜像，得到centos的 IMAGE ID: 66ee80d59a6812345[root@JD ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest 108db0e7c85e 2 weeks ago 557.4 MBdocker.io/hello-world latest f2a91732366c 3 months ago 1.848 kBdocker.io/centos 7.3.1611 66ee80d59a68 4 months ago 191.8 MB 4.启动docker中的CentOS712345678910111213141516171819docker run -ti 66ee /bin/bash#6866 是 IMAGE ID 前四位数字-能区分出是哪个image即可root@b4ad1d1c87da /]# #登录成功，接下来就可以为所欲为啦。命令笔记 容器是在镜像的基础上来运行的，一旦容器启动了，我们就可以登录到容器中，安装自己所需的软件或应用程序。既然镜像已经下载到本地，那么如何才能启动容器呢 docker run -i -t -v /root/software/:/mnt/software/ 25c5298b1a36 /bin/bash docker run &lt;相关参数&gt; &lt;镜像 ID&gt; &lt;初始命令&gt; -i：表示以“交互模式”运行容器 -t：表示容器启动后会进入其命令行 -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt; 假设我们的所有安装程序都放在了宿主机的/root/software/目录下，现在需要将其挂载到容器的/mnt/software/目录下。 初始命令表示一旦容器启动，需要运行的命令，此时使用“/bin/bash”，表示什么也不做，只需进入命令行即可。 5.检查CentOS7系统1234root@b4ad1d1c87da /]# uname -aLinux b4ad1d1c87da 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux[root@b4ad1d1c87da /]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) 6.退出1234ctrl+d 退出容器且关闭, docker ps 查看无,ctrl+p+q 退出容器但不关闭, docker ps 7.再进入CentOS71234567[root@wxtest1607 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb4ad1d1c87da 6866 \"/bin/bash\" 12 seconds ago Up 9 seconds mad_swanson drunk_hypatia得到 CONTAINER ID [root@wxtest1607 ~]# docker exec -ti b4ad /bin/bash [root@b4ad1d1c87da /]# 8.安装tomcat123456781. yum -y install tomcat注： 在docker中通过systemctl 启动服务的时候总是报Failed to get D-Bus connection: Operation not permitted 这样的错误提示。 解决方法： 解决办法就是在docker run 的时候运行/usr/sbin/init 。比如： docker run -ti 66ee /usr/sbin/init2. 在Centos使用yum安装后，Tomcat相关的目录都已采用符号链接到/usr/share/tomcat6目录，包含webapps等，这很方便我们配置管理 转载：http://www.runoob.com/docker/docker-tutorial.html 转载：http://developer.51cto.com/art/201702/529956.htm 转载：http://www.jb51.net/article/112921.htm 转载：https://www.jianshu.com/p/0aa535e681f5","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"Mysql 用户及权限管理","slug":"backend/database/Mysql 用户及权限管理d","date":"2018-03-07T14:24:12.000Z","updated":"2018-12-06T12:28:47.875Z","comments":true,"path":"2018/03/07/backend/database/Mysql 用户及权限管理d/","link":"","permalink":"http://www.songshuiyang.site/2018/03/07/backend/database/Mysql 用户及权限管理d/","excerpt":"权限控制授权语法：1234567891011121314151617181920GRANT privileges (columns) ON what TO user IDENTIFIED BY \"password\" WITH GRANT OPTION权限列表:ALTER: 修改表和索引。CREATE: 创建数据库和表。DELETE: 删除表中已有的记录。DROP: 抛弃(删除)数据库和表。INDEX: 创建或抛弃索引。INSERT: 向表中插入新行。REFERENCE: 未用。SELECT: 检索表中的记录。UPDATE: 修改现存表记录。FILE: 读或写服务器上的文件。PROCESS: 查看服务器中执行的线程信息或杀死线程。RELOAD: 重载授权表或清空日志、主机缓存或表缓存。SHUTDOWN: 关闭服务器。ALL: 所有权限，ALL PRIVILEGES同义词。USAGE: 特殊的 \"无权限\" 权限。用 户账户包括 \"username\" 和 \"host\" 两部分，后者表示该用户被允许从何地接入。tom@'%' 表示任何地址，默认可以省略。还可以是 \"tom@192.168.1.%\"、\"tom@%.abc.com\" 等。数据库格式为 db@table，可以是 \"test.*\" 或 \"*.*\"，前者表示 test 数据库的所有表，后者表示所有数据库的所有表。子句 \"WITH GRANT OPTION\" 表示该用户可以为其他用户分配权限。","text":"权限控制授权语法：1234567891011121314151617181920GRANT privileges (columns) ON what TO user IDENTIFIED BY \"password\" WITH GRANT OPTION权限列表:ALTER: 修改表和索引。CREATE: 创建数据库和表。DELETE: 删除表中已有的记录。DROP: 抛弃(删除)数据库和表。INDEX: 创建或抛弃索引。INSERT: 向表中插入新行。REFERENCE: 未用。SELECT: 检索表中的记录。UPDATE: 修改现存表记录。FILE: 读或写服务器上的文件。PROCESS: 查看服务器中执行的线程信息或杀死线程。RELOAD: 重载授权表或清空日志、主机缓存或表缓存。SHUTDOWN: 关闭服务器。ALL: 所有权限，ALL PRIVILEGES同义词。USAGE: 特殊的 \"无权限\" 权限。用 户账户包括 \"username\" 和 \"host\" 两部分，后者表示该用户被允许从何地接入。tom@'%' 表示任何地址，默认可以省略。还可以是 \"tom@192.168.1.%\"、\"tom@%.abc.com\" 等。数据库格式为 db@table，可以是 \"test.*\" 或 \"*.*\"，前者表示 test 数据库的所有表，后者表示所有数据库的所有表。子句 \"WITH GRANT OPTION\" 表示该用户可以为其他用户分配权限。 实例： 12345678910111213141516171819202122use mysql1. 新建用户, 并赋予所有数据库权限 GRANT ALL PRIVILEGES ON *.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION; 说明: 1. username - 你将创建的用户名, host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器. 2. 指定helloworld数据库: GRANT ALL PRIVILEGES ON helloword.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION;2. 指定该用户只能执行 select 和 update 命令 GRANT SELECT, UPDATE ON *.* TO 'username'@'%' IDENTIFIED BY 'password';3. 另外每当调整权限后，通常需要执行以下语句刷新权限： FLUSH PRIVILEGES;4. grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。 grant select on testdb.* to common_user@’%’ grant insert on testdb.* to common_user@’%’ grant update on testdb.* to common_user@’%’ grant delete on testdb.* to common_user@’%’ 或者，用一条 MySQL 命令来替代： grant select, insert, update, delete on testdb.* to common_user@’%’ 用户12345678910111213141516171819202122232425262728293031323334351. 删除刚才创建的用户： DROP USER username@localhost;2. 查看用户创建是否成功 select user,host from user ; +-----------+-----------+ | user | host | +-----------+-----------+ | root | % | | select | % | | server | % | | shuiyang | % | | user | % | | mysql.sys | localhost | +-----------+-----------+ 3. 查看select用户的授权 show grants for select; MySQL [mysql]&gt; show grants for `select`; +---------------------------------------------+ | Grants for select@% | +---------------------------------------------+ | GRANT SELECT, UPDATE ON *.* TO 'select'@'%' | +---------------------------------------------+ 1 row in set (0.00 sec) 4. 设置与更改用户密码SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword')如果是当前登陆用户用SET PASSWORD = PASSWORD(\"newpassword\");","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.songshuiyang.site/tags/mysql/"}]},{"title":"Mysql 字符集和排序规则说明","slug":"backend/database/Mysql 字符集和排序规则说明","date":"2018-03-07T14:24:12.000Z","updated":"2018-12-06T12:28:47.870Z","comments":true,"path":"2018/03/07/backend/database/Mysql 字符集和排序规则说明/","link":"","permalink":"http://www.songshuiyang.site/2018/03/07/backend/database/Mysql 字符集和排序规则说明/","excerpt":"","text":"字符集utf8mb4 和 utf8 比较UTF-8是使用1~4个字节，一种变长的编码格式。（字符编码 ） mb4即 most bytes 4，使用4个字节来表示完整的UTF-8。而MySQL中的utf8是utfmb3，只有三个字节，节省空间但不能表达全部的UTF-8，只能支持“基本多文种平面”（Basic Multilingual Plane，BMP）。 推荐使用utf8mb4。 排序规则ci 是 case insensitive, 即 “大小写不敏感”, a 和 A 会在字符判断中会被当做一样的。 bin 是二进制, a 和 A 会别区别对待。 例如你运行如下sql, 那么在utf8_bin中你就找不到 txt = ‘A’ 的那一行, 而 utf8_general_ci 则可以。1SELECT * FROM table WHERE txt = 'a'; 常用排序规则 utf8_general_ci：不区分大小写，这个你在注册用户名和邮箱的时候就要使用。 utf8_general_cs：区分大小写，如果用户名和邮箱用这个 就会照成不良后果。 utf8_bin：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容。 总结 utf8_unicode_ci和utf8_general_ci对中、英文来说没有实质的差别。 utf8_general_ci：校对速度快，但准确度稍差。 utf8_unicode_ci：准确度高，但校对速度稍慢。 如果你的应用有德语、法语或者俄语，请一定使用utf8_unicode_ci。一般用utf8_general_ci就够了，到现在也没发现问题。 参考:https://www.cnblogs.com/zwakeup/p/8267204.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.songshuiyang.site/tags/mysql/"}]},{"title":"Centos7安装Mysql5.7.md","slug":"backend/server/Linux/Centos7安装Mysql5.7","date":"2018-03-07T12:30:44.000Z","updated":"2018-06-11T14:59:30.379Z","comments":true,"path":"2018/03/07/backend/server/Linux/Centos7安装Mysql5.7/","link":"","permalink":"http://www.songshuiyang.site/2018/03/07/backend/server/Linux/Centos7安装Mysql5.7/","excerpt":"一：配置YUM源 官网地址 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/ 1.下载mysql源安装包1wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 命令笔记:12345678910111213141516171819202122232425262728wget:用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；-b：进行后台的方式运行wget；-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；-c：继续执行上次终端的任务；-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；-d：调试模式运行指令；-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；-h：显示指令帮助信息；-i&lt;文件&gt;：从指定文件获取要下载的URL地址；-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；-L：仅顺着关联的连接；-r：递归下载方式；-nc：文件存在时，下载文件不覆盖原有文件；-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；-q：不显示指令执行过程；-nh：不查询主机名称；-v：显示详细执行过程；-V：显示版本信息；--passive-ftp：使用被动模式PASV连接FTP服务器；--follow-ftp：从HTML文件中下载FTP连接文件下载并以不同的文件名保存:wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080","text":"一：配置YUM源 官网地址 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/ 1.下载mysql源安装包1wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 命令笔记:12345678910111213141516171819202122232425262728wget:用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；-b：进行后台的方式运行wget；-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；-c：继续执行上次终端的任务；-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；-d：调试模式运行指令；-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；-h：显示指令帮助信息；-i&lt;文件&gt;：从指定文件获取要下载的URL地址；-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；-L：仅顺着关联的连接；-r：递归下载方式；-nc：文件存在时，下载文件不覆盖原有文件；-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；-q：不显示指令执行过程；-nh：不查询主机名称；-v：显示详细执行过程；-V：显示版本信息；--passive-ftp：使用被动模式PASV连接FTP服务器；--follow-ftp：从HTML文件中下载FTP连接文件下载并以不同的文件名保存:wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080 2.安装mysql源1yum localinstall mysql57-community-release-el7-8.noarch.rpm 命令笔记:12345678910111213141516171819202122232425262728293031323334353637yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。选项:-h：显示帮助信息；-y：对所有的提问都回答“yes”；-c：指定配置文件；-q：安静模式；-v：详细模式；-d：设置调试等级（0-10）；-e：设置错误等级（0-10）；-R：设置yum处理一个命令的最大等待时间；-C：完全从缓存中运行，而不去下载或者更新任何头文件。参数：install：安装rpm软件包；update：更新rpm软件包；check-update：检查是否有可用的更新rpm软件包；remove：删除指定的rpm软件包；list：显示软件包的信息；search：检查软件包的信息；info：显示指定的rpm软件包的描述信息和概要信息；clean：清理yum过期的缓存；shell：进入yum的shell提示符；resolvedep：显示rpm软件包的依赖关系；localinstall：安装本地的rpm软件包；localupdate：显示本地rpm软件包进行更新；deplist：显示rpm软件包的所有依赖关系。实例部分常用的命令包括：自动搜索最快镜像插件：yum install yum-fastestmirror安装yum图形窗口插件：yum install yumex查看可能批量安装的列表：yum grouplist 3.检查mysql源是否安装成功1yum repolist enabled | grep \"mysql.*-community.*\" logo 看到上图所示表示mysql源安装成功。 可以修改vim /etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。比如要安装5.6版本，将5.7源的enabled=1改成enabled=0。然后再将5.6源的enabled=0改成enabled=1即可 二 安装MySQL1yum install mysql-community-server 命令笔记:123456789101112131415161718192021222324252627安装yum install #全部安装yum install package1 #安装指定的安装包package1yum groupinsall group1 #安装程序组group1更新和升级yum update #全部更新yum update package1 #更新指定程序包package1yum check-update #检查可更新的程序yum upgrade package1 #升级指定程序包package1yum groupupdate group1 #升级程序组group1查找和显示yum info package1 #显示安装包信息package1yum list #显示所有已经安装和可以安装的程序包yum list package1 #显示指定程序包安装情况package1yum groupinfo group1 #显示程序组group1信息yum search string 根据关键字string查找安装包删除程序yum remove &amp;#124; erase package1 #删除程序包package1yum groupremove group1 #删除程序组group1yum deplist package1 #查看程序package1依赖情况 三：启动MySQL服务1.启动1systemctl start mysqld 命令笔记：123456789101112systemctl是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。任务 旧指令 新指令使某服务自动启动 chkconfig --level 3 httpd on systemctl enable httpd.service使某服务不自动启动 chkconfig --level 3 httpd off systemctl disable httpd.service检查服务状态 service httpd status systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active)显示所有已启动的服务 chkconfig --list systemctl list-units --type=service启动某服务 service httpd start systemctl start httpd.service停止某服务 service httpd stop systemctl stop httpd.service重启某服务 service httpd restart systemctl restart httpd.service 2.查看状态1234567891011121314151617查看MySQL的启动状态systemctl status mysqld输出：● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2018-03-07 21:14:55 CST; 18min ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 17338 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 17320 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 17343 (mysqld) CGroup: /system.slice/mysqld.service └─17343 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidMar 07 21:14:54 VM_0_8_centos systemd[1]: Starting MySQL Server...Mar 07 21:14:55 VM_0_8_centos systemd[1]: Started MySQL Server. 3.开机启动12systemctl enable mysqldsystemctl daemon-reload 4.修改root本地登录密码12345678910111213141516171819202122232425mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：1. 修改密码策略 mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误 步骤1：不需要密码策略，添加/etc/my.cnf件中添加如下配置禁用即可： validate_password = off 步骤2：重新启动mysql服务使配置生效： systemctl restart mysqld 2. 查看初始密码： grep 'temporary password' /var/log/mysqld.log 输出： 2018-03-07T13:01:08.963552Z 1 [Note] A temporary password is generated for root@localhost: zktt1wKFD.HN 得到临时密码: zktt1wKFD.HN3. 登录mysql: mysql -uroot -p 输入临时密码进入mysql命令行4. 修改密码 set password for 'root'@'localhost'=password('MyNewPass4!'); 5. 重启服务 systemctl restart mysqld 四：开启远程连接1234567891011121314151617181920登入mysql mysql -uroot -p 使用mysql数据库 use mysql; 开启远程连接（root 用户名，% 所有人都可以访问 ，password 密码） GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION; 也可以添加一个新用户: GRANT ALL PRIVILEGES ON *.* TO 'shuiyang'@'%' IDENTIFIED BY 'password!' WITH GRANT OPTION; FLUSH PRIVILEGES; 重起mysql服务 service mysqld restart如果执行完以上步骤，还是不能远程连接，那么我们需要查看服务器的防火墙是否开启 service iptables status如果防火墙开启，请关闭 service iptables stop 五：配置默认编码为utf812345678910111213141516171819202122修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：[mysqld]character_set_server=utf8init_connect='SET NAMES utf8'重新启动mysql服务，查看数据库默认编码如下所示：mysql&gt; show variables like '%character%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 备注：12345默认配置文件路径： 配置文件：/etc/my.cnf 日志文件：/var/log//var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid 转载：https://www.linuxidc.com/Linux/2016-09/135288.htm转载:http://blog.csdn.net/sun614345456/article/details/53672150","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"百度富文本框编辑器Ueditor的使用","slug":"backend/other/百度富文本框编辑器Ueditor的使用","date":"2018-03-05T14:54:12.000Z","updated":"2018-03-05T15:40:04.825Z","comments":true,"path":"2018/03/05/backend/other/百度富文本框编辑器Ueditor的使用/","link":"","permalink":"http://www.songshuiyang.site/2018/03/05/backend/other/百度富文本框编辑器Ueditor的使用/","excerpt":"百度富文本框编辑器：官网： http://ueditor.baidu.com/website/ 官网演示地址：http://ueditor.baidu.com/website/onlinedemo.html UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码…","text":"百度富文本框编辑器：官网： http://ueditor.baidu.com/website/ 官网演示地址：http://ueditor.baidu.com/website/onlinedemo.html UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码… 开始使用：参考:http://fex.baidu.com/ueditor/ 1. 入门部署和体验1.1下载编辑器到官网下载 UEditor 最新版：[官网地址] 1.2创建demo文件解压下载的包，在解压后的目录创建 demo.html 文件，填入下面的html代码 123456789101112131415161718192021222324&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ueditor demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 加载编辑器的容器 --&gt; &lt;script id=\"container\" name=\"content\" type=\"text/plain\"&gt; 这里写你的初始化内容 &lt;/script&gt; &lt;!-- 配置文件 --&gt; &lt;script type=\"text/javascript\" src=\"ueditor.config.js\"&gt;&lt;/script&gt; &lt;!-- 编辑器源码文件 --&gt; &lt;script type=\"text/javascript\" src=\"ueditor.all.js\"&gt;&lt;/script&gt; &lt;!-- 实例化编辑器 --&gt; &lt;script type=\"text/javascript\"&gt; var ue = UE.getEditor('container'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.3 在浏览器打开demo.html如果看到了编辑器，恭喜你，初次部署成功！ 2. 整合jsp后端配置2.1 下载 jsp 版本完整包下载地址: http://ueditor.baidu.com/website/download.html 选择 [1.4.3.3 Jsp 版本] 2.2 下载之后会得到如下文件按照官网上的做法是把文件copy到webapp跟目录下 , 但我们是集成ueditor, 肯定不是放在根目录下, 所以我们把文件都复制到 webapp/static/plugins/ueditor 下, 方便管理 logo 2.3 前台代码集成2.3.1 在需要集成ueditor的页面添加如下代码, 如果能看到编辑器则说明配置成功12345678910111213141516171819202122232425&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ueditor demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"$&#123;ctx&#125;static/plugins/ueditor/lang/zh-cn/zh-cn.js\" media=\"all\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 加载编辑器的容器 --&gt; &lt;script id=\"container\" name=\"content\" type=\"text/plain\"&gt; 这里写你的初始化内容 &lt;/script&gt; &lt;!-- 配置文件 --&gt; &lt;script type=\"text/javascript\" src=\"$&#123;ctx&#125;static/plugins/ueditor/ueditor.config.js\"&gt;&lt;/script&gt; &lt;!-- 编辑器源码文件 --&gt; &lt;script type=\"text/javascript\" src=\"$&#123;ctx&#125;static/plugins/ueditor/ueditor.all.js\"&gt;&lt;/script&gt; &lt;!-- 实例化编辑器 --&gt; &lt;script type=\"text/javascript\"&gt; var ueditor = UE.getEditor('container'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 获取编辑器内容123var ueditor = UE.getEditor('container');var content = ueditor.getContent(content); 设置编辑器内容12345// 等UEditor创建完成就使用UEditor的setContent函数var ueditor = UE.getEditor('container');ueditor.ready(function() &#123; ueditor.setContent(content);&#125;); 有了这些你可以处理一些普通文字, 但如果是要文件上传,图片上传,视频上传这些功能你就要进行一些后台代码的配置 2.4 后台代码集成后台环境： Spring + Spring Mvc + Mybatis + Maven 2.4.1 配置 ueditor.config.js原配置:1234567891011121314var URL = window.UEDITOR_HOME_URL || getUEBasePath();/** * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。 */window.UEDITOR_CONFIG = &#123; //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL // 服务器统一请求接口路径 , serverUrl: URL + \"jsp/controller.jsp\" //工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的重新定义 修改后的配置：1234567891011121314window.UEDITOR_HOME_URL = \"/static/plugins/ueditor/\";var URL = window.UEDITOR_HOME_URL || getUEBasePath();/** * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。 */window.UEDITOR_CONFIG = &#123; //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL // 服务器统一请求接口路径 , serverUrl: \"/ueditor/ueditorAction\" 主要是 window.UEDITOR_HOME_URL 这个参数赋值成自己的ueditor的文件路径 修改 服务器统一请求接口路径 /ueditor/ueditorAction , 这样Ueditor后台服务接口就会请求到这个接口中来 2.4.2 新增后台服务接口第一步： 导入jar包, 我是只添加了最后俩个包，其他的包可以通过maven的形式导入，copy 这俩个包放到WEBINF/lib目录下, 然后配置Maven依赖 logo 注：使用maven构建项目的时候需要进行如下配置, 这样maven构建的时候才不会报找不到lib目录下jar包的错误1234567&lt;dependency&gt; &lt;groupId&gt;json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib/json.jar&lt;/systemPath&gt;&lt;/dependency&gt; 第二步：新建 后台统一服务接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * Ueditor 后台统一服务接口 * @author songshuiyang * @date 2018/3/4 18:11 */@Controller@RequestMapping(\"/ueditor\")public class UEditorController extends BaseController &#123; private HttpServletRequest request = null; private String actionType = null; private ConfigManager configManager = null; @RequestMapping(value = \"ueditorAction\", method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) @ResponseBody public JSONObject exec (@RequestParam String action, HttpServletRequest request) &#123; String result; this.actionType = action; this.request = request; String rootPath = request.getSession().getServletContext().getRealPath(\"/\"); String contextPath = request.getContextPath(); this.configManager = ConfigManager.getInstance( rootPath, contextPath,\"/static/plugins/ueditor/jsp/controller.jsp\"); String callbackName = this.request.getParameter(\"callback\"); if ( callbackName != null ) &#123; result = !validCallbackName( callbackName ) ? new BaseState( false, AppInfo.ILLEGAL ).toJSONString() : callbackName+\"(\"+this.invoke()+\");\"; &#125; else &#123; result = this.invoke(); &#125; return JSONObject.fromObject(result); &#125; public String invoke() &#123; if ( actionType == null || !ActionMap.mapping.containsKey( actionType ) ) &#123; return new BaseState( false, AppInfo.INVALID_ACTION ).toJSONString(); &#125; if ( this.configManager == null || !this.configManager.valid() ) &#123; return new BaseState( false, AppInfo.CONFIG_ERROR ).toJSONString(); &#125; State state = null; int actionCode = ActionMap.getType( this.actionType ); Map&lt;String, Object&gt; conf; switch ( actionCode ) &#123; case ActionMap.CONFIG: return this.configManager.getAllConfig().toString(); case ActionMap.UPLOAD_IMAGE: case ActionMap.UPLOAD_SCRAWL: case ActionMap.UPLOAD_VIDEO: case ActionMap.UPLOAD_FILE: conf = this.configManager.getConfig( actionCode ); state = new Uploader( request, conf ).doExec(); break; case ActionMap.CATCH_IMAGE: conf = configManager.getConfig( actionCode ); String[] list = this.request.getParameterValues( (String)conf.get( \"fieldName\" ) ); state = new ImageHunter( conf ).capture( list ); break; case ActionMap.LIST_IMAGE: case ActionMap.LIST_FILE: conf = configManager.getConfig( actionCode ); int start = this.getStartIndex(); state = new FileManager( conf ).listFile( start ); break; &#125; assert state != null; return state.toJSONString(); &#125; private int getStartIndex () &#123; String start = this.request.getParameter( \"start\" ); try &#123; return Integer.parseInt( start ); &#125; catch ( Exception e ) &#123; return 0; &#125; &#125; /** * callback参数验证 * @param name 名字 * @return boolean */ private boolean validCallbackName ( String name ) &#123; return name.matches( \"^[a-zA-Z_]+[\\\\w0-9_]*$\" ); &#125;&#125; 一： 初始化ueditor的时候, ueditor会访问该接口, 此时action 参数是 config , 该接口会返回其/static/plugins/ueditor/jsp/config.json 配置的json参数，这些参数配置了上传功能的一些参数, 通过这些配置你可以DIY上传功能, ueditor获取到这些参数之后就可以使用上传功能了,否则你上传文件会提示： 后端配置项没有正常加载，上传插件不能正常使用！ 配置主要包括： 上传图片配置项 涂鸦图片上传配置项 截图工具上传 抓取远程图片配置 上传视频配置 上传文件配置 二： 如要上传图片, ueditor会访问该接口, 此时action 参数是 uploadimage ，则会执行上传图片操作, 上传成功后会返回123456&#123; \"state\": \"SUCCESS\", \"url\": \"upload/demo.jpg\", \"title\": \"demo.jpg\", \"original\": \"demo.jpg\"&#125; 三：由于系统文件上传使用的是阿里云的OSS所以需要将文件上传转到OSS处理上 前台配置：1234567891011121314151617&lt;script type=\"text/javascript\"&gt; // 当action是如下时，访问自己定义的服务接口 UE.Editor.prototype._bkGetActionUrl=UE.Editor.prototype.getActionUrl; UE.Editor.prototype.getActionUrl=function(action)&#123; // 上传图片, 文件, 视频 if (action == 'uploadimage' || action == 'uploadfile' || action == 'uploadvideo') &#123; return '/file/uploadLocal'; &#125; else if( action== 'uploadscrawl')&#123; // 上传涂鸦，涂鸦请求是Base64字符需要请求另外的接口 return '/file/uploadScrawl'; &#125; else if(action == 'listimage')&#123; return this._bkGetActionUrl.call(this, action); &#125; else&#123; return this._bkGetActionUrl.call(this, action); &#125; &#125; var ueditor = UE.getEditor('ueditorContainer');&lt;/script&gt; 后台接口：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.ecut.admin.controller;import com.aliyun.oss.ClientException;import com.aliyun.oss.OSSException;import com.ecut.admin.entity.OssFile;import com.ecut.admin.entity.UeditorState;import com.ecut.admin.service.impl.FileServiceImpl;import com.ecut.core.base.BaseController;import com.ecut.core.utils.Base64Utils;import com.ecut.core.utils.MessageUtils;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import java.io.ByteArrayInputStream;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import static com.ecut.core.utils.MessageUtils.success;/** * 阿里云OSS文件上传控制器 * @author songshuiyang * @date 2018/2/11 20:22 */@Controller@RequestMapping(\"/file\")public class FileController extends BaseController &#123; private final Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private FileServiceImpl fileServiceImpl; /** * 文件上传 * produces=\"application/json;charset=UTF-8 解决服务器返回406问题 * @param file * @return * @throws OSSException * @throws ClientException * @throws IOException */ @RequestMapping(value = \"/uploadLocal\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\") @ResponseBody public UeditorState uploadLocalFile(@RequestParam(value = \"upfile\",required = false) MultipartFile file) throws OSSException, ClientException, IOException &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(); OssFile file1 = fileServiceImpl.uploadFileByMultipartFile(file); UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName()); return ueditorState; &#125; /** * 上传涂鸦照片 * @param upfile * @return * @throws Exception */ @RequestMapping(value = \"/uploadScrawl\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\") @ResponseBody public UeditorState uploadscrawl(String upfile) throws Exception &#123; byte [] bytes= Base64Utils.decode(upfile); InputStream inputStream = new ByteArrayInputStream(bytes); String fileType = \"image/png\"; Long fileSize = new Long((long)bytes.length); String fileName = \"scrawl\" + System.currentTimeMillis() + \".png\"; String extensionName = \"png\"; OssFile file1 = fileServiceImpl.uploadFileByInputStream(inputStream, fileType,fileSize,fileName,extensionName); UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName()); return ueditorState; &#125;&#125; 2.4.3 问题集合解决百度ueditor富文本编辑器不能插入视频的问题/src掉链/src清空，不能显示视频转载：http://blog.csdn.net/qq_34787830/article/details/75092347 直接下载到的百度富文本编辑器当插入视频的时候会自动清掉src，不显示视频造成这样的原因是:百度富文本编辑器的过滤器xssFilter导致插入视频异常，编辑器在切换源码的过程中过滤掉img的_url属性（用来存储视频url） 解决办法: 1.在配置文件ueditor.config.js中，定位 //xss过滤白名单，即,whitList:{ }，对 img: 增加 “_url” 属性： 在下面的 video 标签后面新增3给标签，使Ueditor分别能支持embed标签和iframe标签：1234567source: ['src', 'type'],embed: ['type', 'class', 'pluginspage', 'src', 'width', 'height', 'align', 'style', 'wmode', 'play', + 'autoplay','loop', 'menu', 'allowscriptaccess', 'allowfullscreen', 'controls', 'preload'],iframe: ['src', 'class', 'height', 'width', 'max-width', 'max-height', 'align', 'frameborder', 'allowfullscreen']","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"基于wordspress搭建个人博客系统","slug":"backend/other/基于wordspress搭建个人博客系统","date":"2018-03-04T12:54:12.000Z","updated":"2018-03-04T08:10:13.375Z","comments":true,"path":"2018/03/04/backend/other/基于wordspress搭建个人博客系统/","link":"","permalink":"http://www.songshuiyang.site/2018/03/04/backend/other/基于wordspress搭建个人博客系统/","excerpt":"什么是Wordspress：官网： https://cn.wordpress.org/ 提供了中英版 WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。 WordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。 WordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的标准通用标记语言下的一个应用HTML代码、CSS、PHP等相关知识。 WordPress官方支持中文版，同时有爱好者开发的第三方中文语言包，如wopus中文语言包。WordPress拥有成千上万个各式插件和不计其数的主题模板样式。","text":"什么是Wordspress：官网： https://cn.wordpress.org/ 提供了中英版 WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。 WordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。 WordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的标准通用标记语言下的一个应用HTML代码、CSS、PHP等相关知识。 WordPress官方支持中文版，同时有爱好者开发的第三方中文语言包，如wopus中文语言包。WordPress拥有成千上万个各式插件和不计其数的主题模板样式。 搭建教程：参考下面的帖子写的十分详细 https://www.jianshu.com/p/56750622cac9 LNMP一键安装包LNMP一键安装包是一个用Linux Shell编写的可以为CentOS/RHEL/Fedora/Aliyun/Amazon、Debian/Ubuntu/Raspbian/Deepin/Mint Linux VPS或独立主机安装LNMP(Nginx/MySQL/PHP)、LNMPA(Nginx/MySQL/PHP/Apache)、LAMP(Apache/MySQL/PHP)生产环境的Shell程序。https://lnmp.org/","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Mysql 数据类型","slug":"backend/database/Mysql 数据类型","date":"2018-03-03T03:15:12.000Z","updated":"2018-12-06T12:28:47.873Z","comments":true,"path":"2018/03/03/backend/database/Mysql 数据类型/","link":"","permalink":"http://www.songshuiyang.site/2018/03/03/backend/database/Mysql 数据类型/","excerpt":"MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。","text":"MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 logo 备注:1.BIT[M] 位字段类型，M表示每个值的位数，范围从1到64，如果M被忽略，默认为1 2.TINYINT[(M)] [UNSIGNED] [ZEROFILL] M默认为4,占1个字节 很小的整数。带符号的范围是-128到127。无符号的范围是0到255。 BOOL，BOOLEAN 是TINYINT(1)的同义词。zero值被视为假。非zero值视为真。 4.SMALLINT[(M)] [UNSIGNED] [ZEROFILL] M默认为6,占2个字节 小的整数。带符号的范围是-32768到32767。无符号的范围是0到65535。 5.MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] M默认为9,占3个字节 中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。 INT[(M)] [UNSIGNED] [ZEROFILL] M默认为11,占4个字节 普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。 7.BIGINT[(M)] [UNSIGNED] [ZEROFILL] M默认为20,占8个字节 大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。 注意：这里的M代表的并不是存储在数据库中的具体的长度，以前总是会误以为int(3)只能存储3个长度的数字，int(11)就会存储11个长度的数字，这是大错特错的。 tinyint(1) 和 tinyint(4) 中的1和4并不表示存储长度，只有字段指定zerofill是有用，如tinyint(4)，如果实际值是2，如果列指定了zerofill，查询结果就是0002，左边用0来填充。 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性 logo 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型 logo","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"db","slug":"db","permalink":"http://www.songshuiyang.site/tags/db/"}]},{"title":"animate.css","slug":"frontend/animate","date":"2018-03-03T02:52:12.000Z","updated":"2018-03-20T15:06:43.836Z","comments":true,"path":"2018/03/03/frontend/animate/","link":"","permalink":"http://www.songshuiyang.site/2018/03/03/frontend/animate/","excerpt":"","text":"一 前言:背景：在看其他人的项目的时候发现其动画效果做的不错，通过看人家的代码发现用了这个animate.css这个css组件，使用起来也是特别的方便，所以就把他copy到项目中来了，顿时档次就上升了 简介:animate.css 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。而且使用起来也是特别方便 官网传送门: https://daneden.github.io/animate.css/ 在官网上有示例动画，主页也十分简洁，同时也提供了代码下载, 也可以看看这篇博客写的例子 https://www.cnblogs.com/xiaohuochai/p/7372665.html 二 如何使用：步骤： 在官网上下载 animate.css , 把他导入到项目中来, 也可以使用cdn https://unpkg.com/animate.css@3.5.2/animate.min.css 代码示例 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/animate.css@3.5.2/animate.min.css\"&gt; &lt;style&gt; .box&#123;height: 100px;width: 100px;background-color: lightblue&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box animated flash\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 只要在元素中class 添加 animated 和相应的动画class名就可以实现动画效果, 当然也可以通过js动态设置class","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.songshuiyang.site/tags/css/"}]},{"title":"Spring mvc 前后台传值中文乱码问题","slug":"backend/framework/spring/spring-mvc/Spring mvc 中文乱码问题","date":"2018-02-28T13:49:44.000Z","updated":"2018-02-28T13:57:02.600Z","comments":true,"path":"2018/02/28/backend/framework/spring/spring-mvc/Spring mvc 中文乱码问题/","link":"","permalink":"http://www.songshuiyang.site/2018/02/28/backend/framework/spring/spring-mvc/Spring mvc 中文乱码问题/","excerpt":"一： 解决GET请求参数到了后台中文乱码问题 方式一: 修改tomcat配置, 暂时做法，没有找到更好的解决办法，换了tomcat了又要重新配置123把tomcat下，server.xml下，添加如下配置，就解决了． &lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 方式二: 自定义filter, 解决了get请求中文参数问题，但post请求参数到了后台就gg了","text":"一： 解决GET请求参数到了后台中文乱码问题 方式一: 修改tomcat配置, 暂时做法，没有找到更好的解决办法，换了tomcat了又要重新配置123把tomcat下，server.xml下，添加如下配置，就解决了． &lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 方式二: 自定义filter, 解决了get请求中文参数问题，但post请求参数到了后台就gg了 新建 CustomEncodingFilter.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.ecut.core.web.filter;import org.springframework.cglib.proxy.InvocationHandler;import org.springframework.cglib.proxy.Proxy;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.lang.reflect.Method;public class CustomEncodingFilter extends OncePerRequestFilter &#123; private String encoding; public void setEncoding(String encoding) &#123; this.encoding = encoding; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 设置请求响应字符编码 request.setCharacterEncoding(encoding); response.setCharacterEncoding(encoding); // 传递给目标servlet或jsp的实际上是动态代理的对象，而不是原始的HttpServletRequest对象 request = (HttpServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(), request.getClass().getInterfaces(), new MyInvacationHandler(request)); chain.doFilter(request, response); &#125; class MyInvacationHandler implements InvocationHandler &#123; private HttpServletRequest request; MyInvacationHandler(HttpServletRequest request)&#123; this.request=request; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; switch (method.getName()) &#123; case \"getParameter\": String value = request.getParameter((String)args[0]); try &#123; if(value != null)&#123; value=new String(value.getBytes(\"ISO-8859-1\"),encoding); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return value; case \"getParameterValues\": String[] values = request.getParameterValues((String)args[0]); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; values[i] = new String(values[i].getBytes(\"ISO-8859-1\"),encoding); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return values; default: return method.invoke(request, args); &#125; &#125; &#125;&#125; 配置web.xml 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.ecut.core.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 二： 解决POST请求参数到了后台中文乱码问题1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"阿里巴巴Java编程规范","slug":"backend/java/standard/阿里巴巴Java编程规范","date":"2018-02-13T01:54:12.000Z","updated":"2018-02-26T12:34:49.085Z","comments":true,"path":"2018/02/13/backend/java/standard/阿里巴巴Java编程规范/","link":"","permalink":"http://www.songshuiyang.site/2018/02/13/backend/java/standard/阿里巴巴Java编程规范/","excerpt":"前言：关于《阿里巴巴Java开发手册》 你是否曾因Java代码规范版本纷杂而无所适从？ 你是否想过代码规范能将系统故障率降低20%？ 你是否曾因团队代码风格迥异而协同困难？ 你是否正在review一些原本可以避免的故障？ 你是否无法确定自己的代码足够健壮？","text":"前言：关于《阿里巴巴Java开发手册》 你是否曾因Java代码规范版本纷杂而无所适从？ 你是否想过代码规范能将系统故障率降低20%？ 你是否曾因团队代码风格迥异而协同困难？ 你是否正在review一些原本可以避免的故障？ 你是否无法确定自己的代码足够健壮？ 码出高效，码出质量！相比C++代码规范业界已经达成共识，Java代码规范业界比较混乱，我们期待这次发布的Java代码规范能够给业界带来一个标准，促使整体行业代码规范水平得到提高，最终能够帮助企业和开发者提升代码质量和降低代码故障率。 阿里出品，质量保证！阿里Java技术团队一手打造出Dubbo、JStorm、Fastjson等诸多流行开源框架，部分已成为Apache基金会孵化项目； 阿里在Java后端领域支撑起全球访问量最大的服务器集群； Java代码构建的阿里双11业务系统订单处理能力达到17.5万笔/秒； 到目前已累计数亿行高并发、高稳定性的最佳Java代码实践； …… 此次公开的Java开发手册正是出自这样的团队，近万名阿里Java技术精英的经验总结，并经历了多次大规模一线实战检验及完善，铸就了这本高含金量的阿里Java开发手册。该手册以Java开发者为中心视角，划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱和故障敏感性，规约依次分为强制、推荐、参考三大类。此套规范不仅能让代码一目了然， 更有助于加强团队分工与合作、真正提升效率。 无规矩不成方圆 无规范不能协作众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有规定靠右行驶，谁还敢上路行驶。 同理，对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，降低故障率，提升协作效率。开发手册详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，提高代码质量。比如，异常日志处理时的各种不规范行为；集合转换的各种坑；创建线程池出现的等待队列OOM等。 阿里技术资深大咖联袂推荐阿里高级研究员多隆：工程师对于代码，一定要“精益求精”，不论从性能，还是简洁优雅，都要具备“精益求精”的工匠精神，认真打磨自己的作品。 阿里研究员毕玄：一个优秀的工程师和一个普通工程师的区别，不是现在满天飞的架构图，他的功底就是体现在他写的每一行代码上。 阿里研究员玄难：代码是软件工程里面的产品设计、系统架构设计等工作的最后承载体，代码的质量决定了一切工作的成败。 阿里巴巴B2B事业群CTO李纯：好的软件产品离不开工程师高质量的代码及相互间顺畅的沟通与合作。简单，适用的代码规约背后所传递的是技术上的追求卓越、协同合作的精神，是每个技术团队不可缺失的重要利器。 阿里研究员、HipHop作者：赵海平（花名：福贝）：程序员是创造个性化作品的艺术家，但同时也是需要团队合作的工种。个性化应尽量表现在代码效率和算法方面，牺牲小我，成就大我。 拥抱规范，远离伤害！开发的同学们赶紧行动起来，遵守代码规范，你好，我好，大家好！ 传送门 原文: https://yq.aliyun.com/articles/69327?spm=5176.100239.blogcont69327.158.xUUgiz&amp;p=2#comments 「阿里巴巴编码规范」考试认证 : https://edu.aliyun.com/certification/cldt02 点击下载《阿里巴巴Java开发手册》(纪念版): https://yq.aliyun.com/attachment/download/?id=4942 IDE插件下载 : https://github.com/alibaba/p3c 以下记录以下自己需要注意的一些规范, 遵守代码规范，你好，我好，大家好！编程规约命名风格 【强制】 抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT 反例： MAX_COUNT 【强制】 POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 反例： 定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted()， RPC 框架在反向解析的时候， “以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异 常。 【强制】杜绝完全不规范的缩写， 避免望文不知义。 反例： AbstractClass“缩写” 命名成 AbsClass； condition“缩写” 命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。 正例： 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。 反例： 变量 int a; 的随意命名方式。 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 正例： 接口方法签名： void f(); 接口基础常量表示： String COMPANY = “alibaba”; 反例： 接口方法定义： public abstract void f(); 说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 正例： 枚举名字为 ProcessStatusEnum 的成员名称： SUCCESS / UNKOWN_REASON。 【参考】各层命名规约： A) Service/DAO 层方法命名规约 1） 获取单个对象的方法用 get 做前缀。 2） 获取多个对象的方法用 list 做前缀。 3） 获取统计值的方法用 count 做前缀。 4） 插入的方法用 save/insert 做前缀。 5） 删除的方法用 remove/delete 做前缀。 6） 修改的方法用 update 做前缀。 B) 领域模型命名规约 1） 数据对象： xxxDO， xxx 即为数据表名。 2） 数据传输对象： xxxDTO， xxx 为业务领域相关的名称。 3） 展示对象： xxxVO， xxx 一般为网页名称。 4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 常量定义 【强制】不允许任何魔法值（即未经定义的常量） 直接出现在代码中。 反例： String key = “Id#taobao_” + tradeId; cache.put(key, value); 【推荐】不要使用一个常量类维护所有常量， 按常量功能进行归类，分开维护。 说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 正例： 缓存相关常量放在类 CacheConsts 下； 系统配置相关常量放在类 ConfigConsts 下。 代码格式1.示例 123456789101112131415161718public static void main(String[] args) &#123; // 缩进 4 个空格 String say = \"hello\"; // 运算符的左右必须有一个空格 int flag = 0;阿里巴巴 Java 开发手册 // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号， 0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println(\"world\"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(\"ok\"); // 在右大括号后直接结束，则必须换行 &#125;&#125; 2.【强制】 注释的双斜线与注释内容之间有且仅有一个空格。 正例： // 注释内容， 注意在//和注释内容之间有一个空格。 3.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则： 1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。 2） 运算符与下文一起换行。 3） 方法调用的点符号与下文一起换行。 4） 方法调用时，多个参数， 需要换行时， 在逗号后进行。 5） 在括号前不要换行，见反例。 正例：123456StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，换行缩进 4 个空格， 点号和方法名称一起换行sb.append(\"zi\").append(\"xin\")... .append(\"huang\")... .append(\"huang\")... .append(\"huang\"); 反例： 1234567StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，不要在括号前换行sb.append(\"zi\").append(\"xin\")...append (\"huang\");// 参数很多的方法调用可能超过 120 个字符， 不要在逗号前换行method(args1, args2, args3, ... , argsX); 4.【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例： 下例中实参的”a”,后边必须要有一个空格。 method(“a”, “b”, “c”);5.【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义 之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。 说明： 没有必要插入多个空行进行隔开 注释规范 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用// xxx 方式。 说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率 【强制】所有的抽象方法（包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明： 对子类的实现要求，或者调用注意事项，请一并说明 【强制】所有的类都必须添加创建者和创建日期。 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1） 待办事宜（TODO） :（标记人，标记时间， [预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签） 。2） 错误，不能工作（FIXME） :（标记人，标记时间， [预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 异常处理 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 MySQL 数据库 建表规约1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是， 0 表示否） 。 说明： 任何字段如果为非负数，必须是 unsigned。 正例： 表达逻辑删除的字段名 is_deleted， 1 表示删除， 0 表示未删除 2.【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。3.【强制】表必备三字段： id, gmt_create, gmt_modified。 说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。 gmt_create,gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被 动更新4.【推荐】表的命名最好是加上“业务名称表的作用”。 正例： alipay_task / force_project / trade_config5.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明： 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生6.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致； 多表关联查询时， 保证被关联的字段需要有索引。 说明： 即使双表 join 也要注意表索引、 SQL 性能 MySQL 数据库 SQL语句 【强制】不要使用 count(列名)或 count(常量)来替代 count()， count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"解决CSS和JS文件的客户端缓存问题","slug":"frontend/CSS和JS文件的客户端缓存问题","date":"2018-02-10T03:48:12.000Z","updated":"2018-02-26T12:31:58.890Z","comments":true,"path":"2018/02/10/frontend/CSS和JS文件的客户端缓存问题/","link":"","permalink":"http://www.songshuiyang.site/2018/02/10/frontend/CSS和JS文件的客户端缓存问题/","excerpt":"","text":"场景做项目的时候，发现自己修改了一个css文件但样式并没有应用，查看http请求(如下图)，注意这个参数Status Code:200 OK (from disk cache) , 说明文件是是之前浏览器缓存的文件，浏览器并没有请求我们新改的文件1234Request URL:http://localhost:8080/static/layui/build/css/app.cssRequest Method:GETStatus Code:200 OK (from disk cache)Remote Address:127.0.0.1:8080Referrer Policy:no-referrer-when-downgrade 解决方法 发现问题了，现在就是要解决如果是服务器js css等文件修改了，怎样让浏览器能够请求我们最新的文件, 通过查看其他人的解决方法，还有看了一下大厂百度, 淘宝 , 新浪 对这个问题的处理，总结了一下下面几种方法: 方法一: 在css文件上, js文件后面加上版本号?v=12453651&lt;link rel=\"stylesheet\" href=\"$&#123;ctx&#125;static/admin/css/main.css?v=1245365\" media=\"all\" /&gt; 如果是经常更新的css文件版本号可以取当前时间的时间戳 v=1518237859338 ,这样就可以每次都获取到最新的文件，但缺点就是每次刷新页面都会请求该文件，在项目开发过程中可以使用这种方式 如果是更新频率不高的的文件，可以取: v=20180210 , 这样的话刷新页面就不会每次请求这个文件了，可以减轻服务器的压力 如果是项目稳定了基本没有改动了，可以取一个固定值:v=0.0.1 方法二：一个版本一个文件夹 淘宝的做法: 用一个文件 6.2.31https://g.alicdn.com/kg/??component/6.2.3/extension/content-box/xtpl/view.xtpl-min.js","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"js","slug":"js","permalink":"http://www.songshuiyang.site/tags/js/"},{"name":"css","slug":"css","permalink":"http://www.songshuiyang.site/tags/css/"}]},{"title":"生成二维码图片(base64格式)","slug":"backend/other/生成二维码图片(base64格式)","date":"2018-01-29T13:00:12.000Z","updated":"2018-02-26T12:31:59.906Z","comments":true,"path":"2018/01/29/backend/other/生成二维码图片(base64格式)/","link":"","permalink":"http://www.songshuiyang.site/2018/01/29/backend/other/生成二维码图片(base64格式)/","excerpt":"生成二维码图片(base64格式)","text":"生成二维码图片(base64格式) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.guangeryi.mall.payment.weixin;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.client.j2se.MatrixToImageWriter;import com.google.zxing.common.BitMatrix;import org.apache.commons.codec.binary.Base64;import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.Hashtable;import java.util.Map;public class QRCodeUtils &#123; /** * 生成二维码 Base64编码后字符串 * * @param contents 内容 */ public static String encodeQRCodeBase64(String contents) &#123; return encodeQRCodeToBase64Str(contents); &#125; /** * 生成二维码 Base64编码后字符串 &lt;img src=''&gt; src填入该字符串显示图片 * （高度:300 , 宽度:300） * @param contents 内容 */ private static String encodeQRCodeToBase64Str(String contents) &#123; int width = WxPcPayConfigImpl.QR_IMG_WIDTH; int height = WxPcPayConfigImpl.QR_IMG_HEIGHT; Map&lt;EncodeHintType, Object&gt; hints = new Hashtable&lt;&gt;(); String base64Img = \"data:image/png;base64,\"; // 指定编码格式 hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\"); try &#123; // 生成输出流 BitMatrix bitMatrix1 = new MultiFormatWriter().encode(contents, BarcodeFormat.QR_CODE, width, height, hints); BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix1); base64Img = base64Img + encodeToString(\"png\", image); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return base64Img; &#125; /** * 将图片转换成base64格式进行存储 * * @param formatName 文件格式 * @param image 图片流 * @return base64字符串 */ private static String encodeToString(String formatName, BufferedImage image) &#123; String imageString = null; try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) &#123; ImageIO.write(image, formatName, bos); byte[] imageBytes = bos.toByteArray(); imageString = new String(Base64.encodeBase64(imageBytes)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return imageString; &#125; public static void main(String[] args) &#123; // 输出在img标签中img属性中 System.out.println(encodeQRCodeBase64(\"你好\")); &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"根据手机区号获取城市地理位置","slug":"backend/other/根据手机区号获取城市地理位置","date":"2018-01-29T12:55:12.000Z","updated":"2018-02-26T12:31:59.863Z","comments":true,"path":"2018/01/29/backend/other/根据手机区号获取城市地理位置/","link":"","permalink":"http://www.songshuiyang.site/2018/01/29/backend/other/根据手机区号获取城市地理位置/","excerpt":"根据手机区号获取城市地理位置httpAPI: http://www.ip138.com:8080/search.asp?action=mobile&amp;mobile=%s","text":"根据手机区号获取城市地理位置httpAPI: http://www.ip138.com:8080/search.asp?action=mobile&amp;mobile=%s 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.guangeryi.mall.third.common;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.select.Elements;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.HashMap;import java.util.Map;public class MobileLocationUtils &#123; private final static Logger logger = LoggerFactory.getLogger(MobileLocationUtils.class); /** * 根据手机号获取所在地信息 * @param mobile 手机号码 * @return 返回map */ public static Map&lt;String,Object&gt; getMobileAddress (String mobile) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); String returnStr= getMobileAddressUtils(mobile); // 将160号的空格转化成32号的空格 returnStr = returnStr.replaceAll(\"[\\\\u00A0]+\", \" \"); // 去空格 returnStr = returnStr.trim(); String [] address = returnStr.split(\"\\\\s+\"); String province = \"\";// 省 String city = \"\"; // 市 // 直辖市 if (address.length == 1) &#123; province = address[0]; city = address[0]; &#125; if (address.length == 2) &#123; province = address[0]; city = address[1]; &#125; map.put(\"province\", province); map.put(\"city\", city); logger.info(mobile + \" 手机号所在信息:\" + map); return map; &#125; public static String getMobileAddressUtils(String mobile)&#123; try &#123; String url = \"http://www.ip138.com:8080/search.asp?action=mobile&amp;mobile=%s\"; url = String.format(url, mobile); Document doc = Jsoup.connect(url).get(); Elements els = doc.getElementsByClass(\"tdc2\"); if(els.get(1).text().equals(\"mobile 不是数字! 验证手机号有误\") || els.get(1).text().equals(\"验证手机号有误\")) &#123; return \"未知\"; &#125; return els.get(1).text(); &#125; catch (Exception e) &#123; return \"未知\"; &#125; &#125; public static void main(String[] args) &#123; System.out.println(getMobileAddress(\"13117975845\")); &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"根据IP获取城市地理位置","slug":"backend/other/根据IP获取城市地理位置","date":"2018-01-29T12:54:12.000Z","updated":"2018-02-26T12:31:59.833Z","comments":true,"path":"2018/01/29/backend/other/根据IP获取城市地理位置/","link":"","permalink":"http://www.songshuiyang.site/2018/01/29/backend/other/根据IP获取城市地理位置/","excerpt":"根据IP获取城市地理位置使用的是百度查询的api，试过到淘宝的API, 但是淘宝做了访问次数限制，如果批量查询的话直接timeout","text":"根据IP获取城市地理位置使用的是百度查询的api，试过到淘宝的API, 但是淘宝做了访问次数限制，如果批量查询的话直接timeout 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.guangeryi.mall.third.common;import net.sf.json.JSONObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.*;import java.net.URL;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Map;/** * 根据IP获取城市地理位置 * 调用百度api：http://api.map.baidu.com/location/ip */public class IpUtils &#123; private final static Logger logger = LoggerFactory.getLogger(AddressUtils.class); /** * 根据ip获取城市信息 * @param ip * @return */ public static Map&lt;String, Object&gt; getCityInfoByIp(String ip)&#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(\"status\",\"success\"); String jsonInfo = null; try &#123; jsonInfo = getCityInfoByUrlAPI(ip); logger.info(\"jsonInfo:\" + jsonInfo); &#125; catch (IOException e) &#123; logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常, ip:\" + ip, e); result.put(\"status\",\"failed\"); return result; &#125; String province = \"\"; String city = \"\"; String district =\"\"; String street = \"\"; try &#123; JSONObject jsonObject = JSONObject.fromObject(jsonInfo); if (jsonObject != null) &#123; if (jsonObject.getJSONObject(\"content\") != null) &#123; JSONObject addressDetail = jsonObject.getJSONObject(\"content\").getJSONObject(\"address_detail\"); province = (String)addressDetail.get(\"province\"); // 省 city = (String)addressDetail.get(\"city\"); // 市 district = (String)addressDetail.get(\"district\"); // 区 street = (String)addressDetail.get(\"street\"); // 街道 &#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常,解析JSON异常 ip:\" + ip, e); result.put(\"status\",\"failed\"); return result; &#125; result.put(\"province\",province); result.put(\"city\",city); result.put(\"district\",district); result.put(\"street\",street); return result; &#125; /** * 调用 api.map.baidu.com/location/ip 获取城市信息 * @param ip * @return * @throws IOException */ private static String getCityInfoByUrlAPI(String ip) throws IOException &#123; String url = \"http://api.map.baidu.com/location/ip?ak=F454f8a5efe5e577997931cc01de3974&amp;ip=\" + ip; try (InputStream is = new URL(url).openStream()) &#123; BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\"))); String jsonText = getStrByReader(rd); jsonText = decodeUnicode(jsonText); return jsonText; &#125; &#125; /** * 获取流数据 * @param rd * @return * @throws IOException */ private static String getStrByReader(Reader rd) throws IOException &#123; StringBuilder sb = new StringBuilder(); int cp; while ((cp = rd.read()) != -1) &#123; sb.append((char) cp); &#125; return sb.toString(); &#125; /** * unicode 转换成 中文 * * @author fanhui 2007-3-15 * @param theString 字符串 * @return String */ private static String decodeUnicode(String theString) &#123; char aChar; int len = theString.length(); StringBuilder outBuilder = new StringBuilder(len); for (int x = 0; x &lt; len;) &#123; aChar = theString.charAt(x++); if (aChar == '\\\\') &#123; aChar = theString.charAt(x++); if (aChar == 'u') &#123; int value = 0; for (int i = 0; i &lt; 4; i++) &#123; aChar = theString.charAt(x++); switch (aChar) &#123; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': value = (value &lt;&lt; 4) + aChar - '0'; break; case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': value = (value &lt;&lt; 4) + 10 + aChar - 'a'; break; case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': value = (value &lt;&lt; 4) + 10 + aChar - 'A'; break; default: throw new IllegalArgumentException(\"Malformed encoding.\"); &#125; &#125; outBuilder.append((char) value); &#125; else &#123; if (aChar == 't') &#123; aChar = '\\t'; &#125; else if (aChar == 'r') &#123; aChar = '\\r'; &#125; else if (aChar == 'n') &#123; aChar = '\\n'; &#125; else if (aChar == 'f') &#123; aChar = '\\f'; &#125; outBuilder.append(aChar); &#125; &#125; else &#123; outBuilder.append(aChar); &#125; &#125; return outBuilder.toString(); &#125; public static void main(String[] args) &#123; System.out.println(getCityInfoByIp(\"118.212.211.23\")); &#125;&#125; 获取用户真实IP地址123456789101112131415161718192021222324252627282930313233343536/** * 获取用户真实IP地址，不使用request.getRemoteAddr()的原因是有可能用户使用了代理软件方式避免真实IP地址, * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值 */public static String getRemoteIp(HttpServletRequest request) &#123; String ip = request.getHeader(\"x-forwarded-for\"); if (ip != null &amp;&amp; ip.length() != 0 &amp;&amp; !\"unknown\".equalsIgnoreCase(ip)) &#123; // 多次反向代理后会有多个ip值，第一个ip才是真实ip if(ip.contains(\",\"))&#123; ip = ip.split(\",\")[0]; &#125; &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"Proxy-Client-IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"WL-Proxy-Client-IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"HTTP_CLIENT_IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"HTTP_X_FORWARDED_FOR\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"X-Real-IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; // TODO 本地测试使用 if (!isIpv4(ip)) &#123; ip= \"120.27.129.177\"; // 服务器ip &#125; return ip;&#125; 校验IP地址12345678910111213141516/** * 校验IP地址 * @param ipAddress IP 地址 * @return true or false */public static boolean isIpv4(String ipAddress) &#123; String ip = \"^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\" +\"(00?\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\" +\"(00?\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\" +\"(00?\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\"; Pattern pattern = Pattern.compile(ip); Matcher matcher = pattern.matcher(ipAddress); return matcher.matches();&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"阿里云服务器搭建Javaweb运行环境","slug":"backend/server/JavaEE服务器/阿里云服务器搭建Javaweb运行环境","date":"2018-01-20T07:07:12.000Z","updated":"2018-06-11T14:40:59.044Z","comments":true,"path":"2018/01/20/backend/server/JavaEE服务器/阿里云服务器搭建Javaweb运行环境/","link":"","permalink":"http://www.songshuiyang.site/2018/01/20/backend/server/JavaEE服务器/阿里云服务器搭建Javaweb运行环境/","excerpt":"","text":"一：前言借助阿里云的云翼计划的梯子买了个 阿里的ESC云服务器，学生专享优惠10块钱/月，原价一百多一个月，超级划算，当然服务器配置对于我们这些学生捣鼓捣鼓还是满足的。 配置： 配置 参数 CPU Intel Xeon E5-2682 v4 1核 内存 2G 最新一代DDR4 内存 带宽 1M带宽 VPC专有网络, I/O 优化 系统盘 40G系统盘高效云盘 系统：CentOS 7.3 64位(可选ubuntu, windows service) ESC: 云服务器 ECS（Elastic Compute Service）是一种弹性可伸缩的计算服务，助您降低 IT 成本，提升运维效率，使您更专注于核心业务创新 二：搭建步骤2.1 购买 ESC云服务器购买链接:https://www.aliyun.com/product/ecs?spm=5176.8499797.765261.239.9Uf4pK, 当然如果是学生的话可以使用上面的云翼计划(https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8789780.765430.4.246c0fa5bHX2oK)优惠的方式购买，当时购买还送了(CDN流量包)和(OSS资源包) , 良心企业!!! 2.2 查看系统参数，及配置参数下单完成之后在 控制台-&gt; 云服务器 ECS -&gt; 实例 可看到系统自动为我们创建的 服务器实例, 里面提供了一些系统参数，还展示了系统的一些运行状态参数。 我们需要的参数 1.公网ip 访问实例需要用 2.远程连接密码 这个在第一次使用浏览器远程连接主机的时候，阿里云会提供，记住只出现一次，可以用笔记本记录下来，以后每次用浏览器远程控制访问主机的时候需要提供 3.登入系统的密码 在实例信息面板中有一个重置密码的功能，第一次需要自己设置，这个是主机系统的登入密码。 一开始用浏览器远程连接主机的时候，进入到了命令行界面, 要求输入密码的时候一直输入的是远程连接密码，导致一直登不进，查了一下资料发现系统登入密码需要自己创建, 登入用户 root 4.安全组配置 安全组配置是阿里云在系统做了一次网关过滤，外网访问主机，主机访问外网都需要配置这个参数，否则访问不到, 安全组配置分为入口和出口 入口配置: 把一些常用端口打开:80 22(ssh, sftp) 23(telnet) , 使用xshell和ftp都是使用的是22端口 添加 全部 ICMP 协议类型, 端口范围为-1/-1, 没有这条规则则ping 不通主机 2.3 连接主机进行配置有了上面的配置就可以通过远程连接主机了, 我是使用xshell 进行远程连接, 使用fileZilla进行传输文件 2.3.1 配置 Java环境方式一：使用yum安装JDK 参考：https://www.cnblogs.com/sxdcgaq8080/p/7492426.html12345678910111213141516171819201.查看yum库中都有哪些jdk版本(暂时只发现了openjdk): [root@localhost ~]# yum search java|grep jdk2.选择版本,进行安装[root@localhost ~]# yum install java-1.8.0-openjdk//安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_643.设置环境变量[root@localhost ~]# vi /etc/profile在profile文件中添加如下内容#set java environmentJAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el7_5.x86_64JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH4.让修改生效[root@localhost java]# source /etc/profile 注: 如果出现export =&#39; not a valid identifier12345678910111213原因就是你修改的 /etc/profile 文件里你加过空格我的代码如下：export JAVA_HOME = /usr/java/jdk1.7.0_75export PATH = $JAVA_HOME/bin:$PATHexport CLASSPATH = .:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar修改为如下：export JAVA_HOME=/usr/java/jdk1.7.0_75export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar将等号两边的空格去掉就可以了 ，大家要注意 2.3.2 配置 Tomcat环境参考： http://www.linuxidc.com/Linux/2015-09/123118.htm12# tar -zxvf apache-tomcat-8.0.26.tar.gz // 解压压缩包 # mv apache-tomcat-8.0.26 tomcat // 改名 注:1.在ECS上启动tomcat后，第一次访问时间特别长1234567892017-04-25 10:16:04 INFO com.world.socket.ServerSocketListener 25-Apr-2017 10:18:48.171 INFO [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom CreaecureRandom instance for session ID generation using [SHA1PRNG] took [163,521] milliseconds. 这个session ID引起的 解决办法：在JVM环境中解决 打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：securerandom.source=file:/dev/urandom 替换成securerandom.source=file:/dev/./urandom 2.Centos打开、关闭、结束tomcat，及查看tomcat运行日志1234567891011启动：一般是执行sh tomcat/bin/startup.sh 停止：一般是执行sh tomcat/bin/shutdown.sh脚本命令 查看：执行ps -ef |grep tomcat 输出如下 *** 5144 。。。等等.Bootstrap start 说明tomcat已经正常启动， 5144 就为进程号 pid = 5144 杀死：kill -9 5144------------------------linux下实时查看tomcat运行日志-------------------------1、先切换到：cd tomcat/logs2、tail -f catalina.out3、这样运行时就可以实时查看运行日志了Ctrl+c 是退出tail命令。 2.3.3 配置 Mysql环境参考： http://www.linuxidc.com/Linux/2016-09/134992.htm 2.4 投放项目文件使用fileZilla进行传输文件1234Tomcat中部署web项目的三种方式：1.部署解包的webapp目录2.打包的war文件3.Manager Web应用程序","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"组合注解","slug":"backend/framework/spring/组合注解","date":"2018-01-14T14:25:44.000Z","updated":"2018-02-26T12:31:59.500Z","comments":true,"path":"2018/01/14/backend/framework/spring/组合注解/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/framework/spring/组合注解/","excerpt":"","text":"组合注解 用一个注解表示其他注解 CombinationAnnocation.java 123456789101112131415package com.smart.boot.groupAnno;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@ComponentScanpublic @interface CombinationAnnocation &#123; String [] value() default &#123;&#125;;&#125; Config.java 12345package com.smart.boot.groupAnno;@CombinationAnnocationpublic class Config &#123;&#125; Application.java1234567891011package com.smart.boot.groupAnno;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Application &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class); context.close(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"异步方法","slug":"backend/framework/spring/异步方法","date":"2018-01-14T14:25:44.000Z","updated":"2018-02-26T12:31:59.472Z","comments":true,"path":"2018/01/14/backend/framework/spring/异步方法/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/framework/spring/异步方法/","excerpt":"","text":"异步方法 加入@Async注解可以让普通方法变为异步方法 AsyncTaskService.java 12345678910111213141516171819202122package com.smart.boot.asyn;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncTaskService &#123; /** * 异步方法 * * @param i */ @Async public void task1(Integer i) &#123; System.out.println(\"执行异步任务\" + i); &#125; @Async public void task2(Integer i) &#123; System.out.println(\"执行异步任务+1 \" + (i + 1)); &#125;&#125; Config.java 1234567891011121314151617181920212223242526272829303132333435package com.smart.boot.asyn;import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.AsyncConfigurer;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.util.concurrent.Executor;@Configuration@ComponentScan(\"com.smart.boot.asyn\")@EnableAsync // 开启异步任务支持public class Config implements AsyncConfigurer &#123; /** * 获得一个基于线程池的 taskExecutor * * @return */ @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(5); taskExecutor.setMaxPoolSize(10); taskExecutor.setQueueCapacity(25); taskExecutor.initialize(); return taskExecutor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return null; &#125;&#125; Application.java123456789101112131415package com.smart.boot.asyn;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Application &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class); AsyncTaskService asyncTaskService = context.getBean(AsyncTaskService.class); for (int i = 0; i &lt; 10; i++) &#123; asyncTaskService.task1(i); asyncTaskService.task2(i); &#125; context.close(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring 事件监听","slug":"backend/framework/spring/spring 事件监听","date":"2018-01-14T12:01:44.000Z","updated":"2018-02-26T12:31:59.444Z","comments":true,"path":"2018/01/14/backend/framework/spring/spring 事件监听/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/framework/spring/spring 事件监听/","excerpt":"Spring 事件监听spring的事件(Application Event)为Bean与Bean之间的消息通信提供了支持, 当第一个Bean处理完一件事之后, 需要另外一个Bean知道并能做出相应的处理, 这时可以通过事件监听来讲一个Bean监听另一个Bean 观察者模式 Spring 事件监听是观察者模式的一种实现 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 事件驱动模型简介 事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点： 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）； 当目标发送改变（发布），观察者（订阅者）就可以接收到改变； 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。","text":"Spring 事件监听spring的事件(Application Event)为Bean与Bean之间的消息通信提供了支持, 当第一个Bean处理完一件事之后, 需要另外一个Bean知道并能做出相应的处理, 这时可以通过事件监听来讲一个Bean监听另一个Bean 观察者模式 Spring 事件监听是观察者模式的一种实现 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 事件驱动模型简介 事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点： 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）； 当目标发送改变（发布），观察者（订阅者）就可以接收到改变； 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。 实现流程1.自定义事件12345678910111213141516171819202122232425262728package com.smart.boot.event;import org.springframework.context.ApplicationEvent;public class DemoEvent extends ApplicationEvent &#123; private String msg; public DemoEvent(Object source, String msg) &#123; super(source); this.msg = msg; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; /** * 去做一些事 */ public void todoSomethings() &#123; System.out.println(\"正在做第一件事 , 做完需要做第二件事\"); &#125;&#125; 2.定义事件监听器12345678910111213141516171819package com.smart.boot.event;import org.springframework.context.ApplicationListener;import org.springframework.stereotype.Component;@Componentpublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123; /** * 对消息进行接受处理 * @param event */ @Override public void onApplicationEvent(DemoEvent event) &#123; String msg = event.getMsg(); System.out.println(\"DemoListener 接受到了消息\" + msg ); event.todoSomethings(); System.out.println(\"正在做第二件事\"); &#125;&#125; 3.发布事件12345678910111213141516171819202122package com.smart.boot.event;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.stereotype.Component;@Componentpublic class DemoPublisher &#123; /** * 注入ApplicationContext来发布事件 */ @Autowired ApplicationContext context; /** * 发布事件 * @param msg */ public void publish(String msg) &#123; context.publishEvent(new DemoEvent(this,msg)); &#125;&#125; 4.定义配置类123456789package com.smart.boot.event;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.smart.boot.event\")public class Config &#123;&#125; 5.运行123456789101112package com.smart.boot.event;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Application &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class); DemoPublisher demoPublisher = context.getBean(DemoPublisher.class); demoPublisher.publish(\"hello songshuiyang\"); context.close(); &#125;&#125; 6.实现结果123DemoListener 接受到了消息hello songshuiyang正在做第一件事 , 做完需要做第二件事正在做第二件事 总结 实现事件监听可以使业务解耦, 每个模块做好自己的事情即可, 可用在用户注册功能, eg: http://jinnianshilongnian.iteye.com/blog/1902886","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"注解Value, Spring EL","slug":"backend/framework/spring/注解Value","date":"2018-01-14T08:01:44.000Z","updated":"2018-02-26T12:31:59.495Z","comments":true,"path":"2018/01/14/backend/framework/spring/注解Value/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/framework/spring/注解Value/","excerpt":"@Value用法及配合Spring EL使用spring支持@Value注解获取一些配置信息及加载资源 ELConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.smart.boot.el;import org.apache.commons.io.IOUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;@Configuration@ComponentScan(\"com.smart.boot.el\")@PropertySource(\"classpath:el.properties\")public class ELConfig &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 注入普通字符串 */ @Value(\"songsy\") private String str; /** * 通过el注入操作系统属性 */ @Value(\"# &#123;systemProperties['os.name']&#125;\") private String osName; /** * 表达式结果 */ @Value(\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\") private double randomNumber; /** * 注入其他Bean属性 */ @Value(\"#&#123;eLService.another&#125;\") public String fromAnothor; /** * 注入文件资源 */ @Value(\"classpath:el.properties\") private Resource testFile; /** * 注入网站资源 */ @Value(\"http://www.baidu.com\") private Resource testUrl; /** * 注入配置文件 */ @Value(\"$&#123;book.name&#125;\") private String bookName; /** * 环境配置 * 环境在容器中是一个抽象的集合，是指应用环境的2个方面: profiles和 properties. * profile: * 配置是一个被命名的，bean定义的逻辑组，这些bean只有在给定的profile配置激活时才会注册到容器。不管是XML还是注解， * Beans都有可能指派给profile配置。Environment环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。 * Properties: * 扮演一个非常重要的角色,可能来源于一下源码变量:properties文件，JVM properties,system环境变量，JNDI, servlet context parameters上下文参数, * 专门的Properties对象，Maps等等。Environment对象的作用，对于properties来说，是提供给用户方便的服务接口，方便撰写配置、方便解析配置。 * 作者：不迷失 * 链接：https://www.jianshu.com/p/49e950b0b008 * 來源：简书 * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */ @Autowired private Environment environment; /** * 若使用@Value注入, 则要配置一个PropertySourcesPlaceholderConfigurer * * @return */ @Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; public void print() throws Exception &#123; logger.info(\"str: \" + str); logger.info(\"osName: \" + osName); logger.info(\"randomNumber: \" + String.valueOf(randomNumber)); logger.info(\"fromAnothor: \" + fromAnothor); logger.info(\"testFile: \" + IOUtils.toString(testFile.getInputStream())); logger.info(\"testUrl: \" + IOUtils.toString(testUrl.getInputStream())); logger.info(\"bookName: \" + bookName); logger.info(\"environment: \" + environment.getProperty(\"book.author\")); &#125;&#125;","text":"@Value用法及配合Spring EL使用spring支持@Value注解获取一些配置信息及加载资源 ELConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.smart.boot.el;import org.apache.commons.io.IOUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;@Configuration@ComponentScan(\"com.smart.boot.el\")@PropertySource(\"classpath:el.properties\")public class ELConfig &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 注入普通字符串 */ @Value(\"songsy\") private String str; /** * 通过el注入操作系统属性 */ @Value(\"# &#123;systemProperties['os.name']&#125;\") private String osName; /** * 表达式结果 */ @Value(\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\") private double randomNumber; /** * 注入其他Bean属性 */ @Value(\"#&#123;eLService.another&#125;\") public String fromAnothor; /** * 注入文件资源 */ @Value(\"classpath:el.properties\") private Resource testFile; /** * 注入网站资源 */ @Value(\"http://www.baidu.com\") private Resource testUrl; /** * 注入配置文件 */ @Value(\"$&#123;book.name&#125;\") private String bookName; /** * 环境配置 * 环境在容器中是一个抽象的集合，是指应用环境的2个方面: profiles和 properties. * profile: * 配置是一个被命名的，bean定义的逻辑组，这些bean只有在给定的profile配置激活时才会注册到容器。不管是XML还是注解， * Beans都有可能指派给profile配置。Environment环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。 * Properties: * 扮演一个非常重要的角色,可能来源于一下源码变量:properties文件，JVM properties,system环境变量，JNDI, servlet context parameters上下文参数, * 专门的Properties对象，Maps等等。Environment对象的作用，对于properties来说，是提供给用户方便的服务接口，方便撰写配置、方便解析配置。 * 作者：不迷失 * 链接：https://www.jianshu.com/p/49e950b0b008 * 來源：简书 * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */ @Autowired private Environment environment; /** * 若使用@Value注入, 则要配置一个PropertySourcesPlaceholderConfigurer * * @return */ @Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; public void print() throws Exception &#123; logger.info(\"str: \" + str); logger.info(\"osName: \" + osName); logger.info(\"randomNumber: \" + String.valueOf(randomNumber)); logger.info(\"fromAnothor: \" + fromAnothor); logger.info(\"testFile: \" + IOUtils.toString(testFile.getInputStream())); logger.info(\"testUrl: \" + IOUtils.toString(testUrl.getInputStream())); logger.info(\"bookName: \" + bookName); logger.info(\"environment: \" + environment.getProperty(\"book.author\")); &#125;&#125; ELService.java12345678910111213141516171819package com.smart.boot.el;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Service(\"eLService\")public class ELService &#123; public String another; public String getAnother() &#123; return another; &#125; @Autowired public void setAnother() &#123; this.another = \"ELService 自动注入\"; &#125;&#125; ELMain.java123456789101112package com.smart.boot.el;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class ELMain &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ELConfig.class); ELConfig elConfig = context.getBean(ELConfig.class); elConfig.print(); context.close(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"npm scripts","slug":"frontend/npm/npm scripts","date":"2018-01-14T03:48:12.000Z","updated":"2018-02-26T12:31:58.964Z","comments":true,"path":"2018/01/14/frontend/npm/npm scripts/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/frontend/npm/npm scripts/","excerpt":"","text":"一、什么是 npm 脚本npm 允许在package.json文件里面，使用scripts字段定义脚本命令。123456&#123; // ... \"scripts\": &#123; \"build\": \"node build.js\" &#125;&#125; 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。命令行下使用npm run命令，就可以执行这段脚本。123$ npm run build# 等同于执行$ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多 项目的相关脚本，可以集中在一个地方。 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。 可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。1$ npm run 二：执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&amp;符号。1$ npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号1$ npm run script1.js &amp;&amp; npm run script2.js 应用在 package.json 添加以下代码执行npm run gg 可以连续执行（hexo g）（hexo d）俩个命令，这样就不用每次执行俩个命令123\"scripts\": &#123; \"gg\": \"hexo g &amp;&amp; hexo d\" &#125; 详见:http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"node","slug":"node","permalink":"http://www.songshuiyang.site/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://www.songshuiyang.site/tags/npm/"}]},{"title":"接入银联支付接口","slug":"backend/business/payment/接入银联支付接口","date":"2018-01-11T14:24:12.000Z","updated":"2018-02-26T12:31:59.756Z","comments":true,"path":"2018/01/11/backend/business/payment/接入银联支付接口/","link":"","permalink":"http://www.songshuiyang.site/2018/01/11/backend/business/payment/接入银联支付接口/","excerpt":"吐槽一下： 1.银联支付SDK是没有提供独立的jar包的，高大上的银联把示例demo和sdk整合在一起了，支付流程和支付宝支付相似，支付需要到银联的支付页面 2.证书说明：其实我们只需要一个邮件上的签名证书文件，官网上文档说的开发者调用接口前需要的其他证书在开发包中目录assets下都有，每个人都一样，没错，每个人都一样 3.银联开发平台常常在下午6点发版本，遇到过俩次，第一次感到惊讶:银联网站挂了？不可能呀，过了十多分钟又恢复正常，晕 4.代码不够规范，用代码检测工具一片黄色123456/** * @ClassName AcpService * @Description acpsdk接口服务类，接入商户集成请可以直接参考使用本类中的方法 * @date 2016-7-22 下午2:44:37 * 声明：以下代码只是为了方便接入方测试而提供的样例代码，商户可以根据自己需要，按照技术文档编写。该代码仅供参考，不提供编码，性能，规范性等方面的保障 */","text":"吐槽一下： 1.银联支付SDK是没有提供独立的jar包的，高大上的银联把示例demo和sdk整合在一起了，支付流程和支付宝支付相似，支付需要到银联的支付页面 2.证书说明：其实我们只需要一个邮件上的签名证书文件，官网上文档说的开发者调用接口前需要的其他证书在开发包中目录assets下都有，每个人都一样，没错，每个人都一样 3.银联开发平台常常在下午6点发版本，遇到过俩次，第一次感到惊讶:银联网站挂了？不可能呀，过了十多分钟又恢复正常，晕 4.代码不够规范，用代码检测工具一片黄色123456/** * @ClassName AcpService * @Description acpsdk接口服务类，接入商户集成请可以直接参考使用本类中的方法 * @date 2016-7-22 下午2:44:37 * 声明：以下代码只是为了方便接入方测试而提供的样例代码，商户可以根据自己需要，按照技术文档编写。该代码仅供参考，不提供编码，性能，规范性等方面的保障 */ 大致步骤一：下载demo及sdkhttps://open.unionpay.com/ajweb/product/newProDetail?proId=1&amp;cataId=14 二：配置参数：接入银联支付审核 听头说好像是挺繁琐的，费时费力，接入银联支付设及到下面几个参数，其他的参数银联都帮我们配置好了 1.商户号: 在银联商家技术服务中心可以看到 https://open.unionpay.com/ajweb/index，注意：在测试环境的商户号一致，刚开始我还不相信，通过客服才知道俩个是一样的，在测试账号信息里面可以看到 2.后台通知地址：填写接收银联后台通知的地址，必须外网能访问 3.前台通知地址：填写处理银联前台通知的地址，必须外网能访问 4.签名证书: 在审核成功发送的邮件里面 5.签名证书密码： 在审核成功发送的邮件里面有 三：调用支付接口protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html; charset=\"+ DemoBase.encoding); //前台页面传过来的 String merId = req.getParameter(\"merId\"); String txnAmt = req.getParameter(\"txnAmt\"); Map&lt;String, String&gt; requestData = new HashMap&lt;String, String&gt;(); /***银联全渠道系统，产品参数，除了encoding自行选择外其他不需修改***/ requestData.put(\"version\", DemoBase.version); //版本号，全渠道默认值 requestData.put(\"encoding\", DemoBase.encoding); //字符集编码，可以使用UTF-8,GBK两种方式 requestData.put(\"signMethod\", SDKConfig.getConfig().getSignMethod()); //签名方法 requestData.put(\"txnType\", \"01\"); //交易类型 ，01：消费 requestData.put(\"txnSubType\", \"01\"); //交易子类型， 01：自助消费 requestData.put(\"bizType\", \"000201\"); //业务类型，B2C网关支付，手机wap支付 requestData.put(\"channelType\", \"07\"); //渠道类型，这个字段区分B2C网关支付和手机wap支付；07：PC,平板 08：手机 /***商户接入参数***/ requestData.put(\"merId\", merId); //商户号码，请改成自己申请的正式商户号或者open上注册得来的777测试商户号 requestData.put(\"accessType\", \"0\"); //接入类型，0：直连商户 requestData.put(\"orderId\",DemoBase.getOrderId()); //商户订单号，8-40位数字字母，不能含“-”或“_”，可以自行定制规则 requestData.put(\"txnTime\", DemoBase.getCurrentTime()); //订单发送时间，取系统时间，格式为YYYYMMDDhhmmss，必须取当前时间，否则会报txnTime无效 requestData.put(\"currencyCode\", \"156\"); //交易币种（境内商户一般是156 人民币） requestData.put(\"txnAmt\", txnAmt); //交易金额，单位分，不要带小数点 //requestData.put(\"reqReserved\", \"透传字段\"); //请求方保留域，如需使用请启用即可；透传字段（可以实现商户自定义参数的追踪）本交易的后台通知,对本交易的交易状态查询交易、对账文件中均会原样返回，商户可以按需上传，长度为1-1024个字节。出现&amp;={}[]符号时可能导致查询接口应答报文解析失败，建议尽量只传字母数字并使用|分割，或者可以最外层做一次base64编码(base64编码之后出现的等号不会导致解析失败可以不用管)。 //前台通知地址 （需设置为外网能访问 http https均可），支付成功后的页面 点击“返回商户”按钮的时候将异步通知报文post到该地址 //如果想要实现过几秒中自动跳转回商户页面权限，需联系银联业务申请开通自动返回商户权限 //异步通知参数详见open.unionpay.com帮助中心 下载 产品接口规范 网关支付产品接口规范 消费交易 商户通知 requestData.put(\"frontUrl\", DemoBase.frontUrl); //后台通知地址（需设置为【外网】能访问 http https均可），支付成功后银联会自动将异步通知报文post到商户上送的该地址，失败的交易银联不会发送后台通知 //后台通知参数详见open.unionpay.com帮助中心 下载 产品接口规范 网关支付产品接口规范 消费交易 商户通知 //注意:1.需设置为外网能访问，否则收不到通知 2.http https均可 3.收单后台通知后需要10秒内返回http200或302状态码 // 4.如果银联通知服务器发送通知后10秒内未收到返回状态码或者应答码非http200，那么银联会间隔一段时间再次发送。总共发送5次，每次的间隔时间为0,1,2,4分钟。 // 5.后台通知地址如果上送了带有？的参数，例如：http://abc/web?a=b&amp;c=d 在后台通知处理程序验证签名之前需要编写逻辑将这些字段去掉再验签，否则将会验签失败 requestData.put(\"backUrl\", DemoBase.backUrl); // 订单超时时间。 // 超过此时间后，除网银交易外，其他交易银联系统会拒绝受理，提示超时。 跳转银行网银交易如果超时后交易成功，会自动退款，大约5个工作日金额返还到持卡人账户。 // 此时间建议取支付时的北京时间加15分钟。 // 超过超时时间调查询接口应答origRespCode不是A6或者00的就可以判断为失败。 requestData.put(\"payTimeout\", new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date().getTime() + 15 * 60 * 1000)); ////////////////////////////////////////////////// // // 报文中特殊用法请查看 PCwap网关跳转支付特殊用法.txt // ////////////////////////////////////////////////// /**请求参数设置完毕，以下对请求参数进行签名并生成html表单，将表单写入浏览器跳转打开银联页面**/ Map&lt;String, String&gt; submitFromData = AcpService.sign(requestData,DemoBase.encoding); //报文中certId,signature的值是在signData方法中获取并自动赋值的，只要证书配置正确即可。 String requestFrontUrl = SDKConfig.getConfig().getFrontRequestUrl(); //获取请求银联的前台地址：对应属性文件acp_sdk.properties文件中的acpsdk.frontTransUrl String html = AcpService.createAutoFormHtml(requestFrontUrl, submitFromData,DemoBase.encoding); //生成自动跳转的Html表单 LogUtil.writeLog(\"打印请求HTML，此为请求报文，为联调排查问题的依据：\"+html); //将生成的html写到浏览器中完成自动跳转打开银联支付页面；这里调用signData之后，将html写到浏览器跳转到银联页面之前均不能对html中的表单项的名称和值进行修改，如果修改会导致验签不通过 resp.getWriter().write(html); } 异步通知：与支付宝微信异步通知处理相同参考于：https://open.unionpay.com/ajweb/product/newProDetail?proId=1&amp;cataId=14","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"接入微信扫码支付接口","slug":"backend/business/payment/接入微信支付接口","date":"2018-01-11T13:24:12.000Z","updated":"2018-02-26T12:31:59.709Z","comments":true,"path":"2018/01/11/backend/business/payment/接入微信支付接口/","link":"","permalink":"http://www.songshuiyang.site/2018/01/11/backend/business/payment/接入微信支付接口/","excerpt":"准备条件开始之前先看一下微信的几个平台: 微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。平台入口：http://mp.weixin.qq.com。 微信开放平台:微信开放平台是商户APP接入微信支付开放接口的申请入口，通过此平台可申请微信APP支付。平台入口：http://open.weixin.qq.com。 微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。平台入口：http://pay.weixin.qq.com 刚开始接入的时候有点昏，各种参数需要到不同的平台找, 不像支付宝一样只有一个开发平台，如果是接入微信扫码支付设及到微信公众平台和微信商户平台，如果是手机app微信支付，设及到微信开放平台和微信商户平台 开通支付功能:有了平台账号之后，然后就是开通支付功能，等待审核通过，当然审核过程有可能被退回，大多是描述信息或者经营类别与营业执照描述不一致","text":"准备条件开始之前先看一下微信的几个平台: 微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。平台入口：http://mp.weixin.qq.com。 微信开放平台:微信开放平台是商户APP接入微信支付开放接口的申请入口，通过此平台可申请微信APP支付。平台入口：http://open.weixin.qq.com。 微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。平台入口：http://pay.weixin.qq.com 刚开始接入的时候有点昏，各种参数需要到不同的平台找, 不像支付宝一样只有一个开发平台，如果是接入微信扫码支付设及到微信公众平台和微信商户平台，如果是手机app微信支付，设及到微信开放平台和微信商户平台 开通支付功能:有了平台账号之后，然后就是开通支付功能，等待审核通过，当然审核过程有可能被退回，大多是描述信息或者经营类别与营业执照描述不一致 微信支付开发: 下面是微信支付的业务流程时序图, 可以看到与支付宝的支付流程主要流程是差不多的，只不过微信扫码可以在本系统完成支付，没有发生页面跳转，可以自己DIY支付页面，只要将支付链接生成二维码图片即可完成支付 logo 接入微信支付步骤1. 获取支付SDK gradle:地址 compile(&quot;com.github.wxpay:wxpay-sdk:0.0.3&quot;) 2. 配置参数主要是如下参数, 可以配置在一个属性文件中方面配置 1、APP ID ，应用ID（在公众平台–基本配置模块中） 2、APP Sercret ，应用秘钥（在公众平台–基本配置模块中）32位数字大小写字母 3、API Key，API的秘钥（在商户平台–API安全中设置） 4、mchID , 商户号（在公众平台—微信支付—商户信息） 5、order_api ， 统一下单API的接口 6、notify_url 交易成功回调的接口的URL 3. 新建一个参数配置类 WxPcPayConfigImpl.java 继承 WXPayConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * 微信支付PC端 基础属性配置 */public class WxPcPayConfigImpl implements WXPayConfig &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); // 配置文件地址 private static final String FILE_NAME = \"weixin_pc_pay.properties\"; // 服务号的应用ID public static String APP_ID; // 服务号的应用密钥 public static String APP_SECRET; // 服务号的配置token public static String TOKEN; // 商户号 public static String MCH_ID; // API密钥 public static String API_KEY; // 签名加密方式 public static String SIGN_TYPE; // 微信支付证书 public static String CERT_PATH; // 异步回调地址 public static String NOTIFY_URL; // 是否使用沙箱环境 public static boolean IS_USE_SANDBOX; // 证书 private static byte[] certData; // INSTANCE private static WxPcPayConfigImpl INSTANCE; // 配置对象 private static Configuration configs; // 文件分隔符 public final static String SF_FILE_SEPARATOR = System.getProperty(\"file.separator\");//文件分隔符 // 二维码图片宽度 public final static int QR_IMG_WIDTH = 300; // 二维码图片高度 public final static int QR_IMG_HEIGHT = 300; /** * 返回配置文件实例 * * @return * @throws Exception */ public static WxPcPayConfigImpl getInstance() throws Exception &#123; if (INSTANCE == null) &#123; synchronized (WxPcPayConfigImpl.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new WxPcPayConfigImpl(); &#125; &#125; &#125; return INSTANCE; &#125; /** * 加载微信配置文件 */ public static synchronized void init() &#123; if (configs != null) &#123; return; &#125; try &#123; configs = new PropertiesConfiguration(FILE_NAME); &#125; catch (ConfigurationException e) &#123; e.printStackTrace(); &#125; if (configs == null) &#123; throw new IllegalStateException(\"读取配置文件错误\" + FILE_NAME); &#125; APP_ID = configs.getString(\"appId\"); APP_SECRET = configs.getString(\"appSecret\"); TOKEN = configs.getString(\"token\"); MCH_ID = configs.getString(\"mchId\"); API_KEY = configs.getString(\"apiKey\"); SIGN_TYPE = configs.getString(\"signType\"); CERT_PATH = configs.getString(\"certPath\"); IS_USE_SANDBOX = configs.getBoolean(\"isUseSandbox\"); NOTIFY_URL = configs.getString(\"notifyUrl\"); // 加载证书 File file; try &#123; // file = new File(CERT_PATH); Resource resource = new ClassPathResource(CERT_PATH); file = resource.getFile(); InputStream certStream = new FileInputStream(file); certData = new byte[(int) file.length()]; certStream.read(certData); certStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取 App ID * * @return App ID */ @Override public String getAppID() &#123; return APP_ID; &#125; /** * 获取 Mch ID * * @return Mch ID */ @Override public String getMchID() &#123; return MCH_ID; &#125; /** * 获取 API 密钥 * * @return API密钥 */ @Override public String getKey() &#123; return API_KEY; &#125; /** * 获取商户证书内容 * * @return 商户证书内容 */ @Override public InputStream getCertStream() &#123; ByteArrayInputStream certBis; certBis = new ByteArrayInputStream(this.certData); return certBis; &#125; /** * HTTP(S) 连接超时时间，单位毫秒 * * @return */ @Override public int getHttpConnectTimeoutMs() &#123; return 8000; &#125; /** * HTTP(S) 读数据超时时间，单位毫秒 * * @return */ @Override public int getHttpReadTimeoutMs() &#123; return 10000; &#125; public byte[] getCertData() &#123; return certData; &#125; public void setCertData(byte[] certData) &#123; this.certData = certData; &#125;&#125; 4. new 一个WXPay对象123WXPay wxAppPay;WxPcPayConfigImpl pcConfig = WxPcPayConfigImpl.getInstance();wxpay = new WXPay(pcConfig, WXPayConstants.SignType.MD5, WxPcPayConfigImpl.IS_USE_SANDBOX); 5. 有了”对象”之后就可以发送支付请求了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * PC端微信支付请求 * * @param domainId 商户订单号取实体类id * @param amount 充值金额 * @return 处理结果数据 */public Map&lt;String, Object&gt; weixinPay(String domainId, BigDecimal amount, HttpServletRequest request) &#123; Map&lt;String, Object&gt; resultMaps = new HashMap&lt;&gt;(); resultMaps.put(\"status\", \"success\"); HashMap&lt;String, String&gt; data = new HashMap&lt;&gt;(); String currentUserName = \"\"; if (AccountUtils.getCurrentUser() != null) &#123; if (StringUtils.isNotBlank(AccountUtils.getCurrentUser().getFdNickName())) &#123; currentUserName = AccountUtils.getCurrentUser().getFdNickName(); &#125; &#125; String description = currentUserName + \" 账户充值\"; data.put(\"body\", description); // 商品描述 data.put(\"out_trade_no\", domainId); // 商户订单号 data.put(\"total_fee\", AmountUtils.transAmountToCent(amount)); // 总金额,单位为分 data.put(\"spbill_create_ip\", WxUtils.getRemoteIp(request)); // 发起人IP地址 data.put(\"notify_url\", WxPcPayConfigImpl.NOTIFY_URL); // 异步通知地址 data.put(\"trade_type\", \"NATIVE\"); // 此处指定为扫码支付 data.put(\"product_id\", domainId); // 商品ID,trade_type=NATIVE时（即扫码支付），此参数必传 Map&lt;String, String&gt; resultMap; try &#123; resultMap = wxpay.unifiedOrder(data); logger.info(\"微信生成二维码返回xml 转成Json\" + JsonFormatUtil.formatJson(resultMap.toString())); System.out.println(resultMap); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(\"微信支付处理异常\"); resultMaps.put(\"status\", \"failed\"); return resultMaps; &#125; String returnCode = resultMap.get(\"return_code\"); // 返回结果 if (\"SUCCESS\".equals(returnCode)) &#123; String resultCode = resultMap.get(\"result_code\"); // 处理结果 if (\"SUCCESS\".equals(resultCode)) &#123; logger.info(\"订单号：&#123;&#125;生成微信支付码成功\", domainId); String urlCode = resultMap.get(\"code_url\"); // 生成二维码 logger.info(\"\"); // WxUtils.encodeQRCode(urlCode,imgPath); String imgBase64Str = WxUtils.encodeQRCodeBase64(urlCode); // 是否是微信支付 resultMaps.put(\"id\", domainId); resultMaps.put(\"isWxPay\", true); resultMaps.put(\"img\", imgBase64Str); &#125; else &#123; String errCodeDes = resultMap.get(\"err_code_des\"); logger.info(\"订单号：&#123;&#125;生成微信支付码(系统)失败:&#123;&#125;\", domainId, errCodeDes); resultMaps.put(\"status\", \"failed\"); return resultMaps; &#125; &#125; else &#123; String returnMsg = resultMap.get(\"return_msg\"); logger.info(\"(订单号：&#123;&#125;生成微信支付码(通信)失败:&#123;&#125;\", domainId, returnMsg); resultMaps.put(\"status\", \"failed\"); return resultMaps; &#125; return resultMaps;&#125; 微信支付统一下单接口:12345678910/** * 作用：统一下单&lt;br&gt; * 场景：公共号支付、扫码支付、APP支付 * @param reqData 向wxpay post的请求数据 * @return API返回数据 * @throws Exception */public Map&lt;String, String&gt; unifiedOrder(Map&lt;String, String&gt; reqData) throws Exception &#123; return this.unifiedOrder(reqData, config.getHttpConnectTimeoutMs(), this.config.getHttpReadTimeoutMs());&#125; 6. 生成支付二维码这里我是将二维码链接字符串转成字符流 然后生成Base64位的图片字符, 只要在 设置src属性值，就可以完成图片展示，不用考虑生成的图片放在那里 7. 支付完成, 处理异步回调备注： 微信支付是使用的xml进行传输数据，需要将xml转成map，当然微信SDK中也提供了工具类，提供了一些十分用的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257package com.github.wxpay.sdk;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.StringWriter;import java.util.*;import java.security.MessageDigest;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.crypto.Mac;import javax.crypto.spec.SecretKeySpec;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import com.github.wxpay.sdk.WXPayConstants.SignType;public class WXPayUtil &#123; /** * XML格式字符串转换为Map * * @param strXML XML字符串 * @return XML数据转换后的Map * @throws Exception */ public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123; Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes(\"UTF-8\")); org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); NodeList nodeList = doc.getDocumentElement().getChildNodes(); for (int idx=0; idx&lt;nodeList.getLength(); ++idx) &#123; Node node = nodeList.item(idx); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; org.w3c.dom.Element element = (org.w3c.dom.Element) node; data.put(element.getNodeName(), element.getTextContent()); &#125; &#125; try &#123; stream.close(); &#125; catch (Exception ex) &#123; &#125; return data; &#125; /** * 将Map转换为XML格式的字符串 * * @param data Map类型数据 * @return XML格式的字符串 * @throws Exception */ public static String mapToXml(Map&lt;String, String&gt; data) throws Exception &#123; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder(); org.w3c.dom.Document document = documentBuilder.newDocument(); org.w3c.dom.Element root = document.createElement(\"xml\"); document.appendChild(root); for (String key: data.keySet()) &#123; String value = data.get(key); if (value == null) &#123; value = \"\"; &#125; value = value.trim(); org.w3c.dom.Element filed = document.createElement(key); filed.appendChild(document.createTextNode(value)); root.appendChild(filed); &#125; TransformerFactory tf = TransformerFactory.newInstance(); Transformer transformer = tf.newTransformer(); DOMSource source = new DOMSource(document); transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); transformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); StringWriter writer = new StringWriter(); StreamResult result = new StreamResult(writer); transformer.transform(source, result); String output = writer.getBuffer().toString(); //.replaceAll(\"\\n|\\r\", \"\"); try &#123; writer.close(); &#125; catch (Exception ex) &#123; &#125; return output; &#125; /** * 生成带有 sign 的 XML 格式字符串 * * @param data Map类型数据 * @param key API密钥 * @return 含有sign字段的XML */ public static String generateSignedXml(final Map&lt;String, String&gt; data, String key) throws Exception &#123; return generateSignedXml(data, key, SignType.MD5); &#125; /** * 生成带有 sign 的 XML 格式字符串 * * @param data Map类型数据 * @param key API密钥 * @param signType 签名类型 * @return 含有sign字段的XML */ public static String generateSignedXml(final Map&lt;String, String&gt; data, String key, SignType signType) throws Exception &#123; String sign = generateSignature(data, key, signType); data.put(WXPayConstants.FIELD_SIGN, sign); return mapToXml(data); &#125; /** * 判断签名是否正确 * * @param xmlStr XML格式数据 * @param key API密钥 * @return 签名是否正确 * @throws Exception */ public static boolean isSignatureValid(String xmlStr, String key) throws Exception &#123; Map&lt;String, String&gt; data = xmlToMap(xmlStr); if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) &#123; return false; &#125; String sign = data.get(WXPayConstants.FIELD_SIGN); return generateSignature(data, key).equals(sign); &#125; /** * 判断签名是否正确，必须包含sign字段，否则返回false。使用MD5签名。 * * @param data Map类型数据 * @param key API密钥 * @return 签名是否正确 * @throws Exception */ public static boolean isSignatureValid(Map&lt;String, String&gt; data, String key) throws Exception &#123; return isSignatureValid(data, key, SignType.MD5); &#125; /** * 判断签名是否正确，必须包含sign字段，否则返回false。 * * @param data Map类型数据 * @param key API密钥 * @param signType 签名方式 * @return 签名是否正确 * @throws Exception */ public static boolean isSignatureValid(Map&lt;String, String&gt; data, String key, SignType signType) throws Exception &#123; if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) &#123; return false; &#125; String sign = data.get(WXPayConstants.FIELD_SIGN); return generateSignature(data, key, signType).equals(sign); &#125; /** * 生成签名 * * @param data 待签名数据 * @param key API密钥 * @return 签名 */ public static String generateSignature(final Map&lt;String, String&gt; data, String key) throws Exception &#123; return generateSignature(data, key, SignType.MD5); &#125; /** * 生成签名. 注意，若含有sign_type字段，必须和signType参数保持一致。 * * @param data 待签名数据 * @param key API密钥 * @param signType 签名方式 * @return 签名 */ public static String generateSignature(final Map&lt;String, String&gt; data, String key, SignType signType) throws Exception &#123; Set&lt;String&gt; keySet = data.keySet(); String[] keyArray = keySet.toArray(new String[keySet.size()]); Arrays.sort(keyArray); StringBuilder sb = new StringBuilder(); for (String k : keyArray) &#123; if (k.equals(WXPayConstants.FIELD_SIGN)) &#123; continue; &#125; if (data.get(k).trim().length() &gt; 0) // 参数值为空，则不参与签名 sb.append(k).append(\"=\").append(data.get(k).trim()).append(\"&amp;\"); &#125; sb.append(\"key=\").append(key); if (SignType.MD5.equals(signType)) &#123; return MD5(sb.toString()).toUpperCase(); &#125; else if (SignType.HMACSHA256.equals(signType)) &#123; return HMACSHA256(sb.toString(), key); &#125; else &#123; throw new Exception(String.format(\"Invalid sign_type: %s\", signType)); &#125; &#125; /** * 获取随机字符串 Nonce Str * * @return String 随机字符串 */ public static String generateNonceStr() &#123; return UUID.randomUUID().toString().replaceAll(\"-\", \"\").substring(0, 32); &#125; /** * 生成 MD5 * * @param data 待处理数据 * @return MD5结果 */ public static String MD5(String data) throws Exception &#123; java.security.MessageDigest md = MessageDigest.getInstance(\"MD5\"); byte[] array = md.digest(data.getBytes(\"UTF-8\")); StringBuilder sb = new StringBuilder(); for (byte item : array) &#123; sb.append(Integer.toHexString((item &amp; 0xFF) | 0x100).substring(1, 3)); &#125; return sb.toString().toUpperCase(); &#125; /** * 生成 HMACSHA256 * @param data 待处理数据 * @param key 密钥 * @return 加密结果 * @throws Exception */ public static String HMACSHA256(String data, String key) throws Exception &#123; Mac sha256_HMAC = Mac.getInstance(\"HmacSHA256\"); SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"HmacSHA256\"); sha256_HMAC.init(secret_key); byte[] array = sha256_HMAC.doFinal(data.getBytes(\"UTF-8\")); StringBuilder sb = new StringBuilder(); for (byte item : array) &#123; sb.append(Integer.toHexString((item &amp; 0xFF) | 0x100).substring(1, 3)); &#125; return sb.toString().toUpperCase(); &#125;&#125; 参考于:http://mp.weixin.qq.com http://open.weixin.qq.com http://pay.weixin.qq.com","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"接入支付宝支付接口","slug":"backend/business/payment/接入支付宝支付接口","date":"2018-01-10T02:24:12.000Z","updated":"2018-11-13T11:59:09.756Z","comments":true,"path":"2018/01/10/backend/business/payment/接入支付宝支付接口/","link":"","permalink":"http://www.songshuiyang.site/2018/01/10/backend/business/payment/接入支付宝支付接口/","excerpt":"一: 应用场景 主要应用于一些交易平台商品订单支付，账户充值，线上收费这些有支付需求的交易 用户通过支付宝PC收银台完成支付，交易款项即时给到商户支付宝账户 logo logo","text":"一: 应用场景 主要应用于一些交易平台商品订单支付，账户充值，线上收费这些有支付需求的交易 用户通过支付宝PC收银台完成支付，交易款项即时给到商户支付宝账户 logo logo 二: 准备条件 一个公司, 不是公司的话是不能接入商户支付宝网关支付的, 当然支付宝是分个人用户和商户用户的, 如果是个人网站的话可以贴个自己收款二维码上去进行收款, 如果是正在运营的商户企业收取费用的话是要接入支付宝网关支付功能进行收费, 这样的话可以看起来bigger更高 企业或个体工商户，具有真实有效的营业执照，且支付宝账户名称需与营业执照主体一致 网站通过ICP备案，能正常访问，页面显示完整，有明确的运营内容与完整的商品信息。 三：接入支付宝支付功能步骤第一步：创建应用要在应用中使用支付宝开放产品的接口能力： 需要先去蚂蚁金服开放平台，在开发者中心创建登记您的应用，此时将获得应用唯一标识（APPID） 请在【功能信息】中点击【添加功能】，选择【电脑网站支付】 提交审核（需要上传公司营业执照,填写法人身份信息等等），等待审核通过，该应用正式可以使用 TIPS：电脑网站支付接口需签约后才能调用 第二步：配置密钥开发者调用接口前需要先生成RSA密钥，RSA密钥包含应用私钥(APP_PRIVATE_KEY)、应用公钥(APP_PUBLIC_KEY）。生成密钥后在开放平台管理中心进行密钥配置，配置完成后可以获取支付宝公钥(ALIPAY_PUBLIC_KEY)。 用途：支付宝发送信息给商户系统时，使用支付宝私钥对数据进行加签，商户获取到支付宝加签的信息后使用支付宝公钥对数据进行验签，得到正确的数据。商户系统给支付宝发送信息时，使用商户自己的私钥对数据加签，支付宝获取到数据后使用商家上传的公钥进行验签。 加签步骤: 1.筛选 获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign与sign_type参数。 2.排序 将筛选的参数按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。拼接 将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝 3.拼接 将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。 4.加签 商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝 验签步骤： 与加签步骤一致，只不过是延签是使用公钥算出sign值，两方算出的sign值都一致的话则延签成功 第三步：搭建和配置开发环境 需要到支付宝开发平台下载服务端SDK,打包即用, 十分方便 配置参数 123456789AlipayClient alipayClient = new DefaultAlipayClient(URL,APP_ID,APP_PRIVATE_KEY,FORMAT,CHARSET,ALIPAY_PUBLIC_KEY,SIGN_TYPE);// URL:支付宝网关（固定） https://openapi.alipay.com/gateway.do, 如果是沙箱环境的话: https://openapi.alipaydev.com/gateway.do// APP_ID:创建应用时获取, 支付宝提供// APP_PRIVATE_KEY: 应用私钥, 运用支付宝提供的工具进行生成// FORMAT: json（固定）// CHARSET: 编码格式// ALIPAY_PUBLIC_KEY: 支付宝公钥, 由支付宝提供// SIGN_TYPE： 加签类型，商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2 配置完参数之后就可以调用支付宝的支付接口了, 十分方便, 阿里阿里 !!! 配置完参数之后先来看一下支付的调用流程： logo 接下来就是发起支付请求了12345678910111213141516171819202122232425262728import com.alipay.api.*;import com.alipay.api.request.*; public void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException,IOException &#123; //获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\", APP_ID, APP_PRIVATE_KEY, FORMAT, CHARSET, ALIPAY_PUBLIC_KEY, SIGN_TYPE);//创建支付请求的对应requestAlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();//设置请求参数及回跳地址和通知地址 alipayRequest.setBizContent(\"&#123;\" + \" \\\"out_trade_no\\\":\\\"20150320010101001\\\",\" + \" \\\"total_amount\":88.88,\" + \" \\\"subject\\\":title\\\",\" + \" \\\"body\\\":\\\"Iphone6 16G\\\",\" + &#125;\");//跳转地址就是支付完成之后，支付宝自动执行页面重定向,就是跳转到我们设置的页面alipayRequest.setReturnUrl(\"http://www.songshuiyang.site/return_url\"); //通知地址就是支付宝会根据API中商户传入的notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统。alipayRequest.setNotifyUrl(\"http://www.songshuiyang.site/notify_url\");String form=\"\";try &#123; //调用SDK生成html表单 form = alipayClient.pageExecute(alipayRequest).getBody(); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; //直接将完整的表单html输出到页面httpResponse.setContentType(\"text/html;charset=\" + CHARSET); httpResponse.getWriter().write(form); httpResponse.getWriter().flush(); httpResponse.getWriter().close(); &#125; 支付接口生成的html代码12345&lt;form name=\"punchout_form\" method=\"post\" action=\"https://openapi.alipay.com/gateway.do?charset=utf-8&amp;method=alipay.trade.page.pay&amp;sign=jsgXRru7b%2FHLO76SMPoj6lIuCnKJ9lkLo%2BTPIKfetqMOd8kyp2zYBZ456Dvf0eb4SyYgUrOjAgTkNW2AkgJh%2BbLJDu3eAtQVAUEEzFGy2Ix3uE3j3lPLHZDs1cF7g8vw7hwfmEqe8CE8OCJ%2B79J0Hp6YFOH8vnJEDUPvjla2AsCO0mhAsnYxm30rmqgDqJPfZLytOvRD5FF%2BoBd4UPH%2Budk7vCn9lEX%2BkEe7YBa3E7l6vWxXz%2BJDKGL9ZMHNtUzYUaid%2F%2BIugVLqtECybldd8YDZUFnz92Iq%2BOwIL09MzNtb6iC9AypfQxlTseFezDihBn%2Fey5itIovqntbLLdxt2g%3D%3D&amp;return_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment%2Findex&amp;notify_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment2%2Falipay_notify&amp;version=1.0&amp;app_id=123456789101554&amp;sign_type=RSA2&amp;timestamp=2018-01-01+14%3A27%3A50&amp;alipay_sdk=alipay-sdk-java-dynamicVersionNo&amp;format=json\"&gt; &lt;input type=\"hidden\" name=\"biz_content\" value=\"&#123;&amp;quot;out_trade_no&amp;quot;:&amp;quot;160b06765224a9aee66a6654541b947f&amp;quot;,&amp;quot;total_amount&amp;quot;:&amp;quot;0.01&amp;quot;,&amp;quot;subject&amp;quot;:&amp;quot;江西广而易科技有限公司 账户充值&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;充值金额: 0.01&amp;quot;,&amp;quot;product_code&amp;quot;:&amp;quot;FAST_INSTANT_TRADE_PAY&amp;quot;&#125;\"&gt; &lt;input type=\"submit\" value=\"立即支付\" style=\"display:none\" &gt;&lt;/form&gt;&lt;script&gt;document.forms[0].submit();&lt;/script&gt; 注意 action 链接后面的sign值就是签名字符串, 用于校验数据的来源还有数据有没有被修改 biz_content 是业务参数 html输出到页面后会跳转到支付的支付页面 第四步：扫码支付进行的步骤1.支付 logo 2.支付成功会自动跳转到商户页面(同步通知) 就是前面设置的 alipayRequest.setReturnUrl(“http://www.songshuiyang.site/return_url&quot;);,这部是支付完成之后支付宝的处理程序进行了页面重定向, 不是支付宝主动触发的。 logo 3.系统后台收到异步通知 对于PC网站支付的交易，在用户支付完成之后，支付宝会根据API中商户传入的alipayRequest.setNotifyUrl(“http://www.songshuiyang.site/notify_url&quot;);，通过POST请求的形式将支付结果作为参数通知到商户系统，该方式的作用是页面跳转同步通知没有处理订单更新，需要通过异步通知的方式去通知系统后台更新流水 4.进行异步通知处理 程序执行完后必须打印输出“success”。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）； 处理代码:123456789101112131415//将异步通知中收到的所有参数都存放到map中Map&lt;String, String&gt; paramsMap = ...;//调用SDK验证签名boolean signVerified = AlipaySignature.rsaCheckV1(paramsMap, ALIPAY_PUBLIC_KEY, CHARSET, SIGN_TYPE) if(signVerfied)&#123; // TODO 验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验1、商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，2、判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），3、校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方4、验证app_id是否为该商户本身。// 二次校验成功，继续商户自身业务处理，处理完成之后返回success&#125; else &#123; // TODO 验签失败则记录异常日志，并在response中返回failure. &#125; 注意： 这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致延签失败 如果是异步通知处理失败 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付异步通知；需要自己手动向支付宝发送查询请求，根据查询出来的结果确定该交易是否成功 12345678910111213AlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\",\"app_id\",\"your private_key\",\"json\",\"GBK\",\"alipay_public_key\",\"RSA2\"); //创建查询请求的对应requestAlipayTradeQueryRequest request = new AlipayTradeQueryRequest();request.setBizContent(\"&#123;\" + \"\\\"out_trade_no\\\":\\\"20150320010101001\\\",\" + \"\\\"trade_no\\\":\\\"2014112611001004680073956707\\\"\" + \"&#125;\"); AlipayTradeQueryResponse response = alipayClient.execute(request); if(response.isSuccess())&#123; //交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）、TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）、TRADE_SUCCESS（交易支付成功）、TRADE_FINISHED（交易结束，不可退款） System.out.println(\"调用成功\"); &#125; else &#123; System.out.println(\"调用失败\"); 注意： 这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致签名失败 五：支付宝网关支付API 接口英文名 接口中文 alipay.trade.page.pay 统一收单下单并支付页面接口 alipay.trade.refund 统一收单交易退款接口 alipay.trade.fastpay.refund.query 统一收单交易退款查询接口 alipay.trade.query 统一收单线下交易查询接口 alipay.trade.close 统一收单交易关闭接口 alipay.data.dataservice.bill.downloadurl.query 查询对账单下载地址 六： 使用沙箱环境进行测试 蚂蚁沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑（当前沙箱支持产品请参考“沙箱支持产品列表”）。 在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。 可以体验一把土豪的感觉, 不用在真实环境下使用一分钱测试联调大法了 七：总结 支付宝的支付接口进行了高度封装，可以拿过来直接使用，不必关心怎样签名&amp;验签、HTTP接口请求这些处理 在进行数据传输通信的同时，需要校验传输数据的来源，数据有没有进行修改，防止恶意数据攻击 注:本文内容参考支付宝开放平台文档内容, 一切以官方文档为准, 链接地址: https://open.alipay.com/platform/home.htm","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"Java基础-ASCII 160 空格","slug":"backend/java/basicKnowledge/Java基础-ASCII 160 空格","date":"2018-01-09T13:24:12.000Z","updated":"2019-05-04T03:16:45.793Z","comments":true,"path":"2018/01/09/backend/java/basicKnowledge/Java基础-ASCII 160 空格/","link":"","permalink":"http://www.songshuiyang.site/2018/01/09/backend/java/basicKnowledge/Java基础-ASCII 160 空格/","excerpt":"","text":"场景 获取从http传输过来的字符串的时候，碰到解析字符串不能分割字符串的情况12String str = doc.get(0); // str = \"江西省 赣州市\"String [] area = str.spilt(\"\\\\s+\"); 运行上面的代码的时候发现不能截取字符串, 初步怀疑是编码问题，然而经过验证发现并不是,然后就通过字符串截取成 char 字符发现，该char字符ASCII是160,马上查找资料发现是空格分两种编码格式: 1: 普通的空格,ASCII码为32 2:第二种是 网页上的 &amp;nbsp 空格,ASCII为160, 才发现空格也是有多种情况 解决方法:12// 需要将ASCII为160的空格转成普通的空格str = str.replaceAll(\"[\\\\s\\\\u00A0]+\", \" \");","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java基础-一切皆是对象","slug":"backend/java/basicKnowledge/Java基础-一切皆是对象","date":"2018-01-09T13:24:12.000Z","updated":"2019-05-04T03:16:45.702Z","comments":true,"path":"2018/01/09/backend/java/basicKnowledge/Java基础-一切皆是对象/","link":"","permalink":"http://www.songshuiyang.site/2018/01/09/backend/java/basicKnowledge/Java基础-一切皆是对象/","excerpt":"","text":"# 用引用操纵对象 在Java的世界里，一切都被视为对象，尽管一切都看成是对象，但操纵的标识符实际上是对象的一个引用,可将这一 情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对电视机的控制，那么手上拿着的是遥控板，而非电视机。12遥控器 --&gt; 电视引用 --&gt; 对象 # 高精度数字1234BigInteger 支持任意精度的整数。也就是说，我们可精确表示任意大小的整数值，同时在运算过程中不会丢失任何信息。BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。对应于我们针对主类型执行的操作。也就是说，能对 int 或 float 做的事情，对 BigInteger 和 BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。 # 基本数据类型默认值类文件的限制 每个文件只能有一个public类, 也可以没有public，如果有的话必须与文件名相同","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Mysql 如何设置字段自动获取当前时间","slug":"backend/database/Mysql 如何设置字段自动获取当前时间","date":"2017-12-17T03:15:12.000Z","updated":"2018-02-26T12:31:59.790Z","comments":true,"path":"2017/12/17/backend/database/Mysql 如何设置字段自动获取当前时间/","link":"","permalink":"http://www.songshuiyang.site/2017/12/17/backend/database/Mysql 如何设置字段自动获取当前时间/","excerpt":"","text":"应用场景：1231、在数据表中，要记录每条数据是什么时候创建的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录创建时间；2、在数据库中，要记录每条数据是什么时候修改的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录修改时间； 实现方式:123456789--修改CreateTime 设置默认时间 CURRENT_TIMESTAMP ALTER TABLE `table_name`MODIFY COLUMN `created_date` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' ;--修改 UpdateTime 设置 默认时间 CURRENT_TIMESTAMP 设置更新时间为 ON UPDATE CURRENT_TIMESTAMP ALTER TABLE `table_name`MODIFY COLUMN `last_modified_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间' ; 转自：https://www.cnblogs.com/lhj588/p/4245719.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"db","slug":"db","permalink":"http://www.songshuiyang.site/tags/db/"}]},{"title":"Druid Monitor","slug":"backend/database/Druid Monitor","date":"2017-12-11T02:24:12.000Z","updated":"2018-02-26T12:31:59.779Z","comments":true,"path":"2017/12/11/backend/database/Druid Monitor/","link":"","permalink":"http://www.songshuiyang.site/2017/12/11/backend/database/Druid Monitor/","excerpt":"","text":"Druid Monitor监控JavaSE和JavaWeb效果图: logo http://blog.csdn.net/binglovezi/article/details/50610269","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"druid","slug":"druid","permalink":"http://www.songshuiyang.site/tags/druid/"}]},{"title":"Maven 41种骨架","slug":"backend/buildTool/Maven/maven 骨架","date":"2017-11-18T13:58:45.000Z","updated":"2018-02-26T12:31:59.327Z","comments":true,"path":"2017/11/18/backend/buildTool/Maven/maven 骨架/","link":"","permalink":"http://www.songshuiyang.site/2017/11/18/backend/buildTool/Maven/maven 骨架/","excerpt":"","text":"Maven 的41种骨架功能介绍 …&gt;mvn archetype:generate12345678910111213141516171819202122232425262728293031323334353637383940411: internal -&gt; appfuse-basic-jsf (创建一个基于Hibernate，Spring和JSF的Web应用程序的原型) 2: internal -&gt; appfuse-basic-spring (创建一个基于Hibernate，Spring和Spring MVC的Web应用程序的原型) 3: internal -&gt; appfuse-basic-struts (创建一个基于Hibernate，Spring和Struts 2的Web应用程序的原型) 4: internal -&gt; appfuse-basic-tapestry (创建一个基于Hibernate, Spring 和 Tapestry 4的Web应用程序的原型) 5: internal -&gt; appfuse-core (创建一个基于 Hibernate and Spring 和 XFire的jar应用程序的原型) 6: internal -&gt; appfuse-modular-jsf (创建一个基于 Hibernate，Spring和JSF的模块化应用原型) 7: internal -&gt; appfuse-modular-spring (创建一个基于 Hibernate, Spring 和 Spring MVC 的模块化应用原型) 8: internal -&gt; appfuse-modular-struts (创建一个基于 Hibernate, Spring 和 Struts 2 的模块化应用原型) 9: internal -&gt; appfuse-modular-tapestry (创建一个基于 Hibernate, Spring 和 Tapestry 4 的模块化应用原型) 10: internal -&gt; maven-archetype-j2ee-simple (一个简单的J2EE的Java应用程序) 11: internal -&gt; maven-archetype-marmalade-mojo (一个Maven的 插件开发项目 using marmalade) 12: internal -&gt; maven-archetype-mojo (一个Maven的Java插件开发项目) 13: internal -&gt; maven-archetype-portlet (一个简单的portlet应用程序) 14: internal -&gt; maven-archetype-profiles () 15: internal -&gt; maven-archetype-quickstart () 16: internal -&gt; maven-archetype-site-simple (简单的网站生成项目) 17: internal -&gt; maven-archetype-site (更复杂的网站项目) 18: internal -&gt; maven-archetype-webapp (一个简单的Java Web应用程序) 19: internal -&gt; jini-service-archetype (Archetype for Jini service project creation) 20: internal -&gt; softeu-archetype-seam (JSF+Facelets+Seam Archetype) 21: internal -&gt; softeu-archetype-seam-simple (JSF+Facelets+Seam (无残留) 原型) 22: internal -&gt; softeu-archetype-jsf (JSF+Facelets 原型) 23: internal -&gt; jpa-maven-archetype (JPA 应用程序) 24: internal -&gt; spring-osgi-bundle-archetype (Spring-OSGi 原型) 25: internal -&gt; confluence-plugin-archetype (Atlassian 聚合插件原型) 26: internal -&gt; jira-plugin-archetype (Atlassian JIRA 插件原型) 27: internal -&gt; maven-archetype-har (Hibernate 存档) 28: internal -&gt; maven-archetype-sar (JBoss 服务存档) 29: internal -&gt; wicket-archetype-quickstart (一个简单的Apache Wicket的项目) 30: internal -&gt; scala-archetype-simple (一个简单的scala的项目) 31: internal -&gt; lift-archetype-blank (一个 blank/empty liftweb 项目) 32: internal -&gt; lift-archetype-basic (基本（liftweb）项目) 33: internal -&gt; cocoon-22-archetype-block-plain ([http://cocoapacorg2/maven-plugins/]) 34: internal -&gt; cocoon-22-archetype-block ([http://cocoapacorg2/maven-plugins/]) 35: internal -&gt; cocoon-22-archetype-webapp ([http://cocoapacorg2/maven-plugins/]) 36: internal -&gt; myfaces-archetype-helloworld (使用MyFaces的一个简单的原型) 37: internal -&gt; myfaces-archetype-helloworld-facelets (一个使用MyFaces和Facelets的简单原型) 38: internal -&gt; myfaces-archetype-trinidad (一个使用MyFaces和Trinidad的简单原型) 39: internal -&gt; myfaces-archetype-jsfcomponents (一种使用MyFaces创建定制JSF组件的简单的原型) 40: internal -&gt; gmaven-archetype-basic (Groovy的基本原型) 41: internal -&gt; gmaven-archetype-mojo (Groovy mojo 原型) 原文: https://www.cnblogs.com/iusmile/archive/2012/11/14/2770118.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"},{"name":"maven","slug":"maven","permalink":"http://www.songshuiyang.site/tags/maven/"}]},{"title":"Spring Aop","slug":"backend/framework/spring/Spring Aop","date":"2017-11-18T07:47:45.000Z","updated":"2018-02-26T12:31:59.365Z","comments":true,"path":"2017/11/18/backend/framework/spring/Spring Aop/","link":"","permalink":"http://www.songshuiyang.site/2017/11/18/backend/framework/spring/Spring Aop/","excerpt":"Spring Aop一: 概念1. 什么是AOP在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 2. 为什么要用Aop利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。在不改变原有方法的基础添加一些功能 , 比如:日志记录，性能统计，安全控制，事务处理，异常处理等等。","text":"Spring Aop一: 概念1. 什么是AOP在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 2. 为什么要用Aop利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。在不改变原有方法的基础添加一些功能 , 比如:日志记录，性能统计，安全控制，事务处理，异常处理等等。 3. Aop 术语 连接点(JoinPoint) 程序执行到某个特定位置 , Spring 仅支持方法级的连接点(方法执行前，方法完成后，抛出异常后) 切点(Pointcut) 从连接点的基础上引出的概念，是指特定的连接点，一个类有好多方法,每个方法又有多个连接点，则需要切点来限定一个小范围的连接点 通知、增强处理(Advice) 就是指你所需要添加的功能及这个功能什么时候(通知)实现 , 比如一个业务方法需要实现日志功能 , 那么就需要专门在一个地方定义好需要做什么，然后定义什么时候执行(方法执行前？，方法完成后？，抛出异常？。。。) Spring 切面可应用的 5 种通知类型： Before——在方法调用之前调用通知 After——在方法完成之后调用通知，无论方法执行成功与否 After-returning——在方法执行成功之后调用通知 After-throwing——在方法抛出异常后进行通知 Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为 引入(introduction) 特殊的增强，为类添加一些属性和方法 切面(Aspect) 切面由切点和增强组成 , 及包括横切逻辑的定义，也包括切点的定义, 目标对象(Target) 增强逻辑的织入目标类 , 如果没有Aop,那么目标对象就要自己实现(日志记录，性能统计，安全控制，事务处理，异常处理)这些功能，那么一个方法就会变成很杂乱 织入(Weaing) 将增强添加到目标对象的具体连接点上, Spring使用动态代理织入 Aop有三种织入方式 编译期织入 类装载期织入 动态代理织入: 在运行期间为目标类添加增强生成子类的方式二: Spring Aop 的应用 Spring Aop的使用一般通过俩种方式:第一种是通过注解的，第二种是通过xml配置 通过注解的方式实现Aop 第一步 Maven 导包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;parent&gt; &lt;groupId&gt;ecut&lt;/groupId&gt; &lt;artifactId&gt;spring-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ecut&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-aop&lt;/name&gt; &lt;dependencies&gt; &lt;!-- spring 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-aop&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--@Override is not allowed when implementing interface method--&gt; &lt;!-- 编码和编译和JDK版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 第二步 编写一个基于 @AspectJ 的切面 12345678910111213141516171819202122232425262728293031package com.aop.learn.aspectj;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;/** * @author songshuiyang * @title: @Aspect * @description: * @date 2017/11/15 */@Component@Aspect // 通过该注解将该类标识为一个切面public class PreGreetingAspect &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 前置增强, greetTo方法执行前触发此方法 * */ @Before(\"execution(* greetTo(..))\") // 定义切点和增强类型（前置增强,可以带任何参数，和任意的返回值） public void beforeGreeting() &#123; // 增强的横切逻辑 logger.info(\"How are you Aspect 使用了前置增强\"); &#125; &#125; 3: 编写目标对象 Writer.java 接口 12345678910111213package com.aop.learn.service;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */public interface Writer &#123; public void greetTo();&#125; NativeWaiter.java 实现方法12345678910111213141516171819202122232425package com.aop.learn.service.impl;import com.aop.learn.annotation.NeedTest;import com.aop.learn.service.Writer;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */@Servicepublic class NativeWaiter implements Writer &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void greetTo() &#123; logger.info(\"执行方法体: \"); &#125; &#125; 4：Spring配置文件 applicationContext.xml12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"com.aop.learn\"/&gt; &lt;!--基于@AspectJ切面的驱动器,自动为Spring容器中匹配@AspectJ切面的Bean创建代理，完成切面织入--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; 表示使用CGLib动态代理技术织入增强--&gt;&lt;/beans&gt; 5: 测试类 测试基类 BaseTest.java123456789101112131415161718192021package com.aop.test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:/spring/applicationContext.xml\")public class BaseTest extends AbstractJUnit4SpringContextTests &#123; public Logger logger = LoggerFactory.getLogger(this.getClass());&#125; 测试类 AspectTest.java 12345678910111213141516171819202122232425262728293031package com.aop.test.service;import com.aop.learn.service.AgentWriter;import com.aop.learn.service.Seller;import com.aop.learn.service.Writer;import com.aop.test.BaseTest;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;/** * @author songshuiyang * @title: 基于spring配置使用@AspectJ切面 * @description: * @date 2017/11/15 */public class AspectTest extends BaseTest &#123; @Autowired private Writer writer; /** * 基于spring配置使用@AspectJ切面 */ @Test public void test1() &#123; writer.greetTo(); &#125;&#125; 6: 效果图,完成 aop增强 logo #### #### #### #### 通过xml schema的方式实现Aop applicationContext-schema.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- aop:config 配置一个基于Schema的切面，aop:config 可以定义多个切面--&gt; &lt;aop:config proxy-target-class=\"true\"&gt; &lt;!--aop:pointcut 配置命名切点,可以被其他增强引用--&gt; &lt;aop:pointcut id=\"greetToPointcut\" expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..))\"/&gt; &lt;aop:pointcut id=\"bindParmPointcut\" expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..)) and args(clientName)\"/&gt; &lt;!-- aop:advisor 是切点和增强的复合体,仅包含一个切点和增强--&gt; &lt;aop:advisor advice-ref=\"advisorMethods\" pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* serveTo(..))\"/&gt; &lt;!--aop:aspect 元素标签定义切面,其内部可以定义多个增强--&gt; &lt;aop:aspect ref=\"adviceMethods\"&gt; &lt;!-- aop:before前置增强 method 增强方法， pointcut 切点表达式--&gt; &lt;aop:before method=\"preGreeting\" pointcut-ref=\"greetToPointcut\"/&gt; &lt;!-- aop:before后置增强--&gt; &lt;aop:after-returning method=\"afterGreeting\" pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* name(..))\" returning=\"retVal\"/&gt; &lt;!-- 测试绑定连接点信息--&gt; &lt;aop:after method=\"bindParmGreet\" pointcut-ref=\"bindParmPointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!--增强方法所在的Bean--&gt; &lt;bean id=\"adviceMethods\" class=\"com.aop.learn.schema.AdviceMethods\"/&gt; &lt;bean id=\"nativeWaiter\" class=\"com.aop.learn.service.impl.NativeWaiter\"/&gt; &lt;bean id=\"advisorMethods\" class=\"com.aop.learn.schema.AdvisorMethods\"/&gt;&lt;/beans&gt; AdviceMethods.java123456789101112131415161718192021222324252627282930313233343536package com.aop.learn.schema;/** * @author songshuiyang * @title: Schema 用作增强的方法 * @description: * @date 2017/11/18 */public class AdviceMethods &#123; /** * 前置增强 */ public void preGreeting() &#123; System.out.println(\"-------------前置增强\"); &#125; /** * 后置增强 * * @param retVal */ public void afterGreeting(String retVal) &#123; System.out.println(\"-------------后置增强,返回的参数\" + retVal); &#125; /** * 绑定连接点信息 * * @param clientName */ public void bindParmGreet(String clientName) &#123; System.out.println(\"-------------绑定连接点信息 的参数\" + clientName); &#125;&#125; NativeWaiter.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.aop.learn.service.impl;import com.aop.learn.annotation.NeedTest;import com.aop.learn.service.Writer;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */@Servicepublic class NativeWaiter implements Writer &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void greetTo(String clientName) &#123; logger.info(\"-------------greetTo \" + clientName); &#125; @Override public void greetTo(String clientName, Integer age) &#123; logger.info(\"-------------greetTo \" + clientName + \" \" + age + \"岁\"); &#125; @Override public void serveTo(String clientName) &#123; logger.info(\"-------------serveTo \" + clientName); &#125; @Override @NeedTest() public void nestTo() &#123; logger.info(\"开始执行 nestTo() 函数\"); &#125; @Override public String name() &#123; return \"宋水阳\"; &#125; @Override public void throwExcetion() &#123; throw new IllegalArgumentException(\"抛出异常了\"); &#125;&#125; AdvisorMethods.java1234567891011121314151617181920package com.aop.learn.schema;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;/** * @author songshuiyang * @title: aop:advisor 是切点和增强的复合体,仅包含一个切点和增强 * @description: * @date 2017/11/18 */public class AdvisorMethods implements MethodBeforeAdvice &#123; @Override public void before(Method method, Object[] args, Object taget) throws Throwable &#123; System.out.println(\"--------------执行aop:advisor增强----------------\"); System.out.println(\"获取的参数\" + args[0]); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"myBatis笔记","slug":"backend/framework/mybatis/mybatis笔记","date":"2017-11-14T13:59:44.000Z","updated":"2018-02-26T12:31:59.583Z","comments":true,"path":"2017/11/14/backend/framework/mybatis/mybatis笔记/","link":"","permalink":"http://www.songshuiyang.site/2017/11/14/backend/framework/mybatis/mybatis笔记/","excerpt":"","text":"mybatis foreach标签 foreach 标签中 item属性名如果和其他参数中同名(如以下代码:item=”id” 和 if test=”id != null” 同名),即使没有传入id参数,SQL也会执行 AND id = #{id} mapper文件:123456789101112131415&lt;select id=\"findPageList\" parameterType=\"map\" resultType=\"user\"&gt; SELECT * FROM user &lt;where&gt; &lt;if test=\"IN_id != null\"&gt; id IN &lt;foreach collection=\"IN_id\" index=\"index\" item=\"id\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; dao层1List&lt;User&gt; findPageList(Map&lt;String, Object&gt; map); 测试方法12345678910@Testpublic void test2() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); idList.add(1); idList.add(4); idList.add(5); map.put(\"IN_id\", idList); userMapper.findPageList(map);&#125; 结果123==&gt; Preparing: SELECT * FROM user WHERE id IN ( ? , ? , ? ) AND id = ? ==&gt; Parameters: 1(Integer), 4(Integer), 5(Integer), 5(Integer)&lt;== Total: 1","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring Task","slug":"backend/framework/spring/Spring Task","date":"2017-11-07T14:47:45.000Z","updated":"2018-02-26T12:31:59.384Z","comments":true,"path":"2017/11/07/backend/framework/spring/Spring Task/","link":"","permalink":"http://www.songshuiyang.site/2017/11/07/backend/framework/spring/Spring Task/","excerpt":"Spring Task spring task作为定时任务的处理,是Spring自带的一个设定时间自动任务调度,提供了两种方式进行配置，一种是注解的方式，而另外一种就是XML配置方式了。","text":"Spring Task spring task作为定时任务的处理,是Spring自带的一个设定时间自动任务调度,提供了两种方式进行配置，一种是注解的方式，而另外一种就是XML配置方式了。 基于XML配置文件的方式 applicationContext.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd\"&gt; &lt;!--使用配置文件的方式,注册 xmlTaskJob bean中的job1方法,每隔一秒执行 --&gt; &lt;task:scheduled-tasks&gt; &lt;task:scheduled ref=\"xmlTaskJob\" method=\"job1\" cron=\"*/1 * * * * ?\"/&gt; &lt;/task:scheduled-tasks&gt; &lt;context:component-scan base-package=\"com.learn.schedule.service\"/&gt;&lt;/beans&gt; XmlTaskJob.Java12345678910111213141516171819202122package com.learn.schedule.service;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;/** * @author songshuiyang * @title: 基于xml文件配置的定时任务 * @description: * @date 2017/11/7 22:20 */@Servicepublic class XmlTaskJob &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); public void job1() &#123; logger.info(\"基于xml文件配置的定时任务，每隔一秒执行\"); &#125;&#125; Test.java1234567891011/** * @author songshuiyang * @title: * @description: * @date 2017/11/7 22:45 */public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/spring/applicationContext.xml\"); &#125;&#125; 基于注解配置文件的方式更简单 applicationContext.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd\"&gt; &lt;!-- 启动定时器 基于注解--&gt; &lt;task:annotation-driven/&gt; &lt;context:component-scan base-package=\"com.learn.schedule.service\"/&gt;&lt;/beans&gt; AnnotationTaskJob.Java12345678910111213141516171819202122package com.learn.schedule.service;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;/** * @author songshuiyang * @title: 基于注解配置的定时任务 * @description: * @date 2017/11/7 22:42 */@Componentpublic class AnnotationTaskJob &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Scheduled(cron = \"*/2 * * * * ?\") //每2秒执行一次 public void job() &#123; logger.info(\"基于注解配置的定时任务，每隔俩秒执行\"); &#125;&#125; 效果: logo","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring","slug":"backend/framework/spring/学习笔记","date":"2017-10-24T14:23:44.000Z","updated":"2018-02-26T12:31:59.535Z","comments":true,"path":"2017/10/24/backend/framework/spring/学习笔记/","link":"","permalink":"http://www.songshuiyang.site/2017/10/24/backend/framework/spring/学习笔记/","excerpt":"","text":"轻量级(重量级)的框架 轻量级框架和重量级框架的区别是什么？很多人以为是以框架之间的耦合性强弱作为判断标准。其实不然，实际上是以启动程序需要的资源来决定。比如，EJB启动的时候，需要消耗大量的资源，内存，CPU等，所以是重量级。而Spring则不，所以是轻量级框架。就是看加载的资源 spring也不能说是轻量级的 EJB默认在应用启动的时候把所有资源和服务都加载进来而spring则是你定制服务 需要什么开什么 如果把spring的所有服务都用上的话 可以认为你是用了一个重量级的框架 实质还是看框架所需要的系统资源大小. IOC 底层原理使用到的技术 xml配置文件 &lt;bean id=&quot;user&quot; class=&quot;java.com.ecut.User&quot;&gt; dom4j解析xml配置文件 工厂设计模式 反射","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Git初始配置","slug":"backend/buildTool/git/git初始配置","date":"2017-10-22T02:45:12.000Z","updated":"2018-02-26T12:31:59.951Z","comments":true,"path":"2017/10/22/backend/buildTool/git/git初始配置/","link":"","permalink":"http://www.songshuiyang.site/2017/10/22/backend/buildTool/git/git初始配置/","excerpt":"","text":"使用Git的前的初始配置1. 配置提交时的用户名与邮件名称(注:只是标识本次commit是谁提交的)1.1 通过命令的方式1234$ git config --global user.name \"songshuiyang\"$ git config --global user.email songshiuyang@foxmail.com注: global 全局配置,在此电脑上的所有项目的git提交都会用这个用户名和邮件 1.2 通过修改配置文件的方式 12345文件路径: 用户目录/.gitconfig 文件把name email改成(新增)自己的配置即可[user] name = songshuiyang email = songshiuyang@foxmail.com 2. 配置 短命令2.1 通过命令的方式1234$ git config --global alias.st status$ git config --global alias.ci commit$ git congig --global alias.co checkout$ git congig --global alias.br branch 2.2 通过修改配置文件的方式123456789101112131415[alias] co = checkout ci = commit st = status cm = commit -m br = branch bm = branch -m bd = branch -D cb = checkout -b df = diff ls = log --stat lp = log -p plo = pull origin plode = pull origin develop pho = push origin 3. 配置文件 Git的三个配置文件 版本库级别的配置文件,文件路径: 项目路径/.git/config 全局配置文件, 文件路径: 用户目录/.gitconfig 系统级配置文件,文件路径: 安装目录/etc目录下 优先级: 版本库级别的配置文件 &gt; 全局配置文件 &gt; 系统级配置文件 4. 文件 .git/index实际上就是一个包括文件索引的目录树,像是一个虚拟的工作区,记录了文件名和文件的状态信息(时间戳和文件长度),文件的内容保存在.git/objects目录下,文件索引建立了文件和对象库中对象实体之间的对应 工作区,版本区,暂存区原理图 git","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.songshuiyang.site/tags/git/"}]},{"title":"编译构建部署版本工具","slug":"backend/buildTool/git/如何修改Git commit的信息","date":"2017-10-14T08:38:12.000Z","updated":"2018-06-06T13:06:57.974Z","comments":true,"path":"2017/10/14/backend/buildTool/git/如何修改Git commit的信息/","link":"","permalink":"http://www.songshuiyang.site/2017/10/14/backend/buildTool/git/如何修改Git commit的信息/","excerpt":"","text":"转自：http://www.cnblogs.com/shenh062326/p/git.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.songshuiyang.site/tags/git/"}]},{"title":"Hibernate Validator","slug":"backend/framework/Hibernate/Hibernate Validator","date":"2017-10-14T04:28:12.000Z","updated":"2018-02-26T12:31:59.018Z","comments":true,"path":"2017/10/14/backend/framework/Hibernate/Hibernate Validator/","link":"","permalink":"http://www.songshuiyang.site/2017/10/14/backend/framework/Hibernate/Hibernate Validator/","excerpt":"","text":"Hibernate ValidatorHibernate Validator 是 Bean Validation 的参考实现 。Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。 1. Bean Validation 中内置的 constraint 注解 作用 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 2. Hibernate Validator 附加的 constraint 注解 作用 @Email 被注释的元素必须是电子邮箱地址 @Length(min=, max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=, max=) 被注释的元素必须在合适的范围内 @NotBlank 被注释的字符串的必须非空 @URL(protocol=,host=, port=, regexp=, flags=) 被注释的字符串必须是一个有效的url @CreditCardNumber 被注释的字符串必须通过Luhn校验算法， 银行卡，信用卡等号码一般都用Luhn 计算合法性 @ScriptAssert (lang=, script=, alias=) 要有Java Scripting API 即JSR 223 (“Scripting for the JavaTM Platform”)的实现 @SafeHtml(whitelistType=, additionalTags=) classpath中要有jsoup包 举个栗子123456789101112131415161718192021222324252627282930public class User &#123; @NotBlank private String name; //年龄要大于18岁 @Min(18) private int age; @Email private String email; //嵌套验证 @Valid private Product products; ... //省略getter，setter &#125; public class Product &#123; @NotBlank private String name; //价格在10元-50元之间 @Range(min=10,max=50) private int price; ... //省略getter，setter &#125; 转自:http://blog.csdn.net/u011851478/article/details/51842157","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"编译构建部署版本工具","slug":"backend/buildTool/grandle","date":"2017-10-13T17:07:12.000Z","updated":"2018-02-26T12:31:59.953Z","comments":true,"path":"2017/10/14/backend/buildTool/grandle/","link":"","permalink":"http://www.songshuiyang.site/2017/10/14/backend/buildTool/grandle/","excerpt":"","text":"Grandle gradle 易百教程http://www.yiibai.com/gradle/ Gradle学习系列之一——Gradle快速入门http://www.cnblogs.com/CloudTeng/p/3417762.html android grandlehttp://www.jianshu.com/p/9df3c3b6067a","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"github","slug":"technology/github","date":"2017-10-08T14:10:12.000Z","updated":"2018-03-16T14:41:21.170Z","comments":true,"path":"2017/10/08/technology/github/","link":"","permalink":"http://www.songshuiyang.site/2017/10/08/technology/github/","excerpt":"","text":"watch、star、fork 的使用watch 对于别人的项目，默认自己都处于 Not watching 的状态，当你选择 Watching，表示你以后会关注这个项目的所有动态，这个项目以后只要发生变动，如被别人提交了 pull request、被别人发起了issue等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。 star 当你点击 star，表示你喜欢这个项目或者通俗点，可以把他理解成朋友圈的点赞吧，表示对这个项目的支持 fork 当选择 fork，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步（注意）。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"计算属性","slug":"frontend/计算属性","date":"2017-10-05T02:52:12.000Z","updated":"2018-02-26T12:31:58.991Z","comments":true,"path":"2017/10/05/frontend/计算属性/","link":"","permalink":"http://www.songshuiyang.site/2017/10/05/frontend/计算属性/","excerpt":"","text":"计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125;","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.songshuiyang.site/tags/vue/"}]},{"title":"v-model v-bind","slug":"frontend/v-model和v-bind的区别","date":"2017-10-05T02:12:12.000Z","updated":"2018-02-26T12:31:58.979Z","comments":true,"path":"2017/10/05/frontend/v-model和v-bind的区别/","link":"","permalink":"http://www.songshuiyang.site/2017/10/05/frontend/v-model和v-bind的区别/","excerpt":"","text":"Mustache (双大括号写法)不能在 HTML 属性中使用，应使用 v-bind 指令：1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除：1&lt;button v-bind:disabled=&quot;someDynamicCondition&quot;&gt;Button&lt;/button&gt; v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=”表达式” v-bind用于绑定属性和数据 ，其缩写为“ : ” 也就是v-bind:id === :id v-model用在表单控件上的，用于实现双向数据绑定，所以如果你用在除了表单控件以外的标签是没有任何效果的。 v-bind1234567891011121314151617181920212223&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.songshuiyang.site/tags/vue/"}]},{"title":"Vue.js","slug":"frontend/Vue","date":"2017-10-03T14:40:12.000Z","updated":"2018-02-26T12:31:58.934Z","comments":true,"path":"2017/10/03/frontend/Vue/","link":"","permalink":"http://www.songshuiyang.site/2017/10/03/frontend/Vue/","excerpt":"前缀 $，实例属性与方法这些只是Vue的命名规则，为了缺分普通变量属性，避免我们自己声明或者添加自定义属性导致覆 生命周期beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载","text":"前缀 $，实例属性与方法这些只是Vue的命名规则，为了缺分普通变量属性，避免我们自己声明或者添加自定义属性导致覆 生命周期beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 生命周期 lifecyc 生命周期钩子 Lifecycle 钩子函数 钩子函数就是指再所有函数执行前，我先执行了的函数，即 钩住 我感兴趣的函数，只要它执行，我就先执行,这个解释666 双向绑定v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。 数据如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如： 1234567data: &#123; newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null&#125; 一个对象的 v-for123&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 12345678910new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, age: 30 &#125; &#125;&#125;) 索引 key value 123&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 123456789101112&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; vue模板只能有一个根对象1234&lt;template&gt; &lt;h2&gt;底部&lt;/h2&gt; &lt;span v-text=\"msgFromFather\"&gt;&lt;/span&gt;&lt;/template&gt; 报错1Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 原来vue模板只能有一个根对象所以你想要出现正常的效果，你的用一个div来或是别的标签来包裹全部的元素123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;底部&lt;/h2&gt; &lt;span v-text=\"msgFromFather\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.songshuiyang.site/tags/vue/"}]},{"title":"嵌入网易云插件","slug":"essay/网易云","date":"2017-10-01T06:31:12.000Z","updated":"2018-03-11T11:21:16.779Z","comments":true,"path":"2017/10/01/essay/网易云/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/essay/网易云/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.songshuiyang.site/categories/随笔/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"其他插件","slug":"technology/其他插件","date":"2017-10-01T06:31:12.000Z","updated":"2017-10-01T06:45:36.150Z","comments":true,"path":"2017/10/01/technology/其他插件/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/technology/其他插件/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"增加畅言功能","slug":"technology/增加畅言功能","date":"2017-10-01T05:31:12.000Z","updated":"2017-10-01T06:10:46.922Z","comments":true,"path":"2017/10/01/technology/增加畅言功能/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/technology/增加畅言功能/","excerpt":"","text":"畅言- 专业的社会化评论系统 网址:https://changyan.kuaizhan.com/ 添加功能: 根据上面的网址注册 复制 畅言秘钥(SourceID) 复制以下代码，并粘贴到您网页源代码的123456789```aidl&lt;div id=&quot;SOHUCS&quot; sid=&quot;请将此处替换为配置SourceID的语句&quot;&gt;&lt;/div&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/changyan.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.changyan.api.config(&#123;appid: &apos;cytf5fPKF&apos;,conf: &apos;prod_ee3a22e2c13174e193691fbc93e3cbc8&apos;&#125;);&lt;/script&gt; 效果: view 网站需要备案,不然只有15天的试用期: ICP备案： 只要网站在国内不管网站大小都需要在工信部网站在线申请备案号，但提供的审核资料可能就是不真实的，因为工信部不会去实际的核实。工信部要求的仅仅是有备案号即视为合法网站","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"nodeJs","slug":"frontend/nodeJs","date":"2017-10-01T03:48:12.000Z","updated":"2018-02-26T12:31:58.947Z","comments":true,"path":"2017/10/01/frontend/nodeJs/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/frontend/nodeJs/","excerpt":"","text":"Node.jsNode.js 让 JavaScript 编写服务器端应用程序成为可能。它建立在 JavaScript V8（C++ 编写的） 运行时之上，所以它很快。最初，它旨在为应用程序提供服务器环境，但是开发人员开始利用它来创建工具，帮助他们本地的任务自动化。此后，一个全新基于 Node 工具（如 Grunt 和 Gulp）的生态系统，使得前端开发改头换面。 要使用 Node.js 中的这些工具（或包），我们需要一种有效的方式来安装和管理它们。这就要用到node 包管理器： npm 了。它能够安装你想要的包，而且提供一个强大接口来使用它们。在使用 npm 之前，首先得在系统上安装 Node.js。 NPM（node package manager）node包管理器 将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 package.json包描述信息如果我们的项目依赖了很多package，一个一个地安装那将是个体力活。我们可以将项目依赖的包都在package.json这个文件里声明，然后一行命令搞定 1npm install 安装方式本地安装：package会被下载到当前所在目录，也只能在当前目录下使用。 全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。’ devDependencies和dependencies的区别使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如： –save-dev –save 但是当安装新包的时候如何让它保持最新呢？我们可以使用 –save 标识。 在 package.json 文件里面提现出来的区别就是，使用 –save-dev 安装的 插件，被写入到 devDependencies 对象里面去，而使用 –save 安装的插件，责被写入到 dependencies 对象里面去。 那 package.json 文件里面的 devDependencies 和 dependencies 对象有什么区别呢？ devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"node","slug":"node","permalink":"http://www.songshuiyang.site/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://www.songshuiyang.site/tags/npm/"}]},{"title":"Java基础-枚举类","slug":"backend/java/basicKnowledge/Java基础-枚举类","date":"2017-09-29T15:32:12.000Z","updated":"2019-05-04T03:16:45.365Z","comments":true,"path":"2017/09/29/backend/java/basicKnowledge/Java基础-枚举类/","link":"","permalink":"http://www.songshuiyang.site/2017/09/29/backend/java/basicKnowledge/Java基础-枚举类/","excerpt":"","text":"枚举是用来构建常量数据结构的模板，这个模板可扩展。枚举的使用增强了程序的健壮性 1. 常量12345public enum Color &#123; RED, GREEN, BLANK, YELLOW &#125; 2. switch1234567891011121314151617181920212223public class B &#123; public static void main(String[] args) &#123; showColor( Color.RED ); &#125; static void showColor(Color color)&#123; switch ( color ) &#123; case BLANK: System.out.println( color ); break; case RED : System.out.println( color ); break; default: System.out.println( color ); break; &#125; &#125;&#125; 3. 自定义函数public enum Color { RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); private String name ; private int index ; private Color( String name , int index ){ this.name = name ; this.index = index ; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; }","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Spring Assert","slug":"backend/framework/spring/Assert 的学习","date":"2017-09-28T16:01:44.000Z","updated":"2018-02-26T12:31:59.350Z","comments":true,"path":"2017/09/29/backend/framework/spring/Assert 的学习/","link":"","permalink":"http://www.songshuiyang.site/2017/09/29/backend/framework/spring/Assert 的学习/","excerpt":"","text":"Assert（当要判断一个方法传入的参数时，我们就可以使用断言。） package org.springframework.util 1. notNull(Object object)当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null； 2. isTrue(boolean expression) / isTrue(boolean expression, String message)当 expression 不为 true 抛出异常； 3. notEmpty(Collection collection) / notEmpty(Collection collection, String message)当集合未包含元素时抛出异常。 notEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断； 4. hasLength(String text) / hasLength(String text, String message)当 text 为 null 或长度为 0 时抛出异常； 5. hasText(String text) / hasText(String text, String message)text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常； 6. isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message)如果 obj 不能被正确造型为 clazz 指定的类将抛出异常； 7. isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message)subType 必须可以按类型匹配于 superType，否则将抛出异常；","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Hibernate 问题记录","slug":"backend/framework/Hibernate/hibernate问题集合","date":"2017-09-24T08:54:12.000Z","updated":"2018-02-26T12:31:59.070Z","comments":true,"path":"2017/09/24/backend/framework/Hibernate/hibernate问题集合/","link":"","permalink":"http://www.songshuiyang.site/2017/09/24/backend/framework/Hibernate/hibernate问题集合/","excerpt":"","text":"org.hibernate.MappingException: Unknown entity常见问题 可能原因一 检查实体类是否导入的是 javax.persistence 下的包 可能原因二 没有在cfg文件中加入 *.hbm.xml造成的 hibernate版本问题,一代版本一代神 4.5 版本 1ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).build(); 5.2 版本 1ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build();","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"Hibernate笔记","slug":"backend/framework/Hibernate/Hibernate笔记","date":"2017-09-23T15:28:12.000Z","updated":"2018-02-26T12:31:59.068Z","comments":true,"path":"2017/09/23/backend/framework/Hibernate/Hibernate笔记/","link":"","permalink":"http://www.songshuiyang.site/2017/09/23/backend/framework/Hibernate/Hibernate笔记/","excerpt":"","text":"hibernate.properties 使用 hibernate.properties 文件配置Hibernate 需要在代码里面手动添加持久化类,所以在实际开发中不使用hibernate.property 文件作为配置文件的原因","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"Hibernate 例子","slug":"backend/framework/Hibernate/Hibernate","date":"2017-09-23T15:28:12.000Z","updated":"2018-02-26T12:31:59.041Z","comments":true,"path":"2017/09/23/backend/framework/Hibernate/Hibernate/","link":"","permalink":"http://www.songshuiyang.site/2017/09/23/backend/framework/Hibernate/Hibernate/","excerpt":"概述: 面向Java环境的对象/关系数据库映射工具,用于将面向对象模型表示的对象映射到基于SQL的关系模型的数据结构中,消除那些针对特定数据库厂商的SQL代码,并把结果集从表格式的形式转换成值对象的形式","text":"概述: 面向Java环境的对象/关系数据库映射工具,用于将面向对象模型表示的对象映射到基于SQL的关系模型的数据结构中,消除那些针对特定数据库厂商的SQL代码,并把结果集从表格式的形式转换成值对象的形式 Hibernate的数据库操作直接采用了POJO(普通的传统的Java对象)作为持久化类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hibernate.entity;import javax.persistence.*;/** * @author songshuiyang * @title: * @description: * @date 2017/9/23 23:41 */@Entity /*标明持久化类*/@Table(name = &quot;user&quot;)public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键生成策略 private String id; private String name; private int sex; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&apos;&quot; + id + &apos;\\&apos;&apos; + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, sex=&quot; + sex + &apos;&#125;&apos;; &#125;&#125; Hibernate基本上是使用了JPA的标准注解(javax.persistence) JPA JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。 JPA是一种规范，而Hibernate是它的一种实现。除了Hibernate，还有EclipseLink(曾经的toplink)，OpenJPA等可供选择，所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。 配置文件 (#.properties , XML配置文件的形式)1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定连接数据库所用的驱动 --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 指定连接数据库的url，其中hibernate是本应用连接的数据库名 --&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost/ecut&lt;/property&gt; &lt;!-- 指定连接数据库的用户名 --&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;!-- 指定连接数据库的密码 --&gt; &lt;property name=&quot;connection.password&quot;&gt;root&lt;/property&gt; &lt;!-- 指定连接池里最大连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt; &lt;!-- 指定连接池里最小连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;1&lt;/property&gt; &lt;!-- 指定连接池里连接的超时时长 --&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;5000&lt;/property&gt; &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/property&gt; &lt;!-- 指定数据库方言 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 根据需要自动创建数据表 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;&lt;!--①--&gt; &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 将SQL脚本进行格式化后再输出 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;mapping class=&quot;com.hibernate.entity.User&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试方法1234567891011121314151617181920212223242526public class UserManagerTest &#123; @Test public void test1()&#123; // 实例化Configuration， Configuration conf = new Configuration().configure(); ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build(); // 以Configuration实例创建SessionFactory实例 SessionFactory sf = conf.buildSessionFactory(serviceRegistry); // 创建Session Session sess = sf.openSession(); // 开始事务 Transaction tx = sess.beginTransaction(); // 创建消息对象 User user = new User(); // 设置消息标题和消息内容 user.setName(&quot;hibernate&quot;); user.setSex(12); sess.save(user); // 提交事务 tx.commit(); // 关闭Session sess.close(); sf.close(); &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"Java基础-Java位运算","slug":"backend/java/basicKnowledge/Java基础-位运算","date":"2017-09-22T11:24:12.000Z","updated":"2019-05-04T03:16:45.447Z","comments":true,"path":"2017/09/22/backend/java/basicKnowledge/Java基础-位运算/","link":"","permalink":"http://www.songshuiyang.site/2017/09/22/backend/java/basicKnowledge/Java基础-位运算/","excerpt":"","text":"与运算符 &amp;int a=129; int b=128; a &amp; b = 128 解析: “a”的值是129，转换成二进制就是10000001，而“b”的值是128，转换成二进制就是10000000。根据与运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128。 或运算 |int a=129; int b=128; a &amp; b = 129 解析: a 的值是129，转换成二进制就是10000001，而b 的值是128，转换成二进制就是10000000，根据或运算符的运算规律，只有两个位有一个是1，结果才是1，可以知道结果就是10000001，即129。 非运算符 ~如果位为0，结果是1，如果位为1，结果是0 异或运算符 ^异或运算符是用符号“^”表示的，其运算规律是： 两个操作数的位中，相同则结果为0，不同则结果为1。下面看一个简单的例子。 int a=15; int b=2; a^b a 与 b 异或的结果是：13 分析上面的程序段：a 的值是15，转换成二进制为1111，而b 的值是2，转换成二进制为0010，根据异或的运算规律，可以得出其结果为1101 即13。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java集合-遍历Map","slug":"backend/java/collection/Java集合-遍历Map","date":"2017-09-22T11:00:12.000Z","updated":"2019-05-04T03:16:45.514Z","comments":true,"path":"2017/09/22/backend/java/collection/Java集合-遍历Map/","link":"","permalink":"http://www.songshuiyang.site/2017/09/22/backend/java/collection/Java集合-遍历Map/","excerpt":"","text":"Java中如何遍历Map对象的4种方法 既然java中的所有map都实现了Map接口，以下方法适用于任何map实现（HashMap, TreeMap, LinkedHashMap, Hashtable, 等等） 方法一: 在for-each循环中使用entries来遍历 这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用1234567Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); &#125; 注意：for-each循环在java 5中被引入所以该方法只能应用于java 5或更高的版本中。如果你遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此在遍历前你总是应该检查空引用。 方法二: 在for-each循环中遍历keys或values。 如果只需要map中的键或者值，你可以通过keySet或values来实现遍历，而不是用entrySet。1234567891011121314151617Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //遍历map中的键 for (Integer key : map.keySet()) &#123; System.out.println(\"Key = \" + key); &#125; //遍历map中的值 for (Integer value : map.values()) &#123; System.out.println(\"Value = \" + value); &#125; 该方法比entrySet遍历在性能上稍好（快了10%），而且代码更加干净。 方法三: 使用Iterator遍历 使用泛型：1234567891011Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = entries.next(); System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); &#125; 不使用泛型:123456789101112131415Map map = new HashMap(); Iterator entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry entry = (Map.Entry) entries.next(); Integer key = (Integer)entry.getKey(); Integer value = (Integer)entry.getValue(); System.out.println(\"Key = \" + key + \", Value = \" + value); &#125; 你也可以在keySet和values上应用同样的方法。 该种方式看起来冗余却有其优点所在。首先，在老版本java中这是惟一遍历map的方式。另一个好处是，你可以在遍历时调用iterator.remove()来删除entries，另两个方法则不能。根据javadoc的说明，如果在for-each遍历中尝试使用此方法，结果是不可预测的。 从性能方面看，该方法类同于for-each遍历（即方法二）的性能。 方法四: 通过键找值遍历（效率低） 作为方法一的替代，这个代码看上去更加干净；但实际上它相当慢且无效率。因为从键取值是耗时的操作（与方法一相比，在不同的Map实现中该方法慢了20%~200%）。如果你安装了FindBugs，它会做出检查并警告你关于哪些是低效率的遍历。所以尽量避免使用。123456789Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Integer key : map.keySet()) &#123; Integer value = map.get(key); System.out.println(\"Key = \" + key + \", Value = \" + value); &#125; 总结如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)。 转自：http://blog.csdn.net/tjcyjd/article/details/11111401","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java基础-概念","slug":"backend/java/basicKnowledge/Java基础-概念","date":"2017-09-21T15:47:12.000Z","updated":"2019-05-04T03:16:45.583Z","comments":true,"path":"2017/09/21/backend/java/basicKnowledge/Java基础-概念/","link":"","permalink":"http://www.songshuiyang.site/2017/09/21/backend/java/basicKnowledge/Java基础-概念/","excerpt":"","text":"全局变量和static修饰的局部变量 默认初始化为 0 。因为全局变量和static静态局部变量存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 0x00。 Java中的switch-case语句 switch接受的参数类型有10种，分别是基本类型的byte,short,int,char，以及引用类型的String(只有JavaSE 7 和以后的版本 可以接受String类型参数),enum和byte,short,int,char的封装类Byte,Short,Integer,Charactercase 后紧跟常量表达式，不能是变量。 Maps.newHashMap(); Map result = new HashMap(); 上面这种是java原生API写法 下面这种是google的guava.jar提供的写法，目的是为了简化代码。唯一的区别就是简化代码 Map result = Maps.newHashMap(); 泛型 仅仅是java的一颗语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。 重载的概念 方法名称相同，参数个数、次序、类型不同 因此重载对返回值没有要求，可以相同，也可以不同 但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"常见的编码方式","slug":"backend/other/常见的编码方式","date":"2017-09-21T12:54:12.000Z","updated":"2018-02-26T12:31:59.816Z","comments":true,"path":"2017/09/21/backend/other/常见的编码方式/","link":"","permalink":"http://www.songshuiyang.site/2017/09/21/backend/other/常见的编码方式/","excerpt":"计算机为什么要编码在计算机中所有的数据都是以0,1来存储的,那字符是怎样在计算机存储的呢,美国的科学家把一个特定的数字对应一个特定的字母进行存储和传输，比如我需要存储字母a，那么我存入一个数字97(即在计算机中存入二进制(01100001)，这个过程叫做编码(encode)，而我们在读取数据的时候，当遇到97时，我们就让计算机显示字母a，这个过程叫做解码(decode)。 编码发展历史简介","text":"计算机为什么要编码在计算机中所有的数据都是以0,1来存储的,那字符是怎样在计算机存储的呢,美国的科学家把一个特定的数字对应一个特定的字母进行存储和传输，比如我需要存储字母a，那么我存入一个数字97(即在计算机中存入二进制(01100001)，这个过程叫做编码(encode)，而我们在读取数据的时候，当遇到97时，我们就让计算机显示字母a，这个过程叫做解码(decode)。 编码发展历史简介 第一阶段ASCII规则: 所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。 把所有的标点符号，英文大小写全部放在32-126范围中。 防止以后出现需要补充的情况，把128-255位这么多位置留出来，应该足够用了吧！所以设置一个字节8位二进制，把这个标准叫American Standard Code for Information Interchange(美国标准信息交换代码，简写为ASCII)，标准制定结束。 实现方式: 第一位始终未0，后面7位表示0-127的范围，一个数字对应一个字母或者标点符号，亦或者控制符号，即所有的ASCII码的统一形式为0xxxx xxxx。 第二阶段 GB2312,GBK, BIG5 Latin1, ISO-8859-1, JIS, ANSI… 计算机技术到了欧洲，欧洲人发现怎么我们的那么多符号没有编进去啊！所以欧洲”砖家”坐到了一起，开始讨论。发现既然美国人把第一位流出来了，那么我们就用128-255的位置好了。 规则: 128-159之间为控制字符，160-255位文字符号，其中包括了西欧语言、希腊语、泰语、阿拉伯语、希伯来语。 刚好把美国人给的空间全部用完，世界真美好，谢谢美利坚预留的每一个位置。 砖家们决定把他们的编码名称叫做Latin1，后面由于欧洲统一制定ISO标准，所以又有了一个ISO的名称，即ISO-8859-1。 实现方式: 0-127的所有位置不动，那么可以兼容ASCII，二进制位0xxx xxxx 128-255位置全部用完，二进制位1xxx xxxx由于所有的位置全部用完，而欧元符号实在指定标准之后才出现的，所以在这个码表中连欧洲人自己的货币符号都没有办法放进去。 计算机技术当然也传到了亚洲大地，比如中国。中国砖家们坐在一起发现，美国人搞的这个东西真的有问题，预留才128-255的空间，可是我们的汉字个数远远超出了这个数目啊，怎么办？？后面聪明的中国砖家们发现，只能使用2个字节了，否则真的搞不定。由于必须和美国原来制定的ASCII不冲突，所以指定了如下规则 规则: 如果一个字节中第一位为0，那么这就是一个ASCII字符。 如果一个字节中第一位为1，那么这个是汉字，认定需要2个字节才表示一个编码的文字。把这个码表叫GB2312这个码表中包含汉字6763个和非汉字图形字符682个。还有很多的空间没有用到，索性全部预留了吧。 实现方式: 0xxxxxxx：表示为ASCII字符 -1xxxxxxx 1xxxxxxx：表示为汉字 后面再次添加更多的字符进去，再次命名为GB18030，兼容GBK。由于汉字很多，2个字节并不能完全包括进去，所以GB18030采用2\\4位混编的形式。 当然计算机也传到了日本(JIS)、韩国、台湾(BIG5)等等地方，大家全部发挥自己的聪明才智，各自实现了自己的编码。这些编码都与ASCII兼容，但是相互之间不兼容。 使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为”MBCS（Muilti-Bytes Charecter Set，多字节字符集）”。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 windows下要转码成gb2312,gbk只需要把文本保存为ANSI编码即可。 不同ANSI编码之间互不兼容 第三阶段 随着通讯越来越多，而老美发现在自己公司需要国际化的时候，自己原来埋的这个雷真的害了自己。于是乎，开始研讨把世界上几乎所有文字全部放在一个码表中，而这个包罗万象的码表就叫做Unicode，即万国码。Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。实际上，在软件制造商的协会（unicode.org）在做这个工作时，国际标准化组织（ISO）在做同样的事情，最后大家都意识到世界上并不需要两个不同的万国码，于是大家坐在一起合并研究的成果，最后的结果就是现在的Unicode。 各个编码及其范围ASCII编码范围00-7F，其中00-1F、FF为控制字符。其它为英文字母、数字、标点符号。 Latin1编码范围00-FF，其中00-7F同ASCII，80-9F为控制符、9F-FF为字母和标点符号. CP1252微软的企业标准，补充了一些符号和欧元符号，为Latin1的超集。 GB2312编码范围为A1A1-F7FE(剔除xx7F)，共23940个码位。其中很多区间没有用到，而汉字使用的区间为B0A1-F7FE，其他为标点符号和特殊字符。除常用简体汉字字符外还包括希腊字母、日文平假名及片假名字母、俄语西里尔字母等字符，未收录繁体中文汉字和一些生僻字。对汉字进行了分区管理，其中第一个字节为区位码，包括下面区位。01-09区为特殊符号。16-55区为一级汉字，按拼音排序。56-87区为二级汉字，按部首/笔画排序。10-15区及88-94区则未有编码。第二个字节为位字节，01-94总计94个。为什么实际选择不是01-5E，而是选择A1-F7的位置呢？因为英文可见字符区间为20-7F，加上128(也就是最高位为1)后得到的取件即是A1-FE区位码使用了0xA1-0xF7(把01-87区的区号加上0xA0)，位字节使用了0xA1-0xFE(把01-94加上 0xA0) GBK编码范围为8140-FEFE,兼容GB2312，仍然有部分区间没有用到。GBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的 汉字部首符号、竖排标点符号等字符。GBK对GB2312就是，你有的，我也有，你没得的，我还有！ CP936CP936是微软指定的标准，属于企业标准，和GBK的有些许差别，绝大多数情况下可以把CP936当作GBK的别名。 BIG5Big5是双字节编码，高字节编码范围是0x81-0xFE，低字节编码范围是0x40-0x7E和0xA1-0xFE。和GBK相比，少了低字节是0x80-0xA0的组合。0x8140-0xA0FE是保留区域，用于用户造字区。Big5收录的汉字只包括繁体汉字，不包括简体汉字，一些生僻的汉字也没有收录。 CP950微软的企业标准，可以理解为是对 Big5的扩展。 GB18030编码范围同GBK，补充了更多的字符，由于Unicode开始流行且GB18030补充的字符都比较生僻，所以实际使用上基本是GBK。GB18030编码是变长编码，有单字节、双字节和四字节三种方式。GB18030的单字节编码范围是0x00-0x7F，完全等同与ASCII；双字节编码的范围和GBK相同，高字节是0x81-0xFE，低字节的编 码范围是0x40-0x7E和0x80-FE；四字节编码中第一、三字节的编码范围是0x81-0xFE，二、四字节是0x30-0x39。 Unicode中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。一个蛋疼的问题就是这个区间全部都是文字，中文标点没有包含在其中，中文标点散落在各个位置。详细请看http://blog.chinaunix.net/uid-12348673-id-3335307.html。一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，详细情况可以参考网址：http://www.cnblogs.com/sosoft/p/3456631.html Unicode的实现方式 Unicode只是进行了编码，也就是说只是一个码表，至于具体怎么实现，并没有规定。下面是Unicode的几种实现方法。 Unicode UTF-8之间的关系简单来说：Unicode 是「字符集」 UTF-8 是「编码规则」 其中： 字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point） 编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程） Unicode定义了所有可以用来表示字符的数值集合（称之为Code Point）。UTF-8和UTF-16等UTF标准定义了这些数值和字符的映射关系。 正如名字所示，在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分，例如，在UTF－8和ASCII中，“A”的编码都是0x41.UTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。 UTF-8 (UCS Transfer Format:Unicode转做某种格式)UTF-8以字节为单位对Unicode进行编码。 从Unicode到UTF-8的编码方式如下： Unicode编码(16进制) ║ UTF-8 字节流(二进制) 000000 - 00007F ║ 0xxxxxxx 000080 - 0007FF ║ 110xxxxx 10xxxxxx 000800 - 00FFFF ║ 1110xxxx 10xxxxxx 10xxxxxx 010000 - 10FFFF ║ 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 特点:UTF-8的特点是对不同范围的字符使用不同长度的编码 UTF-16在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。而在辅助平面定义的字符，会以代理对（surrogate pair）的形式，以两个2字节的值来储存。UTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16却无法兼容于ASCII编码。可以认为UTF-16是下面介绍的UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的是同一的意思。但当引入辅助平面字符后，就称为UTF-16了。现在若有软件声称自己支援UCS-2编码，那其实是暗指它不能支援在UTF-16中超过2bytes的字集。对于小于0x10000的UCS码，UTF-16编码就等于UCS码。如果一个UTF-16文件没有指定BOM，默认应该是UTF-16BE，但是在Intel x86中却是UTF-16LE。所以在现实世界中有很多的没有指定大小尾的UTF-16却是UTF-16LE。 UTF-32每一个Unicode码位使用恰好32位元。可以粗暴的认为UTF-32和下面要介绍的UCS-4是等同的。 UCS-2采用2个字节，定长的表示每一个字符，所以总计可以表示2^16个字符。 UCS-4UCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行(rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。group 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。 转自:http://www.cnblogs.com/jessonluo/p/4800331.html 编码检测到底采用什么编码，如果能检测就好了。专家们也是这么想的，所以专家给每种格式和字节序规定了一些特殊的编码， 这些编码在unicode 中是没有使用的，所以不用担心会冲突。 这个叫做BOM（Byte Order Mark）头。意思是字节序标志头。通过它基本能确定编码格式和字节序。 UTF编码 ║ Byte Order Mark UTF-8 ║ EF BB BF UTF-16LE ║ FF FE UTF-16BE ║ FE FF UTF-32LE ║ FF FE 00 00 UTF-32BE ║ 00 00 FE FF所以通过检测文件前面的BOM头，基本能确定编码格式和字节序。但是这个BOM头只是建议添加，不是强制的，所以不少软件和系统没有添加这个BOM头（所以有些软件格式中有带BOM头 和NoBOM头的选择），这个时候要检测什么格式，就比较麻烦了当然可以检测，但是不能保证100%准确，只能通过编码范围从概率上来检查，虽然准确度还是比较高，但是不能保证 100%。所以，时常看到检测错误的软件，也不奇怪了。 UTF-8 与UTF-16的区别 UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊. 于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定. 于是UTF-8和UTF-16的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用UTF-8就比UTF-16节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16就占优势了,可以节省很多空间.另外还有个容错问题,等会再讲","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Struts2 问题总结","slug":"backend/framework/Struts2/Struts2 问题总结","date":"2017-09-19T08:12:44.000Z","updated":"2018-02-26T12:31:59.545Z","comments":true,"path":"2017/09/19/backend/framework/Struts2/Struts2 问题总结/","link":"","permalink":"http://www.songshuiyang.site/2017/09/19/backend/framework/Struts2/Struts2 问题总结/","excerpt":"","text":"上传图片出现错误但是，明明上传的文件格式是正确，还是出现： Content-Type not allowed: file &quot;09poC_wallpapers.jpg&quot; &quot;upload_1ea6fe4e_13611ac7d7c__8000_00000012.tmp&quot; image/pjpeg firefox 和 ie 的文件类型区别 Firefox： image/jpeg, image/bmp, image/gif, image/png ie 6： image/pjpeg ,image/bmp, image/gif, image/x-png ie 7： image/pjpeg, image/bmp, image/gif, image/x-png ie 8： image/pjpeg, image/bmp, image/gif, image/x-png Ie 9： image/jpeg, image/bmp, image/gif, image/png 解决方法 &lt;param name=&quot;allowedTypes&quot;&gt; image/bmp,image/png,image/gif,image/jpeg,image/jpg, image/pjpeg ,image/bmp, image/gif, image/x-png, &lt;/param&gt;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"struts2","slug":"struts2","permalink":"http://www.songshuiyang.site/tags/struts2/"}]},{"title":"Struts2 的简单实例","slug":"backend/framework/Struts2/Struts2 的简单实例","date":"2017-09-16T13:30:44.000Z","updated":"2018-02-26T12:31:59.540Z","comments":true,"path":"2017/09/16/backend/framework/Struts2/Struts2 的简单实例/","link":"","permalink":"http://www.songshuiyang.site/2017/09/16/backend/framework/Struts2/Struts2 的简单实例/","excerpt":"","text":"Struts2 实现流程 浏览器发送请求 到达 StrutsPrepareAndExecuteFilter ( 核心控制器 ) 分发到指定 XXXAction ( 业务控制器 ) 调用业务方法 返回逻辑视图名 StrutsPrepareAndExecuteFilter forward到物理视图,生成响应内容，输出响应","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"struts2","slug":"struts2","permalink":"http://www.songshuiyang.site/tags/struts2/"}]},{"title":"Servlet-web.xml中配置JSP属性","slug":"backend/java/servlet/Servlet-web.xml中配置JSP属性","date":"2017-09-15T08:19:45.000Z","updated":"2019-05-04T03:21:13.673Z","comments":true,"path":"2017/09/15/backend/java/servlet/Servlet-web.xml中配置JSP属性/","link":"","permalink":"http://www.songshuiyang.site/2017/09/15/backend/java/servlet/Servlet-web.xml中配置JSP属性/","excerpt":"","text":"web.xml中配置JSP属性 为什么要在web.xml配置JSP属性 如果许多JSP有着相似的属性，那么在每个JSP文件的顶部重复添加page指令是非常麻烦的工作。幸运的是，在部署描述符中可以配置通用的JSP属性。 web.xml中添加JSP属性样例 &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspf&lt;/url-pattern&gt; &lt;page-encoding&gt;UTF-8&lt;/page-encoding&gt; &lt;scripting-invalid&gt;false&lt;/scripting-invalid&gt; &lt;include-prelude&gt;/WEB-INF/jsp/base.jspf&lt;/include-prelude&gt; &lt;trim-directive-whitespaces&gt;true&lt;/trim-directive-whitespaces&gt; &lt;default-content-type&gt;text/html&lt;/default-content-type&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; 中可以包含任意数目的标签。通过为定义不同的标签来区分不同的属性组。 标签，将告诉容器在所有属于改该属性组的JSP的头部添加文件/WEB-INF/jsp/base.jspf。 标签定义了包含在组中所有JSP尾部的文件。 在一个JSP组中可以同时使用这些标签多次。 与page指令的pageEncoding特性一致。 标签可以定义内容类型，默认为text/html 也是一个特别有用的属性，该属性告诉JSP转换器删除响应输出中的空白，只保留指令、声明、脚本和其他JSP标签创建的文本。 标签可以实现完全禁止JSP中的Java 的作用类似，不过它对应的是page指令中的isELIgnored特性。除了，中所有标签都是可选的，但在使用它们时必须按照下面的顺序添加到中(忽略掉部希望使用的标签)：、、、、、、、、、、、。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"},{"name":"jsp","slug":"jsp","permalink":"http://www.songshuiyang.site/tags/jsp/"}]},{"title":"Servlet","slug":"backend/java/servlet/Servlet-概述","date":"2017-09-14T15:36:44.000Z","updated":"2018-02-26T12:31:59.263Z","comments":true,"path":"2017/09/14/backend/java/servlet/Servlet-概述/","link":"","permalink":"http://www.songshuiyang.site/2017/09/14/backend/java/servlet/Servlet-概述/","excerpt":"Servlet服务器端小程序,运行在服务器端的程序，用于处理及响应客户端的请求,自MVC规范出现之后,Servlet仅仅只作为控制器 Servlet和Jsp的区别 Servlet中没有内置对象,原来JSP中的内置对象都必须有程序显式创建 Servlet对于HTML标签只能使用页面输出流逐行输出，所以自MVC规范出现之后,Servlet仅仅只作为控制器","text":"Servlet服务器端小程序,运行在服务器端的程序，用于处理及响应客户端的请求,自MVC规范出现之后,Servlet仅仅只作为控制器 Servlet和Jsp的区别 Servlet中没有内置对象,原来JSP中的内置对象都必须有程序显式创建 Servlet对于HTML标签只能使用页面输出流逐行输出，所以自MVC规范出现之后,Servlet仅仅只作为控制器 @WebServlet从3.0开始配置Servlet可以使用注解的形式 有些人可能会遇到这种种情况，在采用注解WebServlet配置Servlet的时候，明明在配置了urlPatterns属性，部署应用程序的时候也没有出错。但是就是在浏览器发请求的时候访问不到资源，报404错误request resource is not available。捣腾了半天也不知道，到底是哪而出错了？ Servlet3.0之后新增了注解，用于简化Servlet、Filter及Listener的声明，这样就在配置Servlet的时候多了一个选择。Servlet3.0的部署描述文件web.xml的顶层标签有一个metadata-complete属性，该属性为true，则容器在部署时只依赖部署描述文件，忽略所有标注，如果不配置该属性，或者将其设置为false，则表示启动标注支持。当metadata-complete=”false”时，web.xml和注解对于Servlet的影响同时起作用，两种方法定义的url-partten都可以访问到该Servlet，但是当通过web.xml定义的url-partten访问时，注解定义的属性（初始化参数等）将失效。 属性值name String 指定Servlet 的 name 属性，等价于 。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。 value String[] 该属性等价于 urlPatterns 属性。两个属性不能同时使用。 urlPatterns String[] 指定一组 Servlet 的 URL 匹配模式。等价于标签。 loadOnStartup int 指定 Servlet 的加载顺序，等价于 标签。 initParams WebInitParam[] 指定一组 Servlet 初始化参数，等价于标签。 asyncSupported boolean 声明 Servlet 是否支持异步操作模式，等价于 标签。 description String 该 Servlet 的描述信息，等价于 标签。 displayName String 该 Servlet 的显示名，通常配合工具使用，等价于 标签。 创建Servlet有俩个时机 用户请求某个Servlet，系统创建该Servlet的实例,所以Servlet第一次访问的时间是较长的，因为要初始化Servlet Web应用启动立即创建Servlet实例,即load-on-startup Servlet Servlet 生命周期 创建实例 Web容器调用Servlet的init方法，对Servlet进行初始化。 初始化后将一直存在于容器中，用于响应客户端请求,get post service用于响应用户请求 通常在Web应用关闭之时销毁Servlet，先调用Servlet的destory()方法 使用Servlet作为表现层如有以下几个劣势 所有的Html标签都需要页面输出流完成 前端人员无法参与到页面的编写 可维护性差，页面代码不好调试","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"Servlet-JSP脚本中的九个内置对象","slug":"backend/java/servlet/Servlet-JSP脚本中的九个内置对象","date":"2017-09-14T07:25:44.000Z","updated":"2019-05-04T03:21:13.590Z","comments":true,"path":"2017/09/14/backend/java/servlet/Servlet-JSP脚本中的九个内置对象/","link":"","permalink":"http://www.songshuiyang.site/2017/09/14/backend/java/servlet/Servlet-JSP脚本中的九个内置对象/","excerpt":"JSP脚本中包含九个内置对象，这九个内置对象都是Servlet API接口的实例，只是JSP规范对它们进行了默认初始化（由JSP页面对应的Servlet的_jspService()方法来创建这些实例),也就是说它们已经是对象，可以直接使用 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable","text":"JSP脚本中包含九个内置对象，这九个内置对象都是Servlet API接口的实例，只是JSP规范对它们进行了默认初始化（由JSP页面对应的Servlet的_jspService()方法来创建这些实例),也就是说它们已经是对象，可以直接使用 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable page对象page对象表示当前一个JSP页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。page对象在开发中几乎不用，了解一下即可 out对象out对象代表一个页面输出流，通常用于在页面上输出变量值及常量。一般在使用输出表达式的地方都可以使用out对象达到同样的效果。out是个页面输出流，负责输出页面的内容，但是用out需要编写更多的代码。&lt;%= %&gt;表达式的本质就是out.write(…);对于页面上的某个html标签来讲 如果使用了out即 &lt;% out.println(“&lt;table&gt;”); out.println(“&lt;tr&gt;”); out.println(“&lt;/tr&gt;”); out.println(“&lt;/table&gt;”); %&gt; pageContext对象pageContext对象是JSP技术中最重要的一个对象，它代表JSP页面的运行环境，这个对象不仅封装了对其它8大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。 getException方法 返回exception隐式对象 getPage方法 返回page隐式对象 getRequest方法 返回request隐式对象 getResponse方法 返回response隐式对象 getServletConfig方法 返回config隐式对象 getServletContext方法返回application隐式对象 getSession方法 返回session隐式对象 getOut方法 返回out隐式对象 pageContext 封装其它8大内置对象的意义 如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，把pageContext传递给谁，谁就能成为一个动态web资源，那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢，在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了java代码，那么就应该想办法把java代码移除掉，我们可以开发一个自定义标签来移除jsp页面上的java代码，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个java类，在调用java类的时候就会把pageContext对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。 pageContext 作为域对象 pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。 pageContext对象的常用方法 1 public void setAttribute(java.lang.String name,java.lang.Object value) 2 public java.lang.Object getAttribute(java.lang.String name) 3 public void removeAttribute(java.lang.String name) 4 public java.lang.Object findAttribute(java.lang.String name) application 对象 在整个Web应用的多个JSP、Servlet之间的共享数据。通常被定义为数据字典来使用。通常在一处实现application.setAttribute(“name”,value);来定义一个变量，在JSP中使用application.getAttribute(“name”);获取值；在Servlet中使用一个实例的ServletContext对象sc.getAttribute(“name”);获取值。我们可以把application理解成一个Map对象，任何JSP、Servlet都可以把某个变量放入application中保存，并指出一个属性名；而该应用的其他JSP、Servlet就可以根据该属性名来得到这个变量。由于application对象代表整个Web应用，所以只应该把Web应用的状态数据放入到application中。 访问Web应用的配置参数，在web.xml中配置类似的参数，该标签是下的子标签。即 &lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/context-param&gt; 在JSP中可以通过 application.getInitParameter(“name”);取得配置的参数，在Servlet中可以先实例个ServletContext对象即： final javax.servlet.ServletContext application;然后就可以取值了，即： application = pageContext.getServletContext(); application.getInitParameter(&quot;name&quot;); 这里通常被用作普通java Web开发中数据库用户名，密码的获取时使用，因为在项目开发用的密码不一定和部署在服务器上的密码一致，但是把它写到这里便于修改这些有关项目的参数。 config 对象config对象代表当前的JSP配置信息，但JSP页面通常无需配置，因此也就不存在配置信息，该对象在JSP页面用的比较少，但在Servlet中用处则相对较大，因为Servlet需要在web.xml文件中进行配置，可以指定配置参数。但是如果说要为某个JSP配置一些参数的话，也是跟配置Servlet一样需要在web.xml中配置，也就说吧JSP当成Servlet配置 &lt;servlet&gt; &lt;servlet-name&gt;Configure&lt;/servlet-name&gt; &lt;jsp-file&gt;/getcontextparam.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;conn&lt;/param-name&gt; &lt;param-value&gt;connnn&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Configure&lt;/servlet-name&gt; &lt;url-pattern&gt;/configure&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中这里“/getcontextparam.jsp”是表明把某个JSP配置成Servlet。在地址栏中访问时要输入http://localhost:8080/test/configure（url-pattern中内容）在JSP中获取参数时使用config.getInitParameter(“conn”)即可。 exception 对象该实例代表其他页面的异常和错误,只有当页面是错误处理页面，即编译指令page的isErrorPage属性为true时,该对象才可以使用","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"},{"name":"jsp","slug":"jsp","permalink":"http://www.songshuiyang.site/tags/jsp/"}]},{"title":"Spring mvc整合velocity","slug":"backend/framework/velocity/Spring mvc整合velocity","date":"2017-09-11T08:12:12.000Z","updated":"2018-02-26T12:31:59.608Z","comments":true,"path":"2017/09/11/backend/framework/velocity/Spring mvc整合velocity/","link":"","permalink":"http://www.songshuiyang.site/2017/09/11/backend/framework/velocity/Spring mvc整合velocity/","excerpt":"添加Maven依赖:&lt;!--springmvc集成 velocity--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt;","text":"添加Maven依赖:&lt;!--springmvc集成 velocity--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; applicationContext-mvc配置文件:&lt;!--》》》》》》》》》》》》》》》 添加velocity显示技术 》》》》》》》》》》》》》》》》》--&gt; &lt;!-- velocity环境配置 --&gt; &lt;bean id=&quot;velocityConfig&quot; class=&quot;org.springframework.web.servlet.view.velocity.VelocityConfigurer&quot;&gt; &lt;!-- velocity配置文件路径 或者直接用velocityProperties属性 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:velocity.properties&quot;/&gt; &lt;!-- velocity模板路径 --&gt; &lt;property name=&quot;resourceLoaderPath&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;/bean&gt; &lt;!-- velocity视图解析器 --&gt; &lt;bean id=&quot;velocityViewResolver&quot; class=&quot;org.springframework.web.servlet.view.velocity.VelocityLayoutViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;0&quot;/&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot;/&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.vm&quot;/&gt; &lt;property name=&quot;layoutUrl&quot; value=&quot;layout/layout.vm&quot;/&gt; &lt;property name=&quot;exposeSpringMacroHelpers&quot; value=&quot;true&quot; /&gt;&lt;!--是否使用spring对宏定义的支持--&gt; &lt;property name=&quot;exposeSessionAttributes&quot; value=&quot;true&quot; /&gt;&lt;!--是否开放request属性--&gt; &lt;property name=&quot;requestContextAttribute&quot; value=&quot;request&quot;/&gt;&lt;!--request属性引用名称--&gt; &lt;property name=&quot;dateToolAttribute&quot; value=&quot;dateTool&quot;/&gt; &lt;property name=&quot;numberToolAttribute&quot; value=&quot;numberTool&quot;/&gt; &lt;/bean&gt; velocity.properties 配置文件该文件velocity.properties 在下面的包路径可以找到 org.apache.velocity.runtime.defaults.velocity.properties #设置字符集 #encoding input.encoding =UTF-8 output.encoding=UTF-8 contentType=text/html;charset=UTF-8 #autoreload when vm changed file.resource.loader.cache=false file.resource.loader.modificationCheckInterval =1 velocimacro.library.autoreload=false 显示文件目录结构 header.mv&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-store&quot;/&gt; &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;/&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;3600&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot; name=&quot;viewport&quot;&gt; layout.mv&lt;html&gt; &lt;head&gt; &lt;title&gt;$!page_title&lt;/title&gt; #parse(&quot;default/header.vm&quot;) &lt;/head&gt; &lt;body&gt; &lt;div&gt; $screen_content &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; velocity.mv&lt;html&gt; &lt;head&gt; &lt;title&gt;Spring MVC and Velocity&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Spring MVC and Velocity&lt;/h1&gt; Hello ${hello} &lt;hr /&gt; Copyright &amp;copy 2014 lm &lt;/body&gt; &lt;/html&gt; velocity 基本语法Velocity的基本语法：1、”#”用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#iinclude、#parse、#macro等；如: #if($info.imgs) #else #end 2、”$”用来标识一个对象(或理解为变量)；如如：$i、$msg、$TagUtil.options(…)等。 3、”{}”用来明确标识Velocity变量；比如在页面中，页面中有一个$someonename，此时，Velocity将把someonename作为变量名，若我们程序是想在someone这 个变量的后面紧接着显示name字符，则上面的标签应该改成${someone}name。 4、”!”用来强制把不存在的变量显示为空白。如当页面中包含$msg，如果msg对象有值，将显示msg的值，如果不存在msg对象同，则在页面中将显示$msg字符。这是我们不希望的，为了把不存 在的变量或变量值为null的对象显示为空白，则只需要在变量名前加一个“!”号即可。如：$!msg 5、循#foreach( $info in $list) $info.someList #end，环读取集合list中的对象 #foreach( $info in $hotL包含文件#inclue(“模板文件名”)或#parse(“模板文件名”)st1)$!info.title #end上面的脚本表示循环遍历hotList1集合中的对象，并输出对象的相关内容。 6、包含文件#inclue(“模板文件名”)或#parse(“模板文件名”)主要用于处理具有相同内容的页面，比如每个网站的顶部或尾部内容。使用方法，可以参考EasyJF开源Blog及EasyJF开源论坛中的应用！如：#parse(“/blog/top.html”)或#include(“/blog/top.html”)parse与include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"},{"name":"velocity","slug":"velocity","permalink":"http://www.songshuiyang.site/tags/velocity/"},{"name":"Spring Mvc","slug":"Spring-Mvc","permalink":"http://www.songshuiyang.site/tags/Spring-Mvc/"}]},{"title":"常用的JavaEE服务器","slug":"backend/server/JavaEE服务器/常用的JavaEE服务器","date":"2017-09-10T15:30:44.000Z","updated":"2018-02-26T12:31:59.228Z","comments":true,"path":"2017/09/10/backend/server/JavaEE服务器/常用的JavaEE服务器/","link":"","permalink":"http://www.songshuiyang.site/2017/09/10/backend/server/JavaEE服务器/常用的JavaEE服务器/","excerpt":"","text":"Web服务器1：Tomcat与Java结合的最好、开源、Oracle官方推荐的JSP服务器 2：Jetty嵌入式服务器：在应用中加入Jetty的Jar文件,即可提供Web服务，最好搭配Maven使用，采用maven jetty插件，即可通过简单的配置，执行命令即可启动web服务 3：Resin目前最快的Jsp，Servlet运行平台，支持EJB,个人免费，商业交钱 Java EE服务器1：JBoss开源，全面支持各种最新的Java EE规范 2：GlassFishOracle官方提供的JavaEE服务器 3：WebLogic收费所以牛逼 4：WebSphereIBM收费也是牛逼,WebSphere 是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的软件。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"新建博客方法","slug":"essay/新建博客方法","date":"2017-09-09T17:07:12.000Z","updated":"2017-09-09T17:08:23.340Z","comments":true,"path":"2017/09/10/essay/新建博客方法/","link":"","permalink":"http://www.songshuiyang.site/2017/09/10/essay/新建博客方法/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.songshuiyang.site/categories/随笔/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.songshuiyang.site/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.songshuiyang.site/tags/github/"}]},{"title":"前端学习技术","slug":"frontend/前端学习技术","date":"2017-09-09T17:00:12.000Z","updated":"2018-02-26T12:31:58.989Z","comments":true,"path":"2017/09/10/frontend/前端学习技术/","link":"","permalink":"http://www.songshuiyang.site/2017/09/10/frontend/前端学习技术/","excerpt":"技术架构图:","text":"技术架构图: logo","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"Hexo问题总结","slug":"essay/hexo问题总结","date":"2017-09-09T07:07:12.000Z","updated":"2018-11-24T03:08:39.813Z","comments":true,"path":"2017/09/09/essay/hexo问题总结/","link":"","permalink":"http://www.songshuiyang.site/2017/09/09/essay/hexo问题总结/","excerpt":"","text":"Hexo问题总结 hexo部署后，CNAME会被自动删除，怎么办？ &nbsp;&nbsp;&nbsp;&nbsp;准确来说 CNAME 文件是放在 hexo 项目下的 source 目录，你再运行下hexo generade然后你再去 public 目录中看看就明白了BTW，为了达到更有说服力的验证，最好在开始前先运行下hexo clean这样会先删除 public 目录 HEXO发布到Github上，README.md文件正常显示的解决 &nbsp;&nbsp;&nbsp;&nbsp;使用hexo d 发布本地编译过的代码到github上的时候，发现这个README.md文件也被解析的乱七八糟的，不是一般的github项目里面的README.md文件的显示样式，查了下，在最外层的_config.yml里面把skip_render: README.md添加这个配置，就OK啦。 指定端口启动 hexo server -p 4001 如何在markdowm中添加本地图片 建议将图片统一放在 source/images 文件夹中。然后通过绝对路径![](/images/image.jpg) 引用 卸载hexo npm uninstall hexo -g hexo版本12hexo: 3.7.0hexo-cli: 1.0.3","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.songshuiyang.site/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.songshuiyang.site/tags/github/"}]},{"title":"第一篇博客","slug":"essay/第一篇博客","date":"2017-09-09T03:02:12.000Z","updated":"2017-09-09T16:55:32.211Z","comments":true,"path":"2017/09/09/essay/第一篇博客/","link":"","permalink":"http://www.songshuiyang.site/2017/09/09/essay/第一篇博客/","excerpt":"使用hexo+github搭建免费个人博客优势: 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台；","text":"使用hexo+github搭建免费个人博客优势: 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.io github: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行 hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导 hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的 使用Hexo搭建博客时，需要区分『博客源代码』和『博客生成代码』 『博客源代码』: Hexo的源码，包括themes目录（博客模板），source目录(使用MarkDown写的博客)等 『博客生成代码』： 执行hexo generate或者hexo server命令生成的代码，是Hexo自动生成的，再public目录 常用命令hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 ### hexo的文件结构├── _config.yml ├── db.json ├── node_modules ├── package.json ├── public ├── scaffolds ├── source #所有文章文件放在这里 └── themes #主题文件夹 _config.yml 站点的配置文件。 db.json 缓存文件 node_modules 安装的插件以及hexo所需的一些node.js模块。 package.json 应用程序信息，配置hexo运行需要的js包。 public 最终所见网页的所有内容 scaffolds 模板文件夹。当新建一个文章时，会默认包含对应模板的内容。 source 资源文件夹是存放用户资源的地方。所有的源文件都会被保存在_post文件夹中。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes 存放主题文件，hexo会根据主题来生成静态页面。 图片测试 logo","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.songshuiyang.site/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.songshuiyang.site/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"http://www.songshuiyang.site/tags/nodejs/"}]}]}