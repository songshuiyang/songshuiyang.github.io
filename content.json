{"meta":{"title":"宋水阳个人博客","subtitle":null,"description":null,"author":"songshuiyang","url":"http://www.songshuiyang.site"},"pages":[{"title":"关于","date":"2017-09-09T16:35:25.000Z","updated":"2017-09-09T16:55:32.269Z","comments":true,"path":"about/index.html","permalink":"http://www.songshuiyang.site/about/index.html","excerpt":"","text":"logo 姓名:宋水阳 学校:东华理工大学 专业:软件工程 籍贯:江西省赣州市 与其纠结无法改变的过去，不如微笑着，珍惜未来。"},{"title":"","date":"2018-07-25T07:20:10.686Z","updated":"2018-07-25T07:20:10.622Z","comments":false,"path":"tags/index.html","permalink":"http://www.songshuiyang.site/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-07-25T07:21:50.657Z","updated":"2018-07-25T07:21:50.594Z","comments":false,"path":"categories/index.html","permalink":"http://www.songshuiyang.site/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"字节码执行(二)基于栈的字节码解释器执行过程","slug":"backend/Java/JVM/字节码执行(二)基于栈的字节码解释器执行过程","date":"2019-03-19T14:59:44.000Z","updated":"2019-03-19T14:49:15.374Z","comments":true,"path":"2019/03/19/backend/Java/JVM/字节码执行(二)基于栈的字节码解释器执行过程/","link":"","permalink":"http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/字节码执行(二)基于栈的字节码解释器执行过程/","excerpt":"","text":"解析 根据一个代码实例来介绍虚拟机中解释器的执行过程 123456public int calculate()&#123; int a = 100; int b = 200; int c = 300; return (a + b) * c; &#125; 由上面的代码可以看出，该方法的逻辑很简单，就是进行简单的四则运算加减乘除，我们编译代码后使用javap -verbose命令查看字节码指令，具体字节码代码如下所示: 12345678910111213141516171819202122public int calculate(); Code: Stack=2, Locals=4, Args_size=1 0: bipush 100 2: istore_1 3: sipush 200 6: istore_2 7: sipush 300 10: istore_3 11: iload_1 12: iload_2 13: iadd 14: iload_3 15: imul 16: ireturn LineNumberTable: line 3: 0 line 4: 3 line 5: 7 line 6: 11 &#125; 根据字节码可以看出，这段代码需要深度为2的操作数栈（Stack=2）和4个Slot的局部变量空间（Locals=4）。下面，使用7张图片来描述上面的字节码代码执行过程中的代码、操作数栈和局部变量表的变化情况。 上图展示了执行偏移地址为0的指令的情况，bipush指令的作用是将单字节的整型常量值（-128~127）推入操作数栈顶，后跟一个参数，指明推送的常量值，这里是100。 上图则是执行偏移地址为2的指令，istore_1指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量Slot中。后面四条指令（3、6、7、10）都是做同样的事情，也就是在对应代码中把变量a、b、c赋值为100、200、300。后面四条指令的图就不重复画了。 上面展示了执行偏移地址为11的指令，iload_1指令的作用是将局部变量第1个Slot中的整型值复制到操作数栈顶。 上图为执行偏移地址12的指令，iload_2指令的执行过程与iload_1类似，把第2个Slot的整型值入栈。 上图展示了执行偏移地址为13的指令情况，iadd指令的作用是将操作数栈中前两个栈顶元素出栈，做整型加法，然后把结果重新入栈。在iadd指令执行完毕后，栈中原有的100和200出栈，它们相加后的和300重新入栈。 上图为执行偏移地址为14的指令的情况，iload_3指令把存放在第3个局部变量Slot中的300入栈到操作数栈中。这时操作数栈为两个整数300,。 下一条偏移地址为15的指令imul是将操作数栈中前两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，这里和iadd指令执行过程完全类似，所以就不重复画图了。 上图是最后一条指令也就是偏移地址为16的指令的执行过程，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给此方法的调用者。到此为止，该方法执行结束。 注：上面的执行过程只是一种概念模型，虚拟机最终会对执行过程做出一些优化来提高性能，实际的运作过程不一定完全符合概念模型的描述。不过从这段程序的执行过程也可以看出栈结构指令集的一般运行过程，整个运算过程的中间变量都是以操作数栈的出栈和入栈为信息交换途径。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/azhegps/article/details/54092466","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"字节码执行(一)运行时栈帧结构","slug":"backend/Java/JVM/字节码执行(一)运行时栈帧结构","date":"2019-03-19T13:59:44.000Z","updated":"2019-03-19T14:43:16.723Z","comments":true,"path":"2019/03/19/backend/Java/JVM/字节码执行(一)运行时栈帧结构/","link":"","permalink":"http://www.songshuiyang.site/2019/03/19/backend/Java/JVM/字节码执行(一)运行时栈帧结构/","excerpt":"","text":"概述 前几章介绍了Class类的文件结构及类的加载，有了原材料及已经运送过来了，那么就要生产产品了，那么字节码的执行就在生产产品 栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。第一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。 一个线程中的方法调用链可能会很长，很多方法都同时处理执行状态。对于执行引擎来讲，活动线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧(Current Stack Frame)，这个栈帧所关联的方法称为当前方法(Current Method)。执行引用所运行的所有字节码指令都只针对当前栈帧进行操作。栈帧的概念结构如下图所示： 运行时栈帧结构1. 局部变量表 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。 在方法执行时，虚拟机是使用局部变量表完成参数变量列表的传递过程，如果是实例方法，那么局部变量表中的每0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问这个隐含的参数，其余参数则按照参数列表的顺序来排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域来分配其余的Slot。局部变量表中的Slot是可重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法，如果当前字节码PC计算器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以交给其它变量使用。 局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的值。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。 2. 操作数栈 操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。 当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。 另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了，重叠过程如下图： 3. 动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。 4. 方法返回地址 当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。 无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。 5. 附加信息 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。 方法调用 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。 解析 如前所述，所有的方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可变的。也就是说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用成为解析。 JAVA中符号“编译器可知、运行期不可变”的方法包括：静态方法、私有方法两大类。前者与类型直接关联，后者在外部不可被访问，这就决定了他们都不可能通过继承或别的方式重写其版本。因此都适合在类的加载阶段进行解析。 JAVA虚拟机里面提供了5条方法调用字节码指令。分别如下： 123456789invokestatic:调用静态方法invokespecial:调用实例构造器&lt;init&gt;方法、私有方法和父类方法（super(),super.method()）。invokevirtual:调用所有的虚方法(静态方法、私有方法、实例构造器、父类方法、final方法都是非虚方法)。invokeinterface:调用接口方法，会在运行时期再确定一个实现此接口的对象。invokedynamic:现在运行时期动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条指令，分派逻辑都是固化在虚拟机里面的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 只要能被invokestatic和invokespecial指令调用的方法都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载阶段就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法（还包括使用final修饰的方法，虽然final方法使用invokevirtual指令调用，因为final方法注定不会被重写，也就是无法被覆盖，也就无需对其进行多态选择）。 解析调用一定是一个静态的过程，在编译期间就可以完全确定，在类装载的解析阶段就会把涉及的符号引用全部转化为可确定的直接引用，不会延迟到运行期去完成。而分派调用可能是静态的也可能是动态的，根据分派一句的宗量数可分为单分派和多分派。因此分派可分为：静态单分派、静态多分派、动态单分派、动态多分派。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/xtayfjpk/article/details/41924283 https://www.cnblogs.com/chenyangyao/p/5305352.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"类加载机制(二)类加载器","slug":"backend/Java/JVM/类加载机制(二)类加载器","date":"2019-03-18T13:59:44.000Z","updated":"2019-03-19T14:43:16.899Z","comments":true,"path":"2019/03/18/backend/Java/JVM/类加载机制(二)类加载器/","link":"","permalink":"http://www.songshuiyang.site/2019/03/18/backend/Java/JVM/类加载机制(二)类加载器/","excerpt":"","text":"解析1. 类加载器 虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类， 3种类加载器： 启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。启动类加载器是无法被Java程序直接引用的。 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。开发者可以直接使用扩展类加载器。 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 例子： 寻找类加载器 123456789package com.neo.classloader;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader loader = Thread.currentThread().getContextClassLoader(); System.out.println(loader); System.out.println(loader.getParent()); System.out.println(loader.getParent().getParent()); &#125;&#125; 结果123sun.misc.Launcher$AppClassLoader@64fef26asun.misc.Launcher$ExtClassLoader@1ddd40f3null 从上面的结果可以看出，并没有获取到ExtClassLoader的父Loader，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。 注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。 站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 在执行非置信代码之前，自动验证数字签名。 动态地创建符合用户特定需要的定制化构建类。 从特定的场所取得java class，例如数据库中和网络中。 2. 自定义类加载器 通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java 类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自 ClassLoader 类，从上面对 loadClass 方法来分析来看，我们只需要重写 findClass 方法即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.neo.classloader;import java.io.*;public class MyClassLoader extends ClassLoader &#123; private String root; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = loadClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] loadClassData(String className) &#123; String fileName = root + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; try &#123; InputStream ins = new FileInputStream(fileName); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int length = 0; while ((length = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; public String getRoot() &#123; return root; &#125; public void setRoot(String root) &#123; this.root = root; &#125; public static void main(String[] args) &#123; MyClassLoader classLoader = new MyClassLoader(); classLoader.setRoot(\"E:\\\\temp\"); Class&lt;?&gt; testClass = null; try &#123; testClass = classLoader.loadClass(\"com.neo.classloader.Test2\"); Object object = testClass.newInstance(); System.out.println(object.getClass().getClassLoader()); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3. 类的加载 类加载有三种方式 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 Class.forName()和ClassLoader.loadClass()区别 Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块； ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。 注：Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。 双亲委派模型 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 双亲委派机制: 1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载； 双亲委派模型意义： 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行参考转载 周志明版 《深入理解Java虚拟机》 http://www.importnew.com/25295.html https://www.cnblogs.com/ityouknow/p/5603287.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"类加载机制(一)类加载时机及过程","slug":"backend/Java/JVM/类加载机制(一)类加载时机及过程","date":"2019-03-16T03:59:44.000Z","updated":"2019-03-19T14:43:16.337Z","comments":true,"path":"2019/03/16/backend/Java/JVM/类加载机制(一)类加载时机及过程/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/类加载机制(一)类加载时机及过程/","excerpt":"","text":"什么是类的加载 虚拟机的加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口 类的生命周期 如下图所示，JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。下面我们就分别来看一下这五个过程。 1. 加载 加载的过程： 1、通过一个类的全限定名来获取其定义的二进制字节流。 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 加载.class文件的方式: 从本地系统中直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件，比如java.lang.reflect.Proxy 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是Java堆中，在hotspot中它是存放在方法区中），这样便可以通过该对象访问方法区中的这些数据。 2. 验证 验证是为了确保被加载的类的正确性 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。3. 准备 准备是为类的静态变量分配内存，并将其初始化为默认值 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为：public static int value = 3；那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行 4. 解析 解析是把类中的符号引用转换为直接引用 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。5. 初始化 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。 在Java中对类变量进行初始值设定有两种方式： 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 JVM初始化步骤 1、假如这个类还没有被加载和连接，则程序先加载并连接该类 2、假如该类的直接父类还没有被初始化，则先初始化其直接父类 3、假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下五种(有且只有)： 1、Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类 2、创建类的实例，也就是new的方式或者访问某个类或接口的静态变量，或者对该静态变量赋值，以及调用一个类的静态方法 3、使用java.lang.reflect包的方法对类进行反射调用的时候（如Class.forName(“com.shengsiyuan.Test”)） 4、初始化某个类的子类，如果父类没有初始化则其父类也会被初始化 5、当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 被动引用 通过子类引用父类的静态字段，不会导致子类初始化 通过数组定义来引用类，不会触发此类的初始化 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发 6.结束 在如下几种情况下，Java虚拟机将结束生命周期 执行了System.exit()方法 程序正常执行结束 程序在执行过程中遇到了异常或错误而异常终止 由于操作系统出现错误而导致Java虚拟机进程终止总结 研究类加载全过程有助于连接JVM运行过程 深入了解java动态性（热部署，动态加载），提高程序的灵活性 参考转载 周志明版 《深入理解Java虚拟机》 http://www.importnew.com/25295.html https://www.cnblogs.com/ityouknow/p/5603287.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM类文件结构(三)字节码指令","slug":"backend/Java/JVM/JVM类文件结构(三)字节码指令","date":"2019-03-16T02:59:44.000Z","updated":"2019-03-19T14:43:16.758Z","comments":true,"path":"2019/03/16/backend/Java/JVM/JVM类文件结构(三)字节码指令/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(三)字节码指令/","excerpt":"","text":"解析 Java虚拟机的指令由一个字节长度、代表着某种特定操作含义的数字（操作码）以及跟随其后代表此操作所需参数（操作数）而构成。由于JAVA虚拟机采用的是面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码 伪代码执行模型 加载、存储指令12341）iload、iload&lt;n&gt;、lload、lload&lt;n&gt;、fload、fload&lt;n&gt;、dload、dload&lt;n&gt;、aload、aload&lt;n&gt;：将一个局部变量加载到操作数栈。2）istore、istore&lt;n&gt;、lstore、lstore&lt;n&gt;、fstore、fstore&lt;n&gt;、dstore、dstore&lt;n&gt;、astore、astore&lt;n&gt;：将一个数值从操作数栈存储到局部变量表。3）bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconstm1、iconst&lt;i&gt;、lconst&lt;l&gt;、fconst&lt;f&gt;、dconst_&lt;d&gt;：将一个常量加载到操作数栈。4）wide：扩充局部变量表的访问索引的指令。 示例： 代码 12345678910public static int methodE()&#123; int e = 100; int c = 300; int d = 300000; e++; ++e; --e; e--; return c + d + e;&#125; 对应的字节码 123456789101112131415161718192021222324252627282930public static int methodE(); Signature: ()I flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=0 0: bipush 100 2: istore_0 3: sipush 300 6: istore_1 7: ldc #5 // int 300000 9: istore_2 10: iinc 0, 1 13: iinc 0, 1 16: iinc 0, -1 19: iinc 0, -1 22: iload_1 23: iload_2 24: iadd 25: iload_0 26: iadd 27: ireturn LineNumberTable: line 40: 0 line 41: 3 line 42: 7 line 43: 10 line 44: 13 line 45: 16 line 46: 19 line 47: 22 运算指令1234567891011121）iadd、ladd、fadd、dadd：加法指令。2）isub、lsub、fsub、dsub：减法指令。3）imul、lmul、fmul、dmul：乘法指令。4）idiv、ldiv、fdiv、ddiv：除法指令。5）irem、lrem、frem、drem：求余指令。6）ineg、lneg、fneg、dneg：取反指令。7）ishl、ishr、iushr、lshl、lshr、lushr：位移指令。8）ior、lor：按位或指令。9）iand、land：按位与指令。10）ixor、lxor：按位异或指令。11）iinc：局部变量自增指令。12）dcmpg、dcmpl、fcmpg、fcmpl、lcmp：比较指令。 示例参照上例 类型转换指令121）int类型到long、float或者double类型，long类型到float、double类型，float类型到double类型：宽化类型转换（虚拟机直接支持）。2）i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f：窄化类型转换（显式指令）。 示例： 代码 12345678910public static void methodK()&#123; int i = 97; short i2s = (short) i; char i2c = (char) i; long i2l = i; float i2f = i; double i2d = i; float l2f = i2l; double l2d = i2l;&#125; 对应的字节码 123456789101112131415161718192021222324252627282930313233343536373839public static void methodK();Signature: ()Vflags: ACC_PUBLIC, ACC_STATICCode: stack=2, locals=11, args_size=0 0: bipush 97 2: istore_0 3: iload_0 4: i2s 5: istore_1 6: iload_0 7: i2c 8: istore_2 9: iload_0 10: i2l 11: lstore_3 12: iload_0 13: i2f 14: fstore 5 16: iload_0 17: i2d 18: dstore 6 20: lload_3 21: l2f 22: fstore 8 24: lload_3 25: l2d 26: dstore 9 28: return LineNumberTable: line 100: 0 line 101: 3 line 102: 6 line 103: 9 line 104: 12 line 105: 16 line 106: 20 line 107: 24 line 108: 28 对象创建与访问指令12345671）new ：创建类实例的指令。2）newarray、anewarray、multianewarray：创建数组的指令。3）getstatic、putstatic、getfield、putfield：访问类字段（类变量）和实例字段（实例变量）的指令。4）baload、caload、saload、iaload、laload、faload、daload、aaload：把一个数组元素加载到操作数栈的指令。5）bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore：把一个操作数栈的值存储到数组元素中的指令。6）arraylength：取数组长度的指令。7）instanceof、checkcast：检查类实例类型的指令。 示例： 代码 12345public static void methodJ()&#123; new SimpleMethodExecuteProcess(); System.out.println(SimpleMethodExecuteProcess.i);&#125; 对应的字节码 1234567891011121314151617public static void methodJ();Signature: ()Vflags: ACC_PUBLIC, ACC_STATICCode: stack=2, locals=0, args_size=0 0: new #9 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess 3: dup 4: invokespecial #10 // Method \"&lt;init&gt;\":()V 7: pop 8: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 11: getstatic #11 // Field i:I 14: invokevirtual #12 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 91: 0 line 93: 8 line 94: 17 操作数栈管理指令1231）pop、pop2：将操作数栈的栈顶一个或两个元素出栈。2）dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶。3）swap：将栈最顶端两个数值互换 示例： 代码 123public static void main(String[] args) &#123; heavyMethod();&#125; 对应的字节码 1234567891011public static void main(java.lang.String[]); Signature: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=1, locals=1, args_size=1 0: invokestatic #23 // Method heavyMethod:()I 3: pop 4: return LineNumberTable: line 115: 0 line 116: 4 控制转移指令1231）ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne：条件分支。2）tableswitch、lookupswitch：复合条件分支。3）goto、goto_w、jsr、jsr_w、ret：无条件分支。 示例： 代码 12345678910public static void methodG()&#123; if(i == 0)&#123; System.out.println(System.currentTimeMillis()); &#125; while(i &lt; 1)&#123; System.out.println(System.currentTimeMillis()); i++; &#125;&#125; 对应的字节码 1234567891011121314151617181920212223242526272829303132public static void methodG(); Signature: ()V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=0, args_size=0 0: getstatic #6 // Field i:I 3: ifne 15 6: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 9: invokestatic #7 // Method java/lang/System.currentTimeMillis:()J 12: invokevirtual #8 // Method java/io/PrintStream.println:(J)V 15: getstatic #6 // Field i:I 18: iconst_1 19: if_icmpge 42 22: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 25: invokestatic #7 // Method java/lang/System.currentTimeMillis:()J 28: invokevirtual #8 // Method java/io/PrintStream.println:(J)V 31: getstatic #6 // Field i:I 34: iconst_1 35: iadd 36: putstatic #6 // Field i:I 39: goto 15 42: return LineNumberTable: line 62: 0 line 63: 6 line 66: 15 line 67: 22 line 68: 31 line 70: 42 StackMapTable: number_of_entries = 2 frame_type = 15 /* same */ frame_type = 26 /* same */ 异常处理指令1athrow ：显式抛出异常指令。 示例： 代码 12345678public static void methodH()&#123; try &#123; throw new NullPointerException(\"nothing ...\"); // do nothing ... &#125; catch (Throwable t)&#123; // do nothing ... &#125;&#125; 对应的字节码 12345678910111213141516171819202122public static void methodH();Signature: ()Vflags: ACC_PUBLIC, ACC_STATICCode: stack=3, locals=1, args_size=0 0: new #9 // class java/lang/NullPointerException 3: dup 4: ldc #10 // String nothing ... 6: invokespecial #11 // Method java/lang/NullPointerException.\"&lt;init&gt;\":(Ljava/lang/String;)V 9: athrow 10: astore_0 11: return Exception table: from to target type 0 10 10 Class java/lang/Throwable LineNumberTable: line 77: 0 line 79: 10 line 82: 11 StackMapTable: number_of_entries = 1 frame_type = 74 /* same_locals_1_stack_item */ stack = [ class java/lang/Throwable ] 同步指令 1monitorenter、monitorexit：支持synchronized语句块语义的指令。 示例： 代码 12345public void methodI()&#123; synchronized (Integer.class)&#123; // do nothing ... &#125;&#125; 对应的字节码 123456789101112131415161718192021222324252627282930313233public void methodI();Signature: ()Vflags: ACC_PUBLICCode: stack=2, locals=3, args_size=1 0: ldc_w #13 // class java/lang/Integer 3: dup 4: astore_1 5: monitorenter 6: aload_1 7: monitorexit 8: goto 16 11: astore_2 12: aload_1 13: monitorexit 14: aload_2 15: athrow 16: return Exception table: from to target type 6 8 11 any 11 14 11 any LineNumberTable: line 88: 0 line 90: 6 line 91: 16 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 11 locals = [ class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4 synchronized 修饰方法的语义解析：可以直接从方法常量池的方法表结构中ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法，不需要解析出monitorenter、monitorexit同步指令。 123456789101112131415public static synchronized void methodL()&#123; int i = 97;&#125; public static synchronized void methodL(); Signature: ()V flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED Code: stack=1, locals=1, args_size=0 0: bipush 97 2: istore_0 3: return LineNumberTable: line 120: 0 line 121: 3 方法调用和返回指令 1234561）invokestatic：调用静态方法。2）invokespecial：调用实例构造器&lt;init&gt;方法、私有方法和父类方法。3）invokevirtual：调用所有的虚方法。非虚方法以外的都是虚方法，非虚方法包括使用invokestatic、invokespecial调用的方法和被final修饰的方法。4）invokeinterface：调用接口方法，运行时再确定一个实现此接口的对象。5）invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。ireturn（返回值是boolean、byte、char、short、int）、lreturn、freturn、dreturn、areturn：方法返回指令。 示例： 代码 123456789101112131415public static int heavyMethod()&#123; int a = 200; int b = 100; int c = methodC(methodA(methodA(a, b), b), methodB(a, b)); methodD(); methodE(); methodF(); methodG(); methodH(); new SimpleMethodExecuteProcess().methodI(); methodJ(); methodK(); methodL(); return c;&#125; 对应的字节码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static int heavyMethod();Signature: ()Iflags: ACC_PUBLIC, ACC_STATICCode: stack=3, locals=3, args_size=0 0: sipush 200 3: istore_0 4: bipush 100 6: istore_1 7: iload_0 8: iload_1 9: invokestatic #17 // Method methodA:(II)I 12: iload_1 13: invokestatic #17 // Method methodA:(II)I 16: iload_0 17: iload_1 18: invokestatic #18 // Method methodB:(II)I 21: invokestatic #19 // Method methodC:(II)I 24: istore_2 25: invokestatic #20 // Method methodD:()V 28: invokestatic #21 // Method methodE:()I 31: pop 32: invokestatic #22 // Method methodF:()D 35: pop2 36: invokestatic #23 // Method methodG:()V 39: invokestatic #24 // Method methodH:()V 42: new #14 // class edu/atlas/demo/java/jvm/SimpleMethodExecuteProcess 45: dup 46: invokespecial #15 // Method \"&lt;init&gt;\":()V 49: invokevirtual #25 // Method methodI:()V 52: invokestatic #26 // Method methodJ:()V 55: invokestatic #27 // Method methodK:()V 58: invokestatic #28 // Method methodL:()V 61: iload_2 62: ireturn LineNumberTable: line 128: 0 line 129: 4 line 130: 7 line 131: 25 line 132: 28 line 133: 32 line 134: 36 line 135: 39 line 136: 42 line 137: 52 line 138: 55 line 139: 58 line 140: 61 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.51cto.com/damon188/2131035","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM类文件结构(二)Code属性","slug":"backend/Java/JVM/JVM类文件结构(二)Code属性","date":"2019-03-16T01:59:44.000Z","updated":"2019-03-19T14:43:16.497Z","comments":true,"path":"2019/03/16/backend/Java/JVM/JVM类文件结构(二)Code属性/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(二)Code属性/","excerpt":"","text":"解析 Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体内的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据 Java虚拟机执行字节码是基于栈的体系结构 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/yxwkf/p/5222589.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM类文件结构(一)Class类文件结构","slug":"backend/Java/JVM/JVM类文件结构(一)Class类文件结构","date":"2019-03-16T00:59:44.000Z","updated":"2019-03-19T14:43:16.634Z","comments":true,"path":"2019/03/16/backend/Java/JVM/JVM类文件结构(一)Class类文件结构/","link":"","permalink":"http://www.songshuiyang.site/2019/03/16/backend/Java/JVM/JVM类文件结构(一)Class类文件结构/","excerpt":"","text":"解析 不论什么一个Class文件都相应唯一一个类或接口的定义信息，可是不是全部的类或接口都得定义在文件里（它们也能够通过类载入器直接生成)。 Class文件是一组以8位字节为基础单位的二进制流。各个数据项严格按顺序排列，没有不论什么分隔符。 Class文件格式採用一种类似于C语言结构体的伪结构来存储数据。这样的伪结构仅仅有两种数据类型：无符号数和表。 无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以 “_info” 结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由表 6-1 所示的数据项构成。 image 使用以下的类进行说明： 123456789package com.test;public class Test &#123; private int m; public int getM()&#123; return m + 1; &#125;&#125; javap -verbose 执行后的可视byteCode（只存在两种数据类型：无符号数字与表）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Classfile /D:/workspace-github/jvm/target/production/jvm/com/songsy/Test.class Last modified 2019-3-16; size 361 bytes MD5 checksum bb8e54060828e4bf1f709c2f4434dca8 Compiled from \"Test.java\"public class com.songsy.Test minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #4.#18 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #3.#19 // com/songsy/Test.m:I #3 = Class #20 // com/songsy/Test #4 = Class #21 // java/lang/Object #5 = Utf8 m #6 = Utf8 I #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lcom/songsy/Test; #14 = Utf8 getM #15 = Utf8 ()I #16 = Utf8 SourceFile #17 = Utf8 Test.java #18 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #19 = NameAndType #5:#6 // m:I #20 = Utf8 com/songsy/Test #21 = Utf8 java/lang/Object&#123; public com.songsy.Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 7: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/songsy/Test; public int getM(); descriptor: ()I flags: ACC_PUBLIC Code: stack=2, locals=1, args_size=1 0: aload_0 1: getfield #2 // Field m:I 4: iconst_1 5: iadd 6: ireturn LineNumberTable: line 11: 0 LocalVariableTable: Start Length Slot Name Signature 0 7 0 this Lcom/songsy/Test;&#125;SourceFile: \"Test.java\" 编译后的class文件例如以下： 1. 魔数与Class版本 每一个class文件的头4个字节称为魔数，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。非常多文件存储标准中都使用魔数来进行身份识别。譬如图片格式gif、jpeg等。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，由于文件拓展格式能够任意修改。Class文件的魔数为：0xCAFEBABE（咖啡宝贝？）。这个魔数似乎也预示着日后JAVA这个商标名称的出现。 第五六个字节是次版本（Minor Version）。第7和第8个字节是主版本（Major Version）。 高版本号的JDK能够向下兼容曾经版本号的Class文件，可是无法执行以后版本号的Class文件，即使文件格式并未发生变化，虚拟机也必须拒绝执行超过其版本号号的Class文件。 2. 常量池 紧接着版本之后就是常量池，常量池能够理解为Class文件之中的资源仓库，是Class文件结构中与其它项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之中的一个。同一时候也是在Class文件里第一个出现的表类型数据项目 常量池中主要存放两大类常量 字面量和符号引用。字面量如文本字符串、声明为final的常量值等 符号引用包含三类常量：类和接口的全限定名、字段的名称和描写叙述符、方法的名称和描写叙述符。 3. 访问标志 在常量池结束之后，紧接着的两个字节代表訪问标志。用于识别一些类或者接口层次的訪问信息。包括：这个类是Class类还是接口；是否定义为public类型，是否被声明为final，具体的标志位及其含义例如以下表所看到的。 依据上面的表格，測试类的訪问标志0x0021= 0x0001 | 0x0020 =ACC_PUBLIC | ACC_SUPER 4. 类索引、父类索引和接口索引集合 Class文件里由这3项数据来确定这个类的继承关系 this_class：类索引，用于确定这个类的全限定名，占2字节 super_class：父类索引。用于确定这个类父类的全限定名（Java语言不同意多重继承，故父类索引仅仅有一个。除了java.lang.Object类之外全部类都有父类，故除了java.lang.Object类之外，全部类该字段值都不为0），占2字节 interfaces_count：接口索引计数器。占2字节。接口索引计数器。占2字节。 interfaces：接口索引集合，一组u2类型数据的集合。用来描写叙述这个类实现了哪些接口。这些被实现的接口将按implements语句（假设该类本身为接口，则为extends语句）后的接口顺序从左至右排列在接口的索引集合中 this_class、super_class与interfaces中保存的索引值均指向常量池中一个CONSTANT_Class_info类型的常量。通过这个常量中保存的索引值能够找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串this_class的值为0x0001，即常量池中第一个常量，super_class的值为0x0003，即常量池中的第三个常量，interfaces_counts的值为0x0000，故接口索引集合大小为0 5. 字段表集合 字段表用于描写叙述接口或者类中声明的变量，包含类级变量和实例级变量(是否是static)。但不包含在方法内部声明的局部变量。 fields_count：字段表计数器。即字段表集合中的字段表数据个数。占2字节，其值为0x0001，即仅仅有一个字段表数据。也就是測试类中仅仅包括一个变量（不算方法内部变量） 字段表集合，一组字段表类型数据的集合。字段表用于描写叙述接口或类中声明的变量。包含类级别（static）和实例级别变量，不包含在方法内部声明的变量 6. 方法表集合 methods_count：方法表计数器，即方法表集合中的方法表数据个数。占2字节，其值为0x0002，即測试类中有2个方法(还自己主动添加了一个构造函数） methods：方法表集合，一组方法表类型数据的集合。方法表结构和字段表结构一样： 7. 属性表集合 在Class文件、属性表、方法表中都能够包括自己的属性表集合。用于描写叙述某些场景的专有信息 与Class文件里其他数据项对长度、顺序、格式的严格要求不同，属性表集合不要求当中包括的属性表具有严格的顺序，而且仅仅要属性的名称不与已有的属性名称反复。不论什么人实现的编译器可以向属性表中写入自定义的属性信息。虚拟机在执行时会忽略不能识别的属性，为了能正确解析Class文件 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/yxwkf/p/5222589.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(四)常用参数","slug":"backend/Java/JVM/JVM垃圾回收(四)常用参数","date":"2019-03-11T13:59:44.000Z","updated":"2019-03-19T14:43:16.431Z","comments":true,"path":"2019/03/11/backend/Java/JVM/JVM垃圾回收(四)常用参数/","link":"","permalink":"http://www.songshuiyang.site/2019/03/11/backend/Java/JVM/JVM垃圾回收(四)常用参数/","excerpt":"","text":"JVM参数的含义 参数名称 含义 默认值 备注 -Xms 初始堆大小 物理内存的1/64(&lt;1GB) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. -Xmx 最大堆大小 物理内存的1/4(&lt;1GB) 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 -Xmn 年轻代大小(1.4or lator) 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 物理内存的1/64 -XX:MaxPermSize 设置持久代最大值 物理内存的1/4 -Xss 每个线程的堆栈大小 JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:””-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。 -XX:ThreadStackSize Thread Stack Size -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置 -XX:SurvivorRatio Eden区与Survivor区的大小比值 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 -XX:LargePageSizeInBytes 内存页的大小不可设置过大， 会影响Perm的大小 =128m -XX:+UseFastAccessorMethods 原始类型的快速优化 -XX:+DisableExplicitGC 关闭System.gc() 这个参数需要严格的测试 -XX:MaxTenuringThreshold 垃圾最大年龄 如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效 -XX:+AggressiveOpts 加快编译 -XX:+UseBiasedLocking 锁机制的性能改善 -Xnoclassgc 禁用垃圾回收 -XX:SoftRefLRUPolicyMSPerMB 每兆堆空闲空间中SoftReference的存活时间 1s -XX:PretenureSizeThreshold 对象超过多大是直接在旧生代分配 0 单位字节 新生代采用Parallel Scavenge GC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. -XX:TLABWasteTargetPercent TLAB占eden区的百分比 1% -XX:+CollectGen0First FullGC时是否先YGC false 并行收集器相关参数 参数名称 含义 默认值 备注 -XX:+UseParallelGC Full GC采用parallel MSC(此项待验证) 选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证) -XX:+UseParNewGC 设置年轻代为并行收集 可与CMS收集同时使用JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值 -XX:ParallelGCThreads 并行收集器的线程数 此值最好配置与处理器数目相等 同样适用于CMS -XX:+UseParallelOldGC 年老代垃圾收集方式为并行收集(Parallel Compacting) 这个是JAVA 6出现的参数选项 -XX:MaxGCPauseMillis 每次年轻代垃圾回收的最长时间(最大暂停时间) 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. -XX:+UseAdaptiveSizePolicy 自动选择年轻代区大小和相应的Survivor区比例 设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开. -XX:GCTimeRatio 设置垃圾回收时间占程序运行时间的百分比 公式为1/(1+n) -XX:+ScavengeBeforeFullGC Full GC前调用YGC true Do young generation GC prior to a full GC. (Introduced in 1.4.1.) CMS相关参数 参数名称 含义 默认值 备注 -XX:+UseConcMarkSweepGC 使用CMS内存收集 -XX:+AggressiveHeap 试图是使用大量的物理内存长时间大内存使用的优化，能检查计算资源（内存， 处理器数量）至少需要256MB内存大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升） -XX:CMSFullGCsBeforeCompaction 多少次后进行内存压缩 由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理. -XX:+CMSParallelRemarkEnabled 降低标记停顿 -XX+UseCMSCompactAtFullCollection 在FULL GC的时候， 对年老代的压缩 CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片 -XX:+UseCMSInitiatingOccupancyOnly 使用手动定义初始化定义开始CMS收集 禁止hostspot自行触发CMS GC -XX:CMSInitiatingOccupancyFraction=70 使用cms作为垃圾回收使用70％后开始CMS收集 92 为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式CMSInitiatingOccupancyFraction计算公式 -XX:CMSInitiatingPermOccupancyFraction 设置Perm Gen使用到达多少比率时触发 92 -XX:+CMSIncrementalMode 设置为增量模式 用于单CPU情况 -XX:+CMSClassUnloadingEnabled 辅助参数 参数名称 含义 默认值 备注 -XX:+PrintGC 输出形式:[GC 118250K-&gt;113543K(130112K), 0.0094143 secs][Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs] -XX:+PrintGCDetails 输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs][GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs] -XX:+PrintGCTimeStamps -XX:+PrintGCApplicationStoppedTime 打印垃圾回收期间程序暂停的时间.可与上面混合使用 可与-XX:+PrintGC -XX:+PrintGCDetails混合使用输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs] -XX:+PrintGCApplicationConcurrentTime 打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用 输出形式:Total time for which application threads were stopped: 0.0468229 seconds -XX:+PrintHeapAtGC 打印GC前后的详细堆栈信息 -Xloggc:filename 把相关日志信息记录到文件以便分析，与上面几个配合使用 -XX:+PrintClassHistogram garbage collects before printing the histogram. -XX:+PrintTLAB 查看TLAB空间的使用情况 XX:+PrintTenuringDistribution 查看每次minor GC后新的存活周期的阈值 Desired survivor size 1048576 bytes, new threshold 7 (max 15)new threshold 7即标识新的存活周期的阈值为7。 参考转载 周志明版 《深入理解Java虚拟机》 http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(三)内存分配及回收策略","slug":"backend/Java/JVM/JVM垃圾回收(三)内存分配及回收策略","date":"2019-03-10T14:59:44.000Z","updated":"2019-03-19T14:43:16.468Z","comments":true,"path":"2019/03/10/backend/Java/JVM/JVM垃圾回收(三)内存分配及回收策略/","link":"","permalink":"http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(三)内存分配及回收策略/","excerpt":"","text":"概述 Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。 对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。 TLAB: 首先讲讲什么是TLAB。内存分配的动作，可以按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程需要分配内存，就在哪个线程的TLAB上分配。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。这么做的目的之一，也是为了并发创建一个对象时，保证创建对象的线程安全性。TLAB比较小，直接在TLAB上分配内存的方式称为快速分配方式，而TLAB大小不够，导致内存被分配在Eden区的内存分配方式称为慢速分配方式。 接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。由于条件因素，只能在Client模式下测试，因此CMS和G1并未提及。 解析1. 对象优先在Eden分配 所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。 新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。 老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。这时会把存活的对象转移进Survivor区。 Minor GC 新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，不过这个过程非常短暂。 Major GC/Full GC 老年代GC，指发生在老年代的GC。 举例说明 下面的代码来看一下jvm具体是怎样分配的，下面的代码注释有详细解释 1234567891011121314151617181920212223242526272829303132333435/** * VM参数： * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC * 参数解析： * * 初始堆大小为20兆，不可扩展，年轻代大小为10兆剩下的10兆分配给老年代，PrintGCDetails打印内存回收日志，SurvivorRatio标识 eden与Survivor比例为8:1 * * \"eden space 8192K from space 1024K to space 1024K\" 新生代总可用空间为9216KB (一个Eden区 + 一个Survivor区) * @author songsy * @date 2019/3/11 18:37 */public class Jvm1 &#123; private static final int _1KB = 1024; private static final int _1MB = 1024 * _1KB; public static void testAllocation() &#123; byte [] allocation1,allocation2, allocation3,allocation4,allocation5; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; /** * 执行到下一步出现一次Minor GC，因为发现Eden已经被占用了6Mb，剩余空间装不下4Mb， * 执行gc的时候发现已有3*2Mb的对象无法放入Survivor（只有1mb）空间，所以只好通过 * 分配担保机制提前转移到老年代去 */ allocation4 = new byte[4 * _1MB]; /** * Gc结束，4Mb的allocation4对象将分配在Eden区，老年代占用6Mb */ &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125;``` * 输出日志 [GC[DefNew: 7485K-&gt;526K(9216K), 0.0076710 secs] 7485K-&gt;6671K(19456K), 0.0077381 secs] [Times: user=0.02 sys=0.00, real=0.01 secs]Heapdef new generation total 9216K, used 4952K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)eden space 8192K, 54% used [0x00000000f9a00000, 0x00000000f9e526c8, 0x00000000fa200000)from space 1024K, 51% used [0x00000000fa300000, 0x00000000fa383bd8, 0x00000000fa400000)to space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)tenured generation total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)compacting perm gen total 21248K, used 2950K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 13% used [0x00000000fae00000, 0x00000000fb0e1918, 0x00000000fb0e1a00, 0x00000000fc2c0000)No shared spaces configured. 12345678910111213141516171819202122232425262728293031### 2. 大对象直接进入老年代* 所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（例子中的byte[]数组就是典型的大对象）。* 虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。* 举例说明 ```java /** * 测试大对象直接进入老年代 * * VM参数： * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC * -XX:PretenureSizeThreshold=3145728 可选 * * @author songsy * @date 2019/3/11 18:37 */ public class Jvm2 &#123; private static final int _1KB = 1024; private static final int _1MB = 1024 * _1KB; public static void testAllocation() &#123; byte [] allocation1; // 直接分配在老年代 allocation1 = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testAllocation(); &#125; &#125; 没设置PretenureSizeThreshold，可以看到新生代def new generation total 9216K, used 5773K，老年代tenured generation total 10240K, used 0K 12345678910Heap def new generation total 9216K, used 5773K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 70% used [0x00000000f9a00000, 0x00000000f9fa3668, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) to space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) tenured generation total 10240K, used 0K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 0% used [0x00000000fa400000, 0x00000000fa400000, 0x00000000fa400200, 0x00000000fae00000) compacting perm gen total 21248K, used 3237K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 15% used [0x00000000fae00000, 0x00000000fb129600, 0x00000000fb129600, 0x00000000fc2c0000)No shared spaces configured. * 设置了PretenureSizeThreshold结果，可以看到新生代`def new generation total 9216K, used 1671K` ,老年代`tenured generation total 10240K, used 4096K` 12345678910Heap def new generation total 9216K, used 1671K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000) eden space 8192K, 20% used [0x00000000f9a00000, 0x00000000f9ba1c08, 0x00000000fa200000) from space 1024K, 0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000) to space 1024K, 0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000) tenured generation total 10240K, used 4096K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000) the space 10240K, 40% used [0x00000000fa400000, 0x00000000fa800010, 0x00000000fa800200, 0x00000000fae00000) compacting perm gen total 21248K, used 2938K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000) the space 21248K, 13% used [0x00000000fae00000, 0x00000000fb0de9e0, 0x00000000fb0dea00, 0x00000000fc2c0000)No shared spaces configured. 3. 长期存活的对象将进入老年代 既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象放在新生代，那些对象放在老年代中 为了能做到这一点，虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。 举例说明 1234567891011121314151617181920212223242526272829/** * 测试长期存活的对象进入老年代 * * VM参数： * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC * -XX:MaxTenuringThreshold=1 可选 * * @author songsy * @date 2019/3/11 18:37 */public class Jvm3 &#123; private static final int _1KB = 1024; private static final int _1MB = 1024 * _1KB; public static void testAllocation() &#123; byte [] allocation1,allocation2, allocation3; allocation1 = new byte[_1MB / 4]; allocation2 = new byte[4 * _1MB]; allocation3 = new byte[4 * _1MB]; // 虽然此处赋值为null，但未进行Gc空间仍被占用，下一行代码会执行minor GC allocation3 = null; // 将MaxTenuringThreshold设为1，可以看出第二次Minor GC时，年轻代已经被清空，allocation1对象因为年龄符合MaxTenuringThreshold设置的值，因此进入老年代。 allocation3 = new byte[4 * _1MB]; &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125; 4. 动态对象年龄判定 为了能更好的适应不同程序的内存状态，虚拟机并不是永远的要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代的 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 5. 空间分配担保 内存分配是在JVM在内存分配的时候，新生代内存不足时，把新生代的存活的对象搬到老生代，然后新生代腾出来的空间用于为分配给最新的对象。这里老生代是担保人。在不同的GC机制下，也就是不同垃圾回收器组合下，担保机制也略有不同。 Parallel Scavenge收集器与其他收集器在空间分配担保上有一点差别, 正常是在Minor GC前进行检查, 而Parallel Scavenge收集器在Minor GC后也会进行检查。 另外当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/v123411739/article/details/78941793","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(二)垃圾回收器","slug":"backend/Java/JVM/JVM垃圾回收(二)垃圾回收器","date":"2019-03-10T13:59:50.000Z","updated":"2019-03-19T14:43:16.267Z","comments":true,"path":"2019/03/10/backend/Java/JVM/JVM垃圾回收(二)垃圾回收器/","link":"","permalink":"http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(二)垃圾回收器/","excerpt":"","text":"概述 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。 Java虚拟机规范对垃圾回收器应该如何实现并没有任何规定，因此不同的厂商、不同的版本的回收器可能会有很大差异，一般是提供参数供用户根据自己的应用特点和要求组合各个年代所使用的回收器 这里讨论的收集器基于JDK1.7Update 14之后的HotSpot虚拟机，这个虚拟机包含的所有收集器如下图3-5所示 1. Serial 收集器 Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。 大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。 新生代采用复制算法，老年代采用标记-整理算法。 虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。 但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。 2. Serial Old 收集器 Serial收集器的老年代版本，它同样是一个单线程收集器。 它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。 3. ParNew 收集器 ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。 新生代采用复制算法，老年代采用标记-整理算法。 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。 并行和并发概念补充： 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。 4. Parallel Old收集器 Parallel Scavenge收集器的老年代版本。 使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。 5. Parallel Scavenge收集器 Parallel Scavenge 收集器类似于ParNew 收集器。 那么它有什么特别之处呢？ Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。 1234567-XX:+UseParallelGC 使用Parallel收集器+ 老年代串行-XX:+UseParallelOldGC 使用Parallel收集器+ 老年代并行 Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 新生代采用复制算法，老年代采用标记-整理算法。 6. CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时GC线程开始对为标记的区域做清扫。 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对CPU资源敏感 无法处理浮动垃圾 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生7. G1收集器 G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点 G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。 G1收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html https://blog.csdn.net/qq_34337272/article/details/82177383","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM垃圾回收(一)垃圾回收算法","slug":"backend/Java/JVM/JVM垃圾回收(一)垃圾回收算法","date":"2019-03-10T13:59:44.000Z","updated":"2019-03-19T14:43:16.858Z","comments":true,"path":"2019/03/10/backend/Java/JVM/JVM垃圾回收(一)垃圾回收算法/","link":"","permalink":"http://www.songshuiyang.site/2019/03/10/backend/Java/JVM/JVM垃圾回收(一)垃圾回收算法/","excerpt":"","text":"概述 猿们都知道JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。 而Java堆区和方法区则不一样、不一样!(怎么不一样说的朗朗上口)，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。 判断对象是否存活的算法 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法！（面试官肯定没少问你吧） 1. 引用计数法一个对象如果没有任何引用指向它，就可认为该对象已经”消亡“，这种方法有个缺点就是无法检测到引用环的存在。 2. 可达性分析算法 通过一系列叫做”GCRoots“的对象作为起点向下搜索，走过的路径称为引用链,当一个对象到GCRoots没有任何引用链时，表明该对象已经”消亡“。 image 上图中每个对象都存在引用链与GCRoots相连，表明对象还在，不能回收。有图中三个对象虽然互相引用，但是没有链接与GCRoots相连，则可判断它们是可回收的对象。 彻底死亡条件： 条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。 条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。 垃圾回收算法1. 标记-清除算法 该算法是最基础的收集算法，算法分为标记和清除两个阶段，首先标记所有需要回收的对象，在标记完成之后统一回收所有被标记的对象 之所以说它是最基础的算法是因为后续的算法都是基于这种思路并对其不足进行改进而得到的 缺点 效率不足 会产生大量不连续的内存碎片，碎片过多的话再分配一个较大对象时就无容身之地从而不得不提前触发另一次垃圾收集 2. 复制算法 为了解决效率问题，此算法把内存划分为相等大小的两个区域，每一只使用其中一个，回收过程中将存活的对象全部复制到另一个区域中，清空原区域。在年轻代中eden区和两个survivor区就是使用了此种算法。这种算法只复制存活的对象，成本较低，而且不会出现内存碎片问题 现在的商业虚拟机都采用这种算法来回收新生代 缺点 费内存，需要2倍的内存空间 3. 标记-整理算法 该算法标记阶段和标记-清除算法一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。效率比“标记-清理”算法低，但不会产生内存碎片。 4. 分代收集算法 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/aspirant/p/8662690.html http://baijiahao.baidu.com/s?id=1565631804713416&amp;wfr=spider&amp;for=pc","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(六)方法区","slug":"backend/Java/JVM/JVM运行时数据区域(六)方法区","date":"2019-03-04T05:59:44.000Z","updated":"2019-03-19T14:43:16.575Z","comments":true,"path":"2019/03/04/backend/Java/JVM/JVM运行时数据区域(六)方法区/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(六)方法区/","excerpt":"","text":"概述 方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。 对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。 Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。 运行时常量池 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规 定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、 装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的 提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除 了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常* 量池中。 运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语 言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容 才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发* 人员利用得比较多的便是String 类的intern() 方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无* 法再申请到内存时会抛出OutOfMemoryError 异常 额外参考转载 周志明版 《深入理解Java虚拟机》","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(五)堆","slug":"backend/Java/JVM/JVM运行时数据区域(五)堆","date":"2019-03-04T04:59:44.000Z","updated":"2019-03-19T14:43:16.680Z","comments":true,"path":"2019/03/04/backend/Java/JVM/JVM运行时数据区域(五)堆/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(五)堆/","excerpt":"","text":"概述 堆是JVM所管理的内存中国最大的一块，是被所有Java线程锁共享的，不是线程安全的，在JVM启动时创建。堆是存储Java对象的地方，这一点Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。Java堆是GC管理的主要区域，从内存回收的角度来看，由于现在GC基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；新生代再细致一点有Eden空间、From Survivor空间、To Survivor空间等。 对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java 堆中的上述各个区域的分配和回收等细节将会是下一章的主题。 根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。 解析 所有通过new创建的对象的内存都在堆中分配，堆被划分为新生代和老年代，新生代又被进一步划分为Eden和Survivor区，而Survivor由FromSpace和ToSpace组成。 新生代：新创建的对象都是用新生代分配内存，Eden空间不足时，触发Minor GC，这时会把存活的对象转移进Survivor区。 老年代：老年代用于存放经过多次Minor GC之后依然存活的对象。 内存溢出及内存泄漏1、内存溢出 out of memory 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出 1.1 方法区溢出 out of memory: PermGen space1.2 本机直接内存溢出2、内存泄露 memory leak 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光 memory leak会最终会导致out of memory！ 内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 3、引起内存溢出的原因 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 代码中存在死循环或循环产生过多重复的对象实体； 使用的第三方软件中的BUG； 使用的第三方软件中的BUG； 4、内存溢出的解决方案 修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。) 检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。 对代码进行走查和分析，找出可能发生内存溢出的位置。 ## java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -Xmx3550m：设置JVM最大可用内存为3550M。 -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k： 设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内 存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 参考转载 周志明版 《深入理解Java虚拟机》 https://www.cnblogs.com/Sharley/p/5285045.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(四)本地方法栈","slug":"backend/Java/JVM/JVM运行时数据区域(四)本地方法栈","date":"2019-03-04T03:59:44.000Z","updated":"2019-03-19T14:43:16.791Z","comments":true,"path":"2019/03/04/backend/Java/JVM/JVM运行时数据区域(四)本地方法栈/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(四)本地方法栈/","excerpt":"","text":"概述 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。 解析Native Method 简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，你可以用extern “C”告知C＋＋编译器去调用一个C的函数 例如 Object.java 类下就有很多Native Method 1public final native Class&lt;?&gt; getClass(); 本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。 为什么要使用Native Method 与java环境外交互：有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。 与操作系统交互：JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun’s Java： Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/qq_28885149/article/details/52672475","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(三)Java虚拟机栈","slug":"backend/Java/JVM/JVM运行时数据区域(三)Java虚拟机栈","date":"2019-03-04T02:59:44.000Z","updated":"2019-03-19T14:43:16.826Z","comments":true,"path":"2019/03/04/backend/Java/JVM/JVM运行时数据区域(三)Java虚拟机栈/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(三)Java虚拟机栈/","excerpt":"","text":"何为虚拟机栈 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存放局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。 解析 执行引擎运行的所有字节码指令只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示： 栈帧数据结构 每一个栈帧包含的内容有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译代码时，栈帧需要多大的局部变量表，多深的操作数栈都可以完全确定的，并写入到方法表的code属性中 我们先来理解一下虚拟机是如何执行一个方法的，这样我们才能理解为什么栈帧需要这些部分，这些部分分别提供了什么功能。首先我们的方法被编译成了字节码，并生成了可执行的命令。通过程序计数器，虚拟机会一行一行的执行命令，直到进入一个新的方法入口，对应虚拟机栈也就是新的栈帧入栈，当前栈帧改变，又或者遇到返回指令或出现异常结束了方法，对应虚拟机也就是出栈。 1、局部变量表 是一片逻辑连续的内存空间，最小单位是Slot，用来存放方法参数和方法内部定义的局部变量 2、操作数栈 每个栈帧都包含一个被叫做操作数栈的后进先出的栈。叫操作栈，或者操作数栈。 栈桢刚创建时，里面的操作数栈是空的。 Java虚拟机提供指令来让操作数栈对一些数据进行入栈操作，比如可以把局部变量表里的数据、实例的字段等数据入栈。 同时也有指令来支持出栈操作。 向其他方法传参的参数，也存在操作数栈中。 其他方法返回的结果，返回时存在操作数栈中。 3、动态链接 一个方法调用另一个方法，或者一个类使用另一个类的成员变量时，总得知道被调用者的名字吧？(你可以不认识它本身，但调用它就需要知道他的名字)。符号引用就相当于名字，这些被调用者的名字就存放在Java字节码文件里。名字是知道了，但是Java真正运行起来的时候，真的能靠这个名字（符号引用）就能找到相应的类和方法吗？需要解析成相应的直接引用，利用直接引用来准确地找到。 举个例子，就相当于我在0X0300H这个地址存入了一个数526，为了方便编程，我把这个给这个地址起了个别名叫A, 以后我编程的时候(运行之前)可以用别名A来暗示访问这个空间的数据，但其实程序运行起来后，实质上还是去寻找0X0300H这片空间来获取526这个数据的。 这样的符号引用和直接引用在运行时进行解析和链接的过程，叫动态链接。 4、方法返回地址 返回一个值给调用它的方法，方法正常完成发生在一个方法执行过程 中遇到了方法返回的字节码指令（§2.11.8）的时候，使用哪种返回指令取决于方法返回值的数 据类型（如果有返回值的话）。 5、附加信息参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/ychenfeng/article/details/77247807 https://blog.csdn.net/u014296316/article/details/82668670","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(二)程序计数器","slug":"backend/Java/JVM/JVM运行时数据区域(二)程序计数器","date":"2019-03-04T01:59:44.000Z","updated":"2019-03-19T14:43:16.603Z","comments":true,"path":"2019/03/04/backend/Java/JVM/JVM运行时数据区域(二)程序计数器/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(二)程序计数器/","excerpt":"","text":"概述程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，在虚拟机的概念模型里（仅仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 特点 线程私有的 是java虚拟机规范里面， 唯一 一个 没有规定任何 OutOfMemoryError 情况的区域 生命周期随着线程，线程启动而产生，线程结束而消亡 作用 程序计数器，可以看做是当前线程执行的字节码的 行号指示器 ，这句话；要理解这句话，需要先知道字节码文件长什么样子，看下面的代码 12345678// java 文件被翻译为字节码的时候，字节码大概类似于下面的样子public void haha()&#123;// 原来的 haha 方法内部的 java 代码，被翻译为下面的类似于汇编语言的指令 0 xxxx .... 2 xxxx .... 4 xx ... 5 xxx ...&#125; 上面左边的 0、2、4、5 ，就是类似于字节码的行号（实际是指令的偏移地址），程序计数器中保存中的值，就是它们；字节码解释器，就是根据它们，来执行程序的 理解了程序计数器，就好理解它的这些特点了；我们都知道，Java是支持多线程的，当CPU执行权从 A 线程，转移到 B 线程的时候，JVM就要暂时挂起线程 A ，去执行线程 B ；当线程 A 再次得到CPU执行权的时候，又会挂起B线程，继续执行 A 线程 ； 我们想象下，CPU是怎么知道记住之前A线程，执行到哪一处的？ 答案是，CPU根本就不会记住之前执行到哪里了，它只是埋头苦干；那是什么保证了切换线程的程序可以正常执行的；答案是 ： 程序计数器 ；程序计数器里面保存的是 当前线程执行的字节码的行号（看着像行号，其实是指令地址）； 那么，我们需要几个程序计数器呢？如果，我们只有一个的话，切换B线程以后，程序计数器里面保存的就是B线程所执行的字节码的行号了，再切换回A线程，就蒙圈了，不知道执行到哪里了，因为，程序计数器里面保存的是B线程当前执行的字节码地址 ；因此，我们可以想象出，要为每个线程都分配一个程序计数器，因此，程序计数器的内存空间是线程私有的 ；这样即使线程 A 被挂起，但是线程 A 里面的程序计数器，记住了A线程当前执行到的字节码的指令地址了 ，等再次切回到A线程的时候，看一下程序计数器，就知道之前执行到哪里了！ 那么程序计数器，什么时候分配内存呢？我们试想下，一个线程在执行的任何期间，都会失去CPU执行权，因此，我们要从一个线程被创建开始执行，就要无时无刻的记录着该线程当前执行到哪里了！因此，线程计数器，必须是线程被创建开始执行的时候，就要一同被创建； 程序计数器，保存的是当前执行的字节码的偏移地址（也就是之前说的行号，其实那不是行号，是指令的偏移地址，只是为了好理解，才说是行号的，），当执行到下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址；因此，永远都不可能内存溢出的；因此，jvm虚拟机规范，也就没有规定，也是唯一一个没有规定 OutOfMemoryError 异常 的区域； 当线程执行的是本地方法的时候，程序计数器中保存的值是空（undefined）；原因很简单：本地方法是C++/C 写的，由系统调用，根本不会产生字节码文件，因此，程序计数器也就不会做任何记录 ； 参考转载 周志明版 《深入理解Java虚拟机》 https://blog.csdn.net/youngyouth/article/details/79868299","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"JVM运行时数据区域(一)介绍","slug":"backend/Java/JVM/JVM运行时数据区域(一)介绍","date":"2019-03-04T00:59:44.000Z","updated":"2019-03-19T14:43:16.544Z","comments":true,"path":"2019/03/04/backend/Java/JVM/JVM运行时数据区域(一)介绍/","link":"","permalink":"http://www.songshuiyang.site/2019/03/04/backend/Java/JVM/JVM运行时数据区域(一)介绍/","excerpt":"","text":"前言 Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域，如图 Java 虚拟机的内存模型分为两部分 线程共享的 方法区 Java 堆 线程私有的 虚拟机栈 本地方法栈 程序计数器 运行时数据区域 程序计数器：指向当前线程正在执行的字节码指令。线程私有的。 虚拟机栈：虚拟机栈是Java执行方法的内存模型。每个方法被执行的时候，都会创建一个栈帧，把栈帧压人栈，当方法正常返回或者抛出未捕获的异常时，栈帧就会出栈 本地方法栈：调用本地native的内存模型 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据 堆（Heap）：Java对象存储的地方 参考转载 周志明版 《深入理解Java虚拟机》 https://segmentfault.com/a/1190000014395186","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"http://www.songshuiyang.site/tags/jvm/"}]},{"title":"Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor","date":"2019-03-03T12:59:44.000Z","updated":"2019-03-16T01:52:02.026Z","comments":true,"path":"2019/03/03/backend/spring/sourceCodeAnalysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor/","link":"","permalink":"http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring Mvc源码(九)RequestBody注解解析之RequestResponseBodyMethodProcessor/","excerpt":"","text":"1.1 前言 RequestResponseBodyMethodProcessor 的作用是处理被@RequestBody注解的参数，和@ResponseBody注解的返回值 查看RequestResponseBodyMethodProcessor继承关系，可以看到它是同时继承了HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler，所以就是说它同时具有参数对象解析及结果对象解析的功能，野心很大 2.1 解析 RequestResponseBodyMethodProcessor.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177/** * 处理被@RequestBody注解的参数，和@ResponseBody注解的返回值 * * Resolves method arguments annotated with &#123;@code @RequestBody&#125; and handles return * values from methods annotated with &#123;@code @ResponseBody&#125; by reading and writing * to the body of the request or response with an &#123;@link HttpMessageConverter&#125;. * * &lt;p&gt;An &#123;@code @RequestBody&#125; method argument is also validated if it is annotated * with &#123;@code @javax.validation.Valid&#125;. In case of validation failure, * &#123;@link MethodArgumentNotValidException&#125; is raised and results in an HTTP 400 * response status code if &#123;@link DefaultHandlerExceptionResolver&#125; is configured. * * @author Arjen Poutsma * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 */public class RequestResponseBodyMethodProcessor extends AbstractMessageConverterMethodProcessor &#123; /** * Basic constructor with converters only. Suitable for resolving * &#123;@code @RequestBody&#125;. For handling &#123;@code @ResponseBody&#125; consider also * providing a &#123;@code ContentNegotiationManager&#125;. */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; super(converters); &#125; /** * Basic constructor with converters and &#123;@code ContentNegotiationManager&#125;. * Suitable for resolving &#123;@code @RequestBody&#125; and handling * &#123;@code @ResponseBody&#125; without &#123;@code Request~&#125; or * &#123;@code ResponseBodyAdvice&#125;. */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, ContentNegotiationManager manager) &#123; super(converters, manager); &#125; /** * Complete constructor for resolving &#123;@code @RequestBody&#125; method arguments. * For handling &#123;@code @ResponseBody&#125; consider also providing a * &#123;@code ContentNegotiationManager&#125;. * @since 4.2 */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, List&lt;Object&gt; requestResponseBodyAdvice) &#123; super(converters, null, requestResponseBodyAdvice); &#125; /** * Complete constructor for resolving &#123;@code @RequestBody&#125; and handling * &#123;@code @ResponseBody&#125;. */ public RequestResponseBodyMethodProcessor(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters, ContentNegotiationManager manager, List&lt;Object&gt; requestResponseBodyAdvice) &#123; super(converters, manager, requestResponseBodyAdvice); &#125; /** * 检测参数是否使用了@RequestBody注解 * * @param parameter the method parameter to check * @return */ @Override public boolean supportsParameter(MethodParameter parameter) &#123; return parameter.hasParameterAnnotation(RequestBody.class); &#125; /** * 检测返回结果是否使用了@ResponseBody注解 * * @param returnType the method return type to check * @return */ @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class)); &#125; /** * 处理被@RequestBody注解的参数 * * Throws MethodArgumentNotValidException if validation fails. * @throws HttpMessageNotReadableException if &#123;@link RequestBody#required()&#125; * is &#123;@code true&#125; and there is no body content or if there is no suitable * converter to read the content with. */ @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; parameter = parameter.nestedIfOptional(); Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) &#123; validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); &#125; &#125; mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); return adaptArgumentIfNecessary(arg, parameter); &#125; /** * * @param webRequest the current request * @param parameter the method parameter descriptor (may be &#123;@code null&#125;) * @param paramType the type of the argument value to be created * @param &lt;T&gt; * @return * @throws IOException * @throws HttpMediaTypeNotSupportedException * @throws HttpMessageNotReadableException */ @Override protected &lt;T&gt; Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter, Type paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123; HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class); ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest); Object arg = readWithMessageConverters(inputMessage, parameter, paramType); if (arg == null) &#123; if (checkRequired(parameter)) &#123; throw new HttpMessageNotReadableException(\"Required request body is missing: \" + parameter.getMethod().toGenericString()); &#125; &#125; return arg; &#125; /** * 检查RequestBody注解是否required * @param parameter * @return */ protected boolean checkRequired(MethodParameter parameter) &#123; return (parameter.getParameterAnnotation(RequestBody.class).required() &amp;&amp; !parameter.isOptional()); &#125; /** * 处理@ResponseBody注解的返回值 * * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws IOException * @throws HttpMediaTypeNotAcceptableException * @throws HttpMessageNotWritableException */ @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; mavContainer.setRequestHandled(true); ServletServerHttpRequest inputMessage = createInputMessage(webRequest); ServletServerHttpResponse outputMessage = createOutputMessage(webRequest); // Try even with null return value. ResponseBodyAdvice could get involved. writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage); &#125;&#125; 2.1.1 处理被@RequestBody注解的参数解析 参数解析需要关注此类是怎么实现的HandlerMethodArgumentResolver接口的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface HandlerMethodArgumentResolver &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method parameter&#125; is * supported by this resolver. * @param parameter the method parameter to check * @return &#123;@code true&#125; if this resolver supports the supplied parameter; * &#123;@code false&#125; otherwise */ boolean supportsParameter(MethodParameter parameter); /** * 根据request解析方法参数值 * * Resolves a method parameter into an argument value from a given request. * A &#123;@link ModelAndViewContainer&#125; provides access to the model for the * request. A &#123;@link WebDataBinderFactory&#125; provides a way to create * a &#123;@link WebDataBinder&#125; instance when needed for data binding and * type conversion purposes. * @param parameter the method parameter to resolve. This parameter must * have previously been passed to &#123;@link #supportsParameter&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @param binderFactory a factory for creating &#123;@link WebDataBinder&#125; instances * @return the resolved argument value, or &#123;@code null&#125; * @throws Exception in case of errors with the preparation of argument values */ Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;&#125;``` * 查看`boolean supportsParameter(MethodParameter parameter);`方法的实现，实现很简单就是判断是否使用了@RequestBody注解```java /** * 检测参数是否使用了@RequestBody注解 * * @param parameter the method parameter to check * @return */ @Override public boolean supportsParameter(MethodParameter parameter) &#123; return parameter.hasParameterAnnotation(RequestBody.class); &#125; 查看public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) 方法的实现 123456789101112131415161718192021222324252627/** * 处理被@RequestBody注解的参数 * * Throws MethodArgumentNotValidException if validation fails. * @throws HttpMessageNotReadableException if &#123;@link RequestBody#required()&#125; * is &#123;@code true&#125; and there is no body content or if there is no suitable * converter to read the content with. */@Overridepublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; parameter = parameter.nestedIfOptional(); // 主体逻辑 Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); String name = Conventions.getVariableNameForParameter(parameter); WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name); if (arg != null) &#123; // 校验参数是否正确 @Valid注解开启 validateIfApplicable(binder, parameter); if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123; throw new MethodArgumentNotValidException(parameter, binder.getBindingResult()); &#125; &#125; mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult()); return adaptArgumentIfNecessary(arg, parameter);&#125; 进入Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType()); 12345678910111213141516@Overrideprotected &lt;T&gt; Object readWithMessageConverters(NativeWebRequest webRequest, MethodParameter parameter, Type paramType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123; HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class); ServletServerHttpRequest inputMessage = new ServletServerHttpRequest(servletRequest); // 主体逻辑 Object arg = readWithMessageConverters(inputMessage, parameter, paramType); if (arg == null) &#123; if (checkRequired(parameter)) &#123; throw new HttpMessageNotReadableException(\"Required request body is missing: \" + parameter.getMethod().toGenericString()); &#125; &#125; return arg;&#125; 继续进入Object arg = readWithMessageConverters(inputMessage, parameter, paramType); ，可以看到是遍历 this.messageConverters 选择适合的消息处理器来处理参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Create the method argument value of the expected parameter type by reading * from the given HttpInputMessage. * @param &lt;T&gt; the expected type of the argument value to be created * @param inputMessage the HTTP input message representing the current request * @param parameter the method parameter descriptor (may be &#123;@code null&#125;) * @param targetType the target type, not necessarily the same as the method * parameter type, e.g. for &#123;@code HttpEntity&lt;String&gt;&#125;. * @return the created method argument value * @throws IOException if the reading from the request fails * @throws HttpMediaTypeNotSupportedException if no suitable message converter is found */@SuppressWarnings(\"unchecked\")protected &lt;T&gt; Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter, Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException &#123; MediaType contentType; boolean noContentType = false; try &#123; contentType = inputMessage.getHeaders().getContentType(); &#125; catch (InvalidMediaTypeException ex) &#123; throw new HttpMediaTypeNotSupportedException(ex.getMessage()); &#125; if (contentType == null) &#123; noContentType = true; contentType = MediaType.APPLICATION_OCTET_STREAM; &#125; Class&lt;?&gt; contextClass = (parameter != null ? parameter.getContainingClass() : null); Class&lt;T&gt; targetClass = (targetType instanceof Class ? (Class&lt;T&gt;) targetType : null); if (targetClass == null) &#123; ResolvableType resolvableType = (parameter != null ? ResolvableType.forMethodParameter(parameter) : ResolvableType.forType(targetType)); targetClass = (Class&lt;T&gt;) resolvableType.resolve(); &#125; HttpMethod httpMethod = ((HttpRequest) inputMessage).getMethod(); Object body = NO_VALUE; try &#123; inputMessage = new EmptyBodyCheckingHttpInputMessage(inputMessage); // 遍历 this.messageConverters 选择适合的消息处理器来处理参数 for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) &#123; Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(); if (converter instanceof GenericHttpMessageConverter) &#123; GenericHttpMessageConverter&lt;?&gt; genericConverter = (GenericHttpMessageConverter&lt;?&gt;) converter; // 判断是否适合处理参数 if (genericConverter.canRead(targetType, contextClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = genericConverter.read(targetType, contextClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125; else if (targetClass != null) &#123; if (converter.canRead(targetClass, contentType)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Read [\" + targetType + \"] as \\\"\" + contentType + \"\\\" with [\" + converter + \"]\"); &#125; if (inputMessage.getBody() != null) &#123; inputMessage = getAdvice().beforeBodyRead(inputMessage, parameter, targetType, converterType); body = ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, inputMessage); body = getAdvice().afterBodyRead(body, inputMessage, parameter, targetType, converterType); &#125; else &#123; body = getAdvice().handleEmptyBody(null, inputMessage, parameter, targetType, converterType); &#125; break; &#125; &#125; &#125; &#125; catch (IOException ex) &#123; throw new HttpMessageNotReadableException(\"I/O error while reading input message\", ex); &#125; if (body == NO_VALUE) &#123; if (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) || (noContentType &amp;&amp; inputMessage.getBody() == null)) &#123; return null; &#125; throw new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes); &#125; return body;&#125; 查看this.messageConverters有哪些呢？见下图 下图是主要MessageConverter的功能介绍 2.1.2 处理被@ResponseBody注解的返回值解析 返回值解析需要关注此类是怎样实现HandlerMethodArgumentResolver接口的方法的 1234567891011121314151617181920212223242526272829303132public interface HandlerMethodReturnValueHandler &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method return type&#125; is * supported by this handler. * @param returnType the method return type to check * @return &#123;@code true&#125; if this handler supports the supplied return type; * &#123;@code false&#125; otherwise */ boolean supportsReturnType(MethodParameter returnType); /** * 处理结果集 * * Handle the given return value by adding attributes to the model and * setting a view or setting the * &#123;@link ModelAndViewContainer#setRequestHandled&#125; flag to &#123;@code true&#125; * to indicate the response has been handled directly. * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws Exception if the return value handling results in an error */ void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;&#125; 查看boolean supportsReturnType(MethodParameter returnType);的方法的实现，实现也很简单就是判断是否使用了@ResponseBody注解 1234567891011/** * 检测返回结果是否使用了@ResponseBody注解 * * @param returnType the method return type to check * @return */@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; return (AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || returnType.hasMethodAnnotation(ResponseBody.class));&#125; 查看public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)的实现 123456789101112131415161718192021222324/** * 处理@ResponseBody注解的返回值 * * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws IOException * @throws HttpMediaTypeNotAcceptableException * @throws HttpMessageNotWritableException */@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123; mavContainer.setRequestHandled(true); ServletServerHttpRequest inputMessage = createInputMessage(webRequest); ServletServerHttpResponse outputMessage = createOutputMessage(webRequest); // Try even with null return value. ResponseBodyAdvice could get involved. writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);&#125; 3.1 总结 我们知道，Http请求和响应报文本质上都是一串字符串，当请求报文来到java世界，它会被封装成为一个ServletInputStream的输入流，供我们读取报文。响应报文则是通过一个ServletOutputStream的输出流，来输出响应报文，我们得到输入输出流之后需要把它转成我们的java实体类对象，这个是怎样转换的呢，就是通过我们的HttpMessageConverter消息转换器来实现的 下图是HttpMessageConverter的工作流程图 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://my.oschina.net/lichhao/blog/172562","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(八)RequestMappingHanlderAdapter","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(八)RequestMappingHanlderAdapter","date":"2019-03-03T03:59:44.000Z","updated":"2019-03-10T01:44:49.412Z","comments":true,"path":"2019/03/03/backend/spring/sourceCodeAnalysis/Spring Mvc源码(八)RequestMappingHanlderAdapter/","link":"","permalink":"http://www.songshuiyang.site/2019/03/03/backend/spring/sourceCodeAnalysis/Spring Mvc源码(八)RequestMappingHanlderAdapter/","excerpt":"","text":"1.1 前言 RequestMappingHanlderAdapter是 HanlderAdapter 中最复杂的也是最常用的处理适配器，他的作用是根据HanlderMapping找到的Handler调用我们Controller 里的方法 既然是调用方法我们推测它的工作应该主要设及3步， 1、方法参数绑定，2、方法执行，3、返回结果处理 ， 方法执行的流程已经在代码里写好了，重点是参数绑定及结果处理，各个方法参数类型不同个数不同，想想就复杂，下面来看人家是怎么做的 2.1 RequestMappingHanlderAdapter初始化解析 查看RequestMappingHanlderAdapter的继承关系 RequestMappingHandlerAdapter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * An &#123;@link AbstractHandlerMethodAdapter&#125; that supports &#123;@link HandlerMethod&#125;s * with their method argument and return type signature, as defined via * &#123;@code @RequestMapping&#125;. * * &lt;p&gt;Support for custom argument and return value types can be added via * &#123;@link #setCustomArgumentResolvers&#125; and &#123;@link #setCustomReturnValueHandlers&#125;. * Or alternatively, to re-configure all argument and return value types, * use &#123;@link #setArgumentResolvers&#125; and &#123;@link #setReturnValueHandlers&#125;. * * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 * @see HandlerMethodArgumentResolver * @see HandlerMethodReturnValueHandler */public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter implements BeanFactoryAware, InitializingBean &#123; private List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers; // 用于给处理器方法和注释了@ModelAttribute的方法设置参数 private HandlerMethodArgumentResolverComposite argumentResolvers; // 用于添加了@initBinder的方法设置参数 private HandlerMethodArgumentResolverComposite initBinderArgumentResolvers; private List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers; // 用于将处理器的返回值处理为ModelAndView类型 private HandlerMethodReturnValueHandlerComposite returnValueHandlers; private List&lt;ModelAndViewResolver&gt; modelAndViewResolvers; private ContentNegotiationManager contentNegotiationManager = new ContentNegotiationManager(); private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters; private List&lt;Object&gt; requestResponseBodyAdvice = new ArrayList&lt;Object&gt;(); private WebBindingInitializer webBindingInitializer; private AsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor(\"MvcAsync\"); private Long asyncRequestTimeout; private CallableProcessingInterceptor[] callableInterceptors = new CallableProcessingInterceptor[0]; private DeferredResultProcessingInterceptor[] deferredResultInterceptors = new DeferredResultProcessingInterceptor[0]; private boolean ignoreDefaultModelOnRedirect = false; private int cacheSecondsForSessionAttributeHandlers = 0; private boolean synchronizeOnSession = false; private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore(); private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); private ConfigurableBeanFactory beanFactory; private final Map&lt;Class&lt;?&gt;, SessionAttributesHandler&gt; sessionAttributesHandlerCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, SessionAttributesHandler&gt;(64); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; initBinderCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; initBinderAdviceCache = new LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;(); private final Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; modelAttributeCache = new ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(64); private final Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; modelAttributeAdviceCache = new LinkedHashMap&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;(); public RequestMappingHandlerAdapter() &#123; StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter(); stringHttpMessageConverter.setWriteAcceptCharset(false); // see SPR-7316 this.messageConverters = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(4); this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(stringHttpMessageConverter); this.messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;()); this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); &#125; 可以看到实现了InitializingBean接口，这个方法注册了this.argumentResolvers this.initBinderArgumentResolvers this.returnValueHandlers 123456789101112131415161718@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBody advice beans initControllerAdviceCache(); if (this.argumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.initBinderArgumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers); &#125; if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers); &#125;&#125; 例如getDefaultArgumentResolvers方法，可以看到是直接写死了有那些默认的参数解析组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Return the list of argument resolvers to use including built-in resolvers * and custom resolvers provided via &#123;@link #setCustomArgumentResolvers&#125;. */private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = new ArrayList&lt;HandlerMethodArgumentResolver&gt;(); // Annotation-based argument resolution resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false)); resolvers.add(new RequestParamMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.PathVariableMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.PathVariableMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.MatrixVariableMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(false)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory())); resolvers.add(new RequestHeaderMapMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletCookieValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory())); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.SessionAttributeMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RequestAttributeMethodArgumentResolver()); // Type-based argument resolution resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletRequestMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletResponseMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.RedirectAttributesMethodArgumentResolver()); resolvers.add(new ModelMethodProcessor()); resolvers.add(new MapMethodProcessor()); resolvers.add(new ErrorsMethodArgumentResolver()); resolvers.add(new SessionStatusMethodArgumentResolver()); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.UriComponentsBuilderMethodArgumentResolver()); // Custom arguments if (getCustomArgumentResolvers() != null) &#123; resolvers.addAll(getCustomArgumentResolvers()); &#125; // Catch-all resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true)); resolvers.add(new org.springframework.web.servlet.mvc.method.annotation.ServletModelAttributeMethodProcessor(true)); return resolvers;&#125; 2.2 处理解析 RequestMappingHanlderAdapter 处理请求入口方法是handleInternal(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod)，进入该方法 12345678910111213141516171819202122232425262728293031@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ModelAndView mav; checkRequest(request); // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // 具体执行请求的处理 // No synchronization on session demanded at all... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125; 关注mav = invokeHandlerMethod(request, response, handlerMethod);方法，进入该方法之后可以看到该方法主要是一些参数准备及组装各种处理单元，先备兵粮 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Invoke the &#123;@link RequestMapping&#125; handler method preparing a &#123;@link ModelAndView&#125; * if view resolution is required. * @since 4.2 * @see #createInvocableHandlerMethod(HandlerMethod) */protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; ServletWebRequest webRequest = new ServletWebRequest(request, response); try &#123; // 创建WebDataBinder，WebDataBinder用于参数绑定，将符合条件的注释了@InitBinder的方法找出来 WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod); // 用来处理Model，在处理器具体处理之前对Model进行初始化，在处理完请求之后对Model参数进行更新 ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory); // 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成 org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod); invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers); invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers); invocableMethod.setDataBinderFactory(binderFactory); invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // ModelAndViewContainer承载着整个请求过程中数据的传递工作 ModelAndViewContainer mavContainer = new ModelAndViewContainer(); mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request)); modelFactory.initModel(webRequest, mavContainer, invocableMethod); mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect); AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response); asyncWebRequest.setTimeout(this.asyncRequestTimeout); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.setTaskExecutor(this.taskExecutor); asyncManager.setAsyncWebRequest(asyncWebRequest); asyncManager.registerCallableInterceptors(this.callableInterceptors); asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors); if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Found concurrent result value [\" + result + \"]\"); &#125; invocableMethod = invocableMethod.wrapConcurrentResult(result); &#125; // 执行方法 invocableMethod.invokeAndHandle(webRequest, mavContainer); if (asyncManager.isConcurrentHandlingStarted()) &#123; return null; &#125; return getModelAndView(mavContainer, modelFactory, webRequest); &#125; finally &#123; webRequest.requestCompleted(); &#125;&#125; 这个方法重点关注ServletInvocableHandlerMethod此对象，该类继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成 123456// 继承自HandlerMethod，实际请求的处理就是通过它来执行的，包括参数绑定，请求处理，以及返回值处理都是在它里面完成org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);invocableMethod.setDataBinderFactory(binderFactory);invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); 查看上面代码可以看到这里设置了参数解析器 结果解析器 等等 ServletInvocableHandlerMethod 解析 先查看ServletInvocableHandlerMethod的继承关系，此类的继承关系有三层 顶层HandlerMethod类，该类封装了方法调用相关信息，比如是属于哪个bean下的的，那个Method，方法的参数MethodParameter[]等等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 封装了方法调用相关信息,子类还提供调用,参数准备和返回值处理的职责 * * Encapsulates information about a handler method consisting of a * &#123;@linkplain #getMethod() method&#125; and a &#123;@linkplain #getBean() bean&#125;. * Provides convenient access to method parameters, the method return value, * method annotations, etc. * * &lt;p&gt;The class may be created with a bean instance or with a bean name * (e.g. lazy-init bean, prototype bean). Use &#123;@link #createWithResolvedBean()&#125; * to obtain a &#123;@code HandlerMethod&#125; instance with a bean instance resolved * through the associated &#123;@link BeanFactory&#125;. * * @author Arjen Poutsma * @author Rossen Stoyanchev * @author Juergen Hoeller * @author Sam Brannen * @since 3.1 */public class HandlerMethod &#123; /** Logger that is available to subclasses */ protected final Log logger = LogFactory.getLog(getClass()); private final Object bean; private final BeanFactory beanFactory; private final Class&lt;?&gt; beanType; private final Method method; private final Method bridgedMethod; /** * 方法的参数 */ private final MethodParameter[] parameters; private HttpStatus responseStatus; private String responseStatusReason; private HandlerMethod resolvedFromHandlerMethod; ... InvocableHandlerMethod 类 HandlerMethod类的基础上添加了方法调用功能及注册了参数解析组件 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 在 HandlerMethod类的基础上添加了方法调用功能及注册了参数解析组件 * * Provides a method for invoking the handler method for a given request after resolving its * method argument values through registered &#123;@link HandlerMethodArgumentResolver&#125;s. * * &lt;p&gt;Argument resolution often requires a &#123;@link WebDataBinder&#125; for data binding or for type * conversion. Use the &#123;@link #setDataBinderFactory(WebDataBinderFactory)&#125; property to supply * a binder factory to pass to argument resolvers. * * &lt;p&gt;Use &#123;@link #setHandlerMethodArgumentResolvers&#125; to customize the list of argument resolvers. * * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 */public class InvocableHandlerMethod extends HandlerMethod &#123; /** * 用于参数解析器ArgumentResolver */ private WebDataBinderFactory dataBinderFactory; /** * 解析参数 */ private org.springframework.web.method.support.HandlerMethodArgumentResolverComposite argumentResolvers = new org.springframework.web.method.support.HandlerMethodArgumentResolverComposite(); /** * 用来获取参数名 */ private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer(); /** * Create an instance from a &#123;@code HandlerMethod&#125;. */ public InvocableHandlerMethod(HandlerMethod handlerMethod) &#123; super(handlerMethod); &#125; ... 得到ServletInvocableHandlerMethod 对象之后进入到ServletInvocableHandlerMethod 类的invocableMethod.invokeAndHandle(webRequest, mavContainer); 方法，可以说这个方法是RequestMappingHandlerAdapter的核心方法，可以看到Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 是执行了方法体，得到returnValue 之后就是调用this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);该方法处理结果对象 123456789101112131415161718192021222324252627282930313233343536/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler&#125;s. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); try &#123; this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(getReturnValueHandlingErrorMessage(\"Error handling return value\", returnValue), ex); &#125; throw ex; &#125;&#125; 进入Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 方法，可以看到该方法很简单，先是得到方法参数Object[] args，然后执行Object returnValue = doInvoke(args); 该方法得到结果 1234567891011121314151617181920212223242526272829/** * Invoke the method after resolving its argument values in the context of the given request. * &lt;p&gt;Argument values are commonly resolved through &#123;@link HandlerMethodArgumentResolver&#125;s. * The &#123;@code providedArgs&#125; parameter however may supply argument values to be used directly, * i.e. without argument resolution. Examples of provided argument values include a * &#123;@link WebDataBinder&#125;, a &#123;@link SessionStatus&#125;, or a thrown exception instance. * Provided argument values are checked before argument resolvers. * @param request the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type, not resolved * @return the raw value returned by the invoked method * @exception Exception raised if no suitable argument resolver can be found, * or if the method raised an exception */public Object invokeForRequest(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"' with arguments \" + Arrays.toString(args)); &#125; Object returnValue = doInvoke(args); if (logger.isTraceEnabled()) &#123; logger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"] returned [\" + returnValue + \"]\"); &#125; return returnValue;&#125; 2.1.1 方法参数绑定 方法参数的绑定需要关注Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); 这行代码，先进入该方法，可以看到该方法有两种解析形式 1： providedArgs 2：argumentResolvers 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 根据当前请求获取方法的请求参数 * Get the method argument values for the current request. * 两种解析形式 1： providedArgs 2：argumentResolvers 在RequestMappingHandlerAdapter中只有argumentResolvers解析 * */private Object[] getMethodArgumentValues(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; // 获取方法的参数，在HanderMethod中 MethodParameter[] parameters = getMethodParameters(); // 用于保存解析出参数的值 Object[] args = new Object[parameters.length]; // 遍历每一个参数进行解析 for (int i = 0; i &lt; parameters.length; i++) &#123; MethodParameter parameter = parameters[i]; // 给Parameter设置参数名解析器 parameter.initParameterNameDiscovery(this.parameterNameDiscoverer); // 如果相应类型的参数已经在providedArgs中提供了，则直接设置到parameter args[i] = resolveProvidedArgument(parameter, providedArgs); if (args[i] != null) &#123; continue; &#125; if (this.argumentResolvers.supportsParameter(parameter)) &#123; try &#123; // 使用argumentResolvers解析参数 args[i] = this.argumentResolvers.resolveArgument( parameter, mavContainer, request, this.dataBinderFactory); continue; &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(getArgumentResolutionErrorMessage(\"Failed to resolve\", i), ex); &#125; throw ex; &#125; &#125; // 解析不出来，抛异常 if (args[i] == null) &#123; throw new IllegalStateException(\"Could not resolve method parameter at index \" + parameter.getParameterIndex() + \" in \" + parameter.getMethod().toGenericString() + \": \" + getArgumentResolutionErrorMessage(\"No suitable resolver for\", i)); &#125; &#125; return args;&#125; 在RequestMappingHandlerAdapter中只有argumentResolvers解析，因为invocableMethod.invokeAndHandle(webRequest, mavContainer); 只传了两个参数，到了Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); 方法之后也是没有传入providedArgs的 argumentResolvers 存放在HandlerMethodArgumentResolverComposite 类中，所有的ArgumentResolver都存放在List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers中，也可以看到该类也做了一个argumentResolverCacheCache处理，也是为了性能 12345678910111213141516171819202122232425262728/** * HandlerMethodArgumentResolver 的仓库 * * Resolves method parameters by delegating to a list of registered &#123;@link HandlerMethodArgumentResolver&#125;s. * Previously resolved method parameters are cached for faster lookups. * * @author Rossen Stoyanchev * @author Juergen Hoeller * @since 3.1 */public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver &#123; protected final Log logger = LogFactory.getLog(getClass()); private final List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers = new LinkedList&lt;HandlerMethodArgumentResolver&gt;(); private final Map&lt;MethodParameter, HandlerMethodArgumentResolver&gt; argumentResolverCache = new ConcurrentHashMap&lt;MethodParameter, HandlerMethodArgumentResolver&gt;(256); /** * Add the given &#123;@link HandlerMethodArgumentResolver&#125;. */ public HandlerMethodArgumentResolverComposite addResolver(HandlerMethodArgumentResolver resolver) &#123; this.argumentResolvers.add(resolver); return this; &#125; 通过调试可以看到有下面这些argumentResolvers，看类名称是不是很熟悉，就是我们平常使用的@RequestBody @RequestParam 是一一对应的，还是专人做专事，可以得出不同的参数是有不同的参数解析组件来专门处理的 下面来看主要XXXArgumentResolver的作用 123456789101112131415161. SessionAttributeMethodArgumentResolver 针对 被 @SessionAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_SESSION) 2. RequestParamMethodArgumentResolver 针对被 @RequestParam 注解修饰, 但类型不是 Map, 或类型是 Map, 并且 @RequestParam 中指定 name, 一般通过 MultipartHttpServletRequest | HttpServletRequest 获取数据3. RequestHeaderMethodArgumentResolver 针对 参数被 RequestHeader 注解, 并且 参数不是 Map 类型, 数据通过 HttpServletRequest.getHeaderValues(name) 获取4. RequestAttributeMethodArgumentResolver 针对 被 @RequestAttribute 修饰的参数起作用, 参数的获取一般通过 HttpServletRequest.getAttribute(name, RequestAttributes.SCOPE_REQUEST)5. PathVariableMethodArgumentResolver 解决被注解 @PathVariable 注释的参数 &lt;- 这个注解对应的是 uri 中的数据, 在解析 URI 中已经进行解析好了 &lt;- 在 RequestMappingInfoHandlerMapping.handleMatch -&gt; getPathMatcher().extractUriTemplateVariables6. MatrixVariableMethodArgumentResolver 针对被 @MatrixVariable 注解修饰的参数起作用, 从 HttpServletRequest 中获取去除 ; 的 URI Template Variables 获取数据7. ExpressionValueMethodArgumentResolver 针对被 @Value 修饰, 返回 ExpressionValueNamedValueInfo8. ServletCookieValueMethodArgumentResolver 针对被 @CookieValue 修饰, 通过 HttpServletRequest.getCookies 获取对应数据 然后进入HandlerMethodArgumentResolverComposite类的args[i] = this.argumentResolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory); 方法，可以看到逻辑十分简单，就是遍历this.argumentResolvers 然后做了个缓存处理，得到HandlerMethodArgumentResolver之后就是调用resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);方法了，该方法是参数解析的主体方法 12345678910111213141516171819202122232425262728293031323334353637/** * 迭代注册过的 HandlerMethodArgumentResolver, 然后找到对应的ArgumentResolver * Iterate over registered &#123;@link HandlerMethodArgumentResolver&#125;s and invoke the one that supports it. * @throws IllegalStateException if no suitable &#123;@link HandlerMethodArgumentResolver&#125; is found. */@Overridepublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter); if (resolver == null) &#123; throw new IllegalArgumentException(\"Unknown parameter type [\" + parameter.getParameterType().getName() + \"]\"); &#125; return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);&#125;/** * 先从缓存里取，没有的再遍历，注意这里是先来先得的 * Find a registered &#123;@link HandlerMethodArgumentResolver&#125; that supports the given method parameter. */private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123; HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter); if (result == null) &#123; for (HandlerMethodArgumentResolver methodArgumentResolver : this.argumentResolvers) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(\"Testing if argument resolver [\" + methodArgumentResolver + \"] supports [\" + parameter.getGenericParameterType() + \"]\"); &#125; if (methodArgumentResolver.supportsParameter(parameter)) &#123; result = methodArgumentResolver; this.argumentResolverCache.put(parameter, result); break; &#125; &#125; &#125; return result;&#125; 再来回顾HandlerMethodArgumentResolver接口，该接口就两个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 方法参数解析器 * * Strategy interface for resolving method parameters into argument values in * the context of a given request. * * @author Arjen Poutsma * @since 3.1 * @see HandlerMethodReturnValueHandler */public interface HandlerMethodArgumentResolver &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method parameter&#125; is * supported by this resolver. * @param parameter the method parameter to check * @return &#123;@code true&#125; if this resolver supports the supplied parameter; * &#123;@code false&#125; otherwise */ boolean supportsParameter(MethodParameter parameter); /** * 根据request解析方法参数值 * * Resolves a method parameter into an argument value from a given request. * A &#123;@link ModelAndViewContainer&#125; provides access to the model for the * request. A &#123;@link WebDataBinderFactory&#125; provides a way to create * a &#123;@link WebDataBinder&#125; instance when needed for data binding and * type conversion purposes. * @param parameter the method parameter to resolve. This parameter must * have previously been passed to &#123;@link #supportsParameter&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @param binderFactory a factory for creating &#123;@link WebDataBinder&#125; instances * @return the resolved argument value, or &#123;@code null&#125; * @throws Exception in case of errors with the preparation of argument values */ Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception;&#125; HandlerMethodArgumentResolver的 resolveArgument 的解析将在之后的章节介绍 2.2.2 方法执行 回到InvocableHandlerMethod类的invokeForRequest 方法，上一小节介绍了方法参数绑定的主体逻辑(Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);)，这一小节介绍Object returnValue = doInvoke(args);，该行代码是方法执行的主体方法 123456789101112131415public Object invokeForRequest(NativeWebRequest request, org.springframework.web.method.support.ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs); if (logger.isTraceEnabled()) &#123; logger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"' with arguments \" + Arrays.toString(args)); &#125; Object returnValue = doInvoke(args); if (logger.isTraceEnabled()) &#123; logger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) + \"] returned [\" + returnValue + \"]\"); &#125; return returnValue;&#125; 进入Object returnValue = doInvoke(args); 方法，可以看到调用了getBridgedMethod().invoke(getBean(), args); 来执行方法，getBridgedMethod() 得到的是private final Method bridgedMethod，百度了一下这个桥接方法的用途是为了和jdk1.5之前的字节码兼容. 因为范型是在jdk1.5之后才引入的. 在jdk1.5之前例如集合的操作都是没有范型支持的, 所以生成的字节码中参数都是用Object接收的, 所以也可以往集合中放入任意类型的对象, 集合类型的校验也被拖到运行期. 1234567891011121314151617181920212223242526272829303132/** * Invoke the handler method with the given argument values. */protected Object doInvoke(Object... args) throws Exception &#123; // 强制将他变为可调用 即使是private方法 ReflectionUtils.makeAccessible(getBridgedMethod()); try &#123; return getBridgedMethod().invoke(getBean(), args); &#125; catch (IllegalArgumentException ex) &#123; assertTargetBean(getBridgedMethod(), getBean(), args); String text = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\"); throw new IllegalStateException(getInvocationErrorMessage(text, args), ex); &#125; catch (InvocationTargetException ex) &#123; // Unwrap for HandlerExceptionResolvers ... Throwable targetException = ex.getTargetException(); if (targetException instanceof RuntimeException) &#123; throw (RuntimeException) targetException; &#125; else if (targetException instanceof Error) &#123; throw (Error) targetException; &#125; else if (targetException instanceof Exception) &#123; throw (Exception) targetException; &#125; else &#123; String text = getInvocationErrorMessage(\"Failed to invoke handler method\", args); throw new IllegalStateException(text, targetException); &#125; &#125;&#125; 在此方法执行完成 2.2.3 返回结果处理 方法执行完成之后就对返回结果的处理了，回到ServletInvocableHandlerMethod类，现在方法体已经执行了，就是对结果对象的处理了 1234567891011121314151617181920212223242526272829303132333435/** * Invoke the method and handle the return value through one of the * configured &#123;@link HandlerMethodReturnValueHandler&#125;s. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception &#123; Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) &#123; if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) &#123; mavContainer.setRequestHandled(true); return; &#125; &#125; else if (StringUtils.hasText(getResponseStatusReason())) &#123; mavContainer.setRequestHandled(true); return; &#125; mavContainer.setRequestHandled(false); try &#123; this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest); &#125; catch (Exception ex) &#123; if (logger.isTraceEnabled()) &#123; logger.trace(getReturnValueHandlingErrorMessage(\"Error handling return value\", returnValue), ex); &#125; throw ex; &#125;&#125; 查看上面的代码可以看到this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest); 这行代码作用是对结果对象的处理，查看returnValueHandlers 对象（private HandlerMethodReturnValueHandlerComposite returnValueHandlers;）可以看到和我们之前的参数绑定的处理是相似的，HandlerMethodReturnValueHandlerComposite存放了各种结果处理组件 HandlerMethodReturnValueHandlerComposite.java 123456789101112131415/** * Handles method return values by delegating to a list of registered &#123;@link HandlerMethodReturnValueHandler&#125;s. * Previously resolved return types are cached for faster lookups. * * @author Rossen Stoyanchev * @since 3.1 */public class HandlerMethodReturnValueHandlerComposite implements AsyncHandlerMethodReturnValueHandler &#123; protected final Log logger = LogFactory.getLog(getClass()); // 结果处理组件 private final List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers = new ArrayList&lt;HandlerMethodReturnValueHandler&gt;(); HandlerMethodReturnValueHandler.java 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 结果对象处理 * * Strategy interface to handle the value returned from the invocation of a * handler method . * * @author Arjen Poutsma * @since 3.1 * @see HandlerMethodArgumentResolver */public interface HandlerMethodReturnValueHandler &#123; /** * 是否支持 * * Whether the given &#123;@linkplain MethodParameter method return type&#125; is * supported by this handler. * @param returnType the method return type to check * @return &#123;@code true&#125; if this handler supports the supplied return type; * &#123;@code false&#125; otherwise */ boolean supportsReturnType(MethodParameter returnType); /** * 处理结果集 * * Handle the given return value by adding attributes to the model and * setting a view or setting the * &#123;@link ModelAndViewContainer#setRequestHandled&#125; flag to &#123;@code true&#125; * to indicate the response has been handled directly. * @param returnValue the value returned from the handler method * @param returnType the type of the return value. This type must have * previously been passed to &#123;@link #supportsReturnType&#125; which must * have returned &#123;@code true&#125;. * @param mavContainer the ModelAndViewContainer for the current request * @param webRequest the current request * @throws Exception if the return value handling results in an error */ void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;&#125; 进入handleReturnValue方法，可以看到和之前方法参数绑定处理是一样的套路的 12345678910111213141516171819202122232425262728/** * 迭代注册过的 HandlerMethodReturnValueHandler, 然后找到对应的ReturnValueHandler * Iterate over registered &#123;@link HandlerMethodReturnValueHandler&#125;s and invoke the one that supports it. * @throws IllegalStateException if no suitable &#123;@link HandlerMethodReturnValueHandler&#125; is found. */@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType); if (handler == null) &#123; throw new IllegalArgumentException(\"Unknown return value type: \" + returnType.getParameterType().getName()); &#125; handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);&#125; private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) &#123; boolean isAsyncValue = isAsyncReturnValue(value, returnType); for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) &#123; if (isAsyncValue &amp;&amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) &#123; continue; &#125; if (handler.supportsReturnType(returnType)) &#123; return handler; &#125; &#125; return null; &#125; 如下图可以看到有如下this.returnValueHandlers 3.1 总结 RequestMappingHanlderAdapter 的功能主要是 1、方法参数绑定，2、方法执行，3、返回结果处理 HandlerMethodArgumentResolver 的方法参数绑定处理是针对于不同的方法参数有专门的ArgumentResolver 专人做专事，专业 HandlerMethodReturnValueHandler 的返回结果处理也是和参数处理那样是针对于不同的返回对象有专门的ReturnValueHandler 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(七)处理适配器HanlderAdapter","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(七)处理适配器HanlderAdapter","date":"2019-02-28T13:59:44.000Z","updated":"2019-03-03T03:19:43.261Z","comments":true,"path":"2019/02/28/backend/spring/sourceCodeAnalysis/Spring Mvc源码(七)处理适配器HanlderAdapter/","link":"","permalink":"http://www.songshuiyang.site/2019/02/28/backend/spring/sourceCodeAnalysis/Spring Mvc源码(七)处理适配器HanlderAdapter/","excerpt":"","text":"1.1 前言 前几章介绍了HandlerMapping处理流程， HandlerMapping负责根据request请求找到对应的Handler处理器及Interceptor拦截器，的到处理器Handler之后，Spring MVC 又根据该Handler 找出对应的 HandlerAdapter，这一章节来介绍HandlerAdapter，HandlerAdapter是具体使用Handler 来干活的 下面还是方法体doDispatch(HttpServletRequest request, HttpServletResponse response) 的处理代码，可以看到得到Handler处理器之后就是遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter，找到之后就是mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 调用真正的处理方法了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否是文件上传请求 Multipart，有则将请求转换为 Multipart 请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中 mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理 last-modified 请求头 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 执行相应拦截器Interceptor的preHandle if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 执行实际的处理程序，执行Controller里的方法 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 2.1 处理适配器HanlderAdapter解析2.1.1 HanlderAdapter 解析 先看HanlderAdapter 这个接口有哪些方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Handler 处理适配器, 适配不同的 Handler * * MVC framework SPI, allowing parameterization of the core MVC workflow. * * &lt;p&gt;Interface that must be implemented for each handler type to handle a request. * This interface is used to allow the &#123;@link DispatcherServlet&#125; to be indefinitely * extensible. The &#123;@code DispatcherServlet&#125; accesses all installed handlers through * this interface, meaning that it does not contain code specific to any handler type. * * &lt;p&gt;Note that a handler can be of type &#123;@code Object&#125;. This is to enable * handlers from other frameworks to be integrated with this framework without * custom coding, as well as to allow for annotation-driven handler objects that * do not obey any specific Java interface. * * &lt;p&gt;This interface is not intended for application developers. It is available * to handlers who want to develop their own web workflow. * * &lt;p&gt;Note: &#123;@code HandlerAdapter&#125; implementors may implement the &#123;@link * org.springframework.core.Ordered&#125; interface to be able to specify a sorting * order (and thus a priority) for getting applied by the &#123;@code DispatcherServlet&#125;. * Non-Ordered instances get treated as lowest priority. * * @author Rod Johnson * @author Juergen Hoeller * @see org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter * @see org.springframework.web.servlet.handler.SimpleServletHandlerAdapter */public interface HandlerAdapter &#123; /** * 检测 HandlerAdapter 是否支持这个 handler * * Given a handler instance, return whether or not this &#123;@code HandlerAdapter&#125; * can support it. Typical HandlerAdapters will base the decision on the handler * type. HandlerAdapters will usually only support one handler type each. * &lt;p&gt;A typical implementation: * &lt;p&gt;&#123;@code * return (handler instanceof MyHandler); * &#125; * @param handler handler object to check * @return whether or not this object can use the given handler */ boolean supports(Object handler); /** * 处理 HttpServletRequest 的入口方法 * * Use the given handler to handle this request. * The workflow that is required may vary widely. * @param request current HTTP request * @param response current HTTP response * @param handler handler to use. This object must have previously been passed * to the &#123;@code supports&#125; method of this interface, which must have * returned &#123;@code true&#125;. * @throws Exception in case of errors * @return ModelAndView object with the name of the view and the required * model data, or &#123;@code null&#125; if the request has been handled directly */ ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * 获取Http 请求中的lastModifiedTime * * Same contract as for HttpServlet's &#123;@code getLastModified&#125; method. * Can simply return -1 if there's no support in the handler class. * @param request current HTTP request * @param handler handler to use * @return the lastModified value for the given handler * @see javax.servlet.http.HttpServlet#getLastModified * @see org.springframework.web.servlet.mvc.LastModified#getLastModified */ long getLastModified(HttpServletRequest request, Object handler);&#125; 下图是HanlderAdapter涉及子类的继承关系，看方法名是不是很熟悉，没错和前几章的HandlerMapping是差不多是一一对应的 image 查看这些类可以看到除了RequestMappingHandlerAdapter 的实现比较复杂之外，其他的HandlerAdapter都是调用Handler里固定的方法，比如下图的SimpleControllerHandlerAdapter 1234567891011121314151617181920212223public class SimpleControllerHandlerAdapter implements HandlerAdapter &#123; @Override public boolean supports(Object handler) &#123; return (handler instanceof Controller); &#125; @Override public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return ((Controller) handler).handleRequest(request, response); &#125; @Override public long getLastModified(HttpServletRequest request, Object handler) &#123; if (handler instanceof LastModified) &#123; return ((LastModified) handler).getLastModified(request); &#125; return -1L; &#125;&#125; 查看AbstractHandlerMethodAdapter可以看到内容也很少，HandlerAdapter 接口的实现都转发到自己的抽象方法里去了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * Abstract base class for &#123;@link HandlerAdapter&#125; implementations that support * handlers of type &#123;@link HandlerMethod&#125;. * * @author Arjen Poutsma * @since 3.1 */public abstract class AbstractHandlerMethodAdapter extends WebContentGenerator implements HandlerAdapter, Ordered &#123; private int order = Ordered.LOWEST_PRECEDENCE; public AbstractHandlerMethodAdapter() &#123; // no restriction of HTTP methods by default super(false); &#125; /** * Specify the order value for this HandlerAdapter bean. * &lt;p&gt;Default value is &#123;@code Integer.MAX_VALUE&#125;, meaning that it's non-ordered. * @see org.springframework.core.Ordered#getOrder() */ public void setOrder(int order) &#123; this.order = order; &#125; @Override public int getOrder() &#123; return this.order; &#125; /** * 先判断是否是HandlerMethod，然后转向抽象方法supportsInternal * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. * @param handler the handler instance to check * @return whether or not this adapter can adapt the given handler */ @Override public final boolean supports(Object handler) &#123; return (handler instanceof HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler)); &#125; /** * Given a handler method, return whether or not this adapter can support it. * @param handlerMethod the handler method to check * @return whether or not this adapter can adapt the given method */ protected abstract boolean supportsInternal(HandlerMethod handlerMethod); /** * 转向抽象方法 handleInternal() * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. */ @Override public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return handleInternal(request, response, (HandlerMethod) handler); &#125; /** * Use the given handler method to handle the request. * @param request current HTTP request * @param response current HTTP response * @param handlerMethod handler method to use. This object must have previously been passed to the * &#123;@link #supportsInternal(HandlerMethod)&#125; this interface, which must have returned &#123;@code true&#125;. * @return ModelAndView object with the name of the view and the required model data, * or &#123;@code null&#125; if the request has been handled directly * @throws Exception in case of errors */ protected abstract ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception; /** * 转向抽象方法 getLastModifiedInternal() * This implementation expects the handler to be an &#123;@link HandlerMethod&#125;. */ @Override public final long getLastModified(HttpServletRequest request, Object handler) &#123; return getLastModifiedInternal(request, (HandlerMethod) handler); &#125; /** * Same contract as for &#123;@link javax.servlet.http.HttpServlet#getLastModified(HttpServletRequest)&#125;. * @param request current HTTP request * @param handlerMethod handler method to use * @return the lastModified value for the given handler */ protected abstract long getLastModifiedInternal(HttpServletRequest request, HandlerMethod handlerMethod);&#125; 2.1.2 各个 HandlerAdapter作用AnnotationMethodHandlerAdapterAnnotationMethodHandlerAdapter主要是适配注解类处理器，注解类处理器就是我们经常使用的@Controller的这类处理器，不过该类已经被@Deprecated 标记了（@deprecated as of Spring 3.2, in favor of`） HttpRequestHandlerAdapterHttpRequestHandlerAdapter 主要是适配静态资源处理器，静态资源处理器就是实现了HttpRequestHandler接口的处理器，这类处理器的作用是处理通过SpringMVC来访问的静态资源的请求。 SimpleControllerHandlerAdapterSimpleControllerHandlerAdapter 是Controller处理适配器，适配实现了Controller接口或Controller接口子类的处理器，比如我们经常自己写的Controller来继承MultiActionController SimpleServletHandlerAdapterSimpleServletHandlerAdapter是Servlet处理适配器,适配实现了Servlet接口或Servlet的子类的处理器，我们不仅可以在web.xml里面配置Servlet，其实也可以用SpringMVC来配置Servlet，不过这个适配器很少用到，而且SpringMVC默认的适配器没有他，默认的是前面的三种。 2.1.3 HandlerAdapter 注册过程 HandlerAdapter 注册过程 和 HandlerMapping 的注册过程是一样的，回到DispatcherServlet 类中onRefresh 方法 1234567891011121314151617181920/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 进入initHandlerAdapters(context); 从下面代码也可以看到也是通过扫描HandlerAdapter类 bean的形式来注册HandlerAdapter 1234567891011121314151617181920212223242526272829303132333435363738/** * Initialize the HandlerAdapters used by this class. * &lt;p&gt;If no HandlerAdapter beans are defined in the BeanFactory for this namespace, * we default to SimpleControllerHandlerAdapter. */private void initHandlerAdapters(ApplicationContext context) &#123; this.handlerAdapters = null; if (this.detectAllHandlerAdapters) &#123; // 加载所有实现了HandlerAdapter接口的bean // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts. Map&lt;String, HandlerAdapter&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerAdapters = new ArrayList&lt;HandlerAdapter&gt;(matchingBeans.values()); // We keep HandlerAdapters in sorted order. AnnotationAwareOrderComparator.sort(this.handlerAdapters); &#125; &#125; else &#123; try &#123; HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class); this.handlerAdapters = Collections.singletonList(ha); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we'll add a default HandlerAdapter later. &#125; &#125; // Ensure we have at least some HandlerAdapters, by registering // default HandlerAdapters if no other adapters are found. if (this.handlerAdapters == null) &#123; this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class); if (logger.isDebugEnabled()) &#123; logger.debug(\"No HandlerAdapters found in servlet '\" + getServletName() + \"': using default\"); &#125; &#125;&#125; 3.1 总结 HanlderAdapter 从字面上的意思就是处理适配器，他的作用就是根据用户的请求调用具体的方法，根据HandlerMapping传过来Hanler与注册好的HandlerAdapter一一匹配，如果找到了其中一种HandlerAdapter是支持传过来的controller类型，那么该HandlerAdapter会调用自己的handle方法 不同的HanlderAdapter可以适应不同的request需求 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.jianshu.com/p/3d6df6b725e4 https://blog.csdn.net/weixin_38399962/article/details/85288660","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程","date":"2019-02-27T13:59:44.000Z","updated":"2019-03-03T02:27:39.710Z","comments":true,"path":"2019/02/27/backend/spring/sourceCodeAnalysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程/","link":"","permalink":"http://www.songshuiyang.site/2019/02/27/backend/spring/sourceCodeAnalysis/Spring Mvc源码(六)基于注解实现的RequestMappingHandlerMapping工作流程/","excerpt":"","text":"1.1 前言 上一章节介绍了 RequestMappingHandlerMapping 这个 HandlerMapping 的加载过程，这一章节来介绍RequestMappingHandlerMapping实现流程 2.1 找到与请求对应的 Handler 解析 还是回到这个方法doDispatch(HttpServletRequest request, HttpServletResponse response) ，下面的代码是发挥RequestMappingHandlerMapping作用的地方 12345678910HandlerExecutionChain mappedHandler = null;...// Determine handler for the current request.// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中mappedHandler = getHandler(processedRequest);if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return;&#125; 还是进入 getHandler方法，这里会遍历到我们的RequestMappingHandlerMapping 这个HandlerMapping，通过HandlerExecutionChain handler = hm.getHandler(request); 得到HandlerExecutionChain 12345678910111213141516protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; // 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; // 注意这里是找到第一个就直接返回 return handler; &#125; &#125; return null;&#125; 进入hm.getHandler(request); 会跳到我们的AbstractHandlerMapping 类中，RequestMappingHandlerMapping 继承该类，由下面代码可以看到这里这里获取了 handler 及 Interceptor 并封装为HandlerExecutionChain 返回调用者 1234567891011121314151617181920212223242526272829303132/** * Look up a handler for the given request, falling back to the default * handler if no specific one is found. * @param request current HTTP request * @return the corresponding handler instance, or the default handler * @see #getHandlerInternal */@Overridepublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 在这里获取 处理器handler，模板方法实现， RequestMappingHandlerMapping 跳到 AbstractHandlerMethodMapping Object handler = getHandlerInternal(request); if (handler == null) &#123; handler = getDefaultHandler(); &#125; if (handler == null) &#123; return null; &#125; // Bean name or resolved handler? if (handler instanceof String) &#123; String handlerName = (String) handler; handler = getApplicationContext().getBean(handlerName); &#125; // 获取 拦截器Interceptor HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); if (CorsUtils.isCorsRequest(request)) &#123; CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request); CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig); executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain;&#125; 关注Object handler = getHandlerInternal(request); 这里是获取handler的地方，这时又会跳到AbstractHandlerMethodMapping 类中，这样跳来跳去可以看到封装的特性及使用模板方法提高了扩展性 1234567891011121314151617181920212223242526272829/** * Look up a handler method for the given request. */@Overrideprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception &#123; // 获取请求url路径 localhost:8080/pub/account/list &gt;&gt;&gt; /pub/account/list String lookupPath = getUrlPathHelper().getLookupPathForRequest(request); if (logger.isDebugEnabled()) &#123; logger.debug(\"Looking up handler method for path \" + lookupPath); &#125; // mappingRegistry添加读锁，其他线程只能读不能写 this.mappingRegistry.acquireReadLock(); try &#123; // 根据request获取对应的HandlerMethod HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); if (logger.isDebugEnabled()) &#123; if (handlerMethod != null) &#123; logger.debug(\"Returning handler method [\" + handlerMethod + \"]\"); &#125; else &#123; logger.debug(\"Did not find handler method for [\" + lookupPath + \"]\"); &#125; &#125; return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null); &#125; finally &#123; this.mappingRegistry.releaseReadLock(); &#125;&#125; 关注 HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request); 这行代码，进入该方法，可以看到这个方法的作用是得到HandlerMethod 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 查找当前request请求 最为匹配的处理方法HandlerMethod，如果有多个匹配结果，则选择最佳匹配结果 * Look up the best-matching handler method for the current request. * If multiple matches are found, the best match is selected. * @param lookupPath mapping lookup path within the current servlet mapping * @param request the current request * @return the best-matching handler method, or &#123;@code null&#125; if no match * @see #handleMatch(Object, String, HttpServletRequest) * @see #handleNoMatch(Set, String, HttpServletRequest) */protected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception &#123; List&lt;Match&gt; matches = new ArrayList&lt;Match&gt;(); // 根据URL来获取,springMVC会在初始化的时候建立URL和相应RequestMappingInfo的映射。如果不是restful接口，这里就可以直接获取到了， lookupPath: /pub/account/list List&lt;T&gt; directPathMatches = this.mappingRegistry.getMappingsByUrl(lookupPath); if (directPathMatches != null) &#123; // 匹配校验 addMatchingMappings(directPathMatches, matches, request); &#125; if (matches.isEmpty()) &#123; // 全盘扫描 // No choice but to go through all mappings... addMatchingMappings(this.mappingRegistry.getMappings().keySet(), matches, request); &#125; // 得到匹配结果 if (!matches.isEmpty()) &#123; Comparator&lt;Match&gt; comparator = new MatchComparator(getMappingComparator(request)); Collections.sort(matches, comparator); if (logger.isTraceEnabled()) &#123; logger.trace(\"Found \" + matches.size() + \" matching mapping(s) for [\" + lookupPath + \"] : \" + matches); &#125; Match bestMatch = matches.get(0); if (matches.size() &gt; 1) &#123; if (CorsUtils.isPreFlightRequest(request)) &#123; return PREFLIGHT_AMBIGUOUS_MATCH; &#125; Match secondBestMatch = matches.get(1); // 如果最佳匹配 第二佳匹配都是同一个则报错 if (comparator.compare(bestMatch, secondBestMatch) == 0) &#123; Method m1 = bestMatch.handlerMethod.getMethod(); Method m2 = secondBestMatch.handlerMethod.getMethod(); throw new IllegalStateException(\"Ambiguous handler methods mapped for HTTP path '\" + request.getRequestURL() + \"': &#123;\" + m1 + \", \" + m2 + \"&#125;\"); &#125; &#125; // 设置HttpServletRequest值 handleMatch(bestMatch.mapping, lookupPath, request); return bestMatch.handlerMethod; &#125; else &#123; // 没有找到匹配，返回null return handleNoMatch(this.mappingRegistry.getMappings().keySet(), lookupPath, request); &#125;&#125; 查看这行代码可以看到是通过url来获取this.mappingRegistry.getMappingsByUrl(lookupPath);，进入该方法，可以看到this.urlLookup是MappingRegistry类中的一个Map,直接通过 url为key得到值 123456789101112131415161718192021222324class MappingRegistry &#123; private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = new HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;(); private final Map&lt;T, HandlerMethod&gt; mappingLookup = new LinkedHashMap&lt;T, HandlerMethod&gt;(); private final MultiValueMap&lt;String, T&gt; urlLookup = new LinkedMultiValueMap&lt;String, T&gt;(); private final Map&lt;String, List&lt;HandlerMethod&gt;&gt; nameLookup = new ConcurrentHashMap&lt;String, List&lt;HandlerMethod&gt;&gt;(); private final Map&lt;HandlerMethod, CorsConfiguration&gt; corsLookup = new ConcurrentHashMap&lt;HandlerMethod, CorsConfiguration&gt;(); private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock(); ... */ public List&lt;T&gt; getMappingsByUrl(String urlPath) &#123; // MultiValueMap&lt;String, T&gt; urlLookup 就是个map return this.urlLookup.get(urlPath); &#125; 下图是this.urlLookup.get(urlPath) 的到的结果，返回的是个list image 返回到lookupHandlerMethod(String lookupPath, HttpServletRequest request) 方法，这里使用了Match做了匹配处理，得到最佳Match bestMatch 对象，最后返回HandlerMethod，在此终于得到了HandlerMethod 3.1 总结 RequestMappingHandlerMapping 的主要功能就是通过 reqeust 获取 HandlerExecutionChain 的 HandlerMethod、Interceptor。 下图是RequestMappingHandlerMapping工作流程图，可以看到RequestMappingHandlerMapping 一个类的实现分了4层，HandlerMapping 接口定义顶级方法，两个抽象类又分两次封装，由上而下，逐渐细分功能 image 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程","date":"2019-02-26T12:59:44.000Z","updated":"2019-02-26T12:19:01.597Z","comments":true,"path":"2019/02/26/backend/spring/sourceCodeAnalysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程/","link":"","permalink":"http://www.songshuiyang.site/2019/02/26/backend/spring/sourceCodeAnalysis/Spring Mvc源码(五)基于注解实现的RequestMappingHandlerMapping加载过程/","excerpt":"","text":"1.1 前言 上一章节介绍了请求映射处理组件HandlerMapping的主体处理流程，根据request url 获取对应的处理器Handler，这一章节来详细介绍我们平常最多使用的RequestMappingHandlerMapping的加载，这个HandlerMapping 是怎样加载基于@Controller,@RequestMapping 实现的Controller 2.1 解析 接下来我们关注RequestMappingHandlerMapping这个HandlerMapping，因为这个是我们开发过程中最为常用的HandlerMapping，那么它是怎样实现HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; 这个方法，先看一下RequestMappingHandlerMapping的继承关系 image 2.1.1 RequestMappingHandlerMapping 加载过程 有上图可以看到RequestMappingHandlerMapping 的父类AbstractHandlerMethodMapping 实现了InitializingBean 接口，InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类， 在初始化bean的时候都会执行该方法。 1234567891011121314public interface InitializingBean &#123; /** * Invoked by a BeanFactory after it has set all bean properties supplied * (and satisfied BeanFactoryAware and ApplicationContextAware). * &lt;p&gt;This method allows the bean instance to perform initialization only * possible when all bean properties have been set and to throw an * exception in the event of misconfiguration. * @throws Exception in the event of misconfiguration (such * as failure to set an essential property) or if initialization fails. */ void afterPropertiesSet() throws Exception;&#125; 查看AbstractHandlerMethodMapping类 afterPropertiesSet()的实现 1234567/** * Detects handler methods at initialization. */@Overridepublic void afterPropertiesSet() &#123; initHandlerMethods();&#125; 又抽象了一个方法，通过方法名可以得到是初始化HandlerMethods，进入initHandlerMethods(); 方法，这个方法是扫描ApplicationContext 所有的bean，如果发现了该bean是Handler，并把它注册为handler methods 1234567891011121314151617181920212223242526272829303132333435363738/** * Scan beans in the ApplicationContext, detect and register handler methods. * @see #isHandler(Class) * @see #getMappingForMethod(Method, Class) * @see #handlerMethodsInitialized(Map) */protected void initHandlerMethods() &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Looking for request mappings in application context: \" + getApplicationContext()); &#125; // 首先拿到容器的所有的beanName数组 String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) : getApplicationContext().getBeanNamesForType(Object.class)); for (String beanName : beanNames) &#123; if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123; // 得到bean类型 Class&lt;?&gt; beanType = null; try &#123; beanType = getApplicationContext().getType(beanName); &#125; catch (Throwable ex) &#123; // An unresolvable bean type, probably from a lazy bean - let's ignore it. if (logger.isDebugEnabled()) &#123; logger.debug(\"Could not resolve target class for bean with name '\" + beanName + \"'\", ex); &#125; &#125; // 检查bean所在的类是否有Controller注解及RequestMapping注解 if (beanType != null &amp;&amp; isHandler(beanType)) &#123; // 负责将Handler保存到Map里 detectHandlerMethods(beanName); &#125; &#125; &#125; // 对Handler进行一些初始化，是一个模板方法 handlerMethodsInitialized(getHandlerMethods());&#125; String[] beanNames 示例 iamge 进入isHandler(beanType)方法，，此方法由RequestMappingHandlerMapping实现， 此方法检查bean所在的类是否有Controller注解及RequestMapping注解，可以看到此方法的实现是在RequestMappingHandlerMapping里，是不是看到了我们熟悉的两个注解 12345678910/** * 检查bean所在的类是否有Controller注解及RequestMapping注解 * &#123;@inheritDoc&#125; * Expects a handler to have a type-level @&#123;@link Controller&#125; annotation. */@Overrideprotected boolean isHandler(Class&lt;?&gt; beanType) &#123; return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) || AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));&#125; 如果该bean有 Controller注解及RequestMapping注解，则执行detectHandlerMethods(beanName);方法，下面举个例子，我们有一个UserController里面有五个方法，下面来看是怎么处理这个类的 12345678910111213141516171819202122232425262728293031323334@RestController@RequestMapping(\"/pub/account\")public class UserController &#123; @Autowired private UserService userService; @GetMapping(\"/list\") public List&lt;User&gt; findAll() &#123; return userService.findAll(); &#125; @GetMapping(\"/view\") public User view() &#123; return userService.findById(1); &#125; @GetMapping(\"/&#123;id&#125;\") public User view(@PathVariable(\"id\") Integer id) &#123; return userService.findById(id); &#125; @PostMapping(\"/\") public void updateUser(@RequestBody User user) &#123; User user1 = userService.findById(user.getId()); user1.setUsername(\"update\"); userService.saveSelective(user1); &#125; @DeleteMapping(\"/&#123;id&#125;\") public void deleteUser(@PathVariable(\"id\") Integer id) &#123; userService.logicDeleteOne(id); &#125;&#125; 进入detectHandlerMethods(beanName);方法，可以看到Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods 获取到了我们五个方法，Map&lt;Method, T&gt; methods 以Method为key，RequestMappingInfo为value image 1234567891011121314151617181920212223242526272829303132333435/** * Look for handler methods in a handler. * @param handler the bean name of a handler or a handler instance */protected void detectHandlerMethods(final Object handler) &#123; // 获取Handler的类型 Class&lt;?&gt; handlerType = (handler instanceof String ? getApplicationContext().getType((String) handler) : handler.getClass()); final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType); // 这里获取 RequestMapping方法，会过滤掉普通方法 Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, new MethodIntrospector.MetadataLookup&lt;T&gt;() &#123; @Override public T inspect(Method method) &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Invalid mapping on handler class [\" + userType.getName() + \"]: \" + method, ex); &#125; &#125; &#125;); if (logger.isDebugEnabled()) &#123; logger.debug(methods.size() + \" request handler methods found on \" + userType + \": \" + methods); &#125; for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123; Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType); T mapping = entry.getValue(); // 注册 mappingRegistry registerHandlerMethod(handler, invocableMethod, mapping); &#125;&#125; 进入getMappingForMethod(method, userType) ，此方法在RequestMappingHandlerMapping实现，这里解析分两步解析，一个是方法method解析，另一个是方法所在类handlerType的解析，然后拼接成一个RequestMappingInfo，可以看到也是对RequestMapping注解的解析 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 没有使用 &#123;@code @RequestMapping&#125; 注解会返回null * Uses method and type-level @&#123;@link RequestMapping&#125; annotations to create * the RequestMappingInfo. * @return the created RequestMappingInfo, or &#123;@code null&#125; if the method * does not have a &#123;@code @RequestMapping&#125; annotation. * @see #getCustomMethodCondition(Method) * @see #getCustomTypeCondition(Class) */@Overrideprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) &#123; // 解析method的@RequestMapping RequestMappingInfo info = createRequestMappingInfo(method); if (info != null) &#123; // 解析Class的@RequestMapping RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType); if (typeInfo != null) &#123; // 合并两个RequestMappingInfo 比如url拼接 info = typeInfo.combine(info); &#125; &#125; // 不是RequestMapping方法返回null return info;&#125;private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) &#123; // 拿到注解 RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class); RequestCondition&lt;?&gt; condition = (element instanceof Class ? getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element)); return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);&#125;protected RequestMappingInfo createRequestMappingInfo( RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition) &#123; // 用@RequestMapping的属性生成RequestMappingInfo return RequestMappingInfo .paths(resolveEmbeddedValuesInPatterns(requestMapping.path())) .methods(requestMapping.method()) .params(requestMapping.params()) .headers(requestMapping.headers()) .consumes(requestMapping.consumes()) .produces(requestMapping.produces()) .mappingName(requestMapping.name()) .customCondition(customCondition) .options(this.config) .build();&#125; RequestMappingInfo.java 对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。 12345678910111213141516171819public final class RequestMappingInfo implements RequestCondition&lt;RequestMappingInfo&gt; &#123; private final String name; private final PatternsRequestCondition patternsCondition; private final RequestMethodsRequestCondition methodsCondition; private final ParamsRequestCondition paramsCondition; private final HeadersRequestCondition headersCondition; private final ConsumesRequestCondition consumesCondition; private final ProducesRequestCondition producesCondition; private final RequestConditionHolder customConditionHolder; ... 返回到detectHandlerMethods方法 123456789101112131415161718192021222324252627282930protected void detectHandlerMethods(final Object handler) &#123; // 获取Handler的类型 Class&lt;?&gt; handlerType = (handler instanceof String ? getApplicationContext().getType((String) handler) : handler.getClass()); final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType); // 这里获取 RequestMapping方法，会过滤掉普通方法 Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, new MethodIntrospector.MetadataLookup&lt;T&gt;() &#123; @Override public T inspect(Method method) &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(\"Invalid mapping on handler class [\" + userType.getName() + \"]: \" + method, ex); &#125; &#125; &#125;); if (logger.isDebugEnabled()) &#123; logger.debug(methods.size() + \" request handler methods found on \" + userType + \": \" + methods); &#125; for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123; Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType); T mapping = entry.getValue(); // 注册 mappingRegistry registerHandlerMethod(handler, invocableMethod, mapping); &#125;&#125; 得到Map&lt;Method, T&gt; methods方法之后，就是把这些信息保存起来，registerHandlerMethod(handler, invocableMethod, mapping); 这行代码就是做的这个功能 123456789101112131415161718192021222324252627282930313233343536373839404142protected void registerHandlerMethod(Object handler, Method method, T mapping) &#123; this.mappingRegistry.register(mapping, handler, method);&#125; public void register(T mapping, Object handler, Method method) &#123; // 加锁 this.readWriteLock.writeLock().lock(); try &#123; // 创建HandlerMethod HandlerMethod handlerMethod = createHandlerMethod(handler, method); assertUniqueMethodMapping(handlerMethod, mapping); if (logger.isInfoEnabled()) &#123; logger.info(\"Mapped \\\"\" + mapping + \"\\\" onto \" + handlerMethod); &#125; this.mappingLookup.put(mapping, handlerMethod); List&lt;String&gt; directUrls = getDirectUrls(mapping); for (String url : directUrls) &#123; this.urlLookup.add(url, mapping); &#125; String name = null; if (getNamingStrategy() != null) &#123; name = getNamingStrategy().getName(handlerMethod, mapping); addMappingName(name, handlerMethod); &#125; CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping); if (corsConfig != null) &#123; this.corsLookup.put(handlerMethod, corsConfig); &#125; /** * private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry = new HashMap&lt;T, MappingRegistration&lt;T&gt;&gt;(); * key: RequestMappingInfo */ this.registry.put(mapping, new MappingRegistration&lt;T&gt;(mapping, handlerMethod, directUrls, name)); &#125; finally &#123; this.readWriteLock.writeLock().unlock(); &#125;&#125; 查看private final Map&lt;T, MappingRegistration&lt;T&gt;&gt; registry 对象，见下图key值是RequestMappingInfo value是MappingRegistration image MappingRegistration.java 1234567891011private static class MappingRegistration&lt;T&gt; &#123; private final T mapping; private final HandlerMethod handlerMethod; private final List&lt;String&gt; directUrls; private final String mappingName; ... 3.1 总结 Spring Mvc提供了各种各样的抽象，你能感受到面向对象的魅力。 RequestMappingInfo 这个类是对请求映射的一个抽象，它包含了请求路径，请求方法，请求头等信息。其实可以看做是@RequestMapping的一个对应类。 HandlerMethod这个类封装了处理器实例（Controller Bean）和 处理方法实例（Method）以及方法参数数组（MethodParameter[]） MethodParameter 这个类从2.0就有了，它封装了方法某个参数的相关信息及行为，如该参数的索引，该参数所属方法实例或构造器实例，该参数的类型等。 HandlerMapping 该接口的实现类用来定义请求和处理器之前的映射关系，其中只定义了一个方法getHandler。 AbstractHandlerMethodMapping 这是HandlerMapping的一个基本实现类，该类定义了请求与HandlerMethod实例的映射关系。 RequestMappingInfoHandlerMapping这个是AbstractHandlerMethodMapping的实现类，他维护了一个RequestMappingInfo和HandlerMethod的Map属性。 RequestMappingHandlerMapping 这个是RequestMappingInfoHandlerMapping的子类，它将@RequestMapping注解转化为RequestMappingInfo实例，并为父类使用。也就是我们处理@RequestMapping的终点。 InitializingBean 这个接口定义了其实现Bean在容器完成属性设置后可以执行自定义初始化操作，我们的AbstractHandlerMethodMapping便实现了这个接口，并且定义了一组自定义操作，就是用来检测处理我们的@RequestMapping注解。 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.cnblogs.com/taotingkai/p/8438360.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(四)请求映射处理组件HandlerMapping","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping","date":"2019-02-25T12:59:44.000Z","updated":"2019-03-03T02:27:39.715Z","comments":true,"path":"2019/02/25/backend/spring/sourceCodeAnalysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping/","link":"","permalink":"http://www.songshuiyang.site/2019/02/25/backend/spring/sourceCodeAnalysis/Spring Mvc源码(四)请求映射处理组件HandlerMapping/","excerpt":"","text":"1.1 前言 上一章节介绍了Spring Mvc执行一个普通请求的整体流程，这一章节介绍其请求映射处理组件HandlerMapping 的作用 HandlerMapping负责根据request请求找到对应的Handler处理器及Interceptor拦截器,并将它们封装在HandlerExecutionChain对象内，返回给中央调度器 2.1 请求映射处理组件HandlerMapping 解析2.1.1 HandlerMapping 解析 先来回顾核心方法体doDispatch(HttpServletRequest request, HttpServletResponse response)，查看HandlerMapping 对应的处理逻辑 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否有 Multipart，有则将请求转换为 Multipart 请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中 mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理 last-modified 请求头 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 执行实际的处理程序 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 遍历拦截器，执行它们的 postHandle() 方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion // 遍历拦截器，执行它们的 afterCompletion() 方法 if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 下面是请求映射处理组件HandlerMapping 主要的处理代码 12345678910HandlerExecutionChain mappedHandler = null;...// Determine handler for the current request.// 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中mappedHandler = getHandler(processedRequest);if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return;&#125; 继续在doDispatch方法中mappedHandler = getHandler(processedRequest); 这行代码打好断点，进入该方法 12345678910111213141516171819202122/** * Return the HandlerExecutionChain for this request. * &lt;p&gt;Tries all handler mappings in order. * @param request current HTTP request * @return the HandlerExecutionChain, or &#123;@code null&#125; if no handler could be found */protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; // 循环handlerMappings eg: RequestMappingHandlerMapping、SimpleUrlHandlerMapping、BeanNameUrlHandlerMapping for (HandlerMapping hm : this.handlerMappings) &#123; if (logger.isTraceEnabled()) &#123; logger.trace( \"Testing handler map [\" + hm + \"] in DispatcherServlet with name '\" + getServletName() + \"'\"); &#125; // 遍历HandlerMapping实现类的找到对应的 HandlerExecutionChain HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; // 注意这里是找到第一个就直接返回 return handler; &#125; &#125; return null;&#125; this.handlerMappings 12/** List of HandlerMappings used by this servlet */private List&lt;HandlerMapping&gt; handlerMappings; 可以看到是遍历了this.handlerMappings这个对象，这个对象是个list，HandlerMapping的初始化处理在第二章有其介绍， 在调试过程中，我们可以看到，默认加载的是如下图所示的的HandlerMapping， 下面来介绍这三种常用的HandlerMapping的作用 RequestMappingHandlerMapping是三个中最常用的handlerMapping，使用注解方式最为方便快捷，SpringMvc项目开发都是采用这种形式，配合@RequestMapping()相关注释就可以完成开发 12345678910111213141516171819&lt;!-- 注册HandlerMapper、HandlerAdapter两个映射类 --&gt;&lt;mvc:annotation-driven /&gt; &lt;!-- 访问静态资源 --&gt;&lt;mvc:default-servlet-handler /&gt; &lt;!-- 配置扫描的包 --&gt;&lt;context:component-scan base-package=\"com.songsy.*\" /&gt; @RestController@RequestMapping(\"/hello\")public class HelloController &#123; protected final Log logger = LogFactory.getLog(this.getClass()); @RequestMapping(\"/index\") public String index()&#123; return \"test\"; &#125;&#125; SimpleUrlHandlerMapping SimpleUrlHandlerMapping的Controller处理类需要实现Controller接口，并注册成Bean就可以完成配置，处理逻辑写在handleRequest方法体内 12345678910111213141516171819&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;prop key=\"/simpleUrlHandlerMapping.do\"&gt;welcomeController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;/** * @author Rob Harrop */public class WelcomeController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) &#123; return new ModelAndView(\"welcomeView\"); &#125;&#125; BeanNameUrlHandlerMapping需要配置 &lt;bean id=&quot;/index&quot; class=&quot;com.alipay.web.TestController&quot; /&gt;，注意在bean的id中要加上斜杆，Controller方面的测试代码跟前面的SimpleUrlHandlerMapping一样，实现Controller，重写handlerRequest()方法即可。 2.1.2 HandlerMapping 注册过程 回到DispatcherServlet 类中onRefresh 方法 1234567891011121314151617181920/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 进入initHandlerMappings(context);方法，这里实现了HandlerMappings的注册过程， BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); 可以看到用了Spring的工具类 beansOfTypeIncludingAncestors 返回给定类型或子类型的所有bean 1234567891011121314151617181920212223242526272829303132333435363738/** * Initialize the HandlerMappings used by this class. * &lt;p&gt;If no HandlerMapping beans are defined in the BeanFactory for this namespace, * we default to BeanNameUrlHandlerMapping. */private void initHandlerMappings(ApplicationContext context) &#123; this.handlerMappings = null; if (this.detectAllHandlerMappings) &#123; // Find all HandlerMappings in the ApplicationContext, including ancestor contexts. // 在ApplicationContext bean中找到所有HandlerMappings Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values()); // We keep HandlerMappings in sorted order. AnnotationAwareOrderComparator.sort(this.handlerMappings); &#125; &#125; else &#123; try &#123; HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); this.handlerMappings = Collections.singletonList(hm); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we'll add a default HandlerMapping later. &#125; &#125; // Ensure we have at least one HandlerMapping, by registering // a default HandlerMapping if no other mappings are found. if (this.handlerMappings == null) &#123; this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); if (logger.isDebugEnabled()) &#123; logger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\"); &#125; &#125;&#125; 下一章节来跟进RequestMappingHandlerMapping这个HandlerMapping 的具体实现 3.1 总结 HandlerMapping我们知道他的作用是根据request找到对应的Handler，Handler具体表现形式可以为类，也可以为方法，上面的三种常用的HandlerMapping有其介绍，我们平常使用@RequestMapping注解来标识一个方法，这个注解的作用就是将这个方法注册为Handler 为什么需要要多种HandlerMapping呢，当然是为了其可扩展性，实现HandlerMapping接口就可以实现自定义Handler的获取，从而实现定制化 Spring Mvc 大量使用了模版方法模式，父类定义流程，子类实现，而这些口子都是所谓的模板方法，可以自由指定，从而保证了灵活性，良好的抽象设计，是整个框架变得非常灵活 Spring Mvc 核心类中所有的变量声明，几乎都以接口的形式给出，并没有绑定在具体的实现类上 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.jianshu.com/p/e4f1c9326223 https://blog.csdn.net/gaoshan12345678910/article/details/81778587 https://blog.csdn.net/lang_programmer/article/details/71598042","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(三)核心分发器DispatcherServlet处理流程","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程","date":"2019-01-28T12:59:44.000Z","updated":"2019-03-03T02:27:39.701Z","comments":true,"path":"2019/01/28/backend/spring/sourceCodeAnalysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程/","link":"","permalink":"http://www.songshuiyang.site/2019/01/28/backend/spring/sourceCodeAnalysis/Spring Mvc源码(三)核心分发器DispatcherServlet处理流程/","excerpt":"","text":"1.1 前言上一章节介绍了DispatcherServlet的初始化过程，这一章节介绍核心分发器DispatcherServlet是怎样处理请求的 2.1 DispatcherServlet 处理请求过程 既然DispatcherServlet本身是Servlet，我们就要专注于它的service、doGet、doPost等相关方法，在FrameworkServlet里可以看到service、doGet、doPost这些方法的重载实现，可以看到都是流转到processRequest(request, response);这个方法中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Override the parent class implementation in order to intercept PATCH requests. */@Overrideprotected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123; processRequest(request, response); &#125; else &#123; super.service(request, response); &#125;&#125;/** * Delegate GET requests to processRequest/doService. * &lt;p&gt;Will also be invoked by HttpServlet's default implementation of &#123;@code doHead&#125;, * with a &#123;@code NoBodyResponse&#125; that just captures the content length. * @see #doService * @see #doHead */@Overrideprotected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125;/** * Delegate POST requests to &#123;@link #processRequest&#125;. * @see #doService */@Overrideprotected final void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125;/** * Delegate PUT requests to &#123;@link #processRequest&#125;. * @see #doService */@Overrideprotected final void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125;/** * Delegate DELETE requests to &#123;@link #processRequest&#125;. * @see #doService */@Overrideprotected final void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; processRequest(request, response);&#125; 根据service方法，我们一步步找到一个方法链service –&gt; processRequest –&gt; doService –&gt; doDispatch，我们最终将目光定位在doDispatch，因为从它的方法体就可以看出它是整个SpringMVC的核心方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Process the actual dispatching to the handler. * &lt;p&gt;The handler will be obtained by applying the servlet's HandlerMappings in order. * The HandlerAdapter will be obtained by querying the servlet's installed HandlerAdapters * to find the first that supports the handler class. * &lt;p&gt;All HTTP methods are handled by this method. It's up to HandlerAdapters or handlers * themselves to decide which methods are acceptable. * @param request current HTTP request * @param response current HTTP response * @throws Exception in case of any kind of processing failure */protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 获取当前请求的WebAsyncManager，如果没找到则创建并与请求关联 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否有 Multipart，有则将请求转换为 Multipart 请求 processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecution 对象中 mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // 处理 last-modified 请求头 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 执行实际的处理程序 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 遍历拦截器，执行它们的 postHandle() 方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; // 处理执行结果，是一个 ModelAndView 或 Exception，然后进行渲染 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion // 遍历拦截器，执行它们的 afterCompletion() 方法 if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; 说它是核心一点也不为过，从上述代码的中文注释可以看出，它包含了解析请求，执行相关拦截器，执行handle方法，这行代码是真正执行我们controller的方法mv = ha.handle(processedRequest, response, mappedHandler.getHandler());，那SpringMvc是怎样找到我们的方法的呢，下一章节将介绍 3.1 总结 Spring Mvc 的处理方式是先在顶层设计好整体结构，然后将具体的处理交给不同的组件具体去实现 DispatcherServlet中的doDispatch方法完成了具体的请求处理，下面是主要流程 遍历所有的 HandlerMapping 找到与请求对应的 Handler，并将其与一堆拦截器封装到 HandlerExecutionChain 对象中 遍历所有的 HandlerAdapter，找到可以处理该 Handler 的 HandlerAdapter 执行相应拦截器Interceptor的preHandle方法 HandlerAdapter 执行Hander，由Hander 执行实际的处理程序，执行Controller里的方法 调用processDispatchResult处理结果 执行相应拦截器Interceptor的postHandle方法 下面是流程图 下面的章节将详细介绍这些流程 1、请求映射处理组件HandlerMapping处理 2、HandlerAdapter处理 3、Interceptor的preHandle方法处理 4、Hander 执行实际的处理程序，执行Controller里的方法 5、调用processDispatchResult处理结果 6、Interceptor的postHandle`方法处理4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html https://blog.csdn.net/lang_programmer/article/details/71598042","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(二)核心分发器DispatcherServlet初始化","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化","date":"2019-01-23T12:59:44.000Z","updated":"2019-03-10T01:44:49.407Z","comments":true,"path":"2019/01/23/backend/spring/sourceCodeAnalysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化/","link":"","permalink":"http://www.songshuiyang.site/2019/01/23/backend/spring/sourceCodeAnalysis/Spring Mvc源码(二)核心分发器DispatcherServlet初始化/","excerpt":"","text":"1.1 前言我们都知道DispatcherServlet是所谓前端控制器，是整个Spring Mvc的入口，但是这个前端控制器里面又有很多箱子，每一个箱子都有其独有的功能，当我们翻开一个箱子之后看看里面有什么的时候，又会发现箱子里面装着又一个箱子，所以我们需要一个个的探究这些箱子。 2.1 DispatcherServlet 初始化过程2.1.1 配置 DispatcherServlet 首先，Tomcat每次启动时都会加载并解析/WEB-INF/web.xml文件，所以可以先从web.xml找突破口，主要代码如下 12345678910111213141516&lt;servlet &gt; &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt; &lt;!-- servlet类 --&gt; &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化参数 --&gt; &lt;init-param &gt; &lt;param-name &gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value &gt;classpath:/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动时加载 --&gt; &lt;load-on-startup &gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping &gt; &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt; &lt;url-pattern &gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 可以看到 DispatcherServlet 本身就是个Servlet，那么看看DispatcherServlet做了什么呢，我们先看下DispatcherServlet的继承关系，重点关注HttpServletBean 和FrameworkServlet 这两个类 12345GenericServlet (javax.servlet) HttpServlet (javax.servlet.http) HttpServletBean (org.springframework.web.servlet) FrameworkServlet (org.springframework.web.servlet) DispatcherServlet (org.springframework.web.servlet) 通过上图可以看到 DispatcherServlet 实现了Spring 的ApplicationContextAware、EnvironmentCapable、 EnvironmentAware这些Spring中的接口，XXXAware在Spring中表示对XXX可以感知，通俗点可以说在某个类中想使用Spring的一些东西，就可以实现XXXAware接口告诉Spring我要这个东西，比如ApplicationContextAware，该接口只有一个方法就是setApplicationContext(ApplicationContext applicationContext), 通过该方法可以得到ApplicationContext，Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。实现XXXCapable接口表示可以得到某种能力，实现EnvironmentCapable接口说明可以得到Environment的能力，也就是可以提供Environment1234567@Overridepublic void setApplicationContext(ApplicationContext applicationContext) &#123; if (this.webApplicationContext == null &amp;&amp; applicationContext instanceof WebApplicationContext) &#123; this.webApplicationContext = (WebApplicationContext) applicationContext; this.webApplicationContextInjected = true; &#125;&#125; 1234567@Override public ConfigurableEnvironment getEnvironment() &#123; if (this.environment == null) &#123; this.environment = createEnvironment(); &#125; return this.environment; &#125; HttpServletBean 覆写了GenericServlet 的init方法，此方法是第一次访问该DispatcherServlet的时候就会执行，对初始化过程做了一些处理，HttpServletBean 这个类的作用主要做一些初始化的工作，将web.xml中配置的参数设置到Servlet中。比如servlet标签的子标签init-param标签中配置的参数(classpath:/spring-mvc.xml)。 12345678910111213141516171819202122232425262728293031323334@Overridepublic final void init() throws ServletException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Initializing servlet '\" + getServletName() + \"'\"); &#125; // 构造过程中会使用ServletConfig对象找出web.xml配置文件中的配置参数并设置到ServletConfigPropertyValues内部 // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) &#123; try &#123; // 使用BeanWrapper构造DispatcherServlet BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); // 设置DispatcherServlet属性 bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; if (logger.isErrorEnabled()) &#123; logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); &#125; throw ex; &#125; &#125; // 让子类去做一些事情，这种在父类定义在子类实现的方式叫做模版方法模式 // Let subclasses do whatever initialization they like initServletBean(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\"); &#125;&#125; 关注initServletBean()方法，该方法的实现在FrameworkServlet 类里，这个类的作用是将Servlet与Spring容器上下文关联。其实也就是初始化FrameworkServlet的属性webApplicationContext 1234567891011121314151617181920212223242526272829303132/** * Overridden method of &#123;@link HttpServletBean&#125;, invoked after any bean properties * have been set. Creates this servlet's WebApplicationContext. */@Overrideprotected final void initServletBean() throws ServletException &#123; getServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\"); if (this.logger.isInfoEnabled()) &#123; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\"); &#125; long startTime = System.currentTimeMillis(); try &#123; // 初始化 WebApplicationContext (即SpringMVC的IOC容器) this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); &#125; catch (ServletException ex) &#123; this.logger.error(\"Context initialization failed\", ex); throw ex; &#125; catch (RuntimeException ex) &#123; this.logger.error(\"Context initialization failed\", ex); throw ex; &#125; if (this.logger.isInfoEnabled()) &#123; long elapsedTime = System.currentTimeMillis() - startTime; this.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" + elapsedTime + \" ms\"); &#125;&#125; 进入this.webApplicationContext = initWebApplicationContext();方法，这个方法的作用是先得到根上下文rootContext 然后创建webApplicationContext并设置根上下文（将 Spring 的容器设为 SpringMVC 容器的父容器），最后就是发布这个 WebApplicationContext 容器到 ServletContext 中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Initialize and publish the WebApplicationContext for this servlet. * &lt;p&gt;Delegates to &#123;@link #createWebApplicationContext&#125; for actual creation * of the context. Can be overridden in subclasses. * @return the WebApplicationContext instance * @see #FrameworkServlet(WebApplicationContext) * @see #setContextClass * @see #setContextConfigLocation */protected WebApplicationContext initWebApplicationContext() &#123; // 获取ContextLoaderListener 初始化并注册在 ServletContext 中的根容器，即 Spring 的容器 WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) &#123; // The context instance was injected without an explicit parent -&gt; set // the root application context (if any; may be null) as the parent // 将 Spring 的容器设为 SpringMVC 容器的父容器 cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id // 如果 WebApplicationContext 为空，则进行查找，能找到说明上下文已经在别处初始化。 wac = findWebApplicationContext(); &#125; if (wac == null) &#123; // No context instance is defined for this servlet -&gt; create a local one // 如果 WebApplicationContext 仍为空，则以 Spring 的容器为父上下文建立一个新的，并设置根上下文为父上下文 wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. // 模版方法，由 DispatcherServlet 实现 onRefresh(wac); &#125; if (this.publishContext) &#123; // Publish the context as a servlet context attribute. // 发布这个 WebApplicationContext 容器到 ServletContext 中 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() + \"' as ServletContext attribute with name [\" + attrName + \"]\"); &#125; &#125; return wac;&#125; 这里的根上下文是web.xml中配置的ContextLoaderListener监听器中根据contextConfigLocation路径生成的上下文。比如这段配置文件中根据classpath:springConfig/applicationContext.xml下的xml文件生成的根上下文。ContextLoaderListener 实现了ServletContextListener，当配置了listener之后启动web容器就会执行它实现的方法，使用ServletContextListener接口，开发者能够在客户端请求提供服务之前向ServletContext中添加任意的对象，ServletContext在web容器运行期间都是可见的 1234567&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springConfig/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; onRefresh(wac); 由 DispatcherServlet 实现，这里的操作就是Spring Mvc自身的初始化过程 1234567891011121314151617181920212223242526272829/** * This implementation calls &#123;@link #initStrategies&#125;. */@Overrideprotected void onRefresh(ApplicationContext context) &#123; // initStrategies方法内部会初始化各个策略接口的实现类。 initStrategies(context);&#125;/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 2.1.1 DispatcherServlet 默认加载bean DispatcherServlet 初始化的时候会默认加载一些组件，代码如下，可以看到是在static代码块中读取一个配置文件并把它注册为Properties defaultStrategies对象 1234567891011121314151617181920/** * Name of the class path resource (relative to the DispatcherServlet class) * that defines DispatcherServlet's default strategy names. */private static final String DEFAULT_STRATEGIES_PATH = \"DispatcherServlet.properties\";... static &#123; // Load default strategy implementations from properties file. // This is currently strictly internal and not meant to be customized // by application developers. try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage()); &#125; &#125; 查看DispatcherServlet.properties文件，该文件在Spring web mvc 包下 123456789101112131415161718192021222324# Default implementation classes for DispatcherServlet&apos;s strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\\ org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\ org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager 从如上配置可以看出DispatcherServlet 配置的是一些类的全限定名，那它是在哪里调用的呢，还是回到之前的onRefresh(wac); 的initStrategies(ApplicationContext context)方法 12345678910111213141516protected void initStrategies(ApplicationContext context) &#123; // 上传组件组件初始化 initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); // 请求映射处理组件初始化 initHandlerMappings(context); // 处理适配器组建初始化 initHandlerAdapters(context); // 异常处理组件初始化 initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图处理组件初始化 initViewResolvers(context); initFlashMapManager(context);&#125; 进入initHandlerMappings(context); 方法 12345678910111213141516171819202122232425262728293031323334private void initHandlerMappings(ApplicationContext context) &#123; this.handlerMappings = null; if (this.detectAllHandlerMappings) &#123; // Find all HandlerMappings in the ApplicationContext, including ancestor contexts. // 在ApplicationContext bean中找到所有HandlerMappings， beansOfTypeIncludingAncestors 返回给定类型或子类型的所有bean Map&lt;String, HandlerMapping&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false); if (!matchingBeans.isEmpty()) &#123; this.handlerMappings = new ArrayList&lt;HandlerMapping&gt;(matchingBeans.values()); // We keep HandlerMappings in sorted order. AnnotationAwareOrderComparator.sort(this.handlerMappings); &#125; &#125; else &#123; try &#123; HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); this.handlerMappings = Collections.singletonList(hm); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Ignore, we'll add a default HandlerMapping later. &#125; &#125; // Ensure we have at least one HandlerMapping, by registering // a default HandlerMapping if no other mappings are found. if (this.handlerMappings == null) &#123; // 在这里将设置 this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); if (logger.isDebugEnabled()) &#123; logger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\"); &#125; &#125;&#125; 关注this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); 这行代码，可以看到this.handlerMappings 在这里赋值，继续进入该方法 1234567891011121314151617181920212223242526272829protected &lt;T&gt; List&lt;T&gt; getDefaultStrategies(ApplicationContext context, Class&lt;T&gt; strategyInterface) &#123; String key = strategyInterface.getName(); String value = defaultStrategies.getProperty(key); if (value != null) &#123; String[] classNames = StringUtils.commaDelimitedListToStringArray(value); List&lt;T&gt; strategies = new ArrayList&lt;T&gt;(classNames.length); for (String className : classNames) &#123; try &#123; Class&lt;?&gt; clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader()); Object strategy = createDefaultStrategy(context, clazz); strategies.add((T) strategy); &#125; catch (ClassNotFoundException ex) &#123; throw new BeanInitializationException( \"Could not find DispatcherServlet's default strategy class [\" + className + \"] for interface [\" + key + \"]\", ex); &#125; catch (LinkageError err) &#123; throw new BeanInitializationException( \"Error loading DispatcherServlet's default strategy class [\" + className + \"] for interface [\" + key + \"]: problem with class file or dependent class\", err); &#125; &#125; return strategies; &#125; else &#123; return new LinkedList&lt;T&gt;(); &#125;&#125; 从可以看到String value = defaultStrategies.getProperty(key); 这里使用了我们的配置对象，createDefaultStrategy 方法就是根据Class对象来创建bean 123protected Object createDefaultStrategy(ApplicationContext context, Class&lt;?&gt; clazz) &#123; return context.getAutowireCapableBeanFactory().createBean(clazz);&#125; 3.1 总结 HttpServletBean 主要做一些初始化的工作，将web.xml中配置的参数设置到Servlet中。比如servlet标签的子标签init-param标签中配置的参数。 FrameworkServlet 将Servlet与Spring容器上下文关联。其实也就是初始化FrameworkServlet的属性webApplicationContext，这个属性代表SpringMVC上下文，它有个父类上下文，既web.xml中配置的ContextLoaderListener监听器初始化的容器上下文。 DispatcherServlet 初始化各个功能的实现类。比如异常处理、视图处理、请求映射处理等。 DispatcherServlet会自动注册一些特殊的Bean，无需我们注册，如果我们注册了，默认的将不会注册。 因此BeanNameUrlHandlerMapping、SimpleControllerHandlerAdapter是不需要注册的，DispatcherServlet默认会注册这两个Bean。 4.1 参考官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html http://www.cnblogs.com/fangjian0423/p/springMVC-dispatcherServlet.html https://blog.csdn.net/lang_programmer/article/details/71598042","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Spring Mvc源码(一)Spring Mvc介绍","slug":"backend/spring/sourceCodeAnalysis/Spring Mvc源码(一)Spring Mvc介绍","date":"2019-01-23T11:59:44.000Z","updated":"2019-02-26T12:02:32.502Z","comments":true,"path":"2019/01/23/backend/spring/sourceCodeAnalysis/Spring Mvc源码(一)Spring Mvc介绍/","link":"","permalink":"http://www.songshuiyang.site/2019/01/23/backend/spring/sourceCodeAnalysis/Spring Mvc源码(一)Spring Mvc介绍/","excerpt":"","text":"1.1 什么是Spring Mvc 在JavaEE体系结构中一个应用可以划分为四个层次，从上到下分别是应用层、Web层、业务层、持久层，现在的项目大都是按照这种结构来开发，我们这一系列介绍的是Web层的处理框架Spring Mvc Spring Web Mvc是一种基于Java的轻量级Web框架，使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。 2.1 为什么要使用Spring Mvc2.1.1 没有使用Spring Mvc会怎么样在Web开发模式中，主要有两个开发模式，称为模式一（Mode I）和模式二（Mode II）. 模式二是因为受不了模式一的缺点而进化出来的，而Spring Mvc则是模式二的进化版本，下面是两种模式的介绍： 模式一（Mode I）指的就是在开发中将显示层、控制层、数据层的操作统一交给JSP或者JavaBean来进行处理！ 优点 开发速度贼快，适合炒鸡简单的应用 缺点 程序的可读性差、复用性低、代码复杂！什么jsp代码、html代码都往上面写，这肯定很难阅读，很难重用！ 要求开发者不仅要掌握 Java ，还要有高超的前端水平 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试 模式二（Mode II）中所有的开发都是以Servlet为主体展开的，由Servlet接收所有的客户端请求，然后根据请求调用相对应的JavaBean，并所有的显示结果交给JSP完成！，也就是俗称的MVC设计模式 优点 相比模式一，耦合度降低了，添加了Servlet来协调视图处理及业务数据处理 缺点 需要定义大量的Servlet来处理应用 MVC设计模式 模型层（Mode）：模型是什么呢？ 模型就是数据，就是 dao,bean 显示层（View）：视图是什么呢？ 就是网页, JSP，用来展示模型中的数据 控制层（Controller）：控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。 很多应用程序的问题在于处理业务数据的对象和显示业务数据的视图之间存在紧密耦合， 模式二（Mode II）就很完美吗，不不不，还可以进行优化，所以有了Web Mvc框架 常见的Web Mvc框架有Sturts及主角Spring Mvc 2.1.2 对比其他WEB框架有那些优势 使用简单，对于开发人员来说实现一个功能肯定是实现越简单越好，Spring Mvc配合一系列注解即可完成Web应用的开发，尤其是在SpringBoot上的体现越明显 性能上Spring会稍微比Struts快。Spring mvc是基于方法的设计，而Sturts是基于类，每次发一次请求都会实例一个action，每个action都会被注入属性，而Spring基于方法，粒度更细，但要小心把握像在Servlet控制数据一样。 易于和Spring容器集成，毕竟是自己家里人 3.1 使用Spring Mvc4.1 总结 框架本身就是为了找到一个平衡，用哪个合适，就用哪个 5.1 参考 官方文档: https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html https://www.cnblogs.com/wmyskxz/p/8848461.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"spring mvc","slug":"spring-mvc","permalink":"http://www.songshuiyang.site/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"http://www.songshuiyang.site/tags/spring/"}]},{"title":"Mybatis源码(二十二)使用拦截器Interceptor完成分页","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页","date":"2018-12-22T12:56:00.000Z","updated":"2018-12-22T14:06:52.725Z","comments":true,"path":"2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页/","link":"","permalink":"http://www.songshuiyang.site/2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十二)使用拦截器Interceptor完成分页/","excerpt":"","text":"前言只要有列表就会有分页功能，利用Mybatis拦截器Interceptor可以十分方便的完成分页功能 思路在执行查询sql之前的时候只要添加limit关键字，即可完成分页，除了分页之外需要count(*)获取数据总数，然后通过页码得到页数 实现 Page.java 分页对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189public class Page&lt;T&gt; &#123; private int end; // 当前页尾条记录位置 private int limit; // 每页记录数 private int page; // 当前页 private long total; // 总记录数 private String sortName; // 排序列 private String sortOrder; // 排序方式 private Map&lt;String, Object&gt; params = new HashMap&lt;&gt;(); // 请求参数 private List&lt;String&gt; columns = Lists.newArrayList(); // 查询出来的参数 private List&lt;T&gt; rows = new ArrayList&lt;&gt;(); // 记录 /** * 限制分页长度 * limit：0 不限制大小 * @param limit */ public Page(int limit) &#123; this.limit = limit; &#125; public Page(HttpServletRequest request) &#123; String param = null; String value = null; param = \"pageIndex\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.page = Integer.parseInt(value); &#125; else &#123; this.page = 1; &#125; param = \"limit\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.limit = Integer.parseInt(value); if (this.limit &gt; 15) &#123; this.limit = 15; &#125; &#125; else &#123; this.limit = 15; &#125; param = \"sortName\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.sortName = CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, value); &#125; param = \"sortOrder\"; value = request.getParameter(param); if (value != null &amp;&amp; value.length() &gt; 0) &#123; this.sortOrder = value; &#125; else &#123; this.sortOrder = \"asc\"; &#125; Map&lt;String, String[]&gt; paramMap = request.getParameterMap(); for (String key : paramMap.keySet()) &#123; if (key.startsWith(\"s_\")) &#123; String vkey = key.substring(2); String[] _params = paramMap.get(key); if (_params.length &gt; 0 &amp;&amp; StringUtils.isNotEmpty(_params[0])) &#123; getParams().put(vkey, StringUtils.join(_params, \"&gt;\").trim()); &#125; &#125; &#125; &#125; /** * 当前页首条记录位置 * * @return */ public int getStart() &#123; if (page == 0) &#123; return 0; &#125; return (page - 1) * limit; &#125; /** * 总页数 * * @return */ public int getTotalPage() &#123; if (limit == 0) &#123; return 0; &#125; return (int) Math.ceil(total / Double.valueOf(limit)); &#125; /** * 必须和数据库字段一致 * * @param sortName */ public void setSortName(String sortName) &#123; this.sortName = sortName; &#125; /** * 设置默认排序方式 * * @param sortName 需要排序的表字段，数据库字段 * @param sortOrder */ public void sortDefault(String sortName, String sortOrder) &#123; if (org.apache.commons.lang3.StringUtils.isEmpty(getSortName()) || org.apache.commons.lang3.StringUtils.isEmpty(getSortOrder())) &#123; setSortName(sortName); setSortOrder(sortOrder); &#125; &#125; public String getSortName() &#123; return sortName; &#125; public String getSortOrder() &#123; return sortOrder; &#125; public void setSortOrder(String sortOrder) &#123; this.sortOrder = sortOrder; &#125; public Map&lt;String, Object&gt; getParams() &#123; return params; &#125; public void setParams(Map&lt;String, Object&gt; params) &#123; this.params = params; &#125; public void setParams(String key, Object value) &#123; Assert.notNull(key, \"key must be not null\"); Assert.notNull(value, \"value must be not null \"); this.params.put(key, value); &#125; public List&lt;T&gt; getRows() &#123; return rows; &#125; public void setRows(List&lt;T&gt; rows) &#123; this.rows = rows; &#125; public List&lt;String&gt; getColumns() &#123; return columns; &#125; public void setColumns(List&lt;String&gt; columns) &#123; this.columns = columns; &#125; public int getEnd() &#123; return end; &#125; public void setEnd(int end) &#123; this.end = end; &#125; public int getLimit() &#123; return limit; &#125; public void setLimit(int limit) &#123; this.limit = limit; &#125; public int getPage() &#123; return page; &#125; public void setPage(int page) &#123; this.page = page; &#125; public long getTotal() &#123; return total; &#125; public void setTotal(long total) &#123; this.total = total; &#125;&#125; PageInterceptor.java 拦截器，此类intercept 方法是完成分页实现方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/** * mybatis拦截器，实现接口分页，拦截Executor接口的query方法 */@Component@Intercepts(&#123; @Signature(type = Executor.class, method = \"query\", args = &#123; MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class &#125;) &#125;)public class PageInterceptor implements Interceptor &#123; private static Logger logger = LoggerFactory.getLogger(PageInterceptor.class); static int MAPPED_STATEMENT_INDEX = 0; static int PARAMETER_INDEX = 1; static int ROWBOUNDS_INDEX = 2; static int RESULT_HANDLER_INDEX = 3; // 需要拦截的ID(正则匹配) private static final String DEFAULT_PAGE_SQL_ID = \".*Page$\"; /** * setProperties方法是用于在Mybatis配置文件中指定一些属性的。 * @param properties */ @Override public void setProperties(Properties properties) &#123; &#125; /** * 拦截器用于封装目标对象 * 在plugin方法中我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象 * @param o * @return */ @Override public Object plugin(Object o) &#123; if (Executor.class.isAssignableFrom(o.getClass())) &#123; // 在这里返回新的 PageExecutor，用于装饰原Executor return Plugin.wrap(new PageExecutor((Executor) o), this); &#125; return Plugin.wrap(o, this); &#125; /** * 在这里完成分页及排序操作得到 新的BoundSql 然后执行查询 * @param invocation * @return * @throws Throwable */ @Override public Object intercept(Invocation invocation) throws Throwable &#123; final Object[] queryArgs = invocation.getArgs(); // MappedStatement对象对应Mapper配置文件中的一个select/update/insert/delete节点，主要描述的是一条SQL语句 final MappedStatement mappedStatement = (MappedStatement) queryArgs[MAPPED_STATEMENT_INDEX]; // 获取查询参数 final Object parameterObject = queryArgs[PARAMETER_INDEX]; BoundSql boundSql = mappedStatement.getBoundSql(parameterObject); // 拦截以Page结尾的查询方法 if (mappedStatement.getId().matches(DEFAULT_PAGE_SQL_ID)) &#123; if (parameterObject == null) &#123; throw new NullPointerException(\"parameterObject is null!\"); &#125; else &#123; // 如果查询参数是Page对象 if (parameterObject instanceof Page&lt;?&gt;) &#123; Page&lt;?&gt; page = (Page&lt;?&gt;) parameterObject; // 执行总记录数查询 setTotalRecord(page, mappedStatement, boundSql); // 拼接排序sql String orderSql = getOrderSql(boundSql.getSql(), page); // 拼接分页sql String pageSql = getPageSql(orderSql, page); logger.debug(\"page sql : &#123;&#125; \", pageSql); BoundSql newBoundSql = copyFromBoundSql(mappedStatement, boundSql, pageSql); MappedStatement newMappedStatement = copyFromMappedStatement(mappedStatement, new BoundSqlSqlSource(newBoundSql)); queryArgs[ROWBOUNDS_INDEX] = new RowBounds(RowBounds.NO_ROW_OFFSET, RowBounds.NO_ROW_LIMIT); queryArgs[MAPPED_STATEMENT_INDEX] = newMappedStatement; &#125; &#125; &#125; return invocation.proceed(); &#125; /** * 得到新的 BoundSql * @param ms * @param boundSql * @param sql * @return */ public static BoundSql copyFromBoundSql(MappedStatement ms, BoundSql boundSql, String sql) &#123; BoundSql newBoundSql = new BoundSql(ms.getConfiguration(), sql, boundSql.getParameterMappings(), boundSql.getParameterObject()); for (ParameterMapping mapping : boundSql.getParameterMappings()) &#123; String prop = mapping.getProperty(); if (boundSql.hasAdditionalParameter(prop)) &#123; newBoundSql.setAdditionalParameter(prop, boundSql.getAdditionalParameter(prop)); &#125; &#125; return newBoundSql; &#125; /** * 得到新的 MappedStatement * @param ms * @param newSqlSource * @return */ private static MappedStatement copyFromMappedStatement(MappedStatement ms, SqlSource newSqlSource) &#123; MappedStatement.Builder builder = new MappedStatement.Builder(ms.getConfiguration(), ms.getId(), newSqlSource, ms.getSqlCommandType()); builder.resource(ms.getResource()); builder.fetchSize(ms.getFetchSize()); builder.statementType(ms.getStatementType()); builder.keyGenerator(ms.getKeyGenerator()); String[] keyProperties = ms.getKeyProperties(); builder.keyProperty(keyProperties == null ? null : keyProperties[0]); builder.timeout(ms.getTimeout()); builder.parameterMap(ms.getParameterMap()); builder.resultMaps(ms.getResultMaps()); builder.resultSetType(ms.getResultSetType()); builder.cache(ms.getCache()); builder.flushCacheRequired(ms.isFlushCacheRequired()); builder.useCache(ms.isUseCache()); return builder.build(); &#125; public static class BoundSqlSqlSource implements SqlSource &#123; BoundSql boundSql; public BoundSqlSqlSource(BoundSql boundSql) &#123; this.boundSql = boundSql; &#125; public BoundSql getBoundSql(Object parameterObject) &#123; return boundSql; &#125; &#125; /** * 查询数据总数 * @param page * @param mappedStatement * @param boundSql */ private void setTotalRecord(Page&lt;?&gt; page, MappedStatement mappedStatement, BoundSql boundSql) throws Throwable &#123; String sql = getCountSql(boundSql.getSql()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); BoundSql countBoundSql = new BoundSql(mappedStatement.getConfiguration(), sql, parameterMappings, page); ParameterHandler parameterHandler = new DefaultParameterHandler(mappedStatement, page, countBoundSql); Connection con = mappedStatement.getConfiguration().getEnvironment().getDataSource().getConnection(); PreparedStatement stmt = null; ResultSet rs = null; try &#123; int total = 0; stmt = con.prepareStatement(sql); parameterHandler.setParameters(stmt); rs = stmt.executeQuery(); if (rs.next()) &#123; total = rs.getInt(1); &#125; page.setTotal(total); logger.debug(\"page count sql : &#123;&#125;\", sql); logger.debug(\"page count total : &#123;&#125;\", total); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JdbcUtils.close(rs, stmt); JdbcUtils.close(con); &#125; &#125; /** * 得到统计总数sql * @param sql * @return */ private String getCountSql(String sql) &#123; int index = sql.indexOf(\"from\") == -1 ? sql.indexOf(\"FROM\") : sql.indexOf(\"from\"); return \"select count(*) \" + sql.substring(index); &#125; /** * 得到分页sql * @param sql * @param page * @return */ private String getPageSql(String sql, Page&lt;?&gt; page) &#123; if (page != null &amp;&amp; page.getLimit() &gt; 0) &#123; StringBuilder pageSql = getMySQLPageSql(sql, page); return pageSql.toString(); &#125; else &#123; return sql; &#125; &#125; /** * 得到排序sql * @param sql * @param page * @return */ private String getOrderSql(String sql, Page&lt;?&gt; page) &#123; if (org.apache.commons.lang3.StringUtils.isNotEmpty(page.getSortName())) &#123; StringBuilder pageSql = new StringBuilder(100); pageSql.append(sql); if ((page.getSortName().indexOf(\"_\") == -1)) &#123; page.setSortName(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, page.getSortName())); &#125; if ((\"asc\".equalsIgnoreCase(page.getSortOrder()) || \"desc\".equalsIgnoreCase(page.getSortOrder()))) &#123; pageSql.append(\" order by \" + page.getSortName() + \" \" + page.getSortOrder()); &#125; return pageSql.toString(); &#125; else &#123; return sql; &#125; &#125; /** * 得到mysql 分页语句 * @param sql * @param page * @return */ public StringBuilder getMySQLPageSql(String sql, Page page) &#123; StringBuilder pageSql = new StringBuilder(100); pageSql.append(sql); pageSql.append(\" limit \" + page.getStart() + \",\" + page.getLimit()); return pageSql; &#125;&#125; PageExecutor.java 用于装饰之前的Executor用于将结果赋值到Page对象的rows属性中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class PageExecutor implements Executor &#123; private static Logger logger = LoggerFactory.getLogger(PageExecutor.class); private final Executor executor; public PageExecutor(Executor executor) &#123; this.executor = executor; &#125; @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey cacheKey, BoundSql boundSql) throws SQLException &#123; final List&lt;E&gt; rows = executor.query(ms, parameter, rowBounds, resultHandler); if (parameter != null &amp;&amp; parameter instanceof Page&lt;?&gt;) &#123; Page&lt;E&gt; page = (Page&lt;E&gt;) parameter; doCache(ms, page, parameter, rowBounds); // 将结果赋值到Page对象的rows属性 page.setRows(rows); &#125; return rows; &#125; @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; final List&lt;E&gt; rows = executor.query(ms, parameter, rowBounds, resultHandler); if (parameter != null &amp;&amp; parameter instanceof Page&lt;?&gt;) &#123; Page&lt;E&gt; page = (Page&lt;E&gt;) parameter; doCache(ms, page, parameter, rowBounds); // 将结果赋值到Page对象的rows属性 page.setRows(rows); &#125; return rows; &#125; private &lt;E&gt; void doCache(MappedStatement ms, Page&lt;E&gt; result, Object parameter, RowBounds rowBounds) &#123; final Cache cache = ms.getCache(); if (executor.getClass().isAssignableFrom(CachingExecutor.class) &amp;&amp; cache != null) &#123; BoundSql boundSql = ms.getBoundSql(parameter); final CacheKey cacheKey = createCacheKey(ms, parameter, rowBounds, boundSql); if (logger.isDebugEnabled()) &#123; logger.debug(\"cache executor the cache's kye is \" + cacheKey); &#125; cache.putObject(cacheKey, result); &#125; &#125; @Override public void setExecutorWrapper(Executor executor) &#123; executor.setExecutorWrapper(executor); &#125; @Override public int update(MappedStatement ms, Object parameter) throws SQLException &#123; return executor.update(ms, parameter); &#125; @Override public List&lt;BatchResult&gt; flushStatements() throws SQLException &#123; return executor.flushStatements(); &#125; @Override public void commit(boolean required) throws SQLException &#123; executor.commit(required); &#125; @Override public void rollback(boolean required) throws SQLException &#123; executor.rollback(required); &#125; @Override public CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123; return executor.createCacheKey(ms, parameterObject, rowBounds, boundSql); &#125; @Override public boolean isCached(MappedStatement ms, CacheKey key) &#123; return executor.isCached(ms, key); &#125; @Override public void clearLocalCache() &#123; executor.clearLocalCache(); &#125; @Override public void deferLoad(MappedStatement mappedStatement, MetaObject metaObject, String s, CacheKey cacheKey, Class&lt;?&gt; aClass) &#123; executor.deferLoad(mappedStatement, metaObject, s, cacheKey, aClass); &#125; @Override public Transaction getTransaction() &#123; return executor.getTransaction(); &#125; @Override public void close(boolean forceRollback) &#123; executor.close(forceRollback); &#125; @Override public boolean isClosed() &#123; return executor.isClosed(); &#125; @Override public &lt;E&gt; Cursor&lt;E&gt; queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException &#123; // TODO Auto-generated method stub return null; &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二十三)Mybatis中#{}和${}","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}","date":"2018-12-22T10:12:00.000Z","updated":"2018-12-22T14:07:43.420Z","comments":true,"path":"2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}/","link":"","permalink":"http://www.songshuiyang.site/2018/12/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十三)Mybatis中#{}和${}/","excerpt":"","text":"前言Mybatis的Sql语句传参有两种方式：#{}和${} #{}是预编译处理 Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； 使用#{}可以有效的防止SQL注入，提高系统安全。 如：order by #{sortName}#，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;, ${}是字符串替换 Mybatis在处理${}时，就是把${}替换成变量的值。 如果是在SQL语句中插入一个不改变的字符串。比如，像ORDER BY，你可以这样来使用：ORDER BY ${columnName} 举个栗子 现在通过一个例子来分析其两者的区别 测试类 1234567891011121314151617181920/** * 测试 $ 和 # * @throws Exception */@Testpublic void selectByUsernameAndPasswordTest() throws Exception &#123; // 读取配置文件 File file = new File(\"src/test/java/resources/mybatis-config.xml\"); InputStream inputStream = new FileInputStream(file); // 构建SqlSessionFactory SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 得到SqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); // 得到Mapper UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername(\"songsy\"); user.setPassword(\"root\"); System.out.println(mapper.selectByUsernameAndPassword(user));&#125; Mapper.xml 配置文件1234567SELECT *FROM sys_userWHERE username = $&#123;username&#125;AND password = #&#123;password&#125; 执行mapper方法，打好断点，进入到Executor的query方法，关注BoundSql boundSql = ms.getBoundSql(parameterObject); 这行，BoundSql对象存放了处理完成之后的sql 1234567 @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; BoundSql boundSql = ms.getBoundSql(parameterObject);//query时传入一个cachekey参数 CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); &#125; 如下图所示，${username} 已经替换成了 songsy ， #{password} 替换成了 ? image 栗子剖析 Mybatis是怎样完成上面的替换解析过程呢，进入BoundSql boundSql = ms.getBoundSql(parameterObject); 方法，可以看到其实就是调用sqlSource.getBoundSql 12345678910111213141516171819 public BoundSql getBoundSql(Object parameterObject) &#123;// 其实就是调用sqlSource.getBoundSql BoundSql boundSql = sqlSource.getBoundSql(parameterObject); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings == null || parameterMappings.isEmpty()) &#123; boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject); &#125; // check for nested result maps in parameter mappings (issue #30) for (ParameterMapping pm : boundSql.getParameterMappings()) &#123; String rmId = pm.getResultMapId(); if (rmId != null) &#123; ResultMap rm = configuration.getResultMap(rmId); if (rm != null) &#123; hasNestedResultMaps |= rm.hasNestedResultMaps(); &#125; &#125; &#125; return boundSql; &#125; 进入sqlSource.getBoundSql(parameterObject); ，因为sql不是静态sql所以进入DynamicSqlSource 类的getBoundSql方法，这里传入了我们的user查询对象 12345678910111213141516171819202122232425262728293031323334/** * 动态SQL源码 * @author Clinton Begin */public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 下面的语句是动态sql的处理，循环执行SqlNode.apply方法，进入 rootSqlNode.apply(context);方法 123DynamicContext context = new DynamicContext(configuration, parameterObject);// 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数rootSqlNode.apply(context); 进入rootSqlNode.apply(context); 之后来到了MixedSqlNode类，这里依次调用list里每个元素的apply，如下图所示 image 执行sqlNode.apply(context);方法这里进入到TextSqlNode的apply方法，这里又调用了GenericTokenParser类的parser.parse(text)方法 1234567891011121314151617181920212223242526272829public class TextSqlNode implements SqlNode &#123; private String text; private Pattern injectionFilter; public TextSqlNode(String text) &#123; this(text, null); &#125; public TextSqlNode(String text, Pattern injectionFilter) &#123; this.text = text; this.injectionFilter = injectionFilter; &#125; //判断是否是动态sql public boolean isDynamic() &#123; DynamicCheckerTokenParser checker = new DynamicCheckerTokenParser(); GenericTokenParser parser = createParser(checker); parser.parse(text); return checker.isDynamic(); &#125; @Override public boolean apply(DynamicContext context) &#123; GenericTokenParser parser = createParser(new BindingTokenParser(context, injectionFilter)); context.appendSql(parser.parse(text)); return true; &#125; ... 进入 GenericTokenParser类的parser.parse(text)方法，可以看到这个类是处理#{}和${}参数的主要方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 普通记号解析器，处理#&#123;&#125;和$&#123;&#125;参数 * @author Clinton Begin */public class GenericTokenParser &#123; // 有一个开始和结束记号 private final String openToken; private final String closeToken; // 记号处理器 private final TokenHandler handler; public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) &#123; this.openToken = openToken; this.closeToken = closeToken; this.handler = handler; &#125; public String parse(String text) &#123; StringBuilder builder = new StringBuilder(); if (text != null &amp;&amp; text.length() &gt; 0) &#123; char[] src = text.toCharArray(); int offset = 0; int start = text.indexOf(openToken, offset); // #&#123;favouriteSection,jdbcType=VARCHAR&#125; // 这里是循环解析参数，参考GenericTokenParserTest,比如可以解析$&#123;first_name&#125; $&#123;initial&#125; $&#123;last_name&#125; reporting.这样的字符串,里面有3个 $&#123;&#125; while (start &gt; -1) &#123; // 判断一下 $&#123; 前面是否是反斜杠，这个逻辑在老版的mybatis中（如3.1.0）是没有的 if (start &gt; 0 &amp;&amp; src[start - 1] == '\\\\') &#123; // the variable is escaped. remove the backslash. // 新版已经没有调用substring了，改为调用如下的offset方式，提高了效率 // issue #760 builder.append(src, offset, start - offset - 1).append(openToken); offset = start + openToken.length(); &#125; else &#123; int end = text.indexOf(closeToken, start); if (end == -1) &#123; builder.append(src, offset, src.length - offset); offset = src.length; &#125; else &#123; builder.append(src, offset, start - offset); offset = start + openToken.length(); String content = new String(src, offset, end - offset); // 得到一对大括号里的字符串后，调用handler.handleToken,比如替换变量 $&#123;username&#125;这种功能 builder.append(handler.handleToken(content)); offset = end + closeToken.length(); &#125; &#125; start = text.indexOf(openToken, offset); &#125; if (offset &lt; src.length) &#123; builder.append(src, offset, src.length - offset); &#125; &#125; return builder.toString(); &#125;&#125; 执行完builder.append(handler.handleToken(content)); 这行代码之后就可以看到${username} 已经替换成songsy了 image 到现在已经完成了${username} 的处理，回到 DynamicSqlSource 类中，现在是处理#{password} 这些参数了 123456789101112131415161718192021222324252627282930public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#&#123;password&#125;都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 下图是处理完动态sql节点及${username}之后的结果 处理完${username} 节点之后现在就是处理#{password} 节点了，解析完了就把那些参数#{password}都替换成?了，也就是最基本的JDBC的SQL写法 12345// 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass();// SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数#&#123;password&#125;都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); 进入sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings());方法，之后又是进入 GenericTokenParser类的parser.parse(text)方法，只不过handleToken方法执行的是下面的代码 1234567@Override public String handleToken(String content) &#123; // 先构建参数映射 parameterMappings.add(buildParameterMapping(content)); // 如何替换很简单，永远是一个问号，但是参数的信息要记录在parameterMappings里面供后续使用 return \"?\"; &#125; 最后拼接成的结果如下 1234567SELECT *FROM sys_userWHERE username = songsyAND password = ? 总结 #{}在一定程度上可以防止SQL的注入 ${}一般用在动态表名，动态字段，设置排序字段上 参考https://www.jianshu.com/p/a9cb929b533e","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二十一)拦截器Interceptor原理探究","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究","date":"2018-12-21T12:56:00.000Z","updated":"2018-12-22T14:02:27.290Z","comments":true,"path":"2018/12/21/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究/","link":"","permalink":"http://www.songshuiyang.site/2018/12/21/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十一)拦截器Interceptor原理探究/","excerpt":"","text":"前言 MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用，拦截后用户可以完成一些额外的定制操作，比如实现分页，这一章节来介绍拦截器的一些基本知识及实现原理，下一章节将介绍如何用拦截器实现查询分页功能 默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： 12345678// 拦截执行器的方法Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)// 拦截参数的处理ParameterHandler (getParameterObject, setParameters)// 拦截结果集的处理ResultSetHandler (handleResultSets, handleOutputParameters)// 拦截Sql语法构建的处理StatementHandler (prepare, parameterize, batch, update, query) 拦截器的使用 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。 123456789101112131415// ExamplePlugin.java@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125; xml 配置 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 上面的插件将会拦截在 Executor 实例中所有的名为update 且参数为(MappedStatement.class,Object.class)的方法调用， 这里的 Executor 是负责执行低层映射语句的内部对象。 拦截器原理探究 拦截器定义 首先我们看下MyBatis拦截器的接口定义 Interceptor.java 12345678910111213141516/** * 拦截器 * @author Clinton Begin */public interface Interceptor &#123; // 在这里完成拦截操作 Object intercept(Invocation invocation) throws Throwable; // 用于封装目标对象，我们可以决定是否要进行拦截进而决定要返回一个什么样的目标对象 Object plugin(Object target); // 用于在Mybatis配置文件中指定一些属性的。 void setProperties(Properties properties);&#125; Signature注解用于定义拦截方法，规则为：type这个类下方法名为method且参数为args的方法 1234567891011121314/** * 就是定义哪些类，方法，参数需要被拦截 * @author Clinton Begin */@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Signature &#123; Class&lt;?&gt; type(); String method(); Class&lt;?&gt;[] args();&#125; 当定义拦截器类之后就是要让Mybatis知道有哪些拦截器了，那Mybatis是怎么知道有哪些拦截器呢，通过以上章节可以知道Spring集成Mybatis有两种方法，一种是通过xml配置的方式，另一种是通过注解的方式，下面来介绍这两种方式是怎样获取定义好的拦截器的 通过xml配置的方式 先是在 mybatis-config.xml 定义好哪些拦截器 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 定义好之后那么Mybatis就会解析pluginElement 然后将会添加到Configuration 对象的InterceptorChain对象中，这样拦截器就解析完成了 123456789101112private void pluginElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; String interceptor = child.getStringAttribute(\"interceptor\"); Properties properties = child.getChildrenAsProperties(); Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance(); interceptorInstance.setProperties(properties); //调用InterceptorChain.addInterceptor configuration.addInterceptor(interceptorInstance); &#125; &#125;&#125; 看看InterceptorChain类，内部就是一个拦截器的List，可以定义多个拦截器 123456789101112131415161718192021222324252627 /** * 拦截器链 * @author Clinton Begin */public class InterceptorChain &#123; // 内部就是一个拦截器的List，可以定义多个拦截器 private final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;Interceptor&gt;(); public Object pluginAll(Object target) &#123; // 循环调用每个Interceptor.plugin方法 for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target); &#125; return target; &#125; public void addInterceptor(Interceptor interceptor) &#123; interceptors.add(interceptor); &#125; public List&lt;Interceptor&gt; getInterceptors() &#123; return Collections.unmodifiableList(interceptors); &#125;&#125; 通过注解的方式 通过注解的方式获取拦截器需要准备环境，查看第十九章 在拦截器那个类添加@Component 让拦截器类注册成Spring bean，这样此拦截器将会自动装配到Mybatis中 123456789101112131415@Component@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125; 那么是怎么实现拦截器的自动装配到Mybatis中，可以查看org.mybatis.spring.boot.autoconfigure 包下的MybatisAutoConfiguration 类，查看其构造方法，关注this.interceptors = interceptorsProvider.getIfAvailable(); 方法，这里实现了查找实现了Interceptor接口的的类，这个方法是Spring的方法，所以之前需要将拦截器类注册成Bean，这样Spring才能找到对应的拦截器 1234567891011public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider, ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider, ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123; this.properties = properties; this.interceptors = interceptorsProvider.getIfAvailable(); this.resourceLoader = resourceLoader; this.databaseIdProvider = databaseIdProvider.getIfAvailable(); this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable();&#125; 现在来看SqlSessionFactory注册为Bean的过程，得到interceptors之后就需要将其添加到万能类Configuration中， 查看SqlSessionFactoryBean的buildSqlSessionFactory 方法，下面的代码就是此操作的实现 12345678if (!isEmpty(this.plugins)) &#123; for (Interceptor plugin : this.plugins) &#123; configuration.addInterceptor(plugin); if (LOGGER.isDebugEnabled()) &#123; LOGGER.debug(\"Registered plugin: '\" + plugin + \"'\"); &#125; &#125; &#125; 拦截器是如何拦截的 以下4个方法都是Configuration的方法。这些方法在MyBatis的新增，删除，修改，查询这些操作中都会被执行到，执行的先后顺序是Executor，ParameterHandler，ResultSetHandler，StatementHandler(其中ParameterHandler和ResultSetHandler的创建是在创建StatementHandler（3个可用的实现类CallableStatementHandler,PreparedStatementHandler,SimpleStatementHandler）的时候，其构造函数调用的（这3个实现类的构造函数其实都调用了父类BaseStatementHandler的构造函数）。 123456789101112131415161718192021222324252627282930313233343536public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql); parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler); return parameterHandler;&#125;public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) &#123; ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds); resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler); return resultSetHandler;&#125;public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) &#123; StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql); statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); return statementHandler;&#125;public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) &#123; executorType = executorType == null ? defaultExecutorType : executorType; executorType = executorType == null ? ExecutorType.SIMPLE : executorType; Executor executor; if (ExecutorType.BATCH == executorType) &#123; executor = new BatchExecutor(this, transaction); &#125; else if (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction); &#125; if (cacheEnabled) &#123; executor = new CachingExecutor(executor, autoCommit); &#125; executor = (Executor) interceptorChain.pluginAll(executor); return executor;&#125; 这4个方法实例化了对应的对象之后，都会调用interceptorChain的pluginAll方法，InterceptorChain的pluginAll刚才已经介绍过了，就是遍历所有的拦截器，然后调用各个拦截器的plugin方法。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象 1234567public Object pluginAll(Object target) &#123; // 循环调用每个Interceptor.plugin方法 for (Interceptor interceptor : interceptors) &#123; target = interceptor.plugin(target); &#125; return target; &#125; 回到之前的拦截器类，这里查看plugin方法Plugin.wrap(target, this);，这里执行了Plugin类的wrap(target, this) 方法，返回了一个新的对象。注意：拦截器的plugin方法的返回值会直接被赋值给原先的对象 1234567891011121314@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; public Object intercept(Invocation invocation) throws Throwable &#123; return invocation.proceed(); &#125; public Object plugin(Object target) &#123; return Plugin.wrap(target, this); &#125; public void setProperties(Properties properties) &#123; &#125;&#125; 进入Plugin类，可以看到这里用了动态代理模式来实现拦截器的拦截操作Plugin.wrap(target, this);返回的是一个动态代理对象，当其动态代理对象执行方法的时候就会执行本Plugin类的invoke方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * 插件,用的代理模式 * @author Clinton Begin */public class Plugin implements InvocationHandler &#123; private Object target; private Interceptor interceptor; private Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap; private Plugin(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123; this.target = target; this.interceptor = interceptor; this.signatureMap = signatureMap; &#125; public static Object wrap(Object target, Interceptor interceptor) &#123; // 取得签名Map Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor); // 取得要改变行为的类(ParameterHandler|ResultSetHandler|StatementHandler|Executor) Class&lt;?&gt; type = target.getClass(); // 取得接口 Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap); // 产生代理 if (interfaces.length &gt; 0) &#123; return Proxy.newProxyInstance( type.getClassLoader(), interfaces, new Plugin(target, interceptor, signatureMap)); &#125; return target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; // 看看如何拦截 Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); // 看哪些方法需要拦截 if (methods != null &amp;&amp; methods.contains(method)) &#123; // 调用Interceptor.intercept，也即插入了我们自己的逻辑 return interceptor.intercept(new Invocation(target, method, args)); &#125; // 最后还是执行原来逻辑 return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125; &#125; // 取得签名Map private static Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123; // 取Intercepts注解，例子可参见ExamplePlugin.java Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class); // issue #251 // 必须得有Intercepts注解，没有报错 if (interceptsAnnotation == null) &#123; throw new PluginException(\"No @Intercepts annotation was found in interceptor \" + interceptor.getClass().getName()); &#125; // value是数组型，Signature的数组 Signature[] sigs = interceptsAnnotation.value(); // 每个class里有多个Method需要被拦截,所以这么定义 Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = new HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(); for (Signature sig : sigs) &#123; Set&lt;Method&gt; methods = signatureMap.get(sig.type()); if (methods == null) &#123; methods = new HashSet&lt;Method&gt;(); signatureMap.put(sig.type(), methods); &#125; try &#123; Method method = sig.type().getMethod(sig.method(), sig.args()); methods.add(method); &#125; catch (NoSuchMethodException e) &#123; throw new PluginException(\"Could not find method on \" + sig.type() + \" named \" + sig.method() + \". Cause: \" + e, e); &#125; &#125; return signatureMap; &#125; // 取得接口 private static Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123; Set&lt;Class&lt;?&gt;&gt; interfaces = new HashSet&lt;Class&lt;?&gt;&gt;(); while (type != null) &#123; for (Class&lt;?&gt; c : type.getInterfaces()) &#123; //貌似只能拦截ParameterHandler|ResultSetHandler|StatementHandler|Executor //拦截其他的无效 //当然我们可以覆盖Plugin.wrap方法，达到拦截其他类的功能 if (signatureMap.containsKey(c)) &#123; interfaces.add(c); &#125; &#125; type = type.getSuperclass(); &#125; return interfaces.toArray(new Class&lt;?&gt;[interfaces.size()]); &#125;&#125; 查看invoke方法,从而调用了我们之前定义的interceptor.intercept();的方法，这里是实现拦截的核心，interceptor.intercept(new Invocation(target, method, args)); 这里插入了我们自己的逻辑 12345678910111213141516@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; try &#123; // 看看如何拦截 Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass()); // 看哪些方法需要拦截 if (methods != null &amp;&amp; methods.contains(method)) &#123; // 调用Interceptor.intercept，也即插入了我们自己的逻辑 return interceptor.intercept(new Invocation(target, method, args)); &#125; // 最后还是执行原来逻辑 return method.invoke(target, args); &#125; catch (Exception e) &#123; throw ExceptionUtil.unwrapThrowable(e); &#125;&#125; 回到之前的节点，在构建Executor的时候，executor = (Executor) interceptorChain.pluginAll(executor);这里返回的是 Plugin.wrap(target, this);一个动态代理对象 1234567891011121314151617public Executor newExecutor(Transaction transaction, ExecutorType executorType, boolean autoCommit) &#123; executorType = executorType == null ? defaultExecutorType : executorType; executorType = executorType == null ? ExecutorType.SIMPLE : executorType; Executor executor; if (ExecutorType.BATCH == executorType) &#123; executor = new BatchExecutor(this, transaction); &#125; else if (ExecutorType.REUSE == executorType) &#123; executor = new ReuseExecutor(this, transaction); &#125; else &#123; executor = new SimpleExecutor(this, transaction); &#125; if (cacheEnabled) &#123; executor = new CachingExecutor(executor, autoCommit); &#125; executor = (Executor) interceptorChain.pluginAll(executor); return executor;&#125; 所以当SqlSession执行Executor的方法时候，这里Executor是个动态代理之后的Executor，当执行Executor的方法的时候就会执行动态代理的invoke方法，在invoke方法执行我们额外的代码 在此拦截器的任务才真正完成 参考官网：http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins https://www.cnblogs.com/fangjian0423/p/mybatis-interceptor.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二十)Spring Mybatis集成之事务管理","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十)Spring Mybatis集成之事务管理","date":"2018-12-18T15:56:00.000Z","updated":"2018-12-20T14:07:39.013Z","comments":true,"path":"2018/12/18/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十)Spring Mybatis集成之事务管理/","link":"","permalink":"http://www.songshuiyang.site/2018/12/18/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二十)Spring Mybatis集成之事务管理/","excerpt":"","text":"前言使用 MyBatis-Spring 的主要原因是它允许 MyBatis 参与到 Spring 的事务管理中。而 不是给 MyBatis 创建一个新的特定的事务管理器,MyBatis-Spring 利用了存在于 Spring 中的 DataSourceTransactionManager。 如何集成 Spring的事务管理 配置 DataSourceTransactionManager Bean 1234&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 要注意, 为事务管理器指定的 DataSource 必须和用来创建 SqlSessionFactoryBean 的 是同一个数据源,否则事务管理器就无法工作了。 一旦 Spring 的 DataSourceTransactionManager 配置好了,你可以在 Spring 中你可以使用@Transactional 注解来完成事物操作。在事务处理期间,一个单独的 SqlSession 对象（线程级别）将会被创建 和使用。当事务完成时,这个 SqlSession 会以合适的方式提交或回滚。相反如果没有开启事物那么SqlSession 对象就是方法级别的了，每次调用Mapper里的方法都会返回一个新的SqlSession 来处理，下面来看其内部是怎么实现的 事务实现解析 与Spring集成以后，Spring提供了一个全局唯一的SqlSessionTemplate 来完成DefailtSqlSession的功能 进入SqlSessionTemplate 可以看到里面有个SqlSession 属性，看属性名可以看出这里又用了动态代理，为什么又要代理呢？下面来看看 12// SqlSession代理private final SqlSession sqlSessionProxy; 观察其构造方法，这里形成SqlSession代理类，再来看动态代理类SqlSessionInterceptor做了什么 123456789101112131415public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\"); notNull(executorType, \"Property 'executorType' is required\"); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; // 形成SqlSession代理类 this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor()); &#125; 进入SqlSessionInterceptor类，这个SqlSession代理类的出现是为了让Spring 来管理SqlSession 的，从而实现事物管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession * Proxy needed to route MyBatis method calls to the proper SqlSession got * from Spring's Transaction Manager * It also unwraps exceptions thrown by &#123;@code Method#invoke(Object, Object...)&#125; to * pass a &#123;@code PersistenceException&#125; to the &#123;@code PersistenceExceptionTranslator&#125;. */private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 获取SqlSession(这个SqlSession才是真正使用的，它不是线程安全的) SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; // 调用真实SqlSession的方法 Object result = method.invoke(sqlSession, args); // 判断一下当前的sqlSession是否被Spring托管 if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() // 没有使用事务 sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125;&#125; 进入getSqlSession()方法，这里是获取SqlSession 的方法 1234567891011121314151617181920public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); notNull(executorType, NO_EXECUTOR_TYPE_SPECIFIED); // 根据sqlSessionFactory从当前线程对应的资源map中获取SqlSessionHolder SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); SqlSession session = sessionHolder(executorType, holder); if (session != null) &#123; return session; &#125; // 如果找不到，则根据执行类型构造一个新的sqlSession LOGGER.debug(() -&gt; \"Creating a new SqlSession\"); session = sessionFactory.openSession(executorType); registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session); return session;&#125; 关注TransactionSynchronizationManager 内部成员，这里使用TreadLocal记录事务的一些属性，用于应用扩展同步器的使用，在事务的开启，挂起，提交等各个点上回调应用的逻辑 1234567891011121314151617181920212223 // 应用代码随事务的声明周期绑定的对象private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal&lt;&gt;(\"Transactional resources\"); // synchronizations-使用的同步器，用于应用扩展private static final ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations = new NamedThreadLocal&lt;&gt;(\"Transaction synchronizations\"); // 事务的名称private static final ThreadLocal&lt;String&gt; currentTransactionName = new NamedThreadLocal&lt;&gt;(\"Current transaction name\"); // 事务是否是只读private static final ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly = new NamedThreadLocal&lt;&gt;(\"Current transaction read-only status\"); // 事务的隔离界别private static final ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel = new NamedThreadLocal&lt;&gt;(\"Current transaction isolation level\"); // 事务是否开启private static final ThreadLocal&lt;Boolean&gt; actualTransactionActive = new NamedThreadLocal&lt;&gt;(\"Actual transaction active\"); 回到SqlSessionInterceptor 类invoke方法，这里有个if判断if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) { 来判断是否开启了Spring事务，如果该Session未被Spring托管则自动commit 12345678public static boolean isSqlSessionTransactional(SqlSession session, SqlSessionFactory sessionFactory) &#123; notNull(session, NO_SQL_SESSION_SPECIFIED); notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); return (holder != null) &amp;&amp; (holder.getSqlSession() == session);&#125; 关注invoke方法的finally块的 closeSqlSession()方法，如果是开启了事务则没有执行session.close(); 123456finally &#123; if (sqlSession != null) &#123; // 关闭SqlSession,如果sqlSession被Spring管理 则调用holder.released(); 使计数器-1 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; 1234567891011121314public static void closeSqlSession(SqlSession session, SqlSessionFactory sessionFactory) &#123; notNull(session, NO_SQL_SESSION_SPECIFIED); notNull(sessionFactory, NO_SQL_SESSION_FACTORY_SPECIFIED); SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory); if ((holder != null) &amp;&amp; (holder.getSqlSession() == session)) &#123; LOGGER.debug(() -&gt; \"Releasing transactional SqlSession [\" + session + \"]\"); // 如果是开启了事务 SqlSession是没有被close的，所以方法体内使用的是一个SqlSession，当然一级缓存是生效的 holder.released(); &#125; else &#123; LOGGER.debug(() -&gt; \"Closing non transactional SqlSession [\" + session + \"]\"); session.close(); &#125;&#125; 总结 通过上述代码可以得出如果开启了事务，同一事务中同一个sqlSessionFactory创建的唯一sqlSession，一个事务中使用的是同一个sqlSession，为什么要用同一个sqlSession呢，是为了使用同一个connection (JDBC) 如果没有开启事务，调用一次mapper里的方法将会新建一个sqlSession来执行方法 参考http://www.mybatis.org/spring/zh/factorybean.html https://www.cnblogs.com/daxin/p/3544188.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析","date":"2018-12-18T13:56:00.000Z","updated":"2019-02-17T04:48:00.774Z","comments":true,"path":"2018/12/18/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析/","link":"","permalink":"http://www.songshuiyang.site/2018/12/18/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十九)Spring Mybatis集成之基于注解的配置原理解析/","excerpt":"","text":"前言Mybatis与Spring的集成实现有两种方式，一种是通过XML配置，另一种是通过注解的信息进行配置，上一章节介绍了通过XML的方式来集成，这一章节来介绍如何通过注解的形式来在Spring Boot环境中集成Mybatis 环境准备 基于MyBatis-Spring-Boot-Starter 快速在Spring Boot环境中集成Mybatis，使用注解解决一切问题 基于Spring Boot环境中添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置类中添加注解 1@MapperScan(\"com.songsy.iframe.mapper\") 添加配置（选填） 1234567mybatis: type-aliases-package: com.songsy.iframe.model type-handlers-package: com.songsy.iframe.typehandler configuration: map-underscore-to-camel-case: true default-fetch-size: 100 default-statement-timeout: 30 以上完成之后就可以使用Mybatis了 原理解析 打开mybatis-spring-boot-starter 源码可以看到是个空壳子 image 打开里面的pom.xml文件，可以看到其依赖，里面已经帮我们导入了mybatis及mybatis-spring的包 123456789101112131415161718192021222324252627282930&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;parent&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/parent&gt;&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;name&gt;mybatis-spring-boot-starter&lt;/name&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 关注mybatis-spring-boot-autoconfigure 包，这里完成了其自动配置的功能，可以看到里面就只有几个类 image MybatisProperties.java是属性配置类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@ConfigurationProperties(prefix = MybatisProperties.MYBATIS_PREFIX)public class MybatisProperties &#123; public static final String MYBATIS_PREFIX = \"mybatis\"; /** * Location of MyBatis xml config file. */ private String configLocation; /** * Locations of MyBatis mapper files. */ private String[] mapperLocations; /** * Packages to search type aliases. (Package delimiters are \",; \\t\\n\") */ private String typeAliasesPackage; /** * Packages to search for type handlers. (Package delimiters are \",; \\t\\n\") */ private String typeHandlersPackage; /** * Indicates whether perform presence check of the MyBatis xml config file. */ private boolean checkConfigLocation = false; /** * Execution mode for &#123;@link org.mybatis.spring.SqlSessionTemplate&#125;. */ private ExecutorType executorType; /** * Externalized properties for MyBatis configuration. */ private Properties configurationProperties; /** * A Configuration object for customize default settings. If &#123;@link #configLocation&#125; * is specified, this property is not used. */ @NestedConfigurationProperty private Configuration configuration; ... MybatisAutoConfiguration 是完成自动配置的主要实现类，可以看到这里定义了SqlSessionFactory及SqlSessionTemplate Bean，这里完成了之前使用xml配置bean的功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/** * &#123;@link EnableAutoConfiguration Auto-Configuration&#125; for Mybatis. Contributes a * &#123;@link SqlSessionFactory&#125; and a &#123;@link SqlSessionTemplate&#125;. * * If &#123;@link org.mybatis.spring.annotation.MapperScan&#125; is used, or a * configuration file is specified as a property, those will be considered, * otherwise this auto-configuration will attempt to register mappers based on * the interface definitions in or under the root auto-configuration package. * * @author Eddú Meléndez * @author Josh Long * @author Kazuki Shimizu * @author Eduardo Macarrón */@org.springframework.context.annotation.Configuration@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)@ConditionalOnBean(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration &#123; private static final Logger logger = LoggerFactory.getLogger(MybatisAutoConfiguration.class); private final MybatisProperties properties; private final Interceptor[] interceptors; private final ResourceLoader resourceLoader; private final DatabaseIdProvider databaseIdProvider; private final List&lt;ConfigurationCustomizer&gt; configurationCustomizers; public MybatisAutoConfiguration(MybatisProperties properties, ObjectProvider&lt;Interceptor[]&gt; interceptorsProvider, ResourceLoader resourceLoader, ObjectProvider&lt;DatabaseIdProvider&gt; databaseIdProvider, ObjectProvider&lt;List&lt;ConfigurationCustomizer&gt;&gt; configurationCustomizersProvider) &#123; this.properties = properties; this.interceptors = interceptorsProvider.getIfAvailable(); this.resourceLoader = resourceLoader; this.databaseIdProvider = databaseIdProvider.getIfAvailable(); this.configurationCustomizers = configurationCustomizersProvider.getIfAvailable(); &#125; @PostConstruct public void checkConfigFileExists() &#123; if (this.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(this.properties.getConfigLocation())) &#123; Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation()); Assert.state(resource.exists(), \"Cannot find config location: \" + resource + \" (please add config file or check your Mybatis configuration)\"); &#125; &#125; @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) &#123; factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); &#125; Configuration configuration = this.properties.getConfiguration(); if (configuration == null &amp;&amp; !StringUtils.hasText(this.properties.getConfigLocation())) &#123; configuration = new Configuration(); &#125; if (configuration != null &amp;&amp; !CollectionUtils.isEmpty(this.configurationCustomizers)) &#123; for (ConfigurationCustomizer customizer : this.configurationCustomizers) &#123; customizer.customize(configuration); &#125; &#125; factory.setConfiguration(configuration); if (this.properties.getConfigurationProperties() != null) &#123; factory.setConfigurationProperties(this.properties.getConfigurationProperties()); &#125; if (!ObjectUtils.isEmpty(this.interceptors)) &#123; factory.setPlugins(this.interceptors); &#125; if (this.databaseIdProvider != null) &#123; factory.setDatabaseIdProvider(this.databaseIdProvider); &#125; if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123; factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); &#125; if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123; factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); &#125; if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123; factory.setMapperLocations(this.properties.resolveMapperLocations()); &#125; return factory.getObject(); &#125; @Bean @ConditionalOnMissingBean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; ExecutorType executorType = this.properties.getExecutorType(); if (executorType != null) &#123; return new SqlSessionTemplate(sqlSessionFactory, executorType); &#125; else &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125; &#125; /** * This will just scan the same base package as Spring Boot does. If you want * more power, you can explicitly use * &#123;@link org.mybatis.spring.annotation.MapperScan&#125; but this will get typed * mappers working correctly, out-of-the-box, similar to using Spring Data JPA * repositories. */ public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123; private BeanFactory beanFactory; private ResourceLoader resourceLoader; @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; logger.debug(\"Searching for mappers annotated with @Mapper\"); ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); try &#123; if (this.resourceLoader != null) &#123; scanner.setResourceLoader(this.resourceLoader); &#125; List&lt;String&gt; packages = AutoConfigurationPackages.get(this.beanFactory); if (logger.isDebugEnabled()) &#123; for (String pkg : packages) &#123; logger.debug(\"Using auto-configuration base package '&#123;&#125;'\", pkg); &#125; &#125; scanner.setAnnotationClass(Mapper.class); scanner.registerFilters(); scanner.doScan(StringUtils.toStringArray(packages)); &#125; catch (IllegalStateException ex) &#123; logger.debug(\"Could not determine auto-configuration package, automatic mapper scanning disabled.\", ex); &#125; &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; this.beanFactory = beanFactory; &#125; @Override public void setResourceLoader(ResourceLoader resourceLoader) &#123; this.resourceLoader = resourceLoader; &#125; &#125; /** * &#123;@link org.mybatis.spring.annotation.MapperScan&#125; ultimately ends up * creating instances of &#123;@link MapperFactoryBean&#125;. If * &#123;@link org.mybatis.spring.annotation.MapperScan&#125; is used then this * auto-configuration is not needed. If it is _not_ used, however, then this * will bring in a bean registrar and automatically register components based * on the same component-scanning path as Spring Boot itself. */ @org.springframework.context.annotation.Configuration @Import(&#123; AutoConfiguredMapperScannerRegistrar.class &#125;) @ConditionalOnMissingBean(MapperFactoryBean.class) public static class MapperScannerRegistrarNotFoundConfiguration &#123; @PostConstruct public void afterPropertiesSet() &#123; logger.debug(\"No &#123;&#125; found.\", MapperFactoryBean.class.getName()); &#125; &#125;&#125; 通过注解配置来集成Spring、Mybatis 的方式可以看到是通过这个注解@MapperScan来实现的，查看注解可以看到通过@Import(MapperScannerRegistrar.class)把实例加入springIOC容器中 123456@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Import(MapperScannerRegistrar.class) // 通过导入的方式实现把实例加入springIOC容器中@Repeatable(MapperScans.class)// 被此注解修饰的注解是可以重复的。注解的参数是可重复注解的存储容器注解类型。@Repeatable括号内的就相当于用来保存该注解内容的容器。public @interface MapperScan &#123; 查看MapperScannerRegistrar类，可以看到实现了 ImportBeanDefinitionRegistrar接口，重写了registerBeanDefinitions方法， 由于实现了该接口让该类成为了拥有注册bean的能力 image 进入registerBeanDefinitions方法 123456789@Overridepublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 拿到注解信息，内部实现是 LinkedHashMap AnnotationAttributes mapperScanAttrs = AnnotationAttributes .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName())); if (mapperScanAttrs != null) &#123; registerBeanDefinitions(mapperScanAttrs, registry); &#125;&#125; 进入第二个registerBeanDefinitions方法，可以看到又出现了ClassPathMapperScanner这个类，果不其然，还是调用了scanner.doScan(StringUtils.toStringArray(basePackages)); 这个方法完成了Mapper的注册 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void registerBeanDefinitions(AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry) &#123; // 获得spring的注册器registry ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); // this check is needed in Spring 3.1 if (resourceLoader != null) &#123; scanner.setResourceLoader(resourceLoader); &#125; Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(\"annotationClass\"); if (!Annotation.class.equals(annotationClass)) &#123; scanner.setAnnotationClass(annotationClass); &#125; Class&lt;?&gt; markerInterface = annoAttrs.getClass(\"markerInterface\"); if (!Class.class.equals(markerInterface)) &#123; scanner.setMarkerInterface(markerInterface); &#125; Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(\"nameGenerator\"); if (!BeanNameGenerator.class.equals(generatorClass)) &#123; scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass)); &#125; Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(\"factoryBean\"); if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123; scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass)); &#125; scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(\"sqlSessionTemplateRef\")); scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(\"sqlSessionFactoryRef\")); List&lt;String&gt; basePackages = new ArrayList&lt;&gt;(); // 如果配置了包路径则将入进去 basePackages.addAll( Arrays.stream(annoAttrs.getStringArray(\"value\")) .filter(StringUtils::hasText) .collect(Collectors.toList())); // 与上面功能一致 basePackages.addAll( Arrays.stream(annoAttrs.getStringArray(\"basePackages\")) .filter(StringUtils::hasText) .collect(Collectors.toList())); basePackages.addAll( Arrays.stream(annoAttrs.getClassArray(\"basePackageClasses\")) .map(ClassUtils::getPackageName) .collect(Collectors.toList())); scanner.registerFilters(); // 开始扫描包 scanner.doScan(StringUtils.toStringArray(basePackages));&#125; 总结 使用注解的方式集成Mybatis比xml配置的方式更为简洁，在Spring Boot项目中就是以这种方式来配置的 mybatis-spring-boot-autoconfigure 帮助我们完成了以下功能1234自动检测现有的DataSource。将创建并注册的一个实例的SqlSessionFactory传递一个数据源作为使用输入SqlSessionFactoryBean的。将创建并注册SqlSessionTemplate的实例从SqlSessionFactory中获取。自动扫描映射器，将它们链接到SqlSessionTemplate并将它们注册到Spring上下文，以便将它们注入到bean中。 参考http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析","date":"2018-12-18T12:56:00.000Z","updated":"2019-02-17T04:48:00.776Z","comments":true,"path":"2018/12/18/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析/","link":"","permalink":"http://www.songshuiyang.site/2018/12/18/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十八)Spring Mybatis集成之基于XML的配置原理解析/","excerpt":"","text":"前言在实际项目开发中，Mybatis一般都是与Spring集成配合使用的，Mybatis与Spring集成需要另一个项目https://github.com/mybatis/spring，该项目提供了Mybatis与Spring的集成实现，Mybatis与Spring的集成实现有两种方式，一种是通过XML配置，另一种是通过注解的信息进行配置，这一章节来介绍如何通过XML的方式来在Spring中集成Mybatis及实现原理 开始集成 在Spring环境中集成MyBatis 添加依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;31-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 添加xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 数据库连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver.encryption&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url.encryption&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;user.encryption&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password.encryption&#125;\"/&gt; &lt;property name=\"initialSize\" value=\"1\"/&gt; &lt;property name=\"minIdle\" value=\"1\"/&gt; &lt;property name=\"maxActive\" value=\"20\"/&gt; &lt;property name=\"maxWait\" value=\"60000\"/&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt; &lt;property name=\"validationQuery\" value=\"SELECT 1 FROM DUAL\"/&gt; &lt;property name=\"testWhileIdle\" value=\"true\"/&gt; &lt;property name=\"testOnBorrow\" value=\"false\"/&gt; &lt;property name=\"testOnReturn\" value=\"false\"/&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\"/&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"20\"/&gt; &lt;property name=\"filters\" value=\"stat,wall,log4j\"/&gt; &lt;property name=\"connectionProperties\"&gt; &lt;value&gt;clientEncoding=UTF-8&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.songsy.admin.entity\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt;&lt;/bean&gt;&lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/&gt; &lt;property name=\"basePackage\" value=\"com.songsy.admin.dao\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 实现解析dataSource 配置数据源 在Spring框架中有如下3种获得DataSource对象的方法: 从JNDI获得DataSource 从第三方的连接池获得DataSource 使用DriverManagerDataSource获得DataSource 用户可以根据需要选择不同的数据源配置使用 SqlSessionFactoryBean 来创建SqlSession工厂 在基本的 MyBatis 中,session 工厂可以使用 SqlSessionFactoryBuilder 来创建。而在 MyBatis-Spring 中,则使用 SqlSessionFactoryBean 来替代。 SqlSessionFactoryBean.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean, ApplicationListener&lt;ApplicationEvent&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(SqlSessionFactoryBean.class); private Resource configLocation; private Configuration configuration; private Resource[] mapperLocations; private DataSource dataSource; private TransactionFactory transactionFactory; private Properties configurationProperties; private SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); private SqlSessionFactory sqlSessionFactory; //EnvironmentAware requires spring 3.1 private String environment = SqlSessionFactoryBean.class.getSimpleName(); private boolean failFast; private Interceptor[] plugins; private TypeHandler&lt;?&gt;[] typeHandlers; private String typeHandlersPackage; private Class&lt;?&gt;[] typeAliases; private String typeAliasesPackage; private Class&lt;?&gt; typeAliasesSuperType; //issue #19. No default provider. private DatabaseIdProvider databaseIdProvider; private Class&lt;? extends VFS&gt; vfs; private Cache cache; private ObjectFactory objectFactory; private ObjectWrapperFactory objectWrapperFactory; @Override public void afterPropertiesSet() throws Exception &#123; notNull(dataSource, \"Property 'dataSource' is required\"); notNull(sqlSessionFactoryBuilder, \"Property 'sqlSessionFactoryBuilder' is required\"); state((configuration == null &amp;&amp; configLocation == null) || !(configuration != null &amp;&amp; configLocation != null), \"Property 'configuration' and 'configLocation' can not specified with together\"); this.sqlSessionFactory = buildSqlSessionFactory(); &#125; ... 要注意 SqlSessionFactoryBean 实现了 Spring 的 FactoryBean 接口,这就说明了由 Spring 最终创建的 bean 不是 SqlSessionFactoryBean 本身, 。 而是工厂类的 getObject()返回的方法的结果。这种情况下,Spring 将会在应用启动时为你 创建 SqlSessionFactory 对象,然后将它以 SqlSessionFactory 为名来存储。在 Java 中, 相同的代码是: 12SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();SqlSessionFactory sessionFactory = factoryBean.getObject(); 关注afterPropertiesSet 方法，这个方法将在Spring将所有的属性被初始化后调用，只需要实现InitializingBean接口就行，里面的buildSqlSessionFactory(); 方法，此方法是构建SqlSessionFactory的主体方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128protected SqlSessionFactory buildSqlSessionFactory() throws IOException &#123; Configuration configuration; XMLConfigBuilder xmlConfigBuilder = null; if (this.configuration != null) &#123; configuration = this.configuration; if (configuration.getVariables() == null) &#123; configuration.setVariables(this.configurationProperties); &#125; else if (this.configurationProperties != null) &#123; configuration.getVariables().putAll(this.configurationProperties); &#125; &#125; else if (this.configLocation != null) &#123; // 解析Mybatis配置文件 xmlConfigBuilder = new XMLConfigBuilder(this.configLocation.getInputStream(), null, this.configurationProperties); configuration = xmlConfigBuilder.getConfiguration(); &#125; else &#123; LOGGER.debug(() -&gt; \"Property 'configuration' or 'configLocation' not specified, using default MyBatis Configuration\"); configuration = new Configuration(); if (this.configurationProperties != null) &#123; configuration.setVariables(this.configurationProperties); &#125; &#125; if (this.objectFactory != null) &#123; configuration.setObjectFactory(this.objectFactory); &#125; if (this.objectWrapperFactory != null) &#123; configuration.setObjectWrapperFactory(this.objectWrapperFactory); &#125; if (this.vfs != null) &#123; configuration.setVfsImpl(this.vfs); &#125; // 基于包名注册别名 if (hasLength(this.typeAliasesPackage)) &#123; String[] typeAliasPackageArray = tokenizeToStringArray(this.typeAliasesPackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); for (String packageToScan : typeAliasPackageArray) &#123; configuration.getTypeAliasRegistry().registerAliases(packageToScan, typeAliasesSuperType == null ? Object.class : typeAliasesSuperType); LOGGER.debug(() -&gt; \"Scanned package: '\" + packageToScan + \"' for aliases\"); &#125; &#125; // 注册别名 if (!isEmpty(this.typeAliases)) &#123; for (Class&lt;?&gt; typeAlias : this.typeAliases) &#123; configuration.getTypeAliasRegistry().registerAlias(typeAlias); LOGGER.debug(() -&gt; \"Registered type alias: '\" + typeAlias + \"'\"); &#125; &#125; // 添加插件 if (!isEmpty(this.plugins)) &#123; for (Interceptor plugin : this.plugins) &#123; configuration.addInterceptor(plugin); LOGGER.debug(() -&gt; \"Registered plugin: '\" + plugin + \"'\"); &#125; &#125; // 基于包名注册类型处理器 if (hasLength(this.typeHandlersPackage)) &#123; String[] typeHandlersPackageArray = tokenizeToStringArray(this.typeHandlersPackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); for (String packageToScan : typeHandlersPackageArray) &#123; configuration.getTypeHandlerRegistry().register(packageToScan); LOGGER.debug(() -&gt; \"Scanned package: '\" + packageToScan + \"' for type handlers\"); &#125; &#125; // 添加类型处理器 if (!isEmpty(this.typeHandlers)) &#123; for (TypeHandler&lt;?&gt; typeHandler : this.typeHandlers) &#123; configuration.getTypeHandlerRegistry().register(typeHandler); LOGGER.debug(() -&gt; \"Registered type handler: '\" + typeHandler + \"'\"); &#125; &#125; if (this.databaseIdProvider != null) &#123;//fix #64 set databaseId before parse mapper xmls try &#123; configuration.setDatabaseId(this.databaseIdProvider.getDatabaseId(this.dataSource)); &#125; catch (SQLException e) &#123; throw new NestedIOException(\"Failed getting a databaseId\", e); &#125; &#125; if (this.cache != null) &#123; configuration.addCache(this.cache); &#125; if (xmlConfigBuilder != null) &#123; try &#123; xmlConfigBuilder.parse(); LOGGER.debug(() -&gt; \"Parsed configuration file: '\" + this.configLocation + \"'\"); &#125; catch (Exception ex) &#123; throw new NestedIOException(\"Failed to parse config resource: \" + this.configLocation, ex); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; if (this.transactionFactory == null) &#123; this.transactionFactory = new SpringManagedTransactionFactory(); &#125; configuration.setEnvironment(new Environment(this.environment, this.transactionFactory, this.dataSource)); // 解析Mapper if (!isEmpty(this.mapperLocations)) &#123; for (Resource mapperLocation : this.mapperLocations) &#123; if (mapperLocation == null) &#123; continue; &#125; try &#123; XMLMapperBuilder xmlMapperBuilder = new XMLMapperBuilder(mapperLocation.getInputStream(), configuration, mapperLocation.toString(), configuration.getSqlFragments()); xmlMapperBuilder.parse(); &#125; catch (Exception e) &#123; throw new NestedIOException(\"Failed to parse mapping resource: '\" + mapperLocation + \"'\", e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; LOGGER.debug(() -&gt; \"Parsed mapper file: '\" + mapperLocation + \"'\"); &#125; &#125; else &#123; LOGGER.debug(() -&gt; \"Property 'mapperLocations' was not specified or no matching resources found\"); &#125; return this.sqlSessionFactoryBuilder.build(configuration);&#125; 如下配置可以看到设置了数据源dataSource，指定了Mybatis的配置文件mybatis-config.xml，配置了别名包路径typeAliasesPackage，及Mapper文件的路径 1234567&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.songsy.admin.entity\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/&gt;&lt;/bean&gt; basePackage 属性是让你为映射器接口文件设置基本的包路径。 你可以使用分号或逗号 作为分隔符设置多于一个的包路径。每个映射器将会在指定的包路径中递归地被搜索到。 SqlSessionFactory 有一个单独的必须属性,就是 JDBC 的 DataSource。这可以是任意 的 DataSource,其配置应该和其它 Spring 数据库连接是一样的。 要注意这个配置文件不需要是一个完整的 MyBatis 配置。确切地说,任意环境,数据源 和 MyBatis 的事务管理器都会被忽略。SqlSessionFactoryBean 会创建它自己的,使用这些 值定制 MyBatis 的 Environment 时是需要的。 使用 MapperScannerConfigurer 来扫描Mapper 使用MapperScannerConfigurer来注册所有的映射器，它将会查找类路径下的映射器并自动将它们创建成MapperFactoryBean，把SqlSession或者SqlSessionFactory注入进去 image MapperScannerConfigurer实现了 BeanDefinitionRegistryPostProcessor接口，如果实现了该接口，那么说明在Spring Application初始化的时候将会调用下面的方法 1234567891011121314151617181920@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; if (this.processPropertyPlaceHolders) &#123; // 处理PropertyResourceConfigurers 加载属性配置问题 processPropertyPlaceHolders(); &#125; ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry); scanner.setAddToConfig(this.addToConfig); scanner.setAnnotationClass(this.annotationClass); scanner.setMarkerInterface(this.markerInterface); scanner.setSqlSessionFactory(this.sqlSessionFactory); scanner.setSqlSessionTemplate(this.sqlSessionTemplate); scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName); scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName); scanner.setResourceLoader(this.applicationContext); scanner.setBeanNameGenerator(this.nameGenerator); scanner.registerFilters(); scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));&#125; 从上面代码可以看到是通过ClassPathMapperScanner 这个类来实现解析的，重点关注scanner.scan() 方法，进入该方法，因为ClassPathMapperScanner继承了ClassPathBeanDefinitionScanner 所以这里调用的是ClassPathBeanDefinitionScanner这个类的scan()方法，可以看到第二行doScan(basePackages); 这个方法是ClassPathMapperScanner 的本地方法，该方法重载了ClassPathBeanDefinitionScanner的doScan方法 123456789101112public int scan(String... basePackages) &#123; int beanCountAtScanStart = this.registry.getBeanDefinitionCount(); doScan(basePackages); // Register annotation config processors, if necessary. if (this.includeAnnotationConfig) &#123; AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry); &#125; return (this.registry.getBeanDefinitionCount() - beanCountAtScanStart);&#125; 进入doScan(basePackages); 返回到ClassPathMapperScanner 这个类，这里是实现MapperScan的核心方法，可以看到通过Spring 的ClassPathBeanDefinitionScanner 类来生成BeanDefinitionHolder，这里是一个接口一个BeanDefinitionHolder 12345678910111213@Overridepublic Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; // 通过Spring 的ClassPathBeanDefinitionScanner 类来生成BeanDefinitionHolder Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages); if (beanDefinitions.isEmpty()) &#123; LOGGER.warn(() -&gt; \"No MyBatis mapper was found in '\" + Arrays.toString(basePackages) + \"' package. Please check your configuration.\"); &#125; else &#123; // 在这里完成对Spring Bean的属性配置 processBeanDefinitions(beanDefinitions); &#125; return beanDefinitions;&#125; 进入processBeanDefinitions(beanDefinitions); 方法，关注definition.setBeanClass(this.mapperFactoryBean.getClass());这一行，可以看到这里设置了Mapper类的Bean，实际的源头Bean是MapperFactoryBean 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123; GenericBeanDefinition definition; for (BeanDefinitionHolder holder : beanDefinitions) &#123; definition = (GenericBeanDefinition) holder.getBeanDefinition(); String beanClassName = definition.getBeanClassName(); LOGGER.debug(() -&gt; \"Creating MapperFactoryBean with name '\" + holder.getBeanName() + \"' and '\" + beanClassName + \"' mapperInterface\"); // the mapper interface is the original class of the bean // but, the actual class of the bean is MapperFactoryBean definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); // issue #59 // 设置了Mapper类的Bean，实际的源头Bean是MapperFactoryBean，Mapper是由该bean生成 definition.setBeanClass(this.mapperFactoryBean.getClass()); definition.getPropertyValues().add(\"addToConfig\", this.addToConfig); boolean explicitFactoryUsed = false; if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123; definition.getPropertyValues().add(\"sqlSessionFactory\", new RuntimeBeanReference(this.sqlSessionFactoryBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionFactory != null) &#123; definition.getPropertyValues().add(\"sqlSessionFactory\", this.sqlSessionFactory); explicitFactoryUsed = true; &#125; if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\"); &#125; definition.getPropertyValues().add(\"sqlSessionTemplate\", new RuntimeBeanReference(this.sqlSessionTemplateBeanName)); explicitFactoryUsed = true; &#125; else if (this.sqlSessionTemplate != null) &#123; if (explicitFactoryUsed) &#123; LOGGER.warn(() -&gt; \"Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.\"); &#125; definition.getPropertyValues().add(\"sqlSessionTemplate\", this.sqlSessionTemplate); explicitFactoryUsed = true; &#125; if (!explicitFactoryUsed) &#123; LOGGER.debug(() -&gt; \"Enabling autowire by type for MapperFactoryBean with name '\" + holder.getBeanName() + \"'.\"); definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE); &#125; &#125;&#125; MapperScannerConfigurer不需要指定SqlSessionFactory 或SqlSessionTemplate,MapperScannerConfigurer 将会创建 MapperFactoryBean之后自动装配，如果你使用了一个以上的 DataSource ,那么自动装配可能会失效 。这种情况下你可以使用 SqlSessionFactoryBeanName 或 SqlSessionTemplateBeanName 属性来设置正确的 Bean 名 称来使用 下面来看一下MapperFactoryBean，可以看到getObject()方法调用的是 SqlSessionDaoSupport类中 SqlSessionTemplate 类的getMapper(this.mapperInterface);方法，该Bean将会在这里返回了Mapper接口的动态代理类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class MapperFactoryBean&lt;T&gt; extends SqlSessionDaoSupport implements FactoryBean&lt;T&gt; &#123; private Class&lt;T&gt; mapperInterface; private boolean addToConfig = true; public MapperFactoryBean() &#123; //intentionally empty &#125; public MapperFactoryBean(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; /** * &#123;@inheritDoc&#125; */ @Override protected void checkDaoConfig() &#123; super.checkDaoConfig(); notNull(this.mapperInterface, \"Property 'mapperInterface' is required\"); Configuration configuration = getSqlSession().getConfiguration(); if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123; try &#123; configuration.addMapper(this.mapperInterface); &#125; catch (Exception e) &#123; logger.error(\"Error while adding the mapper '\" + this.mapperInterface + \"' to configuration.\", e); throw new IllegalArgumentException(e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; &#125; /** * &#123;@inheritDoc&#125; */ @Override public T getObject() throws Exception &#123; return getSqlSession().getMapper(this.mapperInterface); &#125; /** * &#123;@inheritDoc&#125; */ @Override public Class&lt;T&gt; getObjectType() &#123; return this.mapperInterface; &#125; /** * &#123;@inheritDoc&#125; */ @Override public boolean isSingleton() &#123; return true; &#125; //------------- mutators -------------- /** * Sets the mapper interface of the MyBatis mapper * * @param mapperInterface class of the interface */ public void setMapperInterface(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; /** * Return the mapper interface of the MyBatis mapper * * @return class of the interface */ public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; /** * If addToConfig is false the mapper will not be added to MyBatis. This means * it must have been included in mybatis-config.xml. * &lt;p&gt; * If it is true, the mapper will be added to MyBatis in the case it is not already * registered. * &lt;p&gt; * By default addToConfig is true. * * @param addToConfig a flag that whether add mapper to MyBatis or not */ public void setAddToConfig(boolean addToConfig) &#123; this.addToConfig = addToConfig; &#125; /** * Return the flag for addition into MyBatis config. * * @return true if the mapper will be added to MyBatis in the case it is not already * registered. */ public boolean isAddToConfig() &#123; return addToConfig; &#125;&#125; MapperFactoryBean 创建的代理类实现了 UserMapper 接口,并且注入到应用程序中。 因为代理创建在运行时环境中(Runtime,译者注),那么指定的映射器必须是一个接口,而不是一个具体的实现类 SqlSessionTemplate 是MyBatis-Spring的核心。这个类负责管理MyBatis的SqlSession,调用MyBatis的SQL方法。SqlSessionTemplate是线程安全的，可以被多个DAO所共享使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class SqlSessionTemplate implements SqlSession, DisposableBean &#123; private final SqlSessionFactory sqlSessionFactory; private final ExecutorType executorType; // SqlSession代理 private final SqlSession sqlSessionProxy; private final PersistenceExceptionTranslator exceptionTranslator; /** * Constructs a Spring managed SqlSession with the &#123;@code SqlSessionFactory&#125; * provided as an argument. * * @param sqlSessionFactory a factory of SqlSession */ public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; this(sqlSessionFactory, sqlSessionFactory.getConfiguration().getDefaultExecutorType()); &#125; /** * Constructs a Spring managed SqlSession with the &#123;@code SqlSessionFactory&#125; * provided as an argument and the given &#123;@code ExecutorType&#125; * &#123;@code ExecutorType&#125; cannot be changed once the &#123;@code SqlSessionTemplate&#125; * is constructed. * * @param sqlSessionFactory a factory of SqlSession * @param executorType an executor type on session */ public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType) &#123; this(sqlSessionFactory, executorType, new MyBatisExceptionTranslator( sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), true)); &#125; /** * Constructs a Spring managed &#123;@code SqlSession&#125; with the given * &#123;@code SqlSessionFactory&#125; and &#123;@code ExecutorType&#125;. * A custom &#123;@code SQLExceptionTranslator&#125; can be provided as an * argument so any &#123;@code PersistenceException&#125; thrown by MyBatis * can be custom translated to a &#123;@code RuntimeException&#125; * The &#123;@code SQLExceptionTranslator&#125; can also be null and thus no * exception translation will be done and MyBatis exceptions will be * thrown * * @param sqlSessionFactory a factory of SqlSession * @param executorType an executor type on session * @param exceptionTranslator a translator of exception */ public SqlSessionTemplate(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) &#123; notNull(sqlSessionFactory, \"Property 'sqlSessionFactory' is required\"); notNull(executorType, \"Property 'executorType' is required\"); this.sqlSessionFactory = sqlSessionFactory; this.executorType = executorType; this.exceptionTranslator = exceptionTranslator; // 形成SqlSession代理类 this.sqlSessionProxy = (SqlSession) newProxyInstance( SqlSessionFactory.class.getClassLoader(), new Class[] &#123; SqlSession.class &#125;, new SqlSessionInterceptor()); &#125; /** * SqlSession 代理类，MyBatis路由方法调用得到有Spring Transaction的SqlSession * Proxy needed to route MyBatis method calls to the proper SqlSession got * from Spring's Transaction Manager * It also unwraps exceptions thrown by &#123;@code Method#invoke(Object, Object...)&#125; to * pass a &#123;@code PersistenceException&#125; to the &#123;@code PersistenceExceptionTranslator&#125;. */ private class SqlSessionInterceptor implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 每次新生成一个SqlSession，一次调用一个SqlSession SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try &#123; Object result = method.invoke(sqlSession, args); // 判断是否事务 if (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) &#123; // force commit even on non-dirty sessions because some databases require // a commit/rollback before calling close() // 没有使用事务 sqlSession.commit(true); &#125; return result; &#125; catch (Throwable t) &#123; Throwable unwrapped = unwrapThrowable(t); if (SqlSessionTemplate.this.exceptionTranslator != null &amp;&amp; unwrapped instanceof PersistenceException) &#123; // release the connection to avoid a deadlock if the translator is no loaded. See issue #22 closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped); if (translated != null) &#123; unwrapped = translated; &#125; &#125; throw unwrapped; &#125; finally &#123; if (sqlSession != null) &#123; // 关闭SqlSession closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); &#125; &#125; &#125; &#125; ... SqlSessionTemplate 自动装配实现 TODO 总结 SqlSessionFactory 为什么能被Spring Ioc容器管理的原因是因为FactoryBean这个接口，这是个支持泛型的接口，Spring 将会在应用启动时为你 创建SqlSessionFactory对象,然后将它以 SqlSessionFactory为名来存储。当把这个bean注入到Spring中去了以后，IOC容器中的其他类型就可以拿到SqlSession实例了，就可以进行相关的SQL执行任务了。 当SqlSessionFactory 被Spring管理之后，如果单纯的使用Mybatis的话，是使用session.getMapper(UserMapper.class)来获取mapper的，但是现在在Spring环境中一般都是通过如下形式来调用的 12@Autowireprivate UserMapper userMapper; 所以Spring Mybatis 通过MapperScannerConfigurer 来将各个UserMapper RoleMapper...注册成为Spring bean (MapperFactoryBean)，由MapperFactoryBean来生成Mapper的代理类对象 参考http://www.mybatis.org/spring/zh/factorybean.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十七)结果映射DefaultResultSetHandler","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十七)结果映射DefaultResultSetHandler","date":"2018-12-09T02:52:00.000Z","updated":"2018-12-09T03:08:38.880Z","comments":true,"path":"2018/12/09/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十七)结果映射DefaultResultSetHandler/","link":"","permalink":"http://www.songshuiyang.site/2018/12/09/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十七)结果映射DefaultResultSetHandler/","excerpt":"","text":"前言上一章节介绍了Mybatis的参数绑定处理，本章将介绍Mybatis的结果映射过程，有执行就应该有结果，那Mybaits是怎样处理Jdbc返回的结果，并将结果映射成我们需要的对象呢？ 结果映射解析原生Jdbc结果映射 还是老套路，在介绍Mybatis结果映射处理之前先来看一下原生Jdbc结果映射是怎样处理的，可以看到通过迭代resultSet并根据列名来获取的值1234567resultSet=statement.executeQuery(sql);while (resultSet.next())&#123; String loginName=resultSet.getString(\"loginName\"); String userName=resultSet.getString(\"userName\"); String password=resultSet.getString(\"password\"); int sex=resultSet.getInt(\"sex\");&#125; Mybatis结果映射解析下面还是通过一个示例来介绍 测试用例 123456789101112// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);User user = new User();user.setUsername(\"admin\");System.out.println(userMapper1.selectSelective(user)); xml 配置 1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 还是打入断点进入SimpleExecutor 的 doQuery 方法 12345678910111213141516@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 新建一个StatementHandler // 这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); // StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 上一章节已经完成了stmt = prepareStatement(handler, ms.getStatementLog());操作，这一章节来处理return handler.&lt;E&gt;query(stmt, resultHandler); 进入该方法之后转到 RoutingStatementHandler 之后又转入 PreparedStatementHandler 进入query 方法，如下如可以看到又出现了Jdbc代码ps.execute(); 123456@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; ps.execute(); return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; execute 完成之后就是处理结果集了resultSetHandler.&lt;E&gt; handleResultSets(ps)， 进入该方法之后进入到DefaultResultSetHandler 类的handleResultSets 方法，以下代码可以知道数据结果都是存放在multipleResults 里面 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 处理ResultSets 并返回结果集 * @param stmt * @return * @throws SQLException */@Overridepublic List&lt;Object&gt; handleResultSets(Statement stmt) throws SQLException &#123; ErrorContext.instance().activity(\"handling results\").object(mappedStatement.getId()); // 存放所有数据 final List&lt;Object&gt; multipleResults = new ArrayList&lt;Object&gt;(); int resultSetCount = 0; ResultSetWrapper rsw = getFirstResultSet(stmt); // 由MappedStatement 获取ResultMap List&lt;ResultMap&gt; resultMaps = mappedStatement.getResultMaps(); // 一般resultMaps里只有一个元素 int resultMapCount = resultMaps.size(); validateResultMapsCount(rsw, resultMapCount); while (rsw != null &amp;&amp; resultMapCount &gt; resultSetCount) &#123; ResultMap resultMap = resultMaps.get(resultSetCount); // 处理结果集 handleResultSet(rsw, resultMap, multipleResults, null); rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; &#125; String[] resultSets = mappedStatement.getResulSets(); if (resultSets != null) &#123; while (rsw != null &amp;&amp; resultSetCount &lt; resultSets.length) &#123; ResultMapping parentMapping = nextResultMaps.get(resultSets[resultSetCount]); if (parentMapping != null) &#123; String nestedResultMapId = parentMapping.getNestedResultMapId(); ResultMap resultMap = configuration.getResultMap(nestedResultMapId); handleResultSet(rsw, resultMap, null, parentMapping); &#125; rsw = getNextResultSet(stmt); cleanUpAfterHandlingResultSet(); resultSetCount++; &#125; &#125; return collapseSingleResultList(multipleResults);&#125; 继续跳入handleResultSet(rsw, resultMap, multipleResults, null); ，可以看到这行代码multipleResults.add(defaultResultHandler.getResultList()); 将结果赋值到了multipleResults，下面的方法对resultHandler 进行了判断，我们现在是没有指定ResultHandler所以这里该值为null，将跳入默认的ResultHandler 处理类 12345678910111213141516171819202122232425// 处理结果集private void handleResultSet(ResultSetWrapper rsw, ResultMap resultMap, List&lt;Object&gt; multipleResults, ResultMapping parentMapping) throws SQLException &#123; try &#123; if (parentMapping != null) &#123; handleRowValues(rsw, resultMap, null, RowBounds.DEFAULT, parentMapping); &#125; else &#123; if (resultHandler == null) &#123; // 如果没有resultHandler // 新建DefaultResultHandler DefaultResultHandler defaultResultHandler = new DefaultResultHandler(objectFactory); // 调用自己的handleRowValues handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null); // 得到记录的list multipleResults.add(defaultResultHandler.getResultList()); &#125; else &#123; //如果有resultHandler handleRowValues(rsw, resultMap, resultHandler, rowBounds, null); &#125; &#125; &#125; finally &#123; //最后别忘了关闭结果集，这个居然出bug了 // issue #228 (close resultsets) closeResultSet(rsw.getResultSet()); &#125;&#125; 跳入handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);，这里有个是否有嵌套的结果集判读，当然如果是有的话肯定要特殊处理的 12345678910private void handleRowValues(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; // 是否有嵌套的结果集 if (resultMap.hasNestedResultMaps()) &#123; ensureNoRowBounds(); checkResultHandler(); handleRowValuesForNestedResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping); &#125; else &#123; handleRowValuesForSimpleResultMap(rsw, resultMap, resultHandler, rowBounds, parentMapping); &#125;&#125; 我们现在这没有嵌套，所以else进入handleRowValuesForSimpleResultMap 方法，可以看到这里是一行一行的处理结果，ResultSetWrapper 是对ResultSet的包装 123456789101112131415161718192021/** * 见方法名知 ResultMap根据处理行数据 * @param rsw * @param resultMap * @param resultHandler 结果存放在这，里面是一个List&lt;Object&gt; * @param rowBounds * @param parentMapping * @throws SQLException */private void handleRowValuesForSimpleResultMap(ResultSetWrapper rsw, ResultMap resultMap, ResultHandler resultHandler, RowBounds rowBounds, ResultMapping parentMapping) throws SQLException &#123; DefaultResultContext resultContext = new DefaultResultContext(); skipRows(rsw.getResultSet(), rowBounds); // 一行一行赋值 rsw.getResultSet().next() Jdbc while (shouldProcessMoreRows(resultContext, rowBounds) &amp;&amp; rsw.getResultSet().next()) &#123; ResultMap discriminatedResultMap = resolveDiscriminatedResultMap(rsw.getResultSet(), resultMap, null); // 获取一行数据 Object rowValue = getRowValue(rsw, discriminatedResultMap); storeObject(resultHandler, resultContext, rowValue, parentMapping, rsw.getResultSet()); &#125;&#125; 重点关注Object rowValue = getRowValue(rsw, discriminatedResultMap); 这里的处理，这里是处理一行的数据 12345678910111213141516171819202122// 核心，取得一行的值private Object getRowValue(ResultSetWrapper rsw, ResultMap resultMap) throws SQLException &#123; // 实例化ResultLoaderMap(延迟加载器) final ResultLoaderMap lazyLoader = new ResultLoaderMap(); // 调用自己的createResultObject,内部就是new一个对象(如果是简单类型，new完也把值赋进去) Object resultObject = createResultObject(rsw, resultMap, lazyLoader, null); if (resultObject != null &amp;&amp; !typeHandlerRegistry.hasTypeHandler(resultMap.getType())) &#123; // 一般不是简单类型不会有typehandler,这个if会进来 final MetaObject metaObject = configuration.newMetaObject(resultObject); boolean foundValues = !resultMap.getConstructorResultMappings().isEmpty(); if (shouldApplyAutomaticMappings(resultMap, false)) &#123; // 自动映射咯 // 这里把每个列的值都赋到相应的字段里去了 foundValues = applyAutomaticMappings(rsw, resultMap, metaObject, null) || foundValues; &#125; foundValues = applyPropertyMappings(rsw, resultMap, metaObject, lazyLoader, null) || foundValues; foundValues = lazyLoader.size() &gt; 0 || foundValues; resultObject = foundValues ? resultObject : null; return resultObject; &#125; return resultObject;&#125; 跳入applyAutomaticMappings 方法，可以看到这里是结果映射的核心代码，巧妙的用TypeHandler取得结果，根据columnName从ResultSet取值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 自动映射 * @param rsw 对 ResultSet 的包装 * @param resultMap ResultMap * @param metaObject 返回的对象 * @param columnPrefix * @return * @throws SQLException */private boolean applyAutomaticMappings(ResultSetWrapper rsw, ResultMap resultMap, MetaObject metaObject, String columnPrefix) throws SQLException &#123; // 得到表列名list final List&lt;String&gt; unmappedColumnNames = rsw.getUnmappedColumnNames(resultMap, columnPrefix); boolean foundValues = false; // 一列一列数据循环赋值 for (String columnName : unmappedColumnNames) &#123; String propertyName = columnName; if (columnPrefix != null &amp;&amp; !columnPrefix.isEmpty()) &#123; // When columnPrefix is specified, // ignore columns without the prefix. if (columnName.toUpperCase(Locale.ENGLISH).startsWith(columnPrefix)) &#123; propertyName = columnName.substring(columnPrefix.length()); &#125; else &#123; continue; &#125; &#125; final String property = metaObject.findProperty(propertyName, configuration.isMapUnderscoreToCamelCase()); if (property != null &amp;&amp; metaObject.hasSetter(property)) &#123; final Class&lt;?&gt; propertyType = metaObject.getSetterType(property); if (typeHandlerRegistry.hasTypeHandler(propertyType)) &#123; // 根据实体类字段类型获取对应的TypeHandler final TypeHandler&lt;?&gt; typeHandler = rsw.getTypeHandler(propertyType, columnName); // 巧妙的用TypeHandler取得结果，根据columnName从ResultSet取值 final Object value = typeHandler.getResult(rsw.getResultSet(), columnName); // issue #377, call setter on nulls if (value != null || configuration.isCallSettersOnNulls()) &#123; if (value != null || !propertyType.isPrimitive()) &#123; // 然后巧妙的用反射来设置到对象 metaObject.setValue(property, value); &#125; foundValues = true; &#125; &#125; &#125; &#125; return foundValues;&#125; 又出现了TypeHandler，下面的方法出现了Jdbc代码return rs.getString(columnName); 12345678public class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; 在此Mybatis结果映射处理完成 总结 Mybatis的参数绑定和结果映射最终处理都是通过不同的TypeHandler来处理的，Mybatis也支持自定义TypeHandler 但一般情况Mybatis提供的就可以应付常见需求了","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十六)参数绑定DefaultParameterHandler","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十六)参数绑定DefaultParameterHandler","date":"2018-12-09T01:17:00.000Z","updated":"2018-12-09T02:11:19.314Z","comments":true,"path":"2018/12/09/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十六)参数绑定DefaultParameterHandler/","link":"","permalink":"http://www.songshuiyang.site/2018/12/09/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十六)参数绑定DefaultParameterHandler/","excerpt":"","text":"前言Mybatis 一个重要功能是参数的自动绑定，Mybatis是怎样帮我们做好Jdbc的参数绑定的呢，这一章节来介绍Mybatis的参数绑定 参数绑定解析原生Jdbc参数绑定 在介绍Mybatis参数绑定之前先来看一下原生Jdbc参数绑定是怎样处理的，从下面的Jdbc代码可以看到，是通过下标顺序来设置参数值的，一个问号一个参数 12345String sql = \"insert into user(sno,name,age)values(?,?,?)\";//定义一个要执行的SQL语句PreparedStatement ps = connection.prepareStatement(sql);ps.setString(1,student.getSno());//设置SQL语句的第一个参数ps.setString(2,student.getName());//设置SQL语句的第二个参数ps.setInt(3,student.getAge());//设置SQL语句的第三个参数 Mybatis参数绑定解析下面通过一个示例来介绍 测试用例，下面的代码是通过User对象来查找对应的数据，user设置了两个属性值id 和 admin 12345678910111213// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);User user = new User();user.setId(1);user.setUsername(\"admin\");System.out.println(userMapper1.selectSelective(user)); xml 配置 1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 从第十五章可以知道，由传入的参数对象配合SqlSource 完成了动态Sql的处理， 下面是得到的结果 SELECT * FROM sys_user WHERE id = ? AND username = ?，这里得到了Jdbc的代码，现在要Mybatis要处理的就是这两个问号? image 还是打入断点进入SimpleExecutor 的 doQuery 方法，在这里可以看到这里新建了一个 StatementHandler 这个是SQL语句的执行器，在由来调度sql的参数绑定，sql执行，sql结果映射，现在重点关注stmt = prepareStatement(handler, ms.getStatementLog()); 这一行，看方法名称就大概知道这里是sql之前预备处理 12345678910111213141516@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 新建一个StatementHandler // 这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); // StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 进入stmt = prepareStatement(handler, ms.getStatementLog()); 方法，这里主要是对Connection 和 sql参数 进行了设置，继续跳入handler.parameterize(stmt); 123456789private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException &#123; Statement stmt; Connection connection = getConnection(statementLog); // 调用StatementHandler.prepare 设置Connection stmt = handler.prepare(connection); // 调用StatementHandler.parameterize 设置参数 handler.parameterize(stmt); return stmt;&#125; 进入handler.parameterize(stmt);方法之后，转到 RoutingStatementHandler 之后又转入 PreparedStatementHandler，一系列的转发之后进入DefaultParameterHandler 类的setParameters 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class DefaultParameterHandler implements ParameterHandler &#123; private final TypeHandlerRegistry typeHandlerRegistry; private final MappedStatement mappedStatement; // 参数对象 private final Object parameterObject; // BoundSql private BoundSql boundSql; // 万能Configuration private Configuration configuration; public DefaultParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; this.mappedStatement = mappedStatement; this.configuration = mappedStatement.getConfiguration(); this.typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry(); this.parameterObject = parameterObject; this.boundSql = boundSql; &#125; @Override public Object getParameterObject() &#123; return parameterObject; &#125; // 设置参数 @Override public void setParameters(PreparedStatement ps) throws SQLException &#123; ErrorContext.instance().activity(\"setting parameters\").object(mappedStatement.getParameterMap().getId()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings != null) &#123; // 循环设参数 for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; // 如果不是OUT，才设进去 Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; // issue #448 ask first for additional params // 若有额外的参数, 设为额外的参数 value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; // 若参数为null，直接设null value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; // 若参数有相应的TypeHandler，直接设object value = parameterObject; &#125; else &#123; // 除此以外，MetaObject.getValue反射取得值设进去 MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); &#125; // 类型处理器 TypeHandler typeHandler = parameterMapping.getTypeHandler(); JdbcType jdbcType = parameterMapping.getJdbcType(); if (value == null &amp;&amp; jdbcType == null) &#123; // 不同类型的set方法不同，所以委派给子类的setParameter方法 jdbcType = configuration.getJdbcTypeForNull(); &#125; // 用在类型处理器进行赋值 typeHandler.setParameter(ps, i + 1, value, jdbcType); &#125; &#125; &#125; &#125;&#125; 进入setParameters 方法之后，可以看到通过我们之前的BoundSql 得到 ParamterMappings对象，如下图可以知道是两个属性，然后下面的操作就是依次赋值了，不过这里有个特殊的地方，也是Mybatis参数绑定高明之处，就是赋值的操作是通过TypeHandler 来赋值的 image 继续跳入typeHandler.setParameter(ps, i + 1, value, jdbcType); 来到 IntegerTypeHandler的 setNonNullParameter方法，有没有看到曙光ps.setInt(i, parameter); ,在这里做了Jdbc的参数绑定操作 1234567891011121314151617public class IntegerTypeHandler extends BaseTypeHandler&lt;Integer&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType) throws SQLException &#123; ps.setInt(i, parameter); &#125;``` * 同理第二个参数是字符类型，所以跳到`StringTypeHandler````javapublic class StringTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; 在此完成Mybatis参数绑定 总结 Mybatis的参数绑定是通过循环 ParamterMappings对象来依次对对象赋值的，具体赋值工作是对应的TypeHandler 来处理的，当然不同类型有不同的处理类","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十五)动态Sql实现之BoundSql","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十五)动态Sql实现之BoundSql","date":"2018-12-08T05:52:00.000Z","updated":"2018-12-08T06:00:22.990Z","comments":true,"path":"2018/12/08/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十五)动态Sql实现之BoundSql/","link":"","permalink":"http://www.songshuiyang.site/2018/12/08/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十五)动态Sql实现之BoundSql/","excerpt":"","text":"前言上一章节介绍了SqlSource ，这一章节来介绍 BoundSql，BoundSql 由 SqlSource 生产，BoundSql 存放了动态sql处理后的private String sql;,动态内容处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数 BoundSql 介绍 下面是 BoundSql 的源码，里面又对其变量的介绍 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 绑定的SQL,是从SqlSource而来，将动态内容都处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数 * * An actual SQL String got form an &#123;@link SqlSource&#125; after having processed any dynamic content. * The SQL may have SQL placeholders \"?\" and an list (ordered) of an parameter mappings * with the additional information for each parameter (at least the property name of the input object to read * the value from). * &lt;/br&gt; * Can also have additional parameters that are created by the dynamic language (for loops, bind...). * @author Clinton Begin */public class BoundSql &#123; // 处理完成得到的SQL语句字符串，其中包括?,还有绑定的参数 private String sql; // 参数映射对象 private List&lt;ParameterMapping&gt; parameterMappings; // 外面传入的sql参数 private Object parameterObject; // 额外参数？ private Map&lt;String, Object&gt; additionalParameters; // 参数元数据 private MetaObject metaParameters; public BoundSql(Configuration configuration, String sql, List&lt;ParameterMapping&gt; parameterMappings, Object parameterObject) &#123; this.sql = sql; this.parameterMappings = parameterMappings; this.parameterObject = parameterObject; this.additionalParameters = new HashMap&lt;String, Object&gt;(); this.metaParameters = configuration.newMetaObject(additionalParameters); &#125; public String getSql() &#123; return sql; &#125; public List&lt;ParameterMapping&gt; getParameterMappings() &#123; return parameterMappings; &#125; public Object getParameterObject() &#123; return parameterObject; &#125; public boolean hasAdditionalParameter(String name) &#123; return metaParameters.hasGetter(name); &#125; public void setAdditionalParameter(String name, Object value) &#123; metaParameters.setValue(name, value); &#125; public Object getAdditionalParameter(String name) &#123; return metaParameters.getValue(name); &#125;&#125; BoundSql 构造 BoundSql 由 SqlSource 生产，SqlSource 有四个实现类，但最常用的是 DynamicSqlSource，下面是其源码，可以看到只有一个方法public BoundSql getBoundSql(Object parameterObject) 12345678910111213141516171819202122232425262728293031323334/** * 动态SQL源码 * @author Clinton Begin */public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 下面通过一个例子来解析 BoundSql 的构造 xml 配置文件1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试用例，user对象给id和username赋值了对象 12345678910111213// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper1 = sqlSession.getMapper(UserMapper.class);User user = new User();user.setId(1);user.setUsername(\"admin\");System.out.println(userMapper1.selectSelective(user)); 打好断点进入到 CachingExecutor 的query方法，第一行可以看到 BoundSql 是由MappedStatement 的方法得到的，getBoundSql 方法只传入了参数对象，在这里是User对象 1234567 @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; BoundSql boundSql = ms.getBoundSql(parameterObject);//query时传入一个cachekey参数 CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql); return query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); &#125; 进入ms.getBoundSql(parameterObject); 方法，重点关注 BoundSql boundSql = sqlSource.getBoundSql(parameterObject);，没错在这里出现了我们的SqlSource对象 1234567891011121314151617181920 public BoundSql getBoundSql(Object parameterObject) &#123;//其实就是调用sqlSource.getBoundSql BoundSql boundSql = sqlSource.getBoundSql(parameterObject); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings == null || parameterMappings.isEmpty()) &#123; boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject); &#125; // check for nested result maps in parameter mappings (issue #30) for (ParameterMapping pm : boundSql.getParameterMappings()) &#123; String rmId = pm.getResultMapId(); if (rmId != null) &#123; ResultMap rm = configuration.getResultMap(rmId); if (rm != null) &#123; hasNestedResultMaps |= rm.hasNestedResultMaps(); &#125; &#125; &#125; return boundSql; &#125; 进入sqlSource.getBoundSql(parameterObject) 方法，这个方法是DynamicSqlSource 的唯一方法，当然SqlSource作用就是得到绑定后的BoundSql对象 12345678910111213141516171819202122232425262728293031323334/** * 动态SQL源码 * @author Clinton Begin */public class DynamicSqlSource implements SqlSource &#123; private Configuration configuration; private SqlNode rootSqlNode; public DynamicSqlSource(Configuration configuration, SqlNode rootSqlNode) &#123; this.configuration = configuration; this.rootSqlNode = rootSqlNode; &#125; // 得到绑定的SQL @Override public BoundSql getBoundSql(Object parameterObject) &#123; // 生成一个动态上下文 DynamicContext context = new DynamicContext(configuration, parameterObject); // 这里SqlNode.apply只是将$&#123;&#125;这种参数替换掉，并没有替换#&#123;&#125;这种参数 rootSqlNode.apply(context); // 调用SqlSourceBuilder SqlSourceBuilder sqlSourceParser = new SqlSourceBuilder(configuration); Class&lt;?&gt; parameterType = parameterObject == null ? Object.class : parameterObject.getClass(); // SqlSourceBuilder.parse,注意这里返回的是StaticSqlSource,解析完了就把那些参数都替换成?了，也就是最基本的JDBC的SQL写法 SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); // 看似是又去递归调用SqlSource.getBoundSql，其实因为是StaticSqlSource，所以没问题，不是递归调用 BoundSql boundSql = sqlSource.getBoundSql(parameterObject); for (Map.Entry&lt;String, Object&gt; entry : context.getBindings().entrySet()) &#123; boundSql.setAdditionalParameter(entry.getKey(), entry.getValue()); &#125; return boundSql; &#125;&#125; 先看rootSqlNode.apply(context); 这行代码，打开断点进入会发现这里依次调用list里每个元素的apply方法，这里是实现动态SQL的关键，如果有嵌套的话也会嵌套执行里面的apply方法 image 静态sqlNode 的apply方法就是直接 appendSql 123456789101112131415public class StaticTextSqlNode implements SqlNode &#123; private String text; public StaticTextSqlNode(String text) &#123; this.text = text; &#125; @Override public boolean apply(DynamicContext context) &#123; //将文本加入context context.appendSql(text); return true; &#125;&#125; if SQL节点的apply方法 会做一个判断，如果 test=&quot;id != null&quot; 这个表达式为true就会 contents.apply(context); 添加到DynamicContext中，DynamicContext 内部成员 StringBuilder sqlBuilder 来存放解析后的sql 1234567891011121314151617181920212223242526/** * if SQL节点 * */public class IfSqlNode implements SqlNode &#123; private ExpressionEvaluator evaluator; private String test; private SqlNode contents; public IfSqlNode(SqlNode contents, String test) &#123; this.test = test; this.contents = contents; this.evaluator = new ExpressionEvaluator(); &#125; @Override public boolean apply(DynamicContext context) &#123; // 如果满足条件，则apply，并返回true if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125; rootSqlNode.apply(context); 处理完成之后就会得到拼接后的sql如下图所示，可以看到这里SqlNode.apply只是将${}这种参数替换掉，并没有替换#{}这种参数 image SqlSource sqlSource = sqlSourceParser.parse(context.getSql(), parameterType, context.getBindings()); 这个方法是解析完了就把那些参数都替换成?，也就是最基本的JDBC的SQL写法，这个方法在以后章节将介绍 最终的到的结果(BoundSql)如下图所示 image 总结 BoundSql 由 SqlSource 构造而成，最终得到的是JDBC的SQL，而实现动态Sql的关键是 各个SqlNode的 apply方法 通过源码可以看到Mybatis动态sql设计巧妙，分工明确","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十四)动态Sql实现之SqlSource","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十四)动态Sql实现之SqlSource","date":"2018-12-08T03:52:00.000Z","updated":"2018-12-08T04:36:31.695Z","comments":true,"path":"2018/12/08/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十四)动态Sql实现之SqlSource/","link":"","permalink":"http://www.songshuiyang.site/2018/12/08/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十四)动态Sql实现之SqlSource/","excerpt":"","text":"前言从本章开始将介绍Mybatis是怎样实现动态sql的，介绍动态sql实现之前先介绍几个重要对象SqlSource，SqlNode ，BoundSql ,本章开始介绍SqlSource对象， 前面第九章及第十章介绍了SqlSource的构造过程，在xml配置的select update节点的sql将会构造成 SqlSource，其 SqlSource 由一组SqlNode组成，现在来看一下SqlSource能做什么 SqlSource 分析 查看SqlSource 是个接口，但他只有一个方法就是BoundSql getBoundSql(Object parameterObject); ，方法参数是sql的参数，然后根据参数来构造成BoundSql，所以他的作用是根据参数对象生产BoundSql，那么BoundSql有什么用呢，下一章节将介绍其作用 12345public interface SqlSource &#123; BoundSql getBoundSql(Object parameterObject);&#125; 下图可以看到SqlSource 其实现类，主要有4种类型 image DynamicSqlSource:处理动态sql语句。 RawSqlSource：处理静态sql语句，其内部装饰StaticSqlSource。 StaticSqlSource：处理静态sql，无论是静态sql，还是动态sql，最终的处理结果，都是静态sql。 ProviderSqlSource:处理注解Annotation形式的sql。 VelocitySqlSource:只是Mybatis的一个测试类 举个栗子，下面是一个动态sql的xml 1234567891011121314151617&lt;select id=\"selectSelective\" resultType=\"org.apache.songsy.entity.User\" parameterType=\"org.apache.songsy.entity.User\"&gt; SELECT * FROM sys_user &lt;where&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=\"password != null\"&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 那么解析成SqlSource将会是下面的样子，SqlSource 是存放在MappedStatement对象的，可以看到SqlSource是一堆嵌套的SqlNode组成 image 总结 有图有栗子来理解SqlSource 就很形象了，有了SqlSource就相当于生产商品有基本原材料了，当然原材料(SqlNode)种类有很多，Mybatis会根据用户的需求(**Mapper.xml) 来采购不同的原材料","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十三)基于Mapper的二级缓存","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十三)基于Mapper的二级缓存","date":"2018-12-07T13:49:00.000Z","updated":"2018-12-08T02:48:43.703Z","comments":true,"path":"2018/12/07/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十三)基于Mapper的二级缓存/","link":"","permalink":"http://www.songshuiyang.site/2018/12/07/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十三)基于Mapper的二级缓存/","excerpt":"","text":"前言mybatis的二级缓存主要是在Executor对象上来做文章，当mybatis发现你在mybatis.xml配置文件中设置了cacheEnabled=true时，mybatis在创建sqlsession时创建Executor对象，同时会对Executor加上装饰者【CacheExecutor】。CacheExecutor对于查询请求，会判断application级别的二级缓存是否有缓存结果，如果有查询结果则直接返回，如果没有再交给查询器Executor实现类，也就是【SimpleExecutor】来执行查询。再就是缓存结果，返回给用户。 二级缓存的使用 配置 mybatis-config.xml1234&lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;&lt;/settings&gt; 配置Mapper xml文件，加上&lt;cache/&gt;1&lt;cache/&gt; 测试代码 12345678910111213// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession1 = sqlSessionFactory.openSession();SqlSession sqlSession2 = sqlSessionFactory.openSession();UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);// 测试二级缓存System.out.println(userMapper1.selectByPrimaryKey(1));System.out.println(userMapper2.selectByPrimaryKey(1)); 打好断点进入，这里是二级缓存的处理，从下面可以看到缓存是存放在MappedStatement 对象中的，所以说二级缓存是基于Mapper的，这是与多个SqlSession能够共享缓存的关键 1234567891011121314151617181920public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; Cache cache = ms.getCache(); // 默认情况下是没有开启缓存的(二级缓存).要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: &lt;cache/&gt; // 简单的说，就是先查CacheKey，查不到再委托给实际的执行器去查 if (cache != null) &#123; flushCacheIfRequired(ms); if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123; ensureNoOutParams(ms, parameterObject, boundSql); @SuppressWarnings(\"unchecked\") List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key); if (list == null) &#123; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116 &#125; return list; &#125; &#125; return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125; 可以看到缓存放在tcm 变量上，打开 TransactionalCacheManager 类 123456789101112131415161718192021222324252627282930313233343536373839404142public class TransactionalCacheManager &#123; //管理了许多TransactionalCache private Map&lt;Cache, TransactionalCache&gt; transactionalCaches = new HashMap&lt;Cache, TransactionalCache&gt;(); public void clear(Cache cache) &#123; getTransactionalCache(cache).clear(); &#125; //得到某个TransactionalCache的值 public Object getObject(Cache cache, CacheKey key) &#123; return getTransactionalCache(cache).getObject(key); &#125; public void putObject(Cache cache, CacheKey key, Object value) &#123; getTransactionalCache(cache).putObject(key, value); &#125; //提交时全部提交 public void commit() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.commit(); &#125; &#125; //回滚时全部回滚 public void rollback() &#123; for (TransactionalCache txCache : transactionalCaches.values()) &#123; txCache.rollback(); &#125; &#125; private TransactionalCache getTransactionalCache(Cache cache) &#123; TransactionalCache txCache = transactionalCaches.get(cache); if (txCache == null) &#123; txCache = new TransactionalCache(cache); transactionalCaches.put(cache, txCache); &#125; return txCache; &#125;&#125; 二级缓存过期策略 映射语句文件中的所有 select 语句将会被缓存。 映射语句文件中的所有 insert,update 和 delete 语句会刷新缓存。 缓存会使用 Least Recently Used(LRU,最近最少使用的)算法来收回。 根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序 来刷新。 缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。 缓存会被视为是 read/write(可读/可写)的缓存,意味着对象检索不是共享的,而 且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。 二级缓存配置所有的这些属性都可以通过缓存元素的属性来修改。比如:123456789101112131415&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt;``` * 这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会 导致冲突。可用的收回策略有: 默认的是 LRU。```xmlLRU – 最近最少使用的:移除最长时间不被使用的对象。FIFO – 先进先出:按对象进入缓存的顺序来移除它们。SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval(刷新间隔)可以被设置为任意的正整数,而且它们代表一个合理的毫秒 形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。 size(引用数目)可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的 可用内存资源数目。默认值是 1024。 readOnly(只读)属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓 存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存 会返回缓存对象的拷贝(通过序列化) 。这会慢一些,但是安全,因此默认是 false。 二级缓存设计 image 总结 mybatis的二级缓存主要是在Executor对象上来做文章，当mybatis发现你在mybatis.xml配置文件中设置了cacheEnabled=true时，mybatis在创建sqlsession时创建Executor对象，同时会对Executor加上装饰者【CacheExecutor】。CacheExecutor对于查询请求，会判断application级别的二级缓存是否有缓存结果，如果有查询结果则直接返回，如果没有再交给查询器Executor实现类，也就是【SimpleExecutor】来执行查询。再就是缓存结果，返回给用户。 避免使用二级缓存，如果出现联合查询语句，如果其中一张表发生了变化，就会出现脏数据的问题，因为缓存节点是根据namespace 参考： http://www.mybatis.org/mybatis-3/zh","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十二)基于SqlSession的一级缓存","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十二)基于SqlSession的一级缓存","date":"2018-12-06T13:49:00.000Z","updated":"2018-12-06T15:00:28.368Z","comments":true,"path":"2018/12/06/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十二)基于SqlSession的一级缓存/","link":"","permalink":"http://www.songshuiyang.site/2018/12/06/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十二)基于SqlSession的一级缓存/","excerpt":"","text":"前言MyBatis提供了一级缓存、二级缓存 这两种缓存机制，能够很好地处理和维护缓存，以提高系统的性能。本章的内容是介绍MyBatis的一级缓存，深入源码，解析MyBatis一级缓存的实现原理，二级缓存将在下一章介绍 一级缓存的使用 下面来通过代码来实践一级缓存，看看第二次查询是否使用了缓存 1234567891011// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(\"第一次查询: \"+userMapper.selectByPrimaryKey(1));System.out.println(\"第二次查询: \"+userMapper.selectByPrimaryKey(1)); 上面的代码是用SqlSession获取了UserMapper，然后用UserMapper 进行了两次查询，打好断点进入MapperProxy 的invoke 方法 12345678910111213141516@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法 // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行 if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; // 这里优化了，去缓存中找MapperMethod final MapperMethod mapperMethod = cachedMapperMethod(method); //执行 return mapperMethod.execute(sqlSession, args);&#125; 进入mapperMethod.execute(sqlSession, args) 之后跳呀跳进入BaseExecutor 的 query 方法，这个看到会创建一个CacheKey 123456789 @Override public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException &#123; // 得到绑定sql BoundSql boundSql = ms.getBoundSql(parameter); // 创建缓存Key CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); // 查询 return query(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125; 下面来看一下这个key是怎么生成的 12345678910111213141516171819202122232425262728293031323334353637383940//创建缓存Key@Overridepublic CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123; if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; CacheKey cacheKey = new CacheKey(); // MyBatis 对于其 Key 的生成采取规则为：[mappedStementId + offset + limit + SQL + queryParams + environment]生成一个哈希码 cacheKey.update(ms.getId()); cacheKey.update(Integer.valueOf(rowBounds.getOffset())); cacheKey.update(Integer.valueOf(rowBounds.getLimit())); cacheKey.update(boundSql.getSql()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic // 模仿DefaultParameterHandler的逻辑,不再重复，请参考DefaultParameterHandler for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; value = parameterObject; &#125; else &#123; MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); &#125; cacheKey.update(value); &#125; &#125; if (configuration.getEnvironment() != null) &#123; // issue #176 cacheKey.update(configuration.getEnvironment().getId()); &#125; return cacheKey;&#125; 得到CacheKey 之后 跳入return query(ms, parameter, rowBounds, resultHandler, key, boundSql); 在这里对一级缓存进行了处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445@SuppressWarnings(\"unchecked\")@Overridepublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId()); //如果已经关闭，报错 if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; //先清局部缓存，再查询.但仅查询堆栈为0，才清。为了处理递归调用 if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123; clearLocalCache(); &#125; List&lt;E&gt; list; try &#123; //加一,这样递归调用到上面的时候就不会再清局部缓存了 queryStack++; //先根据cachekey从localCache去查 list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) &#123; //若查到localCache缓存，处理localOutputParameterCache handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); &#125; else &#123; //从数据库查 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); &#125; &#125; finally &#123; //清空堆栈 queryStack--; &#125; if (queryStack == 0) &#123; //延迟加载队列中所有元素 for (DeferredLoad deferredLoad : deferredLoads) &#123; deferredLoad.load(); &#125; // issue #601 //清空延迟加载队列 deferredLoads.clear(); if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // issue #482 //如果是STATEMENT，清本地缓存 clearLocalCache(); &#125; &#125; return list;&#125; 重点是下面几行代码，可以看到先根据cachekey从localCache去查，如果有就返回缓存里的数据，没有就从数据库里查 123456789// 先根据cachekey从localCache去查list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;if (list != null) &#123; // 若查到localCache缓存，处理localOutputParameterCache handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);&#125; else &#123; // 从数据库查 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);&#125; 下面来看localCache 的本体PerpetualCache, 从下面的代码就可以看见其内部实现就是Map&lt;Object, Object&gt; cache 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * 永久缓存 * 一旦存入就一直保持 * @author Clinton Begin */public class PerpetualCache implements Cache &#123; // 每个永久缓存有一个ID来识别 private String id; // 内部就是一个HashMap,所有方法基本就是直接调用HashMap的方法 private Map&lt;Object, Object&gt; cache = new HashMap&lt;Object, Object&gt;(); public PerpetualCache(String id) &#123; this.id = id; &#125; @Override public String getId() &#123; return id; &#125; @Override public int getSize() &#123; return cache.size(); &#125; @Override public void putObject(Object key, Object value) &#123; cache.put(key, value); &#125; @Override public Object getObject(Object key) &#123; return cache.get(key); &#125; @Override public Object removeObject(Object key) &#123; return cache.remove(key); &#125; @Override public void clear() &#123; cache.clear(); &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return null; &#125; @Override public boolean equals(Object o) &#123; //只要id相等就认为两个cache相同 if (getId() == null) &#123; throw new CacheException(\"Cache instances require an ID.\"); &#125; if (this == o) &#123; return true; &#125; if (!(o instanceof Cache)) &#123; return false; &#125; Cache otherCache = (Cache) o; return getId().equals(otherCache.getId()); &#125; @Override public int hashCode() &#123; if (getId() == null) &#123; throw new CacheException(\"Cache instances require an ID.\"); &#125; return getId().hashCode(); &#125;&#125; 现在回到主线，因为第一次查询一级缓存是没有数据的，所以继续执行queryFromDatabase，从下面的方法可以看到在这里实现了缓存的加入操作localCache.putObject(key, list); 12345678910111213141516171819// 从数据库查private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; List&lt;E&gt; list; // 先向缓存中放入占位符 localCache.putObject(key, EXECUTION_PLACEHOLDER); try &#123; list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql); &#125; finally &#123; // 最后删除占位符 localCache.removeObject(key); &#125; // 加入缓存 localCache.putObject(key, list); // 如果是存储过程，OUT参数也加入缓存 if (ms.getStatementType() == StatementType.CALLABLE) &#123; localOutputParameterCache.putObject(key, parameter); &#125; return list;&#125; 一级缓存的生命周期有多长 MyBatis在开启一个数据库会话时，会 创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。 iamge 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用； 123456789101112131415161718192021@Overridepublic void close(boolean forceRollback) &#123; try &#123; try &#123; rollback(forceRollback); &#125; finally &#123; if (transaction != null) &#123; transaction.close(); &#125; &#125; &#125; catch (SQLException e) &#123; // Ignore. There's nothing that can be done at this point. log.warn(\"Unexpected exception on closing transaction. Cause: \" + e); &#125; finally &#123; transaction = null; deferredLoads = null; localCache = null; localOutputParameterCache = null; closed = true; &#125;&#125; 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用； 1234567@Overridepublic void clearLocalCache() &#123; if (!closed) &#123; localCache.clear(); localOutputParameterCache.clear(); &#125;&#125; SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用； 1234567891011// SqlSession.update/insert/delete会调用此方法@Overridepublic int update(MappedStatement ms, Object parameter) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity(\"executing an update\").object(ms.getId()); if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; //先清局部缓存，再更新，如何更新交由子类，模板方法模式 clearLocalCache(); return doUpdate(ms, parameter);&#125; 缓存分析为什么要使用一级缓存使用缓存是为了提高查询效率，减少资源消费，如果我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同 所以为了解决这一问题，减少资源的浪费，MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了 如下图所示，MyBatis会在一次会话的表示—-一个SqlSession对象中创建一个本地缓存(local cache)，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。 image 一级缓存查询时序图 image CacheKey的定义 Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。 现在最核心的问题出现了：怎样来确定一次查询的特征值？ MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询 123451. 传入的statementId，对于MyBatis而言，你要使用它，必须需要一个statementId，它代表着你将执行什么样的Sql；2. MyBatis自身提供的分页功能是通过RowBounds来实现的，它通过rowBounds.offset和rowBounds.limit来过滤查询出来的结果集，这种分页功能是基于查询结果的再过滤，而不是进行数据库的物理分页；3. 由于MyBatis底层还是依赖于JDBC实现的，那么，对于两次完全一模一样的查询，MyBatis要保证对于底层JDBC而言，也是完全一致的查询才行。而对于JDBC而言，两次查询，只要传入给JDBC的SQL语句完全一致，传入的参数也完全一致，就认为是两次查询是完全一致的。 下面是创建CacheKey的代码 12345678910111213141516171819202122232425262728293031323334353637383940//创建缓存Key@Overridepublic CacheKey createCacheKey(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql) &#123; if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; CacheKey cacheKey = new CacheKey(); // MyBatis 对于其 Key 的生成采取规则为：[mappedStementId + offset + limit + SQL + queryParams + environment]生成一个哈希码 cacheKey.update(ms.getId()); cacheKey.update(Integer.valueOf(rowBounds.getOffset())); cacheKey.update(Integer.valueOf(rowBounds.getLimit())); cacheKey.update(boundSql.getSql()); List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry(); // mimic DefaultParameterHandler logic // 模仿DefaultParameterHandler的逻辑,不再重复，请参考DefaultParameterHandler for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; value = parameterObject; &#125; else &#123; MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); &#125; cacheKey.update(value); &#125; &#125; if (configuration.getEnvironment() != null) &#123; // issue #176 cacheKey.update(configuration.getEnvironment().getId()); &#125; return cacheKey;&#125; 总结 如果缓存中有数据就不用从数据库中获取，大大提高系统性能。 一级缓存的作用级别是Session级别的，因为一个Session中存放一个Executor。而一级缓存放在Executor。 参考：https://blog.csdn.net/chenyao1994/article/details/79233725","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十一)MapperXML映射文件OGNL表达式","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十一)MapperXML映射文件OGNL表达式","date":"2018-12-06T10:40:00.000Z","updated":"2018-12-06T12:43:45.110Z","comments":true,"path":"2018/12/06/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十一)MapperXML映射文件OGNL表达式/","link":"","permalink":"http://www.songshuiyang.site/2018/12/06/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十一)MapperXML映射文件OGNL表达式/","excerpt":"","text":"基本介绍OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。 Struts2框架使用OGNL作为默认的表达式语言 OGNL是一种比EL强大很多倍的语言，支持对象方法调用，支持静态方法和字段访问，支持赋值操作等等。xwork提供了OGNL表达式。其jar包为ognl-x.x.x.jar。 MyBatis常用OGNL表达式123456789101112131415•e1 or e2•e1 and e2•e1 == e2,e1 eq e2•e1 != e2,e1 neq e2•e1 lt e2：小于•e1 lte e2：小于等于，其他gt（大于）,gte（大于等于）•e1 in e2•e1 not in e2•e1 + e2,e1 * e2,e1/e2,e1 - e2,e1%e2•!e,not e：非，求反•e.method(args)调用对象方法•e.property对象属性值•e1[ e2 ]按索引取值，List,数组和Map•@class@method(args)调用类的静态方法•@class@field调用类的静态字段值 MyBatis中可以使用OGNL的地方有两处 动态SQL表达式中 ${param}参数中 上面这两处地方在MyBatis中处理的时候都是使用OGNL处理的。 下面通过举例来说明这两种情况的用法。 动态SQL表达式中 下面代码中test的值会使用OGNL计算结果。12345678&lt;select id=\"xxx\" ...&gt; select id,name,... from country &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; name like concat('%', #&#123;name&#125;, '%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 通用 like 查询及的value值会使用OGNL计算123456789&lt;select id=\"xxx\" ...&gt; select id,name,... from country &lt;bind name=\"nameLike\" value=\"'%' + name + '%'\"/&gt; &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; name like #&#123;nameLike&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 通用Mapper中支持一种UUID的主键1&lt;bind name=\"username_bind\" value='@java.util.UUID@randomUUID().toString().replace(\"-\", \"\")' /&gt; ${param}参数中1234567891011121314&lt;select id=\"xxx\" ...&gt; select id,name,... from country &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; name like '$&#123;'%' + name + '%'&#125;' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这里注意写的是$&#123;'%' + name + '%'&#125; ，而不是%$&#123;name&#125;% ，这两种方式的结果一样，但是处理过程不一样。 在MyBatis中处理$&#123;&#125;的时候，只是使用OGNL计算这个结果值，然后替换SQL中对应的$&#123;xxx&#125; ，OGNL处理的只是$&#123;这里的表达式&#125;。 这里表达式可以是OGNL支持的所有表达式，可以写的很复杂，可以调用静态方法返回值，也可以调用静态的属性值。 参考： https://www.jb51.net/article/116160.htm","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(十)MapperXML映射文件构建SqlNode","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(十)MapperXML映射文件构建SqlNode","date":"2018-12-06T02:40:00.000Z","updated":"2018-12-06T12:28:47.867Z","comments":true,"path":"2018/12/06/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十)MapperXML映射文件构建SqlNode/","link":"","permalink":"http://www.songshuiyang.site/2018/12/06/backend/mybatis/sourceCodeAnalysis/Mybatis源码(十)MapperXML映射文件构建SqlNode/","excerpt":"","text":"前言上一章节介绍了SqlSource的构造过程，SqlSource 由一堆SqlNode构成，本章来介绍SqlNode的构造，如下图可以看到SqlNode的主要成员 image 源码解析SqlNode 还是回到 parseScriptNode 方法，关注List&lt;SqlNode&gt; contents = parseDynamicTags(context); 这个方法会把 select|insert|update|delete 这些标签的sql解析成一堆SqlNode, 包括静态SqlNode 和动态SqlNode(可见上图) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public SqlSource parseScriptNode() &#123; // 获取SqlNode List List&lt;SqlNode&gt; contents = parseDynamicTags(context); MixedSqlNode rootSqlNode = new MixedSqlNode(contents); SqlSource sqlSource = null; if (isDynamic) &#123; sqlSource = new DynamicSqlSource(configuration, rootSqlNode); &#125; else &#123; sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); &#125; return sqlSource;&#125;List&lt;SqlNode&gt; parseDynamicTags(XNode node) &#123; // 一行一个SqlNode List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;(); NodeList children = node.getNode().getChildNodes(); for (int i = 0; i &lt; children.getLength(); i++) &#123; XNode child = node.newXNode(children.item(i)); // 如果节点类型CDATA或者是文本，构造一个TextSqlNode或StaticTextSqlNode if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123; String data = child.getStringBody(\"\"); TextSqlNode textSqlNode = new TextSqlNode(data); if (textSqlNode.isDynamic()) &#123; contents.add(textSqlNode); isDynamic = true; &#125; else &#123; contents.add(new StaticTextSqlNode(data)); &#125; &#125; else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; // 如果是xml标签 trim|where|set... String nodeName = child.getNode().getNodeName(); // 得到动态sql标签处理类 trim|where|set... NodeHandler handler = nodeHandlers(nodeName); if (handler == null) &#123; throw new BuilderException(\"Unknown element &lt;\" + nodeName + \"&gt; in SQL statement.\"); &#125; // 解析动态结点 handler.handleNode(child, contents); isDynamic = true; &#125; &#125; return contents;&#125;NodeHandler nodeHandlers(String nodeName) &#123; Map&lt;String, NodeHandler&gt; map = new HashMap&lt;String, NodeHandler&gt;(); map.put(\"trim\", new TrimHandler()); map.put(\"where\", new WhereHandler()); map.put(\"set\", new SetHandler()); map.put(\"foreach\", new ForEachHandler()); map.put(\"if\", new IfHandler()); map.put(\"choose\", new ChooseHandler()); map.put(\"when\", new IfHandler()); map.put(\"otherwise\", new OtherwiseHandler()); map.put(\"bind\", new BindHandler()); return map.get(nodeName);&#125; SqlNode 是 Mybatis 实现动态sql的核心，下面来看看一些常用节点的的处理，IfSqlNode 节点 12345678910111213141516171819202122232425/** * if SQL节点 * @author Clinton Begin */public class IfSqlNode implements SqlNode &#123; private ExpressionEvaluator evaluator; private String test; private SqlNode contents; public IfSqlNode(SqlNode contents, String test) &#123; this.test = test; this.contents = contents; this.evaluator = new ExpressionEvaluator(); &#125; @Override public boolean apply(DynamicContext context) &#123; // 如果满足条件，则apply，并返回true if (evaluator.evaluateBoolean(test, context.getBindings())) &#123; contents.apply(context); return true; &#125; return false; &#125;&#125; ForEachSqlNode 节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * foreach SQL节点 * @author Clinton Begin */public class ForEachSqlNode implements SqlNode &#123; public static final String ITEM_PREFIX = \"__frch_\"; private ExpressionEvaluator evaluator; private String collectionExpression; private SqlNode contents; private String open; private String close; private String separator; private String item; private String index; private Configuration configuration; public ForEachSqlNode(Configuration configuration, SqlNode contents, String collectionExpression, String index, String item, String open, String close, String separator) &#123; this.evaluator = new ExpressionEvaluator(); this.collectionExpression = collectionExpression; this.contents = contents; this.open = open; this.close = close; this.separator = separator; this.index = index; this.item = item; this.configuration = configuration; &#125; @Override public boolean apply(DynamicContext context) &#123; Map&lt;String, Object&gt; bindings = context.getBindings(); //解析collectionExpression-&gt;iterable,核心用的ognl final Iterable&lt;?&gt; iterable = evaluator.evaluateIterable(collectionExpression, bindings); if (!iterable.iterator().hasNext()) &#123; return true; &#125; boolean first = true; //加上( applyOpen(context); int i = 0; for (Object o : iterable) &#123; DynamicContext oldContext = context; if (first) &#123; context = new PrefixedContext(context, \"\"); &#125; else if (separator != null) &#123; context = new PrefixedContext(context, separator); &#125; else &#123; context = new PrefixedContext(context, \"\"); &#125; int uniqueNumber = context.getUniqueNumber(); // Issue #709 if (o instanceof Map.Entry) &#123; @SuppressWarnings(\"unchecked\") Map.Entry&lt;Object, Object&gt; mapEntry = (Map.Entry&lt;Object, Object&gt;) o; applyIndex(context, mapEntry.getKey(), uniqueNumber); applyItem(context, mapEntry.getValue(), uniqueNumber); &#125; else &#123; //索引 applyIndex(context, i, uniqueNumber); //加上一个元素 applyItem(context, o, uniqueNumber); &#125; contents.apply(new FilteredDynamicContext(configuration, context, index, item, uniqueNumber)); if (first) &#123; first = !((PrefixedContext) context).isPrefixApplied(); &#125; context = oldContext; i++; &#125; //加上) applyClose(context); return true; &#125; ... MixedSqlNode 这个Node比较特殊，获得的SqlNode会以list放在 MixedSqlNode中 123456789101112131415161718192021/** * 混合SQL节点 * @author Clinton Begin */public class MixedSqlNode implements SqlNode &#123; // 组合模式，拥有一个SqlNode的List private List&lt;SqlNode&gt; contents; public MixedSqlNode(List&lt;SqlNode&gt; contents) &#123; this.contents = contents; &#125; @Override public boolean apply(DynamicContext context) &#123; // 依次调用list里每个元素的apply for (SqlNode sqlNode : contents) &#123; sqlNode.apply(context); &#125; return true; &#125;&#125; selectByPrimaryKey 解析成果，见下图 123456&lt;select id=\"selectByPrimaryKey\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.Integer\" &gt; select &lt;include refid=\"Base_Column_List\" /&gt; from sys_role where id = #&#123;id,jdbcType=INTEGER&#125;&lt;/select&gt; image updateByPrimaryKeySelective 解析成果，见下图123456789101112131415161718192021222324252627282930313233343536&lt;update id=\"updateByPrimaryKeySelective\" parameterType=\"org.apache.songsy.entity.Role\" &gt; update sys_role &lt;set &gt; &lt;if test=\"roleName != null\" &gt; role_name = #&#123;roleName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"roleCode != null\" &gt; role_code = #&#123;roleCode,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"roleDescribe != null\" &gt; role_describe = #&#123;roleDescribe,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"createdDate != null\" &gt; created_date = #&#123;createdDate,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test=\"createdBy != null\" &gt; created_by = #&#123;createdBy,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"lastModifiedDate != null\" &gt; last_modified_date = #&#123;lastModifiedDate,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test=\"lastModifiedBy != null\" &gt; last_modified_by = #&#123;lastModifiedBy,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"remarks != null\" &gt; remarks = #&#123;remarks,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=\"status != null\" &gt; status = #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=\"enable != null\" &gt; enable = #&#123;enable,jdbcType=BIT&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125;&lt;/update&gt; image 总结","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(九)MapperXML映射文件构建SqlSource","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(九)MapperXML映射文件构建SqlSource","date":"2018-12-01T02:40:00.000Z","updated":"2018-12-08T04:00:11.584Z","comments":true,"path":"2018/12/01/backend/mybatis/sourceCodeAnalysis/Mybatis源码(九)MapperXML映射文件构建SqlSource/","link":"","permalink":"http://www.songshuiyang.site/2018/12/01/backend/mybatis/sourceCodeAnalysis/Mybatis源码(九)MapperXML映射文件构建SqlSource/","excerpt":"","text":"前言上一章节介绍了select|insert|update|delete 这些sql标签会解析成MappedStatement对象，MappedStatement 对象的重点属性是SqlSource，本章来介绍SqlSource的构造过程，其最终执行的sql字符串就是由SqlSource提供的。 源码解析SqlSource 类下图可以看到其实现类，主要有4种类型 image DynamicSqlSource:处理动态sql语句。 RawSqlSource：处理静态sql语句，其内部装饰StaticSqlSource。 StaticSqlSource：处理静态sql，无论是静态sql，还是动态sql，最终的处理结果，都是静态sql。 ProviderSqlSource:处理注解Annotation形式的sql。 VelocitySqlSource:只是Mybatis的一个测试类 DynamicSqlSource和StaticSqlSource的最大区别在于：StaticSqlSource的String sql，可以直接获取使用，而DynamicSqlSource的String sql需要逐一根据条件解析并拼接出最终的sql，方能使用。 Mybatis解析sql的时机Mybatis对于用户在XXMapper.xml文件中配置的sql解析主要分为2个时机 静态sql：程序启动的时候解析 动态sql：用户进行查询等sql相关操作的时候解析 什么是静态sql，动态sql？ 如果select|insert|update|delete标签体内包含XML标签或者select|insert|update|delete标签体内的sql文本中包含${}参数占位符则为动态sql，否则为静态sql。 如下面的2个sql中，第一个为动态sql，第二个为静态sql 1234567891011&lt;select id=\"selectUser\" parameterType=\"com.fit.bean.User\" resultType=\"com.fit.bean.User\" useCache=\"true\"&gt; select id, name from tab_user where id = $&#123;id&#125; &lt;if test=\"name!=null and name!=''\"&gt; and name=#&#123;name&#125; &lt;/if&gt; and 1 = 1&lt;/select&gt; &lt;select id=\"selectUserById\" parameterType=\"int\" resultType=\"com.fit.bean.User\" useCache=\"true\"&gt; select id, name from tab_user where id = #&#123;id&#125;&lt;/select&gt; 进入 parseStatementNode 方法，关注SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);这一行，打好断点进入langDriver.createSqlSource(configuration, context, parameterTypeClass); 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public void parseStatementNode() &#123; String id = context.getStringAttribute(\"id\"); String databaseId = context.getStringAttribute(\"databaseId\"); //如果databaseId不匹配，退出 if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123; return; &#125; //暗示驱动程序每次批量返回的结果行数 Integer fetchSize = context.getIntAttribute(\"fetchSize\"); //超时时间 Integer timeout = context.getIntAttribute(\"timeout\"); //引用外部 parameterMap,已废弃 String parameterMap = context.getStringAttribute(\"parameterMap\"); //参数类型 String parameterType = context.getStringAttribute(\"parameterType\"); Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType); //引用外部的 resultMap(高级功能) String resultMap = context.getStringAttribute(\"resultMap\"); //结果类型 String resultType = context.getStringAttribute(\"resultType\"); //脚本语言,mybatis3.2的新功能 String lang = context.getStringAttribute(\"lang\"); //得到语言驱动 LanguageDriver langDriver = getLanguageDriver(lang); Class&lt;?&gt; resultTypeClass = resolveClass(resultType); //结果集类型，FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE 中的一种 String resultSetType = context.getStringAttribute(\"resultSetType\"); //语句类型, STATEMENT|PREPARED|CALLABLE 的一种 StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString())); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); //获取命令类型(select|insert|update|delete) String nodeName = context.getNode().getNodeName(); SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH)); boolean isSelect = sqlCommandType == SqlCommandType.SELECT; boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect); //是否要缓存select结果 boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect); //仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 //这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false); // Include Fragments before parsing //解析之前先解析&lt;include&gt;SQL片段 XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant); includeParser.applyIncludes(context.getNode()); // Parse selectKey after includes and remove them. //解析之前先解析&lt;selectKey&gt; processSelectKeyNodes(id, parameterTypeClass, langDriver); // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed) //解析成SqlSource，一般是DynamicSqlSource SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass); String resultSets = context.getStringAttribute(\"resultSets\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyProperty = context.getStringAttribute(\"keyProperty\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyColumn = context.getStringAttribute(\"keyColumn\"); KeyGenerator keyGenerator; String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); if (configuration.hasKeyGenerator(keyStatementId)) &#123; keyGenerator = configuration.getKeyGenerator(keyStatementId); &#125; else &#123; keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\", configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? new Jdbc3KeyGenerator() : new NoKeyGenerator(); &#125; //又去调助手类 builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets); &#125; 进入langDriver.createSqlSource方法后默认是进入 XMLLanguageDriver类 createSqlSource 方法，可以看到又调用了XMLScriptBuilder 类的builder.parseScriptNode() 方法 1234567891011121314151617181920212223242526272829303132333435public class XMLLanguageDriver implements LanguageDriver &#123; @Override public ParameterHandler createParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) &#123; //返回默认的参数处理器 return new DefaultParameterHandler(mappedStatement, parameterObject, boundSql); &#125; @Override public SqlSource createSqlSource(Configuration configuration, XNode script, Class&lt;?&gt; parameterType) &#123; //用XML脚本构建器解析 XMLScriptBuilder builder = new XMLScriptBuilder(configuration, script, parameterType); return builder.parseScriptNode(); &#125; //注解方式构建mapper @Override public SqlSource createSqlSource(Configuration configuration, String script, Class&lt;?&gt; parameterType) &#123; // issue #3 if (script.startsWith(\"&lt;script&gt;\")) &#123; XPathParser parser = new XPathParser(script, false, configuration.getVariables(), new XMLMapperEntityResolver()); return createSqlSource(configuration, parser.evalNode(\"/script\"), parameterType); &#125; else &#123; // issue #127 script = PropertyParser.parse(script, configuration.getVariables()); TextSqlNode textSqlNode = new TextSqlNode(script); //一种是动态，一种是原始 if (textSqlNode.isDynamic()) &#123; return new DynamicSqlSource(configuration, textSqlNode); &#125; else &#123; return new RawSqlSource(configuration, script, parameterType); &#125; &#125; &#125;&#125; 进入XMLScriptBuilder类 根据 isDynamic 变量来返回 DynamicSqlSource 对象和 RawSqlSource 对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224public class XMLScriptBuilder extends BaseBuilder &#123; private XNode context; private boolean isDynamic; private Class&lt;?&gt; parameterType; public XMLScriptBuilder(Configuration configuration, XNode context) &#123; this(configuration, context, null); &#125; public XMLScriptBuilder(Configuration configuration, XNode context, Class&lt;?&gt; parameterType) &#123; super(configuration); this.context = context; this.parameterType = parameterType; &#125; public SqlSource parseScriptNode() &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(context); MixedSqlNode rootSqlNode = new MixedSqlNode(contents); SqlSource sqlSource = null; if (isDynamic) &#123; sqlSource = new DynamicSqlSource(configuration, rootSqlNode); &#125; else &#123; sqlSource = new RawSqlSource(configuration, rootSqlNode, parameterType); &#125; return sqlSource; &#125; List&lt;SqlNode&gt; parseDynamicTags(XNode node) &#123; // 一行一个SqlNode List&lt;SqlNode&gt; contents = new ArrayList&lt;SqlNode&gt;(); NodeList children = node.getNode().getChildNodes(); for (int i = 0; i &lt; children.getLength(); i++) &#123; XNode child = node.newXNode(children.item(i)); // 如果节点类型CDATA或者是文本，构造一个TextSqlNode或StaticTextSqlNode if (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE || child.getNode().getNodeType() == Node.TEXT_NODE) &#123; String data = child.getStringBody(\"\"); TextSqlNode textSqlNode = new TextSqlNode(data); if (textSqlNode.isDynamic()) &#123; contents.add(textSqlNode); isDynamic = true; &#125; else &#123; contents.add(new StaticTextSqlNode(data)); &#125; &#125; else if (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; // 如果是xml标签 trim|where|set... String nodeName = child.getNode().getNodeName(); // 得到动态sql标签处理类 trim|where|set... NodeHandler handler = nodeHandlers(nodeName); if (handler == null) &#123; throw new BuilderException(\"Unknown element &lt;\" + nodeName + \"&gt; in SQL statement.\"); &#125; // 解析动态结点 handler.handleNode(child, contents); isDynamic = true; &#125; &#125; return contents; &#125; NodeHandler nodeHandlers(String nodeName) &#123; Map&lt;String, NodeHandler&gt; map = new HashMap&lt;String, NodeHandler&gt;(); map.put(\"trim\", new TrimHandler()); map.put(\"where\", new WhereHandler()); map.put(\"set\", new SetHandler()); map.put(\"foreach\", new ForEachHandler()); map.put(\"if\", new IfHandler()); map.put(\"choose\", new ChooseHandler()); map.put(\"when\", new IfHandler()); map.put(\"otherwise\", new OtherwiseHandler()); map.put(\"bind\", new BindHandler()); return map.get(nodeName); &#125; private interface NodeHandler &#123; void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents); &#125; private class BindHandler implements NodeHandler &#123; public BindHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; final String name = nodeToHandle.getStringAttribute(\"name\"); final String expression = nodeToHandle.getStringAttribute(\"value\"); final VarDeclSqlNode node = new VarDeclSqlNode(name, expression); targetContents.add(node); &#125; &#125; private class TrimHandler implements NodeHandler &#123; public TrimHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); String prefix = nodeToHandle.getStringAttribute(\"prefix\"); String prefixOverrides = nodeToHandle.getStringAttribute(\"prefixOverrides\"); String suffix = nodeToHandle.getStringAttribute(\"suffix\"); String suffixOverrides = nodeToHandle.getStringAttribute(\"suffixOverrides\"); TrimSqlNode trim = new TrimSqlNode(configuration, mixedSqlNode, prefix, prefixOverrides, suffix, suffixOverrides); targetContents.add(trim); &#125; &#125; private class WhereHandler implements NodeHandler &#123; public WhereHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); WhereSqlNode where = new WhereSqlNode(configuration, mixedSqlNode); targetContents.add(where); &#125; &#125; private class SetHandler implements NodeHandler &#123; public SetHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); SetSqlNode set = new SetSqlNode(configuration, mixedSqlNode); targetContents.add(set); &#125; &#125; private class ForEachHandler implements NodeHandler &#123; public ForEachHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); String collection = nodeToHandle.getStringAttribute(\"collection\"); String item = nodeToHandle.getStringAttribute(\"item\"); String index = nodeToHandle.getStringAttribute(\"index\"); String open = nodeToHandle.getStringAttribute(\"open\"); String close = nodeToHandle.getStringAttribute(\"close\"); String separator = nodeToHandle.getStringAttribute(\"separator\"); ForEachSqlNode forEachSqlNode = new ForEachSqlNode(configuration, mixedSqlNode, collection, index, item, open, close, separator); targetContents.add(forEachSqlNode); &#125; &#125; private class IfHandler implements NodeHandler &#123; public IfHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); String test = nodeToHandle.getStringAttribute(\"test\"); IfSqlNode ifSqlNode = new IfSqlNode(mixedSqlNode, test); targetContents.add(ifSqlNode); &#125; &#125; private class OtherwiseHandler implements NodeHandler &#123; public OtherwiseHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; contents = parseDynamicTags(nodeToHandle); MixedSqlNode mixedSqlNode = new MixedSqlNode(contents); targetContents.add(mixedSqlNode); &#125; &#125; private class ChooseHandler implements NodeHandler &#123; public ChooseHandler() &#123; // Prevent Synthetic Access &#125; @Override public void handleNode(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents) &#123; List&lt;SqlNode&gt; whenSqlNodes = new ArrayList&lt;SqlNode&gt;(); List&lt;SqlNode&gt; otherwiseSqlNodes = new ArrayList&lt;SqlNode&gt;(); handleWhenOtherwiseNodes(nodeToHandle, whenSqlNodes, otherwiseSqlNodes); SqlNode defaultSqlNode = getDefaultSqlNode(otherwiseSqlNodes); ChooseSqlNode chooseSqlNode = new ChooseSqlNode(whenSqlNodes, defaultSqlNode); targetContents.add(chooseSqlNode); &#125; private void handleWhenOtherwiseNodes(XNode chooseSqlNode, List&lt;SqlNode&gt; ifSqlNodes, List&lt;SqlNode&gt; defaultSqlNodes) &#123; List&lt;XNode&gt; children = chooseSqlNode.getChildren(); for (XNode child : children) &#123; String nodeName = child.getNode().getNodeName(); NodeHandler handler = nodeHandlers(nodeName); if (handler instanceof IfHandler) &#123; handler.handleNode(child, ifSqlNodes); &#125; else if (handler instanceof OtherwiseHandler) &#123; handler.handleNode(child, defaultSqlNodes); &#125; &#125; &#125; private SqlNode getDefaultSqlNode(List&lt;SqlNode&gt; defaultSqlNodes) &#123; SqlNode defaultSqlNode = null; if (defaultSqlNodes.size() == 1) &#123; defaultSqlNode = defaultSqlNodes.get(0); &#125; else if (defaultSqlNodes.size() &gt; 1) &#123; throw new BuilderException(\"Too many default (otherwise) elements in choose statement.\"); &#125; return defaultSqlNode; &#125; &#125;&#125; 重点是这个方法List&lt;SqlNode&gt; parseDynamicTags(XNode node) ，下面几行代码是处理动态sql的操作 12345678// 得到动态sql标签处理类 trim|where|set...NodeHandler handler = nodeHandlers(nodeName);if (handler == null) &#123; throw new BuilderException(\"Unknown element &lt;\" + nodeName + \"&gt; in SQL statement.\");&#125;// 解析动态结点handler.handleNode(child, contents);isDynamic = true; 通过 nodeHandlers (nodeName) 方法来获取相应的处理类 12345678910111213NodeHandler nodeHandlers(String nodeName) &#123; Map&lt;String, NodeHandler&gt; map = new HashMap&lt;String, NodeHandler&gt;(); map.put(\"trim\", new TrimHandler()); map.put(\"where\", new WhereHandler()); map.put(\"set\", new SetHandler()); map.put(\"foreach\", new ForEachHandler()); map.put(\"if\", new IfHandler()); map.put(\"choose\", new ChooseHandler()); map.put(\"when\", new IfHandler()); map.put(\"otherwise\", new OtherwiseHandler()); map.put(\"bind\", new BindHandler()); return map.get(nodeName);&#125; 各个Handler 处理类是 XMLScriptBuilder 的子类，实际上会转到各个SqlNode 处理类 总结 解析mapper文件中的每个&lt;select/&gt;,&lt;insert/&gt;,&lt;update/&gt;,&lt;delete/&gt;节点内的SQL字符串(其中可能包含动态SQL部分,诸如&lt;if/&gt;,&lt;where/&gt;等)是这个XMLScriptBuilder类","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(八)MapperXML映射文件构建MappedStatement","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(八)MapperXML映射文件构建MappedStatement","date":"2018-11-27T14:00:44.000Z","updated":"2018-12-01T13:55:55.263Z","comments":true,"path":"2018/11/27/backend/mybatis/sourceCodeAnalysis/Mybatis源码(八)MapperXML映射文件构建MappedStatement/","link":"","permalink":"http://www.songshuiyang.site/2018/11/27/backend/mybatis/sourceCodeAnalysis/Mybatis源码(八)MapperXML映射文件构建MappedStatement/","excerpt":"","text":"前言上一章节介绍了ResultMap标签的解析过程，这一章节来介绍select|insert|update|delete 这些sql标签的解析，这些节点会构造成MappedStatement类对象 源码解析 还是从 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 作为入口找到 configurationElement(XNode context) 方法，如下所示，按照步骤节点一步步解析，最后才是处理select|insert|update|delete节点 123456789101112131415161718192021222324private void configurationElement(XNode context) &#123; try &#123; //1.配置namespace String namespace = context.getStringAttribute(\"namespace\"); if (namespace.equals(\"\")) &#123; throw new BuilderException(\"Mapper's namespace cannot be empty\"); &#125; builderAssistant.setCurrentNamespace(namespace); //2.配置cache-ref cacheRefElement(context.evalNode(\"cache-ref\")); //3.配置cache cacheElement(context.evalNode(\"cache\")); //4.配置parameterMap(已经废弃,老式风格的参数映射) parameterMapElement(context.evalNodes(\"/mapper/parameterMap\")); //5.配置resultMap(高级功能) resultMapElements(context.evalNodes(\"/mapper/resultMap\")); //6.配置sql(定义可重用的 SQL 代码段) sqlElement(context.evalNodes(\"/mapper/sql\")); //7.配置select|insert|update|delete TODO buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e); &#125;&#125; 打好断点进入 buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;)); 方法，可以看到是一个或的匹配，匹配所有的select|insert|update|delete 这些标签 123456789101112131415161718192021222324//7.配置select|insert|update|deleteprivate void buildStatementFromContext(List&lt;XNode&gt; list) &#123; //调用7.1构建语句 if (configuration.getDatabaseId() != null) &#123; buildStatementFromContext(list, configuration.getDatabaseId()); &#125; buildStatementFromContext(list, null);&#125;// 7.1构建语句private void buildStatementFromContext(List&lt;XNode&gt; list, String requiredDatabaseId) &#123; for (XNode context : list) &#123; // 构建所有语句,一个mapper下可以有很多select // 语句比较复杂，核心都在这里面，所以调用XMLStatementBuilder final XMLStatementBuilder statementParser = new XMLStatementBuilder(configuration, builderAssistant, context, requiredDatabaseId); try &#123; // 核心XMLStatementBuilder.parseStatementNode statementParser.parseStatementNode(); &#125; catch (IncompleteElementException e) &#123; // 如果出现SQL语句不完整，把它记下来，塞到configuration去 configuration.addIncompleteStatement(statementParser); &#125; &#125;&#125; 可以看到又涉及到了一个XMLStatementBuilder.java 来对这些标签进行解析，进入statementParser.parseStatementNode(); 方法，可以看到xml标签的一些属性解析，最后是builderAssistant.addMappedStatement(...) 方法将构建好的MappedStatement对象添加到Configuration这个大佬身上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 //解析语句(select|insert|update|delete)//&lt;select// id=\"selectPerson\"// parameterType=\"int\"// parameterMap=\"deprecated\"// resultType=\"hashmap\"// resultMap=\"personResultMap\"// flushCache=\"false\"// useCache=\"true\"// timeout=\"10000\"// fetchSize=\"256\"// statementType=\"PREPARED\"// resultSetType=\"FORWARD_ONLY\"&gt;// SELECT * FROM PERSON WHERE ID = #&#123;id&#125;//&lt;/select&gt; public void parseStatementNode() &#123; String id = context.getStringAttribute(\"id\"); String databaseId = context.getStringAttribute(\"databaseId\"); //如果databaseId不匹配，退出 if (!databaseIdMatchesCurrent(id, databaseId, this.requiredDatabaseId)) &#123; return; &#125; //暗示驱动程序每次批量返回的结果行数 Integer fetchSize = context.getIntAttribute(\"fetchSize\"); //超时时间 Integer timeout = context.getIntAttribute(\"timeout\"); //引用外部 parameterMap,已废弃 String parameterMap = context.getStringAttribute(\"parameterMap\"); //参数类型 String parameterType = context.getStringAttribute(\"parameterType\"); Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType); //引用外部的 resultMap(高级功能) String resultMap = context.getStringAttribute(\"resultMap\"); //结果类型 String resultType = context.getStringAttribute(\"resultType\"); //脚本语言,mybatis3.2的新功能 String lang = context.getStringAttribute(\"lang\"); //得到语言驱动 LanguageDriver langDriver = getLanguageDriver(lang); Class&lt;?&gt; resultTypeClass = resolveClass(resultType); //结果集类型，FORWARD_ONLY|SCROLL_SENSITIVE|SCROLL_INSENSITIVE 中的一种 String resultSetType = context.getStringAttribute(\"resultSetType\"); //语句类型, STATEMENT|PREPARED|CALLABLE 的一种 StatementType statementType = StatementType.valueOf(context.getStringAttribute(\"statementType\", StatementType.PREPARED.toString())); ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType); //获取命令类型(select|insert|update|delete) String nodeName = context.getNode().getNodeName(); SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH)); boolean isSelect = sqlCommandType == SqlCommandType.SELECT; boolean flushCache = context.getBooleanAttribute(\"flushCache\", !isSelect); //是否要缓存select结果 boolean useCache = context.getBooleanAttribute(\"useCache\", isSelect); //仅针对嵌套结果 select 语句适用：如果为 true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。 //这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false。 boolean resultOrdered = context.getBooleanAttribute(\"resultOrdered\", false); // Include Fragments before parsing //解析之前先解析&lt;include&gt;SQL片段 XMLIncludeTransformer includeParser = new XMLIncludeTransformer(configuration, builderAssistant); includeParser.applyIncludes(context.getNode()); // Parse selectKey after includes and remove them. //解析之前先解析&lt;selectKey&gt; processSelectKeyNodes(id, parameterTypeClass, langDriver); // Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed) //解析成SqlSource，一般是DynamicSqlSource SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass); String resultSets = context.getStringAttribute(\"resultSets\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyProperty = context.getStringAttribute(\"keyProperty\"); //(仅对 insert 有用) 标记一个属性, MyBatis 会通过 getGeneratedKeys 或者通过 insert 语句的 selectKey 子元素设置它的值 String keyColumn = context.getStringAttribute(\"keyColumn\"); KeyGenerator keyGenerator; String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX; keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, true); if (configuration.hasKeyGenerator(keyStatementId)) &#123; keyGenerator = configuration.getKeyGenerator(keyStatementId); &#125; else &#123; keyGenerator = context.getBooleanAttribute(\"useGeneratedKeys\", configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? new Jdbc3KeyGenerator() : new NoKeyGenerator(); &#125; //又去调助手类 builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets); &#125; MappedStatement类在Mybatis框架中用于表示XML文件中一个sql语句节点，即一个或者标签。Mybatis框架在初始化阶段会对XML配置文件进行读取，将其中的sql语句节点对象化为一个个MappedStatement对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public final class MappedStatement &#123; // xml文件位置 private String resource; private Configuration configuration; // 节点中的id属性加要命名空间比如 org.apache.songsy.mapper.RoleMapper.selectByPrimaryKey private String id; private Integer fetchSize; private Integer timeout; private StatementType statementType; private ResultSetType resultSetType; // SQL源码，实现动态sql private SqlSource sqlSource; private Cache cache; private ParameterMap parameterMap; private List&lt;ResultMap&gt; resultMaps; private boolean flushCacheRequired; private boolean useCache; private boolean resultOrdered; private SqlCommandType sqlCommandType; private KeyGenerator keyGenerator; private String[] keyProperties; private String[] keyColumns; private boolean hasNestedResultMaps; private String databaseId; private Log statementLog; private LanguageDriver lang; private String[] resultSets; MappedStatement() &#123; // constructor disabled &#125; //静态内部类，建造者模式 public static class Builder &#123; private MappedStatement mappedStatement = new MappedStatement(); public Builder(Configuration configuration, String id, SqlSource sqlSource, SqlCommandType sqlCommandType) &#123; mappedStatement.configuration = configuration; mappedStatement.id = id; mappedStatement.sqlSource = sqlSource; mappedStatement.statementType = StatementType.PREPARED; mappedStatement.parameterMap = new ParameterMap.Builder(configuration, \"defaultParameterMap\", null, new ArrayList&lt;ParameterMapping&gt;()).build(); mappedStatement.resultMaps = new ArrayList&lt;ResultMap&gt;(); mappedStatement.timeout = configuration.getDefaultStatementTimeout(); mappedStatement.sqlCommandType = sqlCommandType; mappedStatement.keyGenerator = configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType) ? new Jdbc3KeyGenerator() : new NoKeyGenerator(); String logId = id; if (configuration.getLogPrefix() != null) &#123; logId = configuration.getLogPrefix() + id; &#125; mappedStatement.statementLog = LogFactory.getLog(logId); mappedStatement.lang = configuration.getDefaultScriptingLanuageInstance(); &#125; ... MappedStatement.java 在哪里会调用呢，可以回顾一些第六章节使用MapperProxy来执行方法，下面是方法 // 核心selectList @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) { try { // 根据statement id找到对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来查询结果,注意这里传入的ResultHandler是null return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); } catch (Exception e) { throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); } finally { ErrorContext.instance().reset(); } }","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(七)MapperXML映射文件解析ResultMap","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(七)MapperXML映射文件解析ResultMap","date":"2018-11-26T14:00:44.000Z","updated":"2018-11-27T14:01:48.097Z","comments":true,"path":"2018/11/26/backend/mybatis/sourceCodeAnalysis/Mybatis源码(七)MapperXML映射文件解析ResultMap/","link":"","permalink":"http://www.songshuiyang.site/2018/11/26/backend/mybatis/sourceCodeAnalysis/Mybatis源码(七)MapperXML映射文件解析ResultMap/","excerpt":"","text":"前言MyBatis 的真正强大在于它的映射语句，也是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单，第三章节已经介绍了Mapper XML 文件解析的整体过程，这一章节来介绍Mapper 映射文件下 select|insert|update|delete 这些节点的解析 源码解析 从 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); 作为入口找到 configurationElement(XNode context) 方法，如下所示，按照步骤节点一步步解析，最后才是处理select|insert|update|delete节点 123456789101112131415161718192021222324private void configurationElement(XNode context) &#123; try &#123; //1.配置namespace String namespace = context.getStringAttribute(\"namespace\"); if (namespace.equals(\"\")) &#123; throw new BuilderException(\"Mapper's namespace cannot be empty\"); &#125; builderAssistant.setCurrentNamespace(namespace); //2.配置cache-ref cacheRefElement(context.evalNode(\"cache-ref\")); //3.配置cache cacheElement(context.evalNode(\"cache\")); //4.配置parameterMap(已经废弃,老式风格的参数映射) parameterMapElement(context.evalNodes(\"/mapper/parameterMap\")); //5.配置resultMap(高级功能) resultMapElements(context.evalNodes(\"/mapper/resultMap\")); //6.配置sql(定义可重用的 SQL 代码段) sqlElement(context.evalNodes(\"/mapper/sql\")); //7.配置select|insert|update|delete TODO buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e); &#125;&#125; 配置resultMap 解析，进入 resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;)); 方法 123456789private void resultMapElements(List&lt;XNode&gt; list) throws Exception &#123; for (XNode resultMapNode : list) &#123; try &#123; // 循环遍历resultMap节点 resultMapElement(resultMapNode); &#125; catch (IncompleteElementException e) &#123; // ignore, it will be retried &#125; &#125; 进入 resultMapElement(resultMapNode); 方法, 这里就是构造ResultMap的主要方法了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 private ResultMap resultMapElement(XNode resultMapNode, List&lt;ResultMapping&gt; additionalResultMappings) throws Exception &#123;//错误上下文//取得标示符 (\"resultMap[userResultMap]\")// &lt;resultMap id=\"userResultMap\" type=\"User\"&gt;// &lt;id property=\"id\" column=\"user_id\" /&gt;// &lt;result property=\"username\" column=\"username\"/&gt;// &lt;result property=\"password\" column=\"password\"/&gt;// &lt;/resultMap&gt; ErrorContext.instance().activity(\"processing \" + resultMapNode.getValueBasedIdentifier()); String id = resultMapNode.getStringAttribute(\"id\", resultMapNode.getValueBasedIdentifier()); String type = resultMapNode.getStringAttribute(\"type\", resultMapNode.getStringAttribute(\"ofType\", resultMapNode.getStringAttribute(\"resultType\", resultMapNode.getStringAttribute(\"javaType\")))); String extend = resultMapNode.getStringAttribute(\"extends\"); //autoMapping Boolean autoMapping = resultMapNode.getBooleanAttribute(\"autoMapping\"); Class&lt;?&gt; typeClass = resolveClass(type); Discriminator discriminator = null; List&lt;ResultMapping&gt; resultMappings = new ArrayList&lt;ResultMapping&gt;(); resultMappings.addAll(additionalResultMappings); // 遍历resultMap 的子节点 List&lt;XNode&gt; resultChildren = resultMapNode.getChildren(); for (XNode resultChild : resultChildren) &#123; if (\"constructor\".equals(resultChild.getName())) &#123; //解析result map的constructor processConstructorElement(resultChild, typeClass, resultMappings); &#125; else if (\"discriminator\".equals(resultChild.getName())) &#123; //解析result map的discriminator discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings); &#125; else &#123; List&lt;ResultFlag&gt; flags = new ArrayList&lt;ResultFlag&gt;(); if (\"id\".equals(resultChild.getName())) &#123; flags.add(ResultFlag.ID); &#125; // 调5.1.1 buildResultMappingFromContext,得到ResultMapping resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags)); &#125; &#125; // 最后再调ResultMapResolver得到ResultMap ResultMapResolver resultMapResolver = new ResultMapResolver(builderAssistant, id, typeClass, extend, discriminator, resultMappings, autoMapping); try &#123; return resultMapResolver.resolve(); &#125; catch (IncompleteElementException e) &#123; configuration.addIncompleteResultMap(resultMapResolver); throw e; &#125; &#125; 下面来看看ResultMap 这个类，可以看到一层套一层 12345678910111213141516171819202122232425262728293031323334353637public class ResultMap &#123; private String id; private Class&lt;?&gt; type; private List&lt;ResultMapping&gt; resultMappings; private List&lt;ResultMapping&gt; idResultMappings; private List&lt;ResultMapping&gt; constructorResultMappings; private List&lt;ResultMapping&gt; propertyResultMappings; private Set&lt;String&gt; mappedColumns; private Discriminator discriminator; private boolean hasNestedResultMaps; private boolean hasNestedQueries; private Boolean autoMapping; private ResultMap() &#123; &#125; // 静态内部类，建造者模式 public static class Builder &#123; private ResultMap resultMap = new ResultMap(); public Builder(Configuration configuration, String id, Class&lt;?&gt; type, List&lt;ResultMapping&gt; resultMappings) &#123; this(configuration, id, type, resultMappings, null); &#125; public Builder(Configuration configuration, String id, Class&lt;?&gt; type, List&lt;ResultMapping&gt; resultMappings, Boolean autoMapping) &#123; resultMap.id = id; resultMap.type = type; resultMap.resultMappings = resultMappings; resultMap.autoMapping = autoMapping; &#125; public Builder discriminator(Discriminator discriminator) &#123; resultMap.discriminator = discriminator; return this; &#125; ... ResultMap 由多个 ResultMapping.java 构造成，下面看看这个类，和我们的mapper文件是一一对应的 12345&lt;resultMap id=\"BaseResultMap\" type=\"com.songsy.imybatis.test.entity.User\"&gt; &lt;id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/&gt; &lt;result column=\"username\" property=\"username\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"password\" property=\"password\" jdbcType=\"VARCHAR\"/&gt; &lt;result column=\"nickname\" property=\"nickname\" jdbcType=\"VARCHAR\"/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ResultMapping &#123; private Configuration configuration; private String property; private String column; private Class&lt;?&gt; javaType; private JdbcType jdbcType; private TypeHandler&lt;?&gt; typeHandler; private String nestedResultMapId; private String nestedQueryId; private Set&lt;String&gt; notNullColumns; private String columnPrefix; private List&lt;ResultFlag&gt; flags; private List&lt;ResultMapping&gt; composites; private String resultSet; private String foreignColumn; private boolean lazy; ResultMapping() &#123; &#125; // 静态内部类，建造者模式 public static class Builder &#123; private ResultMapping resultMapping = new ResultMapping(); public Builder(Configuration configuration, String property, String column, TypeHandler&lt;?&gt; typeHandler) &#123; this(configuration, property); resultMapping.column = column; resultMapping.typeHandler = typeHandler; &#125; public Builder(Configuration configuration, String property, String column, Class&lt;?&gt; javaType) &#123; this(configuration, property); resultMapping.column = column; resultMapping.javaType = javaType; &#125; public Builder(Configuration configuration, String property) &#123; resultMapping.configuration = configuration; resultMapping.property = property; resultMapping.flags = new ArrayList&lt;ResultFlag&gt;(); resultMapping.composites = new ArrayList&lt;ResultMapping&gt;(); resultMapping.lazy = configuration.isLazyLoadingEnabled(); &#125; public Builder javaType(Class&lt;?&gt; javaType) &#123; resultMapping.javaType = javaType; return this; &#125; public Builder jdbcType(JdbcType jdbcType) &#123; resultMapping.jdbcType = jdbcType; return this; &#125; public Builder nestedResultMapId(String nestedResultMapId) &#123; resultMapping.nestedResultMapId = nestedResultMapId; return this; &#125; .... 总结 Mybatis最强大的元素，它可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中。 当返回类型直接是一个ResultMap的时候也是非常有用的，这主要用在进行复杂联合查询上，因为进行简单查询是没有什么必要的，可以使用ResultType来处理","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(六)使用MapperProxy来执行方法","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(六)使用MapperProxy来执行方法","date":"2018-11-23T06:10:44.000Z","updated":"2018-12-09T03:05:34.090Z","comments":true,"path":"2018/11/23/backend/mybatis/sourceCodeAnalysis/Mybatis源码(六)使用MapperProxy来执行方法/","link":"","permalink":"http://www.songshuiyang.site/2018/11/23/backend/mybatis/sourceCodeAnalysis/Mybatis源码(六)使用MapperProxy来执行方法/","excerpt":"","text":"前言上一章节通过SqlSession来获取Mapper的代理类MapperProxy， 有了代理类之后就可以执行里面的方法了 MapperProxy 执行方法 MapperProxy 继承 InvocationHandler 实现了动态代理，只要是调用的Mapper接口的方法都会进入到 里面的invoke 方法中，具体解释如下代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 映射器代理，代理模式 * @author Clinton Begin * @author Eduardo Macarron */public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; // 使用了缓存 private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法 // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行 if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; // 这里优化了，去缓存中找MapperMethod final MapperMethod mapperMethod = cachedMapperMethod(method); // 真正的方法执行 return mapperMethod.execute(sqlSession, args); &#125; // 去缓存中找MapperMethod private MapperMethod cachedMapperMethod(Method method) &#123; MapperMethod mapperMethod = methodCache.get(method); if (mapperMethod == null) &#123; // 找不到才去new mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()); methodCache.put(method, mapperMethod); &#125; return mapperMethod; &#125;&#125; 接下来关注这一行mapperMethod.execute(sqlSession, args); 这里是重头戏，我们打开 MapperMethod 这个类，重点关注execute 方法，可以看到在这里进行了一些路由转发(insert|update|delete|select，分别调用SqlSession的4大类方法，又回到了SqlSession中), 还有就是对查询参数的一些处理封装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 映射器方法 * @author Clinton Begin * @author Eduardo Macarron * @author Lasse Voss */public class MapperMethod &#123; private final SqlCommand command; private final MethodSignature method; public MapperMethod(Class&lt;?&gt; mapperInterface, Method method, Configuration config) &#123; this.command = new SqlCommand(config, mapperInterface, method); this.method = new MethodSignature(config, method); &#125; //执行 public Object execute(SqlSession sqlSession, Object[] args) &#123; Object result; //可以看到执行时就是4种情况，insert|update|delete|select，分别调用SqlSession的4大类方法 if (SqlCommandType.INSERT == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.insert(command.getName(), param)); &#125; else if (SqlCommandType.UPDATE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.update(command.getName(), param)); &#125; else if (SqlCommandType.DELETE == command.getType()) &#123; Object param = method.convertArgsToSqlCommandParam(args); result = rowCountResult(sqlSession.delete(command.getName(), param)); &#125; else if (SqlCommandType.SELECT == command.getType()) &#123; if (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123; //如果有结果处理器 executeWithResultHandler(sqlSession, args); result = null; &#125; else if (method.returnsMany()) &#123; //如果结果有多条记录 result = executeForMany(sqlSession, args); &#125; else if (method.returnsMap()) &#123; //如果结果是map result = executeForMap(sqlSession, args); &#125; else &#123; //否则就是一条记录 Object param = method.convertArgsToSqlCommandParam(args); result = sqlSession.selectOne(command.getName(), param); &#125; &#125; else &#123; throw new BindingException(\"Unknown execution method for: \" + command.getName()); &#125; if (result == null &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123; throw new BindingException(\"Mapper method '\" + command.getName() + \" attempted to return null from a method with a primitive return type (\" + method.getReturnType() + \").\"); &#125; return result; &#125; ... 放不下 现在来执行一条查询，根据断点一步步发掘 12UserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); 一大堆if判断进入到这里 12Object param = method.convertArgsToSqlCommandParam(args);result = sqlSession.selectOne(command.getName(), param); 进入 sqlSession.selectOne(command.getName(), param); 方法 12345678910111213@Overridepublic &lt;T&gt; T selectOne(String statement, Object parameter) &#123; // Popular vote was to return null on 0 results and throw exception on too many. // 转而去调用selectList,很简单的，如果得到0条则返回null，得到1条则返回1条，得到多条报TooManyResultsException错 List&lt;T&gt; list = this.&lt;T&gt;selectList(statement, parameter); if (list.size() == 1) &#123; return list.get(0); &#125; else if (list.size() &gt; 1) &#123; throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size()); &#125; else &#123; return null; &#125;&#125; selectOne 调用的是 selectList 方法，在这里可以看到 MappedStatement 及 Executor 1234567891011121314// 核心selectList@Overridepublic &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; // 根据statement id找到对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来查询结果,注意这里传入的ResultHandler是null return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125;&#125; 查看 MappedStatement 这里可以看到我们的sql image 继续跳入 executor.query 方法，这里面跳到 CachingExecutor 执行，这里面使用了装饰器模式，里面有个private Executor delegate;，装饰SimpleExecutor , 在SimpleExecutor基础的上添加了二级缓存的功能 123456789101112131415161718192021@Overridepublic &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; Cache cache = ms.getCache(); // 默认情况下是没有开启缓存的(二级缓存).要开启二级缓存,你需要在你的 SQL 映射文件中添加一行: &lt;cache/&gt; // 简单的说，就是先查CacheKey，查不到再委托给实际的执行器去查 if (cache != null) &#123; flushCacheIfRequired(ms); if (ms.isUseCache() &amp;&amp; resultHandler == null) &#123; ensureNoOutParams(ms, parameterObject, boundSql); @SuppressWarnings(\"unchecked\") List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key); if (list == null) &#123; list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); tcm.putObject(cache, key, list); // issue #578 and #116 &#125; return list; &#125; &#125; return delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);&#125; 因为二级缓存是需要配置开启的，所以继续跳入 delegate.&lt;E&gt; query 方法，进入到BaseExecutor 方法，在这里可以看到一级缓存的处理 12345678910111213141516171819202122232425262728293031323334353637383940414243public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException &#123; ErrorContext.instance().resource(ms.getResource()).activity(\"executing a query\").object(ms.getId()); // 如果已经关闭，报错 if (closed) &#123; throw new ExecutorException(\"Executor was closed.\"); &#125; // 先清局部缓存，再查询.但仅查询堆栈为0，才清。为了处理递归调用 if (queryStack == 0 &amp;&amp; ms.isFlushCacheRequired()) &#123; clearLocalCache(); &#125; List&lt;E&gt; list; try &#123; // 加一,这样递归调用到上面的时候就不会再清局部缓存了 queryStack++; // 先根据cachekey从localCache去查 list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null; if (list != null) &#123; // 若查到localCache缓存，处理localOutputParameterCache handleLocallyCachedOutputParameters(ms, key, parameter, boundSql); &#125; else &#123; // 从数据库查 list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql); &#125; &#125; finally &#123; // 清空堆栈 queryStack--; &#125; if (queryStack == 0) &#123; // 延迟加载队列中所有元素 for (DeferredLoad deferredLoad : deferredLoads) &#123; deferredLoad.load(); &#125; // issue #601 // 清空延迟加载队列 deferredLoads.clear(); if (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123; // issue #482 // 如果是STATEMENT，清本地缓存 clearLocalCache(); &#125; &#125; return list;&#125; 继续跳入queryFromDatabase() 方法，从数据库查， 跳入到SimpleExecutor类 12345678910111213141516@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); // 新建一个StatementHandler // 这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); // 准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); //StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 继续跳入 doQuery()方法 1234567891011121314151617//select@Overridepublic &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException &#123; Statement stmt = null; try &#123; Configuration configuration = ms.getConfiguration(); //新建一个StatementHandler //这里看到ResultHandler传入了 StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql); //准备语句 stmt = prepareStatement(handler, ms.getStatementLog()); //StatementHandler.query return handler.&lt;E&gt;query(stmt, resultHandler); &#125; finally &#123; closeStatement(stmt); &#125;&#125; 继续跳入 handler.query(), 这里又从SimpleExecutor类 跳入 PreparedStatementHandler 类中，终于在这里看到了我们的JDBC的代码，并通过 ResultSetHandler 类来处理我们的结果 123456@Overridepublic &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException &#123; PreparedStatement ps = (PreparedStatement) statement; ps.execute(); return resultSetHandler.&lt;E&gt; handleResultSets(ps);&#125; 时序图 image 总结 可以看到一个方法的执行涉及到一大堆类，为什么要那么多类的，就是为了解耦，高内聚，低耦合，每个类都有其独有的功能，就像工厂流水线一样，一个部门做一个部门的事，专人做专事，这样也方便以后添加功能","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(五)通过SqlSession来获取Mapper的代理类","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(五)通过SqlSession来获取MapperProxy","date":"2018-11-23T02:10:44.000Z","updated":"2018-11-24T03:08:39.809Z","comments":true,"path":"2018/11/23/backend/mybatis/sourceCodeAnalysis/Mybatis源码(五)通过SqlSession来获取MapperProxy/","link":"","permalink":"http://www.songshuiyang.site/2018/11/23/backend/mybatis/sourceCodeAnalysis/Mybatis源码(五)通过SqlSession来获取MapperProxy/","excerpt":"","text":"前言有了SqlSession 这个类之后，就可以通过sqlSession.getMapper(UserMapper.class);来获取UserMapper了12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); 获取Mapper 查看代码又可以发现 Configuration 这个类的影子，哪里都有它的影子，当然因为Mapper的映射关系数据存在这里 12345@Overridepublic &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; // 最后会去调用MapperRegistry.getMapper return configuration.&lt;T&gt;getMapper(type, this);&#125; 继续跟进 configuration.&lt;T&gt;getMapper(type, this); 方法，进入到Configuration 类中，可以发现是MapperRegistry 类维护了Mapper的映射关系 123public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; return mapperRegistry.getMapper(type, sqlSession);&#125; 继续跟进mapperRegistry.getMapper(type, sqlSession); 方法，进入到 MapperRegistry 类中，可以看到里面的映射关系就是用Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers 一个Map来存放，Key是 Class对象，Value就是MapperProxyFactory 是Mapper代理类的生成工厂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 映射器注册机 * @author Clinton Begin * @author Eduardo Macarron * @author Lasse Voss */public class MapperRegistry &#123; private Configuration config; // 将已经添加的映射都放入HashMap private final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;(); public MapperRegistry(Configuration config) &#123; this.config = config; &#125; @SuppressWarnings(\"unchecked\") // 返回代理类 public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\"); &#125; try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e); &#125; &#125; public &lt;T&gt; boolean hasMapper(Class&lt;T&gt; type) &#123; return knownMappers.containsKey(type); &#125; // 看一下如何添加一个映射 public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123; // mapper必须是接口！才会添加 if (type.isInterface()) &#123; if (hasMapper(type)) &#123; // 如果重复添加了，报错 throw new BindingException(\"Type \" + type + \" is already known to the MapperRegistry.\"); &#125; boolean loadCompleted = false; try &#123; knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type)); // It's important that the type is added before the parser is run // otherwise the binding may automatically be attempted by the // mapper parser. If the type is already known, it won't try. MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type); parser.parse(); loadCompleted = true; &#125; finally &#123; // 如果加载过程中出现异常需要再将这个mapper从mybatis中删除,这种方式比较丑陋吧，难道是不得已而为之？ if (!loadCompleted) &#123; knownMappers.remove(type); &#125; &#125; &#125; &#125; /** * @since 3.2.2 */ public Collection&lt;Class&lt;?&gt;&gt; getMappers() &#123; return Collections.unmodifiableCollection(knownMappers.keySet()); &#125; /** * @since 3.2.2 */ public void addMappers(String packageName, Class&lt;?&gt; superType) &#123; // 查找包下所有是superType的类 ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;Class&lt;?&gt;&gt;(); resolverUtil.find(new ResolverUtil.IsA(superType), packageName); Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses(); for (Class&lt;?&gt; mapperClass : mapperSet) &#123; addMapper(mapperClass); &#125; &#125; /** * @since 3.2.2 */ // 查找包下所有类 public void addMappers(String packageName) &#123; addMappers(packageName, Object.class); &#125; &#125; 查看该类可以发现 knownMappers 是通过 addMapper()方法来添加的，那么addMapper()是哪里调用的呢，大家还记得之前的XMLConfigBuilder这个类吗，就是这里来解析mapper节点的 123&lt;mappers&gt; &lt;mapper resource=\"resources/mapper/UserMapper.xml\"/&gt; &lt;/mappers&gt; 回到XMLConfigBuilder类可以找到这个方法mapperElement，可以发现是通过 configuration.addMappers(mapperPackage); 及configuration.addMapper(mapperInterface); 来添加mapper映射的1234567891011121314151617181920212223242526272829303132333435363738private void mapperElement(XNode parent) throws Exception &#123; if (parent != null) &#123; for (XNode child : parent.getChildren()) &#123; if (\"package\".equals(child.getName())) &#123; //10.4自动扫描包下所有映射器 String mapperPackage = child.getStringAttribute(\"name\"); configuration.addMappers(mapperPackage); &#125; else &#123; String resource = child.getStringAttribute(\"resource\"); String url = child.getStringAttribute(\"url\"); String mapperClass = child.getStringAttribute(\"class\"); if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123; //10.1使用类路径 ErrorContext.instance().resource(resource); InputStream inputStream = Resources.getResourceAsStream(resource); //映射器比较复杂，调用XMLMapperBuilder //注意在for循环里每个mapper都重新new一个XMLMapperBuilder，来解析 XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123; //10.2使用绝对url路径 ErrorContext.instance().resource(url); InputStream inputStream = Resources.getUrlAsStream(url); //映射器比较复杂，调用XMLMapperBuilder XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments()); mapperParser.parse(); &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123; //10.3使用java类名 Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass); //直接把这个映射加入配置 configuration.addMapper(mapperInterface); &#125; else &#123; throw new BuilderException(\"A mapper element may only specify a url, resource or class, but not more than one.\"); &#125; &#125; &#125; &#125;&#125; 回归主线，在 MapperRegistry 类的 getMapper 方法，可以发现是通过mapperProxyFactory.newInstance(sqlSession); 是通过Mapper代理类工厂来获取Mapper的 123456789101112// 返回代理类public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123; final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type); if (mapperProxyFactory == null) &#123; throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\"); &#125; try &#123; return mapperProxyFactory.newInstance(sqlSession); &#125; catch (Exception e) &#123; throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e); &#125;&#125; 继续跟进 mapperProxyFactory.newInstance(sqlSession) 进入到 MapperProxyFactory类中，没错就是在这里生成代理Mapper的，是用JDK自带的动态代理生成映射器 123456789101112131415161718192021222324252627282930313233/** * 映射器代理工厂 * @author Lasse Voss */public class MapperProxyFactory&lt;T&gt; &#123; private final Class&lt;T&gt; mapperInterface; private Map&lt;Method, MapperMethod&gt; methodCache = new ConcurrentHashMap&lt;Method, MapperMethod&gt;(); public MapperProxyFactory(Class&lt;T&gt; mapperInterface) &#123; this.mapperInterface = mapperInterface; &#125; public Class&lt;T&gt; getMapperInterface() &#123; return mapperInterface; &#125; public Map&lt;Method, MapperMethod&gt; getMethodCache() &#123; return methodCache; &#125; @SuppressWarnings(\"unchecked\") protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) &#123; // 用JDK自带的动态代理生成映射器 return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] &#123; mapperInterface &#125;, mapperProxy); &#125; public T newInstance(SqlSession sqlSession) &#123; final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache); return newInstance(mapperProxy); &#125;&#125; 看一下MapperProxy.java 的真面目，这就是真正的实现类，重点是 mapperMethod.execute(sqlSession, args); 这一句，这是真正的执行者 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 映射器代理，代理模式 * @author Clinton Begin * @author Eduardo Macarron */public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable &#123; private static final long serialVersionUID = -6424540398559729838L; private final SqlSession sqlSession; private final Class&lt;T&gt; mapperInterface; private final Map&lt;Method, MapperMethod&gt; methodCache; public MapperProxy(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache) &#123; this.sqlSession = sqlSession; this.mapperInterface = mapperInterface; this.methodCache = methodCache; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // 代理以后，所有Mapper的方法调用时，都会调用这个invoke方法 // 并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行 if (Object.class.equals(method.getDeclaringClass())) &#123; try &#123; return method.invoke(this, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; // 这里优化了，去缓存中找MapperMethod final MapperMethod mapperMethod = cachedMapperMethod(method); // 真正的执行方法 return mapperMethod.execute(sqlSession, args); &#125; // 去缓存中找MapperMethod private MapperMethod cachedMapperMethod(Method method) &#123; MapperMethod mapperMethod = methodCache.get(method); if (mapperMethod == null) &#123; // 找不到才去new mapperMethod = new MapperMethod(mapperInterface, method, sqlSession.getConfiguration()); methodCache.put(method, mapperMethod); &#125; return mapperMethod; &#125;&#125; 时序图 image 总结 Mapper接口的实现类是Mybatis生成的代理类MapperProxy.java，所有接口的代理类是通过MapperProxyFactory.java 方法来生成的，这里可以看到Mybatis的高明之处就是所有Mapper接口的代理类都是通过MapperProxy.java来实现 因为是Mapper接口，所以Mybatis代理类的实现运用的是JDK的动态代理","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(四)构建SqlSession","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(四)构建SqlSession","date":"2018-11-22T08:10:44.000Z","updated":"2018-11-24T03:08:39.812Z","comments":true,"path":"2018/11/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(四)构建SqlSession/","link":"","permalink":"http://www.songshuiyang.site/2018/11/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(四)构建SqlSession/","excerpt":"","text":"前言有了SqlSessionFactory会话工厂 这个类之后，就可以通过sqlSessionFactory.openSession();来生成SqlSession了12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); SqlSession 简介Sqlsession对应着一次数据库会话。由于数据库会话不是永久的，因此Sqlsession的生命周期也不应该是永久的，相反，在你每次访问数据库时都需要创建它（当然并不是说在Sqlsession里只能执行一次sql，你可以执行多次，当一旦关闭了Sqlsession就需要重新创建它）。创建Sqlsession的地方只有一个，那就是SqlsessionFactory的openSession方法 构建 SqlSession SqlSession.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263/** * 这是MyBatis主要的一个类，用来执行SQL，获取映射器，管理事务 * The primary Java interface for working with MyBatis. * Through this interface you can execute commands, get mappers and manage transactions. * * @author Clinton Begin */public interface SqlSession extends Closeable &#123; // 语句执行方法 // 这些方法被用来执行SELECT，INSERT，UPDATE和DELETE语句。 /** * Retrieve a single row mapped from the statement key * 获取一条记录 * @param &lt;T&gt; the returned object type * @param statement * @return Mapped object */ &lt;T&gt; T selectOne(String statement); /** * Retrieve a single row mapped from the statement key and parameter. * 获取一条记录 * @param &lt;T&gt; the returned object type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return Mapped object */ &lt;T&gt; T selectOne(String statement, Object parameter); /** * Retrieve a list of mapped objects from the statement key and parameter. * 获取多条记录 * @param &lt;E&gt; the returned list element type * @param statement Unique identifier matching the statement to use. * @return List of mapped object */ &lt;E&gt; List&lt;E&gt; selectList(String statement); /** * Retrieve a list of mapped objects from the statement key and parameter. * 获取多条记录 * @param &lt;E&gt; the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @return List of mapped object */ &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter); /** * Retrieve a list of mapped objects from the statement key and parameter, * within the specified row bounds. * 获取多条记录,加上分页 * @param &lt;E&gt; the returned list element type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param rowBounds Bounds to limit object retrieval * @return List of mapped object */ &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * Eg. Return a of Map[Integer,Author] for selectMap(\"selectAuthors\",\"id\") * 获取多条记录,并存入Map * @param &lt;K&gt; the returned Map keys type * @param &lt;V&gt; the returned Map values type * @param statement Unique identifier matching the statement to use. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * 获取多条记录,并存入Map * @param &lt;K&gt; the returned Map keys type * @param &lt;V&gt; the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @return Map containing key pair data. */ &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey); /** * The selectMap is a special case in that it is designed to convert a list * of results into a Map based on one of the properties in the resulting * objects. * 获取多条记录,加上分页,并存入Map * @param &lt;K&gt; the returned Map keys type * @param &lt;V&gt; the returned Map values type * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param mapKey The property to use as key for each value in the list. * @param rowBounds Bounds to limit object retrieval * @return Map containing key pair data. */ &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds); /** * Retrieve a single row mapped from the statement key and parameter * using a &#123;@code ResultHandler&#125;. * 获取一条记录,并转交给ResultHandler处理 * @param statement Unique identifier matching the statement to use. * @param parameter A parameter object to pass to the statement. * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, Object parameter, ResultHandler handler); /** * Retrieve a single row mapped from the statement * using a &#123;@code ResultHandler&#125;. * 获取一条记录,并转交给ResultHandler处理 * @param statement Unique identifier matching the statement to use. * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, ResultHandler handler); /** * Retrieve a single row mapped from the statement key and parameter * using a &#123;@code ResultHandler&#125; and &#123;@code RowBounds&#125; * 获取一条记录,加上分页,并转交给ResultHandler处理 * @param statement Unique identifier matching the statement to use. * @param rowBounds RowBound instance to limit the query results * @param handler ResultHandler that will handle each retrieved row * @return Mapped object */ void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler); /** * Execute an insert statement. * 插入记录 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the insert. */ int insert(String statement); /** * Execute an insert statement with the given parameter object. Any generated * autoincrement values or selectKey entries will modify the given parameter * object properties. Only the number of rows affected will be returned. * 插入记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the insert. */ int insert(String statement, Object parameter); /** * Execute an update statement. The number of rows affected will be returned. * 更新记录 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the update. */ int update(String statement); /** * Execute an update statement. The number of rows affected will be returned. * 更新记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the update. */ int update(String statement, Object parameter); /** * Execute a delete statement. The number of rows affected will be returned. * 删除记录 * @param statement Unique identifier matching the statement to execute. * @return int The number of rows affected by the delete. */ int delete(String statement); /** * Execute a delete statement. The number of rows affected will be returned. * 删除记录 * @param statement Unique identifier matching the statement to execute. * @param parameter A parameter object to pass to the statement. * @return int The number of rows affected by the delete. */ int delete(String statement, Object parameter); //以下是事务控制方法,commit,rollback /** * Flushes batch statements and commits database connection. * Note that database connection will not be committed if no updates/deletes/inserts were called. * To force the commit call &#123;@link SqlSession#commit(boolean)&#125; */ void commit(); /** * Flushes batch statements and commits database connection. * @param force forces connection commit */ void commit(boolean force); /** * Discards pending batch statements and rolls database connection back. * Note that database connection will not be rolled back if no updates/deletes/inserts were called. * To force the rollback call &#123;@link SqlSession#rollback(boolean)&#125; */ void rollback(); /** * Discards pending batch statements and rolls database connection back. * Note that database connection will not be rolled back if no updates/deletes/inserts were called. * @param force forces connection rollback */ void rollback(boolean force); /** * Flushes batch statements. * 刷新批处理语句,返回批处理结果 * @return BatchResult list of updated records * @since 3.0.6 */ List&lt;BatchResult&gt; flushStatements(); /** * Closes the session * 关闭Session */ @Override void close(); /** * Clears local session cache * 清理Session缓存 */ void clearCache(); /** * Retrieves current configuration * 得到配置 * @return Configuration */ Configuration getConfiguration(); /** * Retrieves a mapper. * 得到映射器 * 这个巧妙的使用了泛型，使得类型安全 * 到了MyBatis 3，还可以用注解,这样xml都不用写了 * @param &lt;T&gt; the mapper type * @param type Mapper interface class * @return a mapper bound to this SqlSession */ &lt;T&gt; T getMapper(Class&lt;T&gt; type); /** * Retrieves inner database connection * 得到数据库连接 * @return Connection */ Connection getConnection();&#125; DefaultSqlSession.java 是 SqlSession.java 接口的默认实现，从DefaultSqlSessionFactory构建的是DefaultSqlSession, 查看DefaultSqlSession.java类成员又可以发现Configuration的影子，Executor成员是MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296/** * 默认SqlSession * @author Clinton Begin */public class DefaultSqlSession implements SqlSession &#123; private Configuration configuration; private Executor executor; private boolean autoCommit; private boolean dirty; public DefaultSqlSession(Configuration configuration, Executor executor, boolean autoCommit) &#123; this.configuration = configuration; this.executor = executor; this.dirty = false; this.autoCommit = autoCommit; &#125; public DefaultSqlSession(Configuration configuration, Executor executor) &#123; this(configuration, executor, false); &#125; @Override public &lt;T&gt; T selectOne(String statement) &#123; return this.&lt;T&gt;selectOne(statement, null); &#125; // 核心selectOne @Override public &lt;T&gt; T selectOne(String statement, Object parameter) &#123; // Popular vote was to return null on 0 results and throw exception on too many. // 转而去调用selectList,很简单的，如果得到0条则返回null，得到1条则返回1条，得到多条报TooManyResultsException错 List&lt;T&gt; list = this.&lt;T&gt;selectList(statement, parameter); if (list.size() == 1) &#123; return list.get(0); &#125; else if (list.size() &gt; 1) &#123; throw new TooManyResultsException(\"Expected one result (or null) to be returned by selectOne(), but found: \" + list.size()); &#125; else &#123; return null; &#125; &#125; @Override public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, String mapKey) &#123; return this.selectMap(statement, null, mapKey, RowBounds.DEFAULT); &#125; @Override public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey) &#123; return this.selectMap(statement, parameter, mapKey, RowBounds.DEFAULT); &#125; // 核心selectMap @Override public &lt;K, V&gt; Map&lt;K, V&gt; selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds) &#123; //转而去调用selectList final List&lt;?&gt; list = selectList(statement, parameter, rowBounds); final DefaultMapResultHandler&lt;K, V&gt; mapResultHandler = new DefaultMapResultHandler&lt;K, V&gt;(mapKey, configuration.getObjectFactory(), configuration.getObjectWrapperFactory()); final DefaultResultContext context = new DefaultResultContext(); for (Object o : list) &#123; // 循环用DefaultMapResultHandler处理每条记录 context.nextResultObject(o); mapResultHandler.handleResult(context); &#125; // 注意这个DefaultMapResultHandler里面存了所有已处理的记录(内部实现可能就是一个Map)，最后再返回一个Map return mapResultHandler.getMappedResults(); &#125; @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement) &#123; return this.selectList(statement, null); &#125; @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) &#123; return this.selectList(statement, parameter, RowBounds.DEFAULT); &#125; // 核心selectList @Override public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) &#123; try &#123; // 根据statement id找到对应的MappedStatement MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来查询结果,注意这里传入的ResultHandler是null return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public void select(String statement, Object parameter, ResultHandler handler) &#123; select(statement, parameter, RowBounds.DEFAULT, handler); &#125; @Override public void select(String statement, ResultHandler handler) &#123; select(statement, null, RowBounds.DEFAULT, handler); &#125; //核心select,带有ResultHandler，和selectList代码差不多的，区别就一个ResultHandler @Override public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123; try &#123; MappedStatement ms = configuration.getMappedStatement(statement); executor.query(ms, wrapCollection(parameter), rowBounds, handler); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error querying database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public int insert(String statement) &#123; return insert(statement, null); &#125; @Override public int insert(String statement, Object parameter) &#123; //insert也是调用update return update(statement, parameter); &#125; @Override public int update(String statement) &#123; return update(statement, null); &#125; // 核心update @Override public int update(String statement, Object parameter) &#123; try &#123; // 每次要更新之前，dirty标志设为true dirty = true; MappedStatement ms = configuration.getMappedStatement(statement); // 转而用执行器来update结果 return executor.update(ms, wrapCollection(parameter)); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error updating database. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public int delete(String statement) &#123; //delete也是调用update return update(statement, null); &#125; @Override public int delete(String statement, Object parameter) &#123; return update(statement, parameter); &#125; @Override public void commit() &#123; commit(false); &#125; // 核心commit @Override public void commit(boolean force) &#123; try &#123; // 转而用执行器来commit executor.commit(isCommitOrRollbackRequired(force)); // 每次commit之后，dirty标志设为false dirty = false; &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error committing transaction. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public void rollback() &#123; rollback(false); &#125; // 核心rollback @Override public void rollback(boolean force) &#123; try &#123; // 转而用执行器来rollback executor.rollback(isCommitOrRollbackRequired(force)); // 每次rollback之后，dirty标志设为false dirty = false; &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error rolling back transaction. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; // 核心flushStatements @Override public List&lt;BatchResult&gt; flushStatements() &#123; try &#123; // 转而用执行器来flushStatements return executor.flushStatements(); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error flushing statements. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; // 核心close @Override public void close() &#123; try &#123; // 转而用执行器来close executor.close(isCommitOrRollbackRequired(false)); // 每次close之后，dirty标志设为false dirty = false; &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; @Override public Configuration getConfiguration() &#123; return configuration; &#125; @Override public &lt;T&gt; T getMapper(Class&lt;T&gt; type) &#123; // 最后会去调用MapperRegistry.getMapper return configuration.&lt;T&gt;getMapper(type, this); &#125; @Override public Connection getConnection() &#123; try &#123; return executor.getTransaction().getConnection(); &#125; catch (SQLException e) &#123; throw ExceptionFactory.wrapException(\"Error getting a new connection. Cause: \" + e, e); &#125; &#125; // 核心clearCache @Override public void clearCache() &#123; // 转而用执行器来clearLocalCache executor.clearLocalCache(); &#125; // 检查是否需要强制commit或rollback private boolean isCommitOrRollbackRequired(boolean force) &#123; return (!autoCommit &amp;&amp; dirty) || force; &#125; // 把参数包装成Collection private Object wrapCollection(final Object object) &#123; if (object instanceof Collection) &#123; // 参数若是Collection型，做collection标记 StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;(); map.put(\"collection\", object); if (object instanceof List) &#123; // 参数若是List型，做list标记 map.put(\"list\", object); &#125; return map; &#125; else if (object != null &amp;&amp; object.getClass().isArray()) &#123; // 参数若是数组型，，做array标记 StrictMap&lt;Object&gt; map = new StrictMap&lt;Object&gt;(); map.put(\"array\", object); return map; &#125; // 参数若不是集合型，直接返回原来值 return object; &#125; // 严格的Map，如果找不到对应的key，直接抛BindingException例外，而不是返回null public static class StrictMap&lt;V&gt; extends HashMap&lt;String, V&gt; &#123; private static final long serialVersionUID = -5741767162221585340L; @Override public V get(Object key) &#123; if (!super.containsKey(key)) &#123; throw new BindingException(\"Parameter '\" + key + \"' not found. Available parameters are \" + this.keySet()); &#125; return super.get(key); &#125; &#125;&#125; 时序图 iamge 总结 通过源码可以看到SqlSession就像是公司的前台人员，正在干活的是 Executor ，人家来找公司谈合作，首先先和前台人员联系，然后再通过前台将人指到真正的实施者","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(三)构建SqlSessionFactory会话工厂","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(三)构建SqlSessionFactory会话工厂","date":"2018-11-22T06:10:44.000Z","updated":"2018-11-24T03:08:39.807Z","comments":true,"path":"2018/11/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(三)构建SqlSessionFactory会话工厂/","link":"","permalink":"http://www.songshuiyang.site/2018/11/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(三)构建SqlSessionFactory会话工厂/","excerpt":"","text":"前言有了Mybatis整体脉络概念之后，现在就是来构建 SqlSessionFactory会话工厂 这个类了12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactorySqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 得到SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 得到MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1)); SqlSessionFactory 简介SqlSessionFactory 是Mybatis的关键对象， 是创建SqlSession的工厂，工厂模式，SqlSessionFactory 由 SqlSessionFactoryBuilder 构建，每一个MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心 logo SqlSessionFactory是个接口，它有两个实现类 DefaultSqlSessionFactory.java, SqlSessionManager.java ，Mybatis使用的是DefaultSqlSessionFactory.java 来作为其默认实现1234567891011public interface SqlSessionFactory &#123; SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration();&#125; 构建 SqlSessionFactory SqlSessionFactory 是通过SqlSessionFactoryBuilder.java 来构建的，build方法传入了一个配置文件的输入流 打开SqlSessionFactoryBuilder.java类，可以发现都是build的重载方法，主要有有俩种配置文件的输入方式，一个是Reader ，另一个是通过InputStream，可以看到里面是通过XMLConfigBuilder.java来解析xml文件的， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class SqlSessionFactoryBuilder &#123; public SqlSessionFactory build(Reader reader) &#123; return build(reader, null, null); &#125; public SqlSessionFactory build(Reader reader, String environment) &#123; return build(reader, environment, null); &#125; public SqlSessionFactory build(Reader reader, Properties properties) &#123; return build(reader, null, properties); &#125; // 第4种方法是最常用的，它使用了一个参照了XML文档或更特定的SqlMapConfig.xml文件的Reader实例。 public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; try &#123; // 委托XMLConfigBuilder来解析xml文件，并构建 XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; //以下3个方法都是调用下面第8种方法 public SqlSessionFactory build(InputStream inputStream) &#123; return build(inputStream, null, null); &#125; public SqlSessionFactory build(InputStream inputStream, String environment) &#123; return build(inputStream, environment, null); &#125; public SqlSessionFactory build(InputStream inputStream, Properties properties) &#123; return build(inputStream, null, properties); &#125; // 第8种方法和第4种方法差不多，Reader换成了InputStream // 可选的参数是environment和properties。Environment决定加载哪种环境(开发环境/生产环境)，包括数据源和事务管理器。 // 如果使用properties，那么就会加载那些properties（属性配置文件），那些属性可以用$&#123;propName&#125;语法形式多次用在配置文件中。和Spring很像，一个思想？ public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) &#123; try &#123; // 委托XMLConfigBuilder来解析xml文件 XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties); return build(parser.parse()); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error building SqlSession.\", e); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; inputStream.close(); &#125; catch (IOException e) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125; //最后一个build方法使用了一个Configuration作为参数,并返回DefaultSqlSessionFactory public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125;&#125; 打开XMLConfigBuilder.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * XML配置构建器，建造者模式,继承BaseBuilder * @author Clinton Begin */public class XMLConfigBuilder extends BaseBuilder &#123; // 是否已解析，XPath解析器 private boolean parsed; // XPath解析器 private XPathParser parser; // 环境 private String environment; // 以下3个一组 public XMLConfigBuilder(Reader reader) &#123; this(reader, null, null); &#125; public XMLConfigBuilder(Reader reader, String environment) &#123; this(reader, environment, null); &#125; // 构造函数，转换成XPathParser再去调用构造函数 public XMLConfigBuilder(Reader reader, String environment, Properties props) &#123; // 构造一个需要验证，XMLMapperEntityResolver的XPathParser this(new XPathParser(reader, true, props, new XMLMapperEntityResolver()), environment, props); &#125; // 以下3个一组 public XMLConfigBuilder(InputStream inputStream) &#123; this(inputStream, null, null); &#125; public XMLConfigBuilder(InputStream inputStream, String environment) &#123; this(inputStream, environment, null); &#125; public XMLConfigBuilder(InputStream inputStream, String environment, Properties props) &#123; this(new XPathParser(inputStream, true, props, new XMLMapperEntityResolver()), environment, props); &#125; // 上面6个构造函数最后都合流到这个函数，传入XPathParser private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123; // 首先调用父类初始化Configuration super(new Configuration()); // 错误上下文设置成SQL Mapper Configuration(XML文件配置),以便后面出错了报错用 ErrorContext.instance().resource(\"SQL Mapper Configuration\"); // 将Properties全部设置到Configuration里面去 this.configuration.setVariables(props); this.parsed = false; this.environment = environment; this.parser = parser; &#125; // 解析配置 public Configuration parse() &#123; // 如果已经解析过了，报错 if (parsed) &#123; throw new BuilderException(\"Each XMLConfigBuilder can only be used once.\"); &#125; parsed = true;// &lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; // &lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" // \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; // &lt;configuration&gt; // &lt;environments default=\"development\"&gt; // &lt;environment id=\"development\"&gt; // &lt;transactionManager type=\"JDBC\"/&gt; // &lt;dataSource type=\"POOLED\"&gt; // &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; // &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; // &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; // &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; // &lt;/dataSource&gt; // &lt;/environment&gt; // &lt;/environments&gt; // &lt;mappers&gt; // &lt;mapper resource=\"org/mybatis/ex ample/BlogMapper.xml\"/&gt; // &lt;/mappers&gt; // &lt;/configuration&gt; // 根节点是configuration parseConfiguration(parser.evalNode(\"/configuration\")); return configuration; &#125; // 解析配置 private void parseConfiguration(XNode root) &#123; try &#123; // 分步骤解析 //issue #117 read properties first //1.properties propertiesElement(root.evalNode(\"properties\")); // 2.类型别名 typeAliasesElement(root.evalNode(\"typeAliases\")); // 3.插件 pluginElement(root.evalNode(\"plugins\")); // 4.对象工厂 objectFactoryElement(root.evalNode(\"objectFactory\")); // 5.对象包装工厂 objectWrapperFactoryElement(root.evalNode(\"objectWrapperFactory\")); // 6.设置 settingsElement(root.evalNode(\"settings\")); // read it after objectFactory and objectWrapperFactory issue #631 // 7.环境 environmentsElement(root.evalNode(\"environments\")); // 8.databaseIdProvider databaseIdProviderElement(root.evalNode(\"databaseIdProvider\")); // 9.类型处理器 typeHandlerElement(root.evalNode(\"typeHandlers\")); // 10.映射器 mapperElement(root.evalNode(\"mappers\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing SQL Mapper Configuration. Cause: \" + e, e); &#125; &#125; ..... 未完 XMLMapperBuilder.java 这个类是解析sql映射文件的 ，下面是核心代码， 可以看到Mybatis是将select|insert|update|delete这些都作为一个单独的节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 // 解析 public void parse() &#123; // 如果没有加载过再加载，防止重复加载 if (!configuration.isResourceLoaded(resource)) &#123; // 解析mapper节点 configurationElement(parser.evalNode(\"/mapper\")); // 标记一下，已经加载过了 configuration.addLoadedResource(resource); // 绑定映射器到namespace bindMapperForNamespace(); &#125; parsePendingResultMaps(); parsePendingChacheRefs(); parsePendingStatements(); &#125; public XNode getSqlFragment(String refid) &#123; return sqlFragments.get(refid); &#125; //配置mapper元素// &lt;mapper namespace=\"org.mybatis.example.BlogMapper\"&gt;// &lt;select id=\"selectBlog\" parameterType=\"int\" resultType=\"Blog\"&gt;// select * from Blog where id = #&#123;id&#125;// &lt;/select&gt;// &lt;/mapper&gt; private void configurationElement(XNode context) &#123; try &#123; //1.配置namespace String namespace = context.getStringAttribute(\"namespace\"); if (namespace.equals(\"\")) &#123; throw new BuilderException(\"Mapper's namespace cannot be empty\"); &#125; builderAssistant.setCurrentNamespace(namespace); //2.配置cache-ref cacheRefElement(context.evalNode(\"cache-ref\")); //3.配置cache cacheElement(context.evalNode(\"cache\")); //4.配置parameterMap(已经废弃,老式风格的参数映射) parameterMapElement(context.evalNodes(\"/mapper/parameterMap\")); //5.配置resultMap(高级功能) resultMapElements(context.evalNodes(\"/mapper/resultMap\")); //6.配置sql(定义可重用的 SQL 代码段) sqlElement(context.evalNodes(\"/mapper/sql\")); //7.配置select|insert|update|delete TODO buildStatementFromContext(context.evalNodes(\"select|insert|update|delete\")); &#125; catch (Exception e) &#123; throw new BuilderException(\"Error parsing Mapper XML. Cause: \" + e, e); &#125; &#125; DefaultSqlSessionFactory.java 是构造SqlSession的默认实现，可以看到实现都是通过configuration该对象来获取配置信息，从而构造SqlSession 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 默认实现的SqlSessionFactory * @author Clinton Begin */public class DefaultSqlSessionFactory implements SqlSessionFactory &#123; private final Configuration configuration; public DefaultSqlSessionFactory(Configuration configuration) &#123; this.configuration = configuration; &#125; // 最终都会调用2种方法：openSessionFromDataSource,openSessionFromConnection // 以下6个方法都会调用openSessionFromDataSource @Override public SqlSession openSession() &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false); &#125; @Override public SqlSession openSession(boolean autoCommit) &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, autoCommit); &#125; @Override public SqlSession openSession(ExecutorType execType) &#123; return openSessionFromDataSource(execType, null, false); &#125; @Override public SqlSession openSession(TransactionIsolationLevel level) &#123; return openSessionFromDataSource(configuration.getDefaultExecutorType(), level, false); &#125; @Override public SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level) &#123; return openSessionFromDataSource(execType, level, false); &#125; @Override public SqlSession openSession(ExecutorType execType, boolean autoCommit) &#123; return openSessionFromDataSource(execType, null, autoCommit); &#125; //以下2个方法都会调用openSessionFromConnection @Override public SqlSession openSession(Connection connection) &#123; return openSessionFromConnection(configuration.getDefaultExecutorType(), connection); &#125; @Override public SqlSession openSession(ExecutorType execType, Connection connection) &#123; return openSessionFromConnection(execType, connection); &#125; @Override public Configuration getConfiguration() &#123; return configuration; &#125; private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) &#123; Transaction tx = null; try &#123; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); // 通过事务工厂来产生一个事务 tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); // 生成一个执行器(事务包含在执行器里) final Executor executor = configuration.newExecutor(tx, execType); // 然后产生一个DefaultSqlSession return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; // 如果打开事务出错，则关闭它 closeTransaction(tx); // may have fetched a connection so lets call close() throw ExceptionFactory.wrapException(\"Error opening session. Cause: \" + e, e); &#125; finally &#123; //最后清空错误上下文 ErrorContext.instance().reset(); &#125; &#125; private SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) &#123; try &#123; boolean autoCommit; try &#123; autoCommit = connection.getAutoCommit(); &#125; catch (SQLException e) &#123; // Failover to true, as most poor drivers // or databases won't support transactions autoCommit = true; &#125; final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); final Transaction tx = transactionFactory.newTransaction(connection); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); &#125; catch (Exception e) &#123; throw ExceptionFactory.wrapException(\"Error opening session. Cause: \" + e, e); &#125; finally &#123; ErrorContext.instance().reset(); &#125; &#125; private TransactionFactory getTransactionFactoryFromEnvironment(Environment environment) &#123; // 如果没有配置事务工厂，则返回托管事务工厂 if (environment == null || environment.getTransactionFactory() == null) &#123; return new ManagedTransactionFactory(); &#125; return environment.getTransactionFactory(); &#125; private void closeTransaction(Transaction tx) &#123; if (tx != null) &#123; try &#123; tx.close(); &#125; catch (SQLException ignore) &#123; // Intentionally ignore. Prefer previous error. &#125; &#125; &#125;&#125; 时序图 iamge 总结 涉及到两种设计模式：工厂模式(SqlSessionFactory.java)及建造者模式(XMLConfigBuilder.java)，通过命名可以发现其设计思想，学习大佬的命名规范 SqlSessionFactory接口的默认实现是DefaultSqlSessionFactory.java DefaultSqlSessionFactory只有一个成员变量 Configuration ，所以构建SqlSessionFactory其实就是解析xml文件，构建Configuration的过程，Configuration是Mybatis的大头，所有的配置信息都存在里面 通过其运行流程可以看到每个类都有其独有的用途，各司其职，有生产SqlSession的类，又解析xml的类，有生产SqlSessionFactory的类，各个模块相互配合","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(二)Mybatis框架架构","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(二)Mybatis框架架构","date":"2018-11-22T03:10:44.000Z","updated":"2018-11-26T13:58:30.434Z","comments":true,"path":"2018/11/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二)Mybatis框架架构/","link":"","permalink":"http://www.songshuiyang.site/2018/11/22/backend/mybatis/sourceCodeAnalysis/Mybatis源码(二)Mybatis框架架构/","excerpt":"","text":"引言本文主要讲解Mybatis的整体程序设计，理清楚框架的主要脉络，这样才能对源码有个整体的了解，先主干后分支，如果没有这些概念那么直接看源码的话肯定会很吃力的 整体设计整体架构图 logo 运作流程(1)、加载配置并初始化Mybatis配置包括两种配置，一种是Mybatis自身的框架配置，另一种是sql映射配置，Mybatis自身的框架配置有两种方式可以配置， 一处是配置文件，另一处是通过Java注解进行配置， 比如说Spring Boot项目整合Mybatis都是通过Java代码的方式来进行配置 初始化是初始化框架基本配置，然后解析sql映射文件，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。 (2)、接收调用请求通过接口来接收调用请求，真实企业环境一般都是通过接口的方式来进行调用，通过该接口将请求传递给下层的请求处理层进行处理。 传统Mybatis工作模式，是创建一个和数据库打交道的SqlSession对象，然后根据Statement Id 和参数来操作数据库，这种方式固然很简单和实用，但是它不符合面向对象语言的概念和面向接口编程的编程习惯。由于面向接口的编程是面向对象的大趋势，MyBatis 为了适应这一趋势，增加了第二种使用MyBatis 支持接口（Interface）调用方式。 image 接口工作模式，MyBatis 将配置文件中的每一个 节点抽象为一个 Mapper 接口，而这个接口中声明的方法和跟 节点中的 节点项对应，即 节点的id值为Mapper 接口中的方法名称，parameterType 值表示Mapper 对应方法的入参类型，而resultMap 值则对应了Mapper 接口表示的返回值类型或者返回结果集的元素类型。 image (3)、处理操作请求处理操作包括参数映射，sql解析，sql执行操作 (4)、返回请求结果将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。 MyBatis的主要的核心部件 logo 类名 描述 SqlSession 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能 Executor MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。 ParameterHandler 负责对用户传递的参数转换成JDBC Statement 所需要的参数 ResultSetHandler 负责将JDBC返回的ResultSet结果集对象转换成List类型的集合 TypeHandler 负责java数据类型和jdbc数据类型之间的映射和转换 MappedStatement MappedStatement维护了一条select update delete insert节点的封装 SqlSource 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中并返回 BoundSql 表示动态生成的SQL语句以及相应的参数信息 Configuration MyBatis所有的配置信息都维持在Configuration对象之中。 参考： https://blog.csdn.net/luanlouis/article/details/40422941 http://chenjc-it.iteye.com/blog/1460990","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"Mybatis源码(一)本地编译Mybatis的源码","slug":"backend/mybatis/sourceCodeAnalysis/Mybatis源码(一)本地编译Mybatis的源码","date":"2018-11-21T07:59:44.000Z","updated":"2018-11-26T14:06:30.201Z","comments":true,"path":"2018/11/21/backend/mybatis/sourceCodeAnalysis/Mybatis源码(一)本地编译Mybatis的源码/","link":"","permalink":"http://www.songshuiyang.site/2018/11/21/backend/mybatis/sourceCodeAnalysis/Mybatis源码(一)本地编译Mybatis的源码/","excerpt":"","text":"引言在开发过程中，对于Mybatis框架一直都是在使用阶段，对于其底层实现的细节不是十分清楚，所以利用空余时间学习Mybatis的源码，学习其设计思想，看看大佬是怎样设计一个框架的，提升自己的代码能力 下载源码 地址 网站 中文官网 http://www.mybatis.org/mybatis-3/zh/index.html 源码地址 https://github.com/mybatis/mybatis-3 下载完源码包后使用maven进行编译 mvn clean install 可以发现会报error 查看pom.xml 发现又一个父级依赖 12345&lt;parent&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-parent&lt;/artifactId&gt; &lt;version&gt;33-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 所以需要把这些依赖下载下来 12345// 下载代码git clone https://github.com/mybatis/parent.git// 编译代码mvn clean install 父级依赖完成之后更改Mybatis的源码，注意版本号需要一致 123456&lt;parent&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-parent&lt;/artifactId&gt; &lt;version&gt;33-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; 解决部分插件版本问题 告诉我们部分插件没有指定的相应的版本号，出于工程的稳定性考虑需要对使用的插件指定其版本号，并给出了合适的版本号，如图红色方框中的文字。我们只要在mybatisg工程的pom.xml文件中找到相对应的插件处添加$NUM 标签即可， $NUM代表具体的版本号。到这我们再执行mvn clean install 指令就可以将mybatis工程构建成功了。 源码基本结构打开源码可以发现如下目录，通过包名就可以大概知道其模块功能 image 解析以下章节将从下面的示例代码来一步步解析Mybatis的源码，分析其实现过程12345678910// 读取配置文件File file = new File(\"src/test/java/resources/mybatis-config.xml\");InputStream inputStream = new FileInputStream(file);// 构建SqlSessionFactory会话工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);// 构建SqlSessionSqlSession sqlSession = sqlSessionFactory.openSession();// 通过SqlSession来获取MapperUserMapper userMapper = sqlSession.getMapper(UserMapper.class);System.out.println(userMapper.selectByPrimaryKey(1));~ 参考：https://blog.csdn.net/yums467/article/details/52801288","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"}]},{"title":"SpringBoot配置Mybatis多数据源","slug":"backend/mybatis/SpringBoot配置Mybatis多数据源","date":"2018-11-09T02:59:44.000Z","updated":"2018-11-13T11:59:09.617Z","comments":true,"path":"2018/11/09/backend/mybatis/SpringBoot配置Mybatis多数据源/","link":"","permalink":"http://www.songshuiyang.site/2018/11/09/backend/mybatis/SpringBoot配置Mybatis多数据源/","excerpt":"","text":"背景同一个项目数据操作有时会涉及到多个数据库，所以需要在后台配置多个数据源，通过特定的设置选择指定的数据库 目的可以配置多个数据源，项目默认使用master数据源，当有新的数据源需求时，可以通过注解的形式动态切换数据源 实现源码: https://github.com/songshuiyang/iframe application.yml 配置数据源1234567891011121314151617181920212223242526272829spring: application: name: iframe# 主数据库master: datasource: use-jndi: false jndi-name: jdbc/datasource url: jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false username: root password: root driver-class: com.mysql.jdbc.Driver initial-size: 0 min-idle: 10 max-active: 100 max-wait: 20000# 从数据库slave: datasource: use-jndi: false jndi-name: jdbc/datasource url: jdbc:mysql://127.0.0.1:3306/iframe?useUnicode=true&amp;characterEncoding=UTF-8&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false username: root password: root driver-class: com.mysql.jdbc.Driver initial-size: 0 min-idle: 10 max-active: 100 max-wait: 20000 Config.java 解析数据源配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 继承TransactionManagementConfigurer可以自定义事务管理器 * @author songsy * @Date 2018/11/7 17:09 */@Configuration@EnableTransactionManagementpublic class Config implements TransactionManagementConfigurer &#123; private static final Logger logger = LoggerFactory.getLogger(Config.class); @Autowired Environment env; /** * 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器 * * @return */ @Override public PlatformTransactionManager annotationDrivenTransactionManager() &#123; return transactionManager(); &#125; /** * 数据源 * * @return */ @Bean(name = \"dataSource\") public DynamicDataSource dataSource() &#123; Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); for (String prefix : DATA_SOURCE_PREFIX) &#123; targetDataSources.put(prefix, createDataSource(prefix)); &#125; DynamicDataSource dynamicDataSource = new DynamicDataSource(); dynamicDataSource.setTargetDataSources(targetDataSources); dynamicDataSource.setDefaultTargetDataSource(targetDataSources.get(MASTER_DATA_SOURCE_PREFIX)); return dynamicDataSource; &#125; /** * 创建事务管理器 * * @return */ @Bean public PlatformTransactionManager transactionManager() &#123; DataSourceTransactionManager txManager = new DataSourceTransactionManager(); txManager.setDataSource(dataSource()); return txManager; &#125; /** * 创建数据源 * * @param prefix * @return */ private DataSource createDataSource(String prefix) &#123; // 是否使用数据源 boolean useJndi = env.getProperty(prefix + \".\" + \"datasource.use-jndi\", Boolean.class, false); // 数据源名称 String jndiName = env.getProperty(prefix + \".\" + \"datasource.jndi-name\", \"\"); // 数据库链接 String url = env.getProperty(prefix + \".\" + \"datasource.url\", \"\"); String username = env.getProperty(prefix + \".\" + \"datasource.username\", \"\"); String password = env.getProperty(prefix + \".\" + \"datasource.password\", \"\"); String driverClass = env.getProperty(prefix + \".\" + \"datasource.driver-class\", \"\"); // 数据源默认初始链接数 int initialSize = env.getProperty(prefix + \".\" + \"datasource.initial-size\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_INIT_SIZE); // 数据源最大连接数 int maxActive = env.getProperty(prefix + \".\" + \"datasource.max-active\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_MAX_ACTIVE); // 数据源最小连接数 int minIdle = env.getProperty(prefix + \".\" + \"datasource.min-idle\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_MIN_IDLE); // 配置获取连接等待超时的时间 int maxWait = env.getProperty(prefix + \".\" + \"datasource.max-wait\", Integer.class, DataSouceConstant.DEFAULT_DATASOURCE_MAX_WAIT); if (useJndi) &#123; try &#123; logger.debug(\"get datasource from jndi - [&#123;&#125;].\", jndiName); Context context = new InitialContext(); DataSource dataSource = (DataSource) context.lookup(jndiName); return dataSource; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; else &#123; logger.debug(\"create druid datasource.\"); logger.debug(\"url - &#123;&#125;.\", url); logger.debug(\"username - &#123;&#125;.\", username); logger.debug(\"password - &#123;&#125;.\", password); logger.debug(\"driverClass - &#123;&#125;.\", driverClass); logger.debug(\"initialSize - &#123;&#125;.\", initialSize); logger.debug(\"maxActive - &#123;&#125;.\", maxActive); logger.debug(\"minIdle - &#123;&#125;.\", minIdle); try &#123; DruidDataSource datasource = new DruidDataSource(); datasource.setUrl(url); datasource.setDriverClassName(driverClass); datasource.setUsername(username); datasource.setPassword(password); datasource.setInitialSize(initialSize); datasource.setMaxActive(maxActive); datasource.setMinIdle(minIdle); datasource.setMaxWait(maxWait); datasource.setFilters(\"stat,slf4j\"); datasource.setProxyFilters(getDruidFilters()); return datasource; &#125; catch (Exception e) &#123; &#125; &#125; return null; &#125; public List&lt;Filter&gt; getDruidFilters() &#123; Slf4jLogFilter slf4jLogFilter = new Slf4jLogFilter(); slf4jLogFilter.setDataSourceLogEnabled(false); slf4jLogFilter.setStatementLogEnabled(false); slf4jLogFilter.setStatementExecutableSqlLogEnable(true); slf4jLogFilter.setResultSetLogEnabled(false); slf4jLogFilter.setResultSetCloseAfterLogEnabled(false); slf4jLogFilter.setConnectionLogEnabled(false); List&lt;Filter&gt; filters = new ArrayList&lt;&gt;(); filters.add(new StatFilter()); filters.add(slf4jLogFilter); return filters; &#125;&#125; 新增 @BindingDataSources 注解，通过该注解实现数据源切换 123456789101112/** * 绑定数据源注解 * @author songsy * @Date 2018/11/7 17:33 */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface BindingDataSources &#123; String value() default \"master\";&#125; 新增 DynamicDataSource.java 实现切换数据源 123456789101112/** * 继承AbstractRoutingDataSource实现determineCurrentLookupKey方法，该方法可以实现数据库的动态切换 * @author songsy * @Date 2018/11/7 17:17 */public class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; return DynamicDataSourceHolder.getDataSource(); &#125;&#125; 新增 DynamicDataSourceHolder.java 保存当前线程绑定的数据源信息1234567891011121314151617181920212223/** * 保存当前线程绑定的数据源信息 * @author songsy * @Date 2018/11/7 17:18 */public class DynamicDataSourceHolder &#123; private static final ThreadLocal&lt;String&gt; dataSourceHolder = new ThreadLocal&lt;&gt;(); public static void setDataSource(String dataSource) &#123; Assert.notNull(dataSource, \"dataSource cannot be null\"); dataSourceHolder.set(dataSource); &#125; public static String getDataSource() &#123; return dataSourceHolder.get(); &#125; public static void removeDataSource() &#123; dataSourceHolder.remove(); &#125;&#125; 通过 DynamicDataSourceAspect.java AOP切面来获取数据源注解信息并设置到 private static final ThreadLocal&lt;String&gt; dataSourceHolder = new ThreadLocal&lt;&gt;(); 变量中，那么determineCurrentLookupKey 方法就可以根据当前线程数据源key值去动态切换数据源 1234567891011121314151617181920212223242526272829303132/** * 配置数据源切面 * @author songsy * @Date 2018/11/7 17:35 */@Aspect@Order(-1)// 保证该AOP在@Transactional之前执行@Componentpublic class DynamicDataSourceAspect &#123; private final static Logger logger = LoggerFactory.getLogger(DynamicDataSourceAspect.class); @Pointcut(\"@annotation(com.songsy.iframe.core.persistence.datasource.annotation.BindingDataSources)\") public void pointcut() &#123; &#125; @Before(\"pointcut() &amp;&amp; @annotation(bindingDataSources)\") public void setDynamicDataSource(JoinPoint point, BindingDataSources bindingDataSources) &#123; Object target = point.getTarget(); Method method = ((MethodSignature) point.getSignature()).getMethod(); logger.debug(\"切换数据源: 类名 - &#123;&#125;\", target.getClass().getCanonicalName()); logger.debug(\"切换数据源: 方法名 - &#123;&#125;\", method.getName()); String key = bindingDataSources.value(); DynamicDataSourceHolder.setDataSource(key); logger.debug(\"切换数据源：[&#123;&#125;] 数据源切换成功.\", DynamicDataSourceHolder.getDataSource()); &#125; @After(\"pointcut()\") public void clearDynamicDataSource(JoinPoint point) &#123; DynamicDataSourceHolder.removeDataSource(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Mybatis通用增删改查实现","slug":"backend/mybatis/Mybatis通用增删改查实现","date":"2018-11-04T03:06:44.000Z","updated":"2018-11-04T03:20:40.217Z","comments":true,"path":"2018/11/04/backend/mybatis/Mybatis通用增删改查实现/","link":"","permalink":"http://www.songshuiyang.site/2018/11/04/backend/mybatis/Mybatis通用增删改查实现/","excerpt":"","text":"iframe 一个基于Mybtais的通用增删改查功能的工具包，mapper接口只要继承相应的接口，实体类添加几个注解即可面向对象操作数据 iframe 基于Spring boot, Gradle, mybatis3实现，代码已通过测试 代码： https://github.com/songshuiyang/iframe 为什么有这个开发需求： 1、在实际整合了Mybatis的项目开发过程中经常会遇到变更数据库字段的情况，如果表结构发生了变化就需要重新修改mapper对应的xml文件，每次修改都要同步更新xml文件。 2、在普通的mapper接口中发现普通的增删改查这些方法每一个mapper接口都有，通过对比可以发现方法除了实体类属性不一样之外，其他的都一样(如下所示)，而且mapper文件也有大量增删改查的sql1234567891011int deleteByPrimaryKey(E id);int insert(T record);int insertSelective(T record);T selectByPrimaryKey(E id);int updateByPrimaryKeySelective(T record);int updateByPrimaryKey(T id); Mybatis 和 Hibernate 优缺点对比 现在开源项目中持久层框架用到最多的基本就是 MyBatis 和 Hibernate Mybatis优点 Mybatis入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验 可以进行更为细致的SQL优化，可以减少查询字段缺点 虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。 Hibernate优点 不需要编写的SQL语句(不需要编辑JDBC)，只需要操作相应的对象就可以了，就可以能够存储、更新、删除、加载对象，可以提高生产效率 使用Hibernate，移植性好缺点 由于对持久层封装过于完整，导致开发人员无法对SQL进行优化，无法灵活使用JDBC的原生SQL，Hibernate封装了JDBC，所以没有JDBC直接访问数据库效率高。要使用数据库的特定优化机制的时候，不适合用Hibernate 开发目的对比Mybatis 和 Hibernate 优缺点，可以发现他们之间的优缺点可以互补，为何不取其精华, 去其糟粕, 双剑合并呢, 所以初步想法是在Mybatis的基础框架上, 扩展一下其面向对象操作的功能。 使用方法准备 在自己的项目中导入 com.songsy.iframe.core.persistence.provider 包下的所有文件。 默认数据库各张表都有如下字段, 如果不符合项目需要即可修改对应的源码 1234567`created_date` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',`created_by` varchar(32) DEFAULT NULL COMMENT '创建人',`last_modified_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后修改时间',`last_modified_by` varchar(32) DEFAULT NULL COMMENT '最后修改人',`version` bigint(20) DEFAULT NULL COMMENT '版本',`remarks` varchar(255) DEFAULT NULL COMMENT '备注',`enable` bit(1) DEFAULT b'1' COMMENT '是否启用', mybatis版本在3.0以上，需要使用其新特性 使用 实体类继承BaseEntity.class类获得公共属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 实体类基类 * @author songshuiyang * @date 2018/10/28 10:13 */@Getter@Setterpublic class BaseEntity&lt;ID&gt; implements Serializable &#123; private static final long serialVersionUID = -3873745966284869947L; /** * 主键 */ @Id(type = Integer.class) @GeneratedValue(strategy = GenerationType.CUSTOM) private ID id; /** * 创建人 */ private String createdBy; /** * 创建时间 */ private Date createdDate; /** * 最后修改人 */ private String lastModifiedBy; /** * 最后修改时间 */ private Date lastModifiedDate; /** * 备注 */ private String remarks; /** * 乐观锁字段 */ @Version private Long version; /** * 逻辑删除标识 */ @Deleted private boolean enable = true; @Override public int hashCode() &#123; return this.id != null ? this.id.hashCode() : null; &#125; @Override public boolean equals(Object obj) &#123; if (!(obj instanceof BaseEntity)) &#123; return false; &#125; BaseEntity i = (BaseEntity) obj; if (i.getId() == null || this.getId() == null) &#123; return false; &#125; if (this.getId().equals(i.getId())) &#123; return true; &#125; return false; &#125;&#125; 实体类加上对应的注解 1234567891011121314151617181920212223242526272829303132/** * 用户 * @author songshuiyang * @date 2017/11/28 21:36 */@Data@Entity@Table(name = \"sys_user\")@EqualsAndHashCode(callSuper = false)public class User extends BaseEntity&lt;Integer&gt; &#123; private String username; private String password; private String nickname; private Integer sex; private Integer age; private String phone; private String email; private String address; private String salt; @Column(name = \"head_portrait\") private String headPortrait;&#125; 注解是参照Jpa的注解来定制的，详情可见com.songsy.iframe.core.persistence.provider.annotation 注解 作用 @Entity 修饰实体类，指明该类将映射到指定的数据表 @Table 当实体类与映射的数据库表名不同名时需要使用 @Table 注解，该注解与 @Entity 注解并列使用，使用其 name 属性指明数据库的表名, 不填写name属性则默认是类名的转化成_格式的表名 @Column 当实体类属性名与数据库字段名不一致时, 可用该注解标识实体类对应在数据库的字段名 @Id 标识该属性为主键 @GeneratedValue 标注主键的生成策略，通过其 strategy 属性标识生成策略 @Transient 标注此注解后在操作数据表的时候将会忽略该属性 @Version 标识乐观锁字段 @Deleted 逻辑删除标识 mapper接口继承BaseCurdMapper.java ，Mapper层增加其通用增删改查方法, &lt;User,Integer&gt;：第一个是实体类类型，第二个标识主键类型12345678/** * 用户 * @author songshuiyang * @date 2017/11/28 20:12 */public interface UserMapper extends BaseCurdMapper&lt;User,Integer&gt; &#123;&#125; 增加的方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 查询所有数据 * @return */List&lt;T&gt; findAll();/** * 根据id查询记录 * @return */T findById(Object id);/** * 插入记录 * @param entity * @return */int insert(T entity);/** * 更新记录 * @param entity * @return */int update(T entity);/** * 更新记录(null值记录也更新) * @param entity * @return */int updateNull(T entity);/** * 根据id物理删除记录 * @param id * @return */int deleteOne (Object id);/** * 根据id逻辑删除记录 * @param id * @return */int logicDeleteOne (Object id); service接口继承BaseService.java ，Service层增加其通用增删改查方法1234567/** * @author songshuiyang * @date 2018/10/28 10:13 */public interface UserService extends BaseService&lt;User, Integer&gt; &#123;&#125; 增加的方法：1234567891011121314151617181920/** * @author songsy * @Date 2018/10/31 18:06 */public interface BaseService &lt;T extends BaseEntity, ID extends Serializable&gt;&#123; List&lt;T&gt; findAll(); T findById(ID id); T saveSelective(T entity); T saveSelective(T entity, Boolean hasId); int updateNull(T entity); int deleteOne (ID id); int logicDeleteOne (ID id);&#125; service实现类继承AbstractBaseService.java ，重写getRepository()方法12345678910111213141516/** * @author songshuiyang * @date 2018/10/28 10:13 */@Servicepublic class UserServiceImpl extends AbstractBaseService&lt;User, Integer&gt; implements UserService &#123; @Autowired private UserMapper userMapper; @Override public BaseCurdMapper&lt;User, Integer&gt; getRepository() &#123; return userMapper; &#125;&#125; AbstractBaseService.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * 抽象service基类 * * @author songsy * @Date 2018/131 17:17 */@Slf4jpublic abstract class AbstractBaseService&lt;T extends BaseEntity, ID extends Serializable&gt; &#123; public abstract BaseCurdMapper&lt;T, ID&gt; getRepository(); public List&lt;T&gt; findAll() &#123; return getRepository().findAll(); &#125; public T findById(ID id) &#123; return getRepository().findById(id); &#125; public int updateNull(T entity) &#123; return getRepository().updateNull(entity); &#125; public int deleteOne(ID id) &#123; return getRepository().deleteOne(id); &#125; public int logicDeleteOne(ID id) &#123; return getRepository().logicDeleteOne(id); &#125; /** * 通用插入更新方法 * * @param entity * @return */ @Transactional public T saveSelective(T entity) &#123; return saveSelective(entity, false); &#125; @Transactional public T saveSelective(T entity, Boolean hasId) &#123; if (hasId) &#123; // 之前已经生成了id insertSelective(entity); &#125; else if (!StringUtils.isEmpty(entity.getId())) &#123; updateSelective(entity); // 插入数据库之后 实体类乐观锁字段自增 entity.setVersion(entity.getVersion() + 1); &#125; else &#123; Class idClass = ReflectionUtils.getPrimarykeyClassType(entity.getClass()); // 如果主键是字符类型，则采用32位随机字符作为主键 if (idClass.equals(String.class)) &#123; entity.setId(IDGeneratorUtils.generateID()); &#125; else &#123; // 默认主键由数据库自动生成（主要是自动增长型） &#125; insertSelective(entity); &#125; return entity; &#125; private void insertSelective(T entity) &#123; entity.setCreatedDate(new Date()); entity.setLastModifiedDate(new Date()); entity.setVersion(new Long(1)); // 设置当前登录人// if (null == entity.getCreatedBy()) &#123;// entity.setCreatedBy(\"\");// &#125;// if (null == entity.getLastModifiedBy()) &#123;// entity.setLastModifiedBy(\"\");// &#125; getRepository().insert(entity); &#125; private void updateSelective(T entity) &#123; if (entity.getVersion() == null) &#123; throw new VersionException(); &#125; entity.setLastModifiedDate(new Date()); // 设置当前登录人// if (null == entity.getLastModifiedBy()) &#123;// entity.setLastModifiedBy(\"\");// &#125; Integer flag = getRepository().update(entity); if (flag == 0) &#123; throw new UpdateException(); &#125; &#125;&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * @author songsy * @Date 2018/10/31 18:00 */public class UserServiceTest extends BaseTest &#123; @Autowired UserService userService; @Test public void findAll () &#123; userService.findAll(); &#125; @Test public void insertUser () &#123; User user = new User(); user.setUsername(\"songsy\"); user.setAddress(\"广东深圳\"); user.setAge(88); user.setEmail(\"1459074711@qq.com\"); user.setHeadPortrait(\"头像\"); user.setNickname(\"宋某\"); user.setPassword(\"root\"); user.setSex(1); userService.saveSelective(user); &#125; @Test public void updateUser1 () &#123; User user = new User(); user.setId(48); user.setUsername(\"songsy\"); user.setAddress(\"广东深圳\"); user.setAge(88); user.setEmail(\"1459074711@qq.com\"); user.setHeadPortrait(\"头像\"); user.setNickname(\"宋某某\"); user.setPassword(\"root\"); user.setSex(1); user.setVersion(1l); userService.saveSelective(user); &#125; @Test public void updateUser2 () &#123; User user = userService.findAll().get(0); User userDb = new User(); userDb.setId(user.getId()); userDb.setVersion(user.getVersion()); userDb.setUsername(\"测试乐观锁111\"); userService.saveSelective(userDb); &#125; @Test public void updateNull () &#123; User user = userService.findById(50); User userDb = new User(); userDb.setId(user.getId()); userDb.setVersion(user.getVersion()); userDb.setUsername(\"测试updateNull\"); userService.updateNull(userDb); &#125; @Test public void deleteOne () &#123; userService.deleteOne(48); &#125; @Test public void logicDeleteOne () &#123; userService.logicDeleteOne(49); &#125;&#125; 使用总结 如果增加或者修改了数据库字段，只要修改对应的实体类文件即可，配合注解的使用可以十分方便完成修改，对于增删改查的操作代码再也不用一个个去修改xml文件了 不用在每一个mapper接口, Mybatis xml文件添加一些重复的代码 在service层即可完成通用增删改查方法，使用Mybatis也可以像Hibernate 那样用对象来更新数据库了 实现解析 详细实现可见com.songsy.iframe.core.persistence.provider 按步骤解析： 使用Spring Aop收集实体类信息及缓存起来，每次调用继承了BaseCurdMapper.java的Mapper接口就会触发 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.songsy.iframe.core.persistence.provider.aspect;import com.google.common.collect.Maps;import com.songsy.iframe.core.persistence.provider.exception.ParameterizedTypeException;import com.songsy.iframe.core.persistence.provider.mapper.BaseCurdMapper;import com.songsy.iframe.core.persistence.provider.threadlocal.EntityProperty;import com.songsy.iframe.core.persistence.provider.threadlocal.EntityThreadLocal;import com.songsy.iframe.core.persistence.provider.utils.ReflectionUtils;import org.apache.ibatis.binding.MapperProxy;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Proxy;import java.lang.reflect.Type;import java.util.Map;/** * BaseCurdMapper接口AOP，用于获取实体类属性 * * @author songshuiyang * @date 2018/10/30 21:44 */@Aspect@Componentpublic class BaseCurdMapperAspect &#123; private final static Logger logger = LoggerFactory.getLogger(BaseCurdMapperAspect.class); /** * 缓存实体类属性 * key: 实体类类型 * value: 实体类属性对象 */ private static Map&lt;String, EntityProperty&gt; entityPropertyMap = Maps.newHashMap(); /** * 定义切点 * Spring Aop是基于代理的，生成的bean也是一个代理对象，this就是这个代理对象， * 当这个对象可以转换为指定的类型时，对应的切入点就是它了，Spring Aop将生效。 */ @Pointcut(\"this(com.songsy.iframe.core.persistence.provider.mapper.BaseCurdMapper)\") public void pointcut() &#123; &#125; /** * 前置增强：获取BaseCurdMapper接口 泛型属性，并设置到ThreadLocal中 * @param point */ @Before(\"pointcut()\") public void before(JoinPoint point) &#123; Class entityClass = null; Class entityIdClass = null; Object target= point.getTarget(); // 是否继承 BaseCurdMapper 接口 if (BaseCurdMapper.class.isAssignableFrom(target.getClass())) &#123; // 获取Mybatis代理类对象 MapperProxy mapperProxy = (MapperProxy) Proxy.getInvocationHandler(target); Class mapperInterface = (Class) ReflectionUtils.getFieldValue(mapperProxy, \"mapperInterface\"); // 获取接口泛型对象 ParameterizedType parameterizedType = (ParameterizedType) mapperInterface.getGenericInterfaces()[0]; Type[] types = parameterizedType.getActualTypeArguments(); if (types.length != 2) &#123; logger.error(\"parameterizedType type length error\"); throw new ParameterizedTypeException(parameterizedType.getTypeName()); &#125; try &#123; entityClass = Class.forName(types[0].getTypeName()); entityIdClass = Class.forName(types[1].getTypeName()); // 如果不存在则加入到entityPropertyMap缓存中 if (!entityPropertyMap.containsKey(entityClass.getName())) &#123; EntityProperty entityProperty = new EntityProperty(entityClass, entityIdClass); entityPropertyMap.put(entityClass.getTypeName(),entityProperty); &#125; &#125; catch (ClassNotFoundException e) &#123; logger.error(e.getMessage()); &#125; &#125; // 设置ThreadLocal if (null != entityClass) &#123; EntityThreadLocal.set(entityPropertyMap.get(entityClass.getName())); &#125; &#125; /** * 后置增强：清除 threadLocal 防止内存泄漏 * @param point */ @After(\"pointcut()\") public void after(JoinPoint point) &#123; EntityThreadLocal.remove(); &#125;&#125; 使用ThreadLocal 获取当前访问线程实体类信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。 * 每次调用mapper接口方法的时候，先把实体类的信息存放在ThreadLocal中 * @author songshuiyang * @date 2018/10/30 21:27 */public class EntityThreadLocal &#123; private static ThreadLocal&lt;EntityProperty&gt; threadLocal = new ThreadLocal&lt;&gt;(); /** * 获取当前线程的实体类属性 * @return */ public static EntityProperty get () &#123; if (null == threadLocal) &#123; initialValue(); &#125; return threadLocal.get(); &#125; /** * 设置当前线程的实体类属性 * @param entityProperty */ public static void set(EntityProperty entityProperty) &#123; if (entityProperty != null) &#123; threadLocal.set(entityProperty); &#125; &#125; /** * 清除 threadLocal */ public static void remove() &#123; threadLocal.remove(); &#125; /** * 默认初始化Object.class */ private static void initialValue() &#123; EntityProperty entityProperty = new EntityProperty(); entityProperty.setEntityClass(Object.class); entityProperty.setIdClass(null); threadLocal.set(entityProperty); &#125;&#125; 使用Mybatis3的@SelectProvider、@InsertProvider, @UpdateProvider,@DeleteProvider，使用注解来配置Mapper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 通用增删改查Mapper * @author songshuiyang * @date 2018/10/28 11:22 */public interface CurdMapper&lt;T extends BaseEntity, ID extends Serializable&gt; &#123; /** * 查询所有数据 * @return */ @SelectProvider(type=MybatisProvider.class,method = MybatisProvider.FIND_ALL) List&lt;T&gt; findAll(); /** * 根据id查询记录 * @return */ @SelectProvider(type=MybatisProvider.class, method = MybatisProvider.FIND_BY_ID) T findById(Object id); /** * 插入记录 * @param entity * @return */ @InsertProvider(type=MybatisProvider.class, method = MybatisProvider.INSERT) int insert(T entity); /** * 更新记录 * @param entity * @return */ @UpdateProvider(type=MybatisProvider.class, method = MybatisProvider.UPDATE) int update(T entity); /** * 更新记录(null值记录也更新) * @param entity * @return */ @UpdateProvider(type=MybatisProvider.class, method = MybatisProvider.UPDATE_NULL) int updateNull(T entity); /** * 根据id物理删除记录 * @param id * @return */ @DeleteProvider(type=MybatisProvider.class, method = MybatisProvider.DELETE_ONE) int deleteOne (Object id); /** * 根据id逻辑删除记录 * @param id * @return */ @DeleteProvider(type=MybatisProvider.class, method = MybatisProvider.LOGIC_DELETE_ONE) int logicDeleteOne (Object id); /** * 分页查询 * @param page * @return */ @SelectProvider(type=MybatisProvider.class,method = MybatisProvider.FIND_AUTO_BY_PAGE) List&lt;T&gt; findAutoByPage(Page&lt;T&gt; page);&#125; 通用增删改查实现类，在这里实现sql的拼接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197package com.songsy.iframe.core.persistence.provider;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import com.songsy.iframe.core.persistence.provider.annotation.Version;import com.songsy.iframe.core.persistence.provider.entity.ColumnEntity;import com.songsy.iframe.core.persistence.provider.entity.TableEntity;import com.songsy.iframe.core.persistence.provider.utils.MybatisTableUtils;import com.songsy.iframe.core.persistence.provider.utils.PageUtils;import com.songsy.iframe.core.persistence.provider.utils.ReflectionUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.lang.reflect.Field;import java.text.ParseException;import java.util.List;import java.util.Map;import java.util.Set;/** * 通用增删改查实现方法 * @author songshuiyang * @date 2018/10/28 11:34 */public class CrudProvider &#123; private static Logger logger = LoggerFactory.getLogger(CrudProvider.class); public static final String FIND_ALL = \"findAll\"; public static final String FIND_BY_ID = \"findById\"; public static final String INSERT = \"insert\"; public static final String UPDATE = \"update\"; public static final String UPDATE_NULL = \"updateNull\"; public static final String DELETE_ONE = \"deleteOne\"; public static final String LOGIC_DELETE_ONE =\"logicDeleteOne\"; public static final String FIND_AUTO_BY_PAGE = \"findAutoByPage\"; /** * 查询所有数据 * @return */ public String findAll() &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); String sql = \"SELECT * FROM \" + tableEntity.getTableName(); return sql; &#125; /** * 根据id查询记录 * @param id * @return */ public String findById (Object id) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); StringBuilder sb = new StringBuilder(\"SELECT \"); sb.append(\" * \"); sb.append(\"FROM\"); sb.append(\" \").append(tableEntity.getTableName()).append(\" \"); sb.append(\" WHERE \").append(tableEntity.getIdColumnEntity().getColumnName()).append(\"=\").append(id); return sb.toString(); &#125; /** * 插入记录 * @param entity */ public String insert (Object entity) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); List&lt;ColumnEntity&gt; columnEntities = tableEntity.getColumnEntities(); List&lt;String&gt; fieldNames = Lists.newArrayList(); List&lt;String&gt; columnNames = Lists.newArrayList(); for (ColumnEntity columnEntity : columnEntities) &#123; Object value = ReflectionUtils.getFieldValue(entity, columnEntity.getFieldName()); // 字段为null不插入 if (value != null) &#123; columnNames.add(columnEntity.getColumnName()); fieldNames.add(\"#&#123;\" + columnEntity.getFieldName() + \"&#125;\"); &#125; &#125; StringBuilder sb = new StringBuilder(\"INSERT INTO \"); sb.append(tableEntity.getTableName()); sb.append(\" (\"); sb.append(StringUtils.join(columnNames, \",\")); sb.append(\") \"); sb.append(\" VALUES(\"); sb.append(StringUtils.join(fieldNames, \",\")); sb.append(\")\"); String sql = sb.toString(); return sql; &#125; /** * 更新记录 * 字段属性为null不更新 * @param entity */ public String update (Object entity) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); List&lt;ColumnEntity&gt; columnEntities = tableEntity.getColumnEntities(); ColumnEntity versionColumnEntity = null; List&lt;String&gt; updateColumns = Lists.newArrayList(); for (ColumnEntity columnEntity : columnEntities) &#123; // 乐观锁处理 更新后version字段加一 Field field = columnEntity.getField(); Version version = field.getAnnotation(Version.class); &#123; if (version != null) &#123; versionColumnEntity = columnEntity; updateColumns.add(columnEntity.getColumnName() + \" = \" + columnEntity.getFieldName() + \" + 1\"); continue; &#125; &#125; Object value = ReflectionUtils.getFieldValue(entity, columnEntity.getFieldName()); if (value != null) &#123; updateColumns.add(columnEntity.getColumnName() + \" = \" + \"#&#123;\" + columnEntity.getFieldName() + \"&#125;\"); &#125; &#125; StringBuilder sb = new StringBuilder(\"UPDATE \"); sb.append(tableEntity.getTableName()); sb.append(\" SET \"); sb.append(StringUtils.join(updateColumns, \",\")); sb.append(\" WHERE \"); sb.append(tableEntity.getIdColumnEntity().getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + tableEntity.getIdColumnEntity().getFieldName() + \"&#125;\"); sb.append(\" and \"); sb.append(versionColumnEntity.getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + versionColumnEntity.getFieldName() + \"&#125;\"); String sql = sb.toString(); return sql; &#125; /** * 更新记录 * 字段属性为null 也会更新为null * @param entity */ public String updateNull (Object entity) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); List&lt;ColumnEntity&gt; columnEntities = tableEntity.getColumnEntities(); ColumnEntity versionColumnEntity = null; List&lt;String&gt; updateColumns = Lists.newArrayList(); for (ColumnEntity columnEntity : columnEntities) &#123; // 乐观锁处理 更新后version字段加一 Field field = columnEntity.getField(); Version version = field.getAnnotation(Version.class); &#123; if (version != null) &#123; versionColumnEntity = columnEntity; updateColumns.add(columnEntity.getColumnName() + \" = \" + columnEntity.getFieldName() + \" + 1\"); continue; &#125; &#125; updateColumns.add(columnEntity.getColumnName() + \" = \" + \"#&#123;\" + columnEntity.getFieldName() + \"&#125;\"); &#125; StringBuilder sb = new StringBuilder(\"UPDATE \"); sb.append(tableEntity.getTableName()); sb.append(\" SET \"); sb.append(StringUtils.join(updateColumns, \",\")); sb.append(\" WHERE \"); sb.append(tableEntity.getIdColumnEntity().getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + tableEntity.getIdColumnEntity().getFieldName() + \"&#125;\"); sb.append(\" and \"); sb.append(versionColumnEntity.getColumnName()); sb.append(\" = \"); sb.append(\"#&#123;\" + versionColumnEntity.getFieldName() + \"&#125;\"); String sql = sb.toString(); return sql; &#125; /** * 根据id物理删除记录 * @param id * @return */ public String deleteOne(Object id) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); String sql = \"DELETE FROM \" + tableEntity.getTableName() + \" WHERE \" + tableEntity.getIdColumnEntity().getColumnName() + \" = #&#123;id&#125;\"; return sql; &#125; /** * 根据id逻辑删除记录 * @param id * @return */ public String logicDeleteOne(Object id) &#123; TableEntity tableEntity = MybatisTableUtils.getCurrentTableEntity(); String sql = \"UPDATE \" + tableEntity.getTableName() + \" SET \" + tableEntity.getDeleteColunmEntity().getColumnName() + \" = 0 \" + \"WHERE \" + tableEntity.getIdColumnEntity().getColumnName() + \" = #&#123;id&#125;\"; return sql; &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring Aop 定义切点","slug":"backend/spring/Spring Aop 定义切点","date":"2018-11-01T02:47:45.000Z","updated":"2018-11-13T11:59:09.624Z","comments":true,"path":"2018/11/01/backend/spring/Spring Aop 定义切点/","link":"","permalink":"http://www.songshuiyang.site/2018/11/01/backend/spring/Spring Aop 定义切点/","excerpt":"","text":"Spring AOP 中，需要使用 AspectJ 的切点表达式来定义切点。 AspectJ 指示器 描述 arg () 限制连接点的指定参数为指定类型的执行方法 @args () 限制连接点匹配参数由指定注解标注的执行方法 execution () 用于匹配连接点的执行方法 this () 限制连接点匹配 AOP 代理的 Bean 引用为指定类型的类 target () 限制连接点匹配特定的执行对象，这些对象对应的类要具备指定类型注解 within () 限制连接点匹配指定类型 @within () 限制连接点匹配指定注释所标注的类型（当使用 Spring AOP 时，方法定义在由指定的注解所标注的类里） @annotation () 限制匹配带有指定注释的连接点","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Markdown语法","slug":"backend/Markdown语法","date":"2018-10-31T17:07:12.000Z","updated":"2019-03-16T01:52:02.022Z","comments":true,"path":"2018/11/01/backend/Markdown语法/","link":"","permalink":"http://www.songshuiyang.site/2018/11/01/backend/Markdown语法/","excerpt":"","text":"图片1![logo](/images/server/mybatis/mybatis-framework.png) logo 表格:1234| a | b | c ||:-------:|:------------- | ----------:|| 居中 | 左对齐 | 右对齐 ||=========|===============|============| a b c 居中 左对齐 右对齐 ========= =============== ============","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"guava工具包.md","slug":"backend/Java/utils/guava工具包","date":"2018-10-31T07:11:12.000Z","updated":"2018-10-31T13:59:45.127Z","comments":true,"path":"2018/10/31/backend/Java/utils/guava工具包/","link":"","permalink":"http://www.songshuiyang.site/2018/10/31/backend/Java/utils/guava工具包/","excerpt":"","text":"驼峰字符和下划线字符相互转换工具类导入Maven12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt;&lt;/dependency&gt; 示例：12345678910111213141516import org.junit.Test;import com.google.common.base.CaseFormat;public class GuavaTester &#123; @Test public void test() &#123; System.out.println(CaseFormat.LOWER_HYPHEN.to(CaseFormat.LOWER_CAMEL, \"test-data\"));//testData System.out.println(CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, \"test_data\"));//testData System.out.println(CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, \"test_data\"));//TestData System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, \"testdata\"));//testdata System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, \"TestData\"));//test_data System.out.println(CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_HYPHEN, \"testData\"));//test-data &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"SpringBoot Maven中parent问题","slug":"backend/spring/spring-cloud/SpringBootMaven中parent问题","date":"2018-10-30T08:07:12.000Z","updated":"2018-10-31T13:59:45.129Z","comments":true,"path":"2018/10/30/backend/spring/spring-cloud/SpringBootMaven中parent问题/","link":"","permalink":"http://www.songshuiyang.site/2018/10/30/backend/spring/spring-cloud/SpringBootMaven中parent问题/","excerpt":"","text":"集成Spring boot时，官方示例中，都是让我们继承一个spring的 spring-boot-starter-parent 这个parent： 123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 但是，一般情况下，在我们自己的项目中，会定义一下自己的 parent 项目，这种情况下，上面的这种做法就行不通了。那么，该如何来做呢？其实，在spring的官网也给出了变通的方法的，在我们自己 parent 项目中，加下下面的声明： 1234567891011&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 请注意，它的 type 是 pom，scope 是 import，这种类型的 dependency 只能在 dependencyManagement 标签中声明，然后，把我们项目中的 子项目 中，parent 的声明，修改为我们自己项目的 parent 项目就可以了，比如，我的是：12345&lt;parent&gt; &lt;groupId&gt;com.songsy&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 详见： http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-maven-without-a-parent参考： https://blog.csdn.net/rainbow702/article/details/55046298","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"ThreadLocal","slug":"backend/Java/highConcurrency/ThreadLocal","date":"2018-10-29T07:24:12.000Z","updated":"2018-11-06T14:20:15.856Z","comments":true,"path":"2018/10/29/backend/Java/highConcurrency/ThreadLocal/","link":"","permalink":"http://www.songshuiyang.site/2018/10/29/backend/Java/highConcurrency/ThreadLocal/","excerpt":"","text":"ThreadLocal 作用在并发编程中时常有这样一种需求：每条线程都需要存取一个同名变量，但每条线程中该变量的值均不相同。 如果是你，该如何实现上述功能？常规的思路如下：使用一个线程共享的Map，Map中的key为线程对象，value即为需要存储的值。那么，我们只需要通过map.get(Thread.currentThread())即可获取本线程中该变量的值。 这种方式确实可以实现我们的需求，但它有何缺点呢？——答案就是：需要同步，效率低！ 由于这个map对象需要被所有线程共享，因此需要加锁来保证线程安全性。当然我们可以使用java.util.concurrent.*包下的ConcurrentHashMap提高并发效率，但这种方法只能降低锁的粒度，不能从根本上避免同步锁。而JDK提供的ThreadLocal就能很好地解决这一问题。下面来看看ThreadLocal是如何高效地实现这一需求的。 ThreadLocal 是什么 ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 ThreadLocal 解析 ThreadLocal的内部结构图 threadLocal 从上面的结构图，我们已经窥见ThreadLocal的核心机制： 每个Thread线程内部都有一个Map。 Map里面存储线程本地对象（key）和线程的变量副本（value） 但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 Thread线程内部的Map在类中描述如下:123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocal类提供如下几个核心方法： get()方法用于获取当前线程的副本变量值。 set()方法用于保存当前线程的副本变量值。 initialValue()为当前线程初始副本变量值。 remove()方法移除当前前程的副本变量值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 返回当前线程的副本变量 * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); // 返回Thread 对象中的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; // 如果没有值的话调用默认setInitialValue()方法 return setInitialValue();&#125;/** * 存放在Thread的 threadLocals * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;/** * 设置初始值 * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;// map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。protected T initialValue() &#123; return null;&#125;/** * 赋值 * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;/** * Removes the current thread's value for this thread-local * variable. If this thread-local variable is subsequently * &#123;@linkplain #get read&#125; by the current thread, its value will be * reinitialized by invoking its &#123;@link #initialValue&#125; method, * unless its value is &#123;@linkplain #set set&#125; by the current thread * in the interim. This may result in multiple invocations of the * &#123;@code initialValue&#125; method in the current thread. * * @since 1.5 */ public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); &#125; ThreadLocalMap ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现:12345678910111213141516171819202122static class ThreadLocalMap &#123; /** * 在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象 * * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as \"stale entries\" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; // Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。 super(k); value = v; &#125; &#125;&#125; ThreadLocalMap的问题由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。 为何要使用弱引用对弱引用不了解的同学可以参考 这篇文章：http://blog.csdn.net/u010425776/article/details/50760053。 Java设计之初的一大宗旨就是——弱化指针。Java设计者希望通过合理的设计简化编程，让程序员无需处理复杂的指针操作。然而指针是客观存在的，在目前的Java开发中也不可避免涉及到“指针操作”。如： 1Object a = new Object(); 上述代码创建了一个强引用a，只要强引用存在，垃圾收集器是不会回收该对象的。如果该对象非常庞大，那么为了节约内存空间，在该对象使用完成后，我们需要手动拆除该强引用，如下面代码所示： 1a = null; 此时，指向该对象的强引用消除了，垃圾收集器便可以回收该对象。但在这个过程中，仍然需要程序员处理指针。为了弱化指针这一概念，弱引用便出现了，如下代码创建了一个Person类型的弱引用：1WeakReference&lt;Person&gt; wr = new WeakReference&lt;Person&gt;(new Person()); 此时程序员不用再关注指针，只要没有强引用指向Person对象，垃圾收集器每次运行都会自动将该对象释放。 那么，ThreadLocalMap中的key使用弱引用的原因也是如此。当一条线程中的ThreadLocal对象使用完毕，没有强引用指向它的时候，垃圾收集器就会自动回收这个Key，从而达到节约内存的目的。 那么，问题又来了——这会导致内存泄漏问题！ 如何避免泄漏既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。 如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。 ThreadLocal 应用场景 Hibernate的session获取场景：每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。 12345678910111213141516171819202122private static final ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;();// 获取Sessionpublic static Session getCurrentSession()&#123; Session session = threadLocal.get(); // 判断Session是否为空，如果为空，将创建一个session，并设置到本地线程变量中 try &#123; if(session == null &amp;&amp; !session.isOpen())&#123; if(sessionFactory == null)&#123; // 创建Hibernate的SessionFactory rbuildSessionFactory(); &#125;else&#123; session = sessionFactory.openSession(); &#125; &#125; threadLocal.set(session); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return session;&#125; 总结： 每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。 ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。 适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。 参考 https://www.jianshu.com/p/98b68c97df9b https://www.jianshu.com/p/3f3620f9011d","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"网关服务Zuul","slug":"backend/spring/spring-cloud/网关服务Zuul","date":"2018-10-23T12:07:12.000Z","updated":"2018-10-23T13:25:14.276Z","comments":true,"path":"2018/10/23/backend/spring/spring-cloud/网关服务Zuul/","link":"","permalink":"http://www.songshuiyang.site/2018/10/23/backend/spring/spring-cloud/网关服务Zuul/","excerpt":"","text":"Zuul 简介Zuul是什么 Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。Zuul组件的核心是一系列的过滤器 为什么要用Zuul在分布式架构中，对外提供的服务，在无网关的情况下，API接口直接暴露给服务调用方，当调用方增多，不同业务调用方各不相同，势必需要添加定制化访问权限、校验等逻辑。当添加API网关后，再第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。Zuul就是提供负载均衡、反向代理、权限认证的这么一个API gateway。 微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关 logo Zuul 提供什么功能Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能： 身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求 审查与监控： 动态路由：动态将请求路由到不同后端集群 压力测试：逐渐增加指向集群的流量，以了解性能 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求 静态响应处理：边缘位置进行响应，避免转发到内部集群 多区域弹性：跨域AWS Region进行请求路由，旨在实现ELB(ElasticLoad Balancing)使用多样化 Spring Cloud对Zuul进行了整合和增强。目前，Zuul使用的默认是Apache的HTTP Client，也可以使用Rest Client，可以设置ribbon.restclient.enabled=true. 简单示例 路由配置 application.yml12345678910111213141516171819202122server: port: 9001spring: application: name: zuul-gatewayeureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9011/eureka/zuul: routes: baidu-url: #传统路由方式 path: /baidu/** url: http://www.baidu.com/ provider: #面向服务的路由 path: /provider/** serviceId: eureka-provider consumer: #面向服务的路由 path: /consumer/** serviceId: eureka-consumer 请求过滤 AccessFilter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 请求过滤 * @author songshuiyang * @date 2018/10/23 20:50 */public class AccessFilter extends ZuulFilter&#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 定义过滤器的类型，决定过滤器在请求的那个生命周期中执行 * @return */ @Override public String filterType() &#123; // 代表会在请求被路由之前被执行 return \"pre\"; &#125; /** * 定义过滤器的顺序 * @return */ @Override public int filterOrder() &#123; return 0; &#125; /** * 判断过滤器是否需要被执行 * @return */ @Override public boolean shouldFilter() &#123; return false; &#125; /** * 过滤器的具体实现 * @return */ @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); logger.info(\"send &#123;&#125; request to &#123;&#125;\", request.getMethod(), request.getRequestURL().toString()); Object accessToken = request.getParameter(\"accessToken\"); if (accessToken == null) &#123; logger.error(\"access check failed\"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); return null; &#125; logger.error(\"access check passs\"); return null; &#125;&#125;Zuul的过滤器之间没有直接的相互通信，他们之间通过一个RequestContext的静态类来进行数据传递的。RequestContext类中有ThreadLocal变量来记录每个Request所需要传递的数据。Zuul的过滤器是由Groovy写成，这些过滤器文件被放在Zuul Server上的特定目录下面，Zuul会定期轮询这些目录，修改过的过滤器会动态的加载到Zuul Server中以便过滤请求使用。下面有几种标准的过滤器类型：Zuul大部分功能都是通过过滤器来实现的。Zuul中定义了四种标准过滤器类型，这些过滤器类型对应于请求的典型生命周期。(1) PRE：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。(2) ROUTING：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。(3) POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。(4) ERROR：在其他阶段发生错误时执行该过滤器。 其他 当我们为Spring Cloud Zuul构建的API网关服务引入Spring Cloud Eureka之后，它会为Eureka中的每个服务都自动创建一个默认路由规则，这些默认规则的path会使用ServiceId配置的服务名作为请求前缀 动态加载动态路由todo 动态过滤器todo","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"注册中心Consul","slug":"backend/spring/spring-cloud/注册中心Consul","date":"2018-10-22T08:07:12.000Z","updated":"2018-10-22T13:00:12.554Z","comments":true,"path":"2018/10/22/backend/spring/spring-cloud/注册中心Consul/","link":"","permalink":"http://www.songshuiyang.site/2018/10/22/backend/spring/spring-cloud/注册中心Consul/","excerpt":"","text":"Consul 介绍 Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其它分布式服务注册与发现的方案，Consul 的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其它工具（比如 ZooKeeper 等）。使用起来也较 为简单。Consul 使用 Go 语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与 Docker 等轻量级容器可无缝配合。 Consul 的优势 使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft。 支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等。 zookeeper 和 etcd 均不提供多数据中心功能的支持。 支持健康检查。 etcd 不提供此功能。 支持 http 和 dns 协议接口。 zookeeper 的集成较为复杂, etcd 只支持 http 协议。 官方提供 web 管理界面, etcd 无此功能。 综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究。Consul 角色 client: 客户端, 无状态, 将 HTTP 和 DNS 接口请求转发给局域网内的服务端集群。 server: 服务端, 保存配置信息, 高可用集群, 在局域网内与本地客户端通讯, 通过广域网与其它数据中心通讯。 每个数据中心的 server 数量推荐为 3 个或是 5 个。 Consul 工作原理 logo 1、当 Producer 启动的时候，会向 Consul 发送一个 post 请求，告诉 Consul 自己的 IP 和 Port 2、Consul 接收到 Producer 的注册后，每隔10s（默认）会向 Producer 发送一个健康检查的请求，检验Producer是否健康 3、当 Consumer 发送 GET 方式请求 /api/address 到 Producer 时，会先从 Consul 中拿到一个存储服务 IP 和 Port 的临时表，从表中拿到 Producer 的 IP 和 Port 后再发送 GET 方式请求 /api/address 4、该临时表每隔10s会更新，只包含有通过了健康检查的 Producer Consul 模式 CLIENT：表示consul的client模式，就是客户端模式。是consul节点的一种模式，这种模式下，所有注册到当前节点的服务会被转发到SERVER，本身是不持久化这些信息。 SERVER：表示consul的server模式，表明这个consul是个server，这种模式下，功能和CLIENT都一样，唯一不同的是，它会把所有的信息持久化的本地，这样遇到故障，信息是可以被保留的。 SERVER-LEADER：中间那个SERVER下面有LEADER的字眼，表明这个SERVER是它们的老大，它和其它SERVER不一样的一点是，它需要负责同步注册的信息给其它的SERVER，同时也要负责各个节点的健康监测。 其它信息：其它信息包括它们之间的通信方式，还有一些协议信息，算法。它们是用于保证节点之间的数据同步，实时性要求等等一系列集群问题的解决。这些有兴趣的自己看看官方文档。 参考：http://www.ityouknow.com/springcloud/2018/07/20/spring-cloud-consul.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"声明式服务调用Feign","slug":"backend/spring/spring-cloud/声明式服务调用Feign","date":"2018-10-17T13:07:12.000Z","updated":"2018-10-22T14:55:42.724Z","comments":true,"path":"2018/10/17/backend/spring/spring-cloud/声明式服务调用Feign/","link":"","permalink":"http://www.songshuiyang.site/2018/10/17/backend/spring/spring-cloud/声明式服务调用Feign/","excerpt":"","text":"Feign 简介是什么Feign是一个声明式的Web Service客户端，整合了Spring Cloud Ribbon与Spring Cloud Hystrix 为什么要使用 只需创建一个接口并用注解的方式来配置它，即可完成服务提供方的接口绑定 在使用过程中与Spring Mvc完美衔接 整合了Spring Cloud Ribbon，可实现负载均衡，实现服务高可用 整合了Spring Cloud Hystrix，可实现服务断路及服务降级 简单例子 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; PersonService.java 123456789101112131415/** * name 为服务提供者 application-name，fallback 指定服务接口的断路器实现方法，自带Ribbon负债均衡及重试机制 * @author songshuiyang * @date 2018/10/22 21:53 */@FeignClient(name = \"eureka-provider\", fallback = PersonHystrixFallback.class)public interface PersonService &#123; @RequestMapping(\"getPersonName\") String getPersonName(); @RequestMapping(\"getPerson\") Person getPerson();&#125; PersonHystrixFallback.java123456789101112131415161718/** * Hystrix服务降级 每一个服务接口的断路器实现就是实现类中重写函数的实现 * @author songshuiyang * @date 2018/10/22 22:26 */@Componentpublic class PersonHystrixFallback implements PersonService &#123; @Override public String getPersonName() &#123; return \"HystrixFallbackService ERROR\"; &#125; @Override public Person getPerson() &#123; return new Person(0,\"HystrixFallbackService ERROR\",88); &#125;&#125; FeignAppliacation.java 123456789101112/** * @author songshuiyang * @date 2018/10/22 21:50 */@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class FeignAppliacation &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignAppliacation.class,args); &#125;&#125; application.yml 1234567891011121314151617server: port: 9031spring: application: name: feign-consumereureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9011/eureka/ribbon: ConnectTimeout: 500 ReadTimeout: 5000feign: hystrix: enabled: true","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"服务容错保护Hystrix","slug":"backend/spring/spring-cloud/服务容错保护Hystrix","date":"2018-10-17T13:07:12.000Z","updated":"2018-10-23T12:17:05.942Z","comments":true,"path":"2018/10/17/backend/spring/spring-cloud/服务容错保护Hystrix/","link":"","permalink":"http://www.songshuiyang.site/2018/10/17/backend/spring/spring-cloud/服务容错保护Hystrix/","excerpt":"","text":"Hystrix 简介Hystrix是什么Hystrix对应的中文名字是“豪猪”，豪猪周身长满了刺，能保护自己不受天敌的伤害，代表了一种防御机制，这与hystrix本身的功能不谋而合，因此Netflix团队将该框架命名为Hystrix，并使用了对应的卡通形象做作为logo。 为什么要使用在一个分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，这个就是Hystrix需要做的事情。 提供哪些功能Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"负载均衡Ribbon","slug":"backend/spring/spring-cloud/负载均衡Ribbon","date":"2018-10-16T14:07:12.000Z","updated":"2019-02-17T04:48:00.787Z","comments":true,"path":"2018/10/16/backend/spring/spring-cloud/负载均衡Ribbon/","link":"","permalink":"http://www.songshuiyang.site/2018/10/16/backend/spring/spring-cloud/负载均衡Ribbon/","excerpt":"","text":"什么是Spring Cloud Ribbon 一个基于HTTP和TCP的客户端负载均衡工具 简单示例1、集成ribbon1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 2、消费方 消费方调用方法12345678910111213141516171819202122@Configuration@RestControllerpublic class DemoController &#123; /** * 主要用来调用REST服务，本身并不具备调用分布式服务的能力，但通过LoadBalanced注解开启客户端负债均衡 * @return */ @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125; @RequestMapping(value = \"/router\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public String router() &#123; RestTemplate restTpl = getRestTemplate(); // 根据应用名称调用服务 String json = restTpl.getForObject(\"http://eureka-provider/person/1\", String.class); return json; &#125;&#125; 消费方配置文件1234567891011server: port: 9050spring: application: name: eureka-consumereureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9020/eureka/ 3、服务方 服务提供方法, 这里就是简单模拟了一下根据personId获取人员信息，并返回对应服务的端口1234567@RequestMapping(value = \"/person/&#123;personId&#125;\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE) public Person findPerson(@PathVariable(\"personId\") Integer personId, HttpServletRequest request) &#123; Person person = new Person(personId, \"songsy\", 18); person.setName(person.getName() + \"端口：\" + IpConfigurationUtils.getPort()); return person; &#125; 配置文件123456789spring: application: name: eureka-providereureka: instance: hostname: localhost client: service-url: defaultZone: http://localhost:9010/eureka/,http://localhost:9020/eureka/ 3.1 服务方1 以9011端口启动123public static void main(String[] args) &#123; new SpringApplicationBuilder(Slave1ProviderApplication.class).properties(\"server.port=9011\").run(args);&#125; 3.2 服务方2 以9023端口启动123public static void main(String[] args) &#123; new SpringApplicationBuilder(Slave1ProviderApplication.class).properties(\"server.port=9023\").run(args);&#125; 4、测试结果连续访问 http://localhost:9050/router 会得到不同的结果， 可以看到已经实现了负载均衡123&#123;\"id\":1,\"name\":\"songsy端口：9023\",\"age\":18&#125;&#123;\"id\":1,\"name\":\"songsy端口：9011\",\"age\":18&#125; 二：RestTemplate 使用 GET 请求 提供 getForObject()、 getForEntity() POST 请求 提供 postForObject()、 postForObject()、postForLocation() PUT 请求 提供 put(), put() 函数没有返回内容 DELETE 请求 提供 delete() 三：源码分析 Ribbon实现客户端负债均衡是通过@LoadBalanced注解来开启的 @LoadBalanced 注解 123456789101112/*** 使用 LoadBalancerClient 该类来配置 * Annotation to mark a RestTemplate bean to be configured to use a LoadBalancerClient * @author Spencer Gibb */@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Qualifierpublic @interface LoadBalanced &#123;&#125; LoadBalancerClient.java 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Represents a client side load balancer * @author Spencer Gibb */public interface LoadBalancerClient extends ServiceInstanceChooser &#123; /** * 根据挑选出来服务实例执行请求 * execute request using a ServiceInstance from the LoadBalancer for the specified * service * @param serviceId the service id to look up the LoadBalancer * @param request allows implementations to execute pre and post actions such as * incrementing metrics * @return the result of the LoadBalancerRequest callback on the selected * ServiceInstance */ &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException; /** * 根据服务实例执行请求 * execute request using a ServiceInstance from the LoadBalancer for the specified * service * @param serviceId the service id to look up the LoadBalancer * @param serviceInstance the service to execute the request to * @param request allows implementations to execute pre and post actions such as * incrementing metrics * @return the result of the LoadBalancerRequest callback on the selected * ServiceInstance */ &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException; /** * 将 http://myservice/path/to/service 构建一个真实的host:port形式的url * Create a proper URI with a real host and port for systems to utilize. * Some systems use a URI with the logical serivce name as the host, * such as http://myservice/path/to/service. This will replace the * service name with the host:port from the ServiceInstance. * @param instance * @param original a URI with the host as a logical service name * @return a reconstructed URI */ URI reconstructURI(ServiceInstance instance, URI original);&#125; ServiceInstanceChooser.java12345678910public interface ServiceInstanceChooser &#123; /** * 根据传入的服务实例名serviceId，从负债均衡中挑选一个对应服务的实例 * Choose a ServiceInstance from the LoadBalancer for the specified service * @param serviceId the service id to look up the LoadBalancer * @return a ServiceInstance that matches the serviceId */ ServiceInstance choose(String serviceId);&#125; 主要负载均衡策略1、简单轮询负载均衡（RoundRobin）以轮询的方式依次将请求调度不同的服务器，即每次调度执行i = (i + 1) mod n，并选出第i台服务器。 2、随机负载均衡 （Random）随机选择状态为UP的Server 3、加权响应时间负载均衡 （WeightedResponseTime）根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。 4、区域感知轮询负载均衡（ZoneAvoidanceRule）复合判断server所在区域的性能和server的可用性选择server","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"服务治理Eureka","slug":"backend/spring/spring-cloud/服务治理Eureka","date":"2018-10-15T14:07:12.000Z","updated":"2018-10-16T14:20:15.267Z","comments":true,"path":"2018/10/15/backend/spring/spring-cloud/服务治理Eureka/","link":"","permalink":"http://www.songshuiyang.site/2018/10/15/backend/spring/spring-cloud/服务治理Eureka/","excerpt":"","text":"Spring Cloud Netflix简介SpringCloud是一个基于SpringBoot实现的云应用开发工具，它为基于JVM的云应用开发中的配置故那里、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了简单的开发方式。 SpringCloud下包含了多个工程，其中的Spring Cloud Netflix提供了一系列搭建微服务基础架构的功能组件。 Netflix的部分组件及功能特性如下： Eureka（服务注册与发现框架）：一个基于REST风格的服务组件，用于定位服务，以实现云端的负载均衡和中间层服务器的故障转移 Hystrix（服务容错组件）：容错管理工具，旨在通过控制服务和第三方库的节点，从而对延迟和故障提供强大的容村能力 Zuul（服务网关）：边缘服务工具，提供动态路由、监控、贪心、安全等边缘服务 Ribbon（客户端负载均衡器）：提供客户端负载均衡算法，将Netflix的中间层服务连接起来 Feign（声明式HTTP客户端）：可以创建声明式、模板化的HTTP客户端，进行微服务调用 什么是 EurekaEureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。SpringCloud将它集成在其子项目spring-cloud-netflix中，以实现SpringCloud的服务发现功能。 https://github.com/songshuiyang/eureka-parent/blob/master/doc/images/eureka1.png 服务发现服务发现就像聊天室一个,每个用户来的时候去服务器上注册,这样他的好友们就能看到你,你同时也将获取好友的上线列表.在微服务中,服务就相当于聊天室的用户,而服务注册中心就像聊天室服务器一样。 目前服务发现的解决方案有Eureka,Consul,Etcd,Zookeeper,SmartStack,等等 Eureka Client通过HTTP(或者TCP,UDP)去Eureka Server册和获取服务列表,为了高可用一般会有多个 Eureka Server组成集群.Eureka会移除那些心跳检查未到达的服务.","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"Springboot构建微服务","slug":"backend/spring/spring-cloud/Springboot构建微服务","date":"2018-10-15T13:07:12.000Z","updated":"2018-10-15T14:19:52.882Z","comments":true,"path":"2018/10/15/backend/spring/spring-cloud/Springboot构建微服务/","link":"","permalink":"http://www.songshuiyang.site/2018/10/15/backend/spring/spring-cloud/Springboot构建微服务/","excerpt":"","text":"什么是Spring-bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程(习惯优于配置)。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 核心功能 独立运行的Spring项目,可以以jar包的形式独立运行, 运行一个Spring boot项目只要通过 java -jar xx.jar 内嵌Tomcat, Jetty, Undertow 无需以war包形式部署项目 提供starter简化Maven配置 自动配置Bean, 极大的减少了我们要使用的配置 优点 快速构建项目 对主流开发框架的无配置集成 项目可独立运行 提供运行时的应用监控 Starter POMs Spring Boot 通过starter依赖为项目的依赖管理提供帮助.starter依赖起始就是特殊的maven依赖,利用了传递依赖解析,把常用库聚合在一起,组成了几个为特定功能而定制的依赖. 所有的starters遵循一个相似的命名模式：spring-boot-starter-，在这里是一种特殊类型的应用程序。eg: 名称 描述 spring-boot-starter 对自动配置、日志记录和YAML支持，核心starter spring-boot-starter-thymeleaf 对Thymeleaf模板引擎的支持，Spring mvc的集成 spring-boot-starter-web 对web支持，包括RESTful，使用tomcat作为默认容器 spring-boot-starter-data-jpa 对jpa支持 不同环境不同配置文件 针对各环境新建不同的配置文件 application-dev.properties、application-test.properties、application-prod.properties , 在这三个文件均都设置不同的server.port属性，如：dev环境设置为8080，test环境设置为9090，prod环境设置为80 application.properties中设置spring.profiles.active=dev，就是说默认以dev环境设置 采用命令行的形式 12345执行java -jar xxx.jar，可以观察到服务端口被设置为8080，也就是默认的开发环境（dev）执行java -jar xxx.jar --spring.profiles.active=test，可以观察到服务端口被设置为9090，也就是测试环境的配置（test）执行java -jar xxx.jar --spring.profiles.active=prod，可以观察到服务端口被设置为80，也就是生产环境的配置（prod） 数据文件的加载顺序 在命令行中传入的参数 SPRING_APPLICATION_JSON: 以JSON格式配置在系统环境变量中的内容 java:comp/env 的JNDI属性 Java的系统属性，可以通过System.getProperties() 操作系统的环境变量 通过 random.* 配置的随机属性 位当前jar之外，针对不同{profile}环境的配置文件内容, application-{profile}.yml 位当前jar之内，针对不同{profile}环境的配置文件内容, application-{profile}.yml 位当前jar之外，application.yml 位当前jar之内，application.yml","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"spring-data-jpa","slug":"backend/spring/spring-data/spring-data-jpa","date":"2018-09-10T11:01:44.000Z","updated":"2018-10-15T12:32:16.771Z","comments":true,"path":"2018/09/10/backend/spring/spring-data/spring-data-jpa/","link":"","permalink":"http://www.songshuiyang.site/2018/09/10/backend/spring/spring-data/spring-data-jpa/","excerpt":"","text":"logo logo logo","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"jpa","slug":"jpa","permalink":"http://www.songshuiyang.site/tags/jpa/"}]},{"title":"BigDecimal","slug":"backend/Java/常用类/BigDecimal","date":"2018-09-05T01:24:12.000Z","updated":"2019-02-17T04:48:00.771Z","comments":true,"path":"2018/09/05/backend/Java/常用类/BigDecimal/","link":"","permalink":"http://www.songshuiyang.site/2018/09/05/backend/Java/常用类/BigDecimal/","excerpt":"","text":"构造函数 参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。 另一方面，String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法。 当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。 运算 减乘除其实最终都返回的是一个新的BigDecimal对象，因为BigInteger与BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以a.add(b);虽然做了加法操作，但是a并没有保存加操作后的值，正确的用法应该是a=a.add(b); 精度1234567891011121314151617BigDecimal.setScale() 方法用于格式化小数点setScale(1) 表示保留一位小数，默认用四舍五入方式setScale(1,BigDecimal.ROUND_DOWN) 直接删除多余的小数位，2.31变成2.3、2.35会变成2.3setScale(1,BigDecimal.ROUND_UP) 进位处理，2.31变成2.4 2.35变成2.4 setScale(1,BigDecimal.ROUND_CEILING) 如果为正数，则舍入行为与 ROUND_UP 相同，反之舍入行为与 ROUND_DOWN 相同setScale(1,BigDecimal.ROUND_FLOOR) 如果为正数，则舍入行为与 ROUND_DOWN 相同，反之舍入行为与 ROUND_UP 相同setScale(1,BigDecimal.ROUND_HALF_UP) 四舍五入，2.35变成2.4setScale(1,BigDecimal.ROUND_HALF_DOWN) 四舍五入，2.35变成2.3(如果是5则向下舍)，2.36变成2.4setScale(1,BigDecimal.ROUND_HALF_EVEN) 银行家舍入法 如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同 如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。如 1.15&gt;1.2 1.25&gt;1.2 异常处理foo.divide(bar)); 报异常1java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result。 原因： 1234567891011121314151617原来JAVA中如果用BigDecimal做除法的时候一定要在divide方法中传递第二个参数，定义精确到小数点后几位，否则在不整除的情况下，结果是无限循环小数时，就会抛出以上异常。解决方法：foo.divide(bar, 2, BigDecimal.ROUND_HALF_UP);注意这个divide方法有两个重载的方法，一个是传两个参数的，一个是传三个参数的：两个参数的方法：@param divisor value by which this &#123;@code BigDecimal&#125; is to be divided. 传入除数@param roundingMode rounding mode to apply. 传入round的模式三个参数的方法：@param divisor value by which this &#123;@code BigDecimal&#125; is to be divided. 传入除数@param scale scale of the &#123;@code BigDecimal&#125; quotient to be returned. 传入精度@param roundingMode rounding mode to apply. 传入round的模式","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"在SELECT 的读取锁定主要分为两种方式","slug":"backend/数据库/在SELECT 的读取锁定主要分为两种方式","date":"2018-08-01T15:15:12.000Z","updated":"2018-08-01T15:42:41.234Z","comments":true,"path":"2018/08/01/backend/数据库/在SELECT 的读取锁定主要分为两种方式/","link":"","permalink":"http://www.songshuiyang.site/2018/08/01/backend/数据库/在SELECT 的读取锁定主要分为两种方式/","excerpt":"","text":"在SELECT 的读取锁定主要分为两种方式： SELECT … LOCK IN SHARE MODE SELECT … FOR UPDATE 这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。 而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。 简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT … UPDATE。 悲观锁介绍 悲观锁是对数据被的修改持悲观态度（认为数据在被修改的时候一定会存在并发问题），因此在整个数据处理过程中将数据锁定。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在应用层中实现了加锁机制，也无法保证外部系统不会修改数据）。 使用场景举例商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。如果不采用锁，那么操作方法如下：123456//1.查询出商品信息select status from t_goods where id=1;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2; 上面这种场景在高并发访问的情况下很可能会出现问题。前面已经提到，只有当goods status为1时才能对该商品下单，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步Update操作的时候，有可能出现其他人先一步对商品下单把goods status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。 使用悲观锁来实现在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出goods信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。要使用悲观锁，我们必须关闭mysql数据库的自动提交属性。 123456789101112set autocommit=0; //设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work; 注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。 上面的第一步我们执行了一次查询操作：select status from t_goods where id=1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 注：需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 相同数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。拿上面的实例来说，当我执行select status from t_goods where id=1 for update;后。我在另外的事务中如果再次执行select status from t_goods where id=1 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from t_goods where id=1;则能正常查询出数据，不会受第一个事务的影响。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"db","slug":"db","permalink":"http://www.songshuiyang.site/tags/db/"}]},{"title":"null != a 与 a != null 区别","slug":"backend/Java/null判断","date":"2018-08-01T12:09:12.000Z","updated":"2018-08-01T12:39:55.072Z","comments":true,"path":"2018/08/01/backend/Java/null判断/","link":"","permalink":"http://www.songshuiyang.site/2018/08/01/backend/Java/null判断/","excerpt":"","text":"在其他人的项目中经常会看到 null ! = a 这种写法, 但平常使用的是都是 a != null 这种写法 原因：功能上是没有区别的，企业里大多是时候是推荐第一种的，是因为能够防止程序员书写遗漏等号导致错误。比如：null != a 这样少了“！”也会报错。而a ！=null少了”！”就不会报错了。程序员有时候容易把 == 误写为 = ，如果把常量放前面 5 = i ，会编译错误，而写成i=5就不会报错了，所以这样写能发现这种笔误bug。 总结 所以在实际项目中，细节很重要，一个小小的问题有可能导致一系列的问题。 多阅读其他人的代码，借鉴其他人的思想及技巧。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"高可用","slug":"backend/Java/高可用","date":"2018-07-31T16:24:12.000Z","updated":"2018-07-31T16:42:07.620Z","comments":true,"path":"2018/08/01/backend/Java/高可用/","link":"","permalink":"http://www.songshuiyang.site/2018/08/01/backend/Java/高可用/","excerpt":"","text":"一、什么是高可用 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。 假设系统一直能够提供服务，我们说系统的可用性是100%。 如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。 很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。 百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过www.baidu.com 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度最高的褒奖。 如何保障系统的高可用我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。 保证系统高可用，架构设计的核心准则是：冗余。 有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。 接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。 分层高可用架构实践下面的图是常见的互联网分层架构 logo 【客户端层】到【反向代理层】的高可用， 是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。 自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。 【反向代理层-&gt;站点层】的高可用 【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。 自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。 【站点层-&gt;服务层】的高可用 【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。 自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。 【服务层&gt;数据库层】的高可用 大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。 参考： https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959728&amp;idx=1&amp;sn=933227840ec8cdc35d3a33ae3fe97ec5&amp;chksm=bd2d046c8a5a8d7a13551124af36bedf68f7a6e31f6f32828678d2adb108b86b7e08c678f22f&amp;scene=21#wechat_redirect","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"高并发","slug":"backend/Java/highConcurrency/高并发","date":"2018-07-31T15:24:12.000Z","updated":"2018-10-29T13:34:48.578Z","comments":true,"path":"2018/07/31/backend/Java/highConcurrency/高并发/","link":"","permalink":"http://www.songshuiyang.site/2018/07/31/backend/Java/highConcurrency/高并发/","excerpt":"","text":"一、什么是高并发 通常指通过设计保证系统能够同时并行处理很多请求。 高并发相关常用的一些指标 参数 定义 响应时间 系统对请求做出响应的时间。例如系统处理一个HTTP请求需要200ms，这个200ms就是系统的响应时间。 吞吐量 单位时间内处理的请求数量。 QPS 每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。 并发用户数 同时承载正常使用系统功能的用户数量。例如一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。 二、如何提升系统的并发能力 互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。 垂直扩展提升单机处理能力。垂直扩展的方式又有两种： 增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G，带宽； 提升单机架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间； 水平扩展下面的图是常见的互联网分层架构 logo 常见互联网分布式架构（1）客户端层：典型调用方是浏览器browser或者手机应用APP （2）反向代理层：系统入口，反向代理 （3）站点应用层：实现核心应用逻辑，返回html或者json （4）服务层：如果实现了服务化，就有这一层 （5）数据-缓存层：缓存加速访问存储 （6）数据-数据库层：数据库固化数据存储 各分层水平扩展架构实践 反向代理层的水平扩展: 配置多个服务器数量 反向代理层的水平扩展，是通过“DNS轮询”实现的：dns-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。 当nginx成为瓶颈的时候，只要增加服务器数量，新增nginx服务的部署，增加一个外网ip，就能扩展反向代理层的性能，做到理论上的无限高并发。 站点层的水平扩展: 配置多个web服务 站点层的水平扩展，是通过“nginx”实现的。通过修改nginx.conf，可以设置多个web后端。 当web后端成为瓶颈的时候，新增web服务的部署，在nginx配置中配置上新的web后端，就能扩展站点层的性能，做到理论上的无限高并发。 服务层的水平扩展 1.服务层的水平扩展，是通过“服务连接池”实现的。 站点层通过RPC-client调用下游的服务层RPC-server时，RPC-client中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在RPC-client处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。 2.动静分离，页面静态化，CDN加速 3.不要频繁的new对象,对于在整个应用中只需要存在一个实例的类使用单例模式 数据层的水平扩展：缓存，数据库 在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。 三、如何处理高并发线程安全问题Java进程加锁乐观锁与悲观锁乐观锁乐观锁是相对悲观锁来说的，它认为数据一般情况下不会造成冲突，所以在访问记录前不会加排他锁，而是在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，具体说根据update返回的行数让用户决定如何去做。乐观锁并不会使用数据库提供的锁机制，一般在表添加version字段或者使用业务状态来做。 悲观锁悲观锁，指数据被外界修改持保守态度(悲观),在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 。数据库中实现是对数据记录进行操作前，先给记录加排它锁，如果获取锁失败，则说明数据正在被其他线程修改，则等待或者抛出异常。如果加锁成功，则获取记录，对其修改，然后事务提交后释放排它锁。 一个例子：select * from 表 where .. for update; 悲观锁是先加锁再访问策略，处理加锁会让数据库产生额外的开销，还有增加产生死锁的机会，另外在多个线程只读情况下不会产生数据不一致行问题，没必要使用锁，只会增加系统负载，降低并发性，因为当一个事务锁定了该条记录，其他读该记录的事务只能等待。 乐观锁直到提交的时候才去锁定，所以不会产生任何锁和死锁。 参考: https://blog.csdn.net/DreamWeaver_zhou/article/details/78587580","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Integer 类型与 int 的==比较","slug":"backend/Java/Integer 类型与 int 的==比较","date":"2018-07-25T03:24:12.000Z","updated":"2018-07-25T06:49:47.378Z","comments":true,"path":"2018/07/25/backend/Java/Integer 类型与 int 的==比较/","link":"","permalink":"http://www.songshuiyang.site/2018/07/25/backend/Java/Integer 类型与 int 的==比较/","excerpt":"","text":"先上题123456789101112131415161718package com.lizi.basic;public class IntegerDemo &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; int c = 3; System.out.println(a == b); System.out.println(a == c); Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125;&#125; 分析思路 基本类型 基本数据类类型存的是数值本身 引用类型 引用类型变量在内存放的是数据的引用 基本类型通过 == 比较的是他们的值大小，而引用类型比较的是他们的引用地址 Integer 用 == 比较的时候往往非常容易出错123456789Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;System.out.println(f1 == f2);System.out.println(f3 == f4);// 当我们给一个Integer赋予一个int类型的时候会调用Integer的静态方法valueOf。Integer f1 = Integer.valueOf(100); Integer f2 = Integer.valueOf(100); Integer f3 = Integer.valueOf(150); Integer f4 = Integer.valueOf(150); 思考：那么Integer.valueOf()返回的Integer是不是是重新new Integer(num);来创建的呢？如果是这样的话，那么== 比较返回都是false，因为他们引用的堆地址不一样 具体来看看Integer.valueOf的源码 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在IntegerCache中cache数组初始化如下，存入了-128 - 127的值1234cache = new Integer[(high - low) + 1];int j = low;for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); 从上面我们可以知道给Interger 赋予的int数值在-128 - 127的时候，直接从cache中获取，这些cache引用对Integer对象地址是不变的，但是不在这个范围内的数字，则new Integer(i) 这个地址是新的地址，不可能一样的 Integer 与 int1234567891011121314Integer a = new Integer(3);Integer b = 3;int c = 3;System.out.println(a == b);System.out.println(a == c);a == b分析Integer b = 3; 自动调用Integer.valueOf(3) 返回一个Integer的对象。 这个对象存放到cache中的而 Integer a = new Integer(3);这里创建了一个新的对象Integer 所以 a == b 返回的是falsea == c 分析一个Integer 与 int比较，先将Integer转换成int类型，再做值比较，所以返回的是true 最后答案1234567891011121314151617public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; int c = 3; System.out.println(a == b); System.out.println(a == c); Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150; System.out.println(f1 == f2); System.out.println(f3 == f4); &#125; false true true false","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"基于 CentOS 搭建 Jenkins 自动化部署服务","slug":"backend/centos/基于 CentOS 搭建 Jenkins服务","date":"2018-07-20T12:48:12.000Z","updated":"2018-07-21T04:05:39.268Z","comments":true,"path":"2018/07/20/backend/centos/基于 CentOS 搭建 Jenkins服务/","link":"","permalink":"http://www.songshuiyang.site/2018/07/20/backend/centos/基于 CentOS 搭建 Jenkins服务/","excerpt":"","text":"需求： 使用 Jenkins 完成 git + Maven项目 + Tomcat 自动化部署 一： 环境准备1. Jenkins环境准备1.1 安装 jenkins-2.7.3123wget http://pkg.jenkins-ci.org/redhat-stable/jenkins-2.7.3-1.1.noarch.rpmrpm -ivh jenkins-2.7.3-1.1.noarch.rpm 1.2 配置启动12345678910111213141516171819202122232425262728291. 修改配置文件，默认端口为8080，如果不冲突则不需要修改 vim /etc/sysconfig/jenkins JENKINS_PORT=\"9080\"2. 配置JDK,启动服务如果报Java路径错误, 需要到vim /etc/profile 查看java路径 修改Jenkins启动配置文件，指定java安装路径。 /usr/local/jdk1.8.0_181/bin/java vim /etc/init.d/jenkins 在candidates中第一行添加java路径，如下： candidates=\" /usr/local/jdk1.8.0_181/bin/java /etc/alternatives/java /usr/lib/jvm/java-1.6.0/bin/java /usr/lib/jvm/jre-1.6.0/bin/java /usr/lib/jvm/java-1.7.0/bin/java /usr/lib/jvm/jre-1.7.0/bin/java /usr/lib/jvm/java-1.8.0/bin/java /usr/lib/jvm/jre-1.8.0/bin/java /usr/bin/java \" 3. 修改jenkins用户 为\"root\"用户4. 启动jenkins服务service jenkins restart5. 启动完成之后即可通过ip 端口进行访问 logo 2. Git 环境准备1234567安装git[root@iZwz9fjhnq78zfjphj8hi4Z bin]# yum –y install git查看是否安装成功[root@iZwz9fjhnq78zfjphj8hi4Z bin]# git --versiongit version 1.8.3.1 3. Maven 环境准备3.1 安装1234567cd /usr/localwget http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gztar zxf apache-maven-3.5.4-bin.tar.gzmv apache-maven-3.5.4 /usr/local/maven-3.5.4 3.2 配置环境变量1234567891011vi /etc/profile然后还需要 配置环境变量。#在适当的位置添加export M2_HOME=/usr/local/maven-3.5.4export PATH=$PATH:$JAVA_HOME/bin:$M2_HOME/bin保存退出后运行下面的命令使配置生效，或者重启服务器生效。source /etc/profile验证版本mvn -v 3.3 更换库源 阿里maven库123456789101112（1）找到 apache-maven-3.5.2\\conf 目录中的 settings.xml 文件（2）修改maven 本地仓库地址, 首先在D:\\Program Files创建文件夹MavenRepository ； 找到settings.xml 文件中 &lt;localRepository&gt; &lt;/localRepository&gt;打开注释修改如下： &lt;localRepository&gt;D:\\Program Files\\MavenRepository&lt;/localRepository&gt;（3）添加阿里源 ，找到 &lt;mirrors&gt; &lt;/ mirrors&gt;标签，在标签内部 添加内容如下： &lt;mirror&gt; &lt;id&gt;AliMaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 4. 使用Jenkins4.1 配置工具环境配置上面的环境都准备好了之后，先配置一下 参数(系统管理-&gt; 全局工具配置) git不用配置使用默认 logo logo logo 4.2 创建一个任务1.点击创建任务，如果在创建项目时候，没有“创建一个Maven 项目”的选项。你需要安装Maven项目插件：Maven Integration plugin 。 logo 2.配置源码管理，jenkins会自动拉取代码放到/var/lib/jenkins/workspace/任务名 路径下 logo 3.配置Maven构建，构建完后会自动打包 logo 4.编写shell脚本，maven构建完成之后就是把打好的包放在tomcat下了并启动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#!/bin/bash#引入了系统环境变量，这样系统环境变量里面没有export声明的也可以用source /etc/profiletomcat_home=/usr/local/tomcat-8.0.48SHUTDOWN=$tomcat_home/bin/shutdown.shSTARTTOMCAT=$tomcat_home/bin/startup.shecho \"停止tomcat服务 /usr/local/tomcat8.0.48/bin/shutdown.sh\"#/usr/local/tomcat8.0.48/bin/shutdown.shecho \"关闭$tomcat_home\"$SHUTDOWNpidlist=`ps -ef |grep tomcat |grep -v \"grep\"|awk '&#123;print $2&#125;'`kill -9 $pidlistecho \"开始删除文件夹 usr/local/tomcat8.0.48/webapps/blogsys-parent\"rm -rf $tomcat_home/webapps/blogsys-parentecho \"开始删除文件 /usr/local/tomcat8.0.48/webapps/blogsys-parent.war\"rm -rf $tomcat_home/webapps/blogsys-parent.warecho \"开始拷贝文件 blogsys-parent.war 拷贝文件目录：/var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target &gt;&gt; /usr/local/tomcat8.0.48/webapps\"cp -ar /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target/blogsys-parent.war $tomcat_home/webapps/blogsys-parent.warecho \"查找文件\"find $tomcat_home/webapps/ -name blogsys-parent.warecho \"启动$tomcat_home\"$STARTTOMCATecho \"延时5秒\"sleep 5echo \"关闭$tomcat_home\"$SHUTDOWNpidlist=`ps -ef |grep tomcat |grep -v \"grep\"|awk '&#123;print $2&#125;'`kill -9 $pidlistecho \"延时5秒重新启动\"sleep 5# 脚本中功能是复制替换某两个配置文件，然后关闭tomcat，重启Tomcat。但是，Tomcat只是启动了一下，就关闭了，并没有启动Tomcat的进程。在网上查了资料，需要在执行脚本之前加入：export BUILD_ID=XXXXXXexport BUILD_ID=dontKillMeecho \"启动$tomcat_home\"$STARTTOMCATecho \"延时10秒\"sleep 10echo \"打印日志开始-》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》》\"tail -2000 $&#123;tomcat_home&#125;/logs/catalina.out``` ##### 启动任务可以看到日志输出```bashStarted by user songshuiyangBuilding in workspace /var/lib/jenkins/workspace/blogsys-parent &gt; git rev-parse --is-inside-work-tree # timeout=10Fetching changes from the remote Git repository &gt; git config remote.origin.url https://gitee.com/songshuiyang/blogsys-parent.git # timeout=10Fetching upstream changes from https://gitee.com/songshuiyang/blogsys-parent.git &gt; git --version # timeout=10using GIT_ASKPASS to set credentials 码云账号 &gt; git fetch --tags --progress https://gitee.com/songshuiyang/blogsys-parent.git +refs/heads/*:refs/remotes/origin/* &gt; git rev-parse refs/remotes/origin/master^&#123;commit&#125; # timeout=10 &gt; git rev-parse refs/remotes/origin/origin/master^&#123;commit&#125; # timeout=10Checking out Revision 926c54ff215417d928b32201b50e2c2cb40b6ba8 (refs/remotes/origin/master) &gt; git config core.sparsecheckout # timeout=10 &gt; git checkout -f 926c54ff215417d928b32201b50e2c2cb40b6ba8Commit message: \"优化 修复pom问题\" &gt; git rev-list --no-walk 926c54ff215417d928b32201b50e2c2cb40b6ba8 # timeout=10Parsing POMsEstablished TCP socket on 40447[blogsys-parent] $ /usr/local/jdk1.8.0_181/bin/java -cp /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven35-agent-1.12-alpha-1.jar:/usr/local/maven-3.5.4/boot/plexus-classworlds-2.5.2.jar:/usr/local/maven-3.5.4/conf/logging jenkins.maven3.agent.Maven35Main /usr/local/maven-3.5.4 /var/cache/jenkins/war/WEB-INF/lib/remoting-3.23.jar /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven35-interceptor-1.12-alpha-1.jar /var/lib/jenkins/plugins/maven-plugin/WEB-INF/lib/maven3-interceptor-commons-1.12-alpha-1.jar 40447&lt;===[JENKINS REMOTING CAPACITY]===&gt;channel startedExecuting Maven: -B -f /var/lib/jenkins/workspace/blogsys-parent/pom.xml clean install -Dmaven.test.skip=true[INFO] Scanning for projects...[WARNING] [WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-admin:war:0.0.1-SNAPSHOT[WARNING] 'dependencies.dependency.systemPath' for json:json:jar should not point at files within the project directory, $&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib/json.jar will be unresolvable by dependent projects @ line 25, column 19[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: com.fasterxml.jackson.core:jackson-databind:jar -&gt; version $&#123;jackson-databind.version&#125; vs 2.7.4 @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 244, column 21[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 383, column 21[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 407, column 21[WARNING] [WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-core:jar:0.0.1-SNAPSHOT[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 383, column 21[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ com.ecut:blogsys-parent:0.0.1-SNAPSHOT, /var/lib/jenkins/workspace/blogsys-parent/pom.xml, line 407, column 21[WARNING] [WARNING] Some problems were encountered while building the effective model for com.ecut:blogsys-parent:pom:0.0.1-SNAPSHOT[WARNING] 'dependencies.dependency.(groupId:artifactId:type:classifier)' must be unique: com.fasterxml.jackson.core:jackson-databind:jar -&gt; version $&#123;jackson-databind.version&#125; vs 2.7.4 @ line 244, column 21[WARNING] 'build.plugins.plugin.version' for org.apache.maven.plugins:maven-surefire-plugin is missing. @ line 383, column 21[WARNING] 'build.plugins.plugin.version' for org.springframework.boot:spring-boot-maven-plugin is missing. @ line 407, column 21[WARNING] [WARNING] It is highly recommended to fix these problems because they threaten the stability of your build.[WARNING] [WARNING] For this reason, future Maven versions might no longer support building such malformed projects.[WARNING] [INFO] ------------------------------------------------------------------------[INFO] Reactor Build Order:[INFO] [INFO] blogsys-parent [pom][INFO] blogsys-admin [war][INFO] blogsys-core [jar][INFO] [INFO] ----------------------&lt; com.ecut:blogsys-parent &gt;-----------------------[INFO] Building blogsys-parent 0.0.1-SNAPSHOT [1/3][INFO] --------------------------------[ pom ]---------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ blogsys-parent ---[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ blogsys-parent ---[INFO] Installing /var/lib/jenkins/workspace/blogsys-parent/pom.xml to /root/.m2/repository/com/ecut/blogsys-parent/0.0.1-SNAPSHOT/blogsys-parent-0.0.1-SNAPSHOT.pom[WARNING] Attempt to (de-)serialize anonymous class hudson.maven.reporters.MavenArtifactArchiver$2; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/[WARNING] Attempt to (de-)serialize anonymous class hudson.maven.reporters.MavenFingerprinter$1; see: https://jenkins.io/redirect/serialization-of-anonymous-classes/[INFO] [INFO] -----------------------&lt; com.ecut:blogsys-admin &gt;-----------------------[INFO] Building blogsys-admin 0.0.1-SNAPSHOT [2/3][INFO] --------------------------------[ war ]---------------------------------[INFO] [INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ blogsys-admin ---[INFO] Deleting /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ blogsys-admin ---[INFO] Using 'UTF-8' encoding to copy filtered resources.[INFO] Copying 32 resources[INFO] [INFO] --- maven-compiler-plugin:2.3.2:compile (default-compile) @ blogsys-admin ---[INFO] Compiling 164 source files to /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/target/classes[WARNING] /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/src/main/java/com/ecut/core/shiro/SecurityUtils.java:[8,15] BASE64Encoder is internal proprietary API and may be removed in a future release[WARNING] /var/lib/jenkins/workspace/blogsys-parent/blogsys-admin/src/main/java/com/ecut/core/utils/elven/encryption/DesEncryptUtils.java:[8,15] BASE64Decoder is internal proprietary API and may be removed in a future release.....","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"http://www.songshuiyang.site/tags/jenkins/"}]},{"title":"HashSet","slug":"backend/Java/集合容器/HashSet","date":"2018-07-08T06:24:12.000Z","updated":"2018-07-08T06:59:36.200Z","comments":true,"path":"2018/07/08/backend/Java/集合容器/HashSet/","link":"","permalink":"http://www.songshuiyang.site/2018/07/08/backend/Java/集合容器/HashSet/","excerpt":"","text":"HashSet源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; static final long serialVersionUID = -5024744406713321676L; // 底层使用HashMap来保存HashSet中所有元素。 private transient HashMap&lt;E,Object&gt; map; // 定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。 private static final Object PRESENT = new Object(); /** * 默认的无参构造器，构造一个空的HashSet。 * * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 */ public HashSet() &#123; map = new HashMap&lt;E,Object&gt;(); &#125; /** * 构造一个包含指定collection中的元素的新set。 * * 实际底层使用默认的加载因子0.75和足以包含指定 * collection中所有元素的初始容量来创建一个HashMap。 * @param c 其中的元素将存放在此set中的collection。 */ public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; /** * 以指定的initialCapacity和loadFactor构造一个空的HashSet。 * * 实际底层以相应的参数构造一个空的HashMap。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 */ public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 以指定的initialCapacity构造一个空的HashSet。 * * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。 * @param initialCapacity 初始容量。 */ public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; /** * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。 * * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。 * @param initialCapacity 初始容量。 * @param loadFactor 加载因子。 * @param dummy 标记。 */ HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; /** * 返回对此set中元素进行迭代的迭代器。返回元素的顺序并不是特定的。 * * 底层实际调用底层HashMap的keySet来返回所有的key。 * 可见HashSet中的元素，只是存放在了底层HashMap的key上， * value使用一个static final的Object对象标识。 * @return 对此set中元素进行迭代的Iterator。 */ public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; /** * 返回此set中的元素的数量（set的容量）。 * * 底层实际调用HashMap的size()方法返回Entry的数量，就得到该Set中元素的个数。 * @return 此set中的元素的数量（set的容量）。 */ public int size() &#123; return map.size(); &#125; /** * 如果此set不包含任何元素，则返回true。 * * 底层实际调用HashMap的isEmpty()判断该HashSet是否为空。 * @return 如果此set不包含任何元素，则返回true。 */ public boolean isEmpty() &#123; return map.isEmpty(); &#125; /** * 如果此set包含指定元素，则返回true。 * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e)) * 的e元素时，返回true。 * * 底层实际调用HashMap的containsKey判断是否包含指定key。 * @param o 在此set中的存在已得到测试的元素。 * @return 如果此set包含指定元素，则返回true。 */ public boolean contains(Object o) &#123; return map.containsKey(o); &#125; /** * 如果此set中尚未包含指定元素，则添加指定元素。 * 更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) * 的元素e2，则向此set 添加指定的元素e。 * 如果此set已包含该元素，则该调用不更改set并返回false。 * * 底层实际将将该元素作为key放入HashMap。 * 由于HashMap的put()方法添加key-value对时，当新放入HashMap的Entry中key * 与集合中原有Entry的key相同（hashCode()返回值相等，通过equals比较也返回true）， * 新添加的Entry的value会将覆盖原来Entry的value，但key不会有任何改变， * 因此如果向HashSet中添加一个已经存在的元素时，新添加的集合元素将不会被放入HashMap中， * 原来的元素也不会有任何改变，这也就满足了Set中元素不重复的特性。 * @param e 将添加到此set中的元素。 * @return 如果此set尚未包含指定元素，则返回true。 */ public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; /** * 如果指定元素存在于此set中，则将其移除。 * 更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e， * 则将其移除。如果此set已包含该元素，则返回true * （或者：如果此set因调用而发生更改，则返回true）。（一旦调用返回，则此set不再包含该元素）。 * * 底层实际调用HashMap的remove方法删除指定Entry。 * @param o 如果存在于此set中则需要将其移除的对象。 * @return 如果set包含指定元素，则返回true。 */ public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; /** * 从此set中移除所有元素。此调用返回后，该set将为空。 * * 底层实际调用HashMap的clear方法清空Entry中所有元素。 */ public void clear() &#123; map.clear(); &#125; /** * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。 * HashSet保证元素不重复HashSet使用HashMap进行存放数据123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; putVal方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 重新计算一下大小 // 获取要插入元素在 哈希桶中的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果这个位置没有Node tab[i] = newNode(hash, key, value, null); // 直接创建一个新的Node else &#123; // 说明此时在对应的索引位置已经有对象了 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断原对象与插入的对象的key是否一样 else if (p instanceof TreeNode) // 如果 你定位到的元素是一个TreeNode(Node的一个子类，也是HashMap的一个内部类) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 那么就插入一TreeNode节点 定位到这个hash桶了 但是这里面是链表（没有进行过树化） else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; //说明原对象与插入的对象的key相同 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //将新插入的entry的value覆盖掉原来的entry的value afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 修改次数+1 和fastRemove()有关也和并发修改有关 if (++size &gt; threshold) // 如果大于了阙值 需要扩容的大小 resize(); // 重新设置hash桶的大小，也有可能进行树化，见后面代码 afterNodeInsertion(evict); return null;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"HashMap理解笔记","slug":"backend/Java/集合容器/HashMap","date":"2018-06-07T11:21:12.000Z","updated":"2018-07-21T03:08:14.390Z","comments":true,"path":"2018/06/07/backend/Java/集合容器/HashMap/","link":"","permalink":"http://www.songshuiyang.site/2018/06/07/backend/Java/集合容器/HashMap/","excerpt":"","text":"什么是HashMapHashMap分为俩个词理解，一个是Hash，另一个是Map Hash: 散列将一个任意长度通过某种hash函数算法转化成一个固定的值 Map：可以理解为地图点的位置 我们如果想要找到地图上的某个点，就需要通过经纬度来定位，Hash就是这个值，我们可以通过这个值，找到我们所要的位置 HashMap 简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。 HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap源码笔记HashMap 常量定义12345678910111213141516171819202122232425262728293031323334353637383940414243/** * The default initial capacity - MUST be a power of two. * 默认初始容量，为16个 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. * 最大容量： 1073741824 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * The load factor used when none specified in constructor. * 加载因子，当容量达到3/4的时候进行容量扩容, 不是满的时候再扩容 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. * .由链表转换成树的阈值TREEIFY_THRESHOLD 一个桶中bin（箱子）的存储方式由链表转换成树的阈值。即当桶中bin的数量超过TREEIFY_THRESHOLD时使用树来代替链表。默认值是8 */ static final int TREEIFY_THRESHOLD = 8; /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. * 当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 */ static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * 当桶中的bin被树化时最小的hash表容量。（如果没有达到这个阈值，即hash表容量小于MIN_TREEIFY_CAPACITY，当桶中bin的数量太多时会执行resize扩容操作）这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4倍。 */static final int MIN_TREEIFY_CAPACITY = 64; putVal方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 重新计算一下大小 // 获取要插入元素在 哈希桶中的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) // 如果这个位置没有Node tab[i] = newNode(hash, key, value, null); // 直接创建一个新的Node else &#123; // 说明此时在对应的索引位置已经有对象了 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断原对象与插入的对象的key是否一样 else if (p instanceof TreeNode) // 如果 你定位到的元素是一个TreeNode(Node的一个子类，也是HashMap的一个内部类) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 那么就插入一TreeNode节点 定位到这个hash桶了 但是这里面是链表（没有进行过树化） else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; //说明原对象与插入的对象的key相同 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; //将新插入的entry的value覆盖掉原来的entry的value afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 修改次数+1 和fastRemove()有关也和并发修改有关 if (++size &gt; threshold) // 如果大于了阙值 需要扩容的大小 resize(); // 重新设置hash桶的大小，也有可能进行树化，见后面代码 afterNodeInsertion(evict); return null;&#125; Java中的hashCode和equals关于hashCode hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的 如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里“ 再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。 以下对hashCode的解读摘自其他博客：123456789101.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有例如内存中有这样的位置0 1 2 3 4 5 6 7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。但如果用hashcode那就会使效率提高很多。我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。那么。重写了equals()，为什么还要重写hashCode()呢？想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 关于equalsequals和== ==用于比较引用和比较基本数据类型时具有不同的功能：比较基本数据类型，如果两个值相同，则结果为true而在比较引用时，如果引用指向内存中的同一对象，结果为true; equals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。 HashMap的实现原理HashMap概述HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 logo 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 logo 其中Java源码如下：12345678910111213/** * The table, resized as necessary. Length MUST Always be a power of two. */transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; final int hash; ……&#125; 可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。 HashMap实现存储和读取存储1234567891011121314151617181920212223242526public V put(K key, V value) &#123; // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; // 如果发现已有该键值，则存储新的值，并返回原始值 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null;&#125; 根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。 根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。 通过这种方式就可以高效的解决HashMap的冲突问题。 读取12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; 从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 归纳起来简单地说，HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 HashMap的resize当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.751000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 总结 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。 转载参考：http://www.cnblogs.com/yuanblog/p/4441017.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Nginx 笔记","slug":"backend/centos/Nginx 笔记","date":"2018-06-05T13:48:12.000Z","updated":"2018-06-06T13:06:57.964Z","comments":true,"path":"2018/06/05/backend/centos/Nginx 笔记/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/centos/Nginx 笔记/","excerpt":"","text":"一. 为什么使用NginxNginx 是一个高性能的 Web 和反向代理服务器, 它具有有很多非常优越的特性: 作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型. 作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。 作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。 Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。基础功能 二. 基础功能 处理静态文件，索引文件以及自动索引； 反向代理加速(无缓存)，简单的负载均衡和容错； FastCGI，简单的负载均衡和容错； 模块化的结构。过滤器包括gzipping, byte ranges, chunked responses, 以及 SSI-filter 。在SSI过滤器中，到同一个 proxy 或者 FastCGI 的多个子请求并发处理；SSL 和 TLS SNI 支持；","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.songshuiyang.site/tags/nginx/"}]},{"title":"基于 CentOS 搭建 Nginx 服务","slug":"backend/centos/基于 CentOS 搭建 Nginx服务","date":"2018-06-05T13:48:12.000Z","updated":"2018-06-06T13:06:57.969Z","comments":true,"path":"2018/06/05/backend/centos/基于 CentOS 搭建 Nginx服务/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/centos/基于 CentOS 搭建 Nginx服务/","excerpt":"1.安装使用Nginx1.1 yum安装1yum install nginx 1.2 提供目录权限12345678提供目录权限: 我需要访问的目录是 /var/ftp, 用户是root, 所以修改如下配置:[root@S205 conf.d]# cat /etc/nginx/nginx.conf |grep useruser root;否则会出现这样的错误:[root@S205 conf.d]# tail /var/log/nginx/error.log 2017/10/13 16:51:09 [error] 13383#0: *1 open() \"/home/data\" failed (13: Permission denied), client: 192.168.50.20, server: _, request: \"GET /data HTTP/1.1\", host: \"192.168.10.205:8080\"","text":"1.安装使用Nginx1.1 yum安装1yum install nginx 1.2 提供目录权限12345678提供目录权限: 我需要访问的目录是 /var/ftp, 用户是root, 所以修改如下配置:[root@S205 conf.d]# cat /etc/nginx/nginx.conf |grep useruser root;否则会出现这样的错误:[root@S205 conf.d]# tail /var/log/nginx/error.log 2017/10/13 16:51:09 [error] 13383#0: *1 open() \"/home/data\" failed (13: Permission denied), client: 192.168.50.20, server: _, request: \"GET /data HTTP/1.1\", host: \"192.168.10.205:8080\" 2.Nginx 命令2.1 启动重启123456[root@S205 conf.d]# systemctl enable nginx[root@S205 conf.d]# systemctl restart nginx[root@S205 conf.d]# vi /etc/nginx/nginx.conf 2.23.Nginx 启用对文件目录的http访问解决以ftp路径形式的图片，在谷歌浏览器上不能正常访问的问题，所以使用http的形式访问文件 3.1 配置如下：采用： http://ip/uploadfile/文件路径的形式访问 或者 直接 http://ip/文件路径的形式访问12345678910111213141516171819202122232425262728server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /var/ftp/pub; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; autoindex on; autoindex_localtime on; &#125; location /uploadfile &#123; alias /var/ftp/pub; autoindex on; autoindex_localtime on; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 3.2 autoindex 和 autoindex_localtime 生成目录索引1234autoindex on; #自动显示目录autoindex_exact_size off; #改为off后，显示出文件的大概大小，单位是kB或者MB或者GB；即人性化方式显示文件大小否则以byte显示autoindex_localtime on; #显示的文件时间为文件的服务器时间；即按服务器时间显示limit_rate_after 10m; #10m之后下载速度为10k 参考:http://blog.licess.com/nginx-autoindex/ 3.2 解决目录列表文件名乱码问题12345678910111213141516171819202122232425262728vi /etc/nginx/nginx.conf 加上 charset utf-8,gbk即可解决;user nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; autoindex on; autoindex_exact_size off; autoindex_localtime on; charset utf-8,gbk;&#125; 4.Nginx 配置反向代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#user nobody;worker_processes 1;#error_log logs/error.log;error_log logs/error.log notice;#error_log logs/error.log info;#error_log /usr/local/etcinx/logs/error.log warn;#pid logsinx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; #tcp_nopush on; #keepalive_timeout 0; sendfile on; keepalive_timeout 65; gzip on; gzip_min_length 1k; gzip_comp_level 3; gzip_buffers 4 16k; gzip_vary on; server &#123; listen 80; server_name localhost 192.168.0.252 songshuiyang.com; location / &#123; proxy_pass http://127.0.0.1:4080; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 100m; &#125; location /uploadfile &#123; alias /var/ftp/pub ; &#125; location /webapp &#123; proxy_pass http://127.0.0.1:8068; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location /admin-webapp &#123; alias html/test-admin-webapp; &#125; location = /favicon.ico &#123; alias /var/ftp/pub/favicon.ico; &#125; &#125;&#125;# include servers/*; 5.Nginx 简单的负载均衡的示例12345678910111213141516http &#123; upstream myproject &#123; server 127.0.0.1:8000 weight=3; server 127.0.0.1:8001; server 127.0.0.1:8002; server 127.0.0.1:8003;&#125;server &#123; listen 80; server_name www.domain.com; location / &#123; proxy_pass http://myproject; &#125; &#125;&#125; 本文参考： http://www.bubuko.com/infodetail-2349571.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://www.songshuiyang.site/tags/nginx/"}]},{"title":"基于 CentOS 搭建 FTP 文件服务","slug":"backend/centos/基于 CentOS 搭建 FTP 文件服务","date":"2018-06-05T12:48:12.000Z","updated":"2018-06-06T13:06:57.967Z","comments":true,"path":"2018/06/05/backend/centos/基于 CentOS 搭建 FTP 文件服务/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/centos/基于 CentOS 搭建 FTP 文件服务/","excerpt":"1.安装并启动 FTP 服务1.1 使用 yum 安装 vsftpd12# yum默认都是安装最新版的软件yum install -y vsftpd 1.2 启动 vsftpd1234567安装完成后，启动 FTP 服务：service vsftpd start启动后，可以看到系统已经监听了 21 端口：netstat -nltp | grep 21此时，访问 ftp://主机ip 可浏览机器上的 /var/ftp目录了。","text":"1.安装并启动 FTP 服务1.1 使用 yum 安装 vsftpd12# yum默认都是安装最新版的软件yum install -y vsftpd 1.2 启动 vsftpd1234567安装完成后，启动 FTP 服务：service vsftpd start启动后，可以看到系统已经监听了 21 端口：netstat -nltp | grep 21此时，访问 ftp://主机ip 可浏览机器上的 /var/ftp目录了。 2.配置 FTP 权限2.1 了解 VSFTP 配置12345vsftpd 的配置目录为 /etc/vsftpd，包含下列的配置文件：vsftpd.conf 为主要配置文件ftpusers 配置禁止访问 FTP 服务器的用户列表user_list 配置用户访问控制 2.1 创建 FTP 用户1234创建一个用户 ftpuseruseradd ftpuser为用户 ftpuser 设置密码echo \"password\" | passwd ftpuser --stdin 2.2 限制该用户仅能通过 FTP 访问12限制用户 ftpuser只能通过 FTP 访问服务器，而不能直接登录服务器：usermod -s /sbin/nologin ftpuser 命令笔记:123456789101112用于修改用户的基本信息。usermod命令不允许你改变正在线上的使用者帐号名称。当usermod命令用来改变user id，必须确认这名user没在电脑上执行任何程序。你需手动更改使用者的crontab档。也需手动更改使用者的at工作档。采用NIS server须在server上更动相关的NIS设定。-c&lt;备注&gt;：修改用户帐号的备注文字；-d&lt;登入目录&gt;：修改用户登入时的目录；-e&lt;有效期限&gt;：修改帐号的有效期限；-f&lt;缓冲天数&gt;：修改在密码过期后多少天即关闭该帐号；-g&lt;群组&gt;：修改用户所属的群组；-G&lt;群组&gt;；修改用户所属的附加群组；-l&lt;帐号名称&gt;：修改用户帐号名称；-L：锁定用户密码，使密码无效；-s&lt;shell&gt;：修改用户登入后所使用的shell；-u&lt;uid&gt;：修改用户ID；-U:解除密码锁定。 2.3 创建登录欢迎文件1echo \"Welcome to use FTP service.\" &gt; /var/ftp/welcome.txt 2.4 配置权限12345设置访问权限chmod a-w /var/ftp &amp;&amp; chmod 777 -R /var/ftp/pub设置为用户的主目录：usermod -d /var/ftp ftpuser 命令笔记:123456789101112131415161718192021222324252627282930313233343536权限范围的表示法如下：u User，即文件或目录的拥有者；g Group，即文件或目录的所属群组；o Other，除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围；a All，即全部的用户，包含拥有者，所属群组以及其他用户；r 读取权限，数字代号为“4”;w 写入权限，数字代号为“2”；x 执行或切换权限，数字代号为“1”；- 不具任何权限，数字代号为“0”；s 特殊功能说明：变更文件或目录的权限。-c或——changes：效果类似“-v”参数，但仅回报更改的部分；-f或--quiet或——silent：不显示错误信息；-R或——recursive：递归处理，将指令目录下的所有文件及子目录一并处理；-v或——verbose：显示指令执行过程；--reference=&lt;参考文件或目录&gt;：把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同；&lt;权限范围&gt;+&lt;权限设置&gt;：开启权限范围的文件或目录的该选项权限设置；&lt;权限范围&gt;-&lt;权限设置&gt;：关闭权限范围的文件或目录的该选项权限设置；&lt;权限范围&gt;=&lt;权限设置&gt;：指定权限范围的文件或目录的该选项权限设置；Linux用 户分为：拥有者、组群(Group)、其他（other），Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信 息， 都是记录在/etc/passwd文件中。每个人的密码则是记录在/etc/shadow文件下。 此外，所有的组群名称记录在/etc/group內！例：rwx rw- r--r=读取属性 //值＝4w=写入属性 //值＝2x=执行属性 //值＝1chmod u+x,g+w f01 //为文件f01设置自己可以执行，组员可以写入的权限chmod u=rwx,g=rw,o=r f01chmod 764 f01chmod a+x f01 //对文件f01的u,g,o都设置可执行属性文件的属主和属组属性设置chown user:market f01 //把文件f01给uesr，添加到market组ll -d f1 查看目录f1的属性 2.5 备注一： 以上配置是匿名用户可以通过ftp://主机ip 即可访问文件，但不能上传文件，所以需要添加一个ftpuser用户ftp上传操作，这样做有俩个好处 访问文件可以通过一个ftp绝对路径访问(也可以通过nginx代理通过http的形式访问)，不需要输入用户名及密码 上传修改文件只能通过该(ftpuser)用户才能进行操作，保证了其安全性 二： 阻止匿名访问和切换根目录1234567891011匿名访问和切换根目录都会给服务器带来安全风险，我们把这两个功能关闭。编辑 /etc/vsftpd/vsftpd.conf，找到下面两处配置并修改：vi /etc/vsftpd/vsftpd.conf # 禁用匿名用户 12 YES 改为NOanonymous_enable=NO# 禁止切换根目录 101 行 删除#chroot_local_user=YES编辑完成后保存配置，重新启动 FTP 服务service vsftpd restart 本文参考： https://www.baidu.com/link?url=3FcSvP44zFbo33EoJBucNlE1ZKKkncTuckfxuvNFJhCPvQuZmlebtZRzRAW3-W0SH8Ep8dShtJ8NSjWlozkrPa&amp;wd=&amp;eqid=edc2684700001d70000000065b17479b","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"http://www.songshuiyang.site/tags/ftp/"}]},{"title":"Shiro记事","slug":"backend/Shiro/Shiro记事","date":"2018-06-05T12:48:12.000Z","updated":"2018-06-06T13:06:57.950Z","comments":true,"path":"2018/06/05/backend/Shiro/Shiro记事/","link":"","permalink":"http://www.songshuiyang.site/2018/06/05/backend/Shiro/Shiro记事/","excerpt":"","text":"Shiro内置了默认的拦截器配置Shiro使得多个角色可以访问同一URL在Shiro配置中，如果对某一URL作如下配置： /a.jsp = roles[&quot;role1, role2&quot;] 其效果等效于hasAllRoles，即要求所有角色都满足才可访问。 但在实际中，可能只需满足任一角色即可访问。在这种情况下，需要自己重载RolesAuthorizationFilter的isAccessAllowed，实现或的关系。具体实现如下：123456789101112131415161718192021222324252627import org.apache.shiro.subject.Subject;import org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class AnyOfRolesAuthorizationFilter extends RolesAuthorizationFilter &#123; @Override public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException &#123; final Subject subject = getSubject(request, response); final String[] rolesArray = (String[]) mappedValue; if (rolesArray == null || rolesArray.length == 0) &#123; //no roles specified, so nothing to check - allow access. return true; &#125; for (String roleName : rolesArray) &#123; if (subject.hasRole(roleName)) &#123; return true; &#125; &#125; return false; &#125;&#125; 相应地，在INI文件中作如下配置：123456[main]...anyofroles = com.your.package.AnyOfRolesAuthorizationFilter[urls].../path/to/some/url = anyofroles[\"role1,role2\"]","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"shiro","slug":"shiro","permalink":"http://www.songshuiyang.site/tags/shiro/"}]},{"title":"使用微软提供的Office Online实现Office文档的在线查看,编辑等功能","slug":"backend/相关技术/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能","date":"2018-05-08T12:54:12.000Z","updated":"2018-05-08T15:07:08.195Z","comments":true,"path":"2018/05/08/backend/相关技术/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能/","link":"","permalink":"http://www.songshuiyang.site/2018/05/08/backend/相关技术/使用微软提供的Office Online实现Office文档的在线查看,编辑等功能/","excerpt":"","text":"使用微软提供的Office Online实现Office文档的在线查看,编辑使用微软提供的Office Online平台只需要一个网址即可在线查看Xls,doc,PPT等文档 在线预览http://view.officeapps.live.com/op/view.aspx?src=要查看的文档地址 在线编辑在线编辑需要登录https://www.office.com并从onedrive中打开或新建文档也可以来自在线模板(下面的Excel来自Excel Online模板，编辑后的文件会保存到你的onedrive中)在线编辑Xls文档(部分功能不支持,但已经够用)","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"freemaker模板框架","slug":"backend/模板框架/freemaker模板框架","date":"2018-04-14T15:35:12.000Z","updated":"2018-04-14T15:46:52.508Z","comments":true,"path":"2018/04/14/backend/模板框架/freemaker模板框架/","link":"","permalink":"http://www.songshuiyang.site/2018/04/14/backend/模板框架/freemaker模板框架/","excerpt":"","text":"freemaker 语法笔记 if 条件 1234567&lt;#if entity.columnName == 'id' &gt; &lt;#elseif entity.columnName == 'id' &gt; &lt;#else&gt; &lt;/#if&gt; list 遍历元素 12345678910111213141516171819202122232425262728293031323334353637383940414243441. 遍历要想在Freemarker中遍历list,必须通过使用list指令,即&lt;#list sequence as item&gt;…&lt;/#list&gt;sequence是集合(collection)的表达式，item是循环变量的名字，不能是表达式。&lt;#list userList as user&gt; …&lt;/#list&gt;List指令还隐含了两个循环变量： item_index:当前迭代项在所有迭代项中的位置，是数字值。 item_has_next:用于判断当前迭代项是否是所有迭代项中的最后一项。 注意：在使用上述两个循环变量时，一定要将item换成你自己定义的循环变量名,item其实就是前缀罢了。 &lt;#--Freemarker遍历list并应用list隐含变量item_index--&gt; item_index使用： &lt;#list userList as user&gt; 第$&#123;user_index+1&#125;个用户 用户名：$&#123;user.userName&#125; 密 码：$&#123;user.userPassword&#125; 年 龄: $&#123;user.age&#125; &lt;/#list&gt; &lt;#--Freemarker遍历list并应用list隐含变量item_has_next--&gt; item_has_next,size使用： &lt;#list userList as user&gt; 用户名：$&#123;user.userName&#125; 密 码：$&#123;user.userPassword&#125; 年 龄: $&#123;user.age&#125; &lt;#if !user_has_next&gt; 共有$&#123;userList?size&#125;最后一个用户是:$&#123;user.userName&#125; &lt;/#if&gt; &lt;/#list&gt;2. 排序sort升序排序函数 sort对序列(sequence)进行排序，要求序列中的变量必须是：字符串（按首字母排序）,数字，日期值。 &lt;#list list?sort as l&gt;…&lt;/#list&gt;sort_by函数 sort_by有一个参数,该参数用于指定想要排序的子变量，排序是按照变量对应的值进行排序,如： &lt;#list userList?sort_by(“age”) as user&gt;…&lt;/#list&gt; age是User对象的属性，排序是按age的值进行的。reverse降序排序函数 &lt;#list list? reverse as l&gt;…&lt;/#list&gt;。reverse使用同sort相同。reverse还可以同sort_by一起使用 如：想让用户按年龄降序排序，那么可以这个样写&lt;#list userList?sort_by(“age”)?reverse as user&gt;…&lt;/#list&gt;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java获取数据表元数据","slug":"backend/Java/Java获取数据表元数据","date":"2018-04-14T09:00:12.000Z","updated":"2018-04-14T09:25:27.186Z","comments":true,"path":"2018/04/14/backend/Java/Java获取数据表元数据/","link":"","permalink":"http://www.songshuiyang.site/2018/04/14/backend/Java/Java获取数据表元数据/","excerpt":"","text":"","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Spring 集成Redis","slug":"backend/缓存技术/Redis","date":"2018-04-08T14:02:12.000Z","updated":"2018-04-09T14:07:01.475Z","comments":true,"path":"2018/04/08/backend/缓存技术/Redis/","link":"","permalink":"http://www.songshuiyang.site/2018/04/08/backend/缓存技术/Redis/","excerpt":"一：Redis1. 什么是RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 官网: https://redis.io/ 中文教程网: http://www.redis.net.cn/tutorial/3501.html 2. 基本介绍Redis 简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。","text":"一：Redis1. 什么是RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 官网: https://redis.io/ 中文教程网: http://www.redis.net.cn/tutorial/3501.html 2. 基本介绍Redis 简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。 3. 安装3.1 windows环境下载地址: https://github.com/MicrosoftArchive/redis/releases 3.1.1 修改配置文件12345redis.windows.conf 文件 配置密码 # requirepass foobaredrequirepass shuiyang 3.1.2 常用命令1234567redis服务安装成windows服务: redis-server --service-install redis.windows.conf开启服务：redis-server --service-start停止服务：redis-server --service-stop卸载服务：redis-server --service-uninstall 3.1.3 Redis可视化管理工具 RedisStudio，百度云连接：http://pan.baidu.com/s/1gfIbLar 密码：mpne Redis Desktop Manager https://redisdesktop.com/download 3.2 Linux环境下载地址：http://www.redis.net.cn/download/，下载最新文档版本。 3.2.1 安装1234$ wget http://download.redis.io/releases/redis-2.8.17.tar.gz$ tar xzf redis-2.8.17.tar.gz$ cd redis-2.8.17$ make make完后 redis-2.8.17目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli 3.2.1 启动服务下面启动redis服务. 1$ ./redis-server 注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。 1./redis-server redis.conf redis.conf是一个默认的配置文件。我们可以根据需要使用自己的配置文件。 3.2.1 测试客户端程序启动redis服务进程后，就可以使用测试客户端程序redis-cli和redis服务交互了。 比如： 12345$ ./redis-cliredis&gt; set foo barOKredis&gt; get foo\"bar\" 4. 与Spring 集成4.1 导入maven1234567891011&lt;!--redis--&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 4.2 新建 redis-config.properties1234567891011121314# Redis settingsredis.host=127.0.0.1redis.port=6379redis.pass=shuiyangredis.dbIndex=0redis.expiration=3000#最大空闲数redis.maxIdle=300#连接池的最大数据库连接数。设为0表示无限制,如果是jedis 2.4以后用redis.maxTotalredis.maxActive=600#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。redis.maxWait=1000#是否在从池中取出连接前进行检验,如果检验失败,则从池中去除连接并尝试取出另一个redis.testOnBorrow=true 4.3 新建 applicationContext-redis.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:cache=\"http://www.springframework.org/schema/cache\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd\"&gt; &lt;!-- 启用缓存注解开关 --&gt; &lt;cache:annotation-driven cache-manager=\"cacheManager\"/&gt; &lt;!-- 配置JedisPoolConfig实例 --&gt; &lt;bean id=\"poolConfig\" class=\"redis.clients.jedis.JedisPoolConfig\"&gt; &lt;property name=\"maxIdle\" value=\"$&#123;redis.maxIdle&#125;\" /&gt; &lt;property name=\"maxTotal\" value=\"$&#123;redis.maxActive&#125;\" /&gt; &lt;property name=\"maxWaitMillis\" value=\"$&#123;redis.maxWait&#125;\" /&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;redis.testOnBorrow&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 配置JedisConnectionFactory --&gt; &lt;bean id=\"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;property name=\"hostName\" value=\"$&#123;redis.host&#125;\" /&gt; &lt;property name=\"port\" value=\"$&#123;redis.port&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;redis.pass&#125;\" /&gt; &lt;property name=\"database\" value=\"$&#123;redis.dbIndex&#125;\" /&gt; &lt;property name=\"poolConfig\" ref=\"poolConfig\" /&gt; &lt;/bean&gt; &lt;!-- 配置RedisTemplate --&gt; &lt;bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\" /&gt; &lt;/bean&gt; &lt;!-- 配置RedisCacheManager --&gt; &lt;bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"&gt; &lt;constructor-arg name=\"redisOperations\" ref=\"redisTemplate\" /&gt; &lt;property name=\"defaultExpiration\" value=\"$&#123;redis.expiration&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 配置RedisCacheManager --&gt; &lt;bean id=\"cacheManager\" class=\"org.springframework.cache.support.SimpleCacheManager\"&gt; &lt;property name=\"caches\"&gt; &lt;set&gt; &lt;!-- 这里可以配置多个redis --&gt; &lt;bean class=\"com.ecut.core.config.RedisCache\"&gt; &lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt; &lt;property name=\"name\" value=\"articlesDetail\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.ecut.core.config.RedisCache\"&gt; &lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt; &lt;property name=\"name\" value=\"getHotArticlesInCache\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.ecut.core.config.RedisCache\"&gt; &lt;property name=\"redisTemplate\" ref=\"redisTemplate\" /&gt; &lt;property name=\"name\" value=\"articlesList\"/&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 4.4 引入 applicationContext-redis.xml redis-config.properties1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\"&gt; &lt;!--使标注Spring注解的类生效--&gt; &lt;context:component-scan base-package=\"com.ecut\"/&gt; &lt;!-- 将多个配置文件读取到容器中，交给Spring管理 --&gt; &lt;bean id=\"propertyConfigurer\" class=\"com.ecut.core.spring.PropertyPlaceholderConfigurerFilter\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;!-- 这里支持多种寻址方式：classpath和file --&gt; &lt;value&gt;classpath:project.properties&lt;/value&gt; &lt;!-- 推荐使用file的方式引入，这样可以将配置和代码分离 --&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:redis-config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;import resource=\"applicationContext-dao.xml\"/&gt; &lt;import resource=\"applicationContext-shiro.xml\"/&gt; &lt;!--encache redis选择一种缓存--&gt; &lt;!--&lt;import resource=\"applicationContext-encache.xml\"/&gt;--&gt; &lt;import resource=\"applicationContext-redis.xml\"/&gt;&lt;/beans&gt; 4.5 新建 RedisCache.java Cache接口实现类 Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136package com.ecut.core.config;import java.io.Serializable;import org.apache.commons.lang3.SerializationUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cache.Cache;import org.springframework.cache.support.SimpleValueWrapper;import org.springframework.dao.DataAccessException;import org.springframework.data.redis.connection.RedisConnection;import org.springframework.data.redis.core.RedisCallback;import org.springframework.data.redis.core.RedisTemplate;import java.io.Serializable;/** * Cache接口实现类 * * Spring对于缓存只是提供了抽象的接口，并且通过接口来调用功能，没有具体的实现类，所以需要我们自己实现具体的操作。 在上面配置中可知，每个实现类都会注入一个redisTemplate实例，我们就可以通过redisTemplate来操作redis * @author songshuiyang * @date 2018/4/9 20:38 */public class RedisCache implements Cache &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); private RedisTemplate&lt;String, Object&gt; redisTemplate; private String name; @Override public void clear() &#123; logger.info(\"----------------------------RedisCache 緩存清理-------------------------\"); redisTemplate.execute(new RedisCallback&lt;String&gt;() &#123; @Override public String doInRedis(RedisConnection connection) throws DataAccessException &#123; connection.flushDb(); return \"ok\"; &#125; &#125;); &#125; @Override public void evict(Object key) &#123; logger.info(\"----------------------------RedisCache 緩存刪除-------------------------\"); final String keyf=key.toString(); redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(RedisConnection connection) throws DataAccessException &#123; return connection.del(keyf.getBytes()); &#125; &#125;); &#125; @Override public ValueWrapper get(Object key) &#123; logger.info(\"----------------------------RedisCache 缓存获取-------------------------\"); final String keyf = key.toString(); Object object = null; object = redisTemplate.execute(new RedisCallback&lt;Object&gt;() &#123; @Override public Object doInRedis(RedisConnection connection) throws DataAccessException &#123; byte[] key = keyf.getBytes(); byte[] value = connection.get(key); if (value == null) &#123; logger.info(\"----------------------------RedisCache 缓存不存在-------------------------\"); return null; &#125; return SerializationUtils.deserialize(value); &#125; &#125;); ValueWrapper obj=(object != null ? new SimpleValueWrapper(object) : null); logger.info(\"----------------------------RedisCache 获取到内容-------------------------\"); return obj; &#125; @Override public void put(Object key, Object value) &#123; System.out.println(\"-------加入缓存------\"); System.out.println(\"key----:\"+key); System.out.println(\"key----:\"+value); final String keyString = key.toString(); final Object valuef = value; final long liveTime = 86400; redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(RedisConnection connection) throws DataAccessException &#123; byte[] keyb = keyString.getBytes(); byte[] valueb = SerializationUtils.serialize((Serializable) valuef); connection.set(keyb, valueb); if (liveTime &gt; 0) &#123; connection.expire(keyb, liveTime); &#125; return 1L; &#125; &#125;); &#125; @Override public &lt;T&gt; T get(Object arg0, Class&lt;T&gt; arg1) &#123; // TODO Auto-generated method stub return null; &#125; @Override public String getName() &#123; return this.name; &#125; @Override public Object getNativeCache() &#123; return this.redisTemplate; &#125; @Override public ValueWrapper putIfAbsent(Object arg0, Object arg1) &#123; // TODO Auto-generated method stub return null; &#125; public RedisTemplate&lt;String, Object&gt; getRedisTemplate() &#123; return redisTemplate; &#125; public void setRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 4.6 完成以上的配置之后就可以使用 Spring Cache注解来使用缓存了首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 @Cacheable 12345678910111213141516171819202122232425262728表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定key的生成规则。@Cacheable 支持如下几个参数： value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中 key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId， 一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， 本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等 condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1' @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\") public User findById(String userId) &#123; return (User) new User(\"1\", \"mengdee\"); &#125; // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\" @Cacheable(value=\"UserCache\", condition=\"#userId.length() &lt; 12\") public boolean isReserved(String userId) &#123; System.out.println(\"UserCache:\"+userId); return false; &#125; @CachePut 1与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。 @CacheEvict 1234567891011121314151617181920与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。@CacheEvict 支持如下几个参数： value：缓存位置名称，不能为空，同上 key：缓存的key，默认为空，同上 condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL allEntries：true表示清除value中的全部缓存，默认为false //清除掉UserCache中某个指定key的缓存 @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\") public void removeUser(User user) &#123; System.out.println(\"UserCache\"+user.getUserId()); &#125; //清除掉UserCache中全部的缓存 @CacheEvict(value=\"UserCache\", allEntries=true) public final void setReservedUsers(String[] reservedUsers) &#123; System.out.println(\"UserCache deleteall\"); &#125; @Caching 1234如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。@Caching(evict = &#123; @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") &#125;)public Book importBooks(String deposit, Date date) @CacheConfig 12345678与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。@CacheConfig(\"books\")public class BookRepositoryImpl implements BookRepository &#123; @Cacheable public Book findBook(ISBN isbn) &#123;...&#125;&#125; 遇到的问题： spring+redis报错org.springframework.core.serializer.support.DeserializingConverter.(Ljava/lang/ClassLoader;)V 123456789101112这个问题的原因大概就是spring-data-redis.jar包版本不对 ，下面版本可以正常启动 &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; Spring Cache 注解问题，使用redis缓存会出现类型转化的问题 ,还未解决 参考：https://www.cnblogs.com/panter/p/6801210.htmlhttp://www.redis.net.cn/tutorial/3503.htmlhttps://www.cnblogs.com/hello-daocaoren/p/7891907.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"微信公众号实现输入兑换码自动发红包功能","slug":"backend/支付/微信公众号开通发红包功能","date":"2018-04-03T14:15:12.000Z","updated":"2018-04-03T15:59:05.984Z","comments":true,"path":"2018/04/03/backend/支付/微信公众号开通发红包功能/","link":"","permalink":"http://www.songshuiyang.site/2018/04/03/backend/支付/微信公众号开通发红包功能/","excerpt":"前言 公司积分抽奖活动有红包奖项(虽然基本上都是这个奖)，但是用户兑奖的过程十分麻烦: 需要先联系公司客服，然后加客服微信，加完之后客服发一个微信红包作为兑换。所以决定简化这个兑奖过程，能不能将这个兑奖的过程改为由用户自己兑换，不用联系公司客服也能兑奖。 初步想法 公司有微信公众号，可以通过微信公众号进行发红包操作，一方面可以实现发送红包的功能，另一方面也可以推广公司的微信公众号。初步想法是用户在微信公众号里输入一个兑换码，然后微信自动发送一个红包给用户，用户只要点一下红包，红包就进用户自己口袋了 业务流程如果用户抽奖中了红包奖励，系统弹出一个提示框，里面有公司的微信公众号二维码图片（微信公众平台可以获取），及兑奖的兑换码，提示用户关注微信公众号，在公众号里面输入兑换码就可以获取红包","text":"前言 公司积分抽奖活动有红包奖项(虽然基本上都是这个奖)，但是用户兑奖的过程十分麻烦: 需要先联系公司客服，然后加客服微信，加完之后客服发一个微信红包作为兑换。所以决定简化这个兑奖过程，能不能将这个兑奖的过程改为由用户自己兑换，不用联系公司客服也能兑奖。 初步想法 公司有微信公众号，可以通过微信公众号进行发红包操作，一方面可以实现发送红包的功能，另一方面也可以推广公司的微信公众号。初步想法是用户在微信公众号里输入一个兑换码，然后微信自动发送一个红包给用户，用户只要点一下红包，红包就进用户自己口袋了 业务流程如果用户抽奖中了红包奖励，系统弹出一个提示框，里面有公司的微信公众号二维码图片（微信公众平台可以获取），及兑奖的兑换码，提示用户关注微信公众号，在公众号里面输入兑换码就可以获取红包 准备1、先介绍几个平台 I.微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。 平台入口：http://mp.weixin.qq.com。 II.微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。 平台入口：http://pay.weixin.qq.com III. 红包接口地址： https://pay.weixin.qq.com/wiki/doc/api/tools/cash_coupon.php?chapter=13_4&amp;index=3 2、 在微信公众平台获取公众号二维码图片（提供了多种尺寸大小），该二维码是提供给用户扫描， 及公众账号appid 3、 在微信商户平台上下载证书（账户中心 - 账户设置 - API安全 - API证书（下载zip压缩包格式即可，无须解压），获取 商户号（账户中心 - 账户设置 - 商户信息 - 基本账户信息 - 微信支付商户号），API密钥（账户中心 - 账户设置 - API安全 - API密钥 - 设置密钥（密钥为32位，需要自行重新设置，记录并保存好，实在没记住也可以更改） 这些参数 4、 开通红包功能，以及充值红包金额，红包金额与充值交易金额是区分开来的，所以需要单独充值，发放现金红包将扣除商户的可用余额，请注意，可用余额并不是微信支付交易额，需要预先充值，确保可用余额充足。查看可用余额、充值、提现请登录微信支付商户平台，进入“资金管理”菜单，进行操作 5、 介绍1234567891011121314151617181920现金红包简介微信红包，2014年春节一经推出即受到广大用户好评，引发全民抢红包热潮。现将微信红包打造成“现金红包”，成为一款定向资金发放的营销工具，供商户使用。申请红包条件1、T+0 结算商户需满足两个条件：1、入驻满90天，2、截止今日往回推30天内连续正常交易。2、其余结算周期的商户无限制，可立即前往【商户平台】-&gt;【产品中心】申请开通。发放方式介绍商户发放现金红包有3种发放方式：1）接口发放商户根据文档”【商户平台】现金红包API文档V2“进行开发，一次调用可以给一个指定用户发送一个指定金额的红包，满足多元化的运营需求；2）通过上传openid文件发放收集要发送红包对象的openid，将openid编辑成txt文件，登录微信支付商户平台，使用上传文件功能发放。一份文件对应一个红包模板，便于管理；为了防止商户手误重复操作发送红包，创建的同一个文件只能上传一次。若需要重复发放则需要修改文件名称或重新创建。3）配置营销规则“满额送”发放配置的规则不可使用红包模版进行发放，商户须在【产品中心】-【现金红包】-【前往功能】中创建红包后配置自助规则：用户使用微信支付发生交易满足一定条件，立送现金红包。税务和发票问题商户给用户发红包，微信支付按照商户指定红包金额扣除完全对等的充值资金，资金最终进入用户零钱。微信支付并未从中收取资金作为营收，所以不予开具发票。发放现金红包请商户遵照国家法律依法纳税，在商户充值之前，我们默认商户已经合法上税，商户使用本功能的行为若涉及纳税或代扣代缴税款的义务，由商户自行承担该义务，我们不会替商户缴纳税款 。 程序实现1、用户抽奖中了红包奖励, 生成一笔抽奖记录，同时生成一笔红包记录，所以需要新建一个红包记录表(表结构如下图)，一开始生成的记录中红包状态是 0-未发放的状态，同时生成兑换码。 兑换码规则： 10位大写字母：3位固定字母开头 + 7位随机字母（大写字母是为了防止【数字0 与字母o O】【 1与字母l】混淆导致用户兑换不了奖， 3位固定字母是为了防止恶意用户无限次输入兑换码导致老是触发红包处理程序，如果不是以这个三个字母开头的文字，统一回复欢迎关注本微信公众号） 1234567891011121314151617181920DROP TABLE IF EXISTS `ge_lottery_redpack_record`;CREATE TABLE `ge_lottery_redpack_record` ( `id` varchar(32) NOT NULL, `created_by` varchar(32) NOT NULL, `created_date` datetime NOT NULL, `last_modified_by` varchar(32) NOT NULL, `last_modified_date` datetime NOT NULL, `remarks` varchar(255) DEFAULT NULL, `version` int(11) DEFAULT NULL, `locked` bit(1) DEFAULT b'0', `enable` bit(1) DEFAULT b'0', `fd_lottery_record_id` varchar(32) DEFAULT NULL COMMENT '中奖纪录id 作为外键', `fd_status` int(11) DEFAULT NULL COMMENT '红包状态 0:未发放 1：已发放待领取 2：发放失败 3：已领取 4：未领取已退款', `fd_redpack_send_date` datetime DEFAULT NULL COMMENT '红包发送时间(非微信)', `fd_redpack_order_id` varchar(32) DEFAULT NULL COMMENT '微信红包订单单号', `fd_redpack_openid` varchar(32) DEFAULT NULL COMMENT '微信红包订单用户在wxappid下的openid', `fd_redeem_code` varchar(32) DEFAULT NULL COMMENT '兑换码', `fd_redpack_price` decimal(19,4) DEFAULT NULL COMMENT '红包金额', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖红包纪录表'; 2、用户得到兑换码之后，就是在微信公众号里输入兑换码，当用户输入兑换码之后，用户信息会发到我们自己服务器后台中, 这里用户触发的是文本事件，我们需要的是三个参数 (1) 用户微信OpenID（用户在本微信公众号的唯一标识） (2) 用户发的兑换码 (3) HttpServletRequest（用于获取用户ip，发红包接口入参需要） 1234567891011// 文本事件if (WechatBindUtil.MESSAGE_TEXT.equals(msgType)) &#123; String content = map.get(\"Content\").trim(); // 如果输入的文本是是以RED开头的, 执行发红包操作 if (content.startsWith(\"RED\")) &#123; String resultContent = lotteryRedpackRecordService.sendRedpackByRedeemCode(fromUserName,content,req); message = WechatBindUtil.initText(toUserName, fromUserName, resultContent); &#125; else &#123; message = WechatBindUtil.initText(toUserName, fromUserName, \"欢迎关注本微信公众号\"); &#125;&#125; 3、如果输入的文本是是以RED开头的, 执行发红包操作, 首先是查询红包记录表有没有该兑换码且红包状态为未发放，如果有的话调用微信发红包接口，同时更改红包状态，记录红包发送时间，微信红包订单单号，微信红包订单用户在wxappid下的openid，没有的话给出提示，实现如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 根据兑换码发送微信红包 * @param openid * @param redeemCode * @return */public String sendRedpackByRedeemCode (String openid, String redeemCode, HttpServletRequest request) &#123; Page&lt;LotteryRedpackRecord&gt; page = new Page&lt;&gt;(0); page.setParams(\"fdRedeemCode\",redeemCode); List&lt;LotteryRedpackRecord&gt; redpackRecords = findAutoByPage(page); if (redpackRecords.size() != 0) &#123; LotteryRedpackRecord oldRecord = redpackRecords.get(0); // 调用微信红包查询接口, 先更新红包纪录状态 updateRedpackState(oldRecord.getId()); // 更新完成之后获取新的红包纪录 LotteryRedpackRecord record = findById(oldRecord.getId()); Integer fdStatus = record.getFdStatus(); if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.未发放.getIndex())) &#123; RedpackDTO redpackDTO = new RedpackDTO(); // 以红包纪录id作为 微信红包接口请求的商品订单号 截取28位 String mchBillNo = record.getId(); mchBillNo= mchBillNo.substring(0,28); redpackDTO.setMchBillNo(mchBillNo); // 指定哪一个微信用户 redpackDTO.setReOpenid(openid); // 红包价格 redpackDTO.setTotalAmount(record.getFdRedpackPrice()); // 调用接口的机器Ip地址 String clientIp = WxUtils.getRemoteIp(request); redpackDTO.setClientIp(clientIp); Map&lt;String,String&gt; sendredpackResult = weixinPayService.sendredpack(redpackDTO); // 更新红包纪录表 LotteryRedpackRecord lotteryRedpackRecord = findById(record.getId()); lotteryRedpackRecord.setFdRedpackOpenid(openid); if (sendredpackResult.get(\"status\").equals(\"success\")) &#123; lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex()); // 红包订单的微信单号-微信服务器上红包纪录的唯一标识 String redpackOrderId = sendredpackResult.get(\"sendListid\"); lotteryRedpackRecord.setFdRedpackOrderId(redpackOrderId); lotteryRedpackRecord.setFdRedpackSendDate(new Date()); // 更新抽奖纪录表, 变为已兑换 LotteryRecord lotteryRecord = lotteryRecordService.findById(record.getFdLotteryRecordId()); lotteryRecord.setFdStatus(R.LotteryRecordItem.FdStatus.已兑换.getIndex()); lotteryRecordService.saveSelective(lotteryRecord); saveSelective(lotteryRedpackRecord); &#125; else &#123; lotteryRedpackRecord.setFdStatus(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex()); lotteryRedpackRecord.setRemarks(sendredpackResult.get(\"message\")); saveSelective(lotteryRedpackRecord); return \"红包发送失败, 请及时联系对应的客服!\"; &#125; &#125; else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已发放待领取.getIndex())) &#123; return \"该兑换码对应的红包已发送! 请注意查收\"; &#125; else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.发放失败.getIndex())) &#123; return \"红包发送失败, 请及时联系对应的客服!\"; &#125; else if (fdStatus.equals(R.LotteryRedpackRecord.FdStatus.已领取.getIndex())) &#123; return \"该兑换码对应的红包已领取\"; &#125; else &#123; return \"该兑换码对应的红包已过时, 请及时联系对应的客服\"; &#125; &#125; else &#123; return \"该兑换码无效, 请输入正确的兑换码!\"; &#125; return \"红包已发送请注意查收! 注: 24小时后未领取该红包失效\";&#125; 4、调用微信红包接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 微信公众号发红包接口 * @param redpackDTO * @return */public Map&lt;String,String&gt; sendredpack(RedpackDTO redpackDTO) &#123; Map&lt;String,String&gt; resultMap = Maps.newHashMap(); Map&lt;String,String&gt; wxResultMap = Maps.newHashMap(); // 请求参数 Map&lt;String, String&gt; reqData = Maps.newHashMap(); logger.info(\"---------------------&gt;&gt;&gt; 开始发送红包start\", redpackDTO); try &#123; // 随机字符串 reqData.put(\"nonce_str\", WXPayUtil.generateNonceStr()); // 商户订单号 reqData.put(\"mch_billno\",redpackDTO.getMchBillNo()); // 商户号 reqData.put(\"mch_id\", WxPcPayConfigImpl.MCH_ID); // 公众账号appid reqData.put(\"wxappid\", WxPcPayConfigImpl.SENDREDPACK_WX_APPID); // 商户名称 reqData.put(\"send_name\", WxPcPayConfigImpl.SENDREDPACK_SEND_NAME); // 用户openid reqData.put(\"re_openid\",redpackDTO.getReOpenid()); // 付款金额 reqData.put(\"total_amount\", AmountUtils.transAmountToCent(redpackDTO.getTotalAmount())); // 红包发放总人数 reqData.put(\"total_num\", WxPcPayConfigImpl.SENDREDPACK_TOTAL_NUM); // 红包祝福语 reqData.put(\"wishing\", WxPcPayConfigImpl.SENDREDPACK_WISHING); // Ip地址 reqData.put(\"client_ip\", redpackDTO.getClientIp()); // 活动名称 reqData.put(\"act_name\", WxPcPayConfigImpl.SENDREDPACK_ACT_NAME); //备注 reqData.put(\"remark\", WxPcPayConfigImpl.SENDREDPACK_REMARK); // 生成签名 reqData.put(\"sign\", WXPayUtil.generateSignature(reqData, WxPcPayConfigImpl.API_KEY, WXPayConstants.SignType.MD5 )); String respXml = wxpay.requestWithCert(WxPcPayConfigImpl.SENDREDPACK_URL,reqData , 10000, 10000); wxResultMap = WXPayUtil.xmlToMap(respXml); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包异常\"); resultMap.put(\"message\", e.getMessage()); resultMap.put(\"status\", \"failed\"); &#125; // 通信标识结果 String returnCode = wxResultMap.get(\"return_code\"); if (\"SUCCESS\".equals(returnCode)) &#123; String resultCode = wxResultMap.get(\"result_code\"); // 业务处理结果 if (\"SUCCESS\".equals(resultCode)) &#123; logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包成功\"); // 红包订单的微信单号 String sendListid = wxResultMap.get(\"send_listid\"); resultMap.put(\"sendListid\",sendListid); resultMap.put(\"message\",\"操作成功\"); resultMap.put(\"status\", \"success\"); &#125; else &#123; logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包失败, 原因: \" + wxResultMap.get(\"err_code_des\")); String errCodeDes = wxResultMap.get(\"err_code_des\"); resultMap.put(\"message\",errCodeDes); resultMap.put(\"status\", \"failed\"); return resultMap; &#125; &#125; else &#123; String returnMsg = wxResultMap.get(\"return_msg\"); logger.info(\"---------------------&gt;&gt;&gt; 微信公众号发送红包失败, 原因: \" + returnMsg); resultMap.put(\"message\", returnMsg); resultMap.put(\"status\", \"failed\"); return resultMap; &#125; return resultMap;&#125; 总结及注意事项1.红包是以分为单位，必须大于100分，小于20000分之间，这个很重要,不要一不小心把公司的钱都转出去了 2.需要对请求参数进行加签操作，wxpay里面封装了方法 3.现金红包接口请求是需要证书的，因为是出账，不像充值是属于进账不用证书， 需要调用requestWithCert 这个请求接口 1234567891011/** * 需要证书的请求 * @param strUrl String * @param reqData 向wxpay post的请求数据 Map * @param connectTimeoutMs 超时时间，单位是毫秒 * @param readTimeoutMs 超时时间，单位是毫秒 * @return API返回数据 * @throws Exception */public String requestWithCert(String strUrl, Map&lt;String, String&gt; reqData, int connectTimeoutMs, int readTimeoutMs) throws Exception &#123; 4.由于红包发出去了不知道用户有没有领取，所以可以用一个定时任务或者一个按钮调用微信红包状态查询接口，以更新红包的最新状态 5.可以借助第三方平台，如摇摇啦应用平台，借助这些平台可以不用开发接口，只要配置好参数就可以使用了，但唯一的缺点是要钱","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"Docelver接口管理平台","slug":"backend/测试/Docelver接口管理平台","date":"2018-04-03T12:07:12.000Z","updated":"2018-06-06T13:06:57.972Z","comments":true,"path":"2018/04/03/backend/测试/Docelver接口管理平台/","link":"","permalink":"http://www.songshuiyang.site/2018/04/03/backend/测试/Docelver接口管理平台/","excerpt":"","text":"前言在项目开发过程中，开发一个功能模块，需要前后端开发进行接口定义并形成文档，如果使用doc这些文档去维护接口，多会出现纰漏，特别是在多人开发的项目中，缺点尤为明显，所以需要一个像代码版本控制（git svn）类型的平台去维护这些文档，方便开发人员进行接口维护，前后端开发人员联调接口，测试人员编写测试用例 市场上常用的接口管理平台1. Rap 阿里出品官网地址： http://rapapi.org/org/index.do 官网介绍： RAP是一个可视化接口管理工具 通过分析接口结构，动态生成模拟数据，校验真实接口正确性， 围绕接口定义，通过一系列自动化工具提升我们的协作效率。我们的口号：提高效率，回家吃晚饭！ 使用体验： RAP的应用范围非常明确，是一个面向开发人员自测和联调的工具性平台，它更适合以开发为核心对接口进行维护 2. DOClever官网地址： http://www.doclever.cn/controller/index/index.html 可以对接口信息进行编辑管理，支持get,post,put,delete,patch 五种方法，支持 https 和 https 协议，并且支持 query，body，json，raw，rest，formdata 的参数可视化编辑。同时对 json 可以进行无限层次可视化编辑。并且，状态码，代码注入，markdown 文档等附加功能应有尽有。 接口调试运行，可以对参数进行加密，从md5 到 aes 一应俱全，返回参数与模型实时分析对比，给出不一致的地方，找出接口可能出现的问题。如果你不想手写文档，那么试试接口的数据生成功能，可以对接口运行的数据一键生成文档信息。 mock 的无缝整合，DOClever 自己就是一个 mock 服务器，当你把接口的开发状态设置成已完成，本地 mock 便会自动请求真实接口数据，否则返回事先定义好的 mock 数据。 支持 postman，rap，swagger 的导入，方便你做无缝迁移，同时也支持 html 文件的导出，方便你离线浏览！ 项目版本和接口快照功能并行，你可以为一个项目定义 1.0，1.1，1.2 版本，并且可以自由的在不同版本间切换回滚，再也不怕接口信息的遗失，同时接口也有快照功能，当你接口开发到一半或者接口需求变更的时候，可以随时查看之前编辑的接口信息。 自动化测试功能，目前市面上类似平台的接口自动化测试大部分都是伪自动化，对于一个复杂的场景，比如获取验证码，登陆，获取订单列表，获取某个特定订单详情这样一个上下文关联的一系列操作无能为力。而 DOClever 独创的自动化测试功能，只需要你编写极少量的 javascript 代码便可以在网页里完成这样一系列操作，同时，DOClever 还提供了后台定时批量执行测试用例并把结果发送到团队成员邮箱的功能，你可以及时获取接口的运行状态。 团队协作功能，很多类似的平台这样的功能是收费的，但是 DOClever 觉得好东西需要共享出来，你可以新建一个团队，并且把团队内的成员都拉进来，给他们分组，给他们分配相关的项目以及权限，发布团队公告等等。 DOClever 开源免费，支持内网部署，很多公司考虑到数据的安全性，不愿意把接口放到公网上，没有关系，DOClever 给出一个方便快捷的解决方案，你可以把平台放到自己的内网上，完全不需要连接外网，同时功能一样也不少，即便是对于产品的升级，DOClever 也提供了很便捷的升级方案！","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://www.songshuiyang.site/tags/测试/"}]},{"title":"Java经典算法","slug":"backend/Java/Java经典算法/Java经典算法","date":"2018-03-31T16:24:12.000Z","updated":"2018-10-15T12:40:12.980Z","comments":true,"path":"2018/04/01/backend/Java/Java经典算法/Java经典算法/","link":"","permalink":"http://www.songshuiyang.site/2018/04/01/backend/Java/Java经典算法/Java经典算法/","excerpt":"","text":"排序算法冒泡排序123456789101112public void bubbleSort(int []a)&#123; int len=a.length; for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len-i-1;j++)&#123;//注意第二重循环的条件 if(a[j]&gt;a[j+1])&#123; int temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125;&#125; 选择排序123456789101112131415public void selectSort(int[]a)&#123; int len=a.length; for(int i=0;i&lt;len;i++)&#123;//循环次数 int value=a[i]; int position=i; for(int j=i+1;j&lt;len;j++)&#123;//找到最小的值和位置 if(a[j]&lt;value)&#123; value=a[j]; position=j; &#125; &#125; a[position]=a[i];//进行交换 a[i]=value; &#125;&#125; 查找算法二分查找1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.Scanner;/* * 二分查找 */public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr=&#123;5,3,6,1,9,8,2,4,7&#125;; //先打印输出原始数组数据 System.out.println(\"原始数组数据如下：\"); for (int n : arr) &#123; System.out.print(n+\" \"); &#125; System.out.println(); //首先对数组进行排序，这里用冒泡排序 for(int i=0;i&lt;arr.length-1;i++)&#123; for(int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; int temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; //遍历输出排序好的数组 System.out.println(\"经过冒泡排序后的数组：\"); for(int n:arr)&#123; System.out.print(n+\" \"); &#125; System.out.println();//换行 Scanner input=new Scanner(System.in); System.out.println(\"请输入你要查找的数：\"); int num=input.nextInt(); int result=binarySearch(arr, num); if(result==-1)&#123; System.out.println(\"你要查找的数不存在……\"); &#125; else&#123; System.out.println(\"你要查找的数存在，在数组中的位置是：\"+result); &#125; &#125; //二分查找算法 public static int binarySearch(int[] arr,int num)&#123; int low=0; int upper=arr.length-1; while(low&lt;=upper)&#123; int mid=(upper+low)/2; if(arr[mid]&lt;num)&#123; low=mid+1; &#125; else if(arr[mid]&gt;num)&#123; upper=mid-1; &#125; else return mid; &#125; return -1; &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Windows批处理(cmd/bat)常用命令","slug":"backend/windows bat","date":"2018-03-24T07:54:12.000Z","updated":"2018-03-24T08:07:37.530Z","comments":true,"path":"2018/03/24/backend/windows bat/","link":"","permalink":"http://www.songshuiyang.site/2018/03/24/backend/windows bat/","excerpt":"需求在使用hexo写博客的时候, hexo d 老是不能把代码push上去，网上找了好多方法都不能解决, 只能自己手动把public文件下生成的文件自己敲git命令push上传, 每次写博客的时候都要执行这种操作, 次数多了会感觉厌烦, 所有想windows不是有批处理脚本吗, 所以自己查阅了一些资料, 写了一个草鸡简单的脚本 auto.bat1234567891011121314151617181920# 文件上传commitgit add -Agit commit -m \"auto commit\"git pushecho copy filexcopy D:\\workspace\\hexo-log-bak\\hexo-log-bak\\public\\*.* D:\\workspace\\hexo-log-upload\\songshuiyang.github.io /s /yecho 提交songshuiyang.github.io 文件cd ../../hexo-log-upload\\songshuiyang.github.iogit add -Agit commit -m \"auto commit\"git pushcd ../../hexo-log-bak/hexo-log-bak","text":"需求在使用hexo写博客的时候, hexo d 老是不能把代码push上去，网上找了好多方法都不能解决, 只能自己手动把public文件下生成的文件自己敲git命令push上传, 每次写博客的时候都要执行这种操作, 次数多了会感觉厌烦, 所有想windows不是有批处理脚本吗, 所以自己查阅了一些资料, 写了一个草鸡简单的脚本 auto.bat1234567891011121314151617181920# 文件上传commitgit add -Agit commit -m \"auto commit\"git pushecho copy filexcopy D:\\workspace\\hexo-log-bak\\hexo-log-bak\\public\\*.* D:\\workspace\\hexo-log-upload\\songshuiyang.github.io /s /yecho 提交songshuiyang.github.io 文件cd ../../hexo-log-upload\\songshuiyang.github.iogit add -Agit commit -m \"auto commit\"git pushcd ../../hexo-log-bak/hexo-log-bak 批处理文件批处理文件（batch file）包含一系列 DOS命令，通常用于自动执行重复性任务。用户只需双击批处理文件便可执行任务，而无需重复输入相同指令。编写批处理文件非常简单，但难点在于确保一切按顺序执行。编写严谨的批处理文件可以极大程度地节省时间，在应对重复性工作时尤其有效。 在Windows中善用批处理可以简化很多重复工作 常用DOS命令123456789101112131415161718192021222324252627282930313233343536373839404142文件夹管理 cd 显示当前目录名或改变当前目录。 md 创建目录。 rd 删除一个目录。 dir 显示目录中的文件和子目录列表。 tree 以图形显示驱动器或路径的文件夹结构。 path 为可执行文件显示或设置一个搜索路径。 xcopy 复制文件和目录树。文件管理 type 显示文本文件的内容。 copy 将一份或多份文件复制到另一个位置。 del 删除一个或数个文件。 move 移动文件并重命名文件和目录。(Windows XP Home Edition中没有) ren 重命名文件。 replace 替换文件。 attrib 显示或更改文件属性。 find 搜索字符串。 fc 比较两个文件或两个文件集并显示它们之间的不同网络命令 ping 进行网络连接测试、名称解析 ftp 文件传输 net 网络命令集及用户管理 telnet 远程登陆 ipconfig显示、修改TCP/IP设置 msg 给用户发送消息 arp 显示、修改局域网的IP地址-物理地址映射列表 系统管理 at 安排在特定日期和时间运行命令和程序 shutdown立即或定时关机或重启 tskill 结束进程 taskkill结束进程(比tskill高级，但WinXPHome版中无该命令) tasklist显示进程列表(Windows XP Home Edition中没有) sc 系统服务设置与控制 reg 注册表控制台工具 powercfg控制系统上的电源设置 例子","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"Spring 集成Encache","slug":"backend/缓存技术/Encache","date":"2018-03-24T03:41:12.000Z","updated":"2018-04-08T15:02:40.632Z","comments":true,"path":"2018/03/24/backend/缓存技术/Encache/","link":"","permalink":"http://www.songshuiyang.site/2018/03/24/backend/缓存技术/Encache/","excerpt":"一：Encache1. 什么是EncacheEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。 官网: http://www.ehcache.org/ 2. 基本介绍Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 Ehcache最初是由Greg Luck于2003年开始开发。2009年,该项目被Terracotta购买。软件仍然是开源,但一些新的主要功能(例如，快速可重启性之间的一致性的)只能在商业产品中使用，例如Enterprise EHCache and BigMemory。维基媒体Foundationannounced目前使用的就是Ehcache技术。","text":"一：Encache1. 什么是EncacheEhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。 官网: http://www.ehcache.org/ 2. 基本介绍Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 Ehcache最初是由Greg Luck于2003年开始开发。2009年,该项目被Terracotta购买。软件仍然是开源,但一些新的主要功能(例如，快速可重启性之间的一致性的)只能在商业产品中使用，例如Enterprise EHCache and BigMemory。维基媒体Foundationannounced目前使用的就是Ehcache技术。 3. 特点主要的特性有： 快速 简单 多种缓存策略 缓存数据有两级：内存和磁盘，因此无需担心容量问题 缓存数据会在虚拟机重启的过程中写入磁盘 可以通过RMI、可插入API等方式进行分布式缓存 具有缓存和缓存管理器的侦听接口 支持多缓存管理器实例，以及一个实例的多个缓存区域 提供Hibernate的缓存实现 ehcache与redis的区别1.redis的数据结构比较丰富，有key-value、hash、set等；ehcache比较简单，只有key-value 2.ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。redis是通过socket访问到缓存服务，效率ecache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 二: Encache与Spring 集成1. 前言Spring自身并没有实现缓存解决方案，但是对缓存管理功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。 Spring Cache是作用在方法上的（不能理解为只注解在方法上），其核心思想是：当我们在调用一个缓存方法时会把该方法参数和返回结果作为一个键值存放在缓存中，等到下次利用同样的参数调用该方法时将不再执行该方法，而是直接从缓存中获取结果进行返回。所以在使用Spring Cache的时候我们要保证我们的缓存的方法对于相同的方法参数要有相同的返回结果。 2. 开始集成 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt; 编写ehcache.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"&gt; &lt;!-- 磁盘缓存位置 在Windows的缓存目录为：C:\\Users\\登录用户~1\\AppData\\Local\\Temp\\ Linux：/tmp --&gt; &lt;diskStore path=\"java.io.tmpdir/ehcache\"/&gt; &lt;!--name：缓存名称。--&gt; &lt;!--maxElementsInMemory：缓存最大个数。--&gt; &lt;!--eternal：缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。--&gt; &lt;!--timeToIdleSeconds：置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。--&gt; &lt;!--timeToLiveSeconds：缓存数据的生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。--&gt; &lt;!--maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。--&gt; &lt;!--overflowToDisk：内存不足时，是否启用磁盘缓存。--&gt; &lt;!--diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。--&gt; &lt;!--maxElementsOnDisk：硬盘最大缓存个数。--&gt; &lt;!--diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。--&gt; &lt;!--diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。--&gt; &lt;!--memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。--&gt; &lt;!--clearOnFlush：内存数量最大时是否清除。--&gt; &lt;!--@Cacheable(value = \"users\", condition = \"#user.getId() &lt;= 2\")--&gt; &lt;!--@CachePut(value = \"users\", key = \"#user.getId()\")--&gt; &lt;!--@CacheEvict(value = \"users\", allEntries = true)--&gt; &lt;!-- 默认缓存 --&gt; &lt;defaultCache maxEntriesLocalHeap=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" maxEntriesLocalDisk=\"10000000\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;persistence strategy=\"localTempSwap\"/&gt; &lt;/defaultCache&gt; &lt;!-- 博客文章详情缓存 --&gt; &lt;cache name=\"articlesDetail\" maxElementsInMemory=\"1000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" overflowToDisk=\"false\" memoryStoreEvictionPolicy=\"LRU\"/&gt; &lt;!-- hotArticles缓存 --&gt; &lt;cache name=\"articlesDetail\" maxElementsInMemory=\"1000\" eternal=\"true\" overflowToDisk=\"false\" memoryStoreEvictionPolicy=\"LRU\"/&gt;&lt;/ehcache&gt; 在需要缓存的地方加上缓存注解 12345678910111213141516171819202122/** * 第一次执行会缓存文章,以id作为key, 第二次会直接取缓存的数据(需要在缓存有效期,过期会重新查询数据库) * @param id * @return */@Override@Cacheable(value = \"articlesDetail\", key = \"#id\")public BlogArticles selectByPrimaryKey(Integer id) &#123; return getMappser().selectByPrimaryKey(id);&#125;/** * 保存文章，同时删除record.getId()该已存的缓存数据 * @param record * @return */@Override@CacheEvict(value = \"articlesDetail\", key = \"#record.getId()\")public int updateByPrimaryKeySelective(BlogArticles record) &#123; setCurrentOperator(record); return getMappser().updateByPrimaryKeySelective(record);&#125; 3. 注解讲解首先使用注解标记方法，相当于定义了切点，然后使用Aop技术在这个方法的调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。 @Cacheable 12345678910111213141516171819202122232425262728表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 这个注解可以用condition属性来设置条件，如果不满足条件，就不使用缓存能力，直接执行方法。 可以使用key属性来指定key的生成规则。@Cacheable 支持如下几个参数： value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓存到哪个Cache中 key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key，支持SpEL，如果要引用参数值使用井号加参数名，如：#userId， 一般来说，我们的更新操作只需要刷新缓存中某一个值，所以定义缓存的key值的方式就很重要，最好是能够唯一，因为这样可以准确的清除掉特定的缓存，而不会影响到其它缓存值 ， 本例子中使用实体加冒号再加ID组合成键的名称，如”user:1”、”order:223123”等 condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存，支持SpEL // 将缓存保存到名称为UserCache中，键为\"user:\"字符串加上userId值，如 'user:1' @Cacheable(value=\"UserCache\", key=\"'user:' + #userId\") public User findById(String userId) &#123; return (User) new User(\"1\", \"mengdee\"); &#125; // 将缓存保存进UserCache中，并当参数userId的长度小于12时才保存进缓存，默认使用参数值及类型作为缓存的key // 保存缓存需要指定key，value， value的数据类型，不指定key默认和参数名一样如：\"1\" @Cacheable(value=\"UserCache\", condition=\"#userId.length() &lt; 12\") public boolean isReserved(String userId) &#123; System.out.println(\"UserCache:\"+userId); return false; &#125; @CachePut 1与@Cacheable不同，@CachePut不仅会缓存方法的结果，还会执行方法的代码段。它支持的属性和用法都与@Cacheable一致。 @CacheEvict 1234567891011121314151617181920与@Cacheable功能相反，@CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。@CacheEvict 支持如下几个参数： value：缓存位置名称，不能为空，同上 key：缓存的key，默认为空，同上 condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL allEntries：true表示清除value中的全部缓存，默认为false //清除掉UserCache中某个指定key的缓存 @CacheEvict(value=\"UserCache\",key=\"'user:' + #userId\") public void removeUser(User user) &#123; System.out.println(\"UserCache\"+user.getUserId()); &#125; //清除掉UserCache中全部的缓存 @CacheEvict(value=\"UserCache\", allEntries=true) public final void setReservedUsers(String[] reservedUsers) &#123; System.out.println(\"UserCache deleteall\"); &#125; @Caching 1234如果需要使用同一个缓存注解（@Cacheable、@CacheEvict或@CachePut）多次修饰一个方法，就需要用到@Caching。@Caching(evict = &#123; @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") &#125;)public Book importBooks(String deposit, Date date) @CacheConfig 12345678与前面的缓存注解不同，这是一个类级别的注解。 如果类的所有操作都是缓存操作，你可以使用@CacheConfig来指定类，省去一些配置。@CacheConfig(\"books\")public class BookRepositoryImpl implements BookRepository &#123; @Cacheable public Book findBook(ISBN isbn) &#123;...&#125;&#125; 4. 创建Cache工具类, 方便对cache进行管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ecut.core.utils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cache.Cache;import org.springframework.cache.CacheManager;/** * 缓存工具类 * @author songshuiyang * @date 2018/3/24 12:16 */public class CacheUtils &#123; private final static Logger logger = LoggerFactory.getLogger(CacheUtils.class); private static CacheManager cacheManager = (CacheManager) SpringContextUtils.getBean(\"cacheManager\"); /** * 获取缓存 * @param cacheName 缓存名 * @param key 键 * @return Object */ public static Object get(String cacheName, Object key) &#123; Cache cache = cacheManager.getCache(cacheName); if (cache != null) &#123; //这里需要判断是否null if(cache.get(key) != null)&#123; return cache.get(key).get(); &#125; &#125; return null; &#125; /** * 添加缓存 * 存在则更新 * @param cacheName 缓存名 * @param key 键 * @param value 值 */ public static void put(String cacheName, Object key, Object value) &#123; Cache cache = cacheManager.getCache(cacheName); if(cache != null)&#123; cache.put(key, value); &#125; &#125; /** * 清除缓存 * @param cacheName 缓存名 * @param key 键 */ public static void remove(String cacheName, Object key) &#123; Cache cache = cacheManager.getCache(cacheName); if (cache != null) &#123; cache.evict(key); &#125;else&#123; logger.warn(\"this key is not in Cache\"); &#125; &#125;&#125;&#125; 参考：https://blog.csdn.net/vbirdbest/article/details/72763048http://www.cnblogs.com/jingmoxukong/p/5975994.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"hover.css","slug":"frontend/hover","date":"2018-03-20T12:52:12.000Z","updated":"2018-03-20T15:08:21.018Z","comments":true,"path":"2018/03/20/frontend/hover/","link":"","permalink":"http://www.songshuiyang.site/2018/03/20/frontend/hover/","excerpt":"","text":"Hover.cssA collection of CSS3 powered hover effects to be applied to links, buttons, logos, SVG, featured images and so on. Easily apply to your own elements, modify or just use for inspiration. Available in CSS, Sass, and LESS. 官网地址: http://ianlunn.github.io/Hover/ 演示地址: http://wow.techbrood.com/fiddle/852","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.songshuiyang.site/tags/css/"}]},{"title":"Linux 命令笔记","slug":"backend/Linux/linux笔记","date":"2018-03-08T09:30:44.000Z","updated":"2018-07-08T07:02:02.887Z","comments":true,"path":"2018/03/08/backend/Linux/linux笔记/","link":"","permalink":"http://www.songshuiyang.site/2018/03/08/backend/Linux/linux笔记/","excerpt":"","text":"出现问题 bash: service: command not found, 解决方法：1yum install initscripts 查看端口12345678910111213141516# 查看80端口占用情况lsof -i tcp:80# 列出所有端口netstat -ntlp# 查看端口状态netstat -lnp|grep 88 #88请换为你的apache需要的端口，如：80# SSH执行以上命令，可以查看到88端口正在被哪个进程使用。如下图，进程号为 1777 。# 查看进程的详细信息ps 1777# 杀掉进程kill -9 1777 #杀掉编号为1777的进程（请根据实际情况输入）","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"Docker笔记","slug":"backend/Linux/Docker笔记","date":"2018-03-08T06:30:44.000Z","updated":"2018-03-10T02:17:01.895Z","comments":true,"path":"2018/03/08/backend/Linux/Docker笔记/","link":"","permalink":"http://www.songshuiyang.site/2018/03/08/backend/Linux/Docker笔记/","excerpt":"什么是DockerDocker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了。作为一名 Java 程序员，我们是时候一起把 Docker 学起来了！ 1.传统虚拟化技术的体系架构： mechine.png 可见，我们在宿主机的操作系统上，可安装了多个虚拟机，而在每个虚拟机中，通过虚拟化技术，实现了一个虚拟操作系统，随后，就可以在该虚拟操作系统上，安装自己所需的应用程序了。这一切看似非常简单，但其中的技术细节是相当高深莫测的，大神级人物都不一定说得清楚。","text":"什么是DockerDocker 是一种“轻量级”容器技术，它几乎动摇了传统虚拟化技术的地位，现在国内外已经有越来越多的公司开始逐步使用 Docker 来替换现有的虚拟化平台了。作为一名 Java 程序员，我们是时候一起把 Docker 学起来了！ 1.传统虚拟化技术的体系架构： mechine.png 可见，我们在宿主机的操作系统上，可安装了多个虚拟机，而在每个虚拟机中，通过虚拟化技术，实现了一个虚拟操作系统，随后，就可以在该虚拟操作系统上，安装自己所需的应用程序了。这一切看似非常简单，但其中的技术细节是相当高深莫测的，大神级人物都不一定说得清楚。 凡是使用过虚拟机的同学，应该都知道，启动虚拟机就像启动一台计算机，初始化过程是相当慢的，我们需要等很久，才能看到登录界面。一旦虚拟机启动以后，就可以与宿主机建立网络连接，确保虚拟机与宿主机之间是互联互通的。不同的虚拟机之间却是相互隔离的，也就是说，彼此并不知道对方的存在，但每个虚拟机占用的都是宿主机的硬件与网络资源。 2.Docker 技术的体系架构 mechine.png 可见，在宿主机的操作系统上，有一个 Docker 服务在运行（或者称为“Docker 引擎”），在此服务上，我们可开启多个 Docker 容器，而每个 Docker 容器中可运行自己所需的应用程序，Docker 容器之间也是相互隔离的，同样地，都是占用的宿主机的硬件与网络资源。、 Docker 容器相对于虚拟机而言，除了在技术实现上完全不一样以外，启动速度较虚拟机而言有本质的飞跃，启动一个容器只在眨眼瞬间。不管是虚拟机还是 Docker 容器，它们都是为了隔离应用程序的运行环境，节省我们的硬件资源，为我们开发人员提供福利。 3.Docker 的 Logo: logo.png 很明显，这是一只鲸鱼，它托着许多集装箱。我们可以把宿主机可当做这只鲸鱼，把相互隔离的容器可看成集装箱，每个集装箱中都包含自己的应用程序。这 Logo 简直的太形象了！ 4.Docker的应用场景123451. Web 应用的自动化打包和发布。2. 自动化测试和持续集成、发布。3. 在服务型环境中部署和调整数据库或其他的后台应用。 5.Docker 的优点123456781、简化程序：Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的 任务，在Docker容器的处理下，只需要数秒就能完成。2、避免选择恐惧症：如果你有选择恐惧症，还是资深患者。Docker 帮你 打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。3、节省开支：一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。 Docker 术语 术语 说明 Docker 镜像(Images) Docker 镜像是用于创建 Docker 容器的模板。 Docker 容器(Container) 容器是独立运行的一个或一组应用。 Docker 客户端(Client) Docker 客户端通过命令行或者其他工具使用 Docker API (https://docs.docker.com/reference/api/docker_remote_api) 与 Docker 的守护进程通信。 Docker 主机(Host) 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Docker 仓库(Registry) Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。 Docker Machine Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。 使用Docker前先配置 Docker国内镜像或者使用registry-mirrors配置加速由于国内访问直接访问Docker hub网速比较慢，拉取镜像的时间就会比较长。一般我们会使用镜像加速或者直接从国内的一些平台镜像仓库上拉取。 123456789101112131415161718192021222324方法一： 网易镜像中心：https://c.163.com/hub#/m/home/ 拉取镜像的命令是： docker pull 镜像名字 所以我们可以按照给出的镜像名字或者命令直接拉取。eg: docker pull hub.c.163.com/library/tomcat:latest方法二： daocloud镜像市场：https://hub.daocloud.io/如果说还是想从dockerhub上拉取，那么使用加速器修改docker的registry-mirrors。这里使用的是DaoCloud的加速器。 首先在http://www.daocloud.io/进行注册登录。然后点击加速器，得到如下脚本 curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://24524c4f.m.daocloud.io Copy 该脚本可以将 --registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。 也可以自己手动修改 /etc/docker/daemon.json&#123; \"registry-mirrors\": [\"http://ef017c13.m.daocloud.io\"], \"live-restore\": true&#125;最后重启docker service docker restart 安装 Docker1.前提条件1234使用 yum 安装（CentOS 7下）Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。通过 uname -r 命令查看你当前的内核版本 2.安装1yum -y install docker 3.启动服务1service docker start 4.测试运行 hello-world1docker run hello-world Docker中使用CentOS7镜像1.启动容器服务1systemctl start docker.service 2.下载CentOS7 镜像12345678910111213141516[root@JD docker]# docker pull centos:7.3.1611Trying to pull repository docker.io/library/centos ... 7.3.1611: Pulling from docker.io/library/centos版本: https://hub.docker.com/_/centos/ 可以在这个网站上选择自己想要的版本 latest, centos7, 7 (docker/Dockerfile) centos6, 6 (docker/Dockerfile) centos7.4.1708, 7.4.1708 (docker/Dockerfile) centos7.3.1611, 7.3.1611 (docker/Dockerfile) centos7.2.1511, 7.2.1511 (docker/Dockerfile) centos7.1.1503, 7.1.1503 (docker/Dockerfile) centos7.0.1406, 7.0.1406 (docker/Dockerfile) centos6.9, 6.9 (docker/Dockerfile) centos6.8, 6.8 (docker/Dockerfile) centos6.7, 6.7 (docker/Dockerfile) centos6.6, 6.6 (docker/Dockerfile) 3.下载成功之后查看本地所有的镜像，得到centos的 IMAGE ID: 66ee80d59a6812345[root@JD ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest 108db0e7c85e 2 weeks ago 557.4 MBdocker.io/hello-world latest f2a91732366c 3 months ago 1.848 kBdocker.io/centos 7.3.1611 66ee80d59a68 4 months ago 191.8 MB 4.启动docker中的CentOS712345678910111213141516171819docker run -ti 66ee /bin/bash#6866 是 IMAGE ID 前四位数字-能区分出是哪个image即可root@b4ad1d1c87da /]# #登录成功，接下来就可以为所欲为啦。命令笔记 容器是在镜像的基础上来运行的，一旦容器启动了，我们就可以登录到容器中，安装自己所需的软件或应用程序。既然镜像已经下载到本地，那么如何才能启动容器呢 docker run -i -t -v /root/software/:/mnt/software/ 25c5298b1a36 /bin/bash docker run &lt;相关参数&gt; &lt;镜像 ID&gt; &lt;初始命令&gt; -i：表示以“交互模式”运行容器 -t：表示容器启动后会进入其命令行 -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt; 假设我们的所有安装程序都放在了宿主机的/root/software/目录下，现在需要将其挂载到容器的/mnt/software/目录下。 初始命令表示一旦容器启动，需要运行的命令，此时使用“/bin/bash”，表示什么也不做，只需进入命令行即可。 5.检查CentOS7系统1234root@b4ad1d1c87da /]# uname -aLinux b4ad1d1c87da 3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux[root@b4ad1d1c87da /]# cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core) 6.退出1234ctrl+d 退出容器且关闭, docker ps 查看无,ctrl+p+q 退出容器但不关闭, docker ps 7.再进入CentOS71234567[root@wxtest1607 ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb4ad1d1c87da 6866 \"/bin/bash\" 12 seconds ago Up 9 seconds mad_swanson drunk_hypatia得到 CONTAINER ID [root@wxtest1607 ~]# docker exec -ti b4ad /bin/bash [root@b4ad1d1c87da /]# 8.安装tomcat123456781. yum -y install tomcat注： 在docker中通过systemctl 启动服务的时候总是报Failed to get D-Bus connection: Operation not permitted 这样的错误提示。 解决方法： 解决办法就是在docker run 的时候运行/usr/sbin/init 。比如： docker run -ti 66ee /usr/sbin/init2. 在Centos使用yum安装后，Tomcat相关的目录都已采用符号链接到/usr/share/tomcat6目录，包含webapps等，这很方便我们配置管理 转载：http://www.runoob.com/docker/docker-tutorial.html 转载：http://developer.51cto.com/art/201702/529956.htm 转载：http://www.jb51.net/article/112921.htm 转载：https://www.jianshu.com/p/0aa535e681f5","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"Mysql 用户及权限管理","slug":"backend/数据库/Mysql 用户及权限管理d","date":"2018-03-07T14:24:12.000Z","updated":"2018-12-06T12:28:47.875Z","comments":true,"path":"2018/03/07/backend/数据库/Mysql 用户及权限管理d/","link":"","permalink":"http://www.songshuiyang.site/2018/03/07/backend/数据库/Mysql 用户及权限管理d/","excerpt":"权限控制授权语法：1234567891011121314151617181920GRANT privileges (columns) ON what TO user IDENTIFIED BY \"password\" WITH GRANT OPTION权限列表:ALTER: 修改表和索引。CREATE: 创建数据库和表。DELETE: 删除表中已有的记录。DROP: 抛弃(删除)数据库和表。INDEX: 创建或抛弃索引。INSERT: 向表中插入新行。REFERENCE: 未用。SELECT: 检索表中的记录。UPDATE: 修改现存表记录。FILE: 读或写服务器上的文件。PROCESS: 查看服务器中执行的线程信息或杀死线程。RELOAD: 重载授权表或清空日志、主机缓存或表缓存。SHUTDOWN: 关闭服务器。ALL: 所有权限，ALL PRIVILEGES同义词。USAGE: 特殊的 \"无权限\" 权限。用 户账户包括 \"username\" 和 \"host\" 两部分，后者表示该用户被允许从何地接入。tom@'%' 表示任何地址，默认可以省略。还可以是 \"tom@192.168.1.%\"、\"tom@%.abc.com\" 等。数据库格式为 db@table，可以是 \"test.*\" 或 \"*.*\"，前者表示 test 数据库的所有表，后者表示所有数据库的所有表。子句 \"WITH GRANT OPTION\" 表示该用户可以为其他用户分配权限。","text":"权限控制授权语法：1234567891011121314151617181920GRANT privileges (columns) ON what TO user IDENTIFIED BY \"password\" WITH GRANT OPTION权限列表:ALTER: 修改表和索引。CREATE: 创建数据库和表。DELETE: 删除表中已有的记录。DROP: 抛弃(删除)数据库和表。INDEX: 创建或抛弃索引。INSERT: 向表中插入新行。REFERENCE: 未用。SELECT: 检索表中的记录。UPDATE: 修改现存表记录。FILE: 读或写服务器上的文件。PROCESS: 查看服务器中执行的线程信息或杀死线程。RELOAD: 重载授权表或清空日志、主机缓存或表缓存。SHUTDOWN: 关闭服务器。ALL: 所有权限，ALL PRIVILEGES同义词。USAGE: 特殊的 \"无权限\" 权限。用 户账户包括 \"username\" 和 \"host\" 两部分，后者表示该用户被允许从何地接入。tom@'%' 表示任何地址，默认可以省略。还可以是 \"tom@192.168.1.%\"、\"tom@%.abc.com\" 等。数据库格式为 db@table，可以是 \"test.*\" 或 \"*.*\"，前者表示 test 数据库的所有表，后者表示所有数据库的所有表。子句 \"WITH GRANT OPTION\" 表示该用户可以为其他用户分配权限。 实例： 12345678910111213141516171819202122use mysql1. 新建用户, 并赋予所有数据库权限 GRANT ALL PRIVILEGES ON *.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION; 说明: 1. username - 你将创建的用户名, host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器. 2. 指定helloworld数据库: GRANT ALL PRIVILEGES ON helloword.* TO 'username'@'host' IDENTIFIED BY 'password' WITH GRANT OPTION;2. 指定该用户只能执行 select 和 update 命令 GRANT SELECT, UPDATE ON *.* TO 'username'@'%' IDENTIFIED BY 'password';3. 另外每当调整权限后，通常需要执行以下语句刷新权限： FLUSH PRIVILEGES;4. grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。 grant select on testdb.* to common_user@’%’ grant insert on testdb.* to common_user@’%’ grant update on testdb.* to common_user@’%’ grant delete on testdb.* to common_user@’%’ 或者，用一条 MySQL 命令来替代： grant select, insert, update, delete on testdb.* to common_user@’%’ 用户12345678910111213141516171819202122232425262728293031323334351. 删除刚才创建的用户： DROP USER username@localhost;2. 查看用户创建是否成功 select user,host from user ; +-----------+-----------+ | user | host | +-----------+-----------+ | root | % | | select | % | | server | % | | shuiyang | % | | user | % | | mysql.sys | localhost | +-----------+-----------+ 3. 查看select用户的授权 show grants for select; MySQL [mysql]&gt; show grants for `select`; +---------------------------------------------+ | Grants for select@% | +---------------------------------------------+ | GRANT SELECT, UPDATE ON *.* TO 'select'@'%' | +---------------------------------------------+ 1 row in set (0.00 sec) 4. 设置与更改用户密码SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword')如果是当前登陆用户用SET PASSWORD = PASSWORD(\"newpassword\");","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.songshuiyang.site/tags/mysql/"}]},{"title":"Mysql 字符集和排序规则说明","slug":"backend/数据库/Mysql 字符集和排序规则说明","date":"2018-03-07T14:24:12.000Z","updated":"2018-12-06T12:28:47.870Z","comments":true,"path":"2018/03/07/backend/数据库/Mysql 字符集和排序规则说明/","link":"","permalink":"http://www.songshuiyang.site/2018/03/07/backend/数据库/Mysql 字符集和排序规则说明/","excerpt":"","text":"字符集utf8mb4 和 utf8 比较UTF-8是使用1~4个字节，一种变长的编码格式。（字符编码 ） mb4即 most bytes 4，使用4个字节来表示完整的UTF-8。而MySQL中的utf8是utfmb3，只有三个字节，节省空间但不能表达全部的UTF-8，只能支持“基本多文种平面”（Basic Multilingual Plane，BMP）。 推荐使用utf8mb4。 排序规则ci 是 case insensitive, 即 “大小写不敏感”, a 和 A 会在字符判断中会被当做一样的。 bin 是二进制, a 和 A 会别区别对待。 例如你运行如下sql, 那么在utf8_bin中你就找不到 txt = ‘A’ 的那一行, 而 utf8_general_ci 则可以。1SELECT * FROM table WHERE txt = 'a'; 常用排序规则 utf8_general_ci：不区分大小写，这个你在注册用户名和邮箱的时候就要使用。 utf8_general_cs：区分大小写，如果用户名和邮箱用这个 就会照成不良后果。 utf8_bin：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容。 总结 utf8_unicode_ci和utf8_general_ci对中、英文来说没有实质的差别。 utf8_general_ci：校对速度快，但准确度稍差。 utf8_unicode_ci：准确度高，但校对速度稍慢。 如果你的应用有德语、法语或者俄语，请一定使用utf8_unicode_ci。一般用utf8_general_ci就够了，到现在也没发现问题。 参考:https://www.cnblogs.com/zwakeup/p/8267204.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://www.songshuiyang.site/tags/mysql/"}]},{"title":"Centos7安装Mysql5.7.md","slug":"backend/Linux/Centos7安装Mysql5.7","date":"2018-03-07T12:30:44.000Z","updated":"2018-06-11T14:59:30.379Z","comments":true,"path":"2018/03/07/backend/Linux/Centos7安装Mysql5.7/","link":"","permalink":"http://www.songshuiyang.site/2018/03/07/backend/Linux/Centos7安装Mysql5.7/","excerpt":"一：配置YUM源 官网地址 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/ 1.下载mysql源安装包1wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 命令笔记:12345678910111213141516171819202122232425262728wget:用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；-b：进行后台的方式运行wget；-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；-c：继续执行上次终端的任务；-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；-d：调试模式运行指令；-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；-h：显示指令帮助信息；-i&lt;文件&gt;：从指定文件获取要下载的URL地址；-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；-L：仅顺着关联的连接；-r：递归下载方式；-nc：文件存在时，下载文件不覆盖原有文件；-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；-q：不显示指令执行过程；-nh：不查询主机名称；-v：显示详细执行过程；-V：显示版本信息；--passive-ftp：使用被动模式PASV连接FTP服务器；--follow-ftp：从HTML文件中下载FTP连接文件下载并以不同的文件名保存:wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080","text":"一：配置YUM源 官网地址 在MySQL官网中下载YUM源rpm安装包：http://dev.mysql.com/downloads/repo/yum/ 1.下载mysql源安装包1wget http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 命令笔记:12345678910111213141516171819202122232425262728wget:用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；-b：进行后台的方式运行wget；-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；-c：继续执行上次终端的任务；-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；-d：调试模式运行指令；-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；-h：显示指令帮助信息；-i&lt;文件&gt;：从指定文件获取要下载的URL地址；-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；-L：仅顺着关联的连接；-r：递归下载方式；-nc：文件存在时，下载文件不覆盖原有文件；-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；-q：不显示指令执行过程；-nh：不查询主机名称；-v：显示详细执行过程；-V：显示版本信息；--passive-ftp：使用被动模式PASV连接FTP服务器；--follow-ftp：从HTML文件中下载FTP连接文件下载并以不同的文件名保存:wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080 2.安装mysql源1yum localinstall mysql57-community-release-el7-8.noarch.rpm 命令笔记:12345678910111213141516171819202122232425262728293031323334353637yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更细与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。选项:-h：显示帮助信息；-y：对所有的提问都回答“yes”；-c：指定配置文件；-q：安静模式；-v：详细模式；-d：设置调试等级（0-10）；-e：设置错误等级（0-10）；-R：设置yum处理一个命令的最大等待时间；-C：完全从缓存中运行，而不去下载或者更新任何头文件。参数：install：安装rpm软件包；update：更新rpm软件包；check-update：检查是否有可用的更新rpm软件包；remove：删除指定的rpm软件包；list：显示软件包的信息；search：检查软件包的信息；info：显示指定的rpm软件包的描述信息和概要信息；clean：清理yum过期的缓存；shell：进入yum的shell提示符；resolvedep：显示rpm软件包的依赖关系；localinstall：安装本地的rpm软件包；localupdate：显示本地rpm软件包进行更新；deplist：显示rpm软件包的所有依赖关系。实例部分常用的命令包括：自动搜索最快镜像插件：yum install yum-fastestmirror安装yum图形窗口插件：yum install yumex查看可能批量安装的列表：yum grouplist 3.检查mysql源是否安装成功1yum repolist enabled | grep \"mysql.*-community.*\" logo 看到上图所示表示mysql源安装成功。 可以修改vim /etc/yum.repos.d/mysql-community.repo源，改变默认安装的mysql版本。比如要安装5.6版本，将5.7源的enabled=1改成enabled=0。然后再将5.6源的enabled=0改成enabled=1即可 二 安装MySQL1yum install mysql-community-server 命令笔记:123456789101112131415161718192021222324252627安装yum install #全部安装yum install package1 #安装指定的安装包package1yum groupinsall group1 #安装程序组group1更新和升级yum update #全部更新yum update package1 #更新指定程序包package1yum check-update #检查可更新的程序yum upgrade package1 #升级指定程序包package1yum groupupdate group1 #升级程序组group1查找和显示yum info package1 #显示安装包信息package1yum list #显示所有已经安装和可以安装的程序包yum list package1 #显示指定程序包安装情况package1yum groupinfo group1 #显示程序组group1信息yum search string 根据关键字string查找安装包删除程序yum remove &amp;#124; erase package1 #删除程序包package1yum groupremove group1 #删除程序组group1yum deplist package1 #查看程序package1依赖情况 三：启动MySQL服务1.启动1systemctl start mysqld 命令笔记：123456789101112systemctl是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。任务 旧指令 新指令使某服务自动启动 chkconfig --level 3 httpd on systemctl enable httpd.service使某服务不自动启动 chkconfig --level 3 httpd off systemctl disable httpd.service检查服务状态 service httpd status systemctl status httpd.service （服务详细信息） systemctl is-active httpd.service （仅显示是否 Active)显示所有已启动的服务 chkconfig --list systemctl list-units --type=service启动某服务 service httpd start systemctl start httpd.service停止某服务 service httpd stop systemctl stop httpd.service重启某服务 service httpd restart systemctl restart httpd.service 2.查看状态1234567891011121314151617查看MySQL的启动状态systemctl status mysqld输出：● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2018-03-07 21:14:55 CST; 18min ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 17338 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 17320 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 17343 (mysqld) CGroup: /system.slice/mysqld.service └─17343 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidMar 07 21:14:54 VM_0_8_centos systemd[1]: Starting MySQL Server...Mar 07 21:14:55 VM_0_8_centos systemd[1]: Started MySQL Server. 3.开机启动12systemctl enable mysqldsystemctl daemon-reload 4.修改root本地登录密码12345678910111213141516171819202122232425mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：1. 修改密码策略 mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误 步骤1：不需要密码策略，添加/etc/my.cnf件中添加如下配置禁用即可： validate_password = off 步骤2：重新启动mysql服务使配置生效： systemctl restart mysqld 2. 查看初始密码： grep 'temporary password' /var/log/mysqld.log 输出： 2018-03-07T13:01:08.963552Z 1 [Note] A temporary password is generated for root@localhost: zktt1wKFD.HN 得到临时密码: zktt1wKFD.HN3. 登录mysql: mysql -uroot -p 输入临时密码进入mysql命令行4. 修改密码 set password for 'root'@'localhost'=password('MyNewPass4!'); 5. 重启服务 systemctl restart mysqld 四：开启远程连接1234567891011121314151617181920登入mysql mysql -uroot -p 使用mysql数据库 use mysql; 开启远程连接（root 用户名，% 所有人都可以访问 ，password 密码） GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION; 也可以添加一个新用户: GRANT ALL PRIVILEGES ON *.* TO 'shuiyang'@'%' IDENTIFIED BY 'password!' WITH GRANT OPTION; FLUSH PRIVILEGES; 重起mysql服务 service mysqld restart如果执行完以上步骤，还是不能远程连接，那么我们需要查看服务器的防火墙是否开启 service iptables status如果防火墙开启，请关闭 service iptables stop 五：配置默认编码为utf812345678910111213141516171819202122修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：[mysqld]character_set_server=utf8init_connect='SET NAMES utf8'重新启动mysql服务，查看数据库默认编码如下所示：mysql&gt; show variables like '%character%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 备注：12345默认配置文件路径： 配置文件：/etc/my.cnf 日志文件：/var/log//var/log/mysqld.log 服务启动脚本：/usr/lib/systemd/system/mysqld.service socket文件：/var/run/mysqld/mysqld.pid 转载：https://www.linuxidc.com/Linux/2016-09/135288.htm转载:http://blog.csdn.net/sun614345456/article/details/53672150","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"百度富文本框编辑器Ueditor的使用","slug":"backend/相关技术/百度富文本框编辑器Ueditor的使用","date":"2018-03-05T14:54:12.000Z","updated":"2018-03-05T15:40:04.825Z","comments":true,"path":"2018/03/05/backend/相关技术/百度富文本框编辑器Ueditor的使用/","link":"","permalink":"http://www.songshuiyang.site/2018/03/05/backend/相关技术/百度富文本框编辑器Ueditor的使用/","excerpt":"百度富文本框编辑器：官网： http://ueditor.baidu.com/website/ 官网演示地址：http://ueditor.baidu.com/website/onlinedemo.html UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码…","text":"百度富文本框编辑器：官网： http://ueditor.baidu.com/website/ 官网演示地址：http://ueditor.baidu.com/website/onlinedemo.html UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码… 开始使用：参考:http://fex.baidu.com/ueditor/ 1. 入门部署和体验1.1下载编辑器到官网下载 UEditor 最新版：[官网地址] 1.2创建demo文件解压下载的包，在解压后的目录创建 demo.html 文件，填入下面的html代码 123456789101112131415161718192021222324&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ueditor demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 加载编辑器的容器 --&gt; &lt;script id=\"container\" name=\"content\" type=\"text/plain\"&gt; 这里写你的初始化内容 &lt;/script&gt; &lt;!-- 配置文件 --&gt; &lt;script type=\"text/javascript\" src=\"ueditor.config.js\"&gt;&lt;/script&gt; &lt;!-- 编辑器源码文件 --&gt; &lt;script type=\"text/javascript\" src=\"ueditor.all.js\"&gt;&lt;/script&gt; &lt;!-- 实例化编辑器 --&gt; &lt;script type=\"text/javascript\"&gt; var ue = UE.getEditor('container'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.3 在浏览器打开demo.html如果看到了编辑器，恭喜你，初次部署成功！ 2. 整合jsp后端配置2.1 下载 jsp 版本完整包下载地址: http://ueditor.baidu.com/website/download.html 选择 [1.4.3.3 Jsp 版本] 2.2 下载之后会得到如下文件按照官网上的做法是把文件copy到webapp跟目录下 , 但我们是集成ueditor, 肯定不是放在根目录下, 所以我们把文件都复制到 webapp/static/plugins/ueditor 下, 方便管理 logo 2.3 前台代码集成2.3.1 在需要集成ueditor的页面添加如下代码, 如果能看到编辑器则说明配置成功12345678910111213141516171819202122232425&lt;!DOCTYPE HTML&gt;&lt;html lang=\"en-US\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;ueditor demo&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"$&#123;ctx&#125;static/plugins/ueditor/lang/zh-cn/zh-cn.js\" media=\"all\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 加载编辑器的容器 --&gt; &lt;script id=\"container\" name=\"content\" type=\"text/plain\"&gt; 这里写你的初始化内容 &lt;/script&gt; &lt;!-- 配置文件 --&gt; &lt;script type=\"text/javascript\" src=\"$&#123;ctx&#125;static/plugins/ueditor/ueditor.config.js\"&gt;&lt;/script&gt; &lt;!-- 编辑器源码文件 --&gt; &lt;script type=\"text/javascript\" src=\"$&#123;ctx&#125;static/plugins/ueditor/ueditor.all.js\"&gt;&lt;/script&gt; &lt;!-- 实例化编辑器 --&gt; &lt;script type=\"text/javascript\"&gt; var ueditor = UE.getEditor('container'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 获取编辑器内容123var ueditor = UE.getEditor('container');var content = ueditor.getContent(content); 设置编辑器内容12345// 等UEditor创建完成就使用UEditor的setContent函数var ueditor = UE.getEditor('container');ueditor.ready(function() &#123; ueditor.setContent(content);&#125;); 有了这些你可以处理一些普通文字, 但如果是要文件上传,图片上传,视频上传这些功能你就要进行一些后台代码的配置 2.4 后台代码集成后台环境： Spring + Spring Mvc + Mybatis + Maven 2.4.1 配置 ueditor.config.js原配置:1234567891011121314var URL = window.UEDITOR_HOME_URL || getUEBasePath();/** * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。 */window.UEDITOR_CONFIG = &#123; //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL // 服务器统一请求接口路径 , serverUrl: URL + \"jsp/controller.jsp\" //工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的重新定义 修改后的配置：1234567891011121314window.UEDITOR_HOME_URL = \"/static/plugins/ueditor/\";var URL = window.UEDITOR_HOME_URL || getUEBasePath();/** * 配置项主体。注意，此处所有涉及到路径的配置别遗漏URL变量。 */window.UEDITOR_CONFIG = &#123; //为编辑器实例添加一个路径，这个不能被注释 UEDITOR_HOME_URL: URL // 服务器统一请求接口路径 , serverUrl: \"/ueditor/ueditorAction\" 主要是 window.UEDITOR_HOME_URL 这个参数赋值成自己的ueditor的文件路径 修改 服务器统一请求接口路径 /ueditor/ueditorAction , 这样Ueditor后台服务接口就会请求到这个接口中来 2.4.2 新增后台服务接口第一步： 导入jar包, 我是只添加了最后俩个包，其他的包可以通过maven的形式导入，copy 这俩个包放到WEBINF/lib目录下, 然后配置Maven依赖 logo 注：使用maven构建项目的时候需要进行如下配置, 这样maven构建的时候才不会报找不到lib目录下jar包的错误1234567&lt;dependency&gt; &lt;groupId&gt;json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib/json.jar&lt;/systemPath&gt;&lt;/dependency&gt; 第二步：新建 后台统一服务接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * Ueditor 后台统一服务接口 * @author songshuiyang * @date 2018/3/4 18:11 */@Controller@RequestMapping(\"/ueditor\")public class UEditorController extends BaseController &#123; private HttpServletRequest request = null; private String actionType = null; private ConfigManager configManager = null; @RequestMapping(value = \"ueditorAction\", method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) @ResponseBody public JSONObject exec (@RequestParam String action, HttpServletRequest request) &#123; String result; this.actionType = action; this.request = request; String rootPath = request.getSession().getServletContext().getRealPath(\"/\"); String contextPath = request.getContextPath(); this.configManager = ConfigManager.getInstance( rootPath, contextPath,\"/static/plugins/ueditor/jsp/controller.jsp\"); String callbackName = this.request.getParameter(\"callback\"); if ( callbackName != null ) &#123; result = !validCallbackName( callbackName ) ? new BaseState( false, AppInfo.ILLEGAL ).toJSONString() : callbackName+\"(\"+this.invoke()+\");\"; &#125; else &#123; result = this.invoke(); &#125; return JSONObject.fromObject(result); &#125; public String invoke() &#123; if ( actionType == null || !ActionMap.mapping.containsKey( actionType ) ) &#123; return new BaseState( false, AppInfo.INVALID_ACTION ).toJSONString(); &#125; if ( this.configManager == null || !this.configManager.valid() ) &#123; return new BaseState( false, AppInfo.CONFIG_ERROR ).toJSONString(); &#125; State state = null; int actionCode = ActionMap.getType( this.actionType ); Map&lt;String, Object&gt; conf; switch ( actionCode ) &#123; case ActionMap.CONFIG: return this.configManager.getAllConfig().toString(); case ActionMap.UPLOAD_IMAGE: case ActionMap.UPLOAD_SCRAWL: case ActionMap.UPLOAD_VIDEO: case ActionMap.UPLOAD_FILE: conf = this.configManager.getConfig( actionCode ); state = new Uploader( request, conf ).doExec(); break; case ActionMap.CATCH_IMAGE: conf = configManager.getConfig( actionCode ); String[] list = this.request.getParameterValues( (String)conf.get( \"fieldName\" ) ); state = new ImageHunter( conf ).capture( list ); break; case ActionMap.LIST_IMAGE: case ActionMap.LIST_FILE: conf = configManager.getConfig( actionCode ); int start = this.getStartIndex(); state = new FileManager( conf ).listFile( start ); break; &#125; assert state != null; return state.toJSONString(); &#125; private int getStartIndex () &#123; String start = this.request.getParameter( \"start\" ); try &#123; return Integer.parseInt( start ); &#125; catch ( Exception e ) &#123; return 0; &#125; &#125; /** * callback参数验证 * @param name 名字 * @return boolean */ private boolean validCallbackName ( String name ) &#123; return name.matches( \"^[a-zA-Z_]+[\\\\w0-9_]*$\" ); &#125;&#125; 一： 初始化ueditor的时候, ueditor会访问该接口, 此时action 参数是 config , 该接口会返回其/static/plugins/ueditor/jsp/config.json 配置的json参数，这些参数配置了上传功能的一些参数, 通过这些配置你可以DIY上传功能, ueditor获取到这些参数之后就可以使用上传功能了,否则你上传文件会提示： 后端配置项没有正常加载，上传插件不能正常使用！ 配置主要包括： 上传图片配置项 涂鸦图片上传配置项 截图工具上传 抓取远程图片配置 上传视频配置 上传文件配置 二： 如要上传图片, ueditor会访问该接口, 此时action 参数是 uploadimage ，则会执行上传图片操作, 上传成功后会返回123456&#123; \"state\": \"SUCCESS\", \"url\": \"upload/demo.jpg\", \"title\": \"demo.jpg\", \"original\": \"demo.jpg\"&#125; 三：由于系统文件上传使用的是阿里云的OSS所以需要将文件上传转到OSS处理上 前台配置：1234567891011121314151617&lt;script type=\"text/javascript\"&gt; // 当action是如下时，访问自己定义的服务接口 UE.Editor.prototype._bkGetActionUrl=UE.Editor.prototype.getActionUrl; UE.Editor.prototype.getActionUrl=function(action)&#123; // 上传图片, 文件, 视频 if (action == 'uploadimage' || action == 'uploadfile' || action == 'uploadvideo') &#123; return '/file/uploadLocal'; &#125; else if( action== 'uploadscrawl')&#123; // 上传涂鸦，涂鸦请求是Base64字符需要请求另外的接口 return '/file/uploadScrawl'; &#125; else if(action == 'listimage')&#123; return this._bkGetActionUrl.call(this, action); &#125; else&#123; return this._bkGetActionUrl.call(this, action); &#125; &#125; var ueditor = UE.getEditor('ueditorContainer');&lt;/script&gt; 后台接口：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.ecut.admin.controller;import com.aliyun.oss.ClientException;import com.aliyun.oss.OSSException;import com.ecut.admin.entity.OssFile;import com.ecut.admin.entity.UeditorState;import com.ecut.admin.service.impl.FileServiceImpl;import com.ecut.core.base.BaseController;import com.ecut.core.utils.Base64Utils;import com.ecut.core.utils.MessageUtils;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartHttpServletRequest;import java.io.ByteArrayInputStream;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import static com.ecut.core.utils.MessageUtils.success;/** * 阿里云OSS文件上传控制器 * @author songshuiyang * @date 2018/2/11 20:22 */@Controller@RequestMapping(\"/file\")public class FileController extends BaseController &#123; private final Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private FileServiceImpl fileServiceImpl; /** * 文件上传 * produces=\"application/json;charset=UTF-8 解决服务器返回406问题 * @param file * @return * @throws OSSException * @throws ClientException * @throws IOException */ @RequestMapping(value = \"/uploadLocal\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\") @ResponseBody public UeditorState uploadLocalFile(@RequestParam(value = \"upfile\",required = false) MultipartFile file) throws OSSException, ClientException, IOException &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(); OssFile file1 = fileServiceImpl.uploadFileByMultipartFile(file); UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName()); return ueditorState; &#125; /** * 上传涂鸦照片 * @param upfile * @return * @throws Exception */ @RequestMapping(value = \"/uploadScrawl\", method = RequestMethod.POST, produces=\"application/json;charset=UTF-8\") @ResponseBody public UeditorState uploadscrawl(String upfile) throws Exception &#123; byte [] bytes= Base64Utils.decode(upfile); InputStream inputStream = new ByteArrayInputStream(bytes); String fileType = \"image/png\"; Long fileSize = new Long((long)bytes.length); String fileName = \"scrawl\" + System.currentTimeMillis() + \".png\"; String extensionName = \"png\"; OssFile file1 = fileServiceImpl.uploadFileByInputStream(inputStream, fileType,fileSize,fileName,extensionName); UeditorState ueditorState = new UeditorState(\"SUCCESS\",file1.getFileSrc(),file1.getFileName(),file1.getFileName()); return ueditorState; &#125;&#125; 2.4.3 问题集合解决百度ueditor富文本编辑器不能插入视频的问题/src掉链/src清空，不能显示视频转载：http://blog.csdn.net/qq_34787830/article/details/75092347 直接下载到的百度富文本编辑器当插入视频的时候会自动清掉src，不显示视频造成这样的原因是:百度富文本编辑器的过滤器xssFilter导致插入视频异常，编辑器在切换源码的过程中过滤掉img的_url属性（用来存储视频url） 解决办法: 1.在配置文件ueditor.config.js中，定位 //xss过滤白名单，即,whitList:{ }，对 img: 增加 “_url” 属性： 在下面的 video 标签后面新增3给标签，使Ueditor分别能支持embed标签和iframe标签：1234567source: ['src', 'type'],embed: ['type', 'class', 'pluginspage', 'src', 'width', 'height', 'align', 'style', 'wmode', 'play', + 'autoplay','loop', 'menu', 'allowscriptaccess', 'allowfullscreen', 'controls', 'preload'],iframe: ['src', 'class', 'height', 'width', 'max-width', 'max-height', 'align', 'frameborder', 'allowfullscreen']","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"基于wordspress搭建个人博客系统","slug":"backend/相关技术/基于wordspress搭建个人博客系统","date":"2018-03-04T12:54:12.000Z","updated":"2018-03-04T08:10:13.375Z","comments":true,"path":"2018/03/04/backend/相关技术/基于wordspress搭建个人博客系统/","link":"","permalink":"http://www.songshuiyang.site/2018/03/04/backend/相关技术/基于wordspress搭建个人博客系统/","excerpt":"什么是Wordspress：官网： https://cn.wordpress.org/ 提供了中英版 WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。 WordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。 WordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的标准通用标记语言下的一个应用HTML代码、CSS、PHP等相关知识。 WordPress官方支持中文版，同时有爱好者开发的第三方中文语言包，如wopus中文语言包。WordPress拥有成千上万个各式插件和不计其数的主题模板样式。","text":"什么是Wordspress：官网： https://cn.wordpress.org/ 提供了中英版 WordPress是使用PHP语言开发的博客平台，用户可以在支持PHP和MySQL数据库的服务器上架设属于自己的网站。也可以把 WordPress当作一个内容管理系统（CMS）来使用。 WordPress是一款个人博客系统，并逐步演化成一款内容管理系统软件，它是使用PHP语言和MySQL数据库开发的。用户可以在支持 PHP 和 MySQL数据库的服务器上使用自己的博客。 WordPress有许多第三方开发的免费模板，安装方式简单易用。不过要做一个自己的模板，则需要你有一定的专业知识。比如你至少要懂的标准通用标记语言下的一个应用HTML代码、CSS、PHP等相关知识。 WordPress官方支持中文版，同时有爱好者开发的第三方中文语言包，如wopus中文语言包。WordPress拥有成千上万个各式插件和不计其数的主题模板样式。 搭建教程：参考下面的帖子写的十分详细 https://www.jianshu.com/p/56750622cac9 LNMP一键安装包LNMP一键安装包是一个用Linux Shell编写的可以为CentOS/RHEL/Fedora/Aliyun/Amazon、Debian/Ubuntu/Raspbian/Deepin/Mint Linux VPS或独立主机安装LNMP(Nginx/MySQL/PHP)、LNMPA(Nginx/MySQL/PHP/Apache)、LAMP(Apache/MySQL/PHP)生产环境的Shell程序。https://lnmp.org/","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Mysql 数据类型","slug":"backend/数据库/Mysql 数据类型","date":"2018-03-03T03:15:12.000Z","updated":"2018-12-06T12:28:47.873Z","comments":true,"path":"2018/03/03/backend/数据库/Mysql 数据类型/","link":"","permalink":"http://www.songshuiyang.site/2018/03/03/backend/数据库/Mysql 数据类型/","excerpt":"MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。","text":"MySQL中定义数据字段的类型对你数据库的优化是非常重要的。 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。 数值类型MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。 BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。 作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。 logo 备注:1.BIT[M] 位字段类型，M表示每个值的位数，范围从1到64，如果M被忽略，默认为1 2.TINYINT[(M)] [UNSIGNED] [ZEROFILL] M默认为4,占1个字节 很小的整数。带符号的范围是-128到127。无符号的范围是0到255。 BOOL，BOOLEAN 是TINYINT(1)的同义词。zero值被视为假。非zero值视为真。 4.SMALLINT[(M)] [UNSIGNED] [ZEROFILL] M默认为6,占2个字节 小的整数。带符号的范围是-32768到32767。无符号的范围是0到65535。 5.MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] M默认为9,占3个字节 中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。 INT[(M)] [UNSIGNED] [ZEROFILL] M默认为11,占4个字节 普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。 7.BIGINT[(M)] [UNSIGNED] [ZEROFILL] M默认为20,占8个字节 大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。 注意：这里的M代表的并不是存储在数据库中的具体的长度，以前总是会误以为int(3)只能存储3个长度的数字，int(11)就会存储11个长度的数字，这是大错特错的。 tinyint(1) 和 tinyint(4) 中的1和4并不表示存储长度，只有字段指定zerofill是有用，如tinyint(4)，如果实际值是2，如果列指定了zerofill，查询结果就是0002，左边用0来填充。 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。 TIMESTAMP类型有专有的自动更新特性 logo 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型 logo","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"db","slug":"db","permalink":"http://www.songshuiyang.site/tags/db/"}]},{"title":"animate.css","slug":"frontend/animate","date":"2018-03-03T02:52:12.000Z","updated":"2018-03-20T15:06:43.836Z","comments":true,"path":"2018/03/03/frontend/animate/","link":"","permalink":"http://www.songshuiyang.site/2018/03/03/frontend/animate/","excerpt":"","text":"一 前言:背景：在看其他人的项目的时候发现其动画效果做的不错，通过看人家的代码发现用了这个animate.css这个css组件，使用起来也是特别的方便，所以就把他copy到项目中来了，顿时档次就上升了 简介:animate.css 是一个来自国外的 CSS3 动画库，它预设了抖动（shake）、闪烁（flash）、弹跳（bounce）、翻转（flip）、旋转（rotateIn/rotateOut）、淡入淡出（fadeIn/fadeOut）等多达 60 多种动画效果，几乎包含了所有常见的动画效果。而且使用起来也是特别方便 官网传送门: https://daneden.github.io/animate.css/ 在官网上有示例动画，主页也十分简洁，同时也提供了代码下载, 也可以看看这篇博客写的例子 https://www.cnblogs.com/xiaohuochai/p/7372665.html 二 如何使用：步骤： 在官网上下载 animate.css , 把他导入到项目中来, 也可以使用cdn https://unpkg.com/animate.css@3.5.2/animate.min.css 代码示例 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/animate.css@3.5.2/animate.min.css\"&gt; &lt;style&gt; .box&#123;height: 100px;width: 100px;background-color: lightblue&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"box animated flash\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 只要在元素中class 添加 animated 和相应的动画class名就可以实现动画效果, 当然也可以通过js动态设置class","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.songshuiyang.site/tags/css/"}]},{"title":"Spring mvc 前后台传值中文乱码问题","slug":"backend/spring/spring-mvc/Spring mvc 中文乱码问题","date":"2018-02-28T13:49:44.000Z","updated":"2018-02-28T13:57:02.600Z","comments":true,"path":"2018/02/28/backend/spring/spring-mvc/Spring mvc 中文乱码问题/","link":"","permalink":"http://www.songshuiyang.site/2018/02/28/backend/spring/spring-mvc/Spring mvc 中文乱码问题/","excerpt":"一： 解决GET请求参数到了后台中文乱码问题 方式一: 修改tomcat配置, 暂时做法，没有找到更好的解决办法，换了tomcat了又要重新配置123把tomcat下，server.xml下，添加如下配置，就解决了． &lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 方式二: 自定义filter, 解决了get请求中文参数问题，但post请求参数到了后台就gg了","text":"一： 解决GET请求参数到了后台中文乱码问题 方式一: 修改tomcat配置, 暂时做法，没有找到更好的解决办法，换了tomcat了又要重新配置123把tomcat下，server.xml下，添加如下配置，就解决了． &lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"UTF-8\"/&gt; 方式二: 自定义filter, 解决了get请求中文参数问题，但post请求参数到了后台就gg了 新建 CustomEncodingFilter.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.ecut.core.web.filter;import org.springframework.cglib.proxy.InvocationHandler;import org.springframework.cglib.proxy.Proxy;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.lang.reflect.Method;public class CustomEncodingFilter extends OncePerRequestFilter &#123; private String encoding; public void setEncoding(String encoding) &#123; this.encoding = encoding; &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; // 设置请求响应字符编码 request.setCharacterEncoding(encoding); response.setCharacterEncoding(encoding); // 传递给目标servlet或jsp的实际上是动态代理的对象，而不是原始的HttpServletRequest对象 request = (HttpServletRequest) Proxy.newProxyInstance(request.getClass().getClassLoader(), request.getClass().getInterfaces(), new MyInvacationHandler(request)); chain.doFilter(request, response); &#125; class MyInvacationHandler implements InvocationHandler &#123; private HttpServletRequest request; MyInvacationHandler(HttpServletRequest request)&#123; this.request=request; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; switch (method.getName()) &#123; case \"getParameter\": String value = request.getParameter((String)args[0]); try &#123; if(value != null)&#123; value=new String(value.getBytes(\"ISO-8859-1\"),encoding); &#125; &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return value; case \"getParameterValues\": String[] values = request.getParameterValues((String)args[0]); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; values[i] = new String(values[i].getBytes(\"ISO-8859-1\"),encoding); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return values; default: return method.invoke(request, args); &#125; &#125; &#125;&#125; 配置web.xml 1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.ecut.core.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 二： 解决POST请求参数到了后台中文乱码问题1234567891011121314151617&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"阿里巴巴Java编程规范","slug":"backend/编程规范/阿里巴巴Java编程规范","date":"2018-02-13T01:54:12.000Z","updated":"2018-02-26T12:34:49.085Z","comments":true,"path":"2018/02/13/backend/编程规范/阿里巴巴Java编程规范/","link":"","permalink":"http://www.songshuiyang.site/2018/02/13/backend/编程规范/阿里巴巴Java编程规范/","excerpt":"前言：关于《阿里巴巴Java开发手册》 你是否曾因Java代码规范版本纷杂而无所适从？ 你是否想过代码规范能将系统故障率降低20%？ 你是否曾因团队代码风格迥异而协同困难？ 你是否正在review一些原本可以避免的故障？ 你是否无法确定自己的代码足够健壮？","text":"前言：关于《阿里巴巴Java开发手册》 你是否曾因Java代码规范版本纷杂而无所适从？ 你是否想过代码规范能将系统故障率降低20%？ 你是否曾因团队代码风格迥异而协同困难？ 你是否正在review一些原本可以避免的故障？ 你是否无法确定自己的代码足够健壮？ 码出高效，码出质量！相比C++代码规范业界已经达成共识，Java代码规范业界比较混乱，我们期待这次发布的Java代码规范能够给业界带来一个标准，促使整体行业代码规范水平得到提高，最终能够帮助企业和开发者提升代码质量和降低代码故障率。 阿里出品，质量保证！阿里Java技术团队一手打造出Dubbo、JStorm、Fastjson等诸多流行开源框架，部分已成为Apache基金会孵化项目； 阿里在Java后端领域支撑起全球访问量最大的服务器集群； Java代码构建的阿里双11业务系统订单处理能力达到17.5万笔/秒； 到目前已累计数亿行高并发、高稳定性的最佳Java代码实践； …… 此次公开的Java开发手册正是出自这样的团队，近万名阿里Java技术精英的经验总结，并经历了多次大规模一线实战检验及完善，铸就了这本高含金量的阿里Java开发手册。该手册以Java开发者为中心视角，划分为编程规约、异常日志规约、MYSQL规约、工程规约、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱和故障敏感性，规约依次分为强制、推荐、参考三大类。此套规范不仅能让代码一目了然， 更有助于加强团队分工与合作、真正提升效率。 无规矩不成方圆 无规范不能协作众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，没有规定靠右行驶，谁还敢上路行驶。 同理，对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的方式一起做事，降低故障率，提升协作效率。开发手册详细列举如何开发更加高效，更加容错，更加有协作性，力求知其然，更知其不然，结合正反例，提高代码质量。比如，异常日志处理时的各种不规范行为；集合转换的各种坑；创建线程池出现的等待队列OOM等。 阿里技术资深大咖联袂推荐阿里高级研究员多隆：工程师对于代码，一定要“精益求精”，不论从性能，还是简洁优雅，都要具备“精益求精”的工匠精神，认真打磨自己的作品。 阿里研究员毕玄：一个优秀的工程师和一个普通工程师的区别，不是现在满天飞的架构图，他的功底就是体现在他写的每一行代码上。 阿里研究员玄难：代码是软件工程里面的产品设计、系统架构设计等工作的最后承载体，代码的质量决定了一切工作的成败。 阿里巴巴B2B事业群CTO李纯：好的软件产品离不开工程师高质量的代码及相互间顺畅的沟通与合作。简单，适用的代码规约背后所传递的是技术上的追求卓越、协同合作的精神，是每个技术团队不可缺失的重要利器。 阿里研究员、HipHop作者：赵海平（花名：福贝）：程序员是创造个性化作品的艺术家，但同时也是需要团队合作的工种。个性化应尽量表现在代码效率和算法方面，牺牲小我，成就大我。 拥抱规范，远离伤害！开发的同学们赶紧行动起来，遵守代码规范，你好，我好，大家好！ 传送门 原文: https://yq.aliyun.com/articles/69327?spm=5176.100239.blogcont69327.158.xUUgiz&amp;p=2#comments 「阿里巴巴编码规范」考试认证 : https://edu.aliyun.com/certification/cldt02 点击下载《阿里巴巴Java开发手册》(纪念版): https://yq.aliyun.com/attachment/download/?id=4942 IDE插件下载 : https://github.com/alibaba/p3c 以下记录以下自己需要注意的一些规范, 遵守代码规范，你好，我好，大家好！编程规约命名风格 【强制】 抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT 反例： MAX_COUNT 【强制】 POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 反例： 定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted()， RPC 框架在反向解析的时候， “以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异 常。 【强制】杜绝完全不规范的缩写， 避免望文不知义。 反例： AbstractClass“缩写” 命名成 AbsClass； condition“缩写” 命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。 正例： 从远程仓库拉取代码的类命名为 PullCodeFromRemoteRepository。 反例： 变量 int a; 的随意命名方式。 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加） ，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 正例： 接口方法签名： void f(); 接口基础常量表示： String COMPANY = “alibaba”; 反例： 接口方法定义： public abstract void f(); 说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。 正例： 枚举名字为 ProcessStatusEnum 的成员名称： SUCCESS / UNKOWN_REASON。 【参考】各层命名规约： A) Service/DAO 层方法命名规约 1） 获取单个对象的方法用 get 做前缀。 2） 获取多个对象的方法用 list 做前缀。 3） 获取统计值的方法用 count 做前缀。 4） 插入的方法用 save/insert 做前缀。 5） 删除的方法用 remove/delete 做前缀。 6） 修改的方法用 update 做前缀。 B) 领域模型命名规约 1） 数据对象： xxxDO， xxx 即为数据表名。 2） 数据传输对象： xxxDTO， xxx 为业务领域相关的名称。 3） 展示对象： xxxVO， xxx 一般为网页名称。 4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 常量定义 【强制】不允许任何魔法值（即未经定义的常量） 直接出现在代码中。 反例： String key = “Id#taobao_” + tradeId; cache.put(key, value); 【推荐】不要使用一个常量类维护所有常量， 按常量功能进行归类，分开维护。 说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 正例： 缓存相关常量放在类 CacheConsts 下； 系统配置相关常量放在类 ConfigConsts 下。 代码格式1.示例 123456789101112131415161718public static void main(String[] args) &#123; // 缩进 4 个空格 String say = \"hello\"; // 运算符的左右必须有一个空格 int flag = 0;阿里巴巴 Java 开发手册 // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号， 0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) &#123; System.out.println(\"world\"); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(\"ok\"); // 在右大括号后直接结束，则必须换行 &#125;&#125; 2.【强制】 注释的双斜线与注释内容之间有且仅有一个空格。 正例： // 注释内容， 注意在//和注释内容之间有一个空格。 3.【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则： 1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。 2） 运算符与下文一起换行。 3） 方法调用的点符号与下文一起换行。 4） 方法调用时，多个参数， 需要换行时， 在逗号后进行。 5） 在括号前不要换行，见反例。 正例：123456StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，换行缩进 4 个空格， 点号和方法名称一起换行sb.append(\"zi\").append(\"xin\")... .append(\"huang\")... .append(\"huang\")... .append(\"huang\"); 反例： 1234567StringBuffer sb = new StringBuffer();// 超过 120 个字符的情况下，不要在括号前换行sb.append(\"zi\").append(\"xin\")...append (\"huang\");// 参数很多的方法调用可能超过 120 个字符， 不要在逗号前换行method(args1, args2, args3, ... , argsX); 4.【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例： 下例中实参的”a”,后边必须要有一个空格。 method(“a”, “b”, “c”);5.【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义 之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。 说明： 没有必要插入多个空行进行隔开 注释规范 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*内容/格式，不得使用// xxx 方式。 说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率 【强制】所有的抽象方法（包括接口中的方法） 必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明： 对子类的实现要求，或者调用注意事项，请一并说明 【强制】所有的类都必须添加创建者和创建日期。 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1） 待办事宜（TODO） :（标记人，标记时间， [预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签） 。2） 错误，不能工作（FIXME） :（标记人，标记时间， [预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 异常处理 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】有 try 块放到了事务代码中， catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 MySQL 数据库 建表规约1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是， 0 表示否） 。 说明： 任何字段如果为非负数，必须是 unsigned。 正例： 表达逻辑删除的字段名 is_deleted， 1 表示删除， 0 表示未删除 2.【强制】 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。3.【强制】表必备三字段： id, gmt_create, gmt_modified。 说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。 gmt_create,gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被 动更新4.【推荐】表的命名最好是加上“业务名称表的作用”。 正例： alipay_task / force_project / trade_config5.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 说明： 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明 显的； 另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必 然有脏数据产生6.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致； 多表关联查询时， 保证被关联的字段需要有索引。 说明： 即使双表 join 也要注意表索引、 SQL 性能 MySQL 数据库 SQL语句 【强制】不要使用 count(列名)或 count(常量)来替代 count()， count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"解决CSS和JS文件的客户端缓存问题","slug":"frontend/CSS和JS文件的客户端缓存问题","date":"2018-02-10T03:48:12.000Z","updated":"2018-02-26T12:31:58.890Z","comments":true,"path":"2018/02/10/frontend/CSS和JS文件的客户端缓存问题/","link":"","permalink":"http://www.songshuiyang.site/2018/02/10/frontend/CSS和JS文件的客户端缓存问题/","excerpt":"","text":"场景做项目的时候，发现自己修改了一个css文件但样式并没有应用，查看http请求(如下图)，注意这个参数Status Code:200 OK (from disk cache) , 说明文件是是之前浏览器缓存的文件，浏览器并没有请求我们新改的文件1234Request URL:http://localhost:8080/static/layui/build/css/app.cssRequest Method:GETStatus Code:200 OK (from disk cache)Remote Address:127.0.0.1:8080Referrer Policy:no-referrer-when-downgrade 解决方法 发现问题了，现在就是要解决如果是服务器js css等文件修改了，怎样让浏览器能够请求我们最新的文件, 通过查看其他人的解决方法，还有看了一下大厂百度, 淘宝 , 新浪 对这个问题的处理，总结了一下下面几种方法: 方法一: 在css文件上, js文件后面加上版本号?v=12453651&lt;link rel=\"stylesheet\" href=\"$&#123;ctx&#125;static/admin/css/main.css?v=1245365\" media=\"all\" /&gt; 如果是经常更新的css文件版本号可以取当前时间的时间戳 v=1518237859338 ,这样就可以每次都获取到最新的文件，但缺点就是每次刷新页面都会请求该文件，在项目开发过程中可以使用这种方式 如果是更新频率不高的的文件，可以取: v=20180210 , 这样的话刷新页面就不会每次请求这个文件了，可以减轻服务器的压力 如果是项目稳定了基本没有改动了，可以取一个固定值:v=0.0.1 方法二：一个版本一个文件夹 淘宝的做法: 用一个文件 6.2.31https://g.alicdn.com/kg/??component/6.2.3/extension/content-box/xtpl/view.xtpl-min.js","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.songshuiyang.site/tags/css/"},{"name":"js","slug":"js","permalink":"http://www.songshuiyang.site/tags/js/"}]},{"title":"生成二维码图片(base64格式)","slug":"backend/相关技术/生成二维码图片(base64格式)","date":"2018-01-29T13:00:12.000Z","updated":"2018-02-26T12:31:59.906Z","comments":true,"path":"2018/01/29/backend/相关技术/生成二维码图片(base64格式)/","link":"","permalink":"http://www.songshuiyang.site/2018/01/29/backend/相关技术/生成二维码图片(base64格式)/","excerpt":"生成二维码图片(base64格式)","text":"生成二维码图片(base64格式) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.guangeryi.mall.payment.weixin;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.client.j2se.MatrixToImageWriter;import com.google.zxing.common.BitMatrix;import org.apache.commons.codec.binary.Base64;import javax.imageio.ImageIO;import java.awt.image.BufferedImage;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.Hashtable;import java.util.Map;public class QRCodeUtils &#123; /** * 生成二维码 Base64编码后字符串 * * @param contents 内容 */ public static String encodeQRCodeBase64(String contents) &#123; return encodeQRCodeToBase64Str(contents); &#125; /** * 生成二维码 Base64编码后字符串 &lt;img src=''&gt; src填入该字符串显示图片 * （高度:300 , 宽度:300） * @param contents 内容 */ private static String encodeQRCodeToBase64Str(String contents) &#123; int width = WxPcPayConfigImpl.QR_IMG_WIDTH; int height = WxPcPayConfigImpl.QR_IMG_HEIGHT; Map&lt;EncodeHintType, Object&gt; hints = new Hashtable&lt;&gt;(); String base64Img = \"data:image/png;base64,\"; // 指定编码格式 hints.put(EncodeHintType.CHARACTER_SET, \"UTF-8\"); try &#123; // 生成输出流 BitMatrix bitMatrix1 = new MultiFormatWriter().encode(contents, BarcodeFormat.QR_CODE, width, height, hints); BufferedImage image = MatrixToImageWriter.toBufferedImage(bitMatrix1); base64Img = base64Img + encodeToString(\"png\", image); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return base64Img; &#125; /** * 将图片转换成base64格式进行存储 * * @param formatName 文件格式 * @param image 图片流 * @return base64字符串 */ private static String encodeToString(String formatName, BufferedImage image) &#123; String imageString = null; try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) &#123; ImageIO.write(image, formatName, bos); byte[] imageBytes = bos.toByteArray(); imageString = new String(Base64.encodeBase64(imageBytes)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return imageString; &#125; public static void main(String[] args) &#123; // 输出在img标签中img属性中 System.out.println(encodeQRCodeBase64(\"你好\")); &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"根据手机区号获取城市地理位置","slug":"backend/相关技术/根据手机区号获取城市地理位置","date":"2018-01-29T12:55:12.000Z","updated":"2018-02-26T12:31:59.863Z","comments":true,"path":"2018/01/29/backend/相关技术/根据手机区号获取城市地理位置/","link":"","permalink":"http://www.songshuiyang.site/2018/01/29/backend/相关技术/根据手机区号获取城市地理位置/","excerpt":"根据手机区号获取城市地理位置httpAPI: http://www.ip138.com:8080/search.asp?action=mobile&amp;mobile=%s","text":"根据手机区号获取城市地理位置httpAPI: http://www.ip138.com:8080/search.asp?action=mobile&amp;mobile=%s 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.guangeryi.mall.third.common;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.select.Elements;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.HashMap;import java.util.Map;public class MobileLocationUtils &#123; private final static Logger logger = LoggerFactory.getLogger(MobileLocationUtils.class); /** * 根据手机号获取所在地信息 * @param mobile 手机号码 * @return 返回map */ public static Map&lt;String,Object&gt; getMobileAddress (String mobile) &#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); String returnStr= getMobileAddressUtils(mobile); // 将160号的空格转化成32号的空格 returnStr = returnStr.replaceAll(\"[\\\\u00A0]+\", \" \"); // 去空格 returnStr = returnStr.trim(); String [] address = returnStr.split(\"\\\\s+\"); String province = \"\";// 省 String city = \"\"; // 市 // 直辖市 if (address.length == 1) &#123; province = address[0]; city = address[0]; &#125; if (address.length == 2) &#123; province = address[0]; city = address[1]; &#125; map.put(\"province\", province); map.put(\"city\", city); logger.info(mobile + \" 手机号所在信息:\" + map); return map; &#125; public static String getMobileAddressUtils(String mobile)&#123; try &#123; String url = \"http://www.ip138.com:8080/search.asp?action=mobile&amp;mobile=%s\"; url = String.format(url, mobile); Document doc = Jsoup.connect(url).get(); Elements els = doc.getElementsByClass(\"tdc2\"); if(els.get(1).text().equals(\"mobile 不是数字! 验证手机号有误\") || els.get(1).text().equals(\"验证手机号有误\")) &#123; return \"未知\"; &#125; return els.get(1).text(); &#125; catch (Exception e) &#123; return \"未知\"; &#125; &#125; public static void main(String[] args) &#123; System.out.println(getMobileAddress(\"13117975845\")); &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"根据IP获取城市地理位置","slug":"backend/相关技术/根据IP获取城市地理位置","date":"2018-01-29T12:54:12.000Z","updated":"2018-02-26T12:31:59.833Z","comments":true,"path":"2018/01/29/backend/相关技术/根据IP获取城市地理位置/","link":"","permalink":"http://www.songshuiyang.site/2018/01/29/backend/相关技术/根据IP获取城市地理位置/","excerpt":"根据IP获取城市地理位置使用的是百度查询的api，试过到淘宝的API, 但是淘宝做了访问次数限制，如果批量查询的话直接timeout","text":"根据IP获取城市地理位置使用的是百度查询的api，试过到淘宝的API, 但是淘宝做了访问次数限制，如果批量查询的话直接timeout 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168package com.guangeryi.mall.third.common;import net.sf.json.JSONObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.*;import java.net.URL;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Map;/** * 根据IP获取城市地理位置 * 调用百度api：http://api.map.baidu.com/location/ip */public class IpUtils &#123; private final static Logger logger = LoggerFactory.getLogger(AddressUtils.class); /** * 根据ip获取城市信息 * @param ip * @return */ public static Map&lt;String, Object&gt; getCityInfoByIp(String ip)&#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(\"status\",\"success\"); String jsonInfo = null; try &#123; jsonInfo = getCityInfoByUrlAPI(ip); logger.info(\"jsonInfo:\" + jsonInfo); &#125; catch (IOException e) &#123; logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常, ip:\" + ip, e); result.put(\"status\",\"failed\"); return result; &#125; String province = \"\"; String city = \"\"; String district =\"\"; String street = \"\"; try &#123; JSONObject jsonObject = JSONObject.fromObject(jsonInfo); if (jsonObject != null) &#123; if (jsonObject.getJSONObject(\"content\") != null) &#123; JSONObject addressDetail = jsonObject.getJSONObject(\"content\").getJSONObject(\"address_detail\"); province = (String)addressDetail.get(\"province\"); // 省 city = (String)addressDetail.get(\"city\"); // 市 district = (String)addressDetail.get(\"district\"); // 区 street = (String)addressDetail.get(\"street\"); // 街道 &#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"调用 api.map.baidu.com/location/ip 获取城市信息异常,解析JSON异常 ip:\" + ip, e); result.put(\"status\",\"failed\"); return result; &#125; result.put(\"province\",province); result.put(\"city\",city); result.put(\"district\",district); result.put(\"street\",street); return result; &#125; /** * 调用 api.map.baidu.com/location/ip 获取城市信息 * @param ip * @return * @throws IOException */ private static String getCityInfoByUrlAPI(String ip) throws IOException &#123; String url = \"http://api.map.baidu.com/location/ip?ak=F454f8a5efe5e577997931cc01de3974&amp;ip=\" + ip; try (InputStream is = new URL(url).openStream()) &#123; BufferedReader rd = new BufferedReader(new InputStreamReader(is, Charset.forName(\"UTF-8\"))); String jsonText = getStrByReader(rd); jsonText = decodeUnicode(jsonText); return jsonText; &#125; &#125; /** * 获取流数据 * @param rd * @return * @throws IOException */ private static String getStrByReader(Reader rd) throws IOException &#123; StringBuilder sb = new StringBuilder(); int cp; while ((cp = rd.read()) != -1) &#123; sb.append((char) cp); &#125; return sb.toString(); &#125; /** * unicode 转换成 中文 * * @author fanhui 2007-3-15 * @param theString 字符串 * @return String */ private static String decodeUnicode(String theString) &#123; char aChar; int len = theString.length(); StringBuilder outBuilder = new StringBuilder(len); for (int x = 0; x &lt; len;) &#123; aChar = theString.charAt(x++); if (aChar == '\\\\') &#123; aChar = theString.charAt(x++); if (aChar == 'u') &#123; int value = 0; for (int i = 0; i &lt; 4; i++) &#123; aChar = theString.charAt(x++); switch (aChar) &#123; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': value = (value &lt;&lt; 4) + aChar - '0'; break; case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': value = (value &lt;&lt; 4) + 10 + aChar - 'a'; break; case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': value = (value &lt;&lt; 4) + 10 + aChar - 'A'; break; default: throw new IllegalArgumentException(\"Malformed encoding.\"); &#125; &#125; outBuilder.append((char) value); &#125; else &#123; if (aChar == 't') &#123; aChar = '\\t'; &#125; else if (aChar == 'r') &#123; aChar = '\\r'; &#125; else if (aChar == 'n') &#123; aChar = '\\n'; &#125; else if (aChar == 'f') &#123; aChar = '\\f'; &#125; outBuilder.append(aChar); &#125; &#125; else &#123; outBuilder.append(aChar); &#125; &#125; return outBuilder.toString(); &#125; public static void main(String[] args) &#123; System.out.println(getCityInfoByIp(\"118.212.211.23\")); &#125;&#125; 获取用户真实IP地址123456789101112131415161718192021222324252627282930313233343536/** * 获取用户真实IP地址，不使用request.getRemoteAddr()的原因是有可能用户使用了代理软件方式避免真实IP地址, * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值 */public static String getRemoteIp(HttpServletRequest request) &#123; String ip = request.getHeader(\"x-forwarded-for\"); if (ip != null &amp;&amp; ip.length() != 0 &amp;&amp; !\"unknown\".equalsIgnoreCase(ip)) &#123; // 多次反向代理后会有多个ip值，第一个ip才是真实ip if(ip.contains(\",\"))&#123; ip = ip.split(\",\")[0]; &#125; &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"Proxy-Client-IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"WL-Proxy-Client-IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"HTTP_CLIENT_IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"HTTP_X_FORWARDED_FOR\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getHeader(\"X-Real-IP\"); &#125; if (ip == null || ip.length() == 0 || \"unknown\".equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; // TODO 本地测试使用 if (!isIpv4(ip)) &#123; ip= \"120.27.129.177\"; // 服务器ip &#125; return ip;&#125; 校验IP地址12345678910111213141516/** * 校验IP地址 * @param ipAddress IP 地址 * @return true or false */public static boolean isIpv4(String ipAddress) &#123; String ip = \"^(1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|[1-9])\\\\.\" +\"(00?\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\" +\"(00?\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)\\\\.\" +\"(00?\\\\d|1\\\\d&#123;2&#125;|2[0-4]\\\\d|25[0-5]|[1-9]\\\\d|\\\\d)$\"; Pattern pattern = Pattern.compile(ip); Matcher matcher = pattern.matcher(ipAddress); return matcher.matches();&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"阿里云服务器搭建Javaweb运行环境","slug":"backend/JavaEE服务器/阿里云服务器搭建Javaweb运行环境","date":"2018-01-20T07:07:12.000Z","updated":"2018-06-11T14:40:59.044Z","comments":true,"path":"2018/01/20/backend/JavaEE服务器/阿里云服务器搭建Javaweb运行环境/","link":"","permalink":"http://www.songshuiyang.site/2018/01/20/backend/JavaEE服务器/阿里云服务器搭建Javaweb运行环境/","excerpt":"","text":"一：前言借助阿里云的云翼计划的梯子买了个 阿里的ESC云服务器，学生专享优惠10块钱/月，原价一百多一个月，超级划算，当然服务器配置对于我们这些学生捣鼓捣鼓还是满足的。 配置： 配置 参数 CPU Intel Xeon E5-2682 v4 1核 内存 2G 最新一代DDR4 内存 带宽 1M带宽 VPC专有网络, I/O 优化 系统盘 40G系统盘高效云盘 系统：CentOS 7.3 64位(可选ubuntu, windows service) ESC: 云服务器 ECS（Elastic Compute Service）是一种弹性可伸缩的计算服务，助您降低 IT 成本，提升运维效率，使您更专注于核心业务创新 二：搭建步骤2.1 购买 ESC云服务器购买链接:https://www.aliyun.com/product/ecs?spm=5176.8499797.765261.239.9Uf4pK, 当然如果是学生的话可以使用上面的云翼计划(https://promotion.aliyun.com/ntms/campus2017.html?spm=5176.8789780.765430.4.246c0fa5bHX2oK)优惠的方式购买，当时购买还送了(CDN流量包)和(OSS资源包) , 良心企业!!! 2.2 查看系统参数，及配置参数下单完成之后在 控制台-&gt; 云服务器 ECS -&gt; 实例 可看到系统自动为我们创建的 服务器实例, 里面提供了一些系统参数，还展示了系统的一些运行状态参数。 我们需要的参数 1.公网ip 访问实例需要用 2.远程连接密码 这个在第一次使用浏览器远程连接主机的时候，阿里云会提供，记住只出现一次，可以用笔记本记录下来，以后每次用浏览器远程控制访问主机的时候需要提供 3.登入系统的密码 在实例信息面板中有一个重置密码的功能，第一次需要自己设置，这个是主机系统的登入密码。 一开始用浏览器远程连接主机的时候，进入到了命令行界面, 要求输入密码的时候一直输入的是远程连接密码，导致一直登不进，查了一下资料发现系统登入密码需要自己创建, 登入用户 root 4.安全组配置 安全组配置是阿里云在系统做了一次网关过滤，外网访问主机，主机访问外网都需要配置这个参数，否则访问不到, 安全组配置分为入口和出口 入口配置: 把一些常用端口打开:80 22(ssh, sftp) 23(telnet) , 使用xshell和ftp都是使用的是22端口 添加 全部 ICMP 协议类型, 端口范围为-1/-1, 没有这条规则则ping 不通主机 2.3 连接主机进行配置有了上面的配置就可以通过远程连接主机了, 我是使用xshell 进行远程连接, 使用fileZilla进行传输文件 2.3.1 配置 Java环境方式一：使用yum安装JDK 参考：https://www.cnblogs.com/sxdcgaq8080/p/7492426.html12345678910111213141516171819201.查看yum库中都有哪些jdk版本(暂时只发现了openjdk): [root@localhost ~]# yum search java|grep jdk2.选择版本,进行安装[root@localhost ~]# yum install java-1.8.0-openjdk//安装完之后，默认的安装目录是在: /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.75.x86_643.设置环境变量[root@localhost ~]# vi /etc/profile在profile文件中添加如下内容#set java environmentJAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el7_5.x86_64JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH4.让修改生效[root@localhost java]# source /etc/profile 注: 如果出现export =&#39; not a valid identifier12345678910111213原因就是你修改的 /etc/profile 文件里你加过空格我的代码如下：export JAVA_HOME = /usr/java/jdk1.7.0_75export PATH = $JAVA_HOME/bin:$PATHexport CLASSPATH = .:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar修改为如下：export JAVA_HOME=/usr/java/jdk1.7.0_75export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar将等号两边的空格去掉就可以了 ，大家要注意 2.3.2 配置 Tomcat环境参考： http://www.linuxidc.com/Linux/2015-09/123118.htm12# tar -zxvf apache-tomcat-8.0.26.tar.gz // 解压压缩包 # mv apache-tomcat-8.0.26 tomcat // 改名 注:1.在ECS上启动tomcat后，第一次访问时间特别长1234567892017-04-25 10:16:04 INFO com.world.socket.ServerSocketListener 25-Apr-2017 10:18:48.171 INFO [localhost-startStop-1] org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom CreaecureRandom instance for session ID generation using [SHA1PRNG] took [163,521] milliseconds. 这个session ID引起的 解决办法：在JVM环境中解决 打开$JAVA_PATH/jre/lib/security/java.security这个文件，找到下面的内容：securerandom.source=file:/dev/urandom 替换成securerandom.source=file:/dev/./urandom 2.Centos打开、关闭、结束tomcat，及查看tomcat运行日志1234567891011启动：一般是执行sh tomcat/bin/startup.sh 停止：一般是执行sh tomcat/bin/shutdown.sh脚本命令 查看：执行ps -ef |grep tomcat 输出如下 *** 5144 。。。等等.Bootstrap start 说明tomcat已经正常启动， 5144 就为进程号 pid = 5144 杀死：kill -9 5144------------------------linux下实时查看tomcat运行日志-------------------------1、先切换到：cd tomcat/logs2、tail -f catalina.out3、这样运行时就可以实时查看运行日志了Ctrl+c 是退出tail命令。 2.3.3 配置 Mysql环境参考： http://www.linuxidc.com/Linux/2016-09/134992.htm 2.4 投放项目文件使用fileZilla进行传输文件1234Tomcat中部署web项目的三种方式：1.部署解包的webapp目录2.打包的war文件3.Manager Web应用程序","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"异步方法","slug":"backend/spring/异步方法","date":"2018-01-14T14:25:44.000Z","updated":"2018-02-26T12:31:59.472Z","comments":true,"path":"2018/01/14/backend/spring/异步方法/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/spring/异步方法/","excerpt":"","text":"异步方法 加入@Async注解可以让普通方法变为异步方法 AsyncTaskService.java 12345678910111213141516171819202122package com.smart.boot.asyn;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;@Servicepublic class AsyncTaskService &#123; /** * 异步方法 * * @param i */ @Async public void task1(Integer i) &#123; System.out.println(\"执行异步任务\" + i); &#125; @Async public void task2(Integer i) &#123; System.out.println(\"执行异步任务+1 \" + (i + 1)); &#125;&#125; Config.java 1234567891011121314151617181920212223242526272829303132333435package com.smart.boot.asyn;import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.AsyncConfigurer;import org.springframework.scheduling.annotation.EnableAsync;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.util.concurrent.Executor;@Configuration@ComponentScan(\"com.smart.boot.asyn\")@EnableAsync // 开启异步任务支持public class Config implements AsyncConfigurer &#123; /** * 获得一个基于线程池的 taskExecutor * * @return */ @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(5); taskExecutor.setMaxPoolSize(10); taskExecutor.setQueueCapacity(25); taskExecutor.initialize(); return taskExecutor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return null; &#125;&#125; Application.java123456789101112131415package com.smart.boot.asyn;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Application &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class); AsyncTaskService asyncTaskService = context.getBean(AsyncTaskService.class); for (int i = 0; i &lt; 10; i++) &#123; asyncTaskService.task1(i); asyncTaskService.task2(i); &#125; context.close(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"组合注解","slug":"backend/spring/组合注解","date":"2018-01-14T14:25:44.000Z","updated":"2018-02-26T12:31:59.500Z","comments":true,"path":"2018/01/14/backend/spring/组合注解/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/spring/组合注解/","excerpt":"","text":"组合注解 用一个注解表示其他注解 CombinationAnnocation.java 123456789101112131415package com.smart.boot.groupAnno;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import java.lang.annotation.*;@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration@ComponentScanpublic @interface CombinationAnnocation &#123; String [] value() default &#123;&#125;;&#125; Config.java 12345package com.smart.boot.groupAnno;@CombinationAnnocationpublic class Config &#123;&#125; Application.java1234567891011package com.smart.boot.groupAnno;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Application &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class); context.close(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring 事件监听","slug":"backend/spring/spring 事件监听","date":"2018-01-14T12:01:44.000Z","updated":"2018-02-26T12:31:59.444Z","comments":true,"path":"2018/01/14/backend/spring/spring 事件监听/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/spring/spring 事件监听/","excerpt":"Spring 事件监听spring的事件(Application Event)为Bean与Bean之间的消息通信提供了支持, 当第一个Bean处理完一件事之后, 需要另外一个Bean知道并能做出相应的处理, 这时可以通过事件监听来讲一个Bean监听另一个Bean 观察者模式 Spring 事件监听是观察者模式的一种实现 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 事件驱动模型简介 事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点： 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）； 当目标发送改变（发布），观察者（订阅者）就可以接收到改变； 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。","text":"Spring 事件监听spring的事件(Application Event)为Bean与Bean之间的消息通信提供了支持, 当第一个Bean处理完一件事之后, 需要另外一个Bean知道并能做出相应的处理, 这时可以通过事件监听来讲一个Bean监听另一个Bean 观察者模式 Spring 事件监听是观察者模式的一种实现 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。 何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。 如何解决：使用面向对象技术，可以将这种依赖关系弱化。 事件驱动模型简介 事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；理解它的几个关键点： 首先是一种对象间的一对多的关系；最简单的如交通信号灯，信号灯是目标（一方），行人注视着信号灯（多方）； 当目标发送改变（发布），观察者（订阅者）就可以接收到改变； 观察者如何处理（如行人如何走，是快走/慢走/不走，目标不会管的），目标无需干涉；所以就松散耦合了它们之间的关系。 实现流程1.自定义事件12345678910111213141516171819202122232425262728package com.smart.boot.event;import org.springframework.context.ApplicationEvent;public class DemoEvent extends ApplicationEvent &#123; private String msg; public DemoEvent(Object source, String msg) &#123; super(source); this.msg = msg; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; /** * 去做一些事 */ public void todoSomethings() &#123; System.out.println(\"正在做第一件事 , 做完需要做第二件事\"); &#125;&#125; 2.定义事件监听器12345678910111213141516171819package com.smart.boot.event;import org.springframework.context.ApplicationListener;import org.springframework.stereotype.Component;@Componentpublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt; &#123; /** * 对消息进行接受处理 * @param event */ @Override public void onApplicationEvent(DemoEvent event) &#123; String msg = event.getMsg(); System.out.println(\"DemoListener 接受到了消息\" + msg ); event.todoSomethings(); System.out.println(\"正在做第二件事\"); &#125;&#125; 3.发布事件12345678910111213141516171819202122package com.smart.boot.event;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.stereotype.Component;@Componentpublic class DemoPublisher &#123; /** * 注入ApplicationContext来发布事件 */ @Autowired ApplicationContext context; /** * 发布事件 * @param msg */ public void publish(String msg) &#123; context.publishEvent(new DemoEvent(this,msg)); &#125;&#125; 4.定义配置类123456789package com.smart.boot.event;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(\"com.smart.boot.event\")public class Config &#123;&#125; 5.运行123456789101112package com.smart.boot.event;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class Application &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Config.class); DemoPublisher demoPublisher = context.getBean(DemoPublisher.class); demoPublisher.publish(\"hello songshuiyang\"); context.close(); &#125;&#125; 6.实现结果123DemoListener 接受到了消息hello songshuiyang正在做第一件事 , 做完需要做第二件事正在做第二件事 总结 实现事件监听可以使业务解耦, 每个模块做好自己的事情即可, 可用在用户注册功能, eg: http://jinnianshilongnian.iteye.com/blog/1902886","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"注解Value, Spring EL","slug":"backend/spring/注解Value","date":"2018-01-14T08:01:44.000Z","updated":"2018-02-26T12:31:59.495Z","comments":true,"path":"2018/01/14/backend/spring/注解Value/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/backend/spring/注解Value/","excerpt":"@Value用法及配合Spring EL使用spring支持@Value注解获取一些配置信息及加载资源 ELConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.smart.boot.el;import org.apache.commons.io.IOUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;@Configuration@ComponentScan(\"com.smart.boot.el\")@PropertySource(\"classpath:el.properties\")public class ELConfig &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 注入普通字符串 */ @Value(\"songsy\") private String str; /** * 通过el注入操作系统属性 */ @Value(\"# &#123;systemProperties['os.name']&#125;\") private String osName; /** * 表达式结果 */ @Value(\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\") private double randomNumber; /** * 注入其他Bean属性 */ @Value(\"#&#123;eLService.another&#125;\") public String fromAnothor; /** * 注入文件资源 */ @Value(\"classpath:el.properties\") private Resource testFile; /** * 注入网站资源 */ @Value(\"http://www.baidu.com\") private Resource testUrl; /** * 注入配置文件 */ @Value(\"$&#123;book.name&#125;\") private String bookName; /** * 环境配置 * 环境在容器中是一个抽象的集合，是指应用环境的2个方面: profiles和 properties. * profile: * 配置是一个被命名的，bean定义的逻辑组，这些bean只有在给定的profile配置激活时才会注册到容器。不管是XML还是注解， * Beans都有可能指派给profile配置。Environment环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。 * Properties: * 扮演一个非常重要的角色,可能来源于一下源码变量:properties文件，JVM properties,system环境变量，JNDI, servlet context parameters上下文参数, * 专门的Properties对象，Maps等等。Environment对象的作用，对于properties来说，是提供给用户方便的服务接口，方便撰写配置、方便解析配置。 * 作者：不迷失 * 链接：https://www.jianshu.com/p/49e950b0b008 * 來源：简书 * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */ @Autowired private Environment environment; /** * 若使用@Value注入, 则要配置一个PropertySourcesPlaceholderConfigurer * * @return */ @Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; public void print() throws Exception &#123; logger.info(\"str: \" + str); logger.info(\"osName: \" + osName); logger.info(\"randomNumber: \" + String.valueOf(randomNumber)); logger.info(\"fromAnothor: \" + fromAnothor); logger.info(\"testFile: \" + IOUtils.toString(testFile.getInputStream())); logger.info(\"testUrl: \" + IOUtils.toString(testUrl.getInputStream())); logger.info(\"bookName: \" + bookName); logger.info(\"environment: \" + environment.getProperty(\"book.author\")); &#125;&#125;","text":"@Value用法及配合Spring EL使用spring支持@Value注解获取一些配置信息及加载资源 ELConfig.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.smart.boot.el;import org.apache.commons.io.IOUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.context.support.PropertySourcesPlaceholderConfigurer;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;@Configuration@ComponentScan(\"com.smart.boot.el\")@PropertySource(\"classpath:el.properties\")public class ELConfig &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 注入普通字符串 */ @Value(\"songsy\") private String str; /** * 通过el注入操作系统属性 */ @Value(\"# &#123;systemProperties['os.name']&#125;\") private String osName; /** * 表达式结果 */ @Value(\"#&#123; T(java.lang.Math).random() * 100.0 &#125;\") private double randomNumber; /** * 注入其他Bean属性 */ @Value(\"#&#123;eLService.another&#125;\") public String fromAnothor; /** * 注入文件资源 */ @Value(\"classpath:el.properties\") private Resource testFile; /** * 注入网站资源 */ @Value(\"http://www.baidu.com\") private Resource testUrl; /** * 注入配置文件 */ @Value(\"$&#123;book.name&#125;\") private String bookName; /** * 环境配置 * 环境在容器中是一个抽象的集合，是指应用环境的2个方面: profiles和 properties. * profile: * 配置是一个被命名的，bean定义的逻辑组，这些bean只有在给定的profile配置激活时才会注册到容器。不管是XML还是注解， * Beans都有可能指派给profile配置。Environment环境对象的作用，对于profiles配置来说，它能决定当前激活的是哪个profile配置，和哪个profile是默认。 * Properties: * 扮演一个非常重要的角色,可能来源于一下源码变量:properties文件，JVM properties,system环境变量，JNDI, servlet context parameters上下文参数, * 专门的Properties对象，Maps等等。Environment对象的作用，对于properties来说，是提供给用户方便的服务接口，方便撰写配置、方便解析配置。 * 作者：不迷失 * 链接：https://www.jianshu.com/p/49e950b0b008 * 來源：简书 * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */ @Autowired private Environment environment; /** * 若使用@Value注入, 则要配置一个PropertySourcesPlaceholderConfigurer * * @return */ @Bean public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer(); &#125; public void print() throws Exception &#123; logger.info(\"str: \" + str); logger.info(\"osName: \" + osName); logger.info(\"randomNumber: \" + String.valueOf(randomNumber)); logger.info(\"fromAnothor: \" + fromAnothor); logger.info(\"testFile: \" + IOUtils.toString(testFile.getInputStream())); logger.info(\"testUrl: \" + IOUtils.toString(testUrl.getInputStream())); logger.info(\"bookName: \" + bookName); logger.info(\"environment: \" + environment.getProperty(\"book.author\")); &#125;&#125; ELService.java12345678910111213141516171819package com.smart.boot.el;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Service(\"eLService\")public class ELService &#123; public String another; public String getAnother() &#123; return another; &#125; @Autowired public void setAnother() &#123; this.another = \"ELService 自动注入\"; &#125;&#125; ELMain.java123456789101112package com.smart.boot.el;import org.springframework.context.annotation.AnnotationConfigApplicationContext;public class ELMain &#123; public static void main(String[] args) throws Exception &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ELConfig.class); ELConfig elConfig = context.getBean(ELConfig.class); elConfig.print(); context.close(); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"npm scripts","slug":"frontend/npm/npm scripts","date":"2018-01-14T03:48:12.000Z","updated":"2018-02-26T12:31:58.964Z","comments":true,"path":"2018/01/14/frontend/npm/npm scripts/","link":"","permalink":"http://www.songshuiyang.site/2018/01/14/frontend/npm/npm scripts/","excerpt":"","text":"一、什么是 npm 脚本npm 允许在package.json文件里面，使用scripts字段定义脚本命令。123456&#123; // ... \"scripts\": &#123; \"build\": \"node build.js\" &#125;&#125; 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。命令行下使用npm run命令，就可以执行这段脚本。123$ npm run build# 等同于执行$ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多 项目的相关脚本，可以集中在一个地方。 不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。 可以利用 npm 提供的很多辅助功能。 查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。1$ npm run 二：执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&amp;符号。1$ npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号1$ npm run script1.js &amp;&amp; npm run script2.js 应用在 package.json 添加以下代码执行npm run gg 可以连续执行（hexo g）（hexo d）俩个命令，这样就不用每次执行俩个命令123\"scripts\": &#123; \"gg\": \"hexo g &amp;&amp; hexo d\" &#125; 详见:http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"node","slug":"node","permalink":"http://www.songshuiyang.site/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://www.songshuiyang.site/tags/npm/"}]},{"title":"接入银联支付接口","slug":"backend/支付/接入银联支付接口","date":"2018-01-11T14:24:12.000Z","updated":"2018-02-26T12:31:59.756Z","comments":true,"path":"2018/01/11/backend/支付/接入银联支付接口/","link":"","permalink":"http://www.songshuiyang.site/2018/01/11/backend/支付/接入银联支付接口/","excerpt":"吐槽一下： 1.银联支付SDK是没有提供独立的jar包的，高大上的银联把示例demo和sdk整合在一起了，支付流程和支付宝支付相似，支付需要到银联的支付页面 2.证书说明：其实我们只需要一个邮件上的签名证书文件，官网上文档说的开发者调用接口前需要的其他证书在开发包中目录assets下都有，每个人都一样，没错，每个人都一样 3.银联开发平台常常在下午6点发版本，遇到过俩次，第一次感到惊讶:银联网站挂了？不可能呀，过了十多分钟又恢复正常，晕 4.代码不够规范，用代码检测工具一片黄色123456/** * @ClassName AcpService * @Description acpsdk接口服务类，接入商户集成请可以直接参考使用本类中的方法 * @date 2016-7-22 下午2:44:37 * 声明：以下代码只是为了方便接入方测试而提供的样例代码，商户可以根据自己需要，按照技术文档编写。该代码仅供参考，不提供编码，性能，规范性等方面的保障 */","text":"吐槽一下： 1.银联支付SDK是没有提供独立的jar包的，高大上的银联把示例demo和sdk整合在一起了，支付流程和支付宝支付相似，支付需要到银联的支付页面 2.证书说明：其实我们只需要一个邮件上的签名证书文件，官网上文档说的开发者调用接口前需要的其他证书在开发包中目录assets下都有，每个人都一样，没错，每个人都一样 3.银联开发平台常常在下午6点发版本，遇到过俩次，第一次感到惊讶:银联网站挂了？不可能呀，过了十多分钟又恢复正常，晕 4.代码不够规范，用代码检测工具一片黄色123456/** * @ClassName AcpService * @Description acpsdk接口服务类，接入商户集成请可以直接参考使用本类中的方法 * @date 2016-7-22 下午2:44:37 * 声明：以下代码只是为了方便接入方测试而提供的样例代码，商户可以根据自己需要，按照技术文档编写。该代码仅供参考，不提供编码，性能，规范性等方面的保障 */ 大致步骤一：下载demo及sdkhttps://open.unionpay.com/ajweb/product/newProDetail?proId=1&amp;cataId=14 二：配置参数：接入银联支付审核 听头说好像是挺繁琐的，费时费力，接入银联支付设及到下面几个参数，其他的参数银联都帮我们配置好了 1.商户号: 在银联商家技术服务中心可以看到 https://open.unionpay.com/ajweb/index，注意：在测试环境的商户号一致，刚开始我还不相信，通过客服才知道俩个是一样的，在测试账号信息里面可以看到 2.后台通知地址：填写接收银联后台通知的地址，必须外网能访问 3.前台通知地址：填写处理银联前台通知的地址，必须外网能访问 4.签名证书: 在审核成功发送的邮件里面 5.签名证书密码： 在审核成功发送的邮件里面有 三：调用支付接口protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.setContentType(\"text/html; charset=\"+ DemoBase.encoding); //前台页面传过来的 String merId = req.getParameter(\"merId\"); String txnAmt = req.getParameter(\"txnAmt\"); Map&lt;String, String&gt; requestData = new HashMap&lt;String, String&gt;(); /***银联全渠道系统，产品参数，除了encoding自行选择外其他不需修改***/ requestData.put(\"version\", DemoBase.version); //版本号，全渠道默认值 requestData.put(\"encoding\", DemoBase.encoding); //字符集编码，可以使用UTF-8,GBK两种方式 requestData.put(\"signMethod\", SDKConfig.getConfig().getSignMethod()); //签名方法 requestData.put(\"txnType\", \"01\"); //交易类型 ，01：消费 requestData.put(\"txnSubType\", \"01\"); //交易子类型， 01：自助消费 requestData.put(\"bizType\", \"000201\"); //业务类型，B2C网关支付，手机wap支付 requestData.put(\"channelType\", \"07\"); //渠道类型，这个字段区分B2C网关支付和手机wap支付；07：PC,平板 08：手机 /***商户接入参数***/ requestData.put(\"merId\", merId); //商户号码，请改成自己申请的正式商户号或者open上注册得来的777测试商户号 requestData.put(\"accessType\", \"0\"); //接入类型，0：直连商户 requestData.put(\"orderId\",DemoBase.getOrderId()); //商户订单号，8-40位数字字母，不能含“-”或“_”，可以自行定制规则 requestData.put(\"txnTime\", DemoBase.getCurrentTime()); //订单发送时间，取系统时间，格式为YYYYMMDDhhmmss，必须取当前时间，否则会报txnTime无效 requestData.put(\"currencyCode\", \"156\"); //交易币种（境内商户一般是156 人民币） requestData.put(\"txnAmt\", txnAmt); //交易金额，单位分，不要带小数点 //requestData.put(\"reqReserved\", \"透传字段\"); //请求方保留域，如需使用请启用即可；透传字段（可以实现商户自定义参数的追踪）本交易的后台通知,对本交易的交易状态查询交易、对账文件中均会原样返回，商户可以按需上传，长度为1-1024个字节。出现&amp;={}[]符号时可能导致查询接口应答报文解析失败，建议尽量只传字母数字并使用|分割，或者可以最外层做一次base64编码(base64编码之后出现的等号不会导致解析失败可以不用管)。 //前台通知地址 （需设置为外网能访问 http https均可），支付成功后的页面 点击“返回商户”按钮的时候将异步通知报文post到该地址 //如果想要实现过几秒中自动跳转回商户页面权限，需联系银联业务申请开通自动返回商户权限 //异步通知参数详见open.unionpay.com帮助中心 下载 产品接口规范 网关支付产品接口规范 消费交易 商户通知 requestData.put(\"frontUrl\", DemoBase.frontUrl); //后台通知地址（需设置为【外网】能访问 http https均可），支付成功后银联会自动将异步通知报文post到商户上送的该地址，失败的交易银联不会发送后台通知 //后台通知参数详见open.unionpay.com帮助中心 下载 产品接口规范 网关支付产品接口规范 消费交易 商户通知 //注意:1.需设置为外网能访问，否则收不到通知 2.http https均可 3.收单后台通知后需要10秒内返回http200或302状态码 // 4.如果银联通知服务器发送通知后10秒内未收到返回状态码或者应答码非http200，那么银联会间隔一段时间再次发送。总共发送5次，每次的间隔时间为0,1,2,4分钟。 // 5.后台通知地址如果上送了带有？的参数，例如：http://abc/web?a=b&amp;c=d 在后台通知处理程序验证签名之前需要编写逻辑将这些字段去掉再验签，否则将会验签失败 requestData.put(\"backUrl\", DemoBase.backUrl); // 订单超时时间。 // 超过此时间后，除网银交易外，其他交易银联系统会拒绝受理，提示超时。 跳转银行网银交易如果超时后交易成功，会自动退款，大约5个工作日金额返还到持卡人账户。 // 此时间建议取支付时的北京时间加15分钟。 // 超过超时时间调查询接口应答origRespCode不是A6或者00的就可以判断为失败。 requestData.put(\"payTimeout\", new SimpleDateFormat(\"yyyyMMddHHmmss\").format(new Date().getTime() + 15 * 60 * 1000)); ////////////////////////////////////////////////// // // 报文中特殊用法请查看 PCwap网关跳转支付特殊用法.txt // ////////////////////////////////////////////////// /**请求参数设置完毕，以下对请求参数进行签名并生成html表单，将表单写入浏览器跳转打开银联页面**/ Map&lt;String, String&gt; submitFromData = AcpService.sign(requestData,DemoBase.encoding); //报文中certId,signature的值是在signData方法中获取并自动赋值的，只要证书配置正确即可。 String requestFrontUrl = SDKConfig.getConfig().getFrontRequestUrl(); //获取请求银联的前台地址：对应属性文件acp_sdk.properties文件中的acpsdk.frontTransUrl String html = AcpService.createAutoFormHtml(requestFrontUrl, submitFromData,DemoBase.encoding); //生成自动跳转的Html表单 LogUtil.writeLog(\"打印请求HTML，此为请求报文，为联调排查问题的依据：\"+html); //将生成的html写到浏览器中完成自动跳转打开银联支付页面；这里调用signData之后，将html写到浏览器跳转到银联页面之前均不能对html中的表单项的名称和值进行修改，如果修改会导致验签不通过 resp.getWriter().write(html); } 异步通知：与支付宝微信异步通知处理相同参考于：https://open.unionpay.com/ajweb/product/newProDetail?proId=1&amp;cataId=14","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"接入微信扫码支付接口","slug":"backend/支付/接入微信支付接口","date":"2018-01-11T13:24:12.000Z","updated":"2018-02-26T12:31:59.709Z","comments":true,"path":"2018/01/11/backend/支付/接入微信支付接口/","link":"","permalink":"http://www.songshuiyang.site/2018/01/11/backend/支付/接入微信支付接口/","excerpt":"准备条件开始之前先看一下微信的几个平台: 微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。平台入口：http://mp.weixin.qq.com。 微信开放平台:微信开放平台是商户APP接入微信支付开放接口的申请入口，通过此平台可申请微信APP支付。平台入口：http://open.weixin.qq.com。 微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。平台入口：http://pay.weixin.qq.com 刚开始接入的时候有点昏，各种参数需要到不同的平台找, 不像支付宝一样只有一个开发平台，如果是接入微信扫码支付设及到微信公众平台和微信商户平台，如果是手机app微信支付，设及到微信开放平台和微信商户平台 开通支付功能:有了平台账号之后，然后就是开通支付功能，等待审核通过，当然审核过程有可能被退回，大多是描述信息或者经营类别与营业执照描述不一致","text":"准备条件开始之前先看一下微信的几个平台: 微信公众平台:是微信公众账号申请入口和管理后台。商户可以在公众平台提交基本资料、业务资料、财务资料申请开通微信支付功能。平台入口：http://mp.weixin.qq.com。 微信开放平台:微信开放平台是商户APP接入微信支付开放接口的申请入口，通过此平台可申请微信APP支付。平台入口：http://open.weixin.qq.com。 微信商户平台:微信商户平台是微信支付相关的商户功能集合，包括参数配置、支付数据查询与统计、在线退款、代金券或立减优惠运营等功能。平台入口：http://pay.weixin.qq.com 刚开始接入的时候有点昏，各种参数需要到不同的平台找, 不像支付宝一样只有一个开发平台，如果是接入微信扫码支付设及到微信公众平台和微信商户平台，如果是手机app微信支付，设及到微信开放平台和微信商户平台 开通支付功能:有了平台账号之后，然后就是开通支付功能，等待审核通过，当然审核过程有可能被退回，大多是描述信息或者经营类别与营业执照描述不一致 微信支付开发: 下面是微信支付的业务流程时序图, 可以看到与支付宝的支付流程主要流程是差不多的，只不过微信扫码可以在本系统完成支付，没有发生页面跳转，可以自己DIY支付页面，只要将支付链接生成二维码图片即可完成支付 logo 接入微信支付步骤1. 获取支付SDK gradle:地址 compile(&quot;com.github.wxpay:wxpay-sdk:0.0.3&quot;) 2. 配置参数主要是如下参数, 可以配置在一个属性文件中方面配置 1、APP ID ，应用ID（在公众平台–基本配置模块中） 2、APP Sercret ，应用秘钥（在公众平台–基本配置模块中）32位数字大小写字母 3、API Key，API的秘钥（在商户平台–API安全中设置） 4、mchID , 商户号（在公众平台—微信支付—商户信息） 5、order_api ， 统一下单API的接口 6、notify_url 交易成功回调的接口的URL 3. 新建一个参数配置类 WxPcPayConfigImpl.java 继承 WXPayConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** * 微信支付PC端 基础属性配置 */public class WxPcPayConfigImpl implements WXPayConfig &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); // 配置文件地址 private static final String FILE_NAME = \"weixin_pc_pay.properties\"; // 服务号的应用ID public static String APP_ID; // 服务号的应用密钥 public static String APP_SECRET; // 服务号的配置token public static String TOKEN; // 商户号 public static String MCH_ID; // API密钥 public static String API_KEY; // 签名加密方式 public static String SIGN_TYPE; // 微信支付证书 public static String CERT_PATH; // 异步回调地址 public static String NOTIFY_URL; // 是否使用沙箱环境 public static boolean IS_USE_SANDBOX; // 证书 private static byte[] certData; // INSTANCE private static WxPcPayConfigImpl INSTANCE; // 配置对象 private static Configuration configs; // 文件分隔符 public final static String SF_FILE_SEPARATOR = System.getProperty(\"file.separator\");//文件分隔符 // 二维码图片宽度 public final static int QR_IMG_WIDTH = 300; // 二维码图片高度 public final static int QR_IMG_HEIGHT = 300; /** * 返回配置文件实例 * * @return * @throws Exception */ public static WxPcPayConfigImpl getInstance() throws Exception &#123; if (INSTANCE == null) &#123; synchronized (WxPcPayConfigImpl.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new WxPcPayConfigImpl(); &#125; &#125; &#125; return INSTANCE; &#125; /** * 加载微信配置文件 */ public static synchronized void init() &#123; if (configs != null) &#123; return; &#125; try &#123; configs = new PropertiesConfiguration(FILE_NAME); &#125; catch (ConfigurationException e) &#123; e.printStackTrace(); &#125; if (configs == null) &#123; throw new IllegalStateException(\"读取配置文件错误\" + FILE_NAME); &#125; APP_ID = configs.getString(\"appId\"); APP_SECRET = configs.getString(\"appSecret\"); TOKEN = configs.getString(\"token\"); MCH_ID = configs.getString(\"mchId\"); API_KEY = configs.getString(\"apiKey\"); SIGN_TYPE = configs.getString(\"signType\"); CERT_PATH = configs.getString(\"certPath\"); IS_USE_SANDBOX = configs.getBoolean(\"isUseSandbox\"); NOTIFY_URL = configs.getString(\"notifyUrl\"); // 加载证书 File file; try &#123; // file = new File(CERT_PATH); Resource resource = new ClassPathResource(CERT_PATH); file = resource.getFile(); InputStream certStream = new FileInputStream(file); certData = new byte[(int) file.length()]; certStream.read(certData); certStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取 App ID * * @return App ID */ @Override public String getAppID() &#123; return APP_ID; &#125; /** * 获取 Mch ID * * @return Mch ID */ @Override public String getMchID() &#123; return MCH_ID; &#125; /** * 获取 API 密钥 * * @return API密钥 */ @Override public String getKey() &#123; return API_KEY; &#125; /** * 获取商户证书内容 * * @return 商户证书内容 */ @Override public InputStream getCertStream() &#123; ByteArrayInputStream certBis; certBis = new ByteArrayInputStream(this.certData); return certBis; &#125; /** * HTTP(S) 连接超时时间，单位毫秒 * * @return */ @Override public int getHttpConnectTimeoutMs() &#123; return 8000; &#125; /** * HTTP(S) 读数据超时时间，单位毫秒 * * @return */ @Override public int getHttpReadTimeoutMs() &#123; return 10000; &#125; public byte[] getCertData() &#123; return certData; &#125; public void setCertData(byte[] certData) &#123; this.certData = certData; &#125;&#125; 4. new 一个WXPay对象123WXPay wxAppPay;WxPcPayConfigImpl pcConfig = WxPcPayConfigImpl.getInstance();wxpay = new WXPay(pcConfig, WXPayConstants.SignType.MD5, WxPcPayConfigImpl.IS_USE_SANDBOX); 5. 有了”对象”之后就可以发送支付请求了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * PC端微信支付请求 * * @param domainId 商户订单号取实体类id * @param amount 充值金额 * @return 处理结果数据 */public Map&lt;String, Object&gt; weixinPay(String domainId, BigDecimal amount, HttpServletRequest request) &#123; Map&lt;String, Object&gt; resultMaps = new HashMap&lt;&gt;(); resultMaps.put(\"status\", \"success\"); HashMap&lt;String, String&gt; data = new HashMap&lt;&gt;(); String currentUserName = \"\"; if (AccountUtils.getCurrentUser() != null) &#123; if (StringUtils.isNotBlank(AccountUtils.getCurrentUser().getFdNickName())) &#123; currentUserName = AccountUtils.getCurrentUser().getFdNickName(); &#125; &#125; String description = currentUserName + \" 账户充值\"; data.put(\"body\", description); // 商品描述 data.put(\"out_trade_no\", domainId); // 商户订单号 data.put(\"total_fee\", AmountUtils.transAmountToCent(amount)); // 总金额,单位为分 data.put(\"spbill_create_ip\", WxUtils.getRemoteIp(request)); // 发起人IP地址 data.put(\"notify_url\", WxPcPayConfigImpl.NOTIFY_URL); // 异步通知地址 data.put(\"trade_type\", \"NATIVE\"); // 此处指定为扫码支付 data.put(\"product_id\", domainId); // 商品ID,trade_type=NATIVE时（即扫码支付），此参数必传 Map&lt;String, String&gt; resultMap; try &#123; resultMap = wxpay.unifiedOrder(data); logger.info(\"微信生成二维码返回xml 转成Json\" + JsonFormatUtil.formatJson(resultMap.toString())); System.out.println(resultMap); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.error(\"微信支付处理异常\"); resultMaps.put(\"status\", \"failed\"); return resultMaps; &#125; String returnCode = resultMap.get(\"return_code\"); // 返回结果 if (\"SUCCESS\".equals(returnCode)) &#123; String resultCode = resultMap.get(\"result_code\"); // 处理结果 if (\"SUCCESS\".equals(resultCode)) &#123; logger.info(\"订单号：&#123;&#125;生成微信支付码成功\", domainId); String urlCode = resultMap.get(\"code_url\"); // 生成二维码 logger.info(\"\"); // WxUtils.encodeQRCode(urlCode,imgPath); String imgBase64Str = WxUtils.encodeQRCodeBase64(urlCode); // 是否是微信支付 resultMaps.put(\"id\", domainId); resultMaps.put(\"isWxPay\", true); resultMaps.put(\"img\", imgBase64Str); &#125; else &#123; String errCodeDes = resultMap.get(\"err_code_des\"); logger.info(\"订单号：&#123;&#125;生成微信支付码(系统)失败:&#123;&#125;\", domainId, errCodeDes); resultMaps.put(\"status\", \"failed\"); return resultMaps; &#125; &#125; else &#123; String returnMsg = resultMap.get(\"return_msg\"); logger.info(\"(订单号：&#123;&#125;生成微信支付码(通信)失败:&#123;&#125;\", domainId, returnMsg); resultMaps.put(\"status\", \"failed\"); return resultMaps; &#125; return resultMaps;&#125; 微信支付统一下单接口:12345678910/** * 作用：统一下单&lt;br&gt; * 场景：公共号支付、扫码支付、APP支付 * @param reqData 向wxpay post的请求数据 * @return API返回数据 * @throws Exception */public Map&lt;String, String&gt; unifiedOrder(Map&lt;String, String&gt; reqData) throws Exception &#123; return this.unifiedOrder(reqData, config.getHttpConnectTimeoutMs(), this.config.getHttpReadTimeoutMs());&#125; 6. 生成支付二维码这里我是将二维码链接字符串转成字符流 然后生成Base64位的图片字符, 只要在 设置src属性值，就可以完成图片展示，不用考虑生成的图片放在那里 7. 支付完成, 处理异步回调备注： 微信支付是使用的xml进行传输数据，需要将xml转成map，当然微信SDK中也提供了工具类，提供了一些十分用的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257package com.github.wxpay.sdk;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.StringWriter;import java.util.*;import java.security.MessageDigest;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import javax.crypto.Mac;import javax.crypto.spec.SecretKeySpec;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import com.github.wxpay.sdk.WXPayConstants.SignType;public class WXPayUtil &#123; /** * XML格式字符串转换为Map * * @param strXML XML字符串 * @return XML数据转换后的Map * @throws Exception */ public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123; Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes(\"UTF-8\")); org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); NodeList nodeList = doc.getDocumentElement().getChildNodes(); for (int idx=0; idx&lt;nodeList.getLength(); ++idx) &#123; Node node = nodeList.item(idx); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; org.w3c.dom.Element element = (org.w3c.dom.Element) node; data.put(element.getNodeName(), element.getTextContent()); &#125; &#125; try &#123; stream.close(); &#125; catch (Exception ex) &#123; &#125; return data; &#125; /** * 将Map转换为XML格式的字符串 * * @param data Map类型数据 * @return XML格式的字符串 * @throws Exception */ public static String mapToXml(Map&lt;String, String&gt; data) throws Exception &#123; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder(); org.w3c.dom.Document document = documentBuilder.newDocument(); org.w3c.dom.Element root = document.createElement(\"xml\"); document.appendChild(root); for (String key: data.keySet()) &#123; String value = data.get(key); if (value == null) &#123; value = \"\"; &#125; value = value.trim(); org.w3c.dom.Element filed = document.createElement(key); filed.appendChild(document.createTextNode(value)); root.appendChild(filed); &#125; TransformerFactory tf = TransformerFactory.newInstance(); Transformer transformer = tf.newTransformer(); DOMSource source = new DOMSource(document); transformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\"); transformer.setOutputProperty(OutputKeys.INDENT, \"yes\"); StringWriter writer = new StringWriter(); StreamResult result = new StreamResult(writer); transformer.transform(source, result); String output = writer.getBuffer().toString(); //.replaceAll(\"\\n|\\r\", \"\"); try &#123; writer.close(); &#125; catch (Exception ex) &#123; &#125; return output; &#125; /** * 生成带有 sign 的 XML 格式字符串 * * @param data Map类型数据 * @param key API密钥 * @return 含有sign字段的XML */ public static String generateSignedXml(final Map&lt;String, String&gt; data, String key) throws Exception &#123; return generateSignedXml(data, key, SignType.MD5); &#125; /** * 生成带有 sign 的 XML 格式字符串 * * @param data Map类型数据 * @param key API密钥 * @param signType 签名类型 * @return 含有sign字段的XML */ public static String generateSignedXml(final Map&lt;String, String&gt; data, String key, SignType signType) throws Exception &#123; String sign = generateSignature(data, key, signType); data.put(WXPayConstants.FIELD_SIGN, sign); return mapToXml(data); &#125; /** * 判断签名是否正确 * * @param xmlStr XML格式数据 * @param key API密钥 * @return 签名是否正确 * @throws Exception */ public static boolean isSignatureValid(String xmlStr, String key) throws Exception &#123; Map&lt;String, String&gt; data = xmlToMap(xmlStr); if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) &#123; return false; &#125; String sign = data.get(WXPayConstants.FIELD_SIGN); return generateSignature(data, key).equals(sign); &#125; /** * 判断签名是否正确，必须包含sign字段，否则返回false。使用MD5签名。 * * @param data Map类型数据 * @param key API密钥 * @return 签名是否正确 * @throws Exception */ public static boolean isSignatureValid(Map&lt;String, String&gt; data, String key) throws Exception &#123; return isSignatureValid(data, key, SignType.MD5); &#125; /** * 判断签名是否正确，必须包含sign字段，否则返回false。 * * @param data Map类型数据 * @param key API密钥 * @param signType 签名方式 * @return 签名是否正确 * @throws Exception */ public static boolean isSignatureValid(Map&lt;String, String&gt; data, String key, SignType signType) throws Exception &#123; if (!data.containsKey(WXPayConstants.FIELD_SIGN) ) &#123; return false; &#125; String sign = data.get(WXPayConstants.FIELD_SIGN); return generateSignature(data, key, signType).equals(sign); &#125; /** * 生成签名 * * @param data 待签名数据 * @param key API密钥 * @return 签名 */ public static String generateSignature(final Map&lt;String, String&gt; data, String key) throws Exception &#123; return generateSignature(data, key, SignType.MD5); &#125; /** * 生成签名. 注意，若含有sign_type字段，必须和signType参数保持一致。 * * @param data 待签名数据 * @param key API密钥 * @param signType 签名方式 * @return 签名 */ public static String generateSignature(final Map&lt;String, String&gt; data, String key, SignType signType) throws Exception &#123; Set&lt;String&gt; keySet = data.keySet(); String[] keyArray = keySet.toArray(new String[keySet.size()]); Arrays.sort(keyArray); StringBuilder sb = new StringBuilder(); for (String k : keyArray) &#123; if (k.equals(WXPayConstants.FIELD_SIGN)) &#123; continue; &#125; if (data.get(k).trim().length() &gt; 0) // 参数值为空，则不参与签名 sb.append(k).append(\"=\").append(data.get(k).trim()).append(\"&amp;\"); &#125; sb.append(\"key=\").append(key); if (SignType.MD5.equals(signType)) &#123; return MD5(sb.toString()).toUpperCase(); &#125; else if (SignType.HMACSHA256.equals(signType)) &#123; return HMACSHA256(sb.toString(), key); &#125; else &#123; throw new Exception(String.format(\"Invalid sign_type: %s\", signType)); &#125; &#125; /** * 获取随机字符串 Nonce Str * * @return String 随机字符串 */ public static String generateNonceStr() &#123; return UUID.randomUUID().toString().replaceAll(\"-\", \"\").substring(0, 32); &#125; /** * 生成 MD5 * * @param data 待处理数据 * @return MD5结果 */ public static String MD5(String data) throws Exception &#123; java.security.MessageDigest md = MessageDigest.getInstance(\"MD5\"); byte[] array = md.digest(data.getBytes(\"UTF-8\")); StringBuilder sb = new StringBuilder(); for (byte item : array) &#123; sb.append(Integer.toHexString((item &amp; 0xFF) | 0x100).substring(1, 3)); &#125; return sb.toString().toUpperCase(); &#125; /** * 生成 HMACSHA256 * @param data 待处理数据 * @param key 密钥 * @return 加密结果 * @throws Exception */ public static String HMACSHA256(String data, String key) throws Exception &#123; Mac sha256_HMAC = Mac.getInstance(\"HmacSHA256\"); SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"HmacSHA256\"); sha256_HMAC.init(secret_key); byte[] array = sha256_HMAC.doFinal(data.getBytes(\"UTF-8\")); StringBuilder sb = new StringBuilder(); for (byte item : array) &#123; sb.append(Integer.toHexString((item &amp; 0xFF) | 0x100).substring(1, 3)); &#125; return sb.toString().toUpperCase(); &#125;&#125; 参考于:http://mp.weixin.qq.com http://open.weixin.qq.com http://pay.weixin.qq.com","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"接入支付宝支付接口","slug":"backend/支付/接入支付宝支付接口","date":"2018-01-10T02:24:12.000Z","updated":"2018-11-13T11:59:09.756Z","comments":true,"path":"2018/01/10/backend/支付/接入支付宝支付接口/","link":"","permalink":"http://www.songshuiyang.site/2018/01/10/backend/支付/接入支付宝支付接口/","excerpt":"一: 应用场景 主要应用于一些交易平台商品订单支付，账户充值，线上收费这些有支付需求的交易 用户通过支付宝PC收银台完成支付，交易款项即时给到商户支付宝账户 logo logo","text":"一: 应用场景 主要应用于一些交易平台商品订单支付，账户充值，线上收费这些有支付需求的交易 用户通过支付宝PC收银台完成支付，交易款项即时给到商户支付宝账户 logo logo 二: 准备条件 一个公司, 不是公司的话是不能接入商户支付宝网关支付的, 当然支付宝是分个人用户和商户用户的, 如果是个人网站的话可以贴个自己收款二维码上去进行收款, 如果是正在运营的商户企业收取费用的话是要接入支付宝网关支付功能进行收费, 这样的话可以看起来bigger更高 企业或个体工商户，具有真实有效的营业执照，且支付宝账户名称需与营业执照主体一致 网站通过ICP备案，能正常访问，页面显示完整，有明确的运营内容与完整的商品信息。 三：接入支付宝支付功能步骤第一步：创建应用要在应用中使用支付宝开放产品的接口能力： 需要先去蚂蚁金服开放平台，在开发者中心创建登记您的应用，此时将获得应用唯一标识（APPID） 请在【功能信息】中点击【添加功能】，选择【电脑网站支付】 提交审核（需要上传公司营业执照,填写法人身份信息等等），等待审核通过，该应用正式可以使用 TIPS：电脑网站支付接口需签约后才能调用 第二步：配置密钥开发者调用接口前需要先生成RSA密钥，RSA密钥包含应用私钥(APP_PRIVATE_KEY)、应用公钥(APP_PUBLIC_KEY）。生成密钥后在开放平台管理中心进行密钥配置，配置完成后可以获取支付宝公钥(ALIPAY_PUBLIC_KEY)。 用途：支付宝发送信息给商户系统时，使用支付宝私钥对数据进行加签，商户获取到支付宝加签的信息后使用支付宝公钥对数据进行验签，得到正确的数据。商户系统给支付宝发送信息时，使用商户自己的私钥对数据加签，支付宝获取到数据后使用商家上传的公钥进行验签。 加签步骤: 1.筛选 获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign与sign_type参数。 2.排序 将筛选的参数按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。拼接 将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝 3.拼接 将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。 4.加签 商户将待签名字符串和商户私钥带入加签算法中得出sign。然后将sign值加入到请求参数中，发送给支付宝 验签步骤： 与加签步骤一致，只不过是延签是使用公钥算出sign值，两方算出的sign值都一致的话则延签成功 第三步：搭建和配置开发环境 需要到支付宝开发平台下载服务端SDK,打包即用, 十分方便 配置参数 123456789AlipayClient alipayClient = new DefaultAlipayClient(URL,APP_ID,APP_PRIVATE_KEY,FORMAT,CHARSET,ALIPAY_PUBLIC_KEY,SIGN_TYPE);// URL:支付宝网关（固定） https://openapi.alipay.com/gateway.do, 如果是沙箱环境的话: https://openapi.alipaydev.com/gateway.do// APP_ID:创建应用时获取, 支付宝提供// APP_PRIVATE_KEY: 应用私钥, 运用支付宝提供的工具进行生成// FORMAT: json（固定）// CHARSET: 编码格式// ALIPAY_PUBLIC_KEY: 支付宝公钥, 由支付宝提供// SIGN_TYPE： 加签类型，商户生成签名字符串所使用的签名算法类型，目前支持RSA2和RSA，推荐使用RSA2 配置完参数之后就可以调用支付宝的支付接口了, 十分方便, 阿里阿里 !!! 配置完参数之后先来看一下支付的调用流程： logo 接下来就是发起支付请求了12345678910111213141516171819202122232425262728import com.alipay.api.*;import com.alipay.api.request.*; public void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws ServletException,IOException &#123; //获得初始化的AlipayClient AlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\", APP_ID, APP_PRIVATE_KEY, FORMAT, CHARSET, ALIPAY_PUBLIC_KEY, SIGN_TYPE);//创建支付请求的对应requestAlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();//设置请求参数及回跳地址和通知地址 alipayRequest.setBizContent(\"&#123;\" + \" \\\"out_trade_no\\\":\\\"20150320010101001\\\",\" + \" \\\"total_amount\":88.88,\" + \" \\\"subject\\\":title\\\",\" + \" \\\"body\\\":\\\"Iphone6 16G\\\",\" + &#125;\");//跳转地址就是支付完成之后，支付宝自动执行页面重定向,就是跳转到我们设置的页面alipayRequest.setReturnUrl(\"http://www.songshuiyang.site/return_url\"); //通知地址就是支付宝会根据API中商户传入的notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统。alipayRequest.setNotifyUrl(\"http://www.songshuiyang.site/notify_url\");String form=\"\";try &#123; //调用SDK生成html表单 form = alipayClient.pageExecute(alipayRequest).getBody(); &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; //直接将完整的表单html输出到页面httpResponse.setContentType(\"text/html;charset=\" + CHARSET); httpResponse.getWriter().write(form); httpResponse.getWriter().flush(); httpResponse.getWriter().close(); &#125; 支付接口生成的html代码12345&lt;form name=\"punchout_form\" method=\"post\" action=\"https://openapi.alipay.com/gateway.do?charset=utf-8&amp;method=alipay.trade.page.pay&amp;sign=jsgXRru7b%2FHLO76SMPoj6lIuCnKJ9lkLo%2BTPIKfetqMOd8kyp2zYBZ456Dvf0eb4SyYgUrOjAgTkNW2AkgJh%2BbLJDu3eAtQVAUEEzFGy2Ix3uE3j3lPLHZDs1cF7g8vw7hwfmEqe8CE8OCJ%2B79J0Hp6YFOH8vnJEDUPvjla2AsCO0mhAsnYxm30rmqgDqJPfZLytOvRD5FF%2BoBd4UPH%2Budk7vCn9lEX%2BkEe7YBa3E7l6vWxXz%2BJDKGL9ZMHNtUzYUaid%2F%2BIugVLqtECybldd8YDZUFnz92Iq%2BOwIL09MzNtb6iC9AypfQxlTseFezDihBn%2Fey5itIovqntbLLdxt2g%3D%3D&amp;return_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment%2Findex&amp;notify_url=http%3A%2F%2Fwww.songshuiyang.com%2Fbuyer2%2Fpayment2%2Falipay_notify&amp;version=1.0&amp;app_id=123456789101554&amp;sign_type=RSA2&amp;timestamp=2018-01-01+14%3A27%3A50&amp;alipay_sdk=alipay-sdk-java-dynamicVersionNo&amp;format=json\"&gt; &lt;input type=\"hidden\" name=\"biz_content\" value=\"&#123;&amp;quot;out_trade_no&amp;quot;:&amp;quot;160b06765224a9aee66a6654541b947f&amp;quot;,&amp;quot;total_amount&amp;quot;:&amp;quot;0.01&amp;quot;,&amp;quot;subject&amp;quot;:&amp;quot;江西广而易科技有限公司 账户充值&amp;quot;,&amp;quot;body&amp;quot;:&amp;quot;充值金额: 0.01&amp;quot;,&amp;quot;product_code&amp;quot;:&amp;quot;FAST_INSTANT_TRADE_PAY&amp;quot;&#125;\"&gt; &lt;input type=\"submit\" value=\"立即支付\" style=\"display:none\" &gt;&lt;/form&gt;&lt;script&gt;document.forms[0].submit();&lt;/script&gt; 注意 action 链接后面的sign值就是签名字符串, 用于校验数据的来源还有数据有没有被修改 biz_content 是业务参数 html输出到页面后会跳转到支付的支付页面 第四步：扫码支付进行的步骤1.支付 logo 2.支付成功会自动跳转到商户页面(同步通知) 就是前面设置的 alipayRequest.setReturnUrl(“http://www.songshuiyang.site/return_url&quot;);,这部是支付完成之后支付宝的处理程序进行了页面重定向, 不是支付宝主动触发的。 logo 3.系统后台收到异步通知 对于PC网站支付的交易，在用户支付完成之后，支付宝会根据API中商户传入的alipayRequest.setNotifyUrl(“http://www.songshuiyang.site/notify_url&quot;);，通过POST请求的形式将支付结果作为参数通知到商户系统，该方式的作用是页面跳转同步通知没有处理订单更新，需要通过异步通知的方式去通知系统后台更新流水 4.进行异步通知处理 程序执行完后必须打印输出“success”。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）； 处理代码:123456789101112131415//将异步通知中收到的所有参数都存放到map中Map&lt;String, String&gt; paramsMap = ...;//调用SDK验证签名boolean signVerified = AlipaySignature.rsaCheckV1(paramsMap, ALIPAY_PUBLIC_KEY, CHARSET, SIGN_TYPE) if(signVerfied)&#123; // TODO 验签成功后，按照支付结果异步通知中的描述，对支付结果中的业务内容进行二次校验1、商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，2、判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），3、校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方4、验证app_id是否为该商户本身。// 二次校验成功，继续商户自身业务处理，处理完成之后返回success&#125; else &#123; // TODO 验签失败则记录异常日志，并在response中返回failure. &#125; 注意： 这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致延签失败 如果是异步通知处理失败 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付异步通知；需要自己手动向支付宝发送查询请求，根据查询出来的结果确定该交易是否成功 12345678910111213AlipayClient alipayClient = new DefaultAlipayClient(\"https://openapi.alipay.com/gateway.do\",\"app_id\",\"your private_key\",\"json\",\"GBK\",\"alipay_public_key\",\"RSA2\"); //创建查询请求的对应requestAlipayTradeQueryRequest request = new AlipayTradeQueryRequest();request.setBizContent(\"&#123;\" + \"\\\"out_trade_no\\\":\\\"20150320010101001\\\",\" + \"\\\"trade_no\\\":\\\"2014112611001004680073956707\\\"\" + \"&#125;\"); AlipayTradeQueryResponse response = alipayClient.execute(request); if(response.isSuccess())&#123; //交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）、TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）、TRADE_SUCCESS（交易支付成功）、TRADE_FINISHED（交易结束，不可退款） System.out.println(\"调用成功\"); &#125; else &#123; System.out.println(\"调用失败\"); 注意： 这里延签公钥是支付宝公钥, 不是应用公钥, 如果是按照支付宝的示例代码的话很容易填成应用公钥, 导致签名失败 五：支付宝网关支付API 接口英文名 接口中文 alipay.trade.page.pay 统一收单下单并支付页面接口 alipay.trade.refund 统一收单交易退款接口 alipay.trade.fastpay.refund.query 统一收单交易退款查询接口 alipay.trade.query 统一收单线下交易查询接口 alipay.trade.close 统一收单交易关闭接口 alipay.data.dataservice.bill.downloadurl.query 查询对账单下载地址 六： 使用沙箱环境进行测试 蚂蚁沙箱环境(Beta)是协助开发者进行接口功能开发及主要功能联调的辅助环境。沙箱环境模拟了开放平台部分产品的主要功能和主要逻辑（当前沙箱支持产品请参考“沙箱支持产品列表”）。 在开发者应用上线审核前，开发者可以根据自身需求，先在沙箱环境中了解、组合和调试各种开放接口，进行开发调通工作，从而帮助开发者在应用上线审核完成后，能更快速、更顺利的进行线上调试和验收工作。 可以体验一把土豪的感觉, 不用在真实环境下使用一分钱测试联调大法了 七：总结 支付宝的支付接口进行了高度封装，可以拿过来直接使用，不必关心怎样签名&amp;验签、HTTP接口请求这些处理 在进行数据传输通信的同时，需要校验传输数据的来源，数据有没有进行修改，防止恶意数据攻击 注:本文内容参考支付宝开放平台文档内容, 一切以官方文档为准, 链接地址: https://open.alipay.com/platform/home.htm","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"支付","slug":"支付","permalink":"http://www.songshuiyang.site/tags/支付/"}]},{"title":"编程思想笔记","slug":"backend/Java/Java编程思想/第二章-一切皆是对象","date":"2018-01-09T13:24:12.000Z","updated":"2018-07-03T13:19:22.409Z","comments":true,"path":"2018/01/09/backend/Java/Java编程思想/第二章-一切皆是对象/","link":"","permalink":"http://www.songshuiyang.site/2018/01/09/backend/Java/Java编程思想/第二章-一切皆是对象/","excerpt":"","text":"# 用引用操纵对象 在Java的世界里，一切都被视为对象，尽管一切都看成是对象，但操纵的标识符实际上是对象的一个引用,可将这一 情形想象成用遥控板（句柄）操纵电视机（对象）。只要握住这个遥控板，就相当于掌握了与电视机连接的通道。但一旦需要“换频道”或者“关小声音”，我们实际操纵的是遥控板（句柄），再由遥控板自己操纵电视机（对象）。如果要在房间里四处走走，并想保持对电视机的控制，那么手上拿着的是遥控板，而非电视机。12遥控器 --&gt; 电视引用 --&gt; 对象 # 高精度数字1234BigInteger 支持任意精度的整数。也就是说，我们可精确表示任意大小的整数值，同时在运算过程中不会丢失任何信息。BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的币值计算。对应于我们针对主类型执行的操作。也就是说，能对 int 或 float 做的事情，对 BigInteger 和 BigDecimal 一样可以做。只是必须使用方法调用，不能使用运算符。此外，由于牵涉更多，所以运算速度会慢一些。我们牺牲了速度，但换来了精度。 # 基本数据类型默认值类文件的限制 每个文件只能有一个public类, 也可以没有public，如果有的话必须与文件名相同","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Ascii 160空格问题","slug":"backend/Java/ASCII 160 空格","date":"2018-01-09T13:24:12.000Z","updated":"2018-06-21T13:59:50.440Z","comments":true,"path":"2018/01/09/backend/Java/ASCII 160 空格/","link":"","permalink":"http://www.songshuiyang.site/2018/01/09/backend/Java/ASCII 160 空格/","excerpt":"","text":"场景 获取从http传输过来的字符串的时候，碰到解析字符串不能分割字符串的情况12String str = doc.get(0); // str = \"江西省 赣州市\"String [] area = str.spilt(\"\\\\s+\"); 运行上面的代码的时候发现不能截取字符串, 初步怀疑是编码问题，然而经过验证发现并不是,然后就通过字符串截取成 char 字符发现，该char字符ASCII是160,马上查找资料发现是空格分两种编码格式: 1: 普通的空格,ASCII码为32 2:第二种是 网页上的 &amp;nbsp 空格,ASCII为160, 才发现空格也是有多种情况 解决方法:12// 需要将ASCII为160的空格转成普通的空格str = str.replaceAll(\"[\\\\s\\\\u00A0]+\", \" \");","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Mysql 如何设置字段自动获取当前时间","slug":"backend/数据库/Mysql 如何设置字段自动获取当前时间","date":"2017-12-17T03:15:12.000Z","updated":"2018-02-26T12:31:59.790Z","comments":true,"path":"2017/12/17/backend/数据库/Mysql 如何设置字段自动获取当前时间/","link":"","permalink":"http://www.songshuiyang.site/2017/12/17/backend/数据库/Mysql 如何设置字段自动获取当前时间/","excerpt":"","text":"应用场景：1231、在数据表中，要记录每条数据是什么时候创建的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录创建时间；2、在数据库中，要记录每条数据是什么时候修改的，不需要应用程序去特意记录，而由数据数据库获取当前时间自动记录修改时间； 实现方式:123456789--修改CreateTime 设置默认时间 CURRENT_TIMESTAMP ALTER TABLE `table_name`MODIFY COLUMN `created_date` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' ;--修改 UpdateTime 设置 默认时间 CURRENT_TIMESTAMP 设置更新时间为 ON UPDATE CURRENT_TIMESTAMP ALTER TABLE `table_name`MODIFY COLUMN `last_modified_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间' ; 转自：https://www.cnblogs.com/lhj588/p/4245719.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"db","slug":"db","permalink":"http://www.songshuiyang.site/tags/db/"}]},{"title":"Druid Monitor","slug":"backend/数据库/Druid Monitor","date":"2017-12-11T02:24:12.000Z","updated":"2018-02-26T12:31:59.779Z","comments":true,"path":"2017/12/11/backend/数据库/Druid Monitor/","link":"","permalink":"http://www.songshuiyang.site/2017/12/11/backend/数据库/Druid Monitor/","excerpt":"","text":"Druid Monitor监控JavaSE和JavaWeb效果图: logo http://blog.csdn.net/binglovezi/article/details/50610269","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"druid","slug":"druid","permalink":"http://www.songshuiyang.site/tags/druid/"}]},{"title":"Maven 41种骨架","slug":"backend/Maven/maven 骨架","date":"2017-11-18T13:58:45.000Z","updated":"2018-02-26T12:31:59.327Z","comments":true,"path":"2017/11/18/backend/Maven/maven 骨架/","link":"","permalink":"http://www.songshuiyang.site/2017/11/18/backend/Maven/maven 骨架/","excerpt":"","text":"Maven 的41种骨架功能介绍 …&gt;mvn archetype:generate12345678910111213141516171819202122232425262728293031323334353637383940411: internal -&gt; appfuse-basic-jsf (创建一个基于Hibernate，Spring和JSF的Web应用程序的原型) 2: internal -&gt; appfuse-basic-spring (创建一个基于Hibernate，Spring和Spring MVC的Web应用程序的原型) 3: internal -&gt; appfuse-basic-struts (创建一个基于Hibernate，Spring和Struts 2的Web应用程序的原型) 4: internal -&gt; appfuse-basic-tapestry (创建一个基于Hibernate, Spring 和 Tapestry 4的Web应用程序的原型) 5: internal -&gt; appfuse-core (创建一个基于 Hibernate and Spring 和 XFire的jar应用程序的原型) 6: internal -&gt; appfuse-modular-jsf (创建一个基于 Hibernate，Spring和JSF的模块化应用原型) 7: internal -&gt; appfuse-modular-spring (创建一个基于 Hibernate, Spring 和 Spring MVC 的模块化应用原型) 8: internal -&gt; appfuse-modular-struts (创建一个基于 Hibernate, Spring 和 Struts 2 的模块化应用原型) 9: internal -&gt; appfuse-modular-tapestry (创建一个基于 Hibernate, Spring 和 Tapestry 4 的模块化应用原型) 10: internal -&gt; maven-archetype-j2ee-simple (一个简单的J2EE的Java应用程序) 11: internal -&gt; maven-archetype-marmalade-mojo (一个Maven的 插件开发项目 using marmalade) 12: internal -&gt; maven-archetype-mojo (一个Maven的Java插件开发项目) 13: internal -&gt; maven-archetype-portlet (一个简单的portlet应用程序) 14: internal -&gt; maven-archetype-profiles () 15: internal -&gt; maven-archetype-quickstart () 16: internal -&gt; maven-archetype-site-simple (简单的网站生成项目) 17: internal -&gt; maven-archetype-site (更复杂的网站项目) 18: internal -&gt; maven-archetype-webapp (一个简单的Java Web应用程序) 19: internal -&gt; jini-service-archetype (Archetype for Jini service project creation) 20: internal -&gt; softeu-archetype-seam (JSF+Facelets+Seam Archetype) 21: internal -&gt; softeu-archetype-seam-simple (JSF+Facelets+Seam (无残留) 原型) 22: internal -&gt; softeu-archetype-jsf (JSF+Facelets 原型) 23: internal -&gt; jpa-maven-archetype (JPA 应用程序) 24: internal -&gt; spring-osgi-bundle-archetype (Spring-OSGi 原型) 25: internal -&gt; confluence-plugin-archetype (Atlassian 聚合插件原型) 26: internal -&gt; jira-plugin-archetype (Atlassian JIRA 插件原型) 27: internal -&gt; maven-archetype-har (Hibernate 存档) 28: internal -&gt; maven-archetype-sar (JBoss 服务存档) 29: internal -&gt; wicket-archetype-quickstart (一个简单的Apache Wicket的项目) 30: internal -&gt; scala-archetype-simple (一个简单的scala的项目) 31: internal -&gt; lift-archetype-blank (一个 blank/empty liftweb 项目) 32: internal -&gt; lift-archetype-basic (基本（liftweb）项目) 33: internal -&gt; cocoon-22-archetype-block-plain ([http://cocoapacorg2/maven-plugins/]) 34: internal -&gt; cocoon-22-archetype-block ([http://cocoapacorg2/maven-plugins/]) 35: internal -&gt; cocoon-22-archetype-webapp ([http://cocoapacorg2/maven-plugins/]) 36: internal -&gt; myfaces-archetype-helloworld (使用MyFaces的一个简单的原型) 37: internal -&gt; myfaces-archetype-helloworld-facelets (一个使用MyFaces和Facelets的简单原型) 38: internal -&gt; myfaces-archetype-trinidad (一个使用MyFaces和Trinidad的简单原型) 39: internal -&gt; myfaces-archetype-jsfcomponents (一种使用MyFaces创建定制JSF组件的简单的原型) 40: internal -&gt; gmaven-archetype-basic (Groovy的基本原型) 41: internal -&gt; gmaven-archetype-mojo (Groovy mojo 原型) 原文: https://www.cnblogs.com/iusmile/archive/2012/11/14/2770118.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"},{"name":"maven","slug":"maven","permalink":"http://www.songshuiyang.site/tags/maven/"}]},{"title":"Spring Aop","slug":"backend/spring/Spring Aop","date":"2017-11-18T07:47:45.000Z","updated":"2018-02-26T12:31:59.365Z","comments":true,"path":"2017/11/18/backend/spring/Spring Aop/","link":"","permalink":"http://www.songshuiyang.site/2017/11/18/backend/spring/Spring Aop/","excerpt":"Spring Aop一: 概念1. 什么是AOP在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 2. 为什么要用Aop利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。在不改变原有方法的基础添加一些功能 , 比如:日志记录，性能统计，安全控制，事务处理，异常处理等等。","text":"Spring Aop一: 概念1. 什么是AOP在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 2. 为什么要用Aop利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。在不改变原有方法的基础添加一些功能 , 比如:日志记录，性能统计，安全控制，事务处理，异常处理等等。 3. Aop 术语 连接点(JoinPoint) 程序执行到某个特定位置 , Spring 仅支持方法级的连接点(方法执行前，方法完成后，抛出异常后) 切点(Pointcut) 从连接点的基础上引出的概念，是指特定的连接点，一个类有好多方法,每个方法又有多个连接点，则需要切点来限定一个小范围的连接点 通知、增强处理(Advice) 就是指你所需要添加的功能及这个功能什么时候(通知)实现 , 比如一个业务方法需要实现日志功能 , 那么就需要专门在一个地方定义好需要做什么，然后定义什么时候执行(方法执行前？，方法完成后？，抛出异常？。。。) Spring 切面可应用的 5 种通知类型： Before——在方法调用之前调用通知 After——在方法完成之后调用通知，无论方法执行成功与否 After-returning——在方法执行成功之后调用通知 After-throwing——在方法抛出异常后进行通知 Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为 引入(introduction) 特殊的增强，为类添加一些属性和方法 切面(Aspect) 切面由切点和增强组成 , 及包括横切逻辑的定义，也包括切点的定义, 目标对象(Target) 增强逻辑的织入目标类 , 如果没有Aop,那么目标对象就要自己实现(日志记录，性能统计，安全控制，事务处理，异常处理)这些功能，那么一个方法就会变成很杂乱 织入(Weaing) 将增强添加到目标对象的具体连接点上, Spring使用动态代理织入 Aop有三种织入方式 编译期织入 类装载期织入 动态代理织入: 在运行期间为目标类添加增强生成子类的方式二: Spring Aop 的应用 Spring Aop的使用一般通过俩种方式:第一种是通过注解的，第二种是通过xml配置 通过注解的方式实现Aop 第一步 Maven 导包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;parent&gt; &lt;groupId&gt;ecut&lt;/groupId&gt; &lt;artifactId&gt;spring-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ecut&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-aop&lt;/name&gt; &lt;dependencies&gt; &lt;!-- spring 核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- spring aop --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;spring-aop&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--@Override is not allowed when implementing interface method--&gt; &lt;!-- 编码和编译和JDK版本 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;utf8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 第二步 编写一个基于 @AspectJ 的切面 12345678910111213141516171819202122232425262728293031package com.aop.learn.aspectj;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;/** * @author songshuiyang * @title: @Aspect * @description: * @date 2017/11/15 */@Component@Aspect // 通过该注解将该类标识为一个切面public class PreGreetingAspect &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 前置增强, greetTo方法执行前触发此方法 * */ @Before(\"execution(* greetTo(..))\") // 定义切点和增强类型（前置增强,可以带任何参数，和任意的返回值） public void beforeGreeting() &#123; // 增强的横切逻辑 logger.info(\"How are you Aspect 使用了前置增强\"); &#125; &#125; 3: 编写目标对象 Writer.java 接口 12345678910111213package com.aop.learn.service;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */public interface Writer &#123; public void greetTo();&#125; NativeWaiter.java 实现方法12345678910111213141516171819202122232425package com.aop.learn.service.impl;import com.aop.learn.annotation.NeedTest;import com.aop.learn.service.Writer;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */@Servicepublic class NativeWaiter implements Writer &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void greetTo() &#123; logger.info(\"执行方法体: \"); &#125; &#125; 4：Spring配置文件 applicationContext.xml12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;context:component-scan base-package=\"com.aop.learn\"/&gt; &lt;!--基于@AspectJ切面的驱动器,自动为Spring容器中匹配@AspectJ切面的Bean创建代理，完成切面织入--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--&lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt; 表示使用CGLib动态代理技术织入增强--&gt;&lt;/beans&gt; 5: 测试类 测试基类 BaseTest.java123456789101112131415161718192021package com.aop.test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:/spring/applicationContext.xml\")public class BaseTest extends AbstractJUnit4SpringContextTests &#123; public Logger logger = LoggerFactory.getLogger(this.getClass());&#125; 测试类 AspectTest.java 12345678910111213141516171819202122232425262728293031package com.aop.test.service;import com.aop.learn.service.AgentWriter;import com.aop.learn.service.Seller;import com.aop.learn.service.Writer;import com.aop.test.BaseTest;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;/** * @author songshuiyang * @title: 基于spring配置使用@AspectJ切面 * @description: * @date 2017/11/15 */public class AspectTest extends BaseTest &#123; @Autowired private Writer writer; /** * 基于spring配置使用@AspectJ切面 */ @Test public void test1() &#123; writer.greetTo(); &#125;&#125; 6: 效果图,完成 aop增强 logo #### #### #### #### 通过xml schema的方式实现Aop applicationContext-schema.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- aop:config 配置一个基于Schema的切面，aop:config 可以定义多个切面--&gt; &lt;aop:config proxy-target-class=\"true\"&gt; &lt;!--aop:pointcut 配置命名切点,可以被其他增强引用--&gt; &lt;aop:pointcut id=\"greetToPointcut\" expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..))\"/&gt; &lt;aop:pointcut id=\"bindParmPointcut\" expression=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* greetTo(..)) and args(clientName)\"/&gt; &lt;!-- aop:advisor 是切点和增强的复合体,仅包含一个切点和增强--&gt; &lt;aop:advisor advice-ref=\"advisorMethods\" pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* serveTo(..))\"/&gt; &lt;!--aop:aspect 元素标签定义切面,其内部可以定义多个增强--&gt; &lt;aop:aspect ref=\"adviceMethods\"&gt; &lt;!-- aop:before前置增强 method 增强方法， pointcut 切点表达式--&gt; &lt;aop:before method=\"preGreeting\" pointcut-ref=\"greetToPointcut\"/&gt; &lt;!-- aop:before后置增强--&gt; &lt;aop:after-returning method=\"afterGreeting\" pointcut=\"target(com.aop.learn.service.impl.NativeWaiter) and execution (* name(..))\" returning=\"retVal\"/&gt; &lt;!-- 测试绑定连接点信息--&gt; &lt;aop:after method=\"bindParmGreet\" pointcut-ref=\"bindParmPointcut\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!--增强方法所在的Bean--&gt; &lt;bean id=\"adviceMethods\" class=\"com.aop.learn.schema.AdviceMethods\"/&gt; &lt;bean id=\"nativeWaiter\" class=\"com.aop.learn.service.impl.NativeWaiter\"/&gt; &lt;bean id=\"advisorMethods\" class=\"com.aop.learn.schema.AdvisorMethods\"/&gt;&lt;/beans&gt; AdviceMethods.java123456789101112131415161718192021222324252627282930313233343536package com.aop.learn.schema;/** * @author songshuiyang * @title: Schema 用作增强的方法 * @description: * @date 2017/11/18 */public class AdviceMethods &#123; /** * 前置增强 */ public void preGreeting() &#123; System.out.println(\"-------------前置增强\"); &#125; /** * 后置增强 * * @param retVal */ public void afterGreeting(String retVal) &#123; System.out.println(\"-------------后置增强,返回的参数\" + retVal); &#125; /** * 绑定连接点信息 * * @param clientName */ public void bindParmGreet(String clientName) &#123; System.out.println(\"-------------绑定连接点信息 的参数\" + clientName); &#125;&#125; NativeWaiter.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.aop.learn.service.impl;import com.aop.learn.annotation.NeedTest;import com.aop.learn.service.Writer;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;/** * @author songshuiyang * @title: * @description: * @date 2017/11/15 */@Servicepublic class NativeWaiter implements Writer &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Override public void greetTo(String clientName) &#123; logger.info(\"-------------greetTo \" + clientName); &#125; @Override public void greetTo(String clientName, Integer age) &#123; logger.info(\"-------------greetTo \" + clientName + \" \" + age + \"岁\"); &#125; @Override public void serveTo(String clientName) &#123; logger.info(\"-------------serveTo \" + clientName); &#125; @Override @NeedTest() public void nestTo() &#123; logger.info(\"开始执行 nestTo() 函数\"); &#125; @Override public String name() &#123; return \"宋水阳\"; &#125; @Override public void throwExcetion() &#123; throw new IllegalArgumentException(\"抛出异常了\"); &#125;&#125; AdvisorMethods.java1234567891011121314151617181920package com.aop.learn.schema;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;/** * @author songshuiyang * @title: aop:advisor 是切点和增强的复合体,仅包含一个切点和增强 * @description: * @date 2017/11/18 */public class AdvisorMethods implements MethodBeforeAdvice &#123; @Override public void before(Method method, Object[] args, Object taget) throws Throwable &#123; System.out.println(\"--------------执行aop:advisor增强----------------\"); System.out.println(\"获取的参数\" + args[0]); &#125;&#125;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"myBatis笔记","slug":"backend/mybatis/mybatis笔记","date":"2017-11-14T13:59:44.000Z","updated":"2018-02-26T12:31:59.583Z","comments":true,"path":"2017/11/14/backend/mybatis/mybatis笔记/","link":"","permalink":"http://www.songshuiyang.site/2017/11/14/backend/mybatis/mybatis笔记/","excerpt":"","text":"mybatis foreach标签 foreach 标签中 item属性名如果和其他参数中同名(如以下代码:item=”id” 和 if test=”id != null” 同名),即使没有传入id参数,SQL也会执行 AND id = #{id} mapper文件:123456789101112131415&lt;select id=\"findPageList\" parameterType=\"map\" resultType=\"user\"&gt; SELECT * FROM user &lt;where&gt; &lt;if test=\"IN_id != null\"&gt; id IN &lt;foreach collection=\"IN_id\" index=\"index\" item=\"id\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;if test=\"id != null\"&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; dao层1List&lt;User&gt; findPageList(Map&lt;String, Object&gt; map); 测试方法12345678910@Testpublic void test2() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); List&lt;Integer&gt; idList = new ArrayList&lt;Integer&gt;(); idList.add(1); idList.add(4); idList.add(5); map.put(\"IN_id\", idList); userMapper.findPageList(map);&#125; 结果123==&gt; Preparing: SELECT * FROM user WHERE id IN ( ? , ? , ? ) AND id = ? ==&gt; Parameters: 1(Integer), 4(Integer), 5(Integer), 5(Integer)&lt;== Total: 1","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.songshuiyang.site/tags/mybatis/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring Aop execution","slug":"backend/spring/Spring Aop execution","date":"2017-11-07T14:47:45.000Z","updated":"2018-11-13T11:59:09.761Z","comments":true,"path":"2017/11/07/backend/spring/Spring Aop execution/","link":"","permalink":"http://www.songshuiyang.site/2017/11/07/backend/spring/Spring Aop execution/","excerpt":"execution() 是最常见的切点函数,语法形式为1excution(&lt;修饰符模式&gt; ? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?)","text":"execution() 是最常见的切点函数,语法形式为1excution(&lt;修饰符模式&gt; ? &lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?) 有代码有真相:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.aop.learn.aspectj;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;/** * @author songshuiyang * @title: execution() 实例 * @description: * @date 2017/11/15 23:05 */@Aspect@Componentpublic class ExecutionAspect &#123; /** * 匹配所有目标类的public方法 */ @Before(\"execution(public * *(..))\") /** * 匹配所有以To为后缀的方法 */ @Before(\"execution(* *To(..))\") /** * 匹配Waiter接口中的所有方法 */ @Before(\"execution(* com.aop.learn.service.Writer.*(..))\") /** * 匹配Waiter接口中及其实现类的方法 */ @Before(\"execution(* com.aop.learn.service.Writer+.*(..))\") /** * 匹配 com.aop.learn.service 包下所有类的所有方法 */ @Before(\"execution(* com.aop.learn.service.*(..))\") /** * 匹配 com.aop.learn.service 包,子孙包下所有类的所有方法 */ @Before(\"execution(* com.aop.learn.service..*(..))\") /** * 匹配 包名前缀为com的任何包下类名后缀为ive的方法,方法必须以Smart为前缀 */ @Before(\"execution(* com..*.*ive.Smart*(..))\") /** * 匹配 save(String name,int age) 函数 */ @Before(\"execution(* save(String,int))\") /** * 匹配 save(String name,*) 函数 第二个参数为任意类型 */ @Before(\"execution(* save(String,*))\") /** * 匹配 save(String name,..) 函数 除第一个参数固定外,接受后面有任意个入参且入参类型不限 */ @Before(\"execution(* save(String,..))\") /** * 匹配 save(String+) 函数 String+ 表示入参类型是String的子类 */ @Before(\"execution(* save(String+))\") /** * 最详细的切入点表达式 具体到包、类名、方法名、方法返回值、参数个数及类型类型 */ @Before(\"execution(public void com.bwlu.aop.MathCalculator.add(int, int))\") /** * 最模糊的切入点表达式 */ @Before(\"execution (* *.*(..))\") /** * MathCalculator中的任意方法,任意参数列表 */ @Before(\"execution(public void com.bwlu.aop.MathCalculator.*(..))\") /** * MathCalculator中的任意方法,任意参数列表，任意返回值 */ @Before(\"execution(public * com.bwlu.aop.MathCalculator.*(..))\") /** * MathCalculator中的任意方法,任意参数列表，任意返回值，任意访问修饰符 */ @Before(\"execution( * com.bwlu.aop.MathCalculator.*(..))\")","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring Task","slug":"backend/spring/Spring Task","date":"2017-11-07T14:47:45.000Z","updated":"2018-02-26T12:31:59.384Z","comments":true,"path":"2017/11/07/backend/spring/Spring Task/","link":"","permalink":"http://www.songshuiyang.site/2017/11/07/backend/spring/Spring Task/","excerpt":"Spring Task spring task作为定时任务的处理,是Spring自带的一个设定时间自动任务调度,提供了两种方式进行配置，一种是注解的方式，而另外一种就是XML配置方式了。","text":"Spring Task spring task作为定时任务的处理,是Spring自带的一个设定时间自动任务调度,提供了两种方式进行配置，一种是注解的方式，而另外一种就是XML配置方式了。 基于XML配置文件的方式 applicationContext.xml12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd\"&gt; &lt;!--使用配置文件的方式,注册 xmlTaskJob bean中的job1方法,每隔一秒执行 --&gt; &lt;task:scheduled-tasks&gt; &lt;task:scheduled ref=\"xmlTaskJob\" method=\"job1\" cron=\"*/1 * * * * ?\"/&gt; &lt;/task:scheduled-tasks&gt; &lt;context:component-scan base-package=\"com.learn.schedule.service\"/&gt;&lt;/beans&gt; XmlTaskJob.Java12345678910111213141516171819202122package com.learn.schedule.service;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;/** * @author songshuiyang * @title: 基于xml文件配置的定时任务 * @description: * @date 2017/11/7 22:20 */@Servicepublic class XmlTaskJob &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); public void job1() &#123; logger.info(\"基于xml文件配置的定时任务，每隔一秒执行\"); &#125;&#125; Test.java1234567891011/** * @author songshuiyang * @title: * @description: * @date 2017/11/7 22:45 */public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:/spring/applicationContext.xml\"); &#125;&#125; 基于注解配置文件的方式更简单 applicationContext.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd\"&gt; &lt;!-- 启动定时器 基于注解--&gt; &lt;task:annotation-driven/&gt; &lt;context:component-scan base-package=\"com.learn.schedule.service\"/&gt;&lt;/beans&gt; AnnotationTaskJob.Java12345678910111213141516171819202122package com.learn.schedule.service;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;/** * @author songshuiyang * @title: 基于注解配置的定时任务 * @description: * @date 2017/11/7 22:42 */@Componentpublic class AnnotationTaskJob &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Scheduled(cron = \"*/2 * * * * ?\") //每2秒执行一次 public void job() &#123; logger.info(\"基于注解配置的定时任务，每隔俩秒执行\"); &#125;&#125; 效果: logo","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Spring","slug":"backend/spring/学习笔记","date":"2017-10-24T14:23:44.000Z","updated":"2018-02-26T12:31:59.535Z","comments":true,"path":"2017/10/24/backend/spring/学习笔记/","link":"","permalink":"http://www.songshuiyang.site/2017/10/24/backend/spring/学习笔记/","excerpt":"","text":"轻量级(重量级)的框架 轻量级框架和重量级框架的区别是什么？很多人以为是以框架之间的耦合性强弱作为判断标准。其实不然，实际上是以启动程序需要的资源来决定。比如，EJB启动的时候，需要消耗大量的资源，内存，CPU等，所以是重量级。而Spring则不，所以是轻量级框架。就是看加载的资源 spring也不能说是轻量级的 EJB默认在应用启动的时候把所有资源和服务都加载进来而spring则是你定制服务 需要什么开什么 如果把spring的所有服务都用上的话 可以认为你是用了一个重量级的框架 实质还是看框架所需要的系统资源大小. IOC 底层原理使用到的技术 xml配置文件 &lt;bean id=&quot;user&quot; class=&quot;java.com.ecut.User&quot;&gt; dom4j解析xml配置文件 工厂设计模式 反射","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Git初始配置","slug":"backend/编译构建部署版本工具/git/git初始配置","date":"2017-10-22T02:45:12.000Z","updated":"2018-02-26T12:31:59.951Z","comments":true,"path":"2017/10/22/backend/编译构建部署版本工具/git/git初始配置/","link":"","permalink":"http://www.songshuiyang.site/2017/10/22/backend/编译构建部署版本工具/git/git初始配置/","excerpt":"","text":"使用Git的前的初始配置1. 配置提交时的用户名与邮件名称(注:只是标识本次commit是谁提交的)1.1 通过命令的方式1234$ git config --global user.name \"songshuiyang\"$ git config --global user.email songshiuyang@foxmail.com注: global 全局配置,在此电脑上的所有项目的git提交都会用这个用户名和邮件 1.2 通过修改配置文件的方式 12345文件路径: 用户目录/.gitconfig 文件把name email改成(新增)自己的配置即可[user] name = songshuiyang email = songshiuyang@foxmail.com 2. 配置 短命令2.1 通过命令的方式1234$ git config --global alias.st status$ git config --global alias.ci commit$ git congig --global alias.co checkout$ git congig --global alias.br branch 2.2 通过修改配置文件的方式123456789101112131415[alias] co = checkout ci = commit st = status cm = commit -m br = branch bm = branch -m bd = branch -D cb = checkout -b df = diff ls = log --stat lp = log -p plo = pull origin plode = pull origin develop pho = push origin 3. 配置文件 Git的三个配置文件 版本库级别的配置文件,文件路径: 项目路径/.git/config 全局配置文件, 文件路径: 用户目录/.gitconfig 系统级配置文件,文件路径: 安装目录/etc目录下 优先级: 版本库级别的配置文件 &gt; 全局配置文件 &gt; 系统级配置文件 4. 文件 .git/index实际上就是一个包括文件索引的目录树,像是一个虚拟的工作区,记录了文件名和文件的状态信息(时间戳和文件长度),文件的内容保存在.git/objects目录下,文件索引建立了文件和对象库中对象实体之间的对应 工作区,版本区,暂存区原理图 git","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.songshuiyang.site/tags/git/"}]},{"title":"编译构建部署版本工具","slug":"backend/编译构建部署版本工具/git/如何修改Git commit的信息","date":"2017-10-14T08:38:12.000Z","updated":"2018-06-06T13:06:57.974Z","comments":true,"path":"2017/10/14/backend/编译构建部署版本工具/git/如何修改Git commit的信息/","link":"","permalink":"http://www.songshuiyang.site/2017/10/14/backend/编译构建部署版本工具/git/如何修改Git commit的信息/","excerpt":"","text":"转自：http://www.cnblogs.com/shenh062326/p/git.html","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www.songshuiyang.site/tags/git/"}]},{"title":"Hibernate Validator","slug":"backend/Hibernate/Hibernate Validator","date":"2017-10-14T04:28:12.000Z","updated":"2018-02-26T12:31:59.018Z","comments":true,"path":"2017/10/14/backend/Hibernate/Hibernate Validator/","link":"","permalink":"http://www.songshuiyang.site/2017/10/14/backend/Hibernate/Hibernate Validator/","excerpt":"","text":"Hibernate ValidatorHibernate Validator 是 Bean Validation 的参考实现 。Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。 1. Bean Validation 中内置的 constraint 注解 作用 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 2. Hibernate Validator 附加的 constraint 注解 作用 @Email 被注释的元素必须是电子邮箱地址 @Length(min=, max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=, max=) 被注释的元素必须在合适的范围内 @NotBlank 被注释的字符串的必须非空 @URL(protocol=,host=, port=, regexp=, flags=) 被注释的字符串必须是一个有效的url @CreditCardNumber 被注释的字符串必须通过Luhn校验算法， 银行卡，信用卡等号码一般都用Luhn 计算合法性 @ScriptAssert (lang=, script=, alias=) 要有Java Scripting API 即JSR 223 (“Scripting for the JavaTM Platform”)的实现 @SafeHtml(whitelistType=, additionalTags=) classpath中要有jsoup包 举个栗子123456789101112131415161718192021222324252627282930public class User &#123; @NotBlank private String name; //年龄要大于18岁 @Min(18) private int age; @Email private String email; //嵌套验证 @Valid private Product products; ... //省略getter，setter &#125; public class Product &#123; @NotBlank private String name; //价格在10元-50元之间 @Range(min=10,max=50) private int price; ... //省略getter，setter &#125; 转自:http://blog.csdn.net/u011851478/article/details/51842157","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"编译构建部署版本工具","slug":"backend/编译构建部署版本工具/grandle","date":"2017-10-13T17:07:12.000Z","updated":"2018-02-26T12:31:59.953Z","comments":true,"path":"2017/10/14/backend/编译构建部署版本工具/grandle/","link":"","permalink":"http://www.songshuiyang.site/2017/10/14/backend/编译构建部署版本工具/grandle/","excerpt":"","text":"Grandle gradle 易百教程http://www.yiibai.com/gradle/ Gradle学习系列之一——Gradle快速入门http://www.cnblogs.com/CloudTeng/p/3417762.html android grandlehttp://www.jianshu.com/p/9df3c3b6067a","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"github","slug":"technology/github","date":"2017-10-08T14:10:12.000Z","updated":"2018-03-16T14:41:21.170Z","comments":true,"path":"2017/10/08/technology/github/","link":"","permalink":"http://www.songshuiyang.site/2017/10/08/technology/github/","excerpt":"","text":"watch、star、fork 的使用watch 对于别人的项目，默认自己都处于 Not watching 的状态，当你选择 Watching，表示你以后会关注这个项目的所有动态，这个项目以后只要发生变动，如被别人提交了 pull request、被别人发起了issue等等情况，你都会在自己的个人通知中心，收到一条通知消息，如果你设置了个人邮箱，那么你的邮箱也可能收到相应的邮件。 star 当你点击 star，表示你喜欢这个项目或者通俗点，可以把他理解成朋友圈的点赞吧，表示对这个项目的支持 fork 当选择 fork，相当于你自己有了一份原项目的拷贝，当然这个拷贝只是针对当时的项目文件，如果后续原项目文件发生改变，你必须通过其他的方式去同步（注意）。","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"计算属性","slug":"frontend/计算属性","date":"2017-10-05T02:52:12.000Z","updated":"2018-02-26T12:31:58.991Z","comments":true,"path":"2017/10/05/frontend/计算属性/","link":"","permalink":"http://www.songshuiyang.site/2017/10/05/frontend/计算属性/","excerpt":"","text":"计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125;","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.songshuiyang.site/tags/vue/"}]},{"title":"v-model v-bind","slug":"frontend/v-model和v-bind的区别","date":"2017-10-05T02:12:12.000Z","updated":"2018-02-26T12:31:58.979Z","comments":true,"path":"2017/10/05/frontend/v-model和v-bind的区别/","link":"","permalink":"http://www.songshuiyang.site/2017/10/05/frontend/v-model和v-bind的区别/","excerpt":"","text":"Mustache (双大括号写法)不能在 HTML 属性中使用，应使用 v-bind 指令：1&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt; 这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除：1&lt;button v-bind:disabled=&quot;someDynamicCondition&quot;&gt;Button&lt;/button&gt; v-bind动态绑定指令，默认情况下标签自带属性的值是固定的，在为了能够动态的给这些属性添加值，可以使用v-bind:你要动态变化的值=”表达式” v-bind用于绑定属性和数据 ，其缩写为“ : ” 也就是v-bind:id === :id v-model用在表单控件上的，用于实现双向数据绑定，所以如果你用在除了表单控件以外的标签是没有任何效果的。 v-bind1234567891011121314151617181920212223&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=&quot;imageSrc&quot;&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot;&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&apos;/path/to/images/&apos; + fileName&quot;&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt;&lt;!-- style 绑定 --&gt;&lt;div :style=&quot;&#123; fontSize: size + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt;&lt;!-- 绑定一个有属性的对象 --&gt;&lt;div v-bind=&quot;&#123; id: someProp, &apos;other-attr&apos;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;&lt;div v-bind:text-content.prop=&quot;text&quot;&gt;&lt;/div&gt;&lt;!-- prop 绑定。“prop”必须在 my-component 中声明。--&gt;&lt;my-component :prop=&quot;someThing&quot;&gt;&lt;/my-component&gt;&lt;!-- 通过 $props 将父组件的 props 一起传给子组件 --&gt;&lt;child-component v-bind=&quot;$props&quot;&gt;&lt;/child-component&gt;&lt;!-- XLink --&gt;&lt;svg&gt;&lt;a :xlink:special=&quot;foo&quot;&gt;&lt;/a&gt;&lt;/svg&gt;","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.songshuiyang.site/tags/vue/"}]},{"title":"Vue.js","slug":"frontend/Vue","date":"2017-10-03T14:40:12.000Z","updated":"2018-02-26T12:31:58.934Z","comments":true,"path":"2017/10/03/frontend/Vue/","link":"","permalink":"http://www.songshuiyang.site/2017/10/03/frontend/Vue/","excerpt":"前缀 $，实例属性与方法这些只是Vue的命名规则，为了缺分普通变量属性，避免我们自己声明或者添加自定义属性导致覆 生命周期beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载","text":"前缀 $，实例属性与方法这些只是Vue的命名规则，为了缺分普通变量属性，避免我们自己声明或者添加自定义属性导致覆 生命周期beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 生命周期 lifecyc 生命周期钩子 Lifecycle 钩子函数 钩子函数就是指再所有函数执行前，我先执行了的函数，即 钩住 我感兴趣的函数，只要它执行，我就先执行,这个解释666 双向绑定v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定。 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。 数据如果你知道你会在晚些时候需要一个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如： 1234567data: &#123; newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null&#125; 一个对象的 v-for123&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 12345678910new Vue(&#123; el: &apos;#v-for-object&apos;, data: &#123; object: &#123; firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, age: 30 &#125; &#125;&#125;) 索引 key value 123&lt;div v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 123456789101112&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身 (比如不是子元素) 触发时触发回调 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt; vue模板只能有一个根对象1234&lt;template&gt; &lt;h2&gt;底部&lt;/h2&gt; &lt;span v-text=\"msgFromFather\"&gt;&lt;/span&gt;&lt;/template&gt; 报错1Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 原来vue模板只能有一个根对象所以你想要出现正常的效果，你的用一个div来或是别的标签来包裹全部的元素123456&lt;template&gt; &lt;div&gt; &lt;h2&gt;底部&lt;/h2&gt; &lt;span v-text=\"msgFromFather\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.songshuiyang.site/tags/vue/"}]},{"title":"其他插件","slug":"technology/其他插件","date":"2017-10-01T06:31:12.000Z","updated":"2017-10-01T06:45:36.150Z","comments":true,"path":"2017/10/01/technology/其他插件/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/technology/其他插件/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"嵌入网易云插件","slug":"essay/网易云","date":"2017-10-01T06:31:12.000Z","updated":"2018-03-11T11:21:16.779Z","comments":true,"path":"2017/10/01/essay/网易云/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/essay/网易云/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.songshuiyang.site/categories/随笔/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"增加畅言功能","slug":"technology/增加畅言功能","date":"2017-10-01T05:31:12.000Z","updated":"2017-10-01T06:10:46.922Z","comments":true,"path":"2017/10/01/technology/增加畅言功能/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/technology/增加畅言功能/","excerpt":"","text":"畅言- 专业的社会化评论系统 网址:https://changyan.kuaizhan.com/ 添加功能: 根据上面的网址注册 复制 畅言秘钥(SourceID) 复制以下代码，并粘贴到您网页源代码的123456789```aidl&lt;div id=&quot;SOHUCS&quot; sid=&quot;请将此处替换为配置SourceID的语句&quot;&gt;&lt;/div&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;https://changyan.sohu.com/upload/changyan.js&quot; &gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.changyan.api.config(&#123;appid: &apos;cytf5fPKF&apos;,conf: &apos;prod_ee3a22e2c13174e193691fbc93e3cbc8&apos;&#125;);&lt;/script&gt; 效果: view 网站需要备案,不然只有15天的试用期: ICP备案： 只要网站在国内不管网站大小都需要在工信部网站在线申请备案号，但提供的审核资料可能就是不真实的，因为工信部不会去实际的核实。工信部要求的仅仅是有备案号即视为合法网站","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"nodeJs","slug":"frontend/nodeJs","date":"2017-10-01T03:48:12.000Z","updated":"2018-02-26T12:31:58.947Z","comments":true,"path":"2017/10/01/frontend/nodeJs/","link":"","permalink":"http://www.songshuiyang.site/2017/10/01/frontend/nodeJs/","excerpt":"","text":"Node.jsNode.js 让 JavaScript 编写服务器端应用程序成为可能。它建立在 JavaScript V8（C++ 编写的） 运行时之上，所以它很快。最初，它旨在为应用程序提供服务器环境，但是开发人员开始利用它来创建工具，帮助他们本地的任务自动化。此后，一个全新基于 Node 工具（如 Grunt 和 Gulp）的生态系统，使得前端开发改头换面。 要使用 Node.js 中的这些工具（或包），我们需要一种有效的方式来安装和管理它们。这就要用到node 包管理器： npm 了。它能够安装你想要的包，而且提供一个强大接口来使用它们。在使用 npm 之前，首先得在系统上安装 Node.js。 NPM（node package manager）node包管理器 将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 package.json包描述信息如果我们的项目依赖了很多package，一个一个地安装那将是个体力活。我们可以将项目依赖的包都在package.json这个文件里声明，然后一行命令搞定 1npm install 安装方式本地安装：package会被下载到当前所在目录，也只能在当前目录下使用。 全局安装：package会被下载到到特定的系统目录下，安装的package能够在所有目录下使用。’ devDependencies和dependencies的区别使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如： –save-dev –save 但是当安装新包的时候如何让它保持最新呢？我们可以使用 –save 标识。 在 package.json 文件里面提现出来的区别就是，使用 –save-dev 安装的 插件，被写入到 devDependencies 对象里面去，而使用 –save 安装的插件，责被写入到 dependencies 对象里面去。 那 package.json 文件里面的 devDependencies 和 dependencies 对象有什么区别呢？ devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"node","slug":"node","permalink":"http://www.songshuiyang.site/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://www.songshuiyang.site/tags/npm/"}]},{"title":"枚举类","slug":"backend/Java/枚举类","date":"2017-09-29T15:32:12.000Z","updated":"2018-02-26T12:31:59.185Z","comments":true,"path":"2017/09/29/backend/Java/枚举类/","link":"","permalink":"http://www.songshuiyang.site/2017/09/29/backend/Java/枚举类/","excerpt":"","text":"枚举是用来构建常量数据结构的模板，这个模板可扩展。枚举的使用增强了程序的健壮性 1. 常量12345public enum Color &#123; RED, GREEN, BLANK, YELLOW &#125; 2. switch1234567891011121314151617181920212223public class B &#123; public static void main(String[] args) &#123; showColor( Color.RED ); &#125; static void showColor(Color color)&#123; switch ( color ) &#123; case BLANK: System.out.println( color ); break; case RED : System.out.println( color ); break; default: System.out.println( color ); break; &#125; &#125;&#125; 3. 自定义函数public enum Color { RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4); private String name ; private int index ; private Color( String name , int index ){ this.name = name ; this.index = index ; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getIndex() { return index; } public void setIndex(int index) { this.index = index; }","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Spring Assert","slug":"backend/spring/Assert 的学习","date":"2017-09-28T16:01:44.000Z","updated":"2018-02-26T12:31:59.350Z","comments":true,"path":"2017/09/29/backend/spring/Assert 的学习/","link":"","permalink":"http://www.songshuiyang.site/2017/09/29/backend/spring/Assert 的学习/","excerpt":"","text":"Assert（当要判断一个方法传入的参数时，我们就可以使用断言。） package org.springframework.util 1. notNull(Object object)当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null； 2. isTrue(boolean expression) / isTrue(boolean expression, String message)当 expression 不为 true 抛出异常； 3. notEmpty(Collection collection) / notEmpty(Collection collection, String message)当集合未包含元素时抛出异常。 notEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断； 4. hasLength(String text) / hasLength(String text, String message)当 text 为 null 或长度为 0 时抛出异常； 5. hasText(String text) / hasText(String text, String message)text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常； 6. isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message)如果 obj 不能被正确造型为 clazz 指定的类将抛出异常； 7. isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message)subType 必须可以按类型匹配于 superType，否则将抛出异常；","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"}]},{"title":"Hibernate 问题记录","slug":"backend/Hibernate/hibernate问题集合","date":"2017-09-24T08:54:12.000Z","updated":"2018-02-26T12:31:59.070Z","comments":true,"path":"2017/09/24/backend/Hibernate/hibernate问题集合/","link":"","permalink":"http://www.songshuiyang.site/2017/09/24/backend/Hibernate/hibernate问题集合/","excerpt":"","text":"org.hibernate.MappingException: Unknown entity常见问题 可能原因一 检查实体类是否导入的是 javax.persistence 下的包 可能原因二 没有在cfg文件中加入 *.hbm.xml造成的 hibernate版本问题,一代版本一代神 4.5 版本 1ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).build(); 5.2 版本 1ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build();","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"Hibernate 例子","slug":"backend/Hibernate/Hibernate","date":"2017-09-23T15:28:12.000Z","updated":"2018-02-26T12:31:59.041Z","comments":true,"path":"2017/09/23/backend/Hibernate/Hibernate/","link":"","permalink":"http://www.songshuiyang.site/2017/09/23/backend/Hibernate/Hibernate/","excerpt":"概述: 面向Java环境的对象/关系数据库映射工具,用于将面向对象模型表示的对象映射到基于SQL的关系模型的数据结构中,消除那些针对特定数据库厂商的SQL代码,并把结果集从表格式的形式转换成值对象的形式","text":"概述: 面向Java环境的对象/关系数据库映射工具,用于将面向对象模型表示的对象映射到基于SQL的关系模型的数据结构中,消除那些针对特定数据库厂商的SQL代码,并把结果集从表格式的形式转换成值对象的形式 Hibernate的数据库操作直接采用了POJO(普通的传统的Java对象)作为持久化类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.hibernate.entity;import javax.persistence.*;/** * @author songshuiyang * @title: * @description: * @date 2017/9/23 23:41 */@Entity /*标明持久化类*/@Table(name = &quot;user&quot;)public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键生成策略 private String id; private String name; private int sex; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getSex() &#123; return sex; &#125; public void setSex(int sex) &#123; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&apos;&quot; + id + &apos;\\&apos;&apos; + &quot;, name=&apos;&quot; + name + &apos;\\&apos;&apos; + &quot;, sex=&quot; + sex + &apos;&#125;&apos;; &#125;&#125; Hibernate基本上是使用了JPA的标准注解(javax.persistence) JPA JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。 JPA是一种规范，而Hibernate是它的一种实现。除了Hibernate，还有EclipseLink(曾经的toplink)，OpenJPA等可供选择，所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。 配置文件 (#.properties , XML配置文件的形式)1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 指定连接数据库所用的驱动 --&gt; &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 指定连接数据库的url，其中hibernate是本应用连接的数据库名 --&gt; &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost/ecut&lt;/property&gt; &lt;!-- 指定连接数据库的用户名 --&gt; &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt; &lt;!-- 指定连接数据库的密码 --&gt; &lt;property name=&quot;connection.password&quot;&gt;root&lt;/property&gt; &lt;!-- 指定连接池里最大连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.max_size&quot;&gt;20&lt;/property&gt; &lt;!-- 指定连接池里最小连接数 --&gt; &lt;property name=&quot;hibernate.c3p0.min_size&quot;&gt;1&lt;/property&gt; &lt;!-- 指定连接池里连接的超时时长 --&gt; &lt;property name=&quot;hibernate.c3p0.timeout&quot;&gt;5000&lt;/property&gt; &lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt; &lt;property name=&quot;hibernate.c3p0.max_statements&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.acquire_increment&quot;&gt;2&lt;/property&gt; &lt;property name=&quot;hibernate.c3p0.validate&quot;&gt;true&lt;/property&gt; &lt;!-- 指定数据库方言 --&gt; &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!-- 根据需要自动创建数据表 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt;&lt;!--①--&gt; &lt;!-- 显示Hibernate持久化操作所生成的SQL --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!-- 将SQL脚本进行格式化后再输出 --&gt; &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; &lt;mapping class=&quot;com.hibernate.entity.User&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 测试方法1234567891011121314151617181920212223242526public class UserManagerTest &#123; @Test public void test1()&#123; // 实例化Configuration， Configuration conf = new Configuration().configure(); ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(conf.getProperties()).configure().build(); // 以Configuration实例创建SessionFactory实例 SessionFactory sf = conf.buildSessionFactory(serviceRegistry); // 创建Session Session sess = sf.openSession(); // 开始事务 Transaction tx = sess.beginTransaction(); // 创建消息对象 User user = new User(); // 设置消息标题和消息内容 user.setName(&quot;hibernate&quot;); user.setSex(12); sess.save(user); // 提交事务 tx.commit(); // 关闭Session sess.close(); sf.close(); &#125;&#125;","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"Hibernate笔记","slug":"backend/Hibernate/Hibernate笔记","date":"2017-09-23T15:28:12.000Z","updated":"2018-02-26T12:31:59.068Z","comments":true,"path":"2017/09/23/backend/Hibernate/Hibernate笔记/","link":"","permalink":"http://www.songshuiyang.site/2017/09/23/backend/Hibernate/Hibernate笔记/","excerpt":"","text":"hibernate.properties 使用 hibernate.properties 文件配置Hibernate 需要在代码里面手动添加持久化类,所以在实际开发中不使用hibernate.property 文件作为配置文件的原因","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.songshuiyang.site/tags/Hibernate/"}]},{"title":"Java位运算","slug":"backend/Java/Java位运算","date":"2017-09-22T11:24:12.000Z","updated":"2018-02-26T12:31:59.097Z","comments":true,"path":"2017/09/22/backend/Java/Java位运算/","link":"","permalink":"http://www.songshuiyang.site/2017/09/22/backend/Java/Java位运算/","excerpt":"","text":"与运算符 &amp;int a=129; int b=128; a &amp; b = 128 解析: “a”的值是129，转换成二进制就是10000001，而“b”的值是128，转换成二进制就是10000000。根据与运算符的运算规律，只有两个位都是1，结果才是1，可以知道结果就是10000000，即128。 或运算 |int a=129; int b=128; a &amp; b = 129 解析: a 的值是129，转换成二进制就是10000001，而b 的值是128，转换成二进制就是10000000，根据或运算符的运算规律，只有两个位有一个是1，结果才是1，可以知道结果就是10000001，即129。 非运算符 ~如果位为0，结果是1，如果位为1，结果是0 异或运算符 ^异或运算符是用符号“^”表示的，其运算规律是： 两个操作数的位中，相同则结果为0，不同则结果为1。下面看一个简单的例子。 int a=15; int b=2; a^b a 与 b 异或的结果是：13 分析上面的程序段：a 的值是15，转换成二进制为1111，而b 的值是2，转换成二进制为0010，根据异或的运算规律，可以得出其结果为1101 即13。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java移位运算","slug":"backend/Java/Java移位运算","date":"2017-09-22T11:00:12.000Z","updated":"2018-02-26T12:31:59.158Z","comments":true,"path":"2017/09/22/backend/Java/Java移位运算/","link":"","permalink":"http://www.songshuiyang.site/2017/09/22/backend/Java/Java移位运算/","excerpt":"","text":": 右移运算符 ```1234567891011 res = 20 &gt;&gt; 2; 20的二进制为 0001 0100，右移2位后为 0000 0101，则结果就为 res = 5;res = -20 &gt;&gt; 2;-20的二进制为其正数的补码加1，即 1110 1011，右移2位后为 1111 1100，结果为 res = -6; ``` &lt;&lt; : 左移运算符 &lt;&lt; 是与&gt;&gt;对应的左移运算符，表示将exp1向左移动exp2位，在低位补0。其实，向左移动n位，就相当于乘以2^n。 &gt;&gt;&gt; : 无符号右移 res = 20 &gt;&gt;&gt; 2; 的结果与 &gt;&gt; 相同； res = -20 &gt;&gt; 2; -20的二进制为 1110 1011，右移2位，此时高位补0，即 0011 1010，结果为 res = 58; 也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java 遍历Map","slug":"backend/Java/Java遍历Map","date":"2017-09-22T11:00:12.000Z","updated":"2018-02-26T12:31:59.177Z","comments":true,"path":"2017/09/22/backend/Java/Java遍历Map/","link":"","permalink":"http://www.songshuiyang.site/2017/09/22/backend/Java/Java遍历Map/","excerpt":"","text":"Java中如何遍历Map对象的4种方法 既然java中的所有map都实现了Map接口，以下方法适用于任何map实现（HashMap, TreeMap, LinkedHashMap, Hashtable, 等等） 方法一: 在for-each循环中使用entries来遍历 这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用1234567Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); &#125; 注意：for-each循环在java 5中被引入所以该方法只能应用于java 5或更高的版本中。如果你遍历的是一个空的map对象，for-each循环将抛出NullPointerException，因此在遍历前你总是应该检查空引用。 方法二: 在for-each循环中遍历keys或values。 如果只需要map中的键或者值，你可以通过keySet或values来实现遍历，而不是用entrySet。1234567891011121314151617Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //遍历map中的键 for (Integer key : map.keySet()) &#123; System.out.println(\"Key = \" + key); &#125; //遍历map中的值 for (Integer value : map.values()) &#123; System.out.println(\"Value = \" + value); &#125; 该方法比entrySet遍历在性能上稍好（快了10%），而且代码更加干净。 方法三: 使用Iterator遍历 使用泛型：1234567891011Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = entries.next(); System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue()); &#125; 不使用泛型:123456789101112131415Map map = new HashMap(); Iterator entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry entry = (Map.Entry) entries.next(); Integer key = (Integer)entry.getKey(); Integer value = (Integer)entry.getValue(); System.out.println(\"Key = \" + key + \", Value = \" + value); &#125; 你也可以在keySet和values上应用同样的方法。 该种方式看起来冗余却有其优点所在。首先，在老版本java中这是惟一遍历map的方式。另一个好处是，你可以在遍历时调用iterator.remove()来删除entries，另两个方法则不能。根据javadoc的说明，如果在for-each遍历中尝试使用此方法，结果是不可预测的。 从性能方面看，该方法类同于for-each遍历（即方法二）的性能。 方法四: 通过键找值遍历（效率低） 作为方法一的替代，这个代码看上去更加干净；但实际上它相当慢且无效率。因为从键取值是耗时的操作（与方法一相比，在不同的Map实现中该方法慢了20%~200%）。如果你安装了FindBugs，它会做出检查并警告你关于哪些是低效率的遍历。所以尽量避免使用。123456789Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Integer key : map.keySet()) &#123; Integer value = map.get(key); System.out.println(\"Key = \" + key + \", Value = \" + value); &#125; 总结如果仅需要键(keys)或值(values)使用方法二。如果你使用的语言版本低于java 5，或是打算在遍历时删除entries，必须使用方法三。否则使用方法一(键值都要)。 转自：http://blog.csdn.net/tjcyjd/article/details/11111401","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Java基础","slug":"backend/Java/Java基础","date":"2017-09-21T15:47:12.000Z","updated":"2018-08-01T12:08:45.259Z","comments":true,"path":"2017/09/21/backend/Java/Java基础/","link":"","permalink":"http://www.songshuiyang.site/2017/09/21/backend/Java/Java基础/","excerpt":"","text":"全局变量和static修饰的局部变量 默认初始化为 0 。因为全局变量和static静态局部变量存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 0x00。 Java中的switch-case语句 switch接受的参数类型有10种，分别是基本类型的byte,short,int,char，以及引用类型的String(只有JavaSE 7 和以后的版本 可以接受String类型参数),enum和byte,short,int,char的封装类Byte,Short,Integer,Charactercase 后紧跟常量表达式，不能是变量。 Maps.newHashMap(); Map result = new HashMap(); 上面这种是java原生API写法 下面这种是google的guava.jar提供的写法，目的是为了简化代码。唯一的区别就是简化代码 Map result = Maps.newHashMap(); 泛型 仅仅是java的一颗语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。 重载的概念 方法名称相同，参数个数、次序、类型不同 因此重载对返回值没有要求，可以相同，也可以不同 但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"常见的编码方式","slug":"backend/相关技术/常见的编码方式","date":"2017-09-21T12:54:12.000Z","updated":"2018-02-26T12:31:59.816Z","comments":true,"path":"2017/09/21/backend/相关技术/常见的编码方式/","link":"","permalink":"http://www.songshuiyang.site/2017/09/21/backend/相关技术/常见的编码方式/","excerpt":"计算机为什么要编码在计算机中所有的数据都是以0,1来存储的,那字符是怎样在计算机存储的呢,美国的科学家把一个特定的数字对应一个特定的字母进行存储和传输，比如我需要存储字母a，那么我存入一个数字97(即在计算机中存入二进制(01100001)，这个过程叫做编码(encode)，而我们在读取数据的时候，当遇到97时，我们就让计算机显示字母a，这个过程叫做解码(decode)。 编码发展历史简介","text":"计算机为什么要编码在计算机中所有的数据都是以0,1来存储的,那字符是怎样在计算机存储的呢,美国的科学家把一个特定的数字对应一个特定的字母进行存储和传输，比如我需要存储字母a，那么我存入一个数字97(即在计算机中存入二进制(01100001)，这个过程叫做编码(encode)，而我们在读取数据的时候，当遇到97时，我们就让计算机显示字母a，这个过程叫做解码(decode)。 编码发展历史简介 第一阶段ASCII规则: 所有的控制字符(比如CR回车、DEL删除等)编码在0-31范围以及127中。 把所有的标点符号，英文大小写全部放在32-126范围中。 防止以后出现需要补充的情况，把128-255位这么多位置留出来，应该足够用了吧！所以设置一个字节8位二进制，把这个标准叫American Standard Code for Information Interchange(美国标准信息交换代码，简写为ASCII)，标准制定结束。 实现方式: 第一位始终未0，后面7位表示0-127的范围，一个数字对应一个字母或者标点符号，亦或者控制符号，即所有的ASCII码的统一形式为0xxxx xxxx。 第二阶段 GB2312,GBK, BIG5 Latin1, ISO-8859-1, JIS, ANSI… 计算机技术到了欧洲，欧洲人发现怎么我们的那么多符号没有编进去啊！所以欧洲”砖家”坐到了一起，开始讨论。发现既然美国人把第一位流出来了，那么我们就用128-255的位置好了。 规则: 128-159之间为控制字符，160-255位文字符号，其中包括了西欧语言、希腊语、泰语、阿拉伯语、希伯来语。 刚好把美国人给的空间全部用完，世界真美好，谢谢美利坚预留的每一个位置。 砖家们决定把他们的编码名称叫做Latin1，后面由于欧洲统一制定ISO标准，所以又有了一个ISO的名称，即ISO-8859-1。 实现方式: 0-127的所有位置不动，那么可以兼容ASCII，二进制位0xxx xxxx 128-255位置全部用完，二进制位1xxx xxxx由于所有的位置全部用完，而欧元符号实在指定标准之后才出现的，所以在这个码表中连欧洲人自己的货币符号都没有办法放进去。 计算机技术当然也传到了亚洲大地，比如中国。中国砖家们坐在一起发现，美国人搞的这个东西真的有问题，预留才128-255的空间，可是我们的汉字个数远远超出了这个数目啊，怎么办？？后面聪明的中国砖家们发现，只能使用2个字节了，否则真的搞不定。由于必须和美国原来制定的ASCII不冲突，所以指定了如下规则 规则: 如果一个字节中第一位为0，那么这就是一个ASCII字符。 如果一个字节中第一位为1，那么这个是汉字，认定需要2个字节才表示一个编码的文字。把这个码表叫GB2312这个码表中包含汉字6763个和非汉字图形字符682个。还有很多的空间没有用到，索性全部预留了吧。 实现方式: 0xxxxxxx：表示为ASCII字符 -1xxxxxxx 1xxxxxxx：表示为汉字 后面再次添加更多的字符进去，再次命名为GB18030，兼容GBK。由于汉字很多，2个字节并不能完全包括进去，所以GB18030采用2\\4位混编的形式。 当然计算机也传到了日本(JIS)、韩国、台湾(BIG5)等等地方，大家全部发挥自己的聪明才智，各自实现了自己的编码。这些编码都与ASCII兼容，但是相互之间不兼容。 使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码，又称为”MBCS（Muilti-Bytes Charecter Set，多字节字符集）”。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码，所以在中文 windows下要转码成gb2312,gbk只需要把文本保存为ANSI编码即可。 不同ANSI编码之间互不兼容 第三阶段 随着通讯越来越多，而老美发现在自己公司需要国际化的时候，自己原来埋的这个雷真的害了自己。于是乎，开始研讨把世界上几乎所有文字全部放在一个码表中，而这个包罗万象的码表就叫做Unicode，即万国码。Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。Unicode用数字0-0x10FFFF来映射这些字符，最多可以容纳1114112个字符，或者说有1114112个码位。码位就是可以分配给字符的数字。实际上，在软件制造商的协会（unicode.org）在做这个工作时，国际标准化组织（ISO）在做同样的事情，最后大家都意识到世界上并不需要两个不同的万国码，于是大家坐在一起合并研究的成果，最后的结果就是现在的Unicode。 各个编码及其范围ASCII编码范围00-7F，其中00-1F、FF为控制字符。其它为英文字母、数字、标点符号。 Latin1编码范围00-FF，其中00-7F同ASCII，80-9F为控制符、9F-FF为字母和标点符号. CP1252微软的企业标准，补充了一些符号和欧元符号，为Latin1的超集。 GB2312编码范围为A1A1-F7FE(剔除xx7F)，共23940个码位。其中很多区间没有用到，而汉字使用的区间为B0A1-F7FE，其他为标点符号和特殊字符。除常用简体汉字字符外还包括希腊字母、日文平假名及片假名字母、俄语西里尔字母等字符，未收录繁体中文汉字和一些生僻字。对汉字进行了分区管理，其中第一个字节为区位码，包括下面区位。01-09区为特殊符号。16-55区为一级汉字，按拼音排序。56-87区为二级汉字，按部首/笔画排序。10-15区及88-94区则未有编码。第二个字节为位字节，01-94总计94个。为什么实际选择不是01-5E，而是选择A1-F7的位置呢？因为英文可见字符区间为20-7F，加上128(也就是最高位为1)后得到的取件即是A1-FE区位码使用了0xA1-0xF7(把01-87区的区号加上0xA0)，位字节使用了0xA1-0xFE(把01-94加上 0xA0) GBK编码范围为8140-FEFE,兼容GB2312，仍然有部分区间没有用到。GBK也支持希腊字母、日文假名字母、俄语字母等字符，但不支持韩语中的表音字符（非汉字字符）。GBK还收录了GB2312不包含的 汉字部首符号、竖排标点符号等字符。GBK对GB2312就是，你有的，我也有，你没得的，我还有！ CP936CP936是微软指定的标准，属于企业标准，和GBK的有些许差别，绝大多数情况下可以把CP936当作GBK的别名。 BIG5Big5是双字节编码，高字节编码范围是0x81-0xFE，低字节编码范围是0x40-0x7E和0xA1-0xFE。和GBK相比，少了低字节是0x80-0xA0的组合。0x8140-0xA0FE是保留区域，用于用户造字区。Big5收录的汉字只包括繁体汉字，不包括简体汉字，一些生僻的汉字也没有收录。 CP950微软的企业标准，可以理解为是对 Big5的扩展。 GB18030编码范围同GBK，补充了更多的字符，由于Unicode开始流行且GB18030补充的字符都比较生僻，所以实际使用上基本是GBK。GB18030编码是变长编码，有单字节、双字节和四字节三种方式。GB18030的单字节编码范围是0x00-0x7F，完全等同与ASCII；双字节编码的范围和GBK相同，高字节是0x81-0xFE，低字节的编 码范围是0x40-0x7E和0x80-FE；四字节编码中第一、三字节的编码范围是0x81-0xFE，二、四字节是0x30-0x39。 Unicode中文的编码范围为4E00-9FCF，其中9FC4-9FCF之间的区间没有使用。一个蛋疼的问题就是这个区间全部都是文字，中文标点没有包含在其中，中文标点散落在各个位置。详细请看http://blog.chinaunix.net/uid-12348673-id-3335307.html。一些特殊的文字和中文部首以及一些特殊符号也不在此范围内，详细情况可以参考网址：http://www.cnblogs.com/sosoft/p/3456631.html Unicode的实现方式 Unicode只是进行了编码，也就是说只是一个码表，至于具体怎么实现，并没有规定。下面是Unicode的几种实现方法。 Unicode UTF-8之间的关系简单来说：Unicode 是「字符集」 UTF-8 是「编码规则」 其中： 字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point） 编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程） Unicode定义了所有可以用来表示字符的数值集合（称之为Code Point）。UTF-8和UTF-16等UTF标准定义了这些数值和字符的映射关系。 正如名字所示，在UTF－8中，字符是以8位序列来编码的，用一个或几个字节来表示一个字符。这种方式的最大好处，是UTF－8保留了ASCII字符的编码做为它的一部分，例如，在UTF－8和ASCII中，“A”的编码都是0x41.UTF－16和UTF－32分别是Unicode的16位和32位编码方式。考虑到最初的目的，通常说的Unicode就是指UTF-16。 UTF-8 (UCS Transfer Format:Unicode转做某种格式)UTF-8以字节为单位对Unicode进行编码。 从Unicode到UTF-8的编码方式如下： Unicode编码(16进制) ║ UTF-8 字节流(二进制) 000000 - 00007F ║ 0xxxxxxx 000080 - 0007FF ║ 110xxxxx 10xxxxxx 000800 - 00FFFF ║ 1110xxxx 10xxxxxx 10xxxxxx 010000 - 10FFFF ║ 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 特点:UTF-8的特点是对不同范围的字符使用不同长度的编码 UTF-16在Unicode基本多文种平面定义的字符（无论是拉丁字母、汉字或其他文字或符号），一律使用2字节储存。而在辅助平面定义的字符，会以代理对（surrogate pair）的形式，以两个2字节的值来储存。UTF-16比起UTF-8，好处在于大部分字符都以固定长度的字节 (2字节) 储存，但UTF-16却无法兼容于ASCII编码。可以认为UTF-16是下面介绍的UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的是同一的意思。但当引入辅助平面字符后，就称为UTF-16了。现在若有软件声称自己支援UCS-2编码，那其实是暗指它不能支援在UTF-16中超过2bytes的字集。对于小于0x10000的UCS码，UTF-16编码就等于UCS码。如果一个UTF-16文件没有指定BOM，默认应该是UTF-16BE，但是在Intel x86中却是UTF-16LE。所以在现实世界中有很多的没有指定大小尾的UTF-16却是UTF-16LE。 UTF-32每一个Unicode码位使用恰好32位元。可以粗暴的认为UTF-32和下面要介绍的UCS-4是等同的。 UCS-2采用2个字节，定长的表示每一个字符，所以总计可以表示2^16个字符。 UCS-4UCS-4根据最高位为0的最高字节分成2^7=128个group。每个group再根据次高字节分为256个plane。每个plane根据第3个字节分为256行(rows)，每行包含256个cells。当然同一行的cells只是最后一个字节不同，其余都相同。group 0的plane 0被称作Basic Multilingual Plane, 即BMP。或者说UCS-4中，高两个字节为0的码位被称作BMP。将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS-4规范中还没有任何字符被分配在BMP之外。 转自:http://www.cnblogs.com/jessonluo/p/4800331.html 编码检测到底采用什么编码，如果能检测就好了。专家们也是这么想的，所以专家给每种格式和字节序规定了一些特殊的编码， 这些编码在unicode 中是没有使用的，所以不用担心会冲突。 这个叫做BOM（Byte Order Mark）头。意思是字节序标志头。通过它基本能确定编码格式和字节序。 UTF编码 ║ Byte Order Mark UTF-8 ║ EF BB BF UTF-16LE ║ FF FE UTF-16BE ║ FE FF UTF-32LE ║ FF FE 00 00 UTF-32BE ║ 00 00 FE FF所以通过检测文件前面的BOM头，基本能确定编码格式和字节序。但是这个BOM头只是建议添加，不是强制的，所以不少软件和系统没有添加这个BOM头（所以有些软件格式中有带BOM头 和NoBOM头的选择），这个时候要检测什么格式，就比较麻烦了当然可以检测，但是不能保证100%准确，只能通过编码范围从概率上来检查，虽然准确度还是比较高，但是不能保证 100%。所以，时常看到检测错误的软件，也不奇怪了。 UTF-8 与UTF-16的区别 UTF-16比较好理解,就是任何字符对应的数字都用两个字节来保存.我们通常对Unicode的误解就是把Unicode与UTF-16等同了.但是很显然如果都是英文字母这做有点浪费.明明用一个字节能表示一个字符为啥整两个啊. 于是又有个UTF-8,这里的8非常容易误导人,8不是指一个字节,难道一个字节表示一个字符?实际上不是.当用UTF-8时表示一个字符是可变的,有可能是用一个字节表示一个字符,也可能是两个,三个.当然最多不能超过3个字节了.反正是根据字符对应的数字大小来确定. 于是UTF-8和UTF-16的优劣很容易就看出来了.如果全部英文或英文与其他文字混合,但英文占绝大部分,用UTF-8就比UTF-16节省了很多空间.而如果全部是中文这样类似的字符或者混合字符中中文占绝大多数.UTF-16就占优势了,可以节省很多空间.另外还有个容错问题,等会再讲","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.songshuiyang.site/tags/Java/"}]},{"title":"Struts2 问题总结","slug":"backend/Struts2/Struts2 问题总结","date":"2017-09-19T08:12:44.000Z","updated":"2018-02-26T12:31:59.545Z","comments":true,"path":"2017/09/19/backend/Struts2/Struts2 问题总结/","link":"","permalink":"http://www.songshuiyang.site/2017/09/19/backend/Struts2/Struts2 问题总结/","excerpt":"","text":"上传图片出现错误但是，明明上传的文件格式是正确，还是出现： Content-Type not allowed: file &quot;09poC_wallpapers.jpg&quot; &quot;upload_1ea6fe4e_13611ac7d7c__8000_00000012.tmp&quot; image/pjpeg firefox 和 ie 的文件类型区别 Firefox： image/jpeg, image/bmp, image/gif, image/png ie 6： image/pjpeg ,image/bmp, image/gif, image/x-png ie 7： image/pjpeg, image/bmp, image/gif, image/x-png ie 8： image/pjpeg, image/bmp, image/gif, image/x-png Ie 9： image/jpeg, image/bmp, image/gif, image/png 解决方法 &lt;param name=&quot;allowedTypes&quot;&gt; image/bmp,image/png,image/gif,image/jpeg,image/jpg, image/pjpeg ,image/bmp, image/gif, image/x-png, &lt;/param&gt;","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"struts2","slug":"struts2","permalink":"http://www.songshuiyang.site/tags/struts2/"}]},{"title":"Struts2 的简单实例","slug":"backend/Struts2/Struts2 的简单实例","date":"2017-09-16T13:30:44.000Z","updated":"2018-02-26T12:31:59.540Z","comments":true,"path":"2017/09/16/backend/Struts2/Struts2 的简单实例/","link":"","permalink":"http://www.songshuiyang.site/2017/09/16/backend/Struts2/Struts2 的简单实例/","excerpt":"","text":"Struts2 实现流程 浏览器发送请求 到达 StrutsPrepareAndExecuteFilter ( 核心控制器 ) 分发到指定 XXXAction ( 业务控制器 ) 调用业务方法 返回逻辑视图名 StrutsPrepareAndExecuteFilter forward到物理视图,生成响应内容，输出响应","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"struts2","slug":"struts2","permalink":"http://www.songshuiyang.site/tags/struts2/"}]},{"title":"web.xml中配置JSP属性","slug":"backend/JspServlet/web.xml中配置JSP属性","date":"2017-09-15T08:19:45.000Z","updated":"2018-02-26T12:31:59.304Z","comments":true,"path":"2017/09/15/backend/JspServlet/web.xml中配置JSP属性/","link":"","permalink":"http://www.songshuiyang.site/2017/09/15/backend/JspServlet/web.xml中配置JSP属性/","excerpt":"","text":"web.xml中配置JSP属性 为什么要在web.xml配置JSP属性 如果许多JSP有着相似的属性，那么在每个JSP文件的顶部重复添加page指令是非常麻烦的工作。幸运的是，在部署描述符中可以配置通用的JSP属性。 web.xml中添加JSP属性样例 &lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspf&lt;/url-pattern&gt; &lt;page-encoding&gt;UTF-8&lt;/page-encoding&gt; &lt;scripting-invalid&gt;false&lt;/scripting-invalid&gt; &lt;include-prelude&gt;/WEB-INF/jsp/base.jspf&lt;/include-prelude&gt; &lt;trim-directive-whitespaces&gt;true&lt;/trim-directive-whitespaces&gt; &lt;default-content-type&gt;text/html&lt;/default-content-type&gt; &lt;/jsp-property-group&gt; &lt;/jsp-config&gt; 中可以包含任意数目的标签。通过为定义不同的标签来区分不同的属性组。 标签，将告诉容器在所有属于改该属性组的JSP的头部添加文件/WEB-INF/jsp/base.jspf。 标签定义了包含在组中所有JSP尾部的文件。 在一个JSP组中可以同时使用这些标签多次。 与page指令的pageEncoding特性一致。 标签可以定义内容类型，默认为text/html 也是一个特别有用的属性，该属性告诉JSP转换器删除响应输出中的空白，只保留指令、声明、脚本和其他JSP标签创建的文本。 标签可以实现完全禁止JSP中的Java 的作用类似，不过它对应的是page指令中的isELIgnored特性。除了，中所有标签都是可选的，但在使用它们时必须按照下面的顺序添加到中(忽略掉部希望使用的标签)：、、、、、、、、、、、。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"},{"name":"jsp","slug":"jsp","permalink":"http://www.songshuiyang.site/tags/jsp/"}]},{"title":"Servlet","slug":"backend/JspServlet/Servlet","date":"2017-09-14T15:36:44.000Z","updated":"2018-02-26T12:31:59.263Z","comments":true,"path":"2017/09/14/backend/JspServlet/Servlet/","link":"","permalink":"http://www.songshuiyang.site/2017/09/14/backend/JspServlet/Servlet/","excerpt":"Servlet服务器端小程序,运行在服务器端的程序，用于处理及响应客户端的请求,自MVC规范出现之后,Servlet仅仅只作为控制器 Servlet和Jsp的区别 Servlet中没有内置对象,原来JSP中的内置对象都必须有程序显式创建 Servlet对于HTML标签只能使用页面输出流逐行输出，所以自MVC规范出现之后,Servlet仅仅只作为控制器","text":"Servlet服务器端小程序,运行在服务器端的程序，用于处理及响应客户端的请求,自MVC规范出现之后,Servlet仅仅只作为控制器 Servlet和Jsp的区别 Servlet中没有内置对象,原来JSP中的内置对象都必须有程序显式创建 Servlet对于HTML标签只能使用页面输出流逐行输出，所以自MVC规范出现之后,Servlet仅仅只作为控制器 @WebServlet从3.0开始配置Servlet可以使用注解的形式 有些人可能会遇到这种种情况，在采用注解WebServlet配置Servlet的时候，明明在配置了urlPatterns属性，部署应用程序的时候也没有出错。但是就是在浏览器发请求的时候访问不到资源，报404错误request resource is not available。捣腾了半天也不知道，到底是哪而出错了？ Servlet3.0之后新增了注解，用于简化Servlet、Filter及Listener的声明，这样就在配置Servlet的时候多了一个选择。Servlet3.0的部署描述文件web.xml的顶层标签有一个metadata-complete属性，该属性为true，则容器在部署时只依赖部署描述文件，忽略所有标注，如果不配置该属性，或者将其设置为false，则表示启动标注支持。当metadata-complete=”false”时，web.xml和注解对于Servlet的影响同时起作用，两种方法定义的url-partten都可以访问到该Servlet，但是当通过web.xml定义的url-partten访问时，注解定义的属性（初始化参数等）将失效。 属性值name String 指定Servlet 的 name 属性，等价于 。如果没有显式指定，则该 Servlet 的取值即为类的全限定名。 value String[] 该属性等价于 urlPatterns 属性。两个属性不能同时使用。 urlPatterns String[] 指定一组 Servlet 的 URL 匹配模式。等价于标签。 loadOnStartup int 指定 Servlet 的加载顺序，等价于 标签。 initParams WebInitParam[] 指定一组 Servlet 初始化参数，等价于标签。 asyncSupported boolean 声明 Servlet 是否支持异步操作模式，等价于 标签。 description String 该 Servlet 的描述信息，等价于 标签。 displayName String 该 Servlet 的显示名，通常配合工具使用，等价于 标签。 创建Servlet有俩个时机 用户请求某个Servlet，系统创建该Servlet的实例,所以Servlet第一次访问的时间是较长的，因为要初始化Servlet Web应用启动立即创建Servlet实例,即load-on-startup Servlet Servlet 生命周期 创建实例 Web容器调用Servlet的init方法，对Servlet进行初始化。 初始化后将一直存在于容器中，用于响应客户端请求,get post service用于响应用户请求 通常在Web应用关闭之时销毁Servlet，先调用Servlet的destory()方法 使用Servlet作为表现层如有以下几个劣势 所有的Html标签都需要页面输出流完成 前端人员无法参与到页面的编写 可维护性差，页面代码不好调试","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"JSP脚本中的九个内置对象","slug":"backend/JspServlet/JSP脚本中的九个内置对象","date":"2017-09-14T07:25:44.000Z","updated":"2018-02-26T12:31:59.241Z","comments":true,"path":"2017/09/14/backend/JspServlet/JSP脚本中的九个内置对象/","link":"","permalink":"http://www.songshuiyang.site/2017/09/14/backend/JspServlet/JSP脚本中的九个内置对象/","excerpt":"JSP脚本中包含九个内置对象，这九个内置对象都是Servlet API接口的实例，只是JSP规范对它们进行了默认初始化（由JSP页面对应的Servlet的_jspService()方法来创建这些实例),也就是说它们已经是对象，可以直接使用 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable","text":"JSP脚本中包含九个内置对象，这九个内置对象都是Servlet API接口的实例，只是JSP规范对它们进行了默认初始化（由JSP页面对应的Servlet的_jspService()方法来创建这些实例),也就是说它们已经是对象，可以直接使用 1 pageContext javax.servlet.jsp.PageContext 2 request javax.servlet.http.HttpServletRequest 3 response javax.servlet.http.HttpServletResponse 4 session javax.servlet.http.HttpSession 5 application javax.servlet.ServletContext 6 config javax.servlet.ServletConfig 7 out javax.servlet.jsp.JspWriter 8 page java.lang.Object 9 exception java.lang.Throwable page对象page对象表示当前一个JSP页面，可以理解为一个对象本身，即：把一个JSP当作一个对象来看待。page对象在开发中几乎不用，了解一下即可 out对象out对象代表一个页面输出流，通常用于在页面上输出变量值及常量。一般在使用输出表达式的地方都可以使用out对象达到同样的效果。out是个页面输出流，负责输出页面的内容，但是用out需要编写更多的代码。&lt;%= %&gt;表达式的本质就是out.write(…);对于页面上的某个html标签来讲 如果使用了out即 &lt;% out.println(“&lt;table&gt;”); out.println(“&lt;tr&gt;”); out.println(“&lt;/tr&gt;”); out.println(“&lt;/table&gt;”); %&gt; pageContext对象pageContext对象是JSP技术中最重要的一个对象，它代表JSP页面的运行环境，这个对象不仅封装了对其它8大隐式对象的引用，它自身还是一个域对象(容器)，可以用来保存数据。并且，这个对象还封装了web开发中经常涉及到的一些常用操作，例如引入和跳转其它资源、检索其它域对象中的属性等。 getException方法 返回exception隐式对象 getPage方法 返回page隐式对象 getRequest方法 返回request隐式对象 getResponse方法 返回response隐式对象 getServletConfig方法 返回config隐式对象 getServletContext方法返回application隐式对象 getSession方法 返回session隐式对象 getOut方法 返回out隐式对象 pageContext 封装其它8大内置对象的意义 如果在编程过程中，把pageContext对象传递给一个普通java对象，那么这个java对象将可以获取8大隐式对象，此时这个java对象就可以和浏览器交互了，此时这个java对象就成为了一个动态web资源了，这就是pageContext封装其它8大内置对象的意义，把pageContext传递给谁，谁就能成为一个动态web资源，那么什么情况下需要把pageContext传递给另外一个java类呢，什么情况下需要使用这种技术呢，在比较正规的开发中，jsp页面是不允许出现java代码的，如果jsp页面出现了java代码，那么就应该想办法把java代码移除掉，我们可以开发一个自定义标签来移除jsp页面上的java代码，首先围绕自定义标签写一个java类，jsp引擎在执行自定义标签的时候就会调用围绕自定义标签写的那个java类，在调用java类的时候就会把pageContext对象传递给这个java类，由于pageContext对象封装了对其它8大隐式对象的引用，因此在这个java类中就可以使用jsp页面中的8大隐式对象(request，response，config，application，exception，Session，page，out)了，pageContext对象在jsp自定义标签开发中特别重要。 pageContext 作为域对象 pageContext对象可以作为容器来使用，因此可以将一些数据存储在pageContext对象中。 pageContext对象的常用方法 1 public void setAttribute(java.lang.String name,java.lang.Object value) 2 public java.lang.Object getAttribute(java.lang.String name) 3 public void removeAttribute(java.lang.String name) 4 public java.lang.Object findAttribute(java.lang.String name) application 对象 在整个Web应用的多个JSP、Servlet之间的共享数据。通常被定义为数据字典来使用。通常在一处实现application.setAttribute(“name”,value);来定义一个变量，在JSP中使用application.getAttribute(“name”);获取值；在Servlet中使用一个实例的ServletContext对象sc.getAttribute(“name”);获取值。我们可以把application理解成一个Map对象，任何JSP、Servlet都可以把某个变量放入application中保存，并指出一个属性名；而该应用的其他JSP、Servlet就可以根据该属性名来得到这个变量。由于application对象代表整个Web应用，所以只应该把Web应用的状态数据放入到application中。 访问Web应用的配置参数，在web.xml中配置类似的参数，该标签是下的子标签。即 &lt;context-param&gt; &lt;param-name&gt;name&lt;/param-name&gt; &lt;param-value&gt;value&lt;/param-value&gt; &lt;/context-param&gt; 在JSP中可以通过 application.getInitParameter(“name”);取得配置的参数，在Servlet中可以先实例个ServletContext对象即： final javax.servlet.ServletContext application;然后就可以取值了，即： application = pageContext.getServletContext(); application.getInitParameter(&quot;name&quot;); 这里通常被用作普通java Web开发中数据库用户名，密码的获取时使用，因为在项目开发用的密码不一定和部署在服务器上的密码一致，但是把它写到这里便于修改这些有关项目的参数。 config 对象config对象代表当前的JSP配置信息，但JSP页面通常无需配置，因此也就不存在配置信息，该对象在JSP页面用的比较少，但在Servlet中用处则相对较大，因为Servlet需要在web.xml文件中进行配置，可以指定配置参数。但是如果说要为某个JSP配置一些参数的话，也是跟配置Servlet一样需要在web.xml中配置，也就说吧JSP当成Servlet配置 &lt;servlet&gt; &lt;servlet-name&gt;Configure&lt;/servlet-name&gt; &lt;jsp-file&gt;/getcontextparam.jsp&lt;/jsp-file&gt; &lt;init-param&gt; &lt;param-name&gt;conn&lt;/param-name&gt; &lt;param-value&gt;connnn&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Configure&lt;/servlet-name&gt; &lt;url-pattern&gt;/configure&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 其中这里“/getcontextparam.jsp”是表明把某个JSP配置成Servlet。在地址栏中访问时要输入http://localhost:8080/test/configure（url-pattern中内容）在JSP中获取参数时使用config.getInitParameter(“conn”)即可。 exception 对象该实例代表其他页面的异常和错误,只有当页面是错误处理页面，即编译指令page的isErrorPage属性为true时,该对象才可以使用","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"},{"name":"jsp","slug":"jsp","permalink":"http://www.songshuiyang.site/tags/jsp/"}]},{"title":"Spring mvc整合velocity","slug":"backend/velocity/Spring mvc整合velocity","date":"2017-09-11T08:12:12.000Z","updated":"2018-02-26T12:31:59.608Z","comments":true,"path":"2017/09/11/backend/velocity/Spring mvc整合velocity/","link":"","permalink":"http://www.songshuiyang.site/2017/09/11/backend/velocity/Spring mvc整合velocity/","excerpt":"添加Maven依赖:&lt;!--springmvc集成 velocity--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt;","text":"添加Maven依赖:&lt;!--springmvc集成 velocity--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; applicationContext-mvc配置文件:&lt;!--》》》》》》》》》》》》》》》 添加velocity显示技术 》》》》》》》》》》》》》》》》》--&gt; &lt;!-- velocity环境配置 --&gt; &lt;bean id=&quot;velocityConfig&quot; class=&quot;org.springframework.web.servlet.view.velocity.VelocityConfigurer&quot;&gt; &lt;!-- velocity配置文件路径 或者直接用velocityProperties属性 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:velocity.properties&quot;/&gt; &lt;!-- velocity模板路径 --&gt; &lt;property name=&quot;resourceLoaderPath&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;/bean&gt; &lt;!-- velocity视图解析器 --&gt; &lt;bean id=&quot;velocityViewResolver&quot; class=&quot;org.springframework.web.servlet.view.velocity.VelocityLayoutViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;0&quot;/&gt; &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot;/&gt; &lt;property name=&quot;cache&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.vm&quot;/&gt; &lt;property name=&quot;layoutUrl&quot; value=&quot;layout/layout.vm&quot;/&gt; &lt;property name=&quot;exposeSpringMacroHelpers&quot; value=&quot;true&quot; /&gt;&lt;!--是否使用spring对宏定义的支持--&gt; &lt;property name=&quot;exposeSessionAttributes&quot; value=&quot;true&quot; /&gt;&lt;!--是否开放request属性--&gt; &lt;property name=&quot;requestContextAttribute&quot; value=&quot;request&quot;/&gt;&lt;!--request属性引用名称--&gt; &lt;property name=&quot;dateToolAttribute&quot; value=&quot;dateTool&quot;/&gt; &lt;property name=&quot;numberToolAttribute&quot; value=&quot;numberTool&quot;/&gt; &lt;/bean&gt; velocity.properties 配置文件该文件velocity.properties 在下面的包路径可以找到 org.apache.velocity.runtime.defaults.velocity.properties #设置字符集 #encoding input.encoding =UTF-8 output.encoding=UTF-8 contentType=text/html;charset=UTF-8 #autoreload when vm changed file.resource.loader.cache=false file.resource.loader.modificationCheckInterval =1 velocimacro.library.autoreload=false 显示文件目录结构 header.mv&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-store&quot;/&gt; &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;/&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;3600&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot; name=&quot;viewport&quot;&gt; layout.mv&lt;html&gt; &lt;head&gt; &lt;title&gt;$!page_title&lt;/title&gt; #parse(&quot;default/header.vm&quot;) &lt;/head&gt; &lt;body&gt; &lt;div&gt; $screen_content &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; velocity.mv&lt;html&gt; &lt;head&gt; &lt;title&gt;Spring MVC and Velocity&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Spring MVC and Velocity&lt;/h1&gt; Hello ${hello} &lt;hr /&gt; Copyright &amp;copy 2014 lm &lt;/body&gt; &lt;/html&gt; velocity 基本语法Velocity的基本语法：1、”#”用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#iinclude、#parse、#macro等；如: #if($info.imgs) #else #end 2、”$”用来标识一个对象(或理解为变量)；如如：$i、$msg、$TagUtil.options(…)等。 3、”{}”用来明确标识Velocity变量；比如在页面中，页面中有一个$someonename，此时，Velocity将把someonename作为变量名，若我们程序是想在someone这 个变量的后面紧接着显示name字符，则上面的标签应该改成${someone}name。 4、”!”用来强制把不存在的变量显示为空白。如当页面中包含$msg，如果msg对象有值，将显示msg的值，如果不存在msg对象同，则在页面中将显示$msg字符。这是我们不希望的，为了把不存 在的变量或变量值为null的对象显示为空白，则只需要在变量名前加一个“!”号即可。如：$!msg 5、循#foreach( $info in $list) $info.someList #end，环读取集合list中的对象 #foreach( $info in $hotL包含文件#inclue(“模板文件名”)或#parse(“模板文件名”)st1)$!info.title #end上面的脚本表示循环遍历hotList1集合中的对象，并输出对象的相关内容。 6、包含文件#inclue(“模板文件名”)或#parse(“模板文件名”)主要用于处理具有相同内容的页面，比如每个网站的顶部或尾部内容。使用方法，可以参考EasyJF开源Blog及EasyJF开源论坛中的应用！如：#parse(“/blog/top.html”)或#include(“/blog/top.html”)parse与include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示。","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.songshuiyang.site/tags/Spring/"},{"name":"velocity","slug":"velocity","permalink":"http://www.songshuiyang.site/tags/velocity/"},{"name":"Spring Mvc","slug":"Spring-Mvc","permalink":"http://www.songshuiyang.site/tags/Spring-Mvc/"}]},{"title":"常用的JavaEE服务器","slug":"backend/JavaEE服务器/常用的JavaEE服务器","date":"2017-09-10T15:30:44.000Z","updated":"2018-02-26T12:31:59.228Z","comments":true,"path":"2017/09/10/backend/JavaEE服务器/常用的JavaEE服务器/","link":"","permalink":"http://www.songshuiyang.site/2017/09/10/backend/JavaEE服务器/常用的JavaEE服务器/","excerpt":"","text":"Web服务器1：Tomcat与Java结合的最好、开源、Oracle官方推荐的JSP服务器 2：Jetty嵌入式服务器：在应用中加入Jetty的Jar文件,即可提供Web服务，最好搭配Maven使用，采用maven jetty插件，即可通过简单的配置，执行命令即可启动web服务 3：Resin目前最快的Jsp，Servlet运行平台，支持EJB,个人免费，商业交钱 Java EE服务器1：JBoss开源，全面支持各种最新的Java EE规范 2：GlassFishOracle官方提供的JavaEE服务器 3：WebLogic收费所以牛逼 4：WebSphereIBM收费也是牛逼,WebSphere 是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的软件。","categories":[{"name":"服务器","slug":"服务器","permalink":"http://www.songshuiyang.site/categories/服务器/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"},{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/tags/server/"}]},{"title":"新建博客方法","slug":"essay/新建博客方法","date":"2017-09-09T17:07:12.000Z","updated":"2017-09-09T17:08:23.340Z","comments":true,"path":"2017/09/10/essay/新建博客方法/","link":"","permalink":"http://www.songshuiyang.site/2017/09/10/essay/新建博客方法/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"随笔","slug":"随笔","permalink":"http://www.songshuiyang.site/categories/随笔/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.songshuiyang.site/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.songshuiyang.site/tags/github/"}]},{"title":"Java学习路线","slug":"backend/Java学习路线","date":"2017-09-09T17:07:12.000Z","updated":"2018-02-26T12:31:59.230Z","comments":true,"path":"2017/09/10/backend/Java学习路线/","link":"","permalink":"http://www.songshuiyang.site/2017/09/10/backend/Java学习路线/","excerpt":"JAVA学习路线图 此乃是java攻城狮的学习路线图，由简到繁，由易到难，一步步的学习 阶段1 1：学习HTML 2:学习CSS 3:Javascript 4:jquery 5:xml解析 6：Bootstrap 阶段2 7:JAVAse基础 8：mysql数据库 9：Powerdesigner 10:JDBC 11:JAVAWEB 阶段3 12:oracle 13:struts2 14:Hibernate 15:Spring 阶段4 16:Maven 17:SpringMVC 18:MyBatis","text":"JAVA学习路线图 此乃是java攻城狮的学习路线图，由简到繁，由易到难，一步步的学习 阶段1 1：学习HTML 2:学习CSS 3:Javascript 4:jquery 5:xml解析 6：Bootstrap 阶段2 7:JAVAse基础 8：mysql数据库 9：Powerdesigner 10:JDBC 11:JAVAWEB 阶段3 12:oracle 13:struts2 14:Hibernate 15:Spring 阶段4 16:Maven 17:SpringMVC 18:MyBatis logo","categories":[{"name":"server","slug":"server","permalink":"http://www.songshuiyang.site/categories/server/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.songshuiyang.site/tags/java/"}]},{"title":"前端学习技术","slug":"frontend/前端学习技术","date":"2017-09-09T17:00:12.000Z","updated":"2018-02-26T12:31:58.989Z","comments":true,"path":"2017/09/10/frontend/前端学习技术/","link":"","permalink":"http://www.songshuiyang.site/2017/09/10/frontend/前端学习技术/","excerpt":"技术架构图:","text":"技术架构图: logo","categories":[{"name":"client","slug":"client","permalink":"http://www.songshuiyang.site/categories/client/"}],"tags":[{"name":"web","slug":"web","permalink":"http://www.songshuiyang.site/tags/web/"}]},{"title":"Hexo问题总结","slug":"essay/hexo问题总结","date":"2017-09-09T07:07:12.000Z","updated":"2018-11-24T03:08:39.813Z","comments":true,"path":"2017/09/09/essay/hexo问题总结/","link":"","permalink":"http://www.songshuiyang.site/2017/09/09/essay/hexo问题总结/","excerpt":"","text":"Hexo问题总结 hexo部署后，CNAME会被自动删除，怎么办？ &nbsp;&nbsp;&nbsp;&nbsp;准确来说 CNAME 文件是放在 hexo 项目下的 source 目录，你再运行下hexo generade然后你再去 public 目录中看看就明白了BTW，为了达到更有说服力的验证，最好在开始前先运行下hexo clean这样会先删除 public 目录 HEXO发布到Github上，README.md文件正常显示的解决 &nbsp;&nbsp;&nbsp;&nbsp;使用hexo d 发布本地编译过的代码到github上的时候，发现这个README.md文件也被解析的乱七八糟的，不是一般的github项目里面的README.md文件的显示样式，查了下，在最外层的_config.yml里面把skip_render: README.md添加这个配置，就OK啦。 指定端口启动 hexo server -p 4001 如何在markdowm中添加本地图片 建议将图片统一放在 source/images 文件夹中。然后通过绝对路径![](/images/image.jpg) 引用 卸载hexo npm uninstall hexo -g hexo版本12hexo: 3.7.0hexo-cli: 1.0.3","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.songshuiyang.site/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.songshuiyang.site/tags/github/"}]},{"title":"第一篇博客","slug":"essay/第一篇博客","date":"2017-09-09T03:02:12.000Z","updated":"2017-09-09T16:55:32.211Z","comments":true,"path":"2017/09/09/essay/第一篇博客/","link":"","permalink":"http://www.songshuiyang.site/2017/09/09/essay/第一篇博客/","excerpt":"使用hexo+github搭建免费个人博客优势: 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台；","text":"使用hexo+github搭建免费个人博客优势: 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.io github: https://github.com/hexojs/hexo 原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行 hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导 hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的 使用Hexo搭建博客时，需要区分『博客源代码』和『博客生成代码』 『博客源代码』: Hexo的源码，包括themes目录（博客模板），source目录(使用MarkDown写的博客)等 『博客生成代码』： 执行hexo generate或者hexo server命令生成的代码，是Hexo自动生成的，再public目录 常用命令hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help #查看帮助 hexo version #查看Hexo的版本 ### hexo的文件结构├── _config.yml ├── db.json ├── node_modules ├── package.json ├── public ├── scaffolds ├── source #所有文章文件放在这里 └── themes #主题文件夹 _config.yml 站点的配置文件。 db.json 缓存文件 node_modules 安装的插件以及hexo所需的一些node.js模块。 package.json 应用程序信息，配置hexo运行需要的js包。 public 最终所见网页的所有内容 scaffolds 模板文件夹。当新建一个文章时，会默认包含对应模板的内容。 source 资源文件夹是存放用户资源的地方。所有的源文件都会被保存在_post文件夹中。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes 存放主题文件，hexo会根据主题来生成静态页面。 图片测试 logo","categories":[{"name":"技术","slug":"技术","permalink":"http://www.songshuiyang.site/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.songshuiyang.site/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.songshuiyang.site/tags/github/"},{"name":"nodejs","slug":"nodejs","permalink":"http://www.songshuiyang.site/tags/nodejs/"}]}]}